diff --git a/ANNOUNCE b/ANNOUNCE
index 6b86f9fa974..9f31e1a58a2 100644
--- a/ANNOUNCE
+++ b/ANNOUNCE
@@ -1,11 +1,15 @@
-The Wine development release 8.0-rc4 is now available.
+The Wine development release 8.2 is now available.
 
 What's new in this release:
-  - Bug fixes only, we are in code freeze.
+  - Better debug information in Wow64 mode.
+  - Wow64 thunks in the WPCAP library.
+  - Indeo IV50 codec support.
+  - Monitor names set from EDID data.
+  - Various bug fixes.
 
 The source is available at:
 
-  https://dl.winehq.org/wine/source/8.0/wine-8.0-rc4.tar.xz
+  https://dl.winehq.org/wine/source/8.x/wine-8.2.tar.xz
 
 Binary packages for various distributions will be available from:
 
@@ -21,113 +25,374 @@ AUTHORS in the distribution for the complete list.
 
 ----------------------------------------------------------------
 
-Bugs fixed in 8.0-rc4 (total 25):
-
- - #48553  Catia (CAD software) refuse to run installation on newest wine   (<=4.18)
- - #51268  Assembler messages: Error: no such instruction: `xsavec (%esp)'
- - #51301  Any action that locks the cursor into place inside the Roblox Client window causes the cursor to freeze
- - #51420  Running any program in Wine causes 100% cpu usage in Xorg
- - #52089  d2d1:d2d1 fails in test_draw_geometry() on Wine
- - #52152  comctl32:edit gets unexpected heights in test_text_position_style() on Windows 10 1809+
- - #52429  Guild Wars: login not possible
- - #52557  GetNetworkParams loops forever on musl
- - #52749  winetricks dotnet35sp1: printfilterpipelinesvc.exe crashes in background
- - #52932  comctl32:edit & user32:edit have test_char_from_pos() failures on Windows with the UTF-8 codepage
- - #52994  mstask:task_trigger - test_GetNextRunTime() fails in Wine on date change
- - #53382  Slow rendering when connected to external monitor
- - #53536  ntdll:rtl - The 32-bit RtlUlonglongByteSwap() breaks test_RtlDecompressBuffer() on Windows
- - #53583  FindNLSStringEx reimplementation doesn't match native
- - #53671  No objects are being rendered in any DX10/11 apps with older GPU drivers
- - #53837  HS_hevo_gc 8.6.1.2 fails to install
- - #54045  ntdll:rtl - test_RtlIpv6StringToAddress() fails on Windows 11
- - #54151  xactengine3_7:xact3 crashes when no speaker is connected
- - #54172  ddraw:ddraw1, ddraw:ddraw2, ddraw:ddraw4, ddraw:ddraw7 - test_window_position() gets the size of the wrong screen in Wine
- - #54180  Petz 4 has corrupt .pet files at startup
- - #54210  Wine fails to compile with Linux 4.11 headers (use of undefined AT_HWCAP2)
- - #54218  RTLD_SELF use breaks musl build since 8.0-rc1
- - #54263  Build of 7.22 fails with mingw-w64 10.0
- - #54264  Hyperdimension Neptunia Re;Birth1 crashes on exit in xactengine notification callback
- - #54287  wineconsole: alternate screen buffer does not work
+Bugs fixed in 8.2 (total 22):
+
+ - #48528  The Void crashes with builtin d3dx9_36 (needs D3DXFillCubeTextureTX() to return S_OK)
+ - #51345  Regression: Visual Studio 2005 "package load failure"
+ - #51545  STDOUT lost from a forked program on Cygwin/MSYS2
+ - #53747  SubLab VST3 plugin fails to register (needs Windows.System.Profile.SystemManufacturers.SmbiosInformation)
+ - #53926  New typelib marshaller depends on IID_IDispatch support from target interface
+ - #54103  opengl32:opengl - test_copy_context() crashes on w11pro64_nv
+ - #54150  d3dcompiler_43:hlsl_d3d11 & d3dcompiler_47:hlsl_d3d11 - test_trig() fails on w11pro64_nv
+ - #54234  vbscript fails to compile when colon follows Else in If...Else
+ - #54318  Rich Edit inserts newly composed text at wrong position when system IME composition ends while a selection is active
+ - #54371  loader won't launch from PATH unless named "wine"
+ - #54384  GOG Heroes of Might and Magic IV crashes on launch
+ - #54431  Switching active window (alt+tab or otherwise) away from Final Fantasy XI causes keyboard keys to remain pressed
+ - #54456  vbscript memory leak in For Each with SafeArray as group
+ - #54457  vbscript memory leaks in interp_redim_preserve
+ - #54458  vbscript memory leaks in Global_Split
+ - #54463  Wrong version value is returned from win32_operatingsystem on win10 (regression)
+ - #54465  dbghelp:dbghelp - The 64-bit test_modules() fails on Windows 7
+ - #54477  user32:msg - test_message_conversion()'s broadcast test fails on Windows 7 and 10
+ - #54486  getenv_s returns the wrong value
+ - #54489  VarAbs() does not handle BSTR arguments correctly
+ - #54490  vbscript fails to compile when statement follows ElseIf
+ - #54493  vbscript fails to compile concat when used without space and expression begins with H
 
 ----------------------------------------------------------------
 
-Changes since 8.0-rc3:
-
-Alexandre Julliard (6):
-      Update copyright info for 2023.
-      gitlab: Add a daily win10 test run.
-      kernelbase: Fix FindNLSStringEx for strings with no primary weights.
-      wow64: Initialize win32u syscall table when it is mapped.
-      winecrt0: Check for RTLD_SELF support to enable ELF constructors.
-      tools: Create a temporary directory to store temp files.
-
-Alistair Leslie-Hughes (1):
-      faudio: Purge and clear notifications on ShutDown.
-
-Conor McCarthy (1):
-      d3d11: Apply the 'KEEP' options when sending RTVs and UAVs to wined3d.
-
-Eric Pouech (7):
-      user32/tests: Retry when opening the clipboard.
-      user32/tests: Fix failing WM_PASTE tests for edit control on Win10+.
-      comctl32/tests: Retry when opening the clipboard.
-      comctl32/tests: Fix failing WM_PASTE tests for edit control on Win10+.
-      conhost: Reset console attribute upon exit in unix mode.
-      conhost: Initialize color_map when creating an alternate screen buffer.
-      po: Update French translations.
-
-Gabriel Ivăncescu (2):
-      win32u: Initialize the tracking_info for NtUserDrawScrollBar params.
-      winex11.drv: Obtain icon info for icons passed to fetch_icon_data().
-
-Gerald Pfeifer (1):
-      wrc: Avoid undefined behavior in the FreeBSD case.
-
-Hans Leidekker (7):
-      iphlpapi: Handle errors from DnsQueryConfig(DnsConfigDnsServerList).
-      wininet/tests: Pass INTERNET_FLAG_RELOAD in secure connection tests.
-      shell32/tests: Fix a test failure on Windows 11.
-      ws2_32/tests: Fix test failures on Windows 11.
-      ntdll: Conform to Windows 11 behavior in RtlIpv6StringToAddress().
-      ntdll: Fix a test failure on Windows 11.
-      ntdll/tests: Mark some test results on Windows 11 as broken.
-
-Hugh McMaster (1):
-      conhost: Migrate from FontPitchFamily to FontFamily.
+Changes since 8.1:
+
+Alex Henrie (23):
+      msi: Handle memory allocation failure in get_link_file (cppcheck).
+      setupapi: Fix memory leak on realloc failure in RetreiveFileSecurity.
+      combase: Avoid calling RtlInitUnicodeString on a static constant.
+      nsiproxy: Avoid calling RtlInitUnicodeString on a static constant.
+      winhlp32: Fix memory leak on realloc failure in HLPFILE_RtfAddBitmap (cppcheck).
+      ole32: Avoid calling RtlInitUnicodeString on a static constant.
+      httpapi: Avoid calling RtlInitUnicodeString on a static constant.
+      msi: Annotate memory allocation functions with __WINE_(DEALLOC|MALLOC).
+      http: Avoid calling RtlInitUnicodeString on a constant.
+      services: Avoid calling RtlInitUnicodeString on a static constant.
+      winebus: Avoid calling RtlInitUnicodeString on a static constant.
+      mountmgr: Avoid calling RtlInitUnicodeString on a static constant.
+      win32u: Avoid calling RtlInitUnicodeString on a static constant.
+      wineboot: Avoid calling RtlInitUnicodeString on a static constant.
+      ws2_32: Avoid calling RtlInitUnicodeString on a static constant.
+      ntdll: Use RTL_CONSTANT_STRING instead of reimplementing it.
+      ntdll: Avoid calling RtlInit(Ansi|Unicode)String on a static constant.
+      winspool: Remove unnecessary call to RtlInitUnicodeString from add_printer_driver.
+      krnl386: Avoid calling RtlInitUnicodeString on a static constant.
+      wow64: Avoid calling RtlInitUnicodeString on a static constant.
+      kernelbase: Avoid calling RtlInitUnicodeString on a static constant.
+      ntoskrnl: Avoid calling RtlInitUnicodeString on a static constant.
+      winspool: Initialize nt_ppd in add_printer_driver.
+
+Alexandre Julliard (25):
+      winedump: Print more information from the PE Load Config directory.
+      winedump: Initial support for dumping PE dynamic relocations.
+      gitlab: Force updating configure.
+      wow64: Move some exception and context functions to syscall.c.
+      wow64: Preserve the CPURESERVED flags across user callbacks.
+      wow64: Call the CPU backend to get/set the current thread context.
+      wow64: Call the thread init entry point in the CPU backend.
+      ntdll: Use the standard unixlib macro for Unix calls.
+      ntdll: Store the unixlib handle at ntdll load time.
+      ntdll: Replace the __wine_dbg_write() syscall by a Unix call.
+      ntdll: Replace the __wine_unix_spawnvp() syscall by a Unix call.
+      ntdll: Replace the wine_server_call() syscall by a Unix call.
+      ntdll: Replace the wine_server_fd_to_handle() syscall by a Unix call.
+      ntdll: Replace the wine_server_handle_to_fd() syscall by a Unix call.
+      winedump: Dump the alternate version of some data directories for hybrid PE dlls.
+      winedump: Dump the metadata of hybrid PE dlls.
+      browseui: Use standard va_list instead of __ms_va_list.
+      comdlg32: Use standard va_list instead of __ms_va_list.
+      cryptui: Use standard va_list instead of __ms_va_list.
+      dxdiagn: Use standard va_list instead of __ms_va_list.
+      oledlg: Use standard va_list instead of __ms_va_list.
+      setupapi: Use standard va_list instead of __ms_va_list.
+      wineusb.sys: Use standard va_list instead of __ms_va_list.
+      ntdll: Consistently initialize x86-64 signal handlers.
+      ntdll: Avoid a misleading indentation warning.
+
+Alistair Leslie-Hughes (5):
+      odbccp32: Append DLL path when loading driver.
+      include: Add missing SQL prototype.
+      msdasql: Use SQLDriverConnectW to connect to the ODBC driver.
+      msdasql: Always return affected rows if required.
+      msdasql: Use SQLColAttributesW to fetch statement attributes.
+
+André Zwing (1):
+      maintainers: Remove myself as maintainer of wpcap.
+
+Aurimas Fišeras (1):
+      po: Update Lithuanian translation.
+
+Brendan Shanks (9):
+      kernelbase: Implement QueryInterruptTime.
+      kernelbase: Partially implement QueryInterruptTimePrecise.
+      loader: In macOS preloader, fix an environment variable sometimes being lost.
+      ntdll/tests: Test NtMapViewOfSection with a 64-bit DLL and zero_bits > 31.
+      ntdll: Respect zero_bits/limit when mapping a PE file.
+      include: Add __ASM_LOCAL_LABEL macro.
+      ntdll: Use __ASM_LOCAL_LABEL in syscall dispatchers.
+      server: On macOS, fake debug registers when running under Rosetta.
+      ntdll: Add a WARN when setting debug registers fails under Rosetta.
+
+Connor McAdams (13):
+      include: Fully define uiautomationclient interfaces.
+      uiautomationcore: Implement UiaLookupId for AutomationIdentifierType_Event GUIDs.
+      include: Define UI Automation pattern provider interfaces.
+      uiautomationcore: Implement UiaLookupId for AutomationIdentifierType_Pattern GUIDs.
+      uiautomationcore: Add UiaRaiseStructureChangedEvent stub.
+      uiautomationcore: Add UiaRaiseAsyncContentLoadedEvent stub.
+      uiautomationcore: Add UiaRaiseTextEditTextChangedEvent stub.
+      uiautomationcore: Add UiaRaiseNotificationEvent stub.
+      uiautomationcore: Add UiaRaiseChangesEvent stub.
+      uiautomationcore: Add support for UIA_BoundingRectanglePropertyId.
+      uiautomationcore: Add support for UIA_ValueIsReadOnlyPropertyId.
+      uiautomationcore: Implement get_BoundingRectangle for MSAA providers.
+      uiautomationcore: Add support for UIA_NamePropertyId to MSAA providers.
+
+Dmitry Timoshkov (2):
+      rpcrt4: Mark the buffer as invalid in NdrProxyFreeBuffer().
+      rpcrt4: Avoid casting an object to IUnknown.
+
+Eric Pouech (40):
+      conhost: Only update font when running with a window.
+      dbghelp: Stop unwinding on potential 64bit frame for i386 cpu.
+      dbghelp: Add tests about modules loading.
+      dbghelp: Allow loading modules for different machines.
+      dbghelp: Filter on machine when searching for Wine system PE modules.
+      winedbg: Handle multi-machine process in command 'info share'.
+      winedbg: Don't expose module whose machine isn't the process' one to gdb.
+      dbghelp: Identify a 32bit multi-arch wow64 debuggee as a live target.
+      winedump: Introduce ability to pass several section names to -j option.
+      winedump: Refactor PDB DBI per-module dump in a dedicated function.
+      winedump: Make use of -j option in PDB dumping.
+      winedump: Dump some more MSF related information.
+      winedump: Load once and store global PDB string table.
+      winedump: Enhance dumping of string tables.
+      winedump: Dump some more bits out of public stream.
+      dbghelp: Fix failing test on Windows 7.
+      include: Add manifest constants for EnumProcessModulesEx.
+      psapi: Let modules test pass on non wow64 compatible platforms.
+      psapi: Add tests for EnumProcessModulesEx().
+      kernelbase: Implement EnumProcessModulesEx.
+      kernelbase: Let GetModuleBaseName succeed on 64bit modules in wow64.
+      kernelbase: Let GetModuleFileNameEx succeed on 64bit modules in wow64.
+      kernelbase: Let GetModuleInformation succeed on 64bit modules in wow64.
+      riched20/tests: Add tests when pasting in plain text mode.
+      riched20: Support SFF_SELECTION when streaming in plain text.
+      riched20/tests: Ensure clipboard has been pasted before testing the result.
+      riched20/tests: Add retry loop around OpenClipboard() to avoid access denial.
+      psapi/tests: Test directory of enumerated loaded modules.
+      dbgeng: Use EnumProcessModulesEx().
+      dbghelp: Use EnumProcessModulesEx().
+      psapi: Add more tests for EnumProcessModules().
+      kernelbase: Re-implement EnumProcessModules on top of EnumProcessModulesEx.
+      dbghelp/tests: Test return value of SymLoadModule.
+      dbghelp/tests: Add tests for 'module' name in EnumLoadedModules() callback.
+      dbghelp: Let EnumerateLoadedModules() expose image names.
+      dbghelp/tests: Add test for loaded modules enumeration.
+      dbghelp/tests: Add some more tests about module handling.
+      dbghelp: Add new module at end of the process' modules list.
+      dbghelp: Unload overlapping modules in SymLoadModule*().
+      ntdll: Implement RtlAddressInSectionTable.
+
+François Gouget (22):
+      winetest: Don't use plain strings as format specifiers.
+      winetest: Avoid an infinite loop in vstrfmtmake() when the format is NULL.
+      d3dcompiler/tests: Allow more imprecision in test_trig() for NVIDIA.
+      crypt32/tests: Fix a typo in a comment.
+      dbghelp: Fix a typo in a comment.
+      kernel32/tests: Fix a typo in a comment.
+      spoolss/tests: Fix a typo in a comment.
+      uiautomationcore: Fix a typo in a FIXME() message.
+      winegstreamer: Fix a typo in a comment.
+      winevulkan: Fix a typo in a comment.
+      winex11.drv: Fix a typo in a comment.
+      winevulkan: Add a trailing linefeed to some FIXME() thunk messages.
+      dpnet/tests: Fix the unexpected async handle traces.
+      atl100/tests: Trace GetLastError() when DeleteFile() fails.
+      riched20/tests: Check clipboard content after destroying the editor window.
+      riched20/tests: Add context to the EM_FORMATRANGE tests.
+      winetest: Trace the keyboard layout.
+      user32/tests: Fix the ToAscii(A) test on Hindi + UTF-8.
+      user32/tests: Show ToAscii(A) returns 'a' for multiple keyboard layouts.
+      ntdll/tests: Test the thread pool stack APIs.
+      ntdll: Use the thread pool stack information.
+      ws2_32: Warn that a libnss plugin may be missing if getaddrinfo() returns EBUSY.
+
+Gabriel Ivăncescu (1):
+      kernelbase: Fix grouping repeat for number formatting.
+
+Giovanni Mascellani (1):
+      wbemprox: Do not call Release() inside wbemprox_cf_CreateInstance().
+
+Hans Leidekker (14):
+      ntdll: Initialize PEB version numbers with Windows 10 values.
+      ntdll: Look at CurrentMajor/MinorVersionNumber registry values before CurrentVersion.
+      configure: Check for pcap_init() instead of pcap_create().
+      wpcap: Sync spec file with latest version of libpcap.
+      wpcap: Make Unix call parameters wow64 compatible.
+      wpcap: Fix an off-by-one error in convert_length_to_ipv6_mask().
+      wpcap: Implement pcap_bufsize().
+      wpcap: Implement pcap_dump_close().
+      wpcap: Implement pcap_init().
+      wpcap: Reimplement pcap_loop() on top of pcap_next_ex().
+      wpcap: Enable UTF-8 encoding in libpcap.
+      wpcap: Add wow64 thunks.
+      wpcap: Try to enable 32-bit mmap() support in libpcap.
+      wpcap/tests: Initial tests.
+
+Huw D. M. Davies (1):
+      rpcrt4/tests: Remove a failing test.
+
+Ivan Chikish (3):
+      winegstreamer: Add missing *out=NULL in unknown_inner_QueryInterface.
+      wmvcore: Add missing *out=NULL in WMReader_QueryInterface.
+      wmvcore/tests: Check out value for NULL in check_interface.
 
 Jacek Caban (2):
-      include: Add vadefs.h header.
-      include: Add stdarg.h header.
-
-Julian Rüger (1):
-      po: Update German translation.
-
-Paul Gofman (3):
-      dwmapi: Fill qpcVBlank in DwmGetCompositionTimingInfo().
-      cryptnet: Check cached revocation status in verify_cert_revocation().
-      cryptnet: Also cache revocation status when using OCSP.
-
-Rémi Bernon (10):
-      ole32: Use CRT allocation for MIDL_user_(allocate/free).
-      ole32: Allocate IEnumSTATDATA data with the process heap.
-      ole32: Reset IMoniker data pointer to NULL on failure.
-      ole32: Allocate and free moniker lists with CRT allocations.
-      dinput/tests: Remove the async cancel tests.
-      rpcrt4/tests: Avoid invalid free of static string.
-      msv1_0: Avoid double free when SpAcceptLsaModeContext fails.
-      msv1_0: Avoid double free when SpInitLsaModeContext fails.
-      wininet: Allocate returned options strings with the process heap.
-      comctl32: Avoid mismatching heap in ProgressWindowProc.
-
-Stefan Dösinger (1):
-      wined3d: Clamp the bound buffer range to the buffer size.
-
-Zebediah Figura (4):
-      ntdll: Check for AT_HWCAP2 definition before using it.
-      ntdll: Manually write byte code for the xsavec instruction.
-      wined3d: Map the destination BO with WINED3D_MAP_DISCARD when replacing the entire destination in wined3d_context_gl_copy_bo_address().
-      wined3d: Write into a mapped BO when replacing the entire destination in wined3d_context_gl_copy_bo_address().
-
-Zhiyi Zhang (2):
-      win32u: Introduce a get_display_depth() helper to retrieve emulated display depth.
-      ddraw/tests: Do not create a fullscreen test window in test_window_position_cb().
+      wininet/tests: Add more InternetSetFilePointer tests.
+      oleaut32: Remove overflow check for VT_R4 and VT_R8 in VarAbs.
+
+Jason Kuo (2):
+      wininet: Partially implement InternetSetFilePointer.
+      wininet/tests: Add InternetSetFilePointer tests.
+
+Jason Millard (8):
+      vbscript: Fix memory leak in Split().
+      vbscript: Fix memory leak in Split().
+      vbscript: Add missing stubs for GetLocale and SetLocale builtins.
+      vbscript: Fix compile when colon follows Else on new line.
+      vbscript: Fix memory leak in owned safearray iterator.
+      oleaut32: Fix VarAbs function for BSTR with positive values.
+      vbscript: Fix compile when statement after ElseIf or after separator.
+      vbscript: Fix compile issue with non hex after concat without space.
+
+Jinoh Kang (2):
+      ntdll/tests: Update test_RtlUniform to match Windows Vista or later.
+      ntdll: Fix integer overflow in RtlUniform.
+
+Max Figura (5):
+      wined3d: Move the WINED3D_RS_ANTIALIAS stub to wined3d_device_apply_stateblock.
+      wined3d: Move the WINED3D_RS_TEXTUREPERSPECTIVE stub to wined3d_device_apply_stateblock.
+      wined3d: Move the WINED3D_RS_WRAPU stub to wined3d_device_apply_stateblock.
+      wined3d: Move the WINED3D_RS_WRAPV stub to wined3d_device_apply_stateblock.
+      wined3d: Move the WINED3D_RS_MONOENABLE stub to wined3d_device_apply_stateblock.
+
+Michael Stefaniuc (3):
+      mshtml/tests: Actually test a return value.
+      d3d11/tests: Actually test the return of CreateRasterizerState().
+      ntdll/tests: Remove some Vista broken broken(<constant>) calls.
+
+Mohamad Al-Jaf (9):
+      include: Add realtimeapiset.h file.
+      kernelbase: Partially implement QueryUnbiasedInterruptTimePrecise.
+      include: Add DirectX 12 Agility SDK definitions.
+      d3d12core: Add stub DLL.
+      include: Add windows.ui.viewmanagement.idl file.
+      windows.ui: Add stub DLL.
+      windows.ui: Add IUISettings3 stub interface.
+      windows.ui/tests: Add IUISettings3::GetColorValue() tests.
+      windows.ui: Implement IUISettings3::GetColorValue().
+
+Nikolay Sivov (1):
+      apisetschema: Add ext-ms-win-networking-wlanapi-l1-1-0.
+
+Paul Gofman (17):
+      winegstreamer: Implement _GetInputStatus() for h264 decoder transform.
+      winegstreamer: Implement _GetInputStatus() for aac decoder transform.
+      winegstreamer: Set MF_SA_D3D11_AWARE attribute for h264 transform.
+      mf/session: Avoid dropping samples delivered from transform in session_request_sample_from_node().
+      bcrypt/tests: Add more tests for AES initialization vectors.
+      bcrypt: Update init vector after encrypt or decrypt.
+      bcrypt: Only reset init vector if the new vector is non-NULL.
+      imm32: Disable cross thread access for ImmSetCompositionString().
+      win32u: Remove monitor name from gdi driver monitor info.
+      win32u: Use monitor ID from EDID when available.
+      win32u: Store EDID info in monitors cache.
+      win32u: Return edidManufactureId and edidProductCodeId from NtUserDisplayConfigGetDeviceInfo().
+      win32u: Get friendly monitor name from EDID in NtUserDisplayConfigGetDeviceInfo().
+      winegstreamer: Route MFAudioFormat_RAW_AAC to mf_media_type_to_wg_format_audio_mpeg4().
+      winegstreamer: Fix getting codec data for raw aac.
+      winegstreamer: Use default 0 for _AAC_PAYLOAD_TYPE if not set.
+      mf/tests: Add basic tests for raw aac decode.
+
+Piotr Caban (4):
+      msvcrt: Don't crash on NULL argument in getenv.
+      msvcrt: Don't crash on NULL argument in _wgetenv.
+      msvcrt: Improve error handling in getenv_s.
+      msvcrt: Improve error handling in _wgetenv_s.
+
+Rémi Bernon (27):
+      include: Add new kbd.h header with KBDTABLES definition.
+      win32u: Use KBDTABLES for default NtUserGetKeyNameText.
+      include: Add VSC_VK constants definitions to kbd.h.
+      win32u: Use KBDTABLES for NtUserMapVirtualKeyEx VSC / VK mapping.
+      include: Add VK_TO_WCHARS constants definitions to kbd.h.
+      win32u: Use KBDTABLES for NtUserMapVirtualKeyEx MAP_VK_TO_CHAR.
+      win32u: Use KBDTABLES for NtUserVkKeyScanEx.
+      win32u: Use KBDTABLES for NtUserToUnicodeEx.
+      joy.cpl: Process messages while waiting for the input threads.
+      joy.cpl: Refresh the DInput button display on device change.
+      joy.cpl: Improve the DInput button display with many buttons.
+      joy.cpl: Use the DIJOYSTATE2 user data format to support more buttons.
+      winebuild: Use .incbin instead of printf for resource data.
+      dinput: Split dinput_unacquire_window_devices helper.
+      dinput: Name input thread message and wparam values.
+      dinput: Use a WH_CBT hook instead of WH_CALLWNDPROC.
+      dinput: Introduce keyboard_handle_key_event helper.
+      dinput: Avoid entering the hook CS in input_thread_ll_hook_proc.
+      dinput: Merge mouse and rawmouse acquired lists.
+      dinput: Merge all acquired device lists together.
+      dinput: Use rawinput interface for keyboard device.
+      include: Move ddk/imm.h to immdev.h.
+      include: Fix ImeInquire declaration.
+      include: Fix ImeToAsciiEx declaration.
+      include: Add Imm(Get|Set)HotKey declarations.
+      dinput: Forbid acquiring for other process windows.
+      dinput: Hook window threads instead of the entire prefix.
+
+Shaun Ren (10):
+      ir50_32: Add stub dll.
+      ir50_32: Implement IV50_GetInfo.
+      ir50_32: Implement IV50_DecompressQuery.
+      ir50_32: Implement IV50_DecompressGetFormat.
+      winegstreamer: Add video_decoder stub.
+      ir50_32: Implement open and close.
+      winegstreamer: Add WG_MAJOR_TYPE_VIDEO_INDEO video type.
+      winegstreamer: Implement basic functionality for video_decoder.
+      ir50_32: Implement decompression.
+      wine.inf: Enable ir50_32 video codec.
+
+Zebediah Figura (28):
+      wined3d: Make depth bounds test a proper state and handle it in wined3d_device_apply_stateblock().
+      setupapi/tests: Add tests for FLG_ADDREG_APPEND.
+      setupapi: Fail installation when trying to append to a registry value of the wrong type.
+      setupapi: Create the registry value if it doesn't exist in append_multi_sz_value().
+      wine.inf: Always use FLG_ADDREG_APPEND for SvcHost entries.
+      scardsvr: Add stub service.
+      oleaut32: Manually construct a stub buffer for dispinterfaces.
+      ws2_32: Forbid passing zero buffers to WSARecv().
+      mfreadwrite/tests: Avoid depending on sample size in test_source_reader().
+      mfreadwrite/tests: Test an audio/video file.
+      winegstreamer: Check the absolute value of the height in mf_media_type_from_wg_format_video().
+      winegstreamer: Separate a mf_video_format_to_wg() helper.
+      user32/tests: Add a register_class() helper.
+      user32/tests: Use ok() instead of assert().
+      user32/tests: Avoid leaking a window in test_message_conversion().
+      user32/tests: Test WM_DEVICECHANGE Unicode conversion.
+      user32/tests: Remove BroadcastSystemMessage() test for WM_DEVICECHANGE.
+      user32: Pass BSMINFO in BroadcastSystemMessageExA().
+      ddraw/tests: Remove unnecessary skips and conditionals from test_pixel_format().
+      d3d9/tests: Test that presenting does not set the pixel format on a window without one.
+      d3d8/tests: Test that presenting does not set the pixel format on a window without one.
+      ddraw/tests: Test that presenting does not set the pixel format on a window without one.
+      wined3d: Introduce wined3d_texture_get_swapchain().
+      dxgi: Implement IDXGIResource::GetUsage().
+      d3d11: Expand tests for IDXGIResource.
+      wined3d: Destroy objects belonging to wined3d_context_vk.completed_command_buffer_id.
+      wined3d: Destroy objects belonging to wined3d_device_gl.completed_fence_id.
+      mfsrcsnk: Add missing DllGetClassObject() export.
+
+Ziqing Hui (6):
+      mfplat: Fix stride calculation for RGB24.
+      mfplat: Support YVYU, NV11, MEDIASUBTYPE_RGB* media types.
+      winegstreamer: Implement GetOutputType for WMV decoder.
+      winegstreamer: Implement SetOutputType for WMV decoder.
+      mf/tests: Test GetOutputSizeInfo for WMV decoder.
+      winegstreamer: Implement GetOutputSizeInfo for WMV decoder.
diff --git a/AUTHORS b/AUTHORS
index e8d677f70b5..f61b613a18f 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -26,6 +26,7 @@ Adrian Harvey
 Adrian Thiele
 Adrian Thurston
 Aidan Thornton
+Ake Rehnman
 Akihiro Sagawa
 Akira Nakagawa
 Alam Arias
@@ -522,6 +523,7 @@ Fabian Maurer
 Fabian Müntefering
 Fabrice Bauzac
 Fabrice Ménard
+Fan WenJie
 Farshad Agah
 Fatih Aşıcı
 Federico Schwindt
@@ -696,6 +698,7 @@ Ismael Barros
 Ismael Luceno
 İsmail Dönmez
 Itai Nahshon
+Ivan Chikish
 Ivan de Saedeleer
 Ivan Gyurdiev
 Ivan Kalvachev
@@ -758,6 +761,7 @@ Jaroslav Šmíd
 Jaroslaw Piotr Sobieszek
 Jason Edmeades
 Jason Green
+Jason Kuo
 Jason Mawdsley
 Jason McMullan
 Jason Millard
@@ -932,6 +936,7 @@ Justin Bradford
 Justin Chevrier
 Justin Martin
 Justin Santa Barbara
+Kacper Michajłow
 Kai Blaschke
 Kai Blin
 Kai Krakow
@@ -950,6 +955,7 @@ Karol Herbst
 Karsten Elfenbein
 Kasper Sandberg
 Katarzyna Caban
+K.B.Dharun Krishna
 Kees Cook
 Kees Schoenmakers
 Keith Bowes
@@ -1161,6 +1167,7 @@ Matthias Kupfer
 Matt Jones
 Matt Robinson
 Mauro Carvalho Chehab
+Max Figura
 Maxime Bellengé
 Maxime Lombard
 Max Kellermann
diff --git a/MAINTAINERS b/MAINTAINERS
index 276471287da..22351f5af60 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -72,6 +72,7 @@ P:	Matteo Bruni <mbruni@codeweavers.com>
 F:	dlls/d3d10core/
 F:	dlls/d3d11/
 F:	dlls/d3d12/
+F:	dlls/d3d12core/
 F:	dlls/d3d8/
 F:	dlls/d3d9/
 F:	dlls/d3drm/
@@ -212,6 +213,7 @@ F:	dlls/winegstreamer/aac_decoder.c
 F:	dlls/winegstreamer/color_convert.c
 F:	dlls/winegstreamer/h264_decoder.c
 F:	dlls/winegstreamer/resampler.c
+F:	dlls/winegstreamer/video_decoder.c
 F:	dlls/winegstreamer/video_processor.c
 F:	dlls/winegstreamer/wg_sample.c
 F:	dlls/winegstreamer/wg_transform.c
@@ -393,10 +395,6 @@ WinINet
 P:	Jacek Caban <jacek@codeweavers.com>
 F:	dlls/wininet/
 
-WPcap
-M:	André Zwing <nerv@dawncrow.de>
-F:	dlls/wpcap/
-
 X11 Driver
 M:	Alexandre Julliard <julliard@winehq.org>
 P:	Rémi Bernon <rbernon@codeweavers.com>
diff --git a/VERSION b/VERSION
index 468d6da97e9..6fe5c43e3f5 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-Wine version 8.0-rc4
+Wine version 8.2
diff --git a/configure b/configure
index 37d1ecbe111..9662264afec 100755
--- a/configure
+++ b/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.71 for Wine 8.0-rc4.
+# Generated by GNU Autoconf 2.71 for Wine 8.2.
 #
 # Report bugs to <wine-devel@winehq.org>.
 #
@@ -611,8 +611,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='Wine'
 PACKAGE_TARNAME='wine'
-PACKAGE_VERSION='8.0-rc4'
-PACKAGE_STRING='Wine 8.0-rc4'
+PACKAGE_VERSION='8.2'
+PACKAGE_STRING='Wine 8.2'
 PACKAGE_BUGREPORT='wine-devel@winehq.org'
 PACKAGE_URL='https://www.winehq.org'
 
@@ -700,7 +700,22 @@ DBUS_LIBS
 DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
+PCSCLITE_LIBS
 PCAP_LIBS
+DRM_LIBS
+DRM_CFLAGS
+GBM_LIBS
+GBM_CFLAGS
+XKBCOMMON_LIBS
+XKBCOMMON_CFLAGS
+WAYLAND_CURSOR_LIBS
+WAYLAND_CURSOR_CFLAGS
+WAYLAND_SCANNER
+WAYLAND_PROTOCOLS_DATADIR
+WAYLAND_PROTOCOLS_LIBS
+WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_CLIENT_LIBS
+WAYLAND_CLIENT_CFLAGS
 X_EXTRA_LIBS
 X_LIBS
 X_PRE_LIBS
@@ -928,6 +943,7 @@ with_opengl
 with_osmesa
 with_oss
 with_pcap
+with_pcsclite
 with_pthread
 with_pulse
 with_sane
@@ -937,6 +953,7 @@ with_unwind
 with_usb
 with_v4l2
 with_vulkan
+with_wayland
 with_xcomposite
 with_xcursor
 with_xfixes
@@ -1015,6 +1032,7 @@ enable_d3d10_1
 enable_d3d10core
 enable_d3d11
 enable_d3d12
+enable_d3d12core
 enable_d3d8
 enable_d3d8thk
 enable_d3d9
@@ -1162,6 +1180,7 @@ enable_inkobj
 enable_inseng
 enable_iphlpapi
 enable_iprop
+enable_ir50_32
 enable_irprops_cpl
 enable_itircl
 enable_itss
@@ -1210,6 +1229,7 @@ enable_msacm32
 enable_msado15
 enable_msadp32_acm
 enable_msasn1
+enable_msauddecmft
 enable_mscat32
 enable_mscms
 enable_mscoree
@@ -1235,6 +1255,7 @@ enable_msimtf
 enable_msisip
 enable_msisys_ocx
 enable_msls31
+enable_msmpeg2vdec
 enable_msnet32
 enable_mspatcha
 enable_msports
@@ -1355,6 +1376,7 @@ enable_sane_ds
 enable_sapi
 enable_sas
 enable_scarddlg
+enable_scardsvr
 enable_sccbase
 enable_schannel
 enable_schedsvc
@@ -1448,6 +1470,8 @@ enable_windows_media_devices
 enable_windows_media_speech
 enable_windows_media
 enable_windows_networking
+enable_windows_system_profile_systemmanufacturers
+enable_windows_ui
 enable_windowscodecs
 enable_windowscodecsext
 enable_winealsa_drv
@@ -1465,6 +1489,7 @@ enable_wineps_drv
 enable_winepulse_drv
 enable_wineusb_sys
 enable_winevulkan
+enable_winewayland_drv
 enable_winex11_drv
 enable_winexinput_sys
 enable_wing32
@@ -1735,6 +1760,18 @@ ZLIB_PE_CFLAGS
 ZLIB_PE_LIBS
 XMKMF
 CPP
+WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS
+WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_PROTOCOLS_LIBS
+WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS
+GBM_CFLAGS
+GBM_LIBS
+DRM_CFLAGS
+DRM_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2321,7 +2358,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures Wine 8.0-rc4 to adapt to many kinds of systems.
+\`configure' configures Wine 8.2 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -2391,7 +2428,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of Wine 8.0-rc4:";;
+     short | recursive ) echo "Configuration of Wine 8.2:";;
    esac
   cat <<\_ACEOF
 
@@ -2438,6 +2475,7 @@ Optional Packages:
   --without-osmesa        do not use the OSMesa library
   --without-oss           do not use the OSS sound support
   --without-pcap          do not use the Packet Capture library
+  --without-pcsclite      do not use PCSC lite
   --without-pthread       do not use the pthread library
   --without-pulse         do not use PulseAudio sound support
   --without-sane          do not use SANE (scanner support)
@@ -2448,6 +2486,7 @@ Optional Packages:
   --without-usb           do not use the libusb library
   --without-v4l2          do not use v4l2 (video capture)
   --without-vulkan        do not use Vulkan
+  --with-wayland          build with wayland support
   --without-xcomposite    do not use the Xcomposite extension
   --without-xcursor       do not use the Xcursor extension
   --without-xfixes        do not use Xfixes for clipboard change notifications
@@ -2533,6 +2572,26 @@ Some influential environment variables:
               Linker flags for the PE zlib, overriding the bundled version
   XMKMF       Path to xmkmf, Makefile generator for X Window System
   CPP         C preprocessor
+  WAYLAND_CLIENT_CFLAGS
+              C compiler flags for wayland-client, overriding pkg-config
+  WAYLAND_CLIENT_LIBS
+              Linker flags for wayland-client, overriding pkg-config
+  WAYLAND_PROTOCOLS_CFLAGS
+              C compiler flags for wayland-protocols, overriding pkg-config
+  WAYLAND_PROTOCOLS_LIBS
+              Linker flags for wayland-protocols, overriding pkg-config
+  WAYLAND_CURSOR_CFLAGS
+              C compiler flags for wayland-cursor, overriding pkg-config
+  WAYLAND_CURSOR_LIBS
+              Linker flags for wayland-cursor, overriding pkg-config
+  XKBCOMMON_CFLAGS
+              C compiler flags for xkbcommon, overriding pkg-config
+  XKBCOMMON_LIBS
+              Linker flags for xkbcommon, overriding pkg-config
+  GBM_CFLAGS  C compiler flags for gbm, overriding pkg-config
+  GBM_LIBS    Linker flags for gbm, overriding pkg-config
+  DRM_CFLAGS  C compiler flags for libdrm, overriding pkg-config
+  DRM_LIBS    Linker flags for libdrm, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -2563,10 +2622,10 @@ Some influential environment variables:
   PULSE_LIBS  Linker flags for libpulse, overriding pkg-config
   GSTREAMER_CFLAGS
               C compiler flags for gstreamer-1.0 gstreamer-video-1.0
-              gstreamer-audio-1.0, overriding pkg-config
+              gstreamer-audio-1.0 gstreamer-tag-1.0, overriding pkg-config
   GSTREAMER_LIBS
               Linker flags for gstreamer-1.0 gstreamer-video-1.0
-              gstreamer-audio-1.0, overriding pkg-config
+              gstreamer-audio-1.0 gstreamer-tag-1.0, overriding pkg-config
   UDEV_CFLAGS C compiler flags for libudev, overriding pkg-config
   UDEV_LIBS   Linker flags for libudev, overriding pkg-config
   UNWIND_CFLAGS
@@ -2660,7 +2719,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-Wine configure 8.0-rc4
+Wine configure 8.2
 generated by GNU Autoconf 2.71
 
 Copyright (C) 2021 Free Software Foundation, Inc.
@@ -3111,7 +3170,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by Wine $as_me 8.0-rc4, which was
+It was created by Wine $as_me 8.2, which was
 generated by GNU Autoconf 2.71.  Invocation command line was
 
   $ $0$ac_configure_args_raw
@@ -4301,6 +4360,13 @@ then :
 fi
 
 
+# Check whether --with-pcsclite was given.
+if test ${with_pcsclite+y}
+then :
+  withval=$with_pcsclite;
+fi
+
+
 # Check whether --with-pthread was given.
 if test ${with_pthread+y}
 then :
@@ -4364,6 +4430,15 @@ then :
 fi
 
 
+# Check whether --with-wayland was given.
+if test ${with_wayland+y}
+then :
+  withval=$with_wayland;
+else $as_nop
+  with_wayland=no
+fi
+
+
 # Check whether --with-xcomposite was given.
 if test ${with_xcomposite+y}
 then :
@@ -5857,11 +5932,11 @@ if test x$ac_prog_cxx_stdcxx = xno
 then :
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CXX option to enable C++11 features" >&5
 printf %s "checking for $CXX option to enable C++11 features... " >&6; }
-if test ${ac_cv_prog_cxx_11+y}
+if test ${ac_cv_prog_cxx_cxx11+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
-  ac_cv_prog_cxx_11=no
+  ac_cv_prog_cxx_cxx11=no
 ac_save_CXX=$CXX
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -5903,11 +5978,11 @@ if test x$ac_prog_cxx_stdcxx = xno
 then :
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CXX option to enable C++98 features" >&5
 printf %s "checking for $CXX option to enable C++98 features... " >&6; }
-if test ${ac_cv_prog_cxx_98+y}
+if test ${ac_cv_prog_cxx_cxx98+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
-  ac_cv_prog_cxx_98=no
+  ac_cv_prog_cxx_cxx98=no
 ac_save_CXX=$CXX
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -6210,7 +6285,7 @@ printf "%s\n" "$wine_cv_cc_m32" >&6; }
       host_cpu="i386"
       notice_platform="32-bit "
       TARGETFLAGS="$TARGETFLAGS -m32"
-      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig}
+      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig}
       export PKG_CONFIG_LIBDIR
       with_unwind=${with_unwind:-no}
     else
@@ -15644,319 +15719,1035 @@ enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 fi
 
-if test "$ac_cv_header_CL_cl_h" = "yes"
+if test "x$with_wayland" = "xno"
 then
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
-printf %s "checking for clGetPlatformInfo in -lOpenCL... " >&6; }
-if test ${ac_cv_lib_OpenCL_clGetPlatformInfo+y}
+    enable_winewayland_drv=no
+else
+    rm -f conftest.err
+if ${WAYLAND_CLIENT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_CFLAGS=`$PKG_CONFIG --cflags wayland-client 2>conftest.err`
+fi
+fi
+
+if ${WAYLAND_CLIENT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_LIBS=`$PKG_CONFIG --libs wayland-client 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client cflags: $WAYLAND_CLIENT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client libs: $WAYLAND_CLIENT_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: wayland-client errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CLIENT_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-client.h" "ac_cv_header_wayland_client_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_client_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CLIENT_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_display_connect in -lwayland-client" >&5
+printf %s "checking for wl_display_connect in -lwayland-client... " >&6; }
+if test ${ac_cv_lib_wayland_client_wl_display_connect+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lOpenCL  $LIBS"
+LIBS="-lwayland-client $WAYLAND_CLIENT_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-char clGetPlatformInfo ();
+char wl_display_connect ();
 int
 main (void)
 {
-return clGetPlatformInfo ();
+return wl_display_connect ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"
 then :
-  ac_cv_lib_OpenCL_clGetPlatformInfo=yes
+  ac_cv_lib_wayland_client_wl_display_connect=yes
 else $as_nop
-  ac_cv_lib_OpenCL_clGetPlatformInfo=no
+  ac_cv_lib_wayland_client_wl_display_connect=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_OpenCL_clGetPlatformInfo" >&5
-printf "%s\n" "$ac_cv_lib_OpenCL_clGetPlatformInfo" >&6; }
-if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" = xyes
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_client_wl_display_connect" >&5
+printf "%s\n" "$ac_cv_lib_wayland_client_wl_display_connect" >&6; }
+if test "x$ac_cv_lib_wayland_client_wl_display_connect" = xyes
 then :
-  OPENCL_LIBS="-lOpenCL"
+  :
+else $as_nop
+  WAYLAND_CLIENT_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
 
+    rm -f conftest.err
+if ${WAYLAND_PROTOCOLS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_PROTOCOLS_CFLAGS=`$PKG_CONFIG --cflags wayland-protocols 2>conftest.err`
+fi
 fi
 
+if ${WAYLAND_PROTOCOLS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_PROTOCOLS_LIBS=`$PKG_CONFIG --libs wayland-protocols 2>/dev/null`
 fi
-if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-protocols cflags: $WAYLAND_PROTOCOLS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-protocols libs: $WAYLAND_PROTOCOLS_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: wayland-protocols errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_PROTOCOLS_CFLAGS"
+WAYLAND_PROTOCOLS_DATADIR=`$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    # Extract the first word of "wayland-scanner", so it can be a program name with args.
+set dummy wayland-scanner; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_WAYLAND_SCANNER+y}
 then :
-  case "x$with_opencl" in
-  x)   as_fn_append wine_notices "|OpenCL ${notice_platform}development files not found, OpenCL won't be supported." ;;
-  xno) ;;
-  *)   as_fn_error $? "OpenCL ${notice_platform}development files not found, OpenCL won't be supported.
-This is an error since --with-opencl was requested." "$LINENO" 5 ;;
+  printf %s "(cached) " >&6
+else $as_nop
+  case $WAYLAND_SCANNER in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_WAYLAND_SCANNER="$WAYLAND_SCANNER" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_WAYLAND_SCANNER="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_WAYLAND_SCANNER" && ac_cv_path_WAYLAND_SCANNER="`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`"
+  ;;
 esac
-enable_opencl=${enable_opencl:-no}
+fi
+WAYLAND_SCANNER=$ac_cv_path_WAYLAND_SCANNER
+if test -n "$WAYLAND_SCANNER"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $WAYLAND_SCANNER" >&5
+printf "%s\n" "$WAYLAND_SCANNER" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
-if test "$ac_cv_header_pcap_pcap_h" = "yes"
-then
-    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pcap_create in -lpcap" >&5
-printf %s "checking for pcap_create in -lpcap... " >&6; }
-if test ${ac_cv_lib_pcap_pcap_create+y}
+
+    rm -f conftest.err
+if ${WAYLAND_CURSOR_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_CFLAGS=`$PKG_CONFIG --cflags wayland-cursor 2>conftest.err`
+fi
+fi
+
+if ${WAYLAND_CURSOR_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_LIBS=`$PKG_CONFIG --libs wayland-cursor 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor cflags: $WAYLAND_CURSOR_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor libs: $WAYLAND_CURSOR_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: wayland-cursor errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CURSOR_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-cursor.h" "ac_cv_header_wayland_cursor_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_cursor_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CURSOR_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_cursor_theme_load in -lwayland-cursor" >&5
+printf %s "checking for wl_cursor_theme_load in -lwayland-cursor... " >&6; }
+if test ${ac_cv_lib_wayland_cursor_wl_cursor_theme_load+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpcap  $LIBS"
+LIBS="-lwayland-cursor $WAYLAND_CURSOR_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-char pcap_create ();
+char wl_cursor_theme_load ();
 int
 main (void)
 {
-return pcap_create ();
+return wl_cursor_theme_load ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"
 then :
-  ac_cv_lib_pcap_pcap_create=yes
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=yes
 else $as_nop
-  ac_cv_lib_pcap_pcap_create=no
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcap_pcap_create" >&5
-printf "%s\n" "$ac_cv_lib_pcap_pcap_create" >&6; }
-if test "x$ac_cv_lib_pcap_pcap_create" = xyes
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&5
+printf "%s\n" "$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&6; }
+if test "x$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" = xyes
 then :
-  PCAP_LIBS="-lpcap"
-
+  :
+else $as_nop
+  WAYLAND_CURSOR_LIBS=""
 fi
 
-fi
-if test "x$ac_cv_lib_pcap_pcap_create" != xyes
-then :
-  case "x$with_pcap" in
-  x)   as_fn_append wine_notices "|pcap ${notice_platform}development files not found, wpcap won't be supported." ;;
-  xno) ;;
-  *)   as_fn_error $? "pcap ${notice_platform}development files not found, wpcap won't be supported.
-This is an error since --with-pcap was requested." "$LINENO" 5 ;;
-esac
-enable_wpcap=${enable_wpcap:-no}
-fi
+CPPFLAGS=$ac_save_CPPFLAGS
 
-if test "x$with_inotify" != "xno"
-then
     rm -f conftest.err
-if ${INOTIFY_CFLAGS:+false} :
+if ${XKBCOMMON_CFLAGS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
-  INOTIFY_CFLAGS=`$PKG_CONFIG --cflags libinotify 2>conftest.err`
+  XKBCOMMON_CFLAGS=`$PKG_CONFIG --cflags xkbcommon 2>conftest.err`
 fi
 fi
 
-if ${INOTIFY_LIBS:+false} :
+if ${XKBCOMMON_LIBS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
-  INOTIFY_LIBS=`$PKG_CONFIG --libs libinotify 2>/dev/null`
+  XKBCOMMON_LIBS=`$PKG_CONFIG --libs xkbcommon 2>/dev/null`
 fi
 fi
 
 
-printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify cflags: $INOTIFY_CFLAGS" >&5
-printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify libs: $INOTIFY_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon cflags: $XKBCOMMON_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon libs: $XKBCOMMON_LIBS" >&5
 if test -s conftest.err; then
-     printf %s "$as_me:${as_lineno-$LINENO}: libinotify errors: " >&5
+     printf %s "$as_me:${as_lineno-$LINENO}: xkbcommon errors: " >&5
      cat conftest.err >&5
 fi
 rm -f conftest.err
 ac_save_CPPFLAGS=$CPPFLAGS
-CPPFLAGS="$CPPFLAGS $INOTIFY_CFLAGS"
-ac_fn_c_check_header_compile "$LINENO" "sys/inotify.h" "ac_cv_header_sys_inotify_h" "$ac_includes_default"
-if test "x$ac_cv_header_sys_inotify_h" = xyes
+CPPFLAGS="$CPPFLAGS $XKBCOMMON_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "xkbcommon/xkbcommon.h" "ac_cv_header_xkbcommon_xkbcommon_h" "$ac_includes_default"
+if test "x$ac_cv_header_xkbcommon_xkbcommon_h" = xyes
 then :
-  printf "%s\n" "#define HAVE_SYS_INOTIFY_H 1" >>confdefs.h
+  printf "%s\n" "#define HAVE_XKBCOMMON_XKBCOMMON_H 1" >>confdefs.h
 
 fi
 
-         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inotify_add_watch in -linotify" >&5
-printf %s "checking for inotify_add_watch in -linotify... " >&6; }
-if test ${ac_cv_lib_inotify_inotify_add_watch+y}
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xkb_context_new in -lxkbcommon" >&5
+printf %s "checking for xkb_context_new in -lxkbcommon... " >&6; }
+if test ${ac_cv_lib_xkbcommon_xkb_context_new+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-linotify $INOTIFY_LIBS $LIBS"
+LIBS="-lxkbcommon $XKBCOMMON_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-char inotify_add_watch ();
+char xkb_context_new ();
 int
 main (void)
 {
-return inotify_add_watch ();
+return xkb_context_new ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"
 then :
-  ac_cv_lib_inotify_inotify_add_watch=yes
+  ac_cv_lib_xkbcommon_xkb_context_new=yes
 else $as_nop
-  ac_cv_lib_inotify_inotify_add_watch=no
+  ac_cv_lib_xkbcommon_xkb_context_new=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_inotify_inotify_add_watch" >&5
-printf "%s\n" "$ac_cv_lib_inotify_inotify_add_watch" >&6; }
-if test "x$ac_cv_lib_inotify_inotify_add_watch" = xyes
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xkbcommon_xkb_context_new" >&5
+printf "%s\n" "$ac_cv_lib_xkbcommon_xkb_context_new" >&6; }
+if test "x$ac_cv_lib_xkbcommon_xkb_context_new" = xyes
 then :
   :
 else $as_nop
-  INOTIFY_LIBS=""
+  XKBCOMMON_LIBS=""
 fi
 
 CPPFLAGS=$ac_save_CPPFLAGS
 
-fi
-if test "$ac_cv_header_sys_inotify_h" != "yes"
-then :
-  case "x$with_inotify" in
-  x)   as_fn_append wine_notices "|libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported." ;;
-  xno) ;;
-  *)   as_fn_error $? "libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported.
-This is an error since --with-inotify was requested." "$LINENO" 5 ;;
-esac
-
-fi
-
-if test "x$with_dbus" != "xno"
-then
     rm -f conftest.err
-if ${DBUS_CFLAGS:+false} :
+if ${GBM_CFLAGS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
-  DBUS_CFLAGS=`$PKG_CONFIG --cflags dbus-1 2>conftest.err`
+  GBM_CFLAGS=`$PKG_CONFIG --cflags gbm 2>conftest.err`
 fi
 fi
 
-if ${DBUS_LIBS:+false} :
+if ${GBM_LIBS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
-  DBUS_LIBS=`$PKG_CONFIG --libs dbus-1 2>/dev/null`
+  GBM_LIBS=`$PKG_CONFIG --libs gbm 2>/dev/null`
 fi
 fi
 
 
-printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 cflags: $DBUS_CFLAGS" >&5
-printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 libs: $DBUS_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm cflags: $GBM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm libs: $GBM_LIBS" >&5
 if test -s conftest.err; then
-     printf %s "$as_me:${as_lineno-$LINENO}: dbus-1 errors: " >&5
+     printf %s "$as_me:${as_lineno-$LINENO}: gbm errors: " >&5
      cat conftest.err >&5
 fi
 rm -f conftest.err
 ac_save_CPPFLAGS=$CPPFLAGS
-CPPFLAGS="$CPPFLAGS $DBUS_CFLAGS"
-ac_fn_c_check_header_compile "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
-if test "x$ac_cv_header_dbus_dbus_h" = xyes
+CPPFLAGS="$CPPFLAGS $GBM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gbm.h" "ac_cv_header_gbm_h" "$ac_includes_default"
+if test "x$ac_cv_header_gbm_h" = xyes
 then :
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
-printf %s "checking for -ldbus-1... " >&6; }
-if test ${ac_cv_lib_soname_dbus_1+y}
+  printf "%s\n" "#define HAVE_GBM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gbm_create_device in -lgbm" >&5
+printf %s "checking for gbm_create_device in -lgbm... " >&6; }
+if test ${ac_cv_lib_gbm_gbm_create_device+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
-  ac_check_soname_save_LIBS=$LIBS
-LIBS="-ldbus-1 $DBUS_LIBS $LIBS"
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgbm $GBM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-char dbus_connection_close ();
+char gbm_create_device ();
 int
 main (void)
 {
-return dbus_connection_close ();
+return gbm_create_device ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"
 then :
-  case "$LIBEXT" in
-    dll) ac_cv_lib_soname_dbus_1=`$ac_cv_path_LDD conftest.exe | grep "dbus-1" | sed -e "s/dll.*/dll/"';2,$d'` ;;
-    dylib) ac_cv_lib_soname_dbus_1=`$OTOOL -L conftest$ac_exeext | grep "libdbus-1\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libdbus-1\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
-    *) ac_cv_lib_soname_dbus_1=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libdbus-1\\.$LIBEXT" | sed -e "s/^.*\\[\\(libdbus-1\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_dbus_1:+false} :
-then :
-  ac_cv_lib_soname_dbus_1=`$LDD conftest$ac_exeext | grep "libdbus-1\\.$LIBEXT" | sed -e "s/^.*\(libdbus-1\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
-fi ;;
-  esac
+  ac_cv_lib_gbm_gbm_create_device=yes
 else $as_nop
-  ac_cv_lib_soname_dbus_1=
+  ac_cv_lib_gbm_gbm_create_device=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
-  LIBS=$ac_check_soname_save_LIBS
+LIBS=$ac_check_lib_save_LIBS
 fi
-if ${ac_cv_lib_soname_dbus_1:+false} :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gbm_gbm_create_device" >&5
+printf "%s\n" "$ac_cv_lib_gbm_gbm_create_device" >&6; }
+if test "x$ac_cv_lib_gbm_gbm_create_device" = xyes
 then :
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-printf "%s\n" "not found" >&6; }
-       DBUS_CFLAGS=""
-else $as_nop
-  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_dbus_1" >&5
-printf "%s\n" "$ac_cv_lib_soname_dbus_1" >&6; }
-
-printf "%s\n" "#define SONAME_LIBDBUS_1 \"$ac_cv_lib_soname_dbus_1\"" >>confdefs.h
-
-
-fi
+  :
 else $as_nop
-  DBUS_CFLAGS=""
+  GBM_LIBS=""
 fi
 
-CPPFLAGS=$ac_save_CPPFLAGS
+         ac_wine_check_funcs_save_LIBS="$LIBS"
+LIBS="$LIBS $GBM_LIBS"
+ac_fn_c_check_func "$LINENO" "gbm_surface_create_with_modifiers2" "ac_cv_func_gbm_surface_create_with_modifiers2"
+if test "x$ac_cv_func_gbm_surface_create_with_modifiers2" = xyes
+then :
+  printf "%s\n" "#define HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2 1" >>confdefs.h
 
 fi
-case $host_os in
-  darwin*|macosx*) ;;
-  *) if test "x$ac_cv_lib_soname_dbus_1" = "x"
-then :
-  case "x$with_dbus" in
-  x)   as_fn_append wine_notices "|libdbus ${notice_platform}development files not found, no dynamic device support." ;;
-  xno) ;;
-  *)   as_fn_error $? "libdbus ${notice_platform}development files not found, no dynamic device support.
-This is an error since --with-dbus was requested." "$LINENO" 5 ;;
-esac
 
-fi ;;
-esac
+LIBS="$ac_wine_check_funcs_save_LIBS"
+CPPFLAGS=$ac_save_CPPFLAGS
 
-if test "x$with_gnutls" != "xno"
-then
     rm -f conftest.err
-if ${GNUTLS_CFLAGS:+false} :
+if ${DRM_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DRM_CFLAGS=`$PKG_CONFIG --cflags libdrm 2>conftest.err`
+fi
+fi
+
+if ${DRM_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DRM_LIBS=`$PKG_CONFIG --libs libdrm 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdrm cflags: $DRM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdrm libs: $DRM_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libdrm errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $DRM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "drm.h" "ac_cv_header_drm_h" "$ac_includes_default"
+if test "x$ac_cv_header_drm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_DRM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for drmPrimeHandleToFD in -ldrm" >&5
+printf %s "checking for drmPrimeHandleToFD in -ldrm... " >&6; }
+if test ${ac_cv_lib_drm_drmPrimeHandleToFD+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldrm $DRM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char drmPrimeHandleToFD ();
+int
+main (void)
+{
+return drmPrimeHandleToFD ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_drm_drmPrimeHandleToFD=yes
+else $as_nop
+  ac_cv_lib_drm_drmPrimeHandleToFD=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_drm_drmPrimeHandleToFD" >&5
+printf "%s\n" "$ac_cv_lib_drm_drmPrimeHandleToFD" >&6; }
+if test "x$ac_cv_lib_drm_drmPrimeHandleToFD" = xyes
+then :
+  :
+else $as_nop
+  DRM_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lEGL" >&5
+printf %s "checking for -lEGL... " >&6; }
+if test ${ac_cv_lib_soname_EGL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lEGL  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char eglGetProcAddress ();
+int
+main (void)
+{
+return eglGetProcAddress ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_EGL=`$ac_cv_path_LDD conftest.exe | grep "EGL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_EGL=`$OTOOL -L conftest$ac_exeext | grep "libEGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libEGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_EGL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libEGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libEGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  ac_cv_lib_soname_EGL=`$LDD conftest$ac_exeext | grep "libEGL\\.$LIBEXT" | sed -e "s/^.*\(libEGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_EGL=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_EGL" >&5
+printf "%s\n" "$ac_cv_lib_soname_EGL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBEGL \"$ac_cv_lib_soname_EGL\"" >>confdefs.h
+
+
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGL  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char glFlush ();
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
+  ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_GL=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
+
+
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGLESv2" >&5
+printf %s "checking for -lGLESv2... " >&6; }
+if test ${ac_cv_lib_soname_GLESv2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGLESv2  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char glFlush ();
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GLESv2=`$ac_cv_path_LDD conftest.exe | grep "GLESv2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GLESv2=`$OTOOL -L conftest$ac_exeext | grep "libGLESv2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGLESv2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GLESv2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGLESv2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGLESv2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  ac_cv_lib_soname_GLESv2=`$LDD conftest$ac_exeext | grep "libGLESv2\\.$LIBEXT" | sed -e "s/^.*\(libGLESv2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_GLESv2=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLESv2" >&5
+printf "%s\n" "$ac_cv_lib_soname_GLESv2" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGLESV2 \"$ac_cv_lib_soname_GLESv2\"" >>confdefs.h
+
+
+fi
+fi
+if test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
+                           test -z "$DRM_LIBS"
+then :
+  case "x$with_wayland" in
+  x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.
+This is an error since --with-wayland was requested." "$LINENO" 5 ;;
+esac
+enable_winewayland_drv=${enable_winewayland_drv:-no}
+fi
+
+if test "$ac_cv_header_CL_cl_h" = "yes"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
+printf %s "checking for clGetPlatformInfo in -lOpenCL... " >&6; }
+if test ${ac_cv_lib_OpenCL_clGetPlatformInfo+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lOpenCL  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char clGetPlatformInfo ();
+int
+main (void)
+{
+return clGetPlatformInfo ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_OpenCL_clGetPlatformInfo=yes
+else $as_nop
+  ac_cv_lib_OpenCL_clGetPlatformInfo=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_OpenCL_clGetPlatformInfo" >&5
+printf "%s\n" "$ac_cv_lib_OpenCL_clGetPlatformInfo" >&6; }
+if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" = xyes
+then :
+  OPENCL_LIBS="-lOpenCL"
+
+fi
+
+fi
+if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes
+then :
+  case "x$with_opencl" in
+  x)   as_fn_append wine_notices "|OpenCL ${notice_platform}development files not found, OpenCL won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "OpenCL ${notice_platform}development files not found, OpenCL won't be supported.
+This is an error since --with-opencl was requested." "$LINENO" 5 ;;
+esac
+enable_opencl=${enable_opencl:-no}
+fi
+
+if test "$ac_cv_header_pcap_pcap_h" = "yes"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pcap_init in -lpcap" >&5
+printf %s "checking for pcap_init in -lpcap... " >&6; }
+if test ${ac_cv_lib_pcap_pcap_init+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcap  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char pcap_init ();
+int
+main (void)
+{
+return pcap_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_pcap_pcap_init=yes
+else $as_nop
+  ac_cv_lib_pcap_pcap_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcap_pcap_init" >&5
+printf "%s\n" "$ac_cv_lib_pcap_pcap_init" >&6; }
+if test "x$ac_cv_lib_pcap_pcap_init" = xyes
+then :
+  PCAP_LIBS="-lpcap"
+
+fi
+
+fi
+if test "x$ac_cv_lib_pcap_pcap_init" != xyes
+then :
+  case "x$with_pcap" in
+  x)   as_fn_append wine_notices "|pcap ${notice_platform}development files not found, wpcap won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "pcap ${notice_platform}development files not found, wpcap won't be supported.
+This is an error since --with-pcap was requested." "$LINENO" 5 ;;
+esac
+enable_wpcap=${enable_wpcap:-no}
+fi
+
+if test "x$with_pcsclite" != "xno"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for SCardEstablishContext in -lpcsclite" >&5
+printf %s "checking for SCardEstablishContext in -lpcsclite... " >&6; }
+if test ${ac_cv_lib_pcsclite_SCardEstablishContext+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcsclite  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char SCardEstablishContext ();
+int
+main (void)
+{
+return SCardEstablishContext ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_pcsclite_SCardEstablishContext=yes
+else $as_nop
+  ac_cv_lib_pcsclite_SCardEstablishContext=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcsclite_SCardEstablishContext" >&5
+printf "%s\n" "$ac_cv_lib_pcsclite_SCardEstablishContext" >&6; }
+if test "x$ac_cv_lib_pcsclite_SCardEstablishContext" = xyes
+then :
+  PCSCLITE_LIBS="-lpcsclite"
+
+fi
+
+fi
+if test "x$ac_cv_lib_pcsclite_SCardEstablishContext" != xyes
+then :
+  case "x$with_pcsclite" in
+  x)   as_fn_append wine_notices "|libpcsclite not found, smart cards won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libpcsclite not found, smart cards won't be supported.
+This is an error since --with-pcsclite was requested." "$LINENO" 5 ;;
+esac
+enable_winscard=${enable_winscard:-no}
+fi
+
+if test "x$with_inotify" != "xno"
+then
+    rm -f conftest.err
+if ${INOTIFY_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  INOTIFY_CFLAGS=`$PKG_CONFIG --cflags libinotify 2>conftest.err`
+fi
+fi
+
+if ${INOTIFY_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  INOTIFY_LIBS=`$PKG_CONFIG --libs libinotify 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify cflags: $INOTIFY_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify libs: $INOTIFY_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libinotify errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $INOTIFY_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "sys/inotify.h" "ac_cv_header_sys_inotify_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_inotify_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_INOTIFY_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inotify_add_watch in -linotify" >&5
+printf %s "checking for inotify_add_watch in -linotify... " >&6; }
+if test ${ac_cv_lib_inotify_inotify_add_watch+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-linotify $INOTIFY_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char inotify_add_watch ();
+int
+main (void)
+{
+return inotify_add_watch ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_inotify_inotify_add_watch=yes
+else $as_nop
+  ac_cv_lib_inotify_inotify_add_watch=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_inotify_inotify_add_watch" >&5
+printf "%s\n" "$ac_cv_lib_inotify_inotify_add_watch" >&6; }
+if test "x$ac_cv_lib_inotify_inotify_add_watch" = xyes
+then :
+  :
+else $as_nop
+  INOTIFY_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "$ac_cv_header_sys_inotify_h" != "yes"
+then :
+  case "x$with_inotify" in
+  x)   as_fn_append wine_notices "|libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported.
+This is an error since --with-inotify was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_dbus" != "xno"
+then
+    rm -f conftest.err
+if ${DBUS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DBUS_CFLAGS=`$PKG_CONFIG --cflags dbus-1 2>conftest.err`
+fi
+fi
+
+if ${DBUS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DBUS_LIBS=`$PKG_CONFIG --libs dbus-1 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 cflags: $DBUS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 libs: $DBUS_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: dbus-1 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $DBUS_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
+if test "x$ac_cv_header_dbus_dbus_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
+printf %s "checking for -ldbus-1... " >&6; }
+if test ${ac_cv_lib_soname_dbus_1+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-ldbus-1 $DBUS_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char dbus_connection_close ();
+int
+main (void)
+{
+return dbus_connection_close ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_dbus_1=`$ac_cv_path_LDD conftest.exe | grep "dbus-1" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_dbus_1=`$OTOOL -L conftest$ac_exeext | grep "libdbus-1\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libdbus-1\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_dbus_1=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libdbus-1\\.$LIBEXT" | sed -e "s/^.*\\[\\(libdbus-1\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_dbus_1:+false} :
+then :
+  ac_cv_lib_soname_dbus_1=`$LDD conftest$ac_exeext | grep "libdbus-1\\.$LIBEXT" | sed -e "s/^.*\(libdbus-1\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_dbus_1=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_dbus_1:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       DBUS_CFLAGS=""
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_dbus_1" >&5
+printf "%s\n" "$ac_cv_lib_soname_dbus_1" >&6; }
+
+printf "%s\n" "#define SONAME_LIBDBUS_1 \"$ac_cv_lib_soname_dbus_1\"" >>confdefs.h
+
+
+fi
+else $as_nop
+  DBUS_CFLAGS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+case $host_os in
+  darwin*|macosx*) ;;
+  *) if test "x$ac_cv_lib_soname_dbus_1" = "x"
+then :
+  case "x$with_dbus" in
+  x)   as_fn_append wine_notices "|libdbus ${notice_platform}development files not found, no dynamic device support." ;;
+  xno) ;;
+  *)   as_fn_error $? "libdbus ${notice_platform}development files not found, no dynamic device support.
+This is an error since --with-dbus was requested." "$LINENO" 5 ;;
+esac
+
+fi ;;
+esac
+
+if test "x$with_gnutls" != "xno"
+then
+    rm -f conftest.err
+if ${GNUTLS_CFLAGS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
@@ -16919,7 +17710,7 @@ if ${GSTREAMER_CFLAGS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
-  GSTREAMER_CFLAGS=`$PKG_CONFIG --cflags gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 2>conftest.err`
+  GSTREAMER_CFLAGS=`$PKG_CONFIG --cflags gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 2>conftest.err`
 fi
 fi
 
@@ -16927,15 +17718,15 @@ if ${GSTREAMER_LIBS:+false} :
 then :
   if test ${PKG_CONFIG+y}
 then :
-  GSTREAMER_LIBS=`$PKG_CONFIG --libs gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 2>/dev/null`
+  GSTREAMER_LIBS=`$PKG_CONFIG --libs gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 2>/dev/null`
 fi
 fi
 
 
-printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 cflags: $GSTREAMER_CFLAGS" >&5
-printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 libs: $GSTREAMER_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 cflags: $GSTREAMER_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 libs: $GSTREAMER_LIBS" >&5
 if test -s conftest.err; then
-     printf %s "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 errors: " >&5
+     printf %s "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 errors: " >&5
      cat conftest.err >&5
 fi
 rm -f conftest.err
@@ -20077,17 +20868,6 @@ _ACEOF
     ;;
 esac
 
-ac_fn_c_check_type "$LINENO" "sigset_t" "ac_cv_type_sigset_t" "#include <sys/types.h>
-#include <signal.h>
-"
-if test "x$ac_cv_type_sigset_t" = xyes
-then :
-
-printf "%s\n" "#define HAVE_SIGSET_T 1" >>confdefs.h
-
-
-fi
-
 ac_fn_c_check_type "$LINENO" "request_sense" "ac_cv_type_request_sense" "#include <linux/cdrom.h>
 "
 if test "x$ac_cv_type_request_sense" = xyes
@@ -20129,42 +20909,6 @@ printf "%s\n" "#define HAVE_STRUCT_XINPGEN 1" >>confdefs.h
 fi
 
 
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sigaddset" >&5
-printf %s "checking for sigaddset... " >&6; }
-if test ${wine_cv_have_sigaddset+y}
-then :
-  printf %s "(cached) " >&6
-else $as_nop
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <signal.h>
-int
-main (void)
-{
-sigset_t set; sigaddset(&set,SIGTERM);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"
-then :
-  wine_cv_have_sigaddset=yes
-else $as_nop
-  wine_cv_have_sigaddset=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.beam \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sigaddset" >&5
-printf "%s\n" "$wine_cv_have_sigaddset" >&6; }
-if test "$wine_cv_have_sigaddset" = "yes"
-then
-
-printf "%s\n" "#define HAVE_SIGADDSET 1" >>confdefs.h
-
-fi
-
-
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we can use re-entrant gethostbyname_r Linux style" >&5
 printf %s "checking whether we can use re-entrant gethostbyname_r Linux style... " >&6; }
 if test ${wine_cv_linux_gethostbyname_r_6+y}
@@ -21085,6 +21829,7 @@ wine_fn_config_makefile dlls/cryptext enable_cryptext
 wine_fn_config_makefile dlls/cryptnet enable_cryptnet
 wine_fn_config_makefile dlls/cryptnet/tests enable_tests
 wine_fn_config_makefile dlls/cryptowinrt enable_cryptowinrt
+wine_fn_config_makefile dlls/cryptowinrt/tests enable_tests
 wine_fn_config_makefile dlls/cryptsp enable_cryptsp
 wine_fn_config_makefile dlls/cryptui enable_cryptui
 wine_fn_config_makefile dlls/cryptui/tests enable_tests
@@ -21104,6 +21849,7 @@ wine_fn_config_makefile dlls/d3d11 enable_d3d11
 wine_fn_config_makefile dlls/d3d11/tests enable_tests
 wine_fn_config_makefile dlls/d3d12 enable_d3d12
 wine_fn_config_makefile dlls/d3d12/tests enable_tests
+wine_fn_config_makefile dlls/d3d12core enable_d3d12core
 wine_fn_config_makefile dlls/d3d8 enable_d3d8
 wine_fn_config_makefile dlls/d3d8/tests enable_tests
 wine_fn_config_makefile dlls/d3d8thk enable_d3d8thk
@@ -21325,6 +22071,7 @@ wine_fn_config_makefile dlls/inseng enable_inseng
 wine_fn_config_makefile dlls/iphlpapi enable_iphlpapi
 wine_fn_config_makefile dlls/iphlpapi/tests enable_tests
 wine_fn_config_makefile dlls/iprop enable_iprop
+wine_fn_config_makefile dlls/ir50_32 enable_ir50_32
 wine_fn_config_makefile dlls/irprops.cpl enable_irprops_cpl
 wine_fn_config_makefile dlls/itircl enable_itircl
 wine_fn_config_makefile dlls/itss enable_itss
@@ -21404,6 +22151,7 @@ wine_fn_config_makefile dlls/msado15/tests enable_tests
 wine_fn_config_makefile dlls/msadp32.acm enable_msadp32_acm
 wine_fn_config_makefile dlls/msasn1 enable_msasn1
 wine_fn_config_makefile dlls/msasn1/tests enable_tests
+wine_fn_config_makefile dlls/msauddecmft enable_msauddecmft
 wine_fn_config_makefile dlls/mscat32 enable_mscat32
 wine_fn_config_makefile dlls/mscms enable_mscms
 wine_fn_config_makefile dlls/mscms/tests enable_tests
@@ -21437,6 +22185,7 @@ wine_fn_config_makefile dlls/msimtf enable_msimtf
 wine_fn_config_makefile dlls/msisip enable_msisip
 wine_fn_config_makefile dlls/msisys.ocx enable_msisys_ocx
 wine_fn_config_makefile dlls/msls31 enable_msls31
+wine_fn_config_makefile dlls/msmpeg2vdec enable_msmpeg2vdec
 wine_fn_config_makefile dlls/msnet32 enable_msnet32
 wine_fn_config_makefile dlls/mspatcha enable_mspatcha
 wine_fn_config_makefile dlls/mspatcha/tests enable_tests
@@ -21630,6 +22379,7 @@ wine_fn_config_makefile dlls/sapi enable_sapi
 wine_fn_config_makefile dlls/sapi/tests enable_tests
 wine_fn_config_makefile dlls/sas enable_sas
 wine_fn_config_makefile dlls/scarddlg enable_scarddlg
+wine_fn_config_makefile dlls/scardsvr enable_scardsvr
 wine_fn_config_makefile dlls/sccbase enable_sccbase
 wine_fn_config_makefile dlls/schannel enable_schannel
 wine_fn_config_makefile dlls/schannel/tests enable_tests
@@ -21795,6 +22545,10 @@ wine_fn_config_makefile dlls/windows.media.speech/tests enable_tests
 wine_fn_config_makefile dlls/windows.media enable_windows_media
 wine_fn_config_makefile dlls/windows.media/tests enable_tests
 wine_fn_config_makefile dlls/windows.networking enable_windows_networking
+wine_fn_config_makefile dlls/windows.system.profile.systemmanufacturers enable_windows_system_profile_systemmanufacturers
+wine_fn_config_makefile dlls/windows.system.profile.systemmanufacturers/tests enable_tests
+wine_fn_config_makefile dlls/windows.ui enable_windows_ui
+wine_fn_config_makefile dlls/windows.ui/tests enable_tests
 wine_fn_config_makefile dlls/windowscodecs enable_windowscodecs
 wine_fn_config_makefile dlls/windowscodecs/tests enable_tests
 wine_fn_config_makefile dlls/windowscodecsext enable_windowscodecsext
@@ -21815,6 +22569,7 @@ wine_fn_config_makefile dlls/wineps16.drv16 enable_win16
 wine_fn_config_makefile dlls/winepulse.drv enable_winepulse_drv
 wine_fn_config_makefile dlls/wineusb.sys enable_wineusb_sys
 wine_fn_config_makefile dlls/winevulkan enable_winevulkan
+wine_fn_config_makefile dlls/winewayland.drv enable_winewayland_drv
 wine_fn_config_makefile dlls/winex11.drv enable_winex11_drv
 wine_fn_config_makefile dlls/winexinput.sys enable_winexinput_sys
 wine_fn_config_makefile dlls/wing.dll16 enable_win16
@@ -21829,6 +22584,7 @@ wine_fn_config_makefile dlls/winnls.dll16 enable_win16
 wine_fn_config_makefile dlls/winnls32 enable_winnls32
 wine_fn_config_makefile dlls/winprint enable_winprint
 wine_fn_config_makefile dlls/winscard enable_winscard
+wine_fn_config_makefile dlls/winscard/tests enable_tests
 wine_fn_config_makefile dlls/winsock.dll16 enable_win16
 wine_fn_config_makefile dlls/winspool.drv enable_winspool_drv
 wine_fn_config_makefile dlls/winspool.drv/tests enable_tests
@@ -21864,6 +22620,7 @@ wine_fn_config_makefile dlls/wow64win enable_wow64win
 wine_fn_config_makefile dlls/wpc enable_wpc
 wine_fn_config_makefile dlls/wpc/tests enable_tests
 wine_fn_config_makefile dlls/wpcap enable_wpcap
+wine_fn_config_makefile dlls/wpcap/tests enable_tests
 wine_fn_config_makefile dlls/ws2_32 enable_ws2_32
 wine_fn_config_makefile dlls/ws2_32/tests enable_tests
 wine_fn_config_makefile dlls/wsdapi enable_wsdapi
@@ -22729,7 +23486,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by Wine $as_me 8.0-rc4, which was
+This file was extended by Wine $as_me 8.2, which was
 generated by GNU Autoconf 2.71.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -22793,7 +23550,7 @@ ac_cs_config_escaped=`printf "%s\n" "$ac_cs_config" | sed "s/^ //; s/'/'\\\\\\\\
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config='$ac_cs_config_escaped'
 ac_cs_version="\\
-Wine config.status 8.0-rc4
+Wine config.status 8.2
 configured by $0, generated by GNU Autoconf 2.71,
   with options \\"\$ac_cs_config\\"
 
@@ -23116,7 +23873,22 @@ X_CFLAGS = $X_CFLAGS
 X_PRE_LIBS = $X_PRE_LIBS
 X_LIBS = $X_LIBS
 X_EXTRA_LIBS = $X_EXTRA_LIBS
+WAYLAND_CLIENT_CFLAGS = $WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS = $WAYLAND_CLIENT_LIBS
+WAYLAND_PROTOCOLS_CFLAGS = $WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_PROTOCOLS_LIBS = $WAYLAND_PROTOCOLS_LIBS
+WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
+WAYLAND_SCANNER = $WAYLAND_SCANNER
+WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS = $XKBCOMMON_LIBS
+GBM_CFLAGS = $GBM_CFLAGS
+GBM_LIBS = $GBM_LIBS
+DRM_CFLAGS = $DRM_CFLAGS
+DRM_LIBS = $DRM_LIBS
 PCAP_LIBS = $PCAP_LIBS
+PCSCLITE_LIBS = $PCSCLITE_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
 DBUS_CFLAGS = $DBUS_CFLAGS
diff --git a/configure.ac b/configure.ac
index 3c30db8fd45..3c016afef29 100644
--- a/configure.ac
+++ b/configure.ac
@@ -50,6 +50,7 @@ AC_ARG_WITH(osmesa,     AS_HELP_STRING([--without-osmesa],[do not use the OSMesa
 AC_ARG_WITH(oss,       AS_HELP_STRING([--without-oss],[do not use the OSS sound support]))
 AC_ARG_WITH(pcap,      AS_HELP_STRING([--without-pcap],[do not use the Packet Capture library]),
             [if test "x$withval" = "xno"; then ac_cv_header_pcap_pcap_h=no; fi])
+AC_ARG_WITH(pcsclite,  AS_HELP_STRING([--without-pcsclite],[do not use PCSC lite]))
 AC_ARG_WITH(pthread,   AS_HELP_STRING([--without-pthread],[do not use the pthread library]),
             [if test "x$withval" = "xno"; then ac_cv_header_pthread_h=no; fi])
 AC_ARG_WITH(pulse,     AS_HELP_STRING([--without-pulse],[do not use PulseAudio sound support]))
@@ -60,6 +61,8 @@ AC_ARG_WITH(unwind,    AS_HELP_STRING([--without-unwind],[do not use the libunwi
 AC_ARG_WITH(usb,       AS_HELP_STRING([--without-usb],[do not use the libusb library]))
 AC_ARG_WITH(v4l2,      AS_HELP_STRING([--without-v4l2],[do not use v4l2 (video capture)]))
 AC_ARG_WITH(vulkan,    AS_HELP_STRING([--without-vulkan],[do not use Vulkan]))
+AC_ARG_WITH(wayland,   AS_HELP_STRING([--with-wayland],[build with wayland support]),
+            [], [with_wayland=no])
 AC_ARG_WITH(xcomposite,AS_HELP_STRING([--without-xcomposite],[do not use the Xcomposite extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi])
 AC_ARG_WITH(xcursor,   AS_HELP_STRING([--without-xcursor],[do not use the Xcursor extension]),
@@ -128,7 +131,7 @@ case $host in
       host_cpu="i386"
       notice_platform="32-bit "
       TARGETFLAGS="$TARGETFLAGS -m32"
-      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig}
+      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig}
       export PKG_CONFIG_LIBDIR
       with_unwind=${with_unwind:-no}
     else
@@ -1359,6 +1362,47 @@ else
                      [enable_winex11_drv])
 fi
 
+if test "x$with_wayland" = "xno"
+then
+    enable_winewayland_drv=no
+else
+    WINE_PACKAGE_FLAGS(WAYLAND_CLIENT,[wayland-client],,,,
+        [AC_CHECK_HEADERS([wayland-client.h])
+         AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
+                      [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_PROTOCOLS, [wayland-protocols],,,,
+         [AC_SUBST(WAYLAND_PROTOCOLS_DATADIR,
+                   `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
+    AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
+                 [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
+    WINE_PACKAGE_FLAGS(WAYLAND_CURSOR,[wayland-cursor],,,,
+        [AC_CHECK_HEADERS([wayland-cursor.h])
+         AC_CHECK_LIB(wayland-cursor,wl_cursor_theme_load,[:],
+                      [WAYLAND_CURSOR_LIBS=""],[$WAYLAND_CURSOR_LIBS])])
+    WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
+        [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
+         AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(GBM,[gbm],,,,
+        [AC_CHECK_HEADERS([gbm.h])
+         AC_CHECK_LIB(gbm,gbm_create_device,[:],[GBM_LIBS=""],[$GBM_LIBS])
+         WINE_CHECK_LIB_FUNCS(gbm_surface_create_with_modifiers2, [$GBM_LIBS])])
+    WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
+        [AC_CHECK_HEADERS([drm.h])
+         AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
+    WINE_CHECK_SONAME(EGL,eglGetProcAddress)
+    WINE_CHECK_SONAME(GL,glFlush)
+    WINE_CHECK_SONAME(GLESv2,glFlush)
+fi
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
+                           test -z "$DRM_LIBS"],
+                 [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
+                 [enable_winewayland_drv])
+
 dnl **** Check for OpenCL ****
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
@@ -1371,12 +1415,21 @@ WINE_NOTICE_WITH(opencl,[test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes],
 dnl **** Check for libpcap ****
 if test "$ac_cv_header_pcap_pcap_h" = "yes"
 then
-    AC_CHECK_LIB(pcap,pcap_create,[AC_SUBST(PCAP_LIBS,["-lpcap"])])
+    AC_CHECK_LIB(pcap,pcap_init,[AC_SUBST(PCAP_LIBS,["-lpcap"])])
 fi
-WINE_NOTICE_WITH(pcap,[test "x$ac_cv_lib_pcap_pcap_create" != xyes],
+WINE_NOTICE_WITH(pcap,[test "x$ac_cv_lib_pcap_pcap_init" != xyes],
                  [pcap ${notice_platform}development files not found, wpcap won't be supported.],
                  [enable_wpcap])
 
+dnl **** Check for libpcsclite ****
+if test "x$with_pcsclite" != "xno"
+then
+    AC_CHECK_LIB(pcsclite,SCardEstablishContext,[AC_SUBST(PCSCLITE_LIBS,["-lpcsclite"])])
+fi
+WINE_NOTICE_WITH(pcsclite,[test "x$ac_cv_lib_pcsclite_SCardEstablishContext" != xyes],
+                 [libpcsclite not found, smart cards won't be supported.],
+                 [enable_winscard])
+
 dnl **** Check for inotify ****
 if test "x$with_inotify" != "xno"
 then
@@ -1570,7 +1623,7 @@ WINE_NOTICE_WITH(pulse, [test -z "$PULSE_LIBS"],
 dnl **** Check for gstreamer ****
 if test "x$with_gstreamer" != "xno"
 then
-    WINE_PACKAGE_FLAGS(GSTREAMER,[gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0],,,,
+    WINE_PACKAGE_FLAGS(GSTREAMER,[gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0],,,,
         [AC_CHECK_HEADER([gst/gst.h],
             [AC_MSG_CHECKING([whether gint64 defined by gst/gst.h is indeed 64-bit])
               AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <gst/gst.h>]],
@@ -2058,8 +2111,6 @@ fi
 dnl **** Check for types ****
 
 AC_C_INLINE
-AC_CHECK_TYPES([sigset_t],,,[#include <sys/types.h>
-#include <signal.h>])
 AC_CHECK_TYPES([request_sense],,,[#include <linux/cdrom.h>])
 
 AC_CHECK_TYPES([struct xinpgen],,,
@@ -2084,14 +2135,6 @@ AC_CHECK_TYPES([struct xinpgen],,,
 #include <netinet/in_pcb.h>
 #endif])
 
-AC_CACHE_CHECK([for sigaddset],wine_cv_have_sigaddset,
-               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <signal.h>]], [[sigset_t set; sigaddset(&set,SIGTERM);]])],[wine_cv_have_sigaddset=yes],[wine_cv_have_sigaddset=no]))
-if test "$wine_cv_have_sigaddset" = "yes"
-then
-  AC_DEFINE(HAVE_SIGADDSET, 1, [Define if sigaddset is supported])
-fi
-
-
 AC_CACHE_CHECK([whether we can use re-entrant gethostbyname_r Linux style],
    	wine_cv_linux_gethostbyname_r_6,
 	AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <netdb.h>]],[[
@@ -2423,6 +2466,7 @@ WINE_CONFIG_MAKEFILE(dlls/cryptext)
 WINE_CONFIG_MAKEFILE(dlls/cryptnet)
 WINE_CONFIG_MAKEFILE(dlls/cryptnet/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptowinrt)
+WINE_CONFIG_MAKEFILE(dlls/cryptowinrt/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptsp)
 WINE_CONFIG_MAKEFILE(dlls/cryptui)
 WINE_CONFIG_MAKEFILE(dlls/cryptui/tests)
@@ -2442,6 +2486,7 @@ WINE_CONFIG_MAKEFILE(dlls/d3d11)
 WINE_CONFIG_MAKEFILE(dlls/d3d11/tests)
 WINE_CONFIG_MAKEFILE(dlls/d3d12)
 WINE_CONFIG_MAKEFILE(dlls/d3d12/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d12core)
 WINE_CONFIG_MAKEFILE(dlls/d3d8)
 WINE_CONFIG_MAKEFILE(dlls/d3d8/tests)
 WINE_CONFIG_MAKEFILE(dlls/d3d8thk)
@@ -2663,6 +2708,7 @@ WINE_CONFIG_MAKEFILE(dlls/inseng)
 WINE_CONFIG_MAKEFILE(dlls/iphlpapi)
 WINE_CONFIG_MAKEFILE(dlls/iphlpapi/tests)
 WINE_CONFIG_MAKEFILE(dlls/iprop)
+WINE_CONFIG_MAKEFILE(dlls/ir50_32)
 WINE_CONFIG_MAKEFILE(dlls/irprops.cpl)
 WINE_CONFIG_MAKEFILE(dlls/itircl)
 WINE_CONFIG_MAKEFILE(dlls/itss)
@@ -2742,6 +2788,7 @@ WINE_CONFIG_MAKEFILE(dlls/msado15/tests)
 WINE_CONFIG_MAKEFILE(dlls/msadp32.acm)
 WINE_CONFIG_MAKEFILE(dlls/msasn1)
 WINE_CONFIG_MAKEFILE(dlls/msasn1/tests)
+WINE_CONFIG_MAKEFILE(dlls/msauddecmft)
 WINE_CONFIG_MAKEFILE(dlls/mscat32)
 WINE_CONFIG_MAKEFILE(dlls/mscms)
 WINE_CONFIG_MAKEFILE(dlls/mscms/tests)
@@ -2775,6 +2822,7 @@ WINE_CONFIG_MAKEFILE(dlls/msimtf)
 WINE_CONFIG_MAKEFILE(dlls/msisip)
 WINE_CONFIG_MAKEFILE(dlls/msisys.ocx)
 WINE_CONFIG_MAKEFILE(dlls/msls31)
+WINE_CONFIG_MAKEFILE(dlls/msmpeg2vdec)
 WINE_CONFIG_MAKEFILE(dlls/msnet32)
 WINE_CONFIG_MAKEFILE(dlls/mspatcha)
 WINE_CONFIG_MAKEFILE(dlls/mspatcha/tests)
@@ -2968,6 +3016,7 @@ WINE_CONFIG_MAKEFILE(dlls/sapi)
 WINE_CONFIG_MAKEFILE(dlls/sapi/tests)
 WINE_CONFIG_MAKEFILE(dlls/sas)
 WINE_CONFIG_MAKEFILE(dlls/scarddlg)
+WINE_CONFIG_MAKEFILE(dlls/scardsvr)
 WINE_CONFIG_MAKEFILE(dlls/sccbase)
 WINE_CONFIG_MAKEFILE(dlls/schannel)
 WINE_CONFIG_MAKEFILE(dlls/schannel/tests)
@@ -3133,6 +3182,10 @@ WINE_CONFIG_MAKEFILE(dlls/windows.media.speech/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.media)
 WINE_CONFIG_MAKEFILE(dlls/windows.media/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.networking)
+WINE_CONFIG_MAKEFILE(dlls/windows.system.profile.systemmanufacturers)
+WINE_CONFIG_MAKEFILE(dlls/windows.system.profile.systemmanufacturers/tests)
+WINE_CONFIG_MAKEFILE(dlls/windows.ui)
+WINE_CONFIG_MAKEFILE(dlls/windows.ui/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext)
@@ -3153,6 +3206,7 @@ WINE_CONFIG_MAKEFILE(dlls/wineps16.drv16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/winepulse.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineusb.sys)
 WINE_CONFIG_MAKEFILE(dlls/winevulkan)
+WINE_CONFIG_MAKEFILE(dlls/winewayland.drv)
 WINE_CONFIG_MAKEFILE(dlls/winex11.drv)
 WINE_CONFIG_MAKEFILE(dlls/winexinput.sys)
 WINE_CONFIG_MAKEFILE(dlls/wing.dll16,enable_win16)
@@ -3167,6 +3221,7 @@ WINE_CONFIG_MAKEFILE(dlls/winnls.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/winnls32)
 WINE_CONFIG_MAKEFILE(dlls/winprint)
 WINE_CONFIG_MAKEFILE(dlls/winscard)
+WINE_CONFIG_MAKEFILE(dlls/winscard/tests)
 WINE_CONFIG_MAKEFILE(dlls/winsock.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/winspool.drv)
 WINE_CONFIG_MAKEFILE(dlls/winspool.drv/tests)
@@ -3202,6 +3257,7 @@ WINE_CONFIG_MAKEFILE(dlls/wow64win)
 WINE_CONFIG_MAKEFILE(dlls/wpc)
 WINE_CONFIG_MAKEFILE(dlls/wpc/tests)
 WINE_CONFIG_MAKEFILE(dlls/wpcap)
+WINE_CONFIG_MAKEFILE(dlls/wpcap/tests)
 WINE_CONFIG_MAKEFILE(dlls/ws2_32)
 WINE_CONFIG_MAKEFILE(dlls/ws2_32/tests)
 WINE_CONFIG_MAKEFILE(dlls/wsdapi)
diff --git a/dlls/adsldp/tests/ldap.c b/dlls/adsldp/tests/ldap.c
index 23cca695c3a..80b41df5ea7 100644
--- a/dlls/adsldp/tests/ldap.c
+++ b/dlls/adsldp/tests/ldap.c
@@ -190,6 +190,11 @@ static void test_ParseDisplayName(void)
 
         count = 0xdeadbeef;
         hr = MkParseDisplayName(bc, test[i].path, &count, &mk);
+        if (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN))
+        {
+            skip("server is down\n");
+            break;
+        }
         todo_wine_if(i == 0 || i == 1 || i == 11 || i == 12)
         ok(hr == test[i].hr, "%d: got %#lx, expected %#lx\n", i, hr, test[i].hr);
         if (hr == S_OK)
diff --git a/dlls/advapi32/crypt.c b/dlls/advapi32/crypt.c
index 66ad7db3ab2..73c9b1d219d 100644
--- a/dlls/advapi32/crypt.c
+++ b/dlls/advapi32/crypt.c
@@ -2390,7 +2390,7 @@ static CRITICAL_SECTION_DEBUG random_debug =
 };
 static CRITICAL_SECTION random_cs = { &random_debug, -1, 0, 0, 0, 0 };
 
-#define MAX_CPUS 128
+#define MAX_CPUS 256
 static char random_buf[sizeof(SYSTEM_INTERRUPT_INFORMATION) * MAX_CPUS];
 static ULONG random_len;
 static ULONG random_pos;
diff --git a/dlls/apisetschema/apisetschema.spec b/dlls/apisetschema/apisetschema.spec
index cb22c25c054..981b80c6976 100644
--- a/dlls/apisetschema/apisetschema.spec
+++ b/dlls/apisetschema/apisetschema.spec
@@ -384,6 +384,7 @@ apiset ext-ms-win-mm-pehelper-l1-1-0 = mf.dll
 apiset ext-ms-win-mm-wmvcore-l1-1-0 = wmvcore.dll
 apiset ext-ms-win-msi-misc-l1-1-0 = msi.dll
 apiset ext-ms-win-msimg-draw-l1-1-0 = msimg32.dll
+apiset ext-ms-win-networking-wlanapi-l1-1-0 = wlanapi.dll
 apiset ext-ms-win-ntdsapi-activedirectoryclient-l1-1-1 = ntdsapi.dll
 apiset ext-ms-win-ntuser-caret-l1-1-0 = user32.dll
 apiset ext-ms-win-ntuser-chartranslation-l1-1-0 = user32.dll
diff --git a/dlls/appwiz.cpl/addons.c b/dlls/appwiz.cpl/addons.c
index c63106de95b..a5fdda3e81f 100644
--- a/dlls/appwiz.cpl/addons.c
+++ b/dlls/appwiz.cpl/addons.c
@@ -255,7 +255,7 @@ static HKEY open_config_key(void)
 
 static enum install_res install_from_registered_dir(void)
 {
-    char *package_dir;
+    char *package_dir, *new_package_dir;
     HKEY hkey;
     DWORD res, type, size = MAX_PATH;
     enum install_res ret;
@@ -267,8 +267,11 @@ static enum install_res install_from_registered_dir(void)
     package_dir = malloc(size);
     res = RegGetValueA(hkey, NULL, addon->dir_config_key, RRF_RT_ANY, &type, (PBYTE)package_dir, &size);
     if(res == ERROR_MORE_DATA) {
-        package_dir = realloc(package_dir, size);
-        res = RegGetValueA(hkey, NULL, addon->dir_config_key, RRF_RT_ANY, &type, (PBYTE)package_dir, &size);
+        new_package_dir = realloc(package_dir, size);
+        if(new_package_dir) {
+            package_dir = new_package_dir;
+            res = RegGetValueA(hkey, NULL, addon->dir_config_key, RRF_RT_ANY, &type, (PBYTE)package_dir, &size);
+        }
     }
     RegCloseKey(hkey);
     if(res == ERROR_FILE_NOT_FOUND) {
diff --git a/dlls/atl100/tests/atl.c b/dlls/atl100/tests/atl.c
index a40c38df25a..2fad97d8008 100644
--- a/dlls/atl100/tests/atl.c
+++ b/dlls/atl100/tests/atl.c
@@ -786,7 +786,7 @@ static void test_ax_win(void)
 
         /* test file:// scheme on non-existent file */
         ret = DeleteFileW(pathW);
-        ok(ret, "DeleteFile failed!\n");
+        ok(ret, "DeleteFile failed (gle=%lu)\n", GetLastError());
         hwnd = CreateWindowW(cls_names[i], file_uri1W, 0, 100, 100, 100, 100, NULL, NULL, NULL, NULL);
         ok(hwnd != NULL, "CreateWindow failed!\n");
         control = NULL;
@@ -1048,7 +1048,7 @@ static void test_AtlAxCreateControl(void)
 
     /* test file:// scheme on non-existent file. */
     ret = DeleteFileW(pathW);
-    ok(ret, "DeleteFile failed!\n");
+    ok(ret, "DeleteFile failed (gle=%lu)\n", GetLastError());
     container = NULL;
     control = NULL;
     hwnd = create_container_window();
diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index cf05e8b4d44..ca5b934a8d5 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -1149,12 +1149,12 @@ static BOOL is_equal_vector( const UCHAR *vector, ULONG len, const UCHAR *vector
 static NTSTATUS key_symmetric_set_vector( struct key *key, UCHAR *vector, ULONG vector_len, BOOL force_reset )
 {
     BOOL needs_reset = force_reset || !is_equal_vector( key->u.s.vector, key->u.s.vector_len, vector, vector_len );
-
-    free( key->u.s.vector );
-    key->u.s.vector = NULL;
-    key->u.s.vector_len = 0;
     if (vector)
     {
+        free( key->u.s.vector );
+        key->u.s.vector = NULL;
+        key->u.s.vector_len = 0;
+
         if (!(key->u.s.vector = malloc( vector_len ))) return STATUS_NO_MEMORY;
         memcpy( key->u.s.vector, vector, vector_len );
         key->u.s.vector_len = vector_len;
@@ -1418,6 +1418,16 @@ static NTSTATUS key_symmetric_encrypt( struct key *key,  UCHAR *input, ULONG inp
         free( buf );
     }
 
+    if (!status)
+    {
+        if (key->u.s.vector && *ret_len >= key->u.s.vector_len)
+        {
+            memcpy( key->u.s.vector, output + *ret_len - key->u.s.vector_len, key->u.s.vector_len );
+            if (iv) memcpy( iv, key->u.s.vector, min( iv_len, key->u.s.vector_len ));
+        }
+        else FIXME( "Unexpected vector len %lu, *ret_len %lu.\n", key->u.s.vector_len, *ret_len );
+    }
+
     return status;
 }
 
@@ -1515,6 +1525,16 @@ static NTSTATUS key_symmetric_decrypt( struct key *key, UCHAR *input, ULONG inpu
         free( buf );
     }
 
+    if (!status)
+    {
+        if (key->u.s.vector && input_len >= key->u.s.vector_len)
+        {
+            memcpy( key->u.s.vector, input + input_len - key->u.s.vector_len, key->u.s.vector_len );
+            if (iv) memcpy( iv, key->u.s.vector, min( iv_len, key->u.s.vector_len ));
+        }
+        else FIXME( "Unexpected vector len %lu, *ret_len %lu.\n", key->u.s.vector_len, *ret_len );
+    }
+
     return status;
 }
 
diff --git a/dlls/bcrypt/tests/bcrypt.c b/dlls/bcrypt/tests/bcrypt.c
index 5d1a80f330b..19518480ee0 100644
--- a/dlls/bcrypt/tests/bcrypt.c
+++ b/dlls/bcrypt/tests/bcrypt.c
@@ -739,6 +739,10 @@ static void test_BCryptGenerateSymmetricKey(void)
         {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
     static UCHAR expected[] =
         {0xc6,0xa1,0x3b,0x37,0x87,0x8f,0x5b,0x82,0x6f,0x4f,0x81,0x62,0xa1,0xc8,0xd8,0x79};
+    static UCHAR expected2[] =
+        {0xb5,0x8a,0x10,0x64,0xd8,0xac,0xa9,0x9b,0xd9,0xb0,0x40,0x5b,0x85,0x45,0xf5,0xbb};
+    static UCHAR expected3[] =
+        {0xe3,0x7c,0xd3,0x63,0xdd,0x7c,0x87,0xa0,0x9a,0xff,0x0e,0x3e,0x60,0xe0,0x9c,0x82};
     BCRYPT_ALG_HANDLE aes;
     BCRYPT_KEY_HANDLE key, key2;
     UCHAR *buf, ciphertext[16], plaintext[16], ivbuf[16], mode[64];
@@ -821,6 +825,7 @@ static void test_BCryptGenerateSymmetricKey(void)
     ret = BCryptEncrypt(key, data, 16, NULL, ivbuf, 16, NULL, 0, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -831,6 +836,26 @@ static void test_BCryptGenerateSymmetricKey(void)
     ok(!memcmp(ciphertext, expected, sizeof(expected)), "wrong data\n");
     for (i = 0; i < 16; i++)
         ok(ciphertext[i] == expected[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected[i]);
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
+
+    size = 0;
+    memset(ciphertext, 0, sizeof(ciphertext));
+    ret = BCryptEncrypt(key, data, 16, NULL, NULL, 0, ciphertext, 16, &size, 0);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 16, "got %lu\n", size);
+    ok(!memcmp(ciphertext, expected2, sizeof(expected2)), "wrong data\n");
+
+    size = 0;
+    memcpy(ivbuf, iv, sizeof(iv));
+    ++ivbuf[0];
+    memset(ciphertext, 0, sizeof(ciphertext));
+    ret = BCryptEncrypt(key, data, 16, NULL, ivbuf, 16, ciphertext, 16, &size, 0);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 16, "got %lu\n", size);
+    ok(!memcmp(ciphertext, expected3, sizeof(expected3)), "wrong data\n");
+    for (i = 0; i < 16; i++)
+        ok(ciphertext[i] == expected3[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected3[i]);
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     key2 = (void *)0xdeadbeef;
     ret = BCryptDuplicateKey(NULL, &key2, NULL, 0, 0);
@@ -858,6 +883,7 @@ static void test_BCryptGenerateSymmetricKey(void)
         ok(!memcmp(ciphertext, expected, sizeof(expected)), "wrong data\n");
         for (i = 0; i < 16; i++)
             ok(ciphertext[i] == expected[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected[i]);
+        ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
         ret = BCryptDestroyKey(key2);
         ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
@@ -881,6 +907,7 @@ static void test_BCryptGenerateSymmetricKey(void)
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
     ok(!memcmp(plaintext, data, sizeof(data)), "wrong data\n");
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     memset(mode, 0, sizeof(mode));
     ret = BCryptGetProperty(key, BCRYPT_CHAINING_MODE, mode, sizeof(mode), &size, 0);
@@ -1083,6 +1110,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 16, NULL, ivbuf, 16, NULL, 0, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1093,6 +1121,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected, sizeof(expected)), "wrong data\n");
     for (i = 0; i < 16; i++)
         ok(ciphertext[i] == expected[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected[i]);
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     /* NULL initialization vector */
     size = 0;
@@ -1100,7 +1129,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 16, NULL, NULL, 0, ciphertext, 16, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
-    todo_wine ok(!memcmp(ciphertext, expected8, sizeof(expected8)), "wrong data\n");
+    ok(!memcmp(ciphertext, expected8, sizeof(expected8)), "wrong data\n");
 
     /* all zero initialization vector */
     size = 0;
@@ -1112,6 +1141,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected9, sizeof(expected9)), "wrong data\n");
     for (i = 0; i < 16; i++)
         ok(ciphertext[i] == expected9[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected9[i]);
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     /* input size is not a multiple of block size */
     size = 0;
@@ -1126,6 +1156,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 17, NULL, ivbuf, 16, NULL, 0, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1136,6 +1167,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected2, sizeof(expected2)), "wrong data\n");
     for (i = 0; i < 32; i++)
         ok(ciphertext[i] == expected2[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected2[i]);
+    ok(!memcmp(ivbuf, ciphertext + 32 - 16, sizeof(iv)), "wrong iv data.\n");
 
     /* input size is a multiple of block size, block padding set */
     size = 0;
@@ -1143,6 +1175,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data2, 32, NULL, ivbuf, 16, NULL, 0, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 48, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1153,6 +1186,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected3, sizeof(expected3)), "wrong data\n");
     for (i = 0; i < 48; i++)
         ok(ciphertext[i] == expected3[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected3[i]);
+    ok(!memcmp(ivbuf, ciphertext + 48 - 16, sizeof(iv)), "wrong iv data.\n");
 
     /* output size too small */
     size = 0;
@@ -1191,6 +1225,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data2, 32, NULL, ivbuf, 16, NULL, 0, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 48, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1201,6 +1236,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected10, sizeof(expected10)), "wrong data\n");
     for (i = 0; i < 48; i++)
         ok(ciphertext[i] == expected10[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected10[i]);
+    ok(!memcmp(ivbuf, ciphertext + 48 - 16, sizeof(iv)), "wrong iv data.\n");
 
     ret = BCryptDestroyKey(key);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
@@ -1267,6 +1303,7 @@ static void test_BCryptEncrypt(void)
         ok(ciphertext[i] == expected4[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected4[i]);
     for (i = 0; i < 16; i++)
         ok(tag[i] == expected_tag[i], "%lu: %02x != %02x\n", i, tag[i], expected_tag[i]);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     /* NULL initialization vector */
     size = 0;
@@ -1296,6 +1333,8 @@ static void test_BCryptEncrypt(void)
         ok(ciphertext[i] == expected4[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected4[i]);
     for (i = 0; i < 16; i++)
         ok(tag[i] == expected_tag[i], "%lu: %02x != %02x\n", i, tag[i], expected_tag[i]);
+    memset(ciphertext, 0, sizeof(iv));
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     /* input size is not multiple of block size */
     size = 0;
@@ -1311,6 +1350,7 @@ static void test_BCryptEncrypt(void)
         ok(ciphertext[i] == expected4[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected4[i]);
     for (i = 0; i < 16; i++)
         ok(tag[i] == expected_tag2[i], "%lu: %02x != %02x\n", i, tag[i], expected_tag2[i]);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     /* test with auth data */
     auth_info.pbAuthData = auth_data;
@@ -1329,6 +1369,7 @@ static void test_BCryptEncrypt(void)
         ok(ciphertext[i] == expected4[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected4[i]);
     for (i = 0; i < 16; i++)
         ok(tag[i] == expected_tag3[i], "%lu: %02x != %02x\n", i, tag[i], expected_tag3[i]);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     memset(tag, 0xff, sizeof(tag));
     ret = BCryptEncrypt(key, data2, 0, &auth_info, ivbuf, 16, NULL, 0, &size, 0);
@@ -1496,6 +1537,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 16, NULL, ivbuf, 16, NULL, 0, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1506,6 +1548,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected11, sizeof(expected11)), "wrong data\n");
     for (i = 0; i < 16; i++)
         ok(ciphertext[i] == expected11[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected11[i]);
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     /* NULL initialization vector */
     size = 0;
@@ -1513,7 +1556,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 16, NULL, NULL, 0, ciphertext, 16, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
-    todo_wine ok(!memcmp(ciphertext, expected12, sizeof(expected12)), "wrong data\n");
+    ok(!memcmp(ciphertext, expected12, sizeof(expected12)), "wrong data\n");
 
     /* all zero initialization vector */
     size = 0;
@@ -1525,6 +1568,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected13, sizeof(expected13)), "wrong data\n");
     for (i = 0; i < 16; i++)
         ok(ciphertext[i] == expected13[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected13[i]);
+    ok(!memcmp(ivbuf, ciphertext, sizeof(iv)), "wrong iv data.\n");
 
     /* input size is not a multiple of block size */
     size = 0;
@@ -1539,6 +1583,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 17, NULL, ivbuf, 16, NULL, 0, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1549,6 +1594,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected14, sizeof(expected14)), "wrong data\n");
     for (i = 0; i < 32; i++)
         ok(ciphertext[i] == expected14[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected14[i]);
+    ok(!memcmp(ivbuf, ciphertext + 32 - 16, sizeof(iv)), "wrong iv data.\n");
 
     /* input size is a multiple of block size, block padding set */
     size = 0;
@@ -1566,6 +1612,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected15, sizeof(expected15)), "wrong data\n");
     for (i = 0; i < 48; i++)
         ok(ciphertext[i] == expected15[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected15[i]);
+    ok(!memcmp(ivbuf, ciphertext + 48 - 16, sizeof(iv)), "wrong iv data.\n");
 
     /* output size too small */
     size = 0;
@@ -1574,6 +1621,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data, 17, NULL, ivbuf, 16, ciphertext, 31, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_BUFFER_TOO_SMALL, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1581,6 +1629,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data2, 32, NULL, ivbuf, 16, ciphertext, 32, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_BUFFER_TOO_SMALL, "got %#lx\n", ret);
     ok(size == 48, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     ret = BCryptDestroyKey(key);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
@@ -1604,6 +1653,7 @@ static void test_BCryptEncrypt(void)
     ret = BCryptEncrypt(key, data2, 32, NULL, ivbuf, 16, NULL, 0, &size, BCRYPT_BLOCK_PADDING);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 48, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1614,6 +1664,7 @@ static void test_BCryptEncrypt(void)
     ok(!memcmp(ciphertext, expected16, sizeof(expected16)), "wrong data\n");
     for (i = 0; i < 48; i++)
         ok(ciphertext[i] == expected16[i], "%lu: %02x != %02x\n", i, ciphertext[i], expected16[i]);
+    ok(!memcmp(ivbuf, ciphertext + 48 - 16, sizeof(iv)), "wrong iv data.\n");
 
     ret = BCryptCloseAlgorithmProvider(aes, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
@@ -1636,6 +1687,12 @@ static void test_BCryptDecrypt(void)
     static UCHAR expected3[] =
         {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
          0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};
+    static UCHAR expected4[] =
+        {0x28,0x73,0x3d,0xef,0x84,0x8f,0xb0,0xa6,0x5d,0x1a,0x51,0xb7,0xec,0x8f,0xea,0xe9,
+         0x10,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f};
+    static UCHAR expected5[] =
+        {0x29,0x73,0x3d,0xef,0x84,0x8f,0xb0,0xa6,0x5d,0x1a,0x51,0xb7,0xec,0x8f,0xea,0xe9,
+         0x10,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f};
     static UCHAR ciphertext[32] =
         {0xc6,0xa1,0x3b,0x37,0x87,0x8f,0x5b,0x82,0x6f,0x4f,0x81,0x62,0xa1,0xc8,0xd8,0x79,
          0x28,0x73,0x3d,0xef,0x84,0x8f,0xb0,0xa6,0x5d,0x1a,0x51,0xb7,0xec,0x8f,0xea,0xe9};
@@ -1702,6 +1759,7 @@ static void test_BCryptDecrypt(void)
     ret = BCryptDecrypt(key, ciphertext, 32, NULL, ivbuf, 16, NULL, 0, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1710,6 +1768,23 @@ static void test_BCryptDecrypt(void)
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
     ok(!memcmp(plaintext, expected, sizeof(expected)), "wrong data\n");
+    ok(!memcmp(ivbuf, ciphertext + size - sizeof(iv), sizeof(iv)), "wrong iv data.\n");
+
+    size = 0;
+    ++ivbuf[0];
+    memset(plaintext, 0, sizeof(plaintext));
+    ret = BCryptDecrypt(key, ciphertext, 32, NULL, ivbuf, 16, plaintext, 32, &size, 0);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(plaintext, expected5, sizeof(expected)), "wrong data\n");
+    ok(!memcmp(ivbuf, ciphertext + 32 - 16, sizeof(iv)), "wrong iv data.\n");
+
+    size = 0;
+    memset(plaintext, 0, sizeof(plaintext));
+    ret = BCryptDecrypt(key, ciphertext, 32, NULL, NULL, 0, plaintext, 32, &size, 0);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(plaintext, expected4, sizeof(expected4)), "wrong data\n");
 
     /* test with padding smaller than block size */
     size = 0;
@@ -1717,6 +1792,7 @@ static void test_BCryptDecrypt(void)
     ret = BCryptDecrypt(key, ciphertext2, 32, NULL, ivbuf, 16, NULL, 0, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1725,6 +1801,15 @@ static void test_BCryptDecrypt(void)
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 17, "got %lu\n", size);
     ok(!memcmp(plaintext, expected2, sizeof(expected2)), "wrong data\n");
+    ok(!memcmp(ivbuf, ciphertext2 + 32 - sizeof(iv), sizeof(iv)), "wrong iv data.\n");
+
+    size = 0;
+    memset(plaintext, 0, sizeof(plaintext));
+    ret = BCryptDecrypt(key, ciphertext2, 32, NULL, ivbuf, 16, plaintext, 17, &size, BCRYPT_BLOCK_PADDING);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 17, "got %lu\n", size);
+    ok(!memcmp(plaintext, expected4, size), "wrong data\n");
+    ok(!memcmp(ivbuf, ciphertext2 + 32 - 16, sizeof(iv)), "wrong iv data.\n");
 
     /* test with padding of block size */
     size = 0;
@@ -1732,6 +1817,7 @@ static void test_BCryptDecrypt(void)
     ret = BCryptDecrypt(key, ciphertext3, 48, NULL, ivbuf, 16, NULL, 0, &size, 0);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 48, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     size = 0;
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1740,6 +1826,7 @@ static void test_BCryptDecrypt(void)
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
     ok(!memcmp(plaintext, expected3, sizeof(expected3)), "wrong data\n");
+    ok(!memcmp(ivbuf, ciphertext3 + 48 - 16, sizeof(iv)), "wrong iv data.\n");
 
     /* output size too small */
     size = 0;
@@ -1816,6 +1903,25 @@ static void test_BCryptDecrypt(void)
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
     ok(!memcmp(plaintext, expected3, sizeof(expected3)), "wrong data\n");
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv.\n");
+
+    size = 0;
+    memset(plaintext, 0, sizeof(plaintext));
+    ret = BCryptDecrypt(key, ciphertext4, 32, &auth_info, NULL, 0, plaintext, 32, &size, 0);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(plaintext, expected3, sizeof(expected3)), "wrong data\n");
+
+    size = 0;
+    memcpy(ivbuf, iv, sizeof(iv));
+    ++ivbuf[0];
+    memset(plaintext, 0, sizeof(plaintext));
+    ret = BCryptDecrypt(key, ciphertext4, 32, &auth_info, ivbuf, 16, plaintext, 32, &size, 0);
+    ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
+    ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(plaintext, expected3, sizeof(expected3)), "wrong data\n");
+    ok(!memcmp(ivbuf + 1, iv + 1, sizeof(iv) - 1), "wrong iv data.\n");
+    ok(ivbuf[0] == iv[0] + 1, "wrong iv data.\n");
 
     /* test with auth data */
     auth_info.pbAuthData = auth_data;
@@ -1830,6 +1936,7 @@ static void test_BCryptDecrypt(void)
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
     ok(!memcmp(plaintext, expected3, sizeof(expected3)), "wrong data\n");
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv.\n");
 
     /* test with wrong tag */
     memcpy(ivbuf, iv, sizeof(iv));
@@ -1837,6 +1944,7 @@ static void test_BCryptDecrypt(void)
     ret = BCryptDecrypt(key, ciphertext4, 32, &auth_info, ivbuf, 16, plaintext, 32, &size, 0);
     ok(ret == STATUS_AUTH_TAG_MISMATCH, "got %#lx\n", ret);
     ok(size == 32, "got %lu\n", size);
+    ok(!memcmp(ivbuf, iv, sizeof(iv)), "wrong iv data.\n");
 
     ret = BCryptDestroyKey(key);
     ok(ret == STATUS_SUCCESS, "got %#lx\n", ret);
@@ -3148,7 +3256,7 @@ static void test_aes_vector(void)
     ret = BCryptEncrypt(key, input, sizeof(input), NULL, iv, sizeof(iv), output, sizeof(output), &size, 0);
     ok(!ret, "got %#lx\n", ret);
     ok(size == 16, "got %lu\n", size);
-    todo_wine ok(!memcmp(output, expect3, sizeof(expect3)), "wrong cipher text\n");
+    ok(!memcmp(output, expect3, sizeof(expect3)), "wrong cipher text\n");
 
     ret = BCryptDestroyKey(key);
     ok(!ret, "got %#lx\n", ret);
diff --git a/dlls/bluetoothapis/Makefile.in b/dlls/bluetoothapis/Makefile.in
index 51b2871d81d..50799b90435 100644
--- a/dlls/bluetoothapis/Makefile.in
+++ b/dlls/bluetoothapis/Makefile.in
@@ -1,3 +1,7 @@
 MODULE    = bluetoothapis.dll
+IMPORTLIB = bluetoothapis
 
 EXTRADLLFLAGS = -Wb,--prefer-native
+
+C_SRCS = \
+	main.c
diff --git a/dlls/bluetoothapis/bluetoothapis.spec b/dlls/bluetoothapis/bluetoothapis.spec
index 39354b8c9a8..625dffb8254 100644
--- a/dlls/bluetoothapis/bluetoothapis.spec
+++ b/dlls/bluetoothapis/bluetoothapis.spec
@@ -7,28 +7,28 @@
 @ stub BluetoothEnumerateLocalServices
 @ stub BluetoothFindBrowseGroupClose
 @ stub BluetoothFindClassIdClose
-@ stub BluetoothFindDeviceClose
+@ stdcall BluetoothFindDeviceClose(ptr)
 @ stub BluetoothFindFirstBrowseGroup
 @ stub BluetoothFindFirstClassId
-@ stub BluetoothFindFirstDevice
+@ stdcall BluetoothFindFirstDevice(ptr ptr)
 @ stub BluetoothFindFirstProfileDescriptor
 @ stub BluetoothFindFirstProtocolDescriptorStack
 @ stub BluetoothFindFirstProtocolEntry
-@ stub BluetoothFindFirstRadio
+@ stdcall BluetoothFindFirstRadio(ptr ptr)
 @ stub BluetoothFindFirstService
 @ stub BluetoothFindFirstServiceEx
 @ stub BluetoothFindNextBrowseGroup
 @ stub BluetoothFindNextClassId
-@ stub BluetoothFindNextDevice
+@ stdcall BluetoothFindNextDevice(ptr ptr)
 @ stub BluetoothFindNextProfileDescriptor
 @ stub BluetoothFindNextProtocolDescriptorStack
 @ stub BluetoothFindNextProtocolEntry
-@ stub BluetoothFindNextRadio
+@ stdcall BluetoothFindNextRadio(ptr ptr)
 @ stub BluetoothFindNextService
 @ stub BluetoothFindProfileDescriptorClose
 @ stub BluetoothFindProtocolDescriptorStackClose
 @ stub BluetoothFindProtocolEntryClose
-@ stub BluetoothFindRadioClose
+@ stdcall BluetoothFindRadioClose(ptr)
 @ stub BluetoothFindServiceClose
 @ stub BluetoothGATTAbortReliableWrite
 @ stub BluetoothGATTBeginReliableWrite
@@ -45,13 +45,13 @@
 @ stub BluetoothGATTUnregisterEvent
 @ stub BluetoothGetDeviceInfo
 @ stub BluetoothGetLocalServiceInfo
-@ stub BluetoothGetRadioInfo
+@ stdcall BluetoothGetRadioInfo(ptr ptr)
 @ stub BluetoothGetServicePnpInstance
 @ stub BluetoothIsConnectable
 @ stub BluetoothIsDiscoverable
 @ stub BluetoothIsVersionAvailable
 @ stub BluetoothRegisterForAuthentication
-@ stub BluetoothRegisterForAuthenticationEx
+@ stdcall BluetoothRegisterForAuthenticationEx(ptr ptr ptr ptr)
 @ stub BluetoothRemoveDevice
 @ stub BluetoothSdpEnumAttributes
 @ stub BluetoothSdpGetAttributeValue
@@ -63,7 +63,7 @@
 @ stub BluetoothSetLocalServiceInfo
 @ stub BluetoothSetServiceState
 @ stub BluetoothSetServiceStateEx
-@ stub BluetoothUnregisterAuthentication
+@ stdcall BluetoothUnregisterAuthentication(long)
 @ stub BluetoothUpdateDeviceRecord
 @ stub BthpCheckForUnsupportedGuid
 @ stub BthpCleanupBRDeviceNode
diff --git a/dlls/bthprops.cpl/main.c b/dlls/bluetoothapis/main.c
similarity index 78%
rename from dlls/bthprops.cpl/main.c
rename to dlls/bluetoothapis/main.c
index 2dcb18458b7..5d9087a9a47 100644
--- a/dlls/bthprops.cpl/main.c
+++ b/dlls/bluetoothapis/main.c
@@ -1,5 +1,5 @@
 /*
- * Bluetooth properties control panel
+ * Bluetooth APIs
  *
  * Copyright 2016 Austin English
  *
@@ -27,7 +27,7 @@
 #include "bthsdpdef.h"
 #include "bluetoothapis.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(bthpropscpl);
+WINE_DEFAULT_DEBUG_CHANNEL(bluetoothapis);
 
 /*********************************************************************
  *  BluetoothFindFirstDevice
@@ -99,3 +99,23 @@ BOOL WINAPI BluetoothFindNextDevice(HBLUETOOTH_DEVICE_FIND find, BLUETOOTH_DEVIC
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
     return FALSE;
 }
+
+/*********************************************************************
+ *  BluetoothRegisterForAuthenticationEx
+ */
+DWORD WINAPI BluetoothRegisterForAuthenticationEx(const BLUETOOTH_DEVICE_INFO *info, HBLUETOOTH_AUTHENTICATION_REGISTRATION *out,
+                                                  PFN_AUTHENTICATION_CALLBACK_EX callback, void *param)
+{
+    FIXME("(%p, %p, %p, %p): stub!\n", info, out, callback, param);
+    return ERROR_CALL_NOT_IMPLEMENTED;
+}
+
+/*********************************************************************
+ *  BluetoothUnregisterAuthentication
+ */
+BOOL WINAPI BluetoothUnregisterAuthentication(HBLUETOOTH_AUTHENTICATION_REGISTRATION handle)
+{
+    FIXME("(%p): stub!\n", handle);
+    if (!handle) SetLastError(ERROR_INVALID_HANDLE);
+    return FALSE;
+}
diff --git a/dlls/browseui/progressdlg.c b/dlls/browseui/progressdlg.c
index 11a973034fa..1e22ef636e1 100644
--- a/dlls/browseui/progressdlg.c
+++ b/dlls/browseui/progressdlg.c
@@ -457,10 +457,10 @@ static void update_time_remaining(ProgressDialog *This, ULONGLONG ullCompleted,
 
     if (i > 0 && remaining < 2 && remainder != 0)
         FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-               This->remainingMsg[1], 0, 0, line, ARRAY_SIZE(line), (__ms_va_list*)args);
+               This->remainingMsg[1], 0, 0, line, ARRAY_SIZE(line), (va_list *)args);
     else
         FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-               This->remainingMsg[0], 0, 0, line, ARRAY_SIZE(line), (__ms_va_list*)args);
+               This->remainingMsg[0], 0, 0, line, ARRAY_SIZE(line), (va_list *)args);
 
     set_buffer(&This->lines[2], line);
     This->dwUpdate |= UPDATE_LINE3;
diff --git a/dlls/bthprops.cpl/Makefile.in b/dlls/bthprops.cpl/Makefile.in
index 41dc9dfdb98..e1a3936fde9 100644
--- a/dlls/bthprops.cpl/Makefile.in
+++ b/dlls/bthprops.cpl/Makefile.in
@@ -1,4 +1,2 @@
-MODULE    = bthprops.cpl
-
-C_SRCS = \
-	main.c
+MODULE  = bthprops.cpl
+IMPORTS = bluetoothapis
diff --git a/dlls/bthprops.cpl/bthprops.cpl.spec b/dlls/bthprops.cpl/bthprops.cpl.spec
index 30b5bfa0040..1698344581e 100644
--- a/dlls/bthprops.cpl/bthprops.cpl.spec
+++ b/dlls/bthprops.cpl/bthprops.cpl.spec
@@ -11,38 +11,38 @@
 @ stub BluetoothEnumerateInstalledServicesEx
 @ stub BluetoothFindBrowseGroupClose
 @ stub BluetoothFindClassIdClose
-@ stdcall BluetoothFindDeviceClose(ptr)
+@ stdcall -import BluetoothFindDeviceClose(ptr)
 @ stub BluetoothFindFirstBrowseGroup
 @ stub BluetoothFindFirstClassId
-@ stdcall BluetoothFindFirstDevice(ptr ptr)
+@ stdcall -import BluetoothFindFirstDevice(ptr ptr)
 @ stub BluetoothFindFirstProfileDescriptor
 @ stub BluetoothFindFirstProtocolDescriptorStack
 @ stub BluetoothFindFirstProtocolEntry
-@ stdcall BluetoothFindFirstRadio(ptr ptr)
+@ stdcall -import BluetoothFindFirstRadio(ptr ptr)
 @ stub BluetoothFindFirstService
 @ stub BluetoothFindFirstServiceEx
 @ stub BluetoothFindNextBrowseGroup
 @ stub BluetoothFindNextClassId
-@ stdcall BluetoothFindNextDevice(ptr ptr)
+@ stdcall -import BluetoothFindNextDevice(ptr ptr)
 @ stub BluetoothFindNextProfileDescriptor
 @ stub BluetoothFindNextProtocolDescriptorStack
 @ stub BluetoothFindNextProtocolEntry
-@ stdcall BluetoothFindNextRadio(ptr ptr)
+@ stdcall -import BluetoothFindNextRadio(ptr ptr)
 @ stub BluetoothFindNextService
 @ stub BluetoothFindProfileDescriptorClose
 @ stub BluetoothFindProtocolDescriptorStackClose
 @ stub BluetoothFindProtocolEntryClose
-@ stdcall BluetoothFindRadioClose(ptr)
+@ stdcall -import BluetoothFindRadioClose(ptr)
 @ stub BluetoothFindServiceClose
 @ stub BluetoothGetDeviceInfo
-@ stdcall BluetoothGetRadioInfo(ptr ptr)
+@ stdcall -import BluetoothGetRadioInfo(ptr ptr)
 @ stub BluetoothIsConnectable
 @ stub BluetoothIsDiscoverable
 @ stub BluetoothIsVersionAvailable
 @ stub BluetoothMapClassOfDeviceToImageIndex
 @ stub BluetoothMapClassOfDeviceToString
 @ stub BluetoothRegisterForAuthentication
-@ stub BluetoothRegisterForAuthenticationEx
+@ stdcall -import BluetoothRegisterForAuthenticationEx(ptr ptr ptr ptr)
 @ stub BluetoothRemoveDevice
 @ stub BluetoothSdpEnumAttributes
 @ stub BluetoothSdpGetAttributeValue
@@ -55,7 +55,7 @@
 @ stub BluetoothSendAuthenticationResponseEx
 @ stub BluetoothSetLocalServiceInfo
 @ stub BluetoothSetServiceState
-@ stub BluetoothUnregisterAuthentication
+@ stdcall -import BluetoothUnregisterAuthentication(long)
 @ stub BluetoothUpdateDeviceRecord
 @ stub BthpEnableAllServices
 @ stub BthpFindPnpInfo
diff --git a/dlls/combase/combase.c b/dlls/combase/combase.c
index 0695bb77405..d834121e2ef 100644
--- a/dlls/combase/combase.c
+++ b/dlls/combase/combase.c
@@ -220,7 +220,7 @@ static HKEY create_classes_root_hkey(DWORD access)
 {
     HKEY hkey, ret = 0;
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING name;
+    UNICODE_STRING name = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Classes");
 
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
@@ -228,7 +228,6 @@ static HKEY create_classes_root_hkey(DWORD access)
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString(&name, L"\\Registry\\Machine\\Software\\Classes");
 
     if (create_key( &hkey, access, &attr )) return 0;
     TRACE( "%s -> %p\n", debugstr_w(attr.ObjectName->Buffer), hkey );
diff --git a/dlls/comctl32/comctl32.h b/dlls/comctl32/comctl32.h
index 7dfdf089eb1..faff3f30717 100644
--- a/dlls/comctl32/comctl32.h
+++ b/dlls/comctl32/comctl32.h
@@ -209,6 +209,7 @@ typedef struct
    SUBCLASSPROCS *SubclassProcs;
    SUBCLASSPROCS *stackpos;
    WNDPROC origproc;
+   int is_unicode;
    int running;
 } SUBCLASS_INFO, *LPSUBCLASS_INFO;
 
diff --git a/dlls/comctl32/commctrl.c b/dlls/comctl32/commctrl.c
index c5910b40869..4c5900bc37f 100644
--- a/dlls/comctl32/commctrl.c
+++ b/dlls/comctl32/commctrl.c
@@ -1103,12 +1103,9 @@ BOOL WINAPI SetWindowSubclass (HWND hWnd, SUBCLASSPROC pfnSubclass,
       SetPropW (hWnd, COMCTL32_wSubclass, stack);
 
       /* set window procedure to our own and save the current one */
-      if (IsWindowUnicode (hWnd))
-         stack->origproc = (WNDPROC)SetWindowLongPtrW (hWnd, GWLP_WNDPROC,
-                                                   (DWORD_PTR)COMCTL32_SubclassProc);
-      else
-         stack->origproc = (WNDPROC)SetWindowLongPtrA (hWnd, GWLP_WNDPROC,
-                                                   (DWORD_PTR)COMCTL32_SubclassProc);
+      stack->is_unicode = IsWindowUnicode (hWnd);
+      stack->origproc = (WNDPROC)SetWindowLongPtrW (hWnd, GWLP_WNDPROC,
+                                                (DWORD_PTR)COMCTL32_SubclassProc);
    }
    else {
       /* Check to see if we have called this function with the same uIDSubClass
@@ -1127,7 +1124,7 @@ BOOL WINAPI SetWindowSubclass (HWND hWnd, SUBCLASSPROC pfnSubclass,
    proc = Alloc(sizeof(SUBCLASSPROCS));
    if (!proc) {
       ERR ("Failed to allocate subclass entry in stack\n");
-      if (IsWindowUnicode (hWnd))
+      if (stack->is_unicode)
          SetWindowLongPtrW (hWnd, GWLP_WNDPROC, (DWORD_PTR)stack->origproc);
       else
          SetWindowLongPtrA (hWnd, GWLP_WNDPROC, (DWORD_PTR)stack->origproc);
@@ -1246,7 +1243,9 @@ BOOL WINAPI RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR u
    if (!stack->SubclassProcs && !stack->running) {
       TRACE("Last Subclass removed, cleaning up\n");
       /* clean up our heap and reset the original window procedure */
-      if (IsWindowUnicode (hWnd))
+      if ((WNDPROC)GetWindowLongPtrW (hWnd, GWLP_WNDPROC) != COMCTL32_SubclassProc)
+         WARN("Window procedure has been modified, skipping restore\n");
+      else if (stack->is_unicode)
          SetWindowLongPtrW (hWnd, GWLP_WNDPROC, (DWORD_PTR)stack->origproc);
       else
          SetWindowLongPtrA (hWnd, GWLP_WNDPROC, (DWORD_PTR)stack->origproc);
@@ -1288,7 +1287,7 @@ static LRESULT WINAPI COMCTL32_SubclassProc (HWND hWnd, UINT uMsg, WPARAM wParam
    if (!stack->SubclassProcs && !stack->running) {
       TRACE("Last Subclass removed, cleaning up\n");
       /* clean up our heap and reset the original window procedure */
-      if (IsWindowUnicode (hWnd))
+      if (stack->is_unicode)
          SetWindowLongPtrW (hWnd, GWLP_WNDPROC, (DWORD_PTR)stack->origproc);
       else
          SetWindowLongPtrA (hWnd, GWLP_WNDPROC, (DWORD_PTR)stack->origproc);
@@ -1331,10 +1330,7 @@ LRESULT WINAPI DefSubclassProc (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lPar
    /* If we are at the end of stack then we have to call the original
     * window procedure */
    if (!stack->stackpos) {
-      if (IsWindowUnicode (hWnd))
-         ret = CallWindowProcW (stack->origproc, hWnd, uMsg, wParam, lParam);
-      else
-         ret = CallWindowProcA (stack->origproc, hWnd, uMsg, wParam, lParam);
+      ret = CallWindowProcW (stack->origproc, hWnd, uMsg, wParam, lParam);
    } else {
       const SUBCLASSPROCS *proc = stack->stackpos;
       stack->stackpos = stack->stackpos->next; 
diff --git a/dlls/comctl32/header.c b/dlls/comctl32/header.c
index 191a314bcd8..1e2d957b93e 100644
--- a/dlls/comctl32/header.c
+++ b/dlls/comctl32/header.c
@@ -1465,7 +1465,6 @@ HEADER_InsertItemT (HEADER_INFO *infoPtr, INT nItem, const HDITEMW *phdi, BOOL b
 static LRESULT
 HEADER_Layout (HEADER_INFO *infoPtr, LPHDLAYOUT lpLayout)
 {
-    lpLayout->pwpos->hwnd = infoPtr->hwndSelf;
     lpLayout->pwpos->hwndInsertAfter = 0;
     lpLayout->pwpos->x = lpLayout->prc->left;
     lpLayout->pwpos->y = lpLayout->prc->top;
diff --git a/dlls/comctl32/listview.c b/dlls/comctl32/listview.c
index 07bea8574b6..750e447dbef 100644
--- a/dlls/comctl32/listview.c
+++ b/dlls/comctl32/listview.c
@@ -11184,7 +11184,7 @@ static void LISTVIEW_UpdateSize(LISTVIEW_INFO *infoPtr)
 	    wp.cy = 0;
 	}
 
-	SetWindowPos(wp.hwnd, wp.hwndInsertAfter, wp.x, wp.y, wp.cx, wp.cy, wp.flags);
+	SetWindowPos(infoPtr->hwndHeader, wp.hwndInsertAfter, wp.x, wp.y, wp.cx, wp.cy, wp.flags);
 	TRACE("  after SWP wp=%d,%d (%dx%d)\n", wp.x, wp.y, wp.cx, wp.cy);
 
 	infoPtr->rcList.top = max(wp.cy, 0);
@@ -11212,6 +11212,7 @@ static INT LISTVIEW_StyleChanged(LISTVIEW_INFO *infoPtr, WPARAM wStyleType,
                                  const STYLESTRUCT *lpss)
 {
     UINT uNewView, uOldView;
+    BOOL repaint = FALSE;
     UINT style;
 
     TRACE("styletype %Ix, styleOld %#lx, styleNew %#lx\n",
@@ -11236,6 +11237,8 @@ static INT LISTVIEW_StyleChanged(LISTVIEW_INFO *infoPtr, WPARAM wStyleType,
     {
     	HIMAGELIST himl;
 
+        repaint = TRUE;
+
         /* LVM_SETVIEW doesn't change window style bits within LVS_TYPEMASK,
            changing style updates current view only when view bits change. */
         map_style_view(infoPtr);
@@ -11297,6 +11300,9 @@ static INT LISTVIEW_StyleChanged(LISTVIEW_INFO *infoPtr, WPARAM wStyleType,
     /* add scrollbars if needed */
     LISTVIEW_UpdateScroll(infoPtr);
 
+    if (repaint)
+        LISTVIEW_InvalidateList(infoPtr);
+
     return 0;
 }
 
diff --git a/dlls/comctl32/tests/header.c b/dlls/comctl32/tests/header.c
index 7261da2a5f3..c027d292385 100644
--- a/dlls/comctl32/tests/header.c
+++ b/dlls/comctl32/tests/header.c
@@ -873,9 +873,12 @@ static void test_hdm_layout(HWND hParent)
     ok_sequence(sequences, PARENT_SEQ_INDEX, add_header_to_parent_seq,
                                     "adder header control to parent", FALSE);
 
+    windowPos.hwnd = (HWND)0xdeadbeef;
     flush_sequences(sequences, NUM_MSG_SEQUENCES);
     retVal = SendMessageA(hChild, HDM_LAYOUT, 0, (LPARAM) &hdLayout);
     expect(TRUE, retVal);
+    ok(windowPos.hwnd == (HWND)0xdeadbeef, "Unexpected value %p.\n", windowPos.hwnd);
+    ok(!windowPos.hwndInsertAfter, "Unexpected value %p.\n", windowPos.hwndInsertAfter);
 
     ok_sequence(sequences, HEADER_SEQ_INDEX, layout_seq, "layout sequence testing", FALSE);
 
@@ -1884,6 +1887,7 @@ START_TEST(header)
     test_hdf_fixedwidth(parent_hwnd);
     test_hds_nosizing(parent_hwnd);
     test_item_auto_format(parent_hwnd);
+    test_hdm_layout(parent_hwnd);
 
     unload_v6_module(ctx_cookie, hCtx);
 
diff --git a/dlls/comctl32/tests/misc.c b/dlls/comctl32/tests/misc.c
index 5613fba15f5..d128c202c67 100644
--- a/dlls/comctl32/tests/misc.c
+++ b/dlls/comctl32/tests/misc.c
@@ -1021,6 +1021,15 @@ static const struct message wm_stylechanged_combox_seq[] =
     {0}
 };
 
+static const struct message wm_stylechanged_listview_report_seq[] =
+{
+    {WM_STYLECHANGED, sent},
+    {WM_ERASEBKGND, sent | defwinproc},
+    {WM_PAINT, sent},
+    {WM_ERASEBKGND, sent | defwinproc},
+    {0}
+};
+
 static const struct message wm_stylechanged_pager_seq[] =
 {
     {WM_STYLECHANGED, sent},
@@ -1081,37 +1090,39 @@ static void test_WM_STYLECHANGED(void)
     static const struct test
     {
         const CHAR *class_name;
+        DWORD add_style;
         const struct message *seq;
         BOOL todo;
     }
     tests[] =
     {
-        {ANIMATE_CLASSA, wm_stylechanged_seq},
-        {WC_BUTTONA, wm_stylechanged_seq},
-        {WC_COMBOBOXA, wm_stylechanged_combox_seq, TRUE},
-        {WC_COMBOBOXEXA, wm_stylechanged_seq},
-        {DATETIMEPICK_CLASSA, wm_stylechanged_seq},
-        {WC_EDITA, wm_stylechanged_seq},
-        {WC_HEADERA, wm_stylechanged_repaint_seq, TRUE},
-        {HOTKEY_CLASSA, wm_stylechanged_seq},
-        {WC_IPADDRESSA, wm_stylechanged_seq},
-        {WC_LISTBOXA, wm_stylechanged_repaint_seq, TRUE},
-        {WC_LISTVIEWA, wm_stylechanged_seq},
-        {MONTHCAL_CLASSA, wm_stylechanged_repaint_seq, TRUE},
-        {WC_NATIVEFONTCTLA, wm_stylechanged_seq},
-        {WC_PAGESCROLLERA, wm_stylechanged_pager_seq, TRUE},
-        {PROGRESS_CLASSA, wm_stylechanged_progress_seq},
-        {REBARCLASSNAMEA, wm_stylechanged_seq},
-        {WC_STATICA, wm_stylechanged_seq},
-        {STATUSCLASSNAMEA, wm_stylechanged_seq},
-        {"SysLink", wm_stylechanged_seq},
-        {WC_TABCONTROLA, wm_stylechanged_seq},
-        {TOOLBARCLASSNAMEA, wm_stylechanged_seq},
-        {TOOLTIPS_CLASSA, wm_stylechanged_seq},
-        {TRACKBAR_CLASSA, wm_stylechanged_trackbar_seq, TRUE},
-        {WC_TREEVIEWA, wm_stylechanged_seq},
-        {UPDOWN_CLASSA, wm_stylechanged_seq},
-        {WC_SCROLLBARA, wm_stylechanged_seq},
+        {ANIMATE_CLASSA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_BUTTONA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_COMBOBOXA, WS_TABSTOP, wm_stylechanged_combox_seq, TRUE},
+        {WC_COMBOBOXEXA, WS_TABSTOP, wm_stylechanged_seq},
+        {DATETIMEPICK_CLASSA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_EDITA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_HEADERA, WS_TABSTOP, wm_stylechanged_repaint_seq, TRUE},
+        {HOTKEY_CLASSA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_IPADDRESSA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_LISTBOXA, WS_TABSTOP, wm_stylechanged_repaint_seq, TRUE},
+        {WC_LISTVIEWA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_LISTVIEWA, LVS_REPORT, wm_stylechanged_listview_report_seq, TRUE},
+        {MONTHCAL_CLASSA, WS_TABSTOP, wm_stylechanged_repaint_seq, TRUE},
+        {WC_NATIVEFONTCTLA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_PAGESCROLLERA, WS_TABSTOP, wm_stylechanged_pager_seq, TRUE},
+        {PROGRESS_CLASSA, WS_TABSTOP, wm_stylechanged_progress_seq},
+        {REBARCLASSNAMEA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_STATICA, WS_TABSTOP, wm_stylechanged_seq},
+        {STATUSCLASSNAMEA, WS_TABSTOP, wm_stylechanged_seq},
+        {"SysLink", WS_TABSTOP, wm_stylechanged_seq},
+        {WC_TABCONTROLA, WS_TABSTOP, wm_stylechanged_seq},
+        {TOOLBARCLASSNAMEA, WS_TABSTOP, wm_stylechanged_seq},
+        {TOOLTIPS_CLASSA, WS_TABSTOP, wm_stylechanged_seq},
+        {TRACKBAR_CLASSA, WS_TABSTOP, wm_stylechanged_trackbar_seq, TRUE},
+        {WC_TREEVIEWA, WS_TABSTOP, wm_stylechanged_seq},
+        {UPDOWN_CLASSA, WS_TABSTOP, wm_stylechanged_seq},
+        {WC_SCROLLBARA, WS_TABSTOP, wm_stylechanged_seq},
     };
 
     parent = CreateWindowA(WC_STATICA, "parent", WS_POPUP | WS_VISIBLE, 100, 100, 100, 100,
@@ -1137,7 +1148,7 @@ static void test_WM_STYLECHANGED(void)
         flush_sequences(sequences, NUM_MSG_SEQUENCES);
 
         style.styleOld = GetWindowLongA(hwnd, GWL_STYLE);
-        style.styleNew = style.styleOld | WS_TABSTOP;
+        style.styleNew = style.styleOld | tests[i].add_style;
         SendMessageA(hwnd, WM_STYLECHANGED, GWL_STYLE, (LPARAM)&style);
         flush_events();
         ok_sequence(sequences, CHILD_SEQ_INDEX, tests[i].seq, "WM_STYLECHANGED", tests[i].todo);
diff --git a/dlls/comctl32/tests/subclass.c b/dlls/comctl32/tests/subclass.c
index e2e8573f4c0..bc3fc6f1d91 100644
--- a/dlls/comctl32/tests/subclass.c
+++ b/dlls/comctl32/tests/subclass.c
@@ -34,9 +34,14 @@ static BOOL (WINAPI *pSetWindowSubclass)(HWND, SUBCLASSPROC, UINT_PTR, DWORD_PTR
 static BOOL (WINAPI *pRemoveWindowSubclass)(HWND, SUBCLASSPROC, UINT_PTR);
 static LRESULT (WINAPI *pDefSubclassProc)(HWND, UINT, WPARAM, LPARAM);
 
+#define IS_WNDPROC_HANDLE(x) (((ULONG_PTR)(x) >> 16) == (~0u >> 16))
+
 #define SEND_NEST   0x01
 #define DELETE_SELF 0x02
 #define DELETE_PREV 0x04
+#define EXPECT_UNICODE    0x10
+#define EXPECT_WNDPROC_1  0x20
+#define EXPECT_WNDPROC_3  0x40
 
 struct message {
     int procnum;           /* WndProc id message is expected from */
@@ -166,15 +171,47 @@ static void ok_sequence(const struct message *expected, const char *context)
     flush_sequence();
 }
 
+static LRESULT WINAPI wnd_proc_1(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
+static LRESULT WINAPI wnd_proc_3(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
+
+#define check_unicode(a, b) check_unicode_(__LINE__, a, b)
+static void check_unicode_(int line, HWND hwnd, DWORD flags)
+{
+    WNDPROC proc;
+    BOOL ret;
+
+    ret = IsWindowUnicode(hwnd);
+    ok_(__FILE__, line)(ret == !!(flags & EXPECT_UNICODE), "IsWindowUnicode returned %u\n", ret);
+
+    proc = (WNDPROC)GetWindowLongPtrW(hwnd, GWLP_WNDPROC);
+    ok_(__FILE__, line)(IS_WNDPROC_HANDLE(proc) == !(flags & EXPECT_UNICODE), "got proc %p\n", proc);
+
+    proc = (WNDPROC)GetWindowLongPtrA(hwnd, GWLP_WNDPROC);
+    if (flags & EXPECT_UNICODE)
+        ok_(__FILE__, line)(IS_WNDPROC_HANDLE(proc), "got proc %p\n", proc);
+    else if (flags & EXPECT_WNDPROC_1)
+        ok_(__FILE__, line)(proc == wnd_proc_1, "got proc %p\n", proc);
+    else if (flags & EXPECT_WNDPROC_3)
+        ok_(__FILE__, line)(proc == wnd_proc_3, "got proc %p\n", proc);
+    else
+        ok_(__FILE__, line)(!IS_WNDPROC_HANDLE(proc), "got proc %p\n", proc);
+}
+
 static LRESULT WINAPI wnd_proc_1(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 {
+    DWORD flags = GetWindowLongA(hwnd, GWLP_USERDATA);
     struct message msg;
+
+    check_unicode(hwnd, flags);
     
     if(message == WM_USER) {
         msg.wParam = wParam;
         msg.procnum = 1;
         add_message(&msg);
     }
+    if (message == WM_CHAR) {
+        ok(!(wParam & ~0xff), "got wParam %#Ix\n", wParam);
+    }
     return DefWindowProcA(hwnd, message, wParam, lParam);
 }
 
@@ -194,7 +231,10 @@ static LRESULT WINAPI wnd_proc_3(HWND hwnd, UINT message, WPARAM wParam, LPARAM
 
 static LRESULT WINAPI wnd_proc_sub(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uldSubclass, DWORD_PTR dwRefData)
 {
+    DWORD flags = GetWindowLongA(hwnd, GWLP_USERDATA);
     struct message msg;
+
+    check_unicode(hwnd, flags);
     
     if(message == WM_USER) {
         msg.wParam = wParam;
@@ -205,13 +245,23 @@ static LRESULT WINAPI wnd_proc_sub(HWND hwnd, UINT message, WPARAM wParam, LPARA
             if(dwRefData & DELETE_SELF) {
                 pRemoveWindowSubclass(hwnd, wnd_proc_sub, uldSubclass);
                 pRemoveWindowSubclass(hwnd, wnd_proc_sub, uldSubclass);
+                check_unicode(hwnd, flags);
             }
             if(dwRefData & DELETE_PREV)
+            {
                 pRemoveWindowSubclass(hwnd, wnd_proc_sub, uldSubclass-1);
+                check_unicode(hwnd, flags);
+            }
             if(dwRefData & SEND_NEST)
+            {
                 SendMessageA(hwnd, WM_USER, wParam+1, 0);
+                check_unicode(hwnd, flags);
+            }
         }
     }
+    if (message == WM_CHAR) {
+        ok(wParam == 0x30c2, "got wParam %#Ix\n", wParam);
+    }
     return pDefSubclassProc(hwnd, message, wParam, lParam);
 }
 
@@ -221,17 +271,27 @@ static void test_subclass(void)
     HWND hwnd = CreateWindowExA(0, "TestSubclass", "Test subclass", WS_OVERLAPPEDWINDOW,
                            100, 100, 200, 200, 0, 0, 0, NULL);
     ok(hwnd != NULL, "failed to create test subclass wnd\n");
+    check_unicode(hwnd, EXPECT_WNDPROC_1);
+    SetWindowLongA(hwnd, GWLP_USERDATA, EXPECT_WNDPROC_1);
 
     ret = pSetWindowSubclass(hwnd, wnd_proc_sub, 2, 0);
     ok(ret == TRUE, "Expected TRUE\n");
+    check_unicode(hwnd, EXPECT_UNICODE);
+    SetWindowLongA(hwnd, GWLP_USERDATA, EXPECT_UNICODE);
+
     SendMessageA(hwnd, WM_USER, 1, 0);
     SendMessageA(hwnd, WM_USER, 2, 0);
     ok_sequence(Sub_BasicTest, "Basic");
+    SendMessageW(hwnd, WM_CHAR, 0x30c2, 1);
 
     ret = pSetWindowSubclass(hwnd, wnd_proc_sub, 2, DELETE_SELF);
     ok(ret == TRUE, "Expected TRUE\n");
+    check_unicode(hwnd, EXPECT_UNICODE);
+
     SendMessageA(hwnd, WM_USER, 1, 1);
     ok_sequence(Sub_DeletedTest, "Deleted");
+    check_unicode(hwnd, EXPECT_WNDPROC_1);
+    SetWindowLongA(hwnd, GWLP_USERDATA, EXPECT_WNDPROC_1);
 
     SendMessageA(hwnd, WM_USER, 1, 0);
     ok_sequence(Sub_AfterDeletedTest, "After Deleted");
@@ -239,15 +299,22 @@ static void test_subclass(void)
     ret = pSetWindowSubclass(hwnd, wnd_proc_sub, 2, 0);
     ok(ret == TRUE, "Expected TRUE\n");
     orig_proc_3 = (WNDPROC)SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LONG_PTR)wnd_proc_3);
+    check_unicode(hwnd, EXPECT_WNDPROC_3);
+    SetWindowLongA(hwnd, GWLP_USERDATA, EXPECT_WNDPROC_3);
+
     SendMessageA(hwnd, WM_USER, 1, 0);
     SendMessageA(hwnd, WM_USER, 2, 0);
     ok_sequence(Sub_OldAfterNewTest, "Old after New");
 
     ret = pSetWindowSubclass(hwnd, wnd_proc_sub, 4, 0);
     ok(ret == TRUE, "Expected TRUE\n");
+    check_unicode(hwnd, EXPECT_WNDPROC_3);
+
     SendMessageA(hwnd, WM_USER, 1, 0);
     ok_sequence(Sub_MixTest, "Mix");
 
+    check_unicode(hwnd, EXPECT_WNDPROC_3);
+
     /* Now the fun starts */
     ret = pSetWindowSubclass(hwnd, wnd_proc_sub, 4, SEND_NEST);
     ok(ret == TRUE, "Expected TRUE\n");
@@ -275,6 +342,8 @@ static void test_subclass(void)
     pRemoveWindowSubclass(hwnd, wnd_proc_sub, 2);
     pRemoveWindowSubclass(hwnd, wnd_proc_sub, 5);
 
+    check_unicode(hwnd, EXPECT_WNDPROC_3);
+
     DestroyWindow(hwnd);
 }
 
diff --git a/dlls/comdlg32/fontdlg.c b/dlls/comdlg32/fontdlg.c
index 4bf041e85b3..6eb7e65c05b 100644
--- a/dlls/comdlg32/fontdlg.c
+++ b/dlls/comdlg32/fontdlg.c
@@ -1108,8 +1108,7 @@ static LRESULT CFn_WMCommand(HWND hDlg, WPARAM wParam, LPARAM lParam, LPCHOOSEFO
             args[0] = lpcf->nSizeMin;
             args[1] = lpcf->nSizeMax;
             FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                           format, 0, 0, msgW, ARRAY_SIZE(msgW),
-                           (__ms_va_list*)args);
+                           format, 0, 0, msgW, ARRAY_SIZE(msgW), (va_list *)args);
             MessageBoxW(hDlg, msgW, NULL, MB_OK);
         }
         return(TRUE);
diff --git a/dlls/comdlg32/printdlg.c b/dlls/comdlg32/printdlg.c
index bb9a9f78330..dcc80433ecb 100644
--- a/dlls/comdlg32/printdlg.c
+++ b/dlls/comdlg32/printdlg.c
@@ -696,9 +696,7 @@ static BOOL PRINTDLG_UpdatePrintDlgW(HWND hDlg,
                 args[0] = lppd->nMinPage;
                 args[1] = lppd->nMaxPage;
                 FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                               resourcestr, 0, 0, resultstr,
-                               ARRAY_SIZE(resultstr),
-                               (__ms_va_list*)args);
+                               resourcestr, 0, 0, resultstr, ARRAY_SIZE(resultstr), (va_list *)args);
 		LoadStringW(COMDLG32_hInstance, PD32_PRINT_TITLE,
 			    resourcestr, 255);
 		MessageBoxW(hDlg, resultstr, resourcestr,
diff --git a/dlls/commdlg.dll16/filedlg.c b/dlls/commdlg.dll16/filedlg.c
index 2631febb6ae..b292561b077 100644
--- a/dlls/commdlg.dll16/filedlg.c
+++ b/dlls/commdlg.dll16/filedlg.c
@@ -249,8 +249,8 @@ static UINT_PTR CALLBACK call_hook_proc( WNDPROC16 hook, HWND hwnd, UINT msg, WP
             CREATESTRUCT16 cs;
 
             CREATESTRUCT32Ato16( cs32, &cs );
-            cs.lpszName  = MapLS( cs32->lpszName );
-            cs.lpszClass = MapLS( cs32->lpszClass );
+            cs.lpszName  = MapLS( (void *)cs32->lpszName );
+            cs.lpszClass = MapLS( (void *)cs32->lpszClass );
             lp = MapLS( &cs );
             ret = call_hook16( hook, hwnd, msg, wp, lp );
             UnMapLS( lp );
diff --git a/dlls/crypt32/tests/store.c b/dlls/crypt32/tests/store.c
index 20d10a110f9..8809c5048b4 100644
--- a/dlls/crypt32/tests/store.c
+++ b/dlls/crypt32/tests/store.c
@@ -391,7 +391,7 @@ static void testRegStoreSavedCerts(void)
         cert1 = CertCreateCertificateContext(X509_ASN_ENCODING, bigCert, sizeof(bigCert));
         ok (cert1 != NULL, "Create cert context failed at %ld, %lx\n", i, GetLastError());
         ret = CertAddCertificateContextToStore(store, cert1, CERT_STORE_ADD_REPLACE_EXISTING, NULL);
-        /* Addittional skip per Win7, it allows opening HKLM store, but disallows adding certs */
+        /* Additional skip per Win7, it allows opening HKLM store, but disallows adding certs */
         err = GetLastError();
         if (!ret)
         {
diff --git a/dlls/cryptnet/cryptnet_main.c b/dlls/cryptnet/cryptnet_main.c
index 516bbad9ca4..75fa4028d12 100644
--- a/dlls/cryptnet/cryptnet_main.c
+++ b/dlls/cryptnet/cryptnet_main.c
@@ -1537,11 +1537,17 @@ BOOL WINAPI CryptRetrieveObjectByUrlW(LPCWSTR pszURL, LPCSTR pszObjectOid,
 
 static const char revocation_cache_signature[] = "Wine cached revocation";
 
-static FILE *open_cached_revocation_file(const CRYPT_INTEGER_BLOB *serial, const WCHAR *mode, int sharing)
+#define CACHED_CERT_HASH_SIZE 20
+
+static FILE *open_cached_revocation_file(const CERT_CONTEXT *cert, const CERT_REVOCATION_PARA *params,
+        const WCHAR *mode, int sharing)
 {
+    BYTE hash_data[CACHED_CERT_HASH_SIZE];
     WCHAR path[MAX_PATH];
     WCHAR *appdata_path;
-    DWORD len, i;
+    DWORD len, i, size;
+    HCRYPTPROV prov;
+    HCRYPTHASH hash;
     HRESULT hr;
 
     if (FAILED(hr = SHGetKnownFolderPath(&FOLDERID_LocalAppDataLow, 0, NULL, &appdata_path)))
@@ -1553,24 +1559,42 @@ static FILE *open_cached_revocation_file(const CRYPT_INTEGER_BLOB *serial, const
     len = swprintf(path, ARRAY_SIZE(path), L"%s\\Microsoft\\CryptnetUrlCache\\Content\\", appdata_path);
     CoTaskMemFree(appdata_path);
 
-    if (len + serial->cbData * 2 * sizeof(WCHAR) > ARRAY_SIZE(path) - 1)
+    if (len + CACHED_CERT_HASH_SIZE * 2 * sizeof(WCHAR) > ARRAY_SIZE(path) - 1)
     {
-        WARN("Serial length exceeds static buffer; not caching.\n");
+        WARN("Hash length exceeds static buffer; not caching.\n");
         return INVALID_HANDLE_VALUE;
     }
 
+    CryptAcquireContextW(&prov, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
+    CryptCreateHash(prov, CALG_SHA1, 0, 0, &hash);
+    CryptHashData(hash, cert->pbCertEncoded, cert->cbCertEncoded, 0);
+    if (params && params->pIssuerCert)
+    {
+        CryptHashData(hash, (BYTE *)&params->pIssuerCert->cbCertEncoded, sizeof(params->pIssuerCert->cbCertEncoded), 0);
+        CryptHashData(hash, params->pIssuerCert->pbCertEncoded, params->pIssuerCert->cbCertEncoded, 0);
+    }
+    else
+    {
+        size = 0;
+        CryptHashData(hash, (BYTE *)&size, sizeof(size), 0);
+    }
+    size = sizeof(hash_data);
+    CryptGetHashParam(hash, HP_HASHVAL, hash_data, &size, 0);
+    CryptDestroyHash(hash);
+    CryptReleaseContext(prov, 0);
+
     SHCreateDirectoryExW(NULL, path, NULL);
 
-    for (i = 0; i < serial->cbData; ++i)
+    for (i = 0; i < CACHED_CERT_HASH_SIZE; ++i)
     {
-        swprintf(path + len, 3, L"%02x", serial->pbData[i]);
+        swprintf(path + len, 3, L"%02x", hash_data[i]);
         len += 2;
     }
 
     return _wfsopen(path, mode, sharing);
 }
 
-static BOOL find_cached_revocation_status(const CRYPT_INTEGER_BLOB *serial,
+static BOOL find_cached_revocation_status(const CERT_CONTEXT *cert, const CERT_REVOCATION_PARA *params,
         const FILETIME *time, CERT_REVOCATION_STATUS *status)
 {
     char buffer[sizeof(revocation_cache_signature)];
@@ -1578,7 +1602,7 @@ static BOOL find_cached_revocation_status(const CRYPT_INTEGER_BLOB *serial,
     FILE *file;
     int len;
 
-    if (!(file = open_cached_revocation_file(serial, L"rb", _SH_DENYWR)))
+    if (!(file = open_cached_revocation_file(cert, params, L"rb", _SH_DENYWR)))
         return FALSE;
 
     if ((len = fread(buffer, 1, sizeof(buffer), file)) != sizeof(buffer)
@@ -1621,12 +1645,12 @@ static BOOL find_cached_revocation_status(const CRYPT_INTEGER_BLOB *serial,
     return TRUE;
 }
 
-static void cache_revocation_status(const CRYPT_INTEGER_BLOB *serial,
+static void cache_revocation_status(const CERT_CONTEXT *cert, const CERT_REVOCATION_PARA *params,
         const FILETIME *time, const CERT_REVOCATION_STATUS *status)
 {
     FILE *file;
 
-    if (!(file = open_cached_revocation_file(serial, L"wb", _SH_DENYRW)))
+    if (!(file = open_cached_revocation_file(cert, params, L"wb", _SH_DENYRW)))
         return;
     fwrite(revocation_cache_signature, 1, sizeof(revocation_cache_signature), file);
     fwrite(time, sizeof(*time), 1, file);
@@ -1683,7 +1707,8 @@ static const CRL_CONTEXT *retrieve_crl_from_dist_points(const CRYPT_URL_ARRAY *a
 }
 
 static DWORD verify_cert_revocation_from_dist_points_ext(const CRYPT_DATA_BLOB *value, const CERT_CONTEXT *cert,
-        FILETIME *time, DWORD flags, const CERT_REVOCATION_PARA *params, CERT_REVOCATION_STATUS *status)
+        FILETIME *time, DWORD flags, const CERT_REVOCATION_PARA *params, CERT_REVOCATION_STATUS *status,
+        FILETIME *next_update)
 {
     DWORD url_array_size, error;
     CRYPT_URL_ARRAY *url_array;
@@ -1719,7 +1744,7 @@ static DWORD verify_cert_revocation_from_dist_points_ext(const CRYPT_DATA_BLOB *
 
     error = verify_cert_revocation_with_crl_online(cert, crl, time, status);
 
-    cache_revocation_status(&cert->pCertInfo->SerialNumber, &crl->pCrlInfo->NextUpdate, status);
+    *next_update = crl->pCrlInfo->NextUpdate;
 
     CertFreeCRLContext(crl);
     CryptMemFree(url_array);
@@ -1920,12 +1945,11 @@ static DWORD check_ocsp_response_info(const CERT_INFO *cert, const CERT_INFO *is
 }
 
 static DWORD verify_signed_ocsp_response_info(const CERT_INFO *cert, const CERT_INFO *issuer,
-                                              const CRYPT_OBJID_BLOB *blob)
+                                              const CRYPT_OBJID_BLOB *blob, FILETIME *next_update)
 {
     OCSP_BASIC_SIGNED_RESPONSE_INFO *info;
     DWORD size, error, status = CRYPT_E_REVOCATION_OFFLINE;
     CRYPT_ALGORITHM_IDENTIFIER *alg;
-    FILETIME next_update;
     CRYPT_BIT_BLOB *sig;
     HCRYPTPROV prov = 0;
     HCRYPTHASH hash = 0;
@@ -1935,7 +1959,7 @@ static DWORD verify_signed_ocsp_response_info(const CERT_INFO *cert, const CERT_
     if (!CryptDecodeObjectEx(X509_ASN_ENCODING, OCSP_BASIC_SIGNED_RESPONSE, blob->pbData, blob->cbData,
                              CRYPT_DECODE_ALLOC_FLAG, NULL, &info, &size)) return GetLastError();
 
-    if ((error = check_ocsp_response_info(cert, issuer, &info->ToBeSigned, &status, &next_update))) goto done;
+    if ((error = check_ocsp_response_info(cert, issuer, &info->ToBeSigned, &status, next_update))) goto done;
 
     alg = &info->SignatureInfo.SignatureAlgorithm;
     if (!alg->pszObjId || !(algid = CertOIDToAlgId(alg->pszObjId)))
@@ -1964,16 +1988,6 @@ static DWORD verify_signed_ocsp_response_info(const CERT_INFO *cert, const CERT_
     else error = ERROR_SUCCESS;
 
 done:
-    if (next_update.dwLowDateTime || next_update.dwHighDateTime)
-    {
-        CERT_REVOCATION_STATUS rev_status;
-
-        memset(&rev_status, 0, sizeof(rev_status));
-        rev_status.cbSize = sizeof(rev_status);
-        rev_status.dwError = status;
-        cache_revocation_status(&cert->SerialNumber, &next_update, &rev_status);
-    }
-
     CryptDestroyKey(key);
     CryptDestroyHash(hash);
     CryptReleaseContext(prov, 0);
@@ -1983,7 +1997,7 @@ done:
 }
 
 static DWORD handle_ocsp_response(const CERT_INFO *cert, const CERT_INFO *issuer, const BYTE *encoded,
-                                  DWORD encoded_size)
+                                  DWORD encoded_size, FILETIME *next_update)
 {
     OCSP_RESPONSE_INFO *info;
     DWORD size, error = CRYPT_E_NO_REVOCATION_CHECK;
@@ -1999,7 +2013,7 @@ static DWORD handle_ocsp_response(const CERT_INFO *cert, const CERT_INFO *issuer
             FIXME("unhandled response type %s\n", debugstr_a(info->pszObjId));
             break;
         }
-        error = verify_signed_ocsp_response_info(cert, issuer, &info->Value);
+        error = verify_signed_ocsp_response_info(cert, issuer, &info->Value, next_update);
         break;
 
     default:
@@ -2012,7 +2026,7 @@ static DWORD handle_ocsp_response(const CERT_INFO *cert, const CERT_INFO *issuer
 }
 
 static DWORD verify_cert_revocation_with_ocsp(const CERT_CONTEXT *cert, const WCHAR *base_url,
-                                              const CERT_REVOCATION_PARA *revpara)
+                                              const CERT_REVOCATION_PARA *revpara, FILETIME *next_update)
 {
     HINTERNET ses, con, req = NULL;
     BYTE *request_data = NULL, *response_data = NULL;
@@ -2081,7 +2095,8 @@ static DWORD verify_cert_revocation_with_ocsp(const CERT_CONTEXT *cert, const WC
         !response_len || !(response_data = malloc(response_len)) ||
         !InternetReadFile(req, response_data, response_len, &count) || count != response_len) goto done;
 
-    ret = handle_ocsp_response(cert->pCertInfo, revpara->pIssuerCert->pCertInfo, response_data, response_len);
+    ret = handle_ocsp_response(cert->pCertInfo, revpara->pIssuerCert->pCertInfo, response_data, response_len,
+                               next_update);
 
 done:
     free(url);
@@ -2093,7 +2108,8 @@ done:
 }
 
 static DWORD verify_cert_revocation_from_aia_ext(const CRYPT_DATA_BLOB *value, const CERT_CONTEXT *cert,
-        FILETIME *pTime, DWORD dwFlags, CERT_REVOCATION_PARA *pRevPara, CERT_REVOCATION_STATUS *pRevStatus)
+        FILETIME *pTime, DWORD dwFlags, CERT_REVOCATION_PARA *pRevPara, CERT_REVOCATION_STATUS *pRevStatus,
+        FILETIME *next_update)
 {
     BOOL ret;
     DWORD size, i, error = CRYPT_E_NO_REVOCATION_CHECK;
@@ -2111,7 +2127,7 @@ static DWORD verify_cert_revocation_from_aia_ext(const CRYPT_DATA_BLOB *value, c
             {
                 const WCHAR *url = aia->rgAccDescr[i].AccessLocation.u.pwszURL;
                 TRACE("OCSP URL = %s\n", debugstr_w(url));
-                error = verify_cert_revocation_with_ocsp(cert, url, pRevPara);
+                error = verify_cert_revocation_with_ocsp(cert, url, pRevPara, next_update);
             }
             else
             {
@@ -2157,25 +2173,31 @@ static DWORD verify_cert_revocation(const CERT_CONTEXT *cert, FILETIME *pTime,
         DWORD dwFlags, CERT_REVOCATION_PARA *pRevPara, CERT_REVOCATION_STATUS *pRevStatus)
 {
     DWORD error = ERROR_SUCCESS;
+    FILETIME next_update = {0};
     PCERT_EXTENSION ext;
 
-    if (find_cached_revocation_status(&cert->pCertInfo->SerialNumber, pTime, pRevStatus))
+    if (find_cached_revocation_status(cert, pRevPara, pTime, pRevStatus))
     {
         if (pRevStatus->dwError == ERROR_SUCCESS || pRevStatus->dwError == CRYPT_E_REVOKED)
+        {
+            TRACE("Returning cached status.\n");
             return pRevStatus->dwError;
+        }
     }
 
     if ((ext = CertFindExtension(szOID_AUTHORITY_INFO_ACCESS, cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension)))
     {
-        error = verify_cert_revocation_from_aia_ext(&ext->Value, cert, pTime, dwFlags, pRevPara, pRevStatus);
+        error = verify_cert_revocation_from_aia_ext(&ext->Value, cert, pTime, dwFlags, pRevPara, pRevStatus,
+                                                    &next_update);
         TRACE("verify_cert_revocation_from_aia_ext() returned %08lx\n", error);
-        if (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED) return error;
+        if (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED) goto done;
     }
     if ((ext = CertFindExtension(szOID_CRL_DIST_POINTS, cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension)))
     {
-        error = verify_cert_revocation_from_dist_points_ext(&ext->Value, cert, pTime, dwFlags, pRevPara, pRevStatus);
+        error = verify_cert_revocation_from_dist_points_ext(&ext->Value, cert, pTime, dwFlags, pRevPara, pRevStatus,
+                                                            &next_update);
         TRACE("verify_cert_revocation_from_dist_points_ext() returned %08lx\n", error);
-        if (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED) return error;
+        if (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED) goto done;
     }
     if (!ext)
     {
@@ -2247,6 +2269,17 @@ static DWORD verify_cert_revocation(const CERT_CONTEXT *cert, FILETIME *pTime,
             error = CRYPT_E_NO_REVOCATION_CHECK;
         }
     }
+done:
+    if ((next_update.dwLowDateTime || next_update.dwHighDateTime)
+        && (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED))
+    {
+        CERT_REVOCATION_STATUS rev_status;
+
+        memset(&rev_status, 0, sizeof(rev_status));
+        rev_status.cbSize = sizeof(rev_status);
+        rev_status.dwError = error;
+        cache_revocation_status(cert, pRevPara, &next_update, &rev_status);
+    }
     return error;
 }
 
diff --git a/dlls/cryptowinrt/Makefile.in b/dlls/cryptowinrt/Makefile.in
index 192ef49f178..6f11a7cd05d 100644
--- a/dlls/cryptowinrt/Makefile.in
+++ b/dlls/cryptowinrt/Makefile.in
@@ -2,6 +2,10 @@ MODULE = cryptowinrt.dll
 IMPORTS = combase bcrypt uuid
 
 C_SRCS = \
+	async.c \
+	credentials.c \
 	main.c
 
-IDL_SRCS = classes.idl
+IDL_SRCS = \
+	classes.idl \
+	provider.idl
diff --git a/dlls/cryptowinrt/async.c b/dlls/cryptowinrt/async.c
new file mode 100644
index 00000000000..dbf111cc880
--- /dev/null
+++ b/dlls/cryptowinrt/async.c
@@ -0,0 +1,508 @@
+/* CryptoWinRT Implementation
+ *
+ * Copyright 2022 Bernhard Kölbl for CodeWeavers
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(crypto);
+
+#define Closed 4
+#define HANDLER_NOT_SET ((void *)~(ULONG_PTR)0)
+
+struct async_info
+{
+    IWineAsyncInfoImpl IWineAsyncInfoImpl_iface;
+    IAsyncInfo IAsyncInfo_iface;
+    IInspectable *IInspectable_outer;
+    LONG ref;
+
+    async_operation_callback callback;
+    TP_WORK *async_run_work;
+    IUnknown *invoker;
+    IUnknown *param;
+
+    CRITICAL_SECTION cs;
+    IWineAsyncOperationCompletedHandler *handler;
+    PROPVARIANT result;
+    AsyncStatus status;
+    HRESULT hr;
+};
+
+static inline struct async_info *impl_from_IWineAsyncInfoImpl( IWineAsyncInfoImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct async_info, IWineAsyncInfoImpl_iface );
+}
+
+static HRESULT WINAPI async_impl_QueryInterface( IWineAsyncInfoImpl *iface, REFIID iid, void **out )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IWineAsyncInfoImpl ))
+    {
+        IInspectable_AddRef( (*out = &impl->IWineAsyncInfoImpl_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IAsyncInfo ))
+    {
+        IInspectable_AddRef( (*out = &impl->IAsyncInfo_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI async_impl_AddRef( IWineAsyncInfoImpl *iface )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI async_impl_Release( IWineAsyncInfoImpl *iface )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        if (impl->handler && impl->handler != HANDLER_NOT_SET) IWineAsyncOperationCompletedHandler_Release( impl->handler );
+        IAsyncInfo_Close( &impl->IAsyncInfo_iface );
+        if (impl->param) IUnknown_Release( impl->param );
+        if (impl->invoker) IUnknown_Release( impl->invoker );
+        impl->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection( &impl->cs );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI async_impl_put_Completed( IWineAsyncInfoImpl *iface, IWineAsyncOperationCompletedHandler *handler )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    else if (impl->handler != HANDLER_NOT_SET) hr = E_ILLEGAL_DELEGATE_ASSIGNMENT;
+    else if ((impl->handler = handler))
+    {
+        IWineAsyncOperationCompletedHandler_AddRef( impl->handler );
+
+        if (impl->status > Started)
+        {
+            IInspectable *operation = impl->IInspectable_outer;
+            AsyncStatus status = impl->status;
+            impl->handler = NULL; /* Prevent concurrent invoke. */
+            LeaveCriticalSection( &impl->cs );
+
+            IWineAsyncOperationCompletedHandler_Invoke( handler, operation, status );
+            IWineAsyncOperationCompletedHandler_Release( handler );
+
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_impl_get_Completed( IWineAsyncInfoImpl *iface, IWineAsyncOperationCompletedHandler **handler )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    if (impl->handler == NULL || impl->handler == HANDLER_NOT_SET) *handler = NULL;
+    else IWineAsyncOperationCompletedHandler_AddRef( (*handler = impl->handler) );
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_impl_get_Result( IWineAsyncInfoImpl *iface, PROPVARIANT *result )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    HRESULT hr = E_ILLEGAL_METHOD_CALL;
+
+    TRACE( "iface %p, result %p.\n", iface, result );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Completed || impl->status == Error)
+    {
+        PropVariantCopy( result, &impl->result );
+        hr = impl->hr;
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_impl_Start( IWineAsyncInfoImpl *iface )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    /* keep the async alive in the callback */
+    IInspectable_AddRef( impl->IInspectable_outer );
+    SubmitThreadpoolWork( impl->async_run_work );
+
+    return S_OK;
+}
+
+static const struct IWineAsyncInfoImplVtbl async_impl_vtbl =
+{
+    /* IUnknown methods */
+    async_impl_QueryInterface,
+    async_impl_AddRef,
+    async_impl_Release,
+    /* IWineAsyncInfoImpl */
+    async_impl_put_Completed,
+    async_impl_get_Completed,
+    async_impl_get_Result,
+    async_impl_Start,
+};
+
+DEFINE_IINSPECTABLE_OUTER( async_info, IAsyncInfo, struct async_info, IInspectable_outer )
+
+static HRESULT WINAPI async_info_get_Id( IAsyncInfo *iface, UINT32 *id )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, id %p.\n", iface, id );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    *id = 1;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_get_Status( IAsyncInfo *iface, AsyncStatus *status )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, status %p.\n", iface, status );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    *status = impl->status;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_get_ErrorCode( IAsyncInfo *iface, HRESULT *error_code )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, error_code %p.\n", iface, error_code );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) *error_code = hr = E_ILLEGAL_METHOD_CALL;
+    else *error_code = impl->hr;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_Cancel( IAsyncInfo *iface )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    else if (impl->status == Started) impl->status = Canceled;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_Close( IAsyncInfo *iface )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Started)
+        hr = E_ILLEGAL_STATE_CHANGE;
+    else if (impl->status != Closed)
+    {
+        CloseThreadpoolWork( impl->async_run_work );
+        impl->async_run_work = NULL;
+        impl->status = Closed;
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static const struct IAsyncInfoVtbl async_info_vtbl =
+{
+    /* IUnknown methods */
+    async_info_QueryInterface,
+    async_info_AddRef,
+    async_info_Release,
+    /* IInspectable methods */
+    async_info_GetIids,
+    async_info_GetRuntimeClassName,
+    async_info_GetTrustLevel,
+    /* IAsyncInfo */
+    async_info_get_Id,
+    async_info_get_Status,
+    async_info_get_ErrorCode,
+    async_info_Cancel,
+    async_info_Close,
+};
+
+static void CALLBACK async_info_callback( TP_CALLBACK_INSTANCE *instance, void *iface, TP_WORK *work )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    IInspectable *operation = impl->IInspectable_outer;
+    PROPVARIANT result;
+    HRESULT hr;
+
+    hr = impl->callback( impl->invoker, impl->param, &result );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status != Closed) impl->status = FAILED(hr) ? Error : Completed;
+    PropVariantCopy( &impl->result, &result );
+    impl->hr = hr;
+
+    if (impl->handler != NULL && impl->handler != HANDLER_NOT_SET)
+    {
+        IWineAsyncOperationCompletedHandler *handler = impl->handler;
+        AsyncStatus status = impl->status;
+        impl->handler = NULL; /* Prevent concurrent invoke. */
+        LeaveCriticalSection( &impl->cs );
+
+        IWineAsyncOperationCompletedHandler_Invoke( handler, operation, status );
+        IWineAsyncOperationCompletedHandler_Release( handler );
+    }
+    else LeaveCriticalSection( &impl->cs );
+
+    /* release refcount acquired in Start */
+    IInspectable_Release( operation );
+
+    PropVariantClear( &result );
+}
+
+static HRESULT async_info_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                  IInspectable *outer, IWineAsyncInfoImpl **out )
+{
+    struct async_info *impl;
+    HRESULT hr;
+
+    if (!(impl = calloc( 1, sizeof(struct async_info) ))) return E_OUTOFMEMORY;
+    impl->IWineAsyncInfoImpl_iface.lpVtbl = &async_impl_vtbl;
+    impl->IAsyncInfo_iface.lpVtbl = &async_info_vtbl;
+    impl->IInspectable_outer = outer;
+    impl->ref = 1;
+
+    impl->callback = callback;
+    impl->handler = HANDLER_NOT_SET;
+    impl->status = Started;
+    if (!(impl->async_run_work = CreateThreadpoolWork( async_info_callback, &impl->IWineAsyncInfoImpl_iface, NULL )))
+    {
+        hr = HRESULT_FROM_WIN32( GetLastError() );
+        free( impl );
+        return hr;
+    }
+
+    if ((impl->invoker = invoker)) IUnknown_AddRef( impl->invoker );
+    if ((impl->param = param)) IUnknown_AddRef( impl->param );
+
+    InitializeCriticalSection( &impl->cs );
+    impl->cs.DebugInfo->Spare[0] = (DWORD_PTR)( __FILE__ ": async_info.cs" );
+
+    *out = &impl->IWineAsyncInfoImpl_iface;
+    return S_OK;
+}
+
+struct async_bool
+{
+    IAsyncOperation_boolean IAsyncOperation_boolean_iface;
+    IWineAsyncInfoImpl *IWineAsyncInfoImpl_inner;
+    LONG ref;
+};
+
+static inline struct async_bool *impl_from_IAsyncOperation_boolean( IAsyncOperation_boolean *iface )
+{
+    return CONTAINING_RECORD( iface, struct async_bool, IAsyncOperation_boolean_iface );
+}
+
+static HRESULT WINAPI async_bool_QueryInterface( IAsyncOperation_boolean *iface, REFIID iid, void **out )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IAsyncOperation_boolean ))
+    {
+        IInspectable_AddRef( (*out = &impl->IAsyncOperation_boolean_iface) );
+        return S_OK;
+    }
+
+    return IWineAsyncInfoImpl_QueryInterface( impl->IWineAsyncInfoImpl_inner, iid, out );
+}
+
+static ULONG WINAPI async_bool_AddRef( IAsyncOperation_boolean *iface )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI async_bool_Release( IAsyncOperation_boolean *iface )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineAsyncInfoImpl_Release( impl->IWineAsyncInfoImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI async_bool_GetIids( IAsyncOperation_boolean *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI async_bool_GetRuntimeClassName( IAsyncOperation_boolean *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( L"Windows.Foundation.IAsyncOperation`1<Boolean>",
+                                ARRAY_SIZE(L"Windows.Foundation.IAsyncOperation`1<Boolean>"),
+                                class_name );
+}
+
+static HRESULT WINAPI async_bool_GetTrustLevel( IAsyncOperation_boolean *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI async_bool_put_Completed( IAsyncOperation_boolean *iface, IAsyncOperationCompletedHandler_boolean *bool_handler )
+{
+    IWineAsyncOperationCompletedHandler *handler = (IWineAsyncOperationCompletedHandler *)bool_handler;
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+    return IWineAsyncInfoImpl_put_Completed( impl->IWineAsyncInfoImpl_inner, (IWineAsyncOperationCompletedHandler *)handler );
+}
+
+static HRESULT WINAPI async_bool_get_Completed( IAsyncOperation_boolean *iface, IAsyncOperationCompletedHandler_boolean **bool_handler )
+{
+    IWineAsyncOperationCompletedHandler **handler = (IWineAsyncOperationCompletedHandler **)bool_handler;
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+    return IWineAsyncInfoImpl_get_Completed( impl->IWineAsyncInfoImpl_inner, (IWineAsyncOperationCompletedHandler **)handler );
+}
+
+static HRESULT WINAPI async_bool_GetResults( IAsyncOperation_boolean *iface, BOOLEAN *results )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    PROPVARIANT result = {.vt = VT_BOOL};
+    HRESULT hr;
+
+    TRACE( "iface %p, results %p.\n", iface, results );
+
+    hr = IWineAsyncInfoImpl_get_Result( impl->IWineAsyncInfoImpl_inner, &result );
+
+    *results = result.boolVal;
+    PropVariantClear( &result );
+    return hr;
+}
+
+static const struct IAsyncOperation_booleanVtbl async_bool_vtbl =
+{
+    /* IUnknown methods */
+    async_bool_QueryInterface,
+    async_bool_AddRef,
+    async_bool_Release,
+    /* IInspectable methods */
+    async_bool_GetIids,
+    async_bool_GetRuntimeClassName,
+    async_bool_GetTrustLevel,
+    /* IAsyncOperation<boolean> */
+    async_bool_put_Completed,
+    async_bool_get_Completed,
+    async_bool_GetResults,
+};
+
+HRESULT async_operation_boolean_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                        IAsyncOperation_boolean **out )
+{
+    struct async_bool *impl;
+    HRESULT hr;
+
+    *out = NULL;
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    impl->IAsyncOperation_boolean_iface.lpVtbl = &async_bool_vtbl;
+    impl->ref = 1;
+
+    if (FAILED(hr = async_info_create( invoker, param, callback, (IInspectable *)&impl->IAsyncOperation_boolean_iface, &impl->IWineAsyncInfoImpl_inner )) ||
+        FAILED(hr = IWineAsyncInfoImpl_Start( impl->IWineAsyncInfoImpl_inner )))
+    {
+        if (impl->IWineAsyncInfoImpl_inner) IWineAsyncInfoImpl_Release( impl->IWineAsyncInfoImpl_inner );
+        free( impl );
+        return hr;
+    }
+
+    *out = &impl->IAsyncOperation_boolean_iface;
+    TRACE( "created IAsyncOperation_boolean %p\n", *out );
+    return S_OK;
+}
diff --git a/dlls/cryptowinrt/classes.idl b/dlls/cryptowinrt/classes.idl
index 4352a8562e5..62272d2f93c 100644
--- a/dlls/cryptowinrt/classes.idl
+++ b/dlls/cryptowinrt/classes.idl
@@ -19,3 +19,4 @@
 #pragma makedep register
 
 #include "windows.security.cryptography.idl"
+#include "windows.security.credentials.idl"
diff --git a/dlls/cryptowinrt/credentials.c b/dlls/cryptowinrt/credentials.c
new file mode 100644
index 00000000000..e23c5d94696
--- /dev/null
+++ b/dlls/cryptowinrt/credentials.c
@@ -0,0 +1,184 @@
+/* CryptoWinRT Credentials Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(crypto);
+
+struct credentials_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    IKeyCredentialManagerStatics IKeyCredentialManagerStatics_iface;
+    LONG ref;
+};
+
+static inline struct credentials_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct credentials_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI credentials_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct credentials_statics *factory = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        IUnknown_AddRef( iface );
+        *out = &factory->IActivationFactory_iface;
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IKeyCredentialManagerStatics ))
+    {
+        IUnknown_AddRef( iface );
+        *out = &factory->IKeyCredentialManagerStatics_iface;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI credentials_AddRef( IActivationFactory *iface )
+{
+    struct credentials_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI credentials_Release( IActivationFactory *iface )
+{
+    struct credentials_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI credentials_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI credentials_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI credentials_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI credentials_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    credentials_QueryInterface,
+    credentials_AddRef,
+    credentials_Release,
+    /* IInspectable methods */
+    credentials_GetIids,
+    credentials_GetRuntimeClassName,
+    credentials_GetTrustLevel,
+    /* IActivationFactory methods */
+    credentials_ActivateInstance,
+};
+
+DEFINE_IINSPECTABLE( credentials_statics, IKeyCredentialManagerStatics, struct credentials_statics, IActivationFactory_iface );
+
+static HRESULT WINAPI is_supported_async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result )
+{
+    result->vt = VT_BOOL;
+    result->boolVal = FALSE;
+    return S_OK;
+}
+
+static HRESULT WINAPI credentials_statics_IsSupportedAsync( IKeyCredentialManagerStatics *iface, IAsyncOperation_boolean **value )
+{
+    TRACE( "iface %p, value %p.\n", iface, value );
+    return async_operation_boolean_create( (IUnknown *)iface, NULL, is_supported_async, value );
+}
+
+static HRESULT WINAPI credentials_statics_RenewAttestationAsync( IKeyCredentialManagerStatics *iface, IAsyncAction **operation )
+{
+    FIXME( "iface %p, operation %p stub!\n", iface, operation );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI credentials_statics_RequestCreateAsync( IKeyCredentialManagerStatics *iface,
+        HSTRING name, KeyCredentialCreationOption option, IAsyncOperation_KeyCredentialRetrievalResult **value )
+{
+    FIXME( "iface %p, name %s, %d option, %p value stub!\n", iface, debugstr_hstring(name), option, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI credentials_statics_OpenAsync(IKeyCredentialManagerStatics *iface,
+        HSTRING name, IAsyncOperation_KeyCredentialRetrievalResult **value)
+{
+    FIXME( "iface %p, name %s, %p value stub!\n", iface, debugstr_hstring(name), value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI credentials_statics_DeleteAsync( IKeyCredentialManagerStatics *iface, HSTRING name, IAsyncAction **operation )
+{
+    FIXME( "iface %p, name %s, %p operation stub!\n", iface, debugstr_hstring(name), operation );
+    return E_NOTIMPL;
+}
+
+static const struct IKeyCredentialManagerStaticsVtbl credentials_statics_vtbl =
+{
+    credentials_statics_QueryInterface,
+    credentials_statics_AddRef,
+    credentials_statics_Release,
+    /* IInspectable methods */
+    credentials_statics_GetIids,
+    credentials_statics_GetRuntimeClassName,
+    credentials_statics_GetTrustLevel,
+    /* IKeyCredentialManagerStatics methods */
+    credentials_statics_IsSupportedAsync,
+    credentials_statics_RenewAttestationAsync,
+    credentials_statics_RequestCreateAsync,
+    credentials_statics_OpenAsync,
+    credentials_statics_DeleteAsync,
+};
+
+static struct credentials_statics credentials_statics =
+{
+    {&factory_vtbl},
+    {&credentials_statics_vtbl},
+    1,
+};
+
+IActivationFactory *credentials_activation_factory = &credentials_statics.IActivationFactory_iface;
diff --git a/dlls/cryptowinrt/main.c b/dlls/cryptowinrt/main.c
index 720b137e4a9..5f28382eba9 100644
--- a/dlls/cryptowinrt/main.c
+++ b/dlls/cryptowinrt/main.c
@@ -16,32 +16,22 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
+#include "initguid.h"
+#include "private.h"
+
 #include <assert.h>
 
-#define COBJMACROS
-#include "windef.h"
-#include "winbase.h"
-#include "winstring.h"
 #include "wine/debug.h"
 #include "objbase.h"
 
-#include "initguid.h"
-#include "activation.h"
-
 #include "bcrypt.h"
 
-#define WIDL_using_Windows_Foundation
-#define WIDL_using_Windows_Foundation_Collections
-#include "windows.foundation.h"
-#define WIDL_using_Windows_Storage_Streams
-#include "windows.storage.streams.h"
 #define WIDL_using_Windows_Security_Cryptography
 #include "windows.security.cryptography.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(crypto);
 
-static const char *debugstr_hstring(HSTRING hstr)
+const char *debugstr_hstring(HSTRING hstr)
 {
     const WCHAR *str;
     UINT32 len;
@@ -62,11 +52,6 @@ static inline struct cryptobuffer_factory *impl_from_IActivationFactory(IActivat
     return CONTAINING_RECORD(iface, struct cryptobuffer_factory, IActivationFactory_iface);
 }
 
-static inline struct cryptobuffer_factory *impl_from_ICryptographicBufferStatics(ICryptographicBufferStatics *iface)
-{
-    return CONTAINING_RECORD(iface, struct cryptobuffer_factory, ICryptographicBufferStatics_iface);
-}
-
 static HRESULT STDMETHODCALLTYPE cryptobuffer_factory_QueryInterface(
         IActivationFactory *iface, REFIID iid, void **out)
 {
@@ -157,45 +142,7 @@ static const struct IActivationFactoryVtbl cryptobuffer_factory_vtbl =
     cryptobuffer_factory_ActivateInstance,
 };
 
-static HRESULT STDMETHODCALLTYPE cryptobuffer_statics_QueryInterface(
-        ICryptographicBufferStatics *iface, REFIID iid, void **object)
-{
-    struct cryptobuffer_factory *factory = impl_from_ICryptographicBufferStatics(iface);
-    return IActivationFactory_QueryInterface(&factory->IActivationFactory_iface, iid, object);
-}
-
-static ULONG STDMETHODCALLTYPE cryptobuffer_statics_AddRef(ICryptographicBufferStatics *iface)
-{
-    struct cryptobuffer_factory *factory = impl_from_ICryptographicBufferStatics(iface);
-    return IActivationFactory_AddRef(&factory->IActivationFactory_iface);
-}
-
-static ULONG STDMETHODCALLTYPE cryptobuffer_statics_Release(ICryptographicBufferStatics *iface)
-{
-    struct cryptobuffer_factory *factory = impl_from_ICryptographicBufferStatics(iface);
-    return IActivationFactory_Release(&factory->IActivationFactory_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE cryptobuffer_statics_GetIids(
-        ICryptographicBufferStatics *iface, ULONG *iid_count, IID **iids)
-{
-    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE cryptobuffer_statics_GetRuntimeClassName(
-        ICryptographicBufferStatics *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE cryptobuffer_statics_GetTrustLevel(
-        ICryptographicBufferStatics *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
-    return E_NOTIMPL;
-}
+DEFINE_IINSPECTABLE(cryptobuffer_statics, ICryptographicBufferStatics, struct cryptobuffer_factory, IActivationFactory_iface);
 
 static HRESULT STDMETHODCALLTYPE cryptobuffer_statics_Compare(
         ICryptographicBufferStatics *iface, IBuffer *object1, IBuffer *object2, boolean *is_equal)
@@ -317,6 +264,8 @@ static struct cryptobuffer_factory cryptobuffer_factory =
     .refcount = 1,
 };
 
+IActivationFactory *cryptobuffer_activation_factory = &cryptobuffer_factory.IActivationFactory_iface;
+
 HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
 {
     FIXME("clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out);
@@ -332,10 +281,9 @@ HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **fac
     *factory = NULL;
 
     if (!wcscmp(name, RuntimeClass_Windows_Security_Cryptography_CryptographicBuffer))
-    {
-        *factory = &cryptobuffer_factory.IActivationFactory_iface;
-        IUnknown_AddRef(*factory);
-    }
+        IActivationFactory_QueryInterface(cryptobuffer_activation_factory, &IID_IActivationFactory, (void **)factory);
+    if (!wcscmp(name, RuntimeClass_Windows_Security_Credentials_KeyCredentialManager))
+        IActivationFactory_QueryInterface(credentials_activation_factory, &IID_IActivationFactory, (void **)factory);
 
     if (*factory) return S_OK;
     return CLASS_E_CLASSNOTAVAILABLE;
diff --git a/dlls/cryptowinrt/private.h b/dlls/cryptowinrt/private.h
new file mode 100644
index 00000000000..b1c195123f3
--- /dev/null
+++ b/dlls/cryptowinrt/private.h
@@ -0,0 +1,90 @@
+/* CryptoWinRT Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_CRYPTOWINRT_PRIVATE_H
+#define __WINE_CRYPTOWINRT_PRIVATE_H
+
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "activation.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Foundation_Collections
+#include "windows.foundation.h"
+#define WIDL_using_Windows_Storage_Streams
+#include "windows.storage.streams.h"
+#define WIDL_using_Windows_Security_Credentials
+#include "windows.security.credentials.h"
+
+#include "provider.h"
+
+extern const char *debugstr_hstring( HSTRING hstr );
+
+extern IActivationFactory *credentials_activation_factory;
+
+typedef HRESULT (WINAPI *async_operation_callback)( IUnknown *invoker, IUnknown *param, PROPVARIANT *result );
+extern HRESULT async_operation_boolean_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                               IAsyncOperation_boolean **out );
+
+#define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
+    static inline impl_type *impl_from( iface_type *iface )                                        \
+    {                                                                                              \
+        return CONTAINING_RECORD( iface, impl_type, iface_mem );                                   \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_QueryInterface( (IInspectable *)(expr), iid, out );                    \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_AddRef( iface_type *iface )                                          \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_AddRef( (IInspectable *)(expr) );                                      \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_Release( iface_type *iface )                                         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_Release( (IInspectable *)(expr) );                                     \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetIids( iface_type *iface, ULONG *iid_count, IID **iids )         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetIids( (IInspectable *)(expr), iid_count, iids );                    \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetRuntimeClassName( iface_type *iface, HSTRING *class_name )      \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetRuntimeClassName( (IInspectable *)(expr), class_name );             \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetTrustLevel( iface_type *iface, TrustLevel *trust_level )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetTrustLevel( (IInspectable *)(expr), trust_level );                  \
+    }
+#define DEFINE_IINSPECTABLE( pfx, iface_type, impl_type, base_iface )                              \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
+#define DEFINE_IINSPECTABLE_OUTER( pfx, iface_type, impl_type, outer_iface )                       \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, impl->outer_iface )
+
+#endif
diff --git a/dlls/cryptowinrt/provider.idl b/dlls/cryptowinrt/provider.idl
new file mode 100644
index 00000000000..7196119dba0
--- /dev/null
+++ b/dlls/cryptowinrt/provider.idl
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2022 Mohamad Al-Jaf
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep header
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "propidl.idl";
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+namespace Windows.Security.Credentials {
+    /* type-pruning version of AsyncOperationCompletedHandler<T> */
+    delegate HRESULT WineAsyncOperationCompletedHandler([in] IInspectable *async, [in] AsyncStatus status);
+
+    [
+        uuid(83f377ee-c799-11ec-9d64-0242ac120002)
+    ]
+    interface IWineAsyncInfoImpl : IUnknown
+    {
+        [propput] HRESULT Completed([in] WineAsyncOperationCompletedHandler *handler);
+        [propget] HRESULT Completed([out, retval] WineAsyncOperationCompletedHandler **handler);
+        [propget] HRESULT Result([out, retval] PROPVARIANT *result);
+        HRESULT Start();
+    }
+}
diff --git a/dlls/cryptowinrt/tests/Makefile.in b/dlls/cryptowinrt/tests/Makefile.in
new file mode 100644
index 00000000000..af7cc510dc2
--- /dev/null
+++ b/dlls/cryptowinrt/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL = cryptowinrt.dll
+IMPORTS = combase
+
+C_SRCS = \
+	crypto.c
diff --git a/dlls/cryptowinrt/tests/crypto.c b/dlls/cryptowinrt/tests/crypto.c
new file mode 100644
index 00000000000..983af748bed
--- /dev/null
+++ b/dlls/cryptowinrt/tests/crypto.c
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+#include "initguid.h"
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "roapi.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Foundation_Collections
+#include "windows.foundation.h"
+#define WIDL_using_Windows_Storage_Streams
+#include "windows.storage.streams.h"
+#define WIDL_using_Windows_Security_Cryptography
+#include "windows.security.cryptography.h"
+#define WIDL_using_Windows_Security_Credentials
+#include "windows.security.credentials.h"
+
+#include "wine/test.h"
+
+static HRESULT (WINAPI *pWindowsDeleteString)( HSTRING str );
+static const WCHAR* (WINAPI *pWindowsGetStringRawBuffer)( HSTRING, UINT32* );
+
+static BOOL load_combase_functions(void)
+{
+    HMODULE combase = GetModuleHandleW( L"combase.dll" );
+
+#define LOAD_FUNC(m, f) if (!(p ## f = (void *)GetProcAddress( m, #f ))) goto failed;
+    LOAD_FUNC( combase, WindowsDeleteString );
+    LOAD_FUNC( combase, WindowsGetStringRawBuffer );
+#undef LOAD_FUNC
+
+    return TRUE;
+
+failed:
+    win_skip("Failed to load combase.dll functions, skipping tests\n");
+    return FALSE;
+}
+
+#define check_interface( obj, iid ) check_interface_( __LINE__, obj, iid )
+static void check_interface_( unsigned int line, void *obj, const IID *iid )
+{
+    IUnknown *iface = obj;
+    IUnknown *unk;
+    HRESULT hr;
+
+    hr = IUnknown_QueryInterface( iface, iid, (void **)&unk );
+    ok_(__FILE__, line)( hr == S_OK, "got hr %#lx.\n", hr );
+    IUnknown_Release( unk );
+}
+
+#define check_runtimeclass( a, b ) check_runtimeclass_( __LINE__, (IInspectable *)a, b )
+static void check_runtimeclass_( int line, IInspectable *inspectable, const WCHAR *class_name )
+{
+    const WCHAR *buffer;
+    UINT32 length;
+    HSTRING str;
+    HRESULT hr;
+
+    hr = IInspectable_GetRuntimeClassName( inspectable, &str );
+    ok_(__FILE__, line)( hr == S_OK, "GetRuntimeClassName returned %#lx\n", hr );
+    buffer = pWindowsGetStringRawBuffer( str, &length );
+    ok_(__FILE__, line)( !wcscmp( buffer, class_name ), "got class name %s\n", debugstr_w(buffer) );
+    pWindowsDeleteString( str );
+}
+
+#define check_bool_async( a, b, c, d, e ) check_bool_async_( __LINE__, a, b, c, d, e )
+static void check_bool_async_( int line, IAsyncOperation_boolean *async, UINT32 expect_id, AsyncStatus expect_status,
+                               HRESULT expect_hr, BOOLEAN expect_result )
+{
+    AsyncStatus async_status;
+    IAsyncInfo *async_info;
+    HRESULT hr, async_hr;
+    UINT32 async_id;
+    BOOLEAN result;
+
+    hr = IAsyncOperation_boolean_QueryInterface( async, &IID_IAsyncInfo, (void **)&async_info );
+    ok_(__FILE__, line)( hr == S_OK, "QueryInterface returned %#lx\n", hr );
+
+    async_id = 0xdeadbeef;
+    hr = IAsyncInfo_get_Id( async_info, &async_id );
+    if (expect_status < 4) ok_(__FILE__, line)( hr == S_OK, "get_Id returned %#lx\n", hr );
+    else ok_(__FILE__, line)( hr == E_ILLEGAL_METHOD_CALL, "get_Id returned %#lx\n", hr );
+    if (expect_id) ok_(__FILE__, line)( async_id == expect_id, "got id %u\n", async_id );
+    else trace("Skipping async_id check, got id %u\n", async_id );
+
+    async_status = 0xdeadbeef;
+    hr = IAsyncInfo_get_Status( async_info, &async_status );
+    if (expect_status < 4) ok_(__FILE__, line)( hr == S_OK, "get_Status returned %#lx\n", hr );
+    else ok_(__FILE__, line)( hr == E_ILLEGAL_METHOD_CALL, "get_Status returned %#lx\n", hr );
+    ok_(__FILE__, line)( async_status == expect_status || broken( async_status == Error ), "got status %u\n", async_status );
+
+    async_hr = 0xdeadbeef;
+    hr = IAsyncInfo_get_ErrorCode( async_info, &async_hr );
+    if (expect_status < 4) ok_(__FILE__, line)( hr == S_OK, "get_ErrorCode returned %#lx\n", hr );
+    else ok_(__FILE__, line)( hr == E_ILLEGAL_METHOD_CALL, "get_ErrorCode returned %#lx\n", hr );
+    if (expect_status < 4)
+        todo_wine_if(FAILED(expect_hr)) ok_(__FILE__, line)( async_hr == expect_hr || broken( async_hr == E_INVALIDARG), "got error %#lx\n", async_hr );
+    else ok_(__FILE__, line)( async_hr == E_ILLEGAL_METHOD_CALL, "got error %#lx\n", async_hr );
+
+    IAsyncInfo_Release( async_info );
+
+    result = !expect_result;
+    hr = IAsyncOperation_boolean_GetResults( async, &result );
+    switch (expect_status)
+    {
+    case Completed:
+    case Error:
+        todo_wine_if(FAILED(expect_hr))
+        ok_(__FILE__, line)( hr == expect_hr || broken( hr == E_INVALIDARG ), "GetResults returned %#lx\n", hr );
+        ok_(__FILE__, line)( result == expect_result, "got result %u\n", result );
+        break;
+    case Canceled:
+    case Started:
+    default:
+        ok_(__FILE__, line)( hr == E_ILLEGAL_METHOD_CALL, "GetResults returned %#lx\n", hr );
+        break;
+    }
+}
+
+struct bool_async_handler
+{
+    IAsyncOperationCompletedHandler_boolean IAsyncOperationCompletedHandler_boolean_iface;
+    IAsyncOperation_boolean *async;
+    AsyncStatus status;
+    BOOL invoked;
+    HANDLE event;
+};
+
+static inline struct bool_async_handler *impl_from_IAsyncOperationCompletedHandler_boolean( IAsyncOperationCompletedHandler_boolean *iface )
+{
+    return CONTAINING_RECORD( iface, struct bool_async_handler, IAsyncOperationCompletedHandler_boolean_iface );
+}
+
+static HRESULT WINAPI bool_async_handler_QueryInterface( IAsyncOperationCompletedHandler_boolean *iface, REFIID iid, void **out )
+{
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IAsyncOperationCompletedHandler_boolean ))
+    {
+        IUnknown_AddRef( iface );
+        *out = iface;
+        return S_OK;
+    }
+
+    trace( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI bool_async_handler_AddRef( IAsyncOperationCompletedHandler_boolean *iface )
+{
+    return 2;
+}
+
+static ULONG WINAPI bool_async_handler_Release( IAsyncOperationCompletedHandler_boolean *iface )
+{
+    return 1;
+}
+
+static HRESULT WINAPI bool_async_handler_Invoke( IAsyncOperationCompletedHandler_boolean *iface,
+                                                 IAsyncOperation_boolean *async, AsyncStatus status )
+{
+    struct bool_async_handler *impl = impl_from_IAsyncOperationCompletedHandler_boolean( iface );
+
+    trace( "iface %p, async %p, status %u\n", iface, async, status );
+
+    ok( !impl->invoked, "invoked twice\n" );
+    impl->invoked = TRUE;
+    impl->async = async;
+    impl->status = status;
+    if (impl->event) SetEvent( impl->event );
+
+    return S_OK;
+}
+
+static IAsyncOperationCompletedHandler_booleanVtbl bool_async_handler_vtbl =
+{
+    /*** IUnknown methods ***/
+    bool_async_handler_QueryInterface,
+    bool_async_handler_AddRef,
+    bool_async_handler_Release,
+    /*** IAsyncOperationCompletedHandler<boolean> methods ***/
+    bool_async_handler_Invoke,
+};
+
+static struct bool_async_handler default_bool_async_handler = {{&bool_async_handler_vtbl}};
+
+static void test_CryptobufferStatics(void)
+{
+    static const WCHAR *cryptobuffer_statics_name = L"Windows.Security.Cryptography.CryptographicBuffer";
+    ICryptographicBufferStatics *cryptobuffer_statics;
+    IActivationFactory *factory;
+    HSTRING str;
+    HRESULT hr;
+    LONG ref;
+
+    hr = WindowsCreateString( cryptobuffer_statics_name, wcslen( cryptobuffer_statics_name ), &str );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    hr = RoGetActivationFactory( str, &IID_IActivationFactory, (void **)&factory );
+    WindowsDeleteString( str );
+    ok( hr == S_OK || broken( hr == REGDB_E_CLASSNOTREG ), "got hr %#lx.\n", hr );
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip( "%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w( cryptobuffer_statics_name ) );
+        return;
+    }
+
+    check_interface( factory, &IID_IUnknown );
+    check_interface( factory, &IID_IInspectable );
+    check_interface( factory, &IID_IAgileObject );
+
+    hr = IActivationFactory_QueryInterface( factory, &IID_ICryptographicBufferStatics, (void **)&cryptobuffer_statics );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    ref = ICryptographicBufferStatics_Release( cryptobuffer_statics );
+    ok( ref == 2, "got ref %ld.\n", ref );
+    ref = IActivationFactory_Release( factory );
+    ok( ref == 1, "got ref %ld.\n", ref );
+}
+
+static void test_Credentials_Statics(void)
+{
+    static const WCHAR *credentials_statics_name = L"Windows.Security.Credentials.KeyCredentialManager";
+    IAsyncOperationCompletedHandler_boolean *tmp_handler;
+    IKeyCredentialManagerStatics *credentials_statics;
+    struct bool_async_handler bool_async_handler;
+    IAsyncOperation_boolean *bool_async;
+    IActivationFactory *factory;
+    IAsyncInfo *async_info;
+    HSTRING str;
+    HRESULT hr;
+    DWORD ret;
+    LONG ref;
+
+    hr = WindowsCreateString( credentials_statics_name, wcslen( credentials_statics_name ), &str );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    hr = RoGetActivationFactory( str, &IID_IActivationFactory, (void **)&factory );
+    WindowsDeleteString( str );
+    ok( hr == S_OK || broken( hr == REGDB_E_CLASSNOTREG ), "got hr %#lx.\n", hr );
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip( "%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w( credentials_statics_name ) );
+        return;
+    }
+
+    check_interface( factory, &IID_IUnknown );
+    check_interface( factory, &IID_IInspectable );
+    check_interface( factory, &IID_IAgileObject );
+
+    hr = IActivationFactory_QueryInterface( factory, &IID_IKeyCredentialManagerStatics, (void **)&credentials_statics );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    if (!load_combase_functions()) return;
+
+    hr = IKeyCredentialManagerStatics_IsSupportedAsync( credentials_statics, &bool_async );
+    ok( hr == S_OK, "IsSupportedAsync returned %#lx\n", hr );
+
+    check_interface( bool_async, &IID_IUnknown );
+    check_interface( bool_async, &IID_IInspectable );
+    check_interface( bool_async, &IID_IAgileObject );
+    check_interface( bool_async, &IID_IAsyncInfo );
+    check_interface( bool_async, &IID_IAsyncOperation_boolean );
+    check_runtimeclass( bool_async, L"Windows.Foundation.IAsyncOperation`1<Boolean>" );
+
+    hr = IAsyncOperation_boolean_get_Completed( bool_async, &tmp_handler );
+    ok( hr == S_OK, "get_Completed returned %#lx\n", hr );
+    ok( tmp_handler == NULL, "got handler %p\n", tmp_handler );
+    bool_async_handler = default_bool_async_handler;
+    bool_async_handler.event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler.IAsyncOperationCompletedHandler_boolean_iface );
+    ok( hr == S_OK, "put_Completed returned %#lx\n", hr );
+    ret = WaitForSingleObject( bool_async_handler.event, 1000 );
+    ok( !ret, "WaitForSingleObject returned %#lx\n", ret );
+    ret = CloseHandle( bool_async_handler.event );
+    ok( ret, "CloseHandle failed, error %lu\n", GetLastError() );
+    ok( bool_async_handler.invoked, "handler not invoked\n" );
+    ok( bool_async_handler.async == bool_async, "got async %p\n", bool_async_handler.async );
+    ok( bool_async_handler.status == Completed || broken( bool_async_handler.status == Error ), "got status %u\n", bool_async_handler.status );
+    bool_async_handler = default_bool_async_handler;
+    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler.IAsyncOperationCompletedHandler_boolean_iface );
+    ok( hr == E_ILLEGAL_DELEGATE_ASSIGNMENT, "put_Completed returned %#lx\n", hr );
+    ok( !bool_async_handler.invoked, "handler invoked\n" );
+    ok( bool_async_handler.async == NULL, "got async %p\n", bool_async_handler.async );
+    ok( bool_async_handler.status == Started, "got status %u\n", bool_async_handler.status );
+
+    hr = IAsyncOperation_boolean_QueryInterface( bool_async, &IID_IAsyncInfo, (void **)&async_info );
+    ok( hr == S_OK, "QueryInterface returned %#lx\n", hr );
+    hr = IAsyncInfo_Cancel( async_info );
+    ok( hr == S_OK, "Cancel returned %#lx\n", hr );
+    check_bool_async( bool_async, 0, Completed, S_OK, FALSE );
+    hr = IAsyncInfo_Close( async_info );
+    ok( hr == S_OK, "Close returned %#lx\n", hr );
+    check_bool_async( bool_async, 0, 4, S_OK, FALSE );
+    IAsyncInfo_Release( async_info );
+
+    IAsyncOperation_boolean_Release( bool_async );
+
+    ref = IKeyCredentialManagerStatics_Release( credentials_statics );
+    ok( ref == 2, "got ref %ld.\n", ref );
+    ref = IActivationFactory_Release( factory );
+    ok( ref == 1, "got ref %ld.\n", ref );
+}
+
+START_TEST(crypto)
+{
+    HRESULT hr;
+
+    hr = RoInitialize( RO_INIT_MULTITHREADED );
+    ok( hr == S_OK, "RoInitialize failed, hr %#lx\n", hr );
+
+    test_CryptobufferStatics();
+    test_Credentials_Statics();
+
+    RoUninitialize();
+}
diff --git a/dlls/cryptui/main.c b/dlls/cryptui/main.c
index 03054ae180c..d545ff9dc43 100644
--- a/dlls/cryptui/main.c
+++ b/dlls/cryptui/main.c
@@ -2712,7 +2712,7 @@ static WCHAR *field_format_public_key(PCCERT_CONTEXT cert)
                 args[1] = CertGetPublicKeyLength(X509_ASN_ENCODING,
                               &cert->pCertInfo->SubjectPublicKeyInfo);
                 FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                               fmt, 0, 0, buf, len, (__ms_va_list*)args);
+                               fmt, 0, 0, buf, len, (va_list *)args);
             }
         }
     }
diff --git a/dlls/d3d10core/tests/d3d10core.c b/dlls/d3d10core/tests/d3d10core.c
index cd14371197f..38a67eac5f9 100644
--- a/dlls/d3d10core/tests/d3d10core.c
+++ b/dlls/d3d10core/tests/d3d10core.c
@@ -1406,13 +1406,18 @@ static void release_test_context_(unsigned int line, struct d3d10core_test_conte
     ok_(__FILE__, line)(!ref, "Device has %lu references left.\n", ref);
 }
 
-static void clear_backbuffer_rtv(struct d3d10core_test_context *test_context, const struct vec4 *v)
+static void clear_rtv(struct d3d10core_test_context *test_context, ID3D10RenderTargetView *rtv, const struct vec4 *v)
 {
     /* Cast to (const float *) instead of passing &v->x, since gcc warns about
      * overreading a float[4] from a float otherwise. */
     ID3D10Device_ClearRenderTargetView(test_context->device, test_context->backbuffer_rtv, (const float *)v);
 }
 
+static void clear_backbuffer_rtv(struct d3d10core_test_context *test_context, const struct vec4 *v)
+{
+    clear_rtv(test_context, test_context->backbuffer_rtv, v);
+}
+
 #define draw_quad(context) draw_quad_vs_(__LINE__, context, NULL, 0)
 #define draw_quad_vs(a, b, c) draw_quad_vs_(__LINE__, a, b, c)
 static void draw_quad_vs_(unsigned int line, struct d3d10core_test_context *context,
@@ -19430,6 +19435,194 @@ static void test_stencil_only_write_after_clear(void)
     release_test_context(&test_context);
 }
 
+static void test_vertex_formats(void)
+{
+    struct d3d10core_test_context test_context;
+    ID3D10RenderTargetView *rtv;
+    ID3D10Device *device;
+    ID3D10Texture2D *rt;
+    unsigned int i;
+    HRESULT hr;
+
+    static const D3D10_TEXTURE2D_DESC rt_desc =
+    {
+        .Width = 4,
+        .Height = 4,
+        .MipLevels = 1,
+        .ArraySize = 1,
+        .Format = DXGI_FORMAT_R32G32B32A32_FLOAT,
+        .SampleDesc.Count = 1,
+        .Usage = D3D10_USAGE_DEFAULT,
+        .BindFlags = D3D10_BIND_RENDER_TARGET,
+    };
+
+    static const struct quad
+    {
+        struct vec2 position;
+        unsigned int color[4];
+    }
+    quad[] =
+    {
+        {{-1.0f, -1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+        {{-1.0f,  1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+        {{ 1.0f, -1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+        {{ 1.0f,  1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+    };
+
+    static const unsigned int vs_code[] =
+    {
+#if 0
+        void main(inout float4 position : sv_position, inout float4 color : COLOR)
+        {
+        }
+#endif
+        0x43425844, 0xc2f6fe60, 0x8a304938, 0x14c1a190, 0xe6f3e35e, 0x00000001, 0x00000144, 0x00000003,
+        0x0000002c, 0x00000080, 0x000000d4, 0x4e475349, 0x0000004c, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000f0f, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x705f7673, 0x7469736f, 0x006e6f69, 0x4f4c4f43, 0xabab0052,
+        0x4e47534f, 0x0000004c, 0x00000002, 0x00000008, 0x00000038, 0x00000000, 0x00000001, 0x00000003,
+        0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x0000000f,
+        0x705f7673, 0x7469736f, 0x006e6f69, 0x4f4c4f43, 0xabab0052, 0x52444853, 0x00000068, 0x00010040,
+        0x0000001a, 0x0300005f, 0x001010f2, 0x00000000, 0x0300005f, 0x001010f2, 0x00000001, 0x04000067,
+        0x001020f2, 0x00000000, 0x00000001, 0x03000065, 0x001020f2, 0x00000001, 0x05000036, 0x001020f2,
+        0x00000000, 0x00101e46, 0x00000000, 0x05000036, 0x001020f2, 0x00000001, 0x00101e46, 0x00000001,
+        0x0100003e,
+    };
+
+    static const unsigned int ps_code[] =
+    {
+#if 0
+        float4 main(float4 position : sv_position, float4 color : COLOR) : sv_target
+        {
+            return color;
+        }
+#endif
+        0x43425844, 0xb9b047ca, 0x73193a19, 0xb9a919ed, 0x21c2ff5f, 0x00000001, 0x000000f4, 0x00000003,
+        0x0000002c, 0x00000080, 0x000000b4, 0x4e475349, 0x0000004c, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x705f7673, 0x7469736f, 0x006e6f69, 0x4f4c4f43, 0xabab0052,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000f, 0x745f7673, 0x65677261, 0xabab0074, 0x52444853, 0x00000038, 0x00000040,
+        0x0000000e, 0x03001062, 0x001010f2, 0x00000001, 0x03000065, 0x001020f2, 0x00000000, 0x05000036,
+        0x001020f2, 0x00000000, 0x00101e46, 0x00000001, 0x0100003e,
+    };
+
+    static const struct vec4 white = {1.0f, 1.0f, 1.0f, 1.0f};
+
+    static const struct
+    {
+        DXGI_FORMAT format;
+        struct vec4 expect;
+    }
+    tests[] =
+    {
+        {DXGI_FORMAT_R32G32B32A32_FLOAT,    {-1.72477726e-34,  5.69045661e-28, -1.07374176e+08, -6.25985340e+18}},
+        {DXGI_FORMAT_R32G32B32_FLOAT,       {-1.72477726e-34,  5.69045661e-28, -1.07374176e+08,  1.0}},
+        {DXGI_FORMAT_R32G32_FLOAT,          {-1.72477726e-34,  5.69045661e-28,  0.0,             1.0}},
+        {DXGI_FORMAT_R32_FLOAT,             {-1.72477726e-34,  0.0,             0.0,             1.0}},
+
+        {DXGI_FORMAT_R10G10B10A2_UNORM,     { 7.82991230e-01,  3.28445762e-01,  1.15347020e-01,  6.66666666e-01}},
+
+        {DXGI_FORMAT_R11G11B10_FLOAT,       { 1.89453125e-01,  1.30000000e+01,  3.81250000e+00,  1.0}},
+
+        {DXGI_FORMAT_R16G16B16A16_FLOAT,    { 3.56445313e+00, -1.12831593e-04,  1.03500000e+02,  7.57217407e-04}},
+        {DXGI_FORMAT_R16G16B16A16_UNORM,    { 2.62226284e-01,  5.28892934e-01,  3.37773710e-01,  7.11070448e-02}},
+        {DXGI_FORMAT_R16G16B16A16_SNORM,    { 5.24460614e-01, -9.42258954e-01,  6.75557733e-01,  1.42216250e-01}},
+        {DXGI_FORMAT_R16G16_FLOAT,          { 3.56445313e+00, -1.12831593e-04,  0.0,             1.0}},
+        {DXGI_FORMAT_R16G16_UNORM,          { 2.62226284e-01,  5.28892934e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R16G16_SNORM,          { 5.24460614e-01, -9.42258954e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R16_FLOAT,             { 3.56445313e+00,  0.0,             0.0,             1.0}},
+        {DXGI_FORMAT_R16_UNORM,             { 2.62226284e-01,  0.0,             0.0,             1.0}},
+        {DXGI_FORMAT_R16_SNORM,             { 5.24460614e-01,  0.0,             0.0,             1.0}},
+
+        {DXGI_FORMAT_R8G8B8A8_UNORM,        { 1.29411772e-01,  2.62745112e-01,  3.96078438e-01,  5.29411793e-01}},
+        {DXGI_FORMAT_R8G8B8A8_SNORM,        { 2.59842515e-01,  5.27559042e-01,  7.95275569e-01, -9.52755928e-01}},
+        {DXGI_FORMAT_R8G8_UNORM,            { 1.29411772e-01,  2.62745112e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R8G8_SNORM,            { 2.59842515e-01,  5.27559042e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R8_UNORM,              { 1.29411772e-01,  0.0,             0.0,             1.0}},
+        {DXGI_FORMAT_R8_SNORM,              { 2.59842515e-01,  0.0,             0.0,             1.0}},
+
+        {DXGI_FORMAT_B8G8R8A8_UNORM,        { 3.96078438e-01,  2.62745112e-01,  1.29411772e-01,  5.29411793e-01}},
+        {DXGI_FORMAT_B8G8R8X8_UNORM,        { 3.96078438e-01,  2.62745112e-01,  1.29411772e-01,  1.0}},
+    };
+
+    if (!init_test_context(&test_context))
+        return;
+    device = test_context.device;
+
+    hr = ID3D10Device_CreateTexture2D(device, &rt_desc, NULL, &rt);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = ID3D10Device_CreateRenderTargetView(device, (ID3D10Resource *)rt, NULL, &rtv);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = ID3D10Device_CreateVertexShader(device, vs_code, sizeof(vs_code), &test_context.vs);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = ID3D10Device_CreatePixelShader(device, ps_code, sizeof(ps_code), &test_context.ps);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_context.vb = create_buffer(device, D3D10_BIND_VERTEX_BUFFER, sizeof(quad), quad);
+
+    for (i = 0; i < ARRAY_SIZE(tests); ++i)
+    {
+        const D3D10_INPUT_ELEMENT_DESC layout_desc[] =
+        {
+            {
+                .SemanticName = "sv_position",
+                .SemanticIndex = 0,
+                .Format = DXGI_FORMAT_R32G32_FLOAT,
+                .InputSlot = 0,
+                .AlignedByteOffset = offsetof(struct quad, position),
+                .InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA,
+            },
+            {
+                .SemanticName = "COLOR",
+                .SemanticIndex = 0,
+                .Format = tests[i].format,
+                .InputSlot = 0,
+                .AlignedByteOffset = offsetof(struct quad, color),
+                .InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA,
+            },
+        };
+
+        static const unsigned int stride = sizeof(*quad);
+        static const unsigned int offset = 0;
+        ID3D10InputLayout *input_layout;
+        unsigned int format_support;
+
+        hr = ID3D10Device_CheckFormatSupport(device, tests[i].format, &format_support);
+        ok(hr == S_OK || hr == E_FAIL, "Got hr %#lx.\n", hr);
+
+        if (!(format_support & D3D10_FORMAT_SUPPORT_IA_VERTEX_BUFFER))
+            continue;
+
+        winetest_push_context("Format %#x", tests[i].format);
+
+        hr = ID3D10Device_CreateInputLayout(device, layout_desc, ARRAY_SIZE(layout_desc),
+                vs_code, sizeof(vs_code), &input_layout);
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+        clear_rtv(&test_context, rtv, &white);
+        ID3D10Device_OMSetRenderTargets(device, 1, &rtv, NULL);
+        ID3D10Device_IASetInputLayout(device, input_layout);
+        ID3D10Device_IASetPrimitiveTopology(device, D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+        ID3D10Device_IASetVertexBuffers(device, 0, 1, &test_context.vb, &stride, &offset);
+        ID3D10Device_VSSetShader(device, test_context.vs);
+        ID3D10Device_PSSetShader(device, test_context.ps);
+        ID3D10Device_Draw(device, 4, 0);
+
+        check_texture_vec4(rt, &tests[i].expect, 1);
+
+        ID3D10InputLayout_Release(input_layout);
+
+        winetest_pop_context();
+    }
+
+    ID3D10RenderTargetView_Release(rtv);
+    ID3D10Texture2D_Release(rt);
+    release_test_context(&test_context);
+}
+
 START_TEST(d3d10core)
 {
     unsigned int argc, i;
@@ -19562,6 +19755,7 @@ START_TEST(d3d10core)
     queue_test(test_dynamic_map_synchronization);
     queue_test(test_rtv_depth_slice);
     queue_test(test_stencil_only_write_after_clear);
+    queue_test(test_vertex_formats);
 
     run_queued_tests();
 
diff --git a/dlls/d3d11/tests/d3d11.c b/dlls/d3d11/tests/d3d11.c
index 1f6b211f693..9bb585f8c13 100644
--- a/dlls/d3d11/tests/d3d11.c
+++ b/dlls/d3d11/tests/d3d11.c
@@ -2512,56 +2512,66 @@ static void test_create_texture1d(void)
     ok(!refcount, "Device has %lu references left.\n", refcount);
 }
 
-#define test_dxgi_resource(a) test_dxgi_resource_(__LINE__, a)
-static void test_dxgi_resource_(unsigned int line, void *iface)
+static void test_dxgi_resource(void *iface, unsigned int bind_flags)
 {
     IDXGIResource *resource, *resource2;
     IDXGISurface *surface, *surface2;
+    DXGI_USAGE usage, expected_usage;
     IUnknown *object = iface, *unk;
     DWORD data;
     HRESULT hr;
     UINT size;
 
     hr = IUnknown_QueryInterface(object, &IID_IDXGIResource, (void **)&resource);
-    ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-    if (FAILED(hr)) return;
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = IDXGIResource_GetUsage(resource, &usage);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    expected_usage = 0;
+    if (bind_flags & D3D11_BIND_RENDER_TARGET)
+        expected_usage |= DXGI_USAGE_RENDER_TARGET_OUTPUT;
+    if (bind_flags & D3D11_BIND_SHADER_RESOURCE)
+        expected_usage |= DXGI_USAGE_SHADER_INPUT;
+    if (bind_flags & D3D11_BIND_UNORDERED_ACCESS)
+        expected_usage |= DXGI_USAGE_UNORDERED_ACCESS;
+    ok(usage == expected_usage, "Got usage %#x.\n", usage);
 
     if (SUCCEEDED(IUnknown_QueryInterface(object, &IID_IDXGISurface, (void **)&surface)))
     {
         hr = IDXGISurface_QueryInterface(surface, &IID_IDXGIDeviceSubObject, (void **)&unk);
-        ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-        ok_(__FILE__, line)((IUnknown *)resource == unk, "Unexpected interface pointer.\n");
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok((IUnknown *)resource == unk, "Unexpected interface pointer.\n");
         IUnknown_Release(unk);
 
         hr = IDXGISurface_QueryInterface(surface, &IID_IDXGIObject, (void **)&unk);
-        ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-        ok_(__FILE__, line)((IUnknown *)resource == unk, "Unexpected interface pointer.\n");
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok((IUnknown *)resource == unk, "Unexpected interface pointer.\n");
         IUnknown_Release(unk);
 
         hr = IDXGISurface_QueryInterface(surface, &IID_IDXGIResource, (void **)&resource2);
-        ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-        ok_(__FILE__, line)(resource2 == resource, "Unexpected resource pointer.\n");
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(resource2 == resource, "Unexpected resource pointer.\n");
         IDXGIResource_Release(resource2);
 
         hr = IDXGIResource_QueryInterface(resource, &IID_IDXGISurface, (void **)&surface2);
-        ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-        ok_(__FILE__, line)(surface2 == surface, "Unexpected surface pointer.\n");
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(surface2 == surface, "Unexpected surface pointer.\n");
         IDXGISurface_Release(surface2);
 
         hr = IDXGISurface_GetParent(surface, &IID_IDXGIResource, (void **)&resource2);
-        ok_(__FILE__, line)(hr == E_NOINTERFACE, "Got unexpected hr %#lx.\n", hr);
+        ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
         hr = IDXGIResource_GetParent(resource, &IID_IDXGISurface, (void **)&surface2);
-        ok_(__FILE__, line)(hr == E_NOINTERFACE, "Got unexpected hr %#lx.\n", hr);
+        ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
 
         data = 123;
         hr = IDXGIResource_SetPrivateData(resource, &IID_IUnknown, sizeof(data), &data);
-        ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
 
         size = sizeof(data);
         data = 0;
         hr = IDXGISurface_GetPrivateData(surface, &IID_IUnknown, &size, &data);
-        ok_(__FILE__, line)(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-        ok_(__FILE__, line)(data == 123, "Unexpected data %#lx.\n", data);
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(data == 123, "Unexpected data %#lx.\n", data);
 
         IDXGISurface_Release(surface);
     }
@@ -2569,6 +2579,98 @@ static void test_dxgi_resource_(unsigned int line, void *iface)
     IDXGIResource_Release(resource);
 }
 
+static void test_dxgi_resources(void)
+{
+    struct d3d11_test_context test_context;
+    ID3D11Device *device;
+    unsigned int i, j;
+    HRESULT hr;
+
+    static const unsigned int bind_flags[] =
+    {
+        0,
+        D3D11_BIND_SHADER_RESOURCE,
+        D3D11_BIND_RENDER_TARGET,
+        D3D11_BIND_DEPTH_STENCIL,
+        D3D11_BIND_UNORDERED_ACCESS,
+        D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
+        D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS,
+        D3D11_BIND_CONSTANT_BUFFER,
+        D3D11_BIND_VERTEX_BUFFER,
+        D3D11_BIND_INDEX_BUFFER,
+        D3D11_BIND_STREAM_OUTPUT,
+    };
+
+    static const struct
+    {
+        D3D11_RESOURCE_DIMENSION dimension;
+        unsigned int level_count;
+    }
+    dimensions[] =
+    {
+        {D3D11_RESOURCE_DIMENSION_BUFFER, 0},
+        {D3D11_RESOURCE_DIMENSION_TEXTURE1D, 1},
+        {D3D11_RESOURCE_DIMENSION_TEXTURE1D, 0},
+        {D3D11_RESOURCE_DIMENSION_TEXTURE2D, 1},
+        {D3D11_RESOURCE_DIMENSION_TEXTURE2D, 0},
+        {D3D11_RESOURCE_DIMENSION_TEXTURE3D, 1},
+        {D3D11_RESOURCE_DIMENSION_TEXTURE3D, 0},
+    };
+
+    if (!init_test_context(&test_context, NULL))
+        return;
+    device = test_context.device;
+
+    for (i = 0; i < ARRAY_SIZE(bind_flags); ++i)
+    {
+        if ((bind_flags[i] & D3D11_BIND_UNORDERED_ACCESS)
+                && ID3D11Device_GetFeatureLevel(device) < D3D_FEATURE_LEVEL_11_0)
+            continue;
+
+        for (j = 0; j < ARRAY_SIZE(dimensions); ++j)
+        {
+            struct resource_desc resource_desc =
+            {
+                .dimension = dimensions[j].dimension,
+                .width = 64,
+                .height = 64,
+                .depth_or_array_size = 1,
+                .level_count = dimensions[j].level_count,
+                .format = DXGI_FORMAT_R8G8B8A8_UNORM,
+                .sample_desc.Count = 1,
+                .usage = D3D11_USAGE_DEFAULT,
+                .bind_flags = bind_flags[i],
+            };
+            ID3D11Resource *resource;
+
+            if ((bind_flags[i] & (D3D11_BIND_CONSTANT_BUFFER | D3D11_BIND_VERTEX_BUFFER
+                    | D3D11_BIND_INDEX_BUFFER | D3D11_BIND_STREAM_OUTPUT))
+                    && resource_desc.dimension != D3D11_RESOURCE_DIMENSION_BUFFER)
+                continue;
+
+            if (bind_flags[i] & D3D11_BIND_DEPTH_STENCIL)
+            {
+                resource_desc.format = DXGI_FORMAT_D24_UNORM_S8_UINT;
+                if (resource_desc.dimension != D3D11_RESOURCE_DIMENSION_TEXTURE1D
+                        && resource_desc.dimension != D3D11_RESOURCE_DIMENSION_TEXTURE2D)
+                    continue;
+            }
+
+            winetest_push_context("Bind flags %#x, dimension %#x, level_count %u",
+                    bind_flags[i], dimensions[j].dimension, dimensions[j].level_count);
+
+            hr = create_resource(device, &resource_desc, NULL, &resource);
+            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            test_dxgi_resource(resource, bind_flags[i]);
+            ID3D11Resource_Release(resource);
+
+            winetest_pop_context();
+        }
+    }
+
+    release_test_context(&test_context);
+}
+
 static void test_texture1d_interfaces(void)
 {
     ID3D10Texture1D *d3d10_texture;
@@ -2628,15 +2730,12 @@ static void test_texture1d_interfaces(void)
 
     hr = ID3D11Device_CreateTexture1D(device, &desc, NULL, &texture);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-    test_dxgi_resource(texture);
     ID3D11Texture1D_Release(texture);
 
     desc.MipLevels = 0;
     hr = ID3D11Device_CreateTexture1D(device, &desc, NULL, &texture);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-    test_dxgi_resource(texture);
     check_interface(texture, &IID_IDXGISurface, FALSE, FALSE);
-    check_interface(texture, &IID_IDXGIResource, TRUE, FALSE);
     hr = check_interface(texture, &IID_ID3D10Texture1D, TRUE, TRUE); /* Not available on all Windows versions. */
     ID3D11Texture1D_Release(texture);
     if (FAILED(hr))
@@ -3025,16 +3124,12 @@ static void test_texture2d_interfaces(void)
     hr = ID3D11Device_CreateTexture2D(device, &desc, NULL, &texture);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
     check_interface(texture, &IID_IDXGISurface, TRUE, FALSE);
-    check_interface(texture, &IID_IDXGIResource, TRUE, FALSE);
-    test_dxgi_resource(texture);
     ID3D11Texture2D_Release(texture);
 
     desc.MipLevels = 0;
     hr = ID3D11Device_CreateTexture2D(device, &desc, NULL, &texture);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
     check_interface(texture, &IID_IDXGISurface, FALSE, FALSE);
-    check_interface(texture, &IID_IDXGIResource, TRUE, FALSE);
-    test_dxgi_resource(texture);
     hr = check_interface(texture, &IID_ID3D10Texture2D, TRUE, TRUE); /* Not available on all Windows versions. */
     ID3D11Texture2D_Release(texture);
     if (FAILED(hr))
@@ -3299,8 +3394,6 @@ static void test_texture3d_interfaces(void)
     hr = ID3D11Device_CreateTexture3D(device, &desc, NULL, &texture);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
     check_interface(texture, &IID_IDXGISurface, FALSE, FALSE);
-    check_interface(texture, &IID_IDXGIResource, TRUE, FALSE);
-    test_dxgi_resource(texture);
     hr = check_interface(texture, &IID_ID3D10Texture3D, TRUE, TRUE); /* Not available on all Windows versions. */
     ID3D11Texture3D_Release(texture);
     if (FAILED(hr))
@@ -21839,7 +21932,7 @@ static void test_stencil_separate(void)
     rs_desc.ScissorEnable = FALSE;
     rs_desc.MultisampleEnable = FALSE;
     rs_desc.AntialiasedLineEnable = FALSE;
-    ID3D11Device_CreateRasterizerState(device, &rs_desc, &rs);
+    hr = ID3D11Device_CreateRasterizerState(device, &rs_desc, &rs);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
 
     ID3D11DeviceContext_ClearRenderTargetView(context, test_context.backbuffer_rtv, red);
@@ -21859,7 +21952,7 @@ static void test_stencil_separate(void)
 
     ID3D11RasterizerState_Release(rs);
     rs_desc.FrontCounterClockwise = TRUE;
-    ID3D11Device_CreateRasterizerState(device, &rs_desc, &rs);
+    hr = ID3D11Device_CreateRasterizerState(device, &rs_desc, &rs);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
     ID3D11DeviceContext_RSSetState(context, rs);
 
@@ -28408,7 +28501,7 @@ static void test_depth_bias(void)
                 for (k = 0; k < ARRAY_SIZE(bias_clamp_tests); ++k)
                 {
                     rasterizer_desc.DepthBiasClamp = bias_clamp_tests[k];
-                    ID3D11Device_CreateRasterizerState(device, &rasterizer_desc, &rs);
+                    hr = ID3D11Device_CreateRasterizerState(device, &rasterizer_desc, &rs);
                     ok(hr == S_OK, "Format %#x, quad %u, bias %u, clamp %u: Got unexpected hr %#lx.\n",
                             format, i, j, k, hr);
                     ID3D11DeviceContext_RSSetState(context, rs);
@@ -28492,7 +28585,7 @@ static void test_depth_bias(void)
                 {
                     BOOL all_match = TRUE;
                     rasterizer_desc.DepthBiasClamp = bias_clamp_tests[k];
-                    ID3D11Device_CreateRasterizerState(device, &rasterizer_desc, &rs);
+                    hr = ID3D11Device_CreateRasterizerState(device, &rasterizer_desc, &rs);
                     ok(hr == S_OK, "Format %#x, slope %u, bias %u, clamp %u: Got unexpected hr %#lx.\n",
                             format, i, j, k, hr);
                     ID3D11DeviceContext_RSSetState(context, rs);
@@ -34725,6 +34818,196 @@ static void test_rtv_depth_slice(void)
     release_test_context(&test_context);
 }
 
+static void test_vertex_formats(void)
+{
+    struct d3d11_test_context test_context;
+    ID3D11DeviceContext *context;
+    ID3D11RenderTargetView *rtv;
+    ID3D11Device *device;
+    ID3D11Texture2D *rt;
+    unsigned int i;
+    HRESULT hr;
+
+    static const D3D11_TEXTURE2D_DESC rt_desc =
+    {
+        .Width = 4,
+        .Height = 4,
+        .MipLevels = 1,
+        .ArraySize = 1,
+        .Format = DXGI_FORMAT_R32G32B32A32_FLOAT,
+        .SampleDesc.Count = 1,
+        .Usage = D3D11_USAGE_DEFAULT,
+        .BindFlags = D3D11_BIND_RENDER_TARGET,
+    };
+
+    static const struct quad
+    {
+        struct vec2 position;
+        unsigned int color[4];
+    }
+    quad[] =
+    {
+        {{-1.0f, -1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+        {{-1.0f,  1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+        {{ 1.0f, -1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+        {{ 1.0f,  1.0f}, {0x87654321, 0x12345678, 0xcccccccc, 0xdeadbeef}},
+    };
+
+    static const unsigned int vs_code[] =
+    {
+#if 0
+        void main(inout float4 position : sv_position, inout float4 color : COLOR)
+        {
+        }
+#endif
+        0x43425844, 0xc2f6fe60, 0x8a304938, 0x14c1a190, 0xe6f3e35e, 0x00000001, 0x00000144, 0x00000003,
+        0x0000002c, 0x00000080, 0x000000d4, 0x4e475349, 0x0000004c, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000f0f, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x705f7673, 0x7469736f, 0x006e6f69, 0x4f4c4f43, 0xabab0052,
+        0x4e47534f, 0x0000004c, 0x00000002, 0x00000008, 0x00000038, 0x00000000, 0x00000001, 0x00000003,
+        0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x0000000f,
+        0x705f7673, 0x7469736f, 0x006e6f69, 0x4f4c4f43, 0xabab0052, 0x52444853, 0x00000068, 0x00010040,
+        0x0000001a, 0x0300005f, 0x001010f2, 0x00000000, 0x0300005f, 0x001010f2, 0x00000001, 0x04000067,
+        0x001020f2, 0x00000000, 0x00000001, 0x03000065, 0x001020f2, 0x00000001, 0x05000036, 0x001020f2,
+        0x00000000, 0x00101e46, 0x00000000, 0x05000036, 0x001020f2, 0x00000001, 0x00101e46, 0x00000001,
+        0x0100003e,
+    };
+
+    static const unsigned int ps_code[] =
+    {
+#if 0
+        float4 main(float4 position : sv_position, float4 color : COLOR) : sv_target
+        {
+            return color;
+        }
+#endif
+        0x43425844, 0xb9b047ca, 0x73193a19, 0xb9a919ed, 0x21c2ff5f, 0x00000001, 0x000000f4, 0x00000003,
+        0x0000002c, 0x00000080, 0x000000b4, 0x4e475349, 0x0000004c, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x705f7673, 0x7469736f, 0x006e6f69, 0x4f4c4f43, 0xabab0052,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000f, 0x745f7673, 0x65677261, 0xabab0074, 0x52444853, 0x00000038, 0x00000040,
+        0x0000000e, 0x03001062, 0x001010f2, 0x00000001, 0x03000065, 0x001020f2, 0x00000000, 0x05000036,
+        0x001020f2, 0x00000000, 0x00101e46, 0x00000001, 0x0100003e,
+    };
+
+    static const struct vec4 white = {1.0f, 1.0f, 1.0f, 1.0f};
+
+    static const struct
+    {
+        DXGI_FORMAT format;
+        struct vec4 expect;
+    }
+    tests[] =
+    {
+        {DXGI_FORMAT_R32G32B32A32_FLOAT,    {-1.72477726e-34,  5.69045661e-28, -1.07374176e+08, -6.25985340e+18}},
+        {DXGI_FORMAT_R32G32B32_FLOAT,       {-1.72477726e-34,  5.69045661e-28, -1.07374176e+08,  1.0}},
+        {DXGI_FORMAT_R32G32_FLOAT,          {-1.72477726e-34,  5.69045661e-28,  0.0,             1.0}},
+        {DXGI_FORMAT_R32_FLOAT,             {-1.72477726e-34,  0.0,             0.0,             1.0}},
+
+        {DXGI_FORMAT_R10G10B10A2_UNORM,     { 7.82991230e-01,  3.28445762e-01,  1.15347020e-01,  6.66666666e-01}},
+
+        {DXGI_FORMAT_R11G11B10_FLOAT,       { 1.89453125e-01,  1.30000000e+01,  3.81250000e+00,  1.0}},
+
+        {DXGI_FORMAT_R16G16B16A16_FLOAT,    { 3.56445313e+00, -1.12831593e-04,  1.03500000e+02,  7.57217407e-04}},
+        {DXGI_FORMAT_R16G16B16A16_UNORM,    { 2.62226284e-01,  5.28892934e-01,  3.37773710e-01,  7.11070448e-02}},
+        {DXGI_FORMAT_R16G16B16A16_SNORM,    { 5.24460614e-01, -9.42258954e-01,  6.75557733e-01,  1.42216250e-01}},
+        {DXGI_FORMAT_R16G16_FLOAT,          { 3.56445313e+00, -1.12831593e-04,  0.0,             1.0}},
+        {DXGI_FORMAT_R16G16_UNORM,          { 2.62226284e-01,  5.28892934e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R16G16_SNORM,          { 5.24460614e-01, -9.42258954e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R16_FLOAT,             { 3.56445313e+00,  0.0,             0.0,             1.0}},
+        {DXGI_FORMAT_R16_UNORM,             { 2.62226284e-01,  0.0,             0.0,             1.0}},
+        {DXGI_FORMAT_R16_SNORM,             { 5.24460614e-01,  0.0,             0.0,             1.0}},
+
+        {DXGI_FORMAT_R8G8B8A8_UNORM,        { 1.29411772e-01,  2.62745112e-01,  3.96078438e-01,  5.29411793e-01}},
+        {DXGI_FORMAT_R8G8B8A8_SNORM,        { 2.59842515e-01,  5.27559042e-01,  7.95275569e-01, -9.52755928e-01}},
+        {DXGI_FORMAT_R8G8_UNORM,            { 1.29411772e-01,  2.62745112e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R8G8_SNORM,            { 2.59842515e-01,  5.27559042e-01,  0.0,             1.0}},
+        {DXGI_FORMAT_R8_UNORM,              { 1.29411772e-01,  0.0,             0.0,             1.0}},
+        {DXGI_FORMAT_R8_SNORM,              { 2.59842515e-01,  0.0,             0.0,             1.0}},
+
+        {DXGI_FORMAT_B8G8R8A8_UNORM,        { 3.96078438e-01,  2.62745112e-01,  1.29411772e-01,  5.29411793e-01}},
+        {DXGI_FORMAT_B8G8R8X8_UNORM,        { 3.96078438e-01,  2.62745112e-01,  1.29411772e-01,  1.0}},
+    };
+
+    if (!init_test_context(&test_context, NULL))
+        return;
+    device = test_context.device;
+    context = test_context.immediate_context;
+
+    hr = ID3D11Device_CreateTexture2D(device, &rt_desc, NULL, &rt);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = ID3D11Device_CreateRenderTargetView(device, (ID3D11Resource *)rt, NULL, &rtv);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = ID3D11Device_CreateVertexShader(device, vs_code, sizeof(vs_code), NULL, &test_context.vs);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = ID3D11Device_CreatePixelShader(device, ps_code, sizeof(ps_code), NULL, &test_context.ps);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_context.vb = create_buffer(device, D3D11_BIND_VERTEX_BUFFER, sizeof(quad), quad);
+
+    for (i = 0; i < ARRAY_SIZE(tests); ++i)
+    {
+        const D3D11_INPUT_ELEMENT_DESC layout_desc[] =
+        {
+            {
+                .SemanticName = "sv_position",
+                .SemanticIndex = 0,
+                .Format = DXGI_FORMAT_R32G32_FLOAT,
+                .InputSlot = 0,
+                .AlignedByteOffset = offsetof(struct quad, position),
+                .InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA,
+            },
+            {
+                .SemanticName = "COLOR",
+                .SemanticIndex = 0,
+                .Format = tests[i].format,
+                .InputSlot = 0,
+                .AlignedByteOffset = offsetof(struct quad, color),
+                .InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA,
+            },
+        };
+
+        static const unsigned int stride = sizeof(*quad);
+        static const unsigned int offset = 0;
+        ID3D11InputLayout *input_layout;
+        unsigned int format_support;
+
+        hr = ID3D11Device_CheckFormatSupport(device, tests[i].format, &format_support);
+        ok(hr == S_OK || hr == E_FAIL, "Got hr %#lx.\n", hr);
+
+        if (!(format_support & D3D11_FORMAT_SUPPORT_IA_VERTEX_BUFFER))
+            continue;
+
+        winetest_push_context("Format %#x", tests[i].format);
+
+        hr = ID3D11Device_CreateInputLayout(device, layout_desc, ARRAY_SIZE(layout_desc),
+                vs_code, sizeof(vs_code), &input_layout);
+        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+        clear_rtv(context, rtv, &white);
+        ID3D11DeviceContext_OMSetRenderTargets(context, 1, &rtv, NULL);
+        ID3D11DeviceContext_IASetInputLayout(context, input_layout);
+        ID3D11DeviceContext_IASetPrimitiveTopology(context, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+        ID3D11DeviceContext_IASetVertexBuffers(context, 0, 1, &test_context.vb, &stride, &offset);
+        ID3D11DeviceContext_VSSetShader(context, test_context.vs, NULL, 0);
+        ID3D11DeviceContext_PSSetShader(context, test_context.ps, NULL, 0);
+        ID3D11DeviceContext_Draw(context, 4, 0);
+
+        check_texture_vec4(rt, &tests[i].expect, 1);
+
+        ID3D11InputLayout_Release(input_layout);
+
+        winetest_pop_context();
+    }
+
+    ID3D11RenderTargetView_Release(rtv);
+    ID3D11Texture2D_Release(rt);
+    release_test_context(&test_context);
+}
+
 START_TEST(d3d11)
 {
     unsigned int argc, i;
@@ -34907,6 +35190,8 @@ START_TEST(d3d11)
     queue_test(test_user_defined_annotation);
     queue_test(test_logic_op);
     queue_test(test_rtv_depth_slice);
+    queue_test(test_vertex_formats);
+    queue_test(test_dxgi_resources);
 
     run_queued_tests();
 
diff --git a/dlls/d3d12/tests/d3d12.c b/dlls/d3d12/tests/d3d12.c
index 0d3deafda45..5d3f8a36a2d 100644
--- a/dlls/d3d12/tests/d3d12.c
+++ b/dlls/d3d12/tests/d3d12.c
@@ -884,8 +884,7 @@ static void test_create_device(void)
     ok(refcount == 1, "Got unexpected refcount %lu.\n", refcount);
     hr = D3D12CreateDevice((IUnknown *)adapter, D3D_FEATURE_LEVEL_11_0, &IID_ID3D12Device, (void **)&device);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-    refcount = IDXGIAdapter_Release(adapter);
-    ok(refcount >= 1, "Got unexpected refcount %lu.\n", refcount);
+    IDXGIAdapter_Release(adapter);
     adapter = NULL;
 
     luid = ID3D12Device_GetAdapterLuid(device);
@@ -1409,7 +1408,8 @@ static void test_desktop_window(void)
     swapchain_desc.Width = rect.right;
     swapchain_desc.Height = rect.bottom;
     hr = IDXGIFactory4_CreateSwapChainForHwnd(factory, queue, window, &swapchain_desc, NULL, NULL, &swapchain);
-    ok(hr == E_ACCESSDENIED, "Got unexpected hr %#lx.\n", hr);
+    ok(hr == E_ACCESSDENIED || broken(hr == E_OUTOFMEMORY /* win10 1709 */),
+       "Got unexpected hr %#lx.\n", hr);
 
     IDXGIFactory4_Release(factory);
     destroy_test_context(&context);
diff --git a/dlls/d3d12core/Makefile.in b/dlls/d3d12core/Makefile.in
new file mode 100644
index 00000000000..8778b66138b
--- /dev/null
+++ b/dlls/d3d12core/Makefile.in
@@ -0,0 +1 @@
+MODULE = d3d12core.dll
diff --git a/dlls/d3d12core/d3d12core.spec b/dlls/d3d12core/d3d12core.spec
new file mode 100644
index 00000000000..c9c73bd4ee4
--- /dev/null
+++ b/dlls/d3d12core/d3d12core.spec
@@ -0,0 +1,2 @@
+@ stub D3D12GetInterface
+@ stub D3D12SDKVersion
diff --git a/dlls/d3d8/tests/device.c b/dlls/d3d8/tests/device.c
index 59532d0a208..c8f52484054 100644
--- a/dlls/d3d8/tests/device.c
+++ b/dlls/d3d8/tests/device.c
@@ -7775,10 +7775,12 @@ static void test_pixel_format(void)
     PIXELFORMATDESCRIPTOR pfd;
     IDirect3D8 *d3d8 = NULL;
     IDirect3DDevice8 *device = NULL;
-    HWND hwnd, hwnd2;
-    HDC hdc, hdc2;
+    HWND hwnd, hwnd2, hwnd3;
+    HDC hdc, hdc2, hdc3;
+    ULONG refcount;
     HMODULE gl;
     HRESULT hr;
+    BOOL ret;
 
     static const float point[] = {0.0f, 0.0f, 0.0f};
 
@@ -7877,14 +7879,68 @@ static void test_pixel_format(void)
     test_format = GetPixelFormat(hdc2);
     ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-cleanup:
-    if (device)
+    refcount = IDirect3DDevice8_Release(device);
+    ok(!refcount, "Device has %lu references left.\n", refcount);
+    IDirect3D8_Release(d3d8);
+
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+
+    /* Test that creating a device doesn't set a pixel format on a window which
+     * never had one. */
+
+    hwnd3 = create_window();
+    hdc3 = GetDC(hwnd3);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    d3d8 = Direct3DCreate8(D3D_SDK_VERSION);
+    ok(!!d3d8, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d8, hwnd3, NULL)))
     {
-        UINT refcount = IDirect3DDevice8_Release(device);
-        ok(!refcount, "Device has %u references left.\n", refcount);
+        skip("Failed to create device\n");
+        goto cleanup;
     }
-    if (d3d8)
-        IDirect3D8_Release(d3d8);
+
+    hr = IDirect3DDevice8_SetVertexShader(device, D3DFVF_XYZ);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IDirect3DDevice8_BeginScene(device);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IDirect3DDevice8_DrawPrimitiveUP(device, D3DPT_POINTLIST, 1, point, 3 * sizeof(float));
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IDirect3DDevice8_EndScene(device);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    refcount = IDirect3DDevice8_Release(device);
+    ok(!refcount, "Device has %lu references left.\n", refcount);
+    IDirect3D8_Release(d3d8);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ret = SetPixelFormat(hdc3, format, &pfd);
+    ok(ret, "Failed to set pixel format %d.\n", format);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(test_format == format, "Expected pixel format %d, got %d.\n", format, test_format);
+
+    ReleaseDC(hwnd3, hdc3);
+    DestroyWindow(hwnd3);
+
+cleanup:
     FreeLibrary(gl);
     ReleaseDC(hwnd2, hdc2);
     ReleaseDC(hwnd, hdc);
diff --git a/dlls/d3d9/tests/device.c b/dlls/d3d9/tests/device.c
index 0a95e819018..0e361b3ac23 100644
--- a/dlls/d3d9/tests/device.c
+++ b/dlls/d3d9/tests/device.c
@@ -11050,10 +11050,12 @@ static void test_pixel_format(void)
     PIXELFORMATDESCRIPTOR pfd;
     IDirect3D9 *d3d9 = NULL;
     IDirect3DDevice9 *device = NULL;
-    HWND hwnd, hwnd2;
-    HDC hdc, hdc2;
+    HWND hwnd, hwnd2, hwnd3;
+    HDC hdc, hdc2, hdc3;
+    ULONG refcount;
     HMODULE gl;
     HRESULT hr;
+    BOOL ret;
 
     static const float point[] = {0.0f, 0.0f, 0.0f};
 
@@ -11152,14 +11154,68 @@ static void test_pixel_format(void)
     test_format = GetPixelFormat(hdc2);
     ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-cleanup:
-    if (device)
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %lu references left.\n", refcount);
+    IDirect3D9_Release(d3d9);
+
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+
+    /* Test that creating a device doesn't set a pixel format on a window which
+     * never had one. */
+
+    hwnd3 = create_window();
+    hdc3 = GetDC(hwnd3);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    d3d9 = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d9, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d9, hwnd3, NULL)))
     {
-        ULONG refcount = IDirect3DDevice9_Release(device);
-        ok(!refcount, "Device has %lu references left.\n", refcount);
+        skip("Failed to create device\n");
+        goto cleanup;
     }
-    if (d3d9)
-        IDirect3D9_Release(d3d9);
+
+    hr = IDirect3DDevice9_SetFVF(device, D3DFVF_XYZ);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IDirect3DDevice9_BeginScene(device);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IDirect3DDevice9_DrawPrimitiveUP(device, D3DPT_POINTLIST, 1, point, 3 * sizeof(float));
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IDirect3DDevice9_EndScene(device);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %lu references left.\n", refcount);
+    IDirect3D9_Release(d3d9);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ret = SetPixelFormat(hdc3, format, &pfd);
+    ok(ret, "Failed to set pixel format %d.\n", format);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(test_format == format, "Expected pixel format %d, got %d.\n", format, test_format);
+
+    ReleaseDC(hwnd3, hdc3);
+    DestroyWindow(hwnd3);
+
+cleanup:
     FreeLibrary(gl);
     ReleaseDC(hwnd2, hdc2);
     ReleaseDC(hwnd, hdc);
diff --git a/dlls/d3dcompiler_43/tests/hlsl_d3d11.c b/dlls/d3dcompiler_43/tests/hlsl_d3d11.c
index 4f52002866e..3e6f3614986 100644
--- a/dlls/d3dcompiler_43/tests/hlsl_d3d11.c
+++ b/dlls/d3dcompiler_43/tests/hlsl_d3d11.c
@@ -501,7 +501,7 @@ static void test_trig(void)
         for (i = 0; i < 640; i += 20)
         {
             v = get_readback_vec4(&rb, i, 0);
-            ok(compare_vec4(v, sinf(i), cosf(i), 0.0f, 0.0f, 8192),
+            ok(compare_vec4(v, sinf(i), cosf(i), 0.0f, 0.0f, 16384),
                     "Test %u: Got {%.8e, %.8e, %.8e, %.8e}, expected {%.8e, %.8e, %.8e, %.8e}.\n",
                     i, v->x, v->y, v->z, v->w, sinf(i), cos(i), 0.0f, 0.0f);
         }
diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index d22415b1f69..ce5abfcc735 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -396,6 +396,8 @@ struct d3dx_parameters_store
     unsigned int full_name_tmp_size;
 };
 
+HRESULT d3dx_init_parameters_store(struct d3dx_parameters_store *store, unsigned int count) DECLSPEC_HIDDEN;
+void d3dx_parameters_store_cleanup(struct d3dx_parameters_store *store) DECLSPEC_HIDDEN;
 struct d3dx_parameter *get_parameter_by_name(struct d3dx_parameters_store *store,
         struct d3dx_parameter *parameter, const char *name) DECLSPEC_HIDDEN;
 
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index c5e1f6ed348..db40bc249cd 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -745,6 +745,40 @@ static void free_parameter_block(struct d3dx_parameter_block *block)
     heap_free(block);
 }
 
+static int param_rb_compare(const void *key, const struct wine_rb_entry *entry)
+{
+    const char *name = key;
+    struct d3dx_parameter *param = WINE_RB_ENTRY_VALUE(entry, struct d3dx_parameter, rb_entry);
+
+    return strcmp(name, param->full_name);
+}
+
+HRESULT d3dx_init_parameters_store(struct d3dx_parameters_store *store, unsigned int count)
+{
+    store->count = count;
+    wine_rb_init(&store->tree, param_rb_compare);
+
+    if (store->count && !(store->parameters = heap_alloc_zero(sizeof(*store->parameters) * store->count)))
+        return E_OUTOFMEMORY;
+
+    return S_OK;
+}
+
+void d3dx_parameters_store_cleanup(struct d3dx_parameters_store *store)
+{
+    unsigned int i;
+
+    heap_free(store->full_name_tmp);
+
+    if (store->parameters)
+    {
+        for (i = 0; i < store->count; ++i)
+            free_top_level_parameter(&store->parameters[i]);
+        heap_free(store->parameters);
+        store->parameters = NULL;
+    }
+}
+
 static void d3dx_effect_cleanup(struct d3dx_effect *effect)
 {
     struct d3dx_parameter_block *block, *cursor;
@@ -760,14 +794,7 @@ static void d3dx_effect_cleanup(struct d3dx_effect *effect)
         free_parameter_block(block);
     }
 
-    heap_free(effect->params.full_name_tmp);
-
-    if (effect->params.parameters)
-    {
-        for (i = 0; i < effect->params.count; ++i)
-            free_top_level_parameter(&effect->params.parameters[i]);
-        heap_free(effect->params.parameters);
-    }
+    d3dx_parameters_store_cleanup(&effect->params);
 
     if (effect->techniques)
     {
@@ -5371,14 +5398,6 @@ static void param_set_magic_number(struct d3dx_parameter *param)
     memcpy(param->magic_string, parameter_magic_string, sizeof(parameter_magic_string));
 }
 
-static int param_rb_compare(const void *key, const struct wine_rb_entry *entry)
-{
-    const char *name = key;
-    struct d3dx_parameter *param = WINE_RB_ENTRY_VALUE(entry, struct d3dx_parameter, rb_entry);
-
-    return strcmp(name, param->full_name);
-}
-
 static void add_param_to_tree(struct d3dx_effect *effect, struct d3dx_parameter *param,
         struct d3dx_parameter *parent, char separator, unsigned int element)
 {
@@ -6301,13 +6320,13 @@ static BOOL param_set_top_level_param(void *top_level_param, struct d3dx_paramet
 static HRESULT d3dx_parse_effect(struct d3dx_effect *effect, const char *data, UINT data_size,
         uint32_t start, const char **skip_constants, unsigned int skip_constants_count)
 {
-    unsigned int string_count, resource_count;
+    unsigned int string_count, resource_count, params_count;
     const char *ptr = data + start;
     unsigned int i;
     HRESULT hr;
 
-    effect->params.count = read_u32(&ptr);
-    TRACE("Parameter count: %u.\n", effect->params.count);
+    params_count = read_u32(&ptr);
+    TRACE("Parameter count: %u.\n", params_count);
 
     effect->technique_count = read_u32(&ptr);
     TRACE("Technique count: %u.\n", effect->technique_count);
@@ -6326,29 +6345,23 @@ static HRESULT d3dx_parse_effect(struct d3dx_effect *effect, const char *data, U
         goto err_out;
     }
 
-    wine_rb_init(&effect->params.tree, param_rb_compare);
-    if (effect->params.count)
+    if (FAILED(hr = d3dx_init_parameters_store(&effect->params, params_count)))
     {
-        effect->params.parameters = heap_alloc_zero(sizeof(*effect->params.parameters) * effect->params.count);
-        if (!effect->params.parameters)
-        {
-            ERR("Out of memory.\n");
-            hr = E_OUTOFMEMORY;
-            goto err_out;
-        }
+        hr = E_OUTOFMEMORY;
+        goto err_out;
+    }
 
-        for (i = 0; i < effect->params.count; ++i)
+    for (i = 0; i < effect->params.count; ++i)
+    {
+        param_set_magic_number(&effect->params.parameters[i].param);
+        hr = d3dx_parse_effect_parameter(effect, &effect->params.parameters[i], data, &ptr, effect->objects);
+        if (hr != D3D_OK)
         {
-            param_set_magic_number(&effect->params.parameters[i].param);
-            hr = d3dx_parse_effect_parameter(effect, &effect->params.parameters[i], data, &ptr, effect->objects);
-            if (hr != D3D_OK)
-            {
-                WARN("Failed to parse parameter %u.\n", i);
-                goto err_out;
-            }
-            walk_parameter_tree(&effect->params.parameters[i].param, param_set_top_level_param, &effect->params.parameters[i]);
-            add_param_to_tree(effect, &effect->params.parameters[i].param, NULL, 0, 0);
+            WARN("Failed to parse parameter %u.\n", i);
+            goto err_out;
         }
+        walk_parameter_tree(&effect->params.parameters[i].param, param_set_top_level_param, &effect->params.parameters[i]);
+        add_param_to_tree(effect, &effect->params.parameters[i].param, NULL, 0, 0);
     }
 
     if (effect->technique_count)
@@ -6427,15 +6440,7 @@ err_out:
         effect->techniques = NULL;
     }
 
-    if (effect->params.parameters)
-    {
-        for (i = 0; i < effect->params.count; ++i)
-        {
-            free_top_level_parameter(&effect->params.parameters[i]);
-        }
-        heap_free(effect->params.parameters);
-        effect->params.parameters = NULL;
-    }
+    d3dx_parameters_store_cleanup(&effect->params);
 
     if (effect->objects)
     {
diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index 8a7dfd76935..ebf62a99c6a 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -144,6 +144,7 @@ static double pres_div(double *args, int n) {return 0.0;}
 #define FOURCC_CLIT 0x54494c43
 #define FOURCC_FXLC 0x434c5846
 #define FOURCC_PRSI 0x49535250
+#define FOURCC_TX_1 0x54580100
 #define PRES_SIGN 0x46580000
 
 struct op_info
@@ -1110,13 +1111,15 @@ static HRESULT parse_preshader(struct d3dx_preshader *pres, unsigned int *ptr, u
         struct d3dx_parameters_store *parameters)
 {
     unsigned int *p;
-    unsigned int i, j, const_count;
+    unsigned int i, j, const_count, magic;
     double *dconst;
     HRESULT hr;
     unsigned int saved_word;
     unsigned int section_size;
 
-    TRACE("Preshader version %#x.\n", *ptr & 0xffff);
+    magic = *ptr;
+
+    TRACE("Preshader version %#x.\n", *ptr);
 
     if (!count)
     {
@@ -1186,6 +1189,8 @@ static HRESULT parse_preshader(struct d3dx_preshader *pres, unsigned int *ptr, u
         return D3DXERR_INVALIDDATA;
     }
     pres->regs.table_sizes[PRES_REGTAB_IMMED] = get_reg_offset(PRES_REGTAB_IMMED, const_count);
+    if (magic == FOURCC_TX_1)
+        pres->regs.table_sizes[PRES_REGTAB_INPUT] = 2;
 
     update_table_sizes_consts(pres->regs.table_sizes, &pres->inputs);
     for (i = 0; i < pres->ins_count; ++i)
@@ -1723,16 +1728,20 @@ HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval, const struct d3dx
     HRESULT hr;
     unsigned int i;
     unsigned int elements, elements_param, elements_table;
+    BOOL is_dirty;
     float *oc;
 
     TRACE("peval %p, param %p, param_value %p.\n", peval, param, param_value);
 
-    if (is_const_tab_input_dirty(&peval->pres.inputs, ULONG64_MAX))
+    if ((is_dirty = is_const_tab_input_dirty(&peval->pres.inputs, ULONG64_MAX)))
     {
         set_constants(&peval->pres.regs, &peval->pres.inputs,
-                next_update_version(peval->version_counter),
-                NULL, NULL, peval->param_type, FALSE, FALSE);
+                next_update_version(peval->version_counter), NULL, NULL,
+                peval->param_type, FALSE, FALSE);
+    }
 
+    if (is_dirty || peval->pres.regs.table_sizes[PRES_REGTAB_INPUT])
+    {
         if (FAILED(hr = execute_preshader(&peval->pres)))
             return hr;
     }
diff --git a/dlls/d3dx9_36/shader.c b/dlls/d3dx9_36/shader.c
index 3663eacf6da..1aa75d64dc5 100644
--- a/dlls/d3dx9_36/shader.c
+++ b/dlls/d3dx9_36/shader.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <assert.h>
 
 #include "d3dx9_private.h"
 #include "d3dcommon.h"
@@ -2361,6 +2362,9 @@ struct d3dx9_texture_shader
     LONG ref;
 
     ID3DXBuffer *byte_code;
+    ULONG64 version_counter;
+    struct d3dx_parameters_store parameters;
+    struct d3dx_param_eval *eval;
 };
 
 static inline struct d3dx9_texture_shader *impl_from_ID3DXTextureShader(ID3DXTextureShader *iface)
@@ -2406,6 +2410,8 @@ static ULONG WINAPI d3dx9_texture_shader_Release(ID3DXTextureShader *iface)
     {
         if (texture_shader->byte_code)
             ID3DXBuffer_Release(texture_shader->byte_code);
+        d3dx_free_param_eval(texture_shader->eval);
+        d3dx_parameters_store_cleanup(&texture_shader->parameters);
         HeapFree(GetProcessHeap(), 0, texture_shader);
     }
 
@@ -2610,6 +2616,15 @@ static const struct ID3DXTextureShaderVtbl d3dx9_texture_shader_vtbl =
     d3dx9_texture_shader_SetMatrixTransposePointerArray
 };
 
+static inline struct d3dx9_texture_shader *unsafe_impl_from_ID3DXTextureShader(ID3DXTextureShader *iface)
+{
+    if (!iface)
+        return NULL;
+
+    assert(iface->lpVtbl == &d3dx9_texture_shader_vtbl);
+    return impl_from_ID3DXTextureShader(iface);
+}
+
 HRESULT WINAPI D3DXCreateTextureShader(const DWORD *function, ID3DXTextureShader **texture_shader)
 {
     struct d3dx9_texture_shader *object;
@@ -2637,11 +2652,90 @@ HRESULT WINAPI D3DXCreateTextureShader(const DWORD *function, ID3DXTextureShader
     }
     memcpy(ID3DXBuffer_GetBufferPointer(object->byte_code), function, size);
 
+    if (FAILED(hr = d3dx_init_parameters_store(&object->parameters, 0)))
+    {
+        IUnknown_Release(&object->ID3DXTextureShader_iface);
+        return hr;
+    }
+
+    if (FAILED(hr = d3dx_create_param_eval(&object->parameters, ID3DXBuffer_GetBufferPointer(object->byte_code),
+            size, D3DXPT_FLOAT, &object->eval, &object->version_counter, NULL, 0)))
+    {
+        IUnknown_Release(&object->ID3DXTextureShader_iface);
+        return hr;
+    }
+
     *texture_shader = &object->ID3DXTextureShader_iface;
 
     return D3D_OK;
 }
 
+void WINAPI texture_shader_fill_2d(D3DXVECTOR4 *out, const D3DXVECTOR2 *texcoord,
+        const D3DXVECTOR2 *texelsize, void *data)
+{
+    struct d3dx9_texture_shader *shader = data;
+    struct d3dx_parameter param = { 0 };
+    float *inputs;
+
+    inputs = (float *)shader->eval->pres.regs.tables[PRES_REGTAB_INPUT];
+
+    *(inputs++) = texcoord->x;
+    *(inputs++) = texcoord->y;
+    *(inputs++) = 0.0f;
+    *(inputs++) = 0.0f;
+
+    *(inputs++) = texelsize->x;
+    *(inputs++) = texelsize->y;
+    *(inputs++) = 0.0f;
+    *(inputs++) = 0.0f;
+
+    param.type = D3DXPT_FLOAT;
+    param.bytes = 4 * sizeof(float);
+    d3dx_evaluate_parameter(shader->eval, &param, out);
+}
+
+void WINAPI texture_shader_fill_3d(D3DXVECTOR4 *out, const D3DXVECTOR3 *texcoord,
+        const D3DXVECTOR3 *texelsize, void *data)
+{
+    struct d3dx9_texture_shader *shader = data;
+    struct d3dx_parameter param = { 0 };
+    float *inputs;
+
+    inputs = (float *)shader->eval->pres.regs.tables[PRES_REGTAB_INPUT];
+
+    *(inputs++) = texcoord->x;
+    *(inputs++) = texcoord->y;
+    *(inputs++) = texcoord->z;
+    *(inputs++) = 0.0f;
+
+    *(inputs++) = texelsize->x;
+    *(inputs++) = texelsize->y;
+    *(inputs++) = texelsize->z;
+    *(inputs++) = 0.0f;
+
+    param.type = D3DXPT_FLOAT;
+    param.bytes = 4 * sizeof(float);
+    d3dx_evaluate_parameter(shader->eval, &param, out);
+}
+
+HRESULT WINAPI D3DXFillTextureTX(struct IDirect3DTexture9 *texture, ID3DXTextureShader *texture_shader)
+{
+    struct d3dx9_texture_shader *shader = unsafe_impl_from_ID3DXTextureShader(texture_shader);
+
+    TRACE("texture %p, texture_shader %p.\n", texture, texture_shader);
+
+    return D3DXFillTexture(texture, texture_shader_fill_2d, shader);
+}
+
+HRESULT WINAPI D3DXFillCubeTextureTX(struct IDirect3DCubeTexture9 *cube, ID3DXTextureShader *texture_shader)
+{
+    struct d3dx9_texture_shader *shader = unsafe_impl_from_ID3DXTextureShader(texture_shader);
+
+    TRACE("cube %p, texture_shader %p.\n", cube, texture_shader);
+
+    return D3DXFillCubeTexture(cube, texture_shader_fill_3d, shader);
+}
+
 static unsigned int get_instr_length(const DWORD *byte_code, unsigned int major, unsigned int minor)
 {
     DWORD opcode = *byte_code & 0xffff;
diff --git a/dlls/d3dx9_36/tests/texture.c b/dlls/d3dx9_36/tests/texture.c
index 20970a93dcd..30495508ac3 100644
--- a/dlls/d3dx9_36/tests/texture.c
+++ b/dlls/d3dx9_36/tests/texture.c
@@ -1330,6 +1330,15 @@ static void WINAPI fillfunc_cube(D3DXVECTOR4 *value, const D3DXVECTOR3 *texcoord
     value->w = texelsize->x;
 }
 
+static void WINAPI fillfunc_cube_coord(D3DXVECTOR4 *value, const D3DXVECTOR3 *texcoord,
+        const D3DXVECTOR3 *texelsize, void *data)
+{
+    value->x = texcoord->x;
+    value->y = texcoord->y;
+    value->z = texcoord->z;
+    value->w = 1.0f;
+}
+
 enum cube_coord
 {
     XCOORD = 0,
@@ -1362,119 +1371,146 @@ static float get_cube_coord(enum cube_coord coord, unsigned int x, unsigned int
     }
 }
 
-static void test_D3DXFillCubeTexture(IDirect3DDevice9 *device)
+static DWORD get_argb_color(D3DFORMAT format, DWORD x, DWORD y, const D3DLOCKED_RECT *lock_rect)
 {
-    IDirect3DCubeTexture9 *tex;
-    HRESULT hr;
-    D3DLOCKED_RECT lock_rect;
-    DWORD x, y, f, m;
-    DWORD v[4], e[4];
-    DWORD value, expected, size, pitch;
-    enum cube_coord coordmap[6][3] =
-        {
-            {ONE, YCOORDINV, XCOORDINV},
-            {ZERO, YCOORDINV, XCOORD},
-            {XCOORD, ONE, YCOORD},
-            {XCOORD, ZERO, YCOORDINV},
-            {XCOORD, YCOORDINV, ONE},
-            {XCOORDINV, YCOORDINV, ZERO}
-        };
-
-    size = 4;
-    hr = IDirect3DDevice9_CreateCubeTexture(device, size, 0, 0, D3DFMT_A8R8G8B8,
-                                            D3DPOOL_MANAGED, &tex, NULL);
+    DWORD value, ret;
+    int pitch;
 
-    if (SUCCEEDED(hr))
+    switch (format)
     {
-        hr = D3DXFillCubeTexture(tex, fillfunc_cube, NULL);
-        ok(hr == D3D_OK, "D3DXFillCubeTexture returned %#lx, expected %#lx\n", hr, D3D_OK);
+    case D3DFMT_A8R8G8B8:
+        pitch = lock_rect->Pitch / sizeof(DWORD);
+        return ((DWORD *)lock_rect->pBits)[y * pitch + x];
+    case D3DFMT_A1R5G5B5:
+        pitch = lock_rect->Pitch / sizeof(WORD);
+        value = ((WORD *)lock_rect->pBits)[y * pitch + x];
 
-        for (m = 0; m < 3; m++)
-        {
-            for (f = 0; f < 6; f++)
-            {
-                hr = IDirect3DCubeTexture9_LockRect(tex, f, m, &lock_rect, NULL, D3DLOCK_READONLY);
-                ok(hr == D3D_OK, "Couldn't lock the texture, error %#lx\n", hr);
-                if (SUCCEEDED(hr))
-                {
-                    pitch = lock_rect.Pitch / sizeof(DWORD);
-                    for (y = 0; y < size; y++)
-                    {
-                        for (x = 0; x < size; x++)
-                        {
-                            value = ((DWORD *)lock_rect.pBits)[y * pitch + x];
-                            v[0] = (value >> 24) & 0xff;
-                            v[1] = (value >> 16) & 0xff;
-                            v[2] = (value >> 8) & 0xff;
-                            v[3] = value & 0xff;
+        ret = (value >> 15 & 0x1) << 24
+                | (value >> 10 & 0x1f) << 16
+                | (value >> 5 & 0x1f) << 8
+                | (value & 0x1f);
 
-                            e[0] = (f == 0) || (f == 1) ?
-                                0 : (BYTE)(255.0f / size * 2.0f + 0.5f);
-                            e[1] = get_cube_coord(coordmap[f][0], x, y, size) / size * 255.0f + 0.5f;
-                            e[2] = get_cube_coord(coordmap[f][1], x, y, size) / size * 255.0f + 0.5f;
-                            e[3] = get_cube_coord(coordmap[f][2], x, y, size) / size * 255.0f + 0.5f;
-                            expected = e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3];
+        return ret;
 
-                            ok(color_match(v, e),
-                               "Texel at face %lu (%lu, %lu) doesn't match: %#lx, expected %#lx\n",
-                               f, x, y, value, expected);
-                        }
-                    }
-                    IDirect3DCubeTexture9_UnlockRect(tex, f, m);
-                }
-            }
-            size >>= 1;
-        }
+    default:
+        return 0;
+    }
+}
+
+static BYTE get_s8_clipped(float v)
+{
+    return (BYTE)(v >= 0.0f ? v * 255 + 0.5f : 0.0f);
+}
 
-        IDirect3DCubeTexture9_Release(tex);
+static DWORD get_expected_argb_color(D3DFORMAT format, const D3DXVECTOR4 *v)
+{
+    switch (format)
+    {
+    case D3DFMT_A8R8G8B8:
+        return get_s8_clipped(v->w) << 24
+                | get_s8_clipped(v->x) << 16
+                | get_s8_clipped(v->y) << 8
+                | get_s8_clipped(v->z);
+
+    case D3DFMT_A1R5G5B5:
+        return (BYTE)(v->w + 0.5f) << 24
+                | (BYTE)(v->x * 31 + 0.5f) << 16
+                | (BYTE)(v->y * 31 + 0.5f) << 8
+                | (BYTE)(v->z * 31 + 0.5f);
+    default:
+        return 0;
     }
-    else
-        skip("Failed to create texture\n");
+}
 
-    hr = IDirect3DDevice9_CreateCubeTexture(device, 4, 1, 0, D3DFMT_A1R5G5B5,
-                                            D3DPOOL_MANAGED, &tex, NULL);
+#define compare_cube_texture(t,f,d) compare_cube_texture_(t,f,d,__LINE__)
+static void compare_cube_texture_(IDirect3DCubeTexture9 *texture,
+        LPD3DXFILL3D func, BYTE diff, unsigned int line)
+{
+    static const enum cube_coord coordmap[6][3] =
+    {
+        {ONE, YCOORDINV, XCOORDINV},
+        {ZERO, YCOORDINV, XCOORD},
+        {XCOORD, ONE, YCOORD},
+        {XCOORD, ZERO, YCOORDINV},
+        {XCOORD, YCOORDINV, ONE},
+        {XCOORDINV, YCOORDINV, ZERO}
+    };
 
-    if (SUCCEEDED(hr))
+    DWORD x, y, m, f, levels, size, value, expected;
+    D3DXVECTOR3 coord, texelsize;
+    D3DLOCKED_RECT lock_rect;
+    D3DSURFACE_DESC desc;
+    D3DXVECTOR4 out;
+    HRESULT hr;
+
+    levels = IDirect3DCubeTexture9_GetLevelCount(texture);
+
+    for (m = 0; m < levels; ++m)
     {
-        hr = D3DXFillCubeTexture(tex, fillfunc_cube, NULL);
-        ok(hr == D3D_OK, "D3DXFillTexture returned %#lx, expected %#lx\n", hr, D3D_OK);
+        hr = IDirect3DCubeTexture9_GetLevelDesc(texture, m, &desc);
+        ok(hr == D3D_OK, "Unexpected hr %#lx.\n", hr);
+
+        size = desc.Width;
+
         for (f = 0; f < 6; f++)
         {
-            hr = IDirect3DCubeTexture9_LockRect(tex, f, 0, &lock_rect, NULL, D3DLOCK_READONLY);
-            ok(hr == D3D_OK, "Couldn't lock the texture, error %#lx\n", hr);
-            if (SUCCEEDED(hr))
+            texelsize.x = (f == 0) || (f == 1) ? 0.0f : 2.0f / size;
+            texelsize.y = (f == 2) || (f == 3) ? 0.0f : 2.0f / size;
+            texelsize.z = (f == 4) || (f == 5) ? 0.0f : 2.0f / size;
+
+            hr = IDirect3DCubeTexture9_LockRect(texture, f, m, &lock_rect, NULL, D3DLOCK_READONLY);
+            ok(hr == D3D_OK, "Couldn't lock the texture, error %#lx.\n", hr);
+
+            for (y = 0; y < size; y++)
             {
-                pitch = lock_rect.Pitch / sizeof(WORD);
-                for (y = 0; y < 4; y++)
+                for (x = 0; x < size; x++)
                 {
-                    for (x = 0; x < 4; x++)
-                    {
-                        value = ((WORD *)lock_rect.pBits)[y * pitch + x];
-                        v[0] = value >> 15;
-                        v[1] = value >> 10 & 0x1f;
-                        v[2] = value >> 5 & 0x1f;
-                        v[3] = value & 0x1f;
+                    coord.x = get_cube_coord(coordmap[f][0], x, y, size) / size * 2.0f - 1.0f;
+                    coord.y = get_cube_coord(coordmap[f][1], x, y, size) / size * 2.0f - 1.0f;
+                    coord.z = get_cube_coord(coordmap[f][2], x, y, size) / size * 2.0f - 1.0f;
 
-                        e[0] = (f == 0) || (f == 1) ?
-                            0 : (BYTE)(1.0f / size * 2.0f + 0.5f);
-                        e[1] = get_cube_coord(coordmap[f][0], x, y, 4) / 4 * 31.0f + 0.5f;
-                        e[2] = get_cube_coord(coordmap[f][1], x, y, 4) / 4 * 31.0f + 0.5f;
-                        e[3] = get_cube_coord(coordmap[f][2], x, y, 4) / 4 * 31.0f + 0.5f;
-                        expected = e[0] << 15 | e[1] << 10 | e[2] << 5 | e[3];
+                    func(&out, &coord, &texelsize, NULL);
 
-                        ok(color_match(v, e),
-                           "Texel at face %lu (%lu, %lu) doesn't match: %#lx, expected %#lx\n",
-                           f, x, y, value, expected);
-                    }
+                    value = get_argb_color(desc.Format, x, y, &lock_rect);
+                    expected = get_expected_argb_color(desc.Format, &out);
+
+                    ok_(__FILE__, line)(compare_color(value, expected, diff),
+                            "Texel at face %lu (%lu, %lu) doesn't match: %08lx, expected %08lx.\n",
+                            f, x, y, value, expected);
                 }
-                IDirect3DCubeTexture9_UnlockRect(tex, f, 0);
             }
+            IDirect3DCubeTexture9_UnlockRect(texture, f, m);
         }
-
-        IDirect3DCubeTexture9_Release(tex);
     }
-    else
-        skip("Failed to create texture\n");
+}
+
+static void test_D3DXFillCubeTexture(IDirect3DDevice9 *device)
+{
+    IDirect3DCubeTexture9 *tex;
+    HRESULT hr;
+
+    /* A8R8G8B8 */
+    hr = IDirect3DDevice9_CreateCubeTexture(device, 4, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &tex, NULL);
+    ok(hr == D3D_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = D3DXFillCubeTexture(tex, fillfunc_cube, NULL);
+    ok(hr == D3D_OK, "Unexpected hr %#lx.\n", hr);
+    compare_cube_texture(tex, fillfunc_cube, 1);
+
+    hr = D3DXFillCubeTexture(tex, fillfunc_cube_coord, NULL);
+    ok(hr == D3D_OK, "Unexpected hr %#lx.\n", hr);
+    compare_cube_texture(tex, fillfunc_cube_coord, 1);
+
+    IDirect3DCubeTexture9_Release(tex);
+
+    /* A1R5G5B5 */
+    hr = IDirect3DDevice9_CreateCubeTexture(device, 4, 1, 0, D3DFMT_A1R5G5B5,
+            D3DPOOL_MANAGED, &tex, NULL);
+    ok(hr == D3D_OK, "Unexpected hr %#lx.\n", hr);
+    hr = D3DXFillCubeTexture(tex, fillfunc_cube, NULL);
+    ok(hr == D3D_OK, "Unexpected hr %#lx.\n", hr);
+    compare_cube_texture(tex, fillfunc_cube, 2);
+    IDirect3DCubeTexture9_Release(tex);
 }
 
 static void WINAPI fillfunc_volume(D3DXVECTOR4 *value, const D3DXVECTOR3 *texcoord,
@@ -2471,21 +2507,20 @@ float4 main(float3 pos : POSITION, float3 size : PSIZE) : COLOR
     hr = tx->lpVtbl->GetConstantBuffer(tx, &buffer);
     todo_wine
     ok(SUCCEEDED(hr), "Failed to get texture shader constant buffer.\n");
-    if (FAILED(hr))
-    {
-        skip("Texture shaders not supported, skipping further tests.\n");
-        IUnknown_Release(tx);
-        return;
-    }
 
-    size = ID3DXBuffer_GetBufferSize(buffer);
-    ok(!size, "Unexpected buffer size %lu.\n", size);
+    if (SUCCEEDED(hr))
+    {
+        size = ID3DXBuffer_GetBufferSize(buffer);
+        ok(!size, "Unexpected buffer size %lu.\n", size);
 
-    ID3DXBuffer_Release(buffer);
+        ID3DXBuffer_Release(buffer);
+    }
 
     hr = tx->lpVtbl->GetDesc(tx, &ctab_desc);
+    todo_wine
     ok(hr == S_OK, "Failed to get constant description, hr %#lx.\n", hr);
-    ok(!ctab_desc.Constants, "Unexpected number of constants %u.\n", ctab_desc.Constants);
+    if (SUCCEEDED(hr))
+        ok(!ctab_desc.Constants, "Unexpected number of constants %u.\n", ctab_desc.Constants);
 
     /* Constant table access calls, without constant table. */
     h = tx->lpVtbl->GetConstant(tx, NULL, 0);
@@ -2561,52 +2596,7 @@ float4 main(float3 pos : POSITION, float3 size : PSIZE) : COLOR
 
     hr = D3DXFillCubeTextureTX(cube_texture, tx);
     ok(SUCCEEDED(hr), "Got unexpected hr %#lx.\n", hr);
-
-    for (z = 0; z < 6; ++z)
-    {
-        static const char * const mapping[6][3] =
-        {
-            {"-x", "-y", "1"},
-            {"+x", "-y", "0"},
-            {"+y", "1", "+x"},
-            {"-y", "0", "+x"},
-            {"1", "-y", "+x"},
-            {"0", "-y", "-x"},
-        };
-
-        hr = IDirect3DCubeTexture9_LockRect(cube_texture, z, 0, &lr, NULL, D3DLOCK_READONLY);
-        ok(SUCCEEDED(hr), "Locking texture failed, hr %#lx.\n", hr);
-        data = lr.pBits;
-        for (y = 0; y < 256; ++y)
-        {
-            for (x = 0; x < 256; ++x)
-            {
-                unsigned int color = data[y * lr.Pitch / sizeof(*data) + x];
-                unsigned int expected = 0xff000000;
-                unsigned int i;
-
-                for (i = 0; i < 3; ++i)
-                {
-                    int component;
-
-                    if (mapping[z][i][0] == '0')
-                        component = 0;
-                    else if (mapping[z][i][0] == '1')
-                        component = 255;
-                    else
-                        component = mapping[z][i][1] == 'x' ? x * 2 - 255 : y * 2 - 255;
-                    if (mapping[z][i][0] == '-')
-                        component = -component;
-                    expected |= max(component, 0) << i * 8;
-                }
-                ok(compare_color(color, expected, 1), "Unexpected color %08x at (%u, %u, %u).\n",
-                        color, x, y, z);
-            }
-        }
-        hr = IDirect3DCubeTexture9_UnlockRect(cube_texture, z, 0);
-        ok(SUCCEEDED(hr), "Unlocking texture failed, hr %#lx.\n", hr);
-    }
-
+    compare_cube_texture(cube_texture, fillfunc_cube_coord, 1);
     IDirect3DCubeTexture9_Release(cube_texture);
 
     if (!(caps.TextureCaps & D3DPTEXTURECAPS_VOLUMEMAP) || caps.MaxVolumeExtent < 64)
@@ -2619,6 +2609,7 @@ float4 main(float3 pos : POSITION, float3 size : PSIZE) : COLOR
     ok(SUCCEEDED(hr), "Got unexpected hr %#lx.\n", hr);
 
     hr = D3DXFillVolumeTextureTX(volume_texture, tx);
+    todo_wine
     ok(SUCCEEDED(hr), "Got unexpected hr %#lx.\n", hr);
 
     hr = IDirect3DVolumeTexture9_LockBox(volume_texture, 0, &lb, NULL, D3DLOCK_READONLY);
@@ -2633,6 +2624,7 @@ float4 main(float3 pos : POSITION, float3 size : PSIZE) : COLOR
                 unsigned int expected = 0xff000000 | ((x * 4 + 2) << 16) | ((y * 4 + 2) << 8) | (z * 4 + 2);
                 unsigned int color = data[z * lb.SlicePitch / sizeof(*data) + y * lb.RowPitch / sizeof(*data) + x];
 
+                todo_wine
                 ok(compare_color(color, expected, 1), "Unexpected color %08x at (%u, %u, %u).\n",
                         color, x, y, z);
             }
@@ -2646,8 +2638,12 @@ float4 main(float3 pos : POSITION, float3 size : PSIZE) : COLOR
     IUnknown_Release(tx);
 
     /* With constant table */
+    tx = NULL;
     hr = D3DXCreateTextureShader(shader_code2, &tx);
+    todo_wine
     ok(SUCCEEDED(hr), "Got unexpected hr %#lx.\n", hr);
+    if (FAILED(hr))
+        goto cleanup;
 
     hr = tx->lpVtbl->GetConstantBuffer(tx, &buffer);
     todo_wine
@@ -2768,7 +2764,8 @@ float4 main(float3 pos : POSITION, float3 size : PSIZE) : COLOR
     IDirect3DDevice9_Release(device);
     IDirect3D9_Release(d3d);
     DestroyWindow(wnd);
-    IUnknown_Release(tx);
+    if (tx)
+        IUnknown_Release(tx);
 }
 
 START_TEST(texture)
diff --git a/dlls/d3dx9_36/texture.c b/dlls/d3dx9_36/texture.c
index 46bca5eb4e6..2ee79b51f79 100644
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -1288,7 +1288,7 @@ static inline void fill_texture(const struct pixel_format_desc *format, BYTE *po
         else if (format->type == FORMAT_ARGBF)
             v = *(DWORD *)&comp_value;
         else if (format->type == FORMAT_ARGB)
-            v = comp_value * ((1 << format->bits[c]) - 1) + 0.5f;
+            v = max(comp_value * ((1 << format->bits[c]) - 1) + 0.5f, 0);
         else
             FIXME("Unhandled format type %#x\n", format->type);
 
@@ -1382,12 +1382,6 @@ HRESULT WINAPI D3DXFillTexture(struct IDirect3DTexture9 *texture, LPD3DXFILL2D f
     return D3D_OK;
 }
 
-HRESULT WINAPI D3DXFillTextureTX(struct IDirect3DTexture9 *texture, ID3DXTextureShader *texture_shader)
-{
-    FIXME("texture %p, texture_shader %p stub.\n", texture, texture_shader);
-    return E_NOTIMPL;
-}
-
 HRESULT WINAPI D3DXCreateCubeTextureFromFileInMemoryEx(IDirect3DDevice9 *device, const void *src_data,
         UINT src_data_size, UINT size, UINT mip_levels, DWORD usage, D3DFORMAT format, D3DPOOL pool,
         DWORD filter, DWORD mip_filter, D3DCOLOR color_key, D3DXIMAGE_INFO *src_info,
@@ -1729,12 +1723,6 @@ HRESULT WINAPI D3DXFillCubeTexture(struct IDirect3DCubeTexture9 *texture, LPD3DX
     return D3D_OK;
 }
 
-HRESULT WINAPI D3DXFillCubeTextureTX(struct IDirect3DCubeTexture9 *texture, ID3DXTextureShader *texture_shader)
-{
-    FIXME("texture %p, texture_shader %p stub.\n", texture, texture_shader);
-    return E_NOTIMPL;
-}
-
 HRESULT WINAPI D3DXFillVolumeTexture(struct IDirect3DVolumeTexture9 *texture, LPD3DXFILL3D function, void *funcdata)
 {
     DWORD miplevels;
diff --git a/dlls/dbgeng/dbgeng.c b/dlls/dbgeng/dbgeng.c
index 3ec510ef296..6d4710163c9 100644
--- a/dlls/dbgeng/dbgeng.c
+++ b/dlls/dbgeng/dbgeng.c
@@ -134,6 +134,8 @@ static HRESULT debug_target_init_modules_info(struct target_process *target)
     HMODULE *modules;
     MODULEINFO info;
     DWORD needed;
+    BOOL wow64;
+    DWORD filter = LIST_MODULES_DEFAULT;
 
     if (target->modules.initialized)
         return S_OK;
@@ -141,8 +143,13 @@ static HRESULT debug_target_init_modules_info(struct target_process *target)
     if (!target->handle)
         return E_UNEXPECTED;
 
+    if (sizeof(void*) > sizeof(int) &&
+        IsWow64Process(target->handle, &wow64) &&
+        wow64)
+        filter = LIST_MODULES_32BIT;
+
     needed = 0;
-    EnumProcessModules(target->handle, NULL, 0, &needed);
+    EnumProcessModulesEx(target->handle, NULL, 0, &needed, filter);
     if (!needed)
         return E_FAIL;
 
@@ -157,7 +164,7 @@ static HRESULT debug_target_init_modules_info(struct target_process *target)
         return E_OUTOFMEMORY;
     }
 
-    if (EnumProcessModules(target->handle, modules, count * sizeof(*modules), &needed))
+    if (EnumProcessModulesEx(target->handle, modules, count * sizeof(*modules), &needed, filter))
     {
         for (i = 0; i < count; ++i)
         {
diff --git a/dlls/dbghelp/cpu_i386.c b/dlls/dbghelp/cpu_i386.c
index c45c45f434c..dcc576cf295 100644
--- a/dlls/dbghelp/cpu_i386.c
+++ b/dlls/dbghelp/cpu_i386.c
@@ -473,7 +473,14 @@ static BOOL i386_stack_walk(struct cpu_stack_walk *csw, STACKFRAME64 *frame,
         union ctx newctx = *context;
 
         if (!fetch_next_frame32(csw, &newctx, frame->AddrPC.Offset - deltapc))
-            goto done_err;
+        {
+            /* When running on wow64 setup, frame below can a 64 bit frame.
+             * As we don't expose 64bit frames for now, pretend it's the first frame.
+             */
+            if (frame->AddrPC.Offset == 0)
+                goto done_err;
+            newctx.x86.Eip = 0;
+        }
         frame->AddrReturn.Mode = AddrModeFlat;
         frame->AddrReturn.Offset = newctx.x86.Eip;
 
diff --git a/dlls/dbghelp/dbghelp.c b/dlls/dbghelp/dbghelp.c
index 2facc58585e..3341bea442e 100644
--- a/dlls/dbghelp/dbghelp.c
+++ b/dlls/dbghelp/dbghelp.c
@@ -67,6 +67,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(dbghelp);
 
 unsigned   dbghelp_options = SYMOPT_UNDNAME;
 BOOL       dbghelp_opt_native = FALSE;
+BOOL       dbghelp_opt_real_path = FALSE;
 SYSTEM_INFO sysinfo;
 
 static struct process* process_first /* = NULL */;
@@ -305,13 +306,9 @@ BOOL WINAPI SymGetSearchPath(HANDLE hProcess, PSTR szSearchPath,
  */
 static BOOL WINAPI process_invade_cb(PCWSTR name, ULONG64 base, ULONG size, PVOID user)
 {
-    WCHAR       tmp[MAX_PATH];
     HANDLE      hProcess = user;
 
-    if (!GetModuleFileNameExW(hProcess, (HMODULE)(DWORD_PTR)base, tmp, ARRAY_SIZE(tmp)))
-        lstrcpynW(tmp, name, ARRAY_SIZE(tmp));
-
-    SymLoadModuleExW(hProcess, 0, tmp, name, base, size, NULL, 0);
+    SymLoadModuleExW(hProcess, 0, name, NULL, base, size, NULL, 0);
     return TRUE;
 }
 
@@ -336,10 +333,8 @@ const struct cpu* process_get_cpu(const struct process* pcs)
 {
     const struct module* m = pcs->lmodules;
 
-    /* main module is the last one in list */
-    if (!m) return dbghelp_current_cpu;
-    while (m->next) m = m->next;
-    return m->cpu;
+    /* return cpu of main module, which is the first module in process's modules list */
+    return (m) ? m->cpu : dbghelp_current_cpu;
 }
 
 /******************************************************************
@@ -349,7 +344,8 @@ const struct cpu* process_get_cpu(const struct process* pcs)
 static BOOL check_live_target(struct process* pcs, BOOL wow64, BOOL child_wow64)
 {
     PROCESS_BASIC_INFORMATION pbi;
-    ULONG_PTR base = 0, env = 0;
+    DWORD64 base = 0, env = 0;
+    const char* peb_addr;
 
     if (!GetProcessId(pcs->handle)) return FALSE;
     if (GetEnvironmentVariableA("DBGHELP_NOLIVE", NULL, 0)) return FALSE;
@@ -358,27 +354,44 @@ static BOOL check_live_target(struct process* pcs, BOOL wow64, BOOL child_wow64)
                                    &pbi, sizeof(pbi), NULL ))
         return FALSE;
 
+    /* Note: we have to deal with the PEB64 and PEB32 in debuggee process
+     * while debugger can be in same or different bitness.
+     * For a 64 bit debuggee, use PEB64 and underlying ELF/system 64 (easy).
+     * For a 32 bit debuggee,
+     * - for environment variables, we need PEB32
+     * - for ELF/system base address, we need PEB32 when run in pure 32bit
+     *   or run in old wow configuration, but PEB64 when run in new wow
+     *   configuration.
+     * - this must be read from a debugger in either 32 or 64 bit setup.
+     */
+    peb_addr = (const char*)pbi.PebBaseAddress;
     if (!pcs->is_64bit)
     {
-        const char* peb32_addr;
         DWORD env32;
         PEB32 peb32;
 
         C_ASSERT(sizeof(void*) != 4 || FIELD_OFFSET(RTL_USER_PROCESS_PARAMETERS, Environment) == 0x48);
-        peb32_addr = (const char*)pbi.PebBaseAddress;
+
         if (!wow64 && child_wow64)
             /* current process is 64bit, while child process is 32 bit, need to read 32bit PEB */
-            peb32_addr += 0x1000;
-        if (!ReadProcessMemory(pcs->handle, peb32_addr, &peb32, sizeof(peb32), NULL)) return FALSE;
-        if (!ReadProcessMemory(pcs->handle, peb32_addr + 0x460 /* CloudFileFlags */, &base, sizeof(base), NULL)) return FALSE;
+            peb_addr += 0x1000;
+        if (!ReadProcessMemory(pcs->handle, peb_addr, &peb32, sizeof(peb32), NULL)) return FALSE;
+        base = *(const DWORD*)((const char*)&peb32 + 0x460 /* CloudFileFlags */);
+        pcs->is_system_64bit = FALSE;
         if (read_process_memory(pcs, peb32.ProcessParameters + 0x48, &env32, sizeof(env32))) env = env32;
     }
-    else
+    if (pcs->is_64bit || base == 0)
     {
-        PEB peb;
-        if (!ReadProcessMemory(pcs->handle, pbi.PebBaseAddress, &peb, sizeof(peb), NULL)) return FALSE;
-        if (!ReadProcessMemory(pcs->handle, (char *)pbi.PebBaseAddress + FIELD_OFFSET(PEB, CloudFileFlags), &base, sizeof(base), NULL)) return FALSE;
-        ReadProcessMemory(pcs->handle, (char *)peb.ProcessParameters + FIELD_OFFSET(RTL_USER_PROCESS_PARAMETERS, Environment), &env, sizeof(env), NULL);
+        PEB64 peb;
+
+        if (!pcs->is_64bit) peb_addr -= 0x1000; /* PEB32 => PEB64 */
+        if (!ReadProcessMemory(pcs->handle, peb_addr, &peb, sizeof(peb), NULL)) return FALSE;
+        base = peb.CloudFileFlags;
+        pcs->is_system_64bit = TRUE;
+        if (pcs->is_64bit)
+            ReadProcessMemory(pcs->handle,
+                              (char *)(ULONG_PTR)peb.ProcessParameters + FIELD_OFFSET(RTL_USER_PROCESS_PARAMETERS, Environment),
+                              &env, sizeof(env), NULL);
     }
 
     /* read debuggee environment block */
@@ -419,9 +432,9 @@ static BOOL check_live_target(struct process* pcs, BOOL wow64, BOOL child_wow64)
 
     if (!base) return FALSE;
 
-    TRACE("got debug info address %#Ix from PEB %p\n", base, pbi.PebBaseAddress);
+    TRACE("got debug info address %#I64x from PEB %p\n", base, pbi.PebBaseAddress);
     if (!elf_read_wine_loader_dbg_info(pcs, base) && !macho_read_wine_loader_dbg_info(pcs, base))
-        WARN("couldn't load process debug info at %#Ix\n", base);
+        WARN("couldn't load process debug info at %#I64x\n", base);
     return TRUE;
 }
 
@@ -602,6 +615,10 @@ BOOL WINAPI SymSetExtendedOption(IMAGEHLP_EXTENDED_OPTIONS option, BOOL value)
             old = dbghelp_opt_native;
             dbghelp_opt_native = value;
             break;
+        case SYMOPT_EX_WINE_MODULE_REAL_PATH:
+            old = dbghelp_opt_real_path;
+            dbghelp_opt_real_path = value;
+            break;
         default:
             FIXME("Unsupported option %d with value %d\n", option, value);
     }
@@ -619,6 +636,8 @@ BOOL WINAPI SymGetExtendedOption(IMAGEHLP_EXTENDED_OPTIONS option)
     {
         case SYMOPT_EX_WINE_NATIVE_MODULES:
             return dbghelp_opt_native;
+        case SYMOPT_EX_WINE_MODULE_REAL_PATH:
+            return dbghelp_opt_real_path;
         default:
             FIXME("Unsupported option %d\n", option);
     }
diff --git a/dlls/dbghelp/dbghelp_private.h b/dlls/dbghelp/dbghelp_private.h
index 319a3b81047..1852aef1795 100644
--- a/dlls/dbghelp/dbghelp_private.h
+++ b/dlls/dbghelp/dbghelp_private.h
@@ -111,6 +111,7 @@ void*    hash_table_iter_up(struct hash_table_iter* hti) DECLSPEC_HIDDEN;
 
 extern unsigned dbghelp_options DECLSPEC_HIDDEN;
 extern BOOL     dbghelp_opt_native DECLSPEC_HIDDEN;
+extern BOOL     dbghelp_opt_real_path DECLSPEC_HIDDEN;
 extern SYSTEM_INFO sysinfo DECLSPEC_HIDDEN;
 
 /* FIXME: this could be optimized later on by using relative offsets and smaller integral sizes */
@@ -514,6 +515,7 @@ struct process
     void*                       buffer;
 
     BOOL                        is_64bit;
+    BOOL                        is_system_64bit;
 };
 
 static inline BOOL read_process_memory(const struct process *process, UINT64 addr, void *buf, size_t size)
@@ -763,8 +765,8 @@ extern BOOL         path_find_symbol_file(const struct process* pcs, const struc
                                           PCSTR full_path, enum module_type type, const GUID* guid, DWORD dw1, DWORD dw2,
                                           WCHAR *buffer, BOOL* is_unmatched) DECLSPEC_HIDDEN;
 extern WCHAR *get_dos_file_name(const WCHAR *filename) __WINE_DEALLOC(HeapFree, 3) __WINE_MALLOC DECLSPEC_HIDDEN;
-extern BOOL search_dll_path(const struct process* process, const WCHAR *name,
-                            BOOL (*match)(void*, HANDLE, const WCHAR*), void *param) DECLSPEC_HIDDEN;
+extern BOOL         search_dll_path(const struct process* process, const WCHAR *name, WORD machine,
+                                    BOOL (*match)(void*, HANDLE, const WCHAR*), void *param) DECLSPEC_HIDDEN;
 extern BOOL search_unix_path(const WCHAR *name, const WCHAR *path, BOOL (*match)(void*, HANDLE, const WCHAR*), void *param) DECLSPEC_HIDDEN;
 extern const WCHAR* file_name(const WCHAR* str) DECLSPEC_HIDDEN;
 extern const char* file_nameA(const char* str) DECLSPEC_HIDDEN;
diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 9ed63463513..1402ffcb941 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -1764,7 +1764,7 @@ static struct symt* dwarf2_parse_udt_type(dwarf2_debug_info_t* di,
 
     /* quirk... FIXME provide real support for anonymous UDTs */
     if (!dwarf2_find_attribute(di, DW_AT_name, &name))
-        name.u.string = "zz_anon_zz";
+        name.u.string = "<unnamed-tag>";
     if (!dwarf2_find_attribute(di, DW_AT_byte_size, &size)) size.u.uvalue = 0;
 
     di->symt = &symt_new_udt(di->unit_ctx->module_ctx->module, dwarf2_get_cpp_name(di, name.u.string),
diff --git a/dlls/dbghelp/elf_module.c b/dlls/dbghelp/elf_module.c
index bc063bf1466..3c1e225e195 100644
--- a/dlls/dbghelp/elf_module.c
+++ b/dlls/dbghelp/elf_module.c
@@ -1373,7 +1373,7 @@ static BOOL elf_search_auxv(const struct process* pcs, unsigned type, ULONG_PTR*
     while (addr < str_max && ReadProcessMemory(pcs->handle, addr, &str, sizeof(str), NULL) && str == NULL)
         addr = (void*)((DWORD_PTR)addr + sizeof(str));
 
-    if (pcs->is_64bit)
+    if (pcs->is_system_64bit)
     {
         struct
         {
@@ -1445,7 +1445,7 @@ static BOOL elf_search_and_load_file(struct process* pcs, const WCHAR* filename,
         load_elf.elf_info    = elf_info;
 
         ret = search_unix_path(filename, process_getenv(pcs, L"LD_LIBRARY_PATH"), elf_load_file_cb, &load_elf)
-            || search_dll_path(pcs, filename, elf_load_file_cb, &load_elf);
+            || search_dll_path(pcs, filename, IMAGE_FILE_MACHINE_UNKNOWN, elf_load_file_cb, &load_elf);
     }
 
     return ret;
@@ -1467,7 +1467,7 @@ static BOOL elf_enum_modules_internal(const struct process* pcs,
     char bufstr[256];
     ULONG_PTR lm_addr;
 
-    if (pcs->is_64bit)
+    if (pcs->is_system_64bit)
     {
         struct
         {
diff --git a/dlls/dbghelp/macho_module.c b/dlls/dbghelp/macho_module.c
index 4852f5beaa4..f1b3107408c 100644
--- a/dlls/dbghelp/macho_module.c
+++ b/dlls/dbghelp/macho_module.c
@@ -1583,7 +1583,7 @@ static BOOL macho_search_and_load_file(struct process* pcs, const WCHAR* filenam
         ret = search_unix_path(p, fallback, macho_load_file_cb, &load_params);
     }
     if (!ret && p == filename)
-        ret = search_dll_path(pcs, filename, macho_load_file_cb, &load_params);
+        ret = search_dll_path(pcs, filename, IMAGE_FILE_MACHINE_UNKNOWN, macho_load_file_cb, &load_params);
 
     return ret;
 }
diff --git a/dlls/dbghelp/minidump.c b/dlls/dbghelp/minidump.c
index 4d3818a8f54..11ce767aa71 100644
--- a/dlls/dbghelp/minidump.c
+++ b/dlls/dbghelp/minidump.c
@@ -213,12 +213,8 @@ static BOOL add_module(struct dump_context* dc, const WCHAR* name,
         dc->alloc_modules = dc->num_modules = 0;
         return FALSE;
     }
-    if (is_elf ||
-        !GetModuleFileNameExW(dc->process->handle, (HMODULE)(DWORD_PTR)base,
-                              dc->modules[dc->num_modules].name,
-                              ARRAY_SIZE(dc->modules[dc->num_modules].name)))
-        lstrcpynW(dc->modules[dc->num_modules].name, name,
-                  ARRAY_SIZE(dc->modules[dc->num_modules].name));
+    lstrcpynW(dc->modules[dc->num_modules].name, name,
+              ARRAY_SIZE(dc->modules[dc->num_modules].name));
     dc->modules[dc->num_modules].base = base;
     dc->modules[dc->num_modules].size = size;
     dc->modules[dc->num_modules].timestamp = timestamp;
diff --git a/dlls/dbghelp/module.c b/dlls/dbghelp/module.c
index d590877497d..ad8ec22fe32 100644
--- a/dlls/dbghelp/module.c
+++ b/dlls/dbghelp/module.c
@@ -177,14 +177,16 @@ struct module* module_new(struct process* pcs, const WCHAR* name,
                           ULONG_PTR stamp, ULONG_PTR checksum, WORD machine)
 {
     struct module*      module;
+    struct module**     pmodule;
     unsigned            i;
 
     assert(type == DMT_ELF || type == DMT_PE || type == DMT_MACHO);
     if (!(module = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*module))))
 	return NULL;
 
-    module->next = pcs->lmodules;
-    pcs->lmodules = module;
+    for (pmodule = &pcs->lmodules; *pmodule; pmodule = &(*pmodule)->next);
+    module->next = NULL;
+    *pmodule = module;
 
     TRACE("=> %s %I64x-%I64x %s\n",
           get_module_type(type, virtual), mod_addr, mod_addr + size, debugstr_w(name));
@@ -660,6 +662,7 @@ static BOOL image_locate_build_id_target(struct image_file_map* fmap, const BYTE
 
     p = malloc(sizeof(L"/usr/lib/debug/.build-id/") +
                (idlen * 2 + 1) * sizeof(WCHAR) + sizeof(L".debug"));
+    if (!p) goto fail;
     wcscpy(p, L"/usr/lib/debug/.build-id/");
     z = p + wcslen(p);
     if (idlen)
@@ -684,9 +687,11 @@ static BOOL image_locate_build_id_target(struct image_file_map* fmap, const BYTE
     sz = GetEnvironmentVariableW(L"WINEHOMEDIR", NULL, 0);
     if (sz)
     {
-        p = realloc(p, sz * sizeof(WCHAR) +
+        z = realloc(p, sz * sizeof(WCHAR) +
                     sizeof(L"\\.cache\\debuginfod_client\\") +
                     idlen * 2 * sizeof(WCHAR) + sizeof(L"\\debuginfo") + 500);
+        if (!z) goto fail;
+        p = z;
         GetEnvironmentVariableW(L"WINEHOMEDIR", p, sz);
         z = p + sz - 1;
         wcscpy(z, L"\\.cache\\debuginfod_client\\");
@@ -703,6 +708,7 @@ static BOOL image_locate_build_id_target(struct image_file_map* fmap, const BYTE
     }
 
     TRACE("not found\n");
+fail:
     free(p);
     HeapFree(GetProcessHeap(), 0, fmap_link);
     return FALSE;
@@ -986,17 +992,10 @@ DWORD64 WINAPI  SymLoadModuleExW(HANDLE hProcess, HANDLE hFile, PCWSTR wImageNam
     }
     if (altmodule)
     {
-        /* we have a conflict as the new module cannot be found by its base address
-         * we need to get rid of one on the two modules
+        /* We have a conflict as the new module cannot be found by its base address
+         * (it's hidden by altmodule).
+         * We need to decide which one the two modules we need to get rid of.
          */
-        if (lstrcmpW(module->modulename, altmodule->modulename) != 0)
-        {
-            /* module overlaps an existing but different module... unload new module and return error */
-            WARN("%ls overlaps %ls\n", module->modulename, altmodule->modulename);
-            module_remove(pcs, module);
-            SetLastError(ERROR_INVALID_PARAMETER);
-            return 0;
-        }
         /* loading same module at same address... don't change anything */
         if (module->module.BaseOfImage == altmodule->module.BaseOfImage)
         {
@@ -1004,9 +1003,10 @@ DWORD64 WINAPI  SymLoadModuleExW(HANDLE hProcess, HANDLE hFile, PCWSTR wImageNam
             SetLastError(ERROR_SUCCESS);
             return 0;
         }
-        /* replace old module with new one, which will look like a shift of base address */
-        WARN("Shift module %ls from %I64x to %I64x\n",
-             module->modulename, altmodule->module.BaseOfImage, module->module.BaseOfImage);
+        /* replace old module with new one */
+        WARN("Replace module %ls at %I64x by module %ls at %I64x\n",
+             altmodule->module.ImageName, altmodule->module.BaseOfImage,
+             module->module.ImageName, module->module.BaseOfImage);
         module_remove(pcs, altmodule);
     }
 
@@ -1266,14 +1266,21 @@ BOOL  WINAPI EnumerateLoadedModulesW64(HANDLE hProcess,
                                        PVOID UserContext)
 {
     HMODULE*    hMods;
-    WCHAR       baseW[256], modW[256];
+    WCHAR       imagenameW[MAX_PATH];
     DWORD       i, sz;
     MODULEINFO  mi;
+    BOOL        wow64;
+    DWORD       filter = LIST_MODULES_DEFAULT;
 
     hMods = HeapAlloc(GetProcessHeap(), 0, 256 * sizeof(hMods[0]));
     if (!hMods) return FALSE;
 
-    if (!EnumProcessModules(hProcess, hMods, 256 * sizeof(hMods[0]), &sz))
+    if (sizeof(void*) > sizeof(int) &&
+        IsWow64Process(hProcess, &wow64) &&
+        wow64)
+        filter = LIST_MODULES_32BIT;
+
+    if (!EnumProcessModulesEx(hProcess, hMods, 256 * sizeof(hMods[0]), &sz, filter))
     {
         /* hProcess should also be a valid process handle !! */
         HeapFree(GetProcessHeap(), 0, hMods);
@@ -1282,17 +1289,16 @@ BOOL  WINAPI EnumerateLoadedModulesW64(HANDLE hProcess,
     if (sz > 256 * sizeof(hMods[0]))
     {
         hMods = HeapReAlloc(GetProcessHeap(), 0, hMods, sz);
-        if (!hMods || !EnumProcessModules(hProcess, hMods, sz, &sz))
+        if (!hMods || !EnumProcessModulesEx(hProcess, hMods, sz, &sz, filter))
             return FALSE;
     }
     sz /= sizeof(HMODULE);
     for (i = 0; i < sz; i++)
     {
         if (!GetModuleInformation(hProcess, hMods[i], &mi, sizeof(mi)) ||
-            !GetModuleBaseNameW(hProcess, hMods[i], baseW, ARRAY_SIZE(baseW)))
+            !GetModuleFileNameExW(hProcess, hMods[i], imagenameW, ARRAY_SIZE(imagenameW)))
             continue;
-        module_fill_module(baseW, modW, ARRAY_SIZE(modW));
-        EnumLoadedModulesCallback(modW, (DWORD_PTR)mi.lpBaseOfDll, mi.SizeOfImage,
+        EnumLoadedModulesCallback(imagenameW, (DWORD_PTR)mi.lpBaseOfDll, mi.SizeOfImage,
                                   UserContext);
     }
     HeapFree(GetProcessHeap(), 0, hMods);
@@ -1439,6 +1445,9 @@ BOOL  WINAPI SymGetModuleInfoW64(HANDLE hProcess, DWORD64 dwAddr,
 
     miw64 = module->module;
 
+    if (dbghelp_opt_real_path && module->real_path)
+        lstrcpynW(miw64.LoadedImageName, module->real_path, ARRAY_SIZE(miw64.LoadedImageName));
+
     /* update debug information from container if any */
     if (module->module.SymType == SymNone)
     {
diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index ebacfc49bfd..56a47ab7dac 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -782,8 +782,8 @@ static BOOL codeview_type_extract_name(const union codeview_type* cvtype,
 
 static unsigned pdb_read_hash_value(const struct codeview_type_parse* ctp, unsigned idx)
 {
-    const void* where = ctp->hash_stream + ctp->header.hash_offset + (idx - ctp->header.first_index) * ctp->header.hash_size;
-    switch (ctp->header.hash_size)
+    const void* where = ctp->hash_stream + ctp->header.hash_offset + (idx - ctp->header.first_index) * ctp->header.hash_value_size;
+    switch (ctp->header.hash_value_size)
     {
     case 2: return *(unsigned short*)where;
     case 4: return *(unsigned*)where;
@@ -2276,7 +2276,7 @@ static BOOL codeview_snarf(const struct msc_debug_info* msc_dbg,
     struct symt_compiland*              compiland = NULL;
     struct location                     loc;
 
-    /* overwrite compiland name from outter context (if any) */
+    /* overwrite compiland name from outer context (if any) */
     if (objname)
         compiland = codeview_new_compiland(msc_dbg, objname);
     /*
@@ -2862,7 +2862,7 @@ static void pdb_location_compute(struct process* pcs,
             case S_DEFRANGE_FRAMEPOINTER_REL:
             case S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE:
                 loc->kind = loc_regrel;
-                loc->reg = dbghelp_current_cpu->frame_regno;
+                loc->reg = modfmt->module->cpu->frame_regno;
                 loc->offset = locinfo->offset;
                 return;
             }
@@ -2874,8 +2874,8 @@ static void pdb_location_compute(struct process* pcs,
     loc->reg = loc_err_internal;
 }
 
-static void* pdb_read_file(const struct pdb_file_info* pdb_file, DWORD file_nr);
-static unsigned pdb_get_file_size(const struct pdb_file_info* pdb_file, DWORD file_nr);
+static void* pdb_read_stream(const struct pdb_file_info* pdb_file, DWORD stream_nr);
+static unsigned pdb_get_stream_size(const struct pdb_file_info* pdb_file, DWORD stream_nr);
 
 static BOOL codeview_snarf_sym_hashtable(const struct msc_debug_info* msc_dbg, const BYTE* symroot, DWORD symsize,
                                          const BYTE* hashroot, DWORD hashsize,
@@ -2888,16 +2888,16 @@ static BOOL codeview_snarf_sym_hashtable(const struct msc_debug_info* msc_dbg, c
     if (hashsize < sizeof(DBI_HASH_HEADER) ||
         hash_hdr->signature != 0xFFFFFFFF ||
         hash_hdr->version != 0xeffe0000 + 19990810 ||
-        (hash_hdr->size_hash_records % sizeof(DBI_HASH_RECORD)) != 0 ||
-        sizeof(DBI_HASH_HEADER) + hash_hdr->size_hash_records + DBI_BITMAP_HASH_SIZE > hashsize ||
-        (hashsize - (sizeof(DBI_HASH_HEADER) + hash_hdr->size_hash_records + DBI_BITMAP_HASH_SIZE)) % sizeof(unsigned))
+        (hash_hdr->hash_records_size % sizeof(DBI_HASH_RECORD)) != 0 ||
+        sizeof(DBI_HASH_HEADER) + hash_hdr->hash_records_size + DBI_BITMAP_HASH_SIZE > hashsize ||
+        (hashsize - (sizeof(DBI_HASH_HEADER) + hash_hdr->hash_records_size + DBI_BITMAP_HASH_SIZE)) % sizeof(unsigned))
     {
         FIXME("Incorrect hash structure\n");
         return FALSE;
     }
 
     hr = (DBI_HASH_RECORD*)(hash_hdr + 1);
-    num_hash_records = hash_hdr->size_hash_records / sizeof(DBI_HASH_RECORD);
+    num_hash_records = hash_hdr->hash_records_size / sizeof(DBI_HASH_RECORD);
 
     /* Only iterate over the records listed in the hash table.
      * We assume that records present in stream, but not listed in hash table, are
@@ -3067,58 +3067,58 @@ static void* pdb_ds_read(const struct PDB_DS_HEADER* pdb, const UINT *block_list
     return buffer;
 }
 
-static void* pdb_read_jg_file(const struct PDB_JG_HEADER* pdb,
-                              const struct PDB_JG_TOC* toc, DWORD file_nr)
+static void* pdb_read_jg_stream(const struct PDB_JG_HEADER* pdb,
+                                const struct PDB_JG_TOC* toc, DWORD stream_nr)
 {
     const WORD*                 block_list;
     DWORD                       i;
 
-    if (!toc || file_nr >= toc->num_files) return NULL;
+    if (!toc || stream_nr >= toc->num_streams) return NULL;
 
-    block_list = (const WORD*) &toc->file[toc->num_files];
-    for (i = 0; i < file_nr; i++)
-        block_list += (toc->file[i].size + pdb->block_size - 1) / pdb->block_size;
+    block_list = (const WORD*) &toc->streams[toc->num_streams];
+    for (i = 0; i < stream_nr; i++)
+        block_list += (toc->streams[i].size + pdb->block_size - 1) / pdb->block_size;
 
-    return pdb_jg_read(pdb, block_list, toc->file[file_nr].size);
+    return pdb_jg_read(pdb, block_list, toc->streams[stream_nr].size);
 }
 
-static void* pdb_read_ds_file(const struct PDB_DS_HEADER* pdb,
-                              const struct PDB_DS_TOC* toc, DWORD file_nr)
+static void* pdb_read_ds_stream(const struct PDB_DS_HEADER* pdb,
+                                const struct PDB_DS_TOC* toc, DWORD stream_nr)
 {
     const UINT *block_list;
     DWORD                       i;
 
-    if (!toc || file_nr >= toc->num_files) return NULL;
-    if (toc->file_size[file_nr] == 0 || toc->file_size[file_nr] == 0xFFFFFFFF) return NULL;
+    if (!toc || stream_nr >= toc->num_streams) return NULL;
+    if (toc->stream_size[stream_nr] == 0 || toc->stream_size[stream_nr] == 0xFFFFFFFF) return NULL;
 
-    block_list = &toc->file_size[toc->num_files];
-    for (i = 0; i < file_nr; i++)
-        block_list += (toc->file_size[i] + pdb->block_size - 1) / pdb->block_size;
+    block_list = &toc->stream_size[toc->num_streams];
+    for (i = 0; i < stream_nr; i++)
+        block_list += (toc->stream_size[i] + pdb->block_size - 1) / pdb->block_size;
 
-    return pdb_ds_read(pdb, block_list, toc->file_size[file_nr]);
+    return pdb_ds_read(pdb, block_list, toc->stream_size[stream_nr]);
 }
 
-static void* pdb_read_file(const struct pdb_file_info* pdb_file,
-                           DWORD file_nr)
+static void* pdb_read_stream(const struct pdb_file_info* pdb_file,
+                             DWORD stream_nr)
 {
     switch (pdb_file->kind)
     {
     case PDB_JG:
-        return pdb_read_jg_file((const struct PDB_JG_HEADER*)pdb_file->image,
-                                pdb_file->u.jg.toc, file_nr);
+        return pdb_read_jg_stream((const struct PDB_JG_HEADER*)pdb_file->image,
+                                pdb_file->u.jg.toc, stream_nr);
     case PDB_DS:
-        return pdb_read_ds_file((const struct PDB_DS_HEADER*)pdb_file->image,
-                                pdb_file->u.ds.toc, file_nr);
+        return pdb_read_ds_stream((const struct PDB_DS_HEADER*)pdb_file->image,
+                                pdb_file->u.ds.toc, stream_nr);
     }
     return NULL;
 }
 
-static unsigned pdb_get_file_size(const struct pdb_file_info* pdb_file, DWORD file_nr)
+static unsigned pdb_get_stream_size(const struct pdb_file_info* pdb_file, DWORD stream_nr)
 {
     switch (pdb_file->kind)
     {
-    case PDB_JG: return pdb_file->u.jg.toc->file[file_nr].size;
-    case PDB_DS: return pdb_file->u.ds.toc->file_size[file_nr];
+    case PDB_JG: return pdb_file->u.jg.toc->streams[stream_nr].size;
+    case PDB_DS: return pdb_file->u.ds.toc->stream_size[stream_nr];
     }
     return 0;
 }
@@ -3205,9 +3205,9 @@ static PDB_STRING_TABLE* pdb_read_strings(const struct pdb_file_info* pdb_file)
     idx = pdb_get_stream_by_name(pdb_file, "/names");
     if (idx != -1)
     {
-        ret = pdb_read_file( pdb_file, idx );
+        ret = pdb_read_stream( pdb_file, idx );
         if (ret && ret->magic == 0xeffeeffe &&
-            sizeof(*ret) + ret->length <= pdb_get_file_size(pdb_file, idx)) return ret;
+            sizeof(*ret) + ret->length <= pdb_get_stream_size(pdb_file, idx)) return ret;
         pdb_free( ret );
     }
     WARN("string table not found\n");
@@ -3248,7 +3248,7 @@ static BOOL pdb_convert_types_header(PDB_TYPES* types, const BYTE* image)
         types->type_size   = old->type_size;
         types->first_index = old->first_index;
         types->last_index  = old->last_index;
-        types->hash_file   = old->hash_file;
+        types->hash_stream = old->hash_stream;
     }
     else
     {
@@ -3268,15 +3268,15 @@ static void pdb_convert_symbols_header(PDB_SYMBOLS* symbols,
     {
         /* Old version of the symbols record header */
         const PDB_SYMBOLS_OLD*  old = (const PDB_SYMBOLS_OLD*)image;
-        symbols->version         = 0;
-        symbols->module_size     = old->module_size;
-        symbols->offset_size     = old->offset_size;
-        symbols->hash_size       = old->hash_size;
-        symbols->srcmodule_size  = old->srcmodule_size;
-        symbols->pdbimport_size  = 0;
-        symbols->global_hash_file= old->global_hash_file;
-        symbols->public_file     = old->public_file;
-        symbols->gsym_file       = old->gsym_file;
+        symbols->version            = 0;
+        symbols->module_size        = old->module_size;
+        symbols->sectcontrib_size   = old->sectcontrib_size;
+        symbols->segmap_size        = old->segmap_size;
+        symbols->srcmodule_size     = old->srcmodule_size;
+        symbols->pdbimport_size     = 0;
+        symbols->global_hash_stream = old->global_hash_stream;
+        symbols->public_stream      = old->public_stream;
+        symbols->gsym_stream        = old->gsym_stream;
 
         *header_size = sizeof(PDB_SYMBOLS_OLD);
     }
@@ -3288,8 +3288,8 @@ static void pdb_convert_symbols_header(PDB_SYMBOLS* symbols,
     }
 }
 
-static void pdb_convert_symbol_file(const PDB_SYMBOLS* symbols, 
-                                    PDB_SYMBOL_FILE_EX* sfile, 
+static void pdb_convert_symbol_file(const PDB_SYMBOLS* symbols,
+                                    PDB_SYMBOL_FILE_EX* sfile,
                                     unsigned* size, const void* image)
 
 {
@@ -3297,10 +3297,10 @@ static void pdb_convert_symbol_file(const PDB_SYMBOLS* symbols,
     {
         const PDB_SYMBOL_FILE *sym_file = image;
         memset(sfile, 0, sizeof(*sfile));
-        sfile->file        = sym_file->file;
-        sfile->range.index = sym_file->range.index;
-        sfile->symbol_size = sym_file->symbol_size;
-        sfile->lineno_size = sym_file->lineno_size;
+        sfile->stream       = sym_file->stream;
+        sfile->range.index  = sym_file->range.index;
+        sfile->symbol_size  = sym_file->symbol_size;
+        sfile->lineno_size  = sym_file->lineno_size;
         sfile->lineno2_size = sym_file->lineno2_size;
         *size = sizeof(PDB_SYMBOL_FILE) - 1;
     }
@@ -3387,12 +3387,12 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
         ERR("-Unknown type info version %d\n", ctp->header.version);
         return FALSE;
     }
-    if (ctp->header.hash_size != 2 && ctp->header.hash_size != 4)
+    if (ctp->header.hash_value_size != 2 && ctp->header.hash_value_size != 4)
     {
-        ERR("-Unsupported hash of size %u\n", ctp->header.hash_size);
+        ERR("-Unsupported hash of size %u\n", ctp->header.hash_value_size);
         return FALSE;
     }
-    ctp->hash_stream = pdb_read_file(pdb_file, ctp->header.hash_file);
+    ctp->hash_stream = pdb_read_stream(pdb_file, ctp->header.hash_stream);
     /* FIXME always present? if not reconstruct ?*/
     if (!ctp->hash_stream)
     {
@@ -3402,7 +3402,7 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
 
     ctp->module = msc_dbg->module;
     /* Reconstruct the types offset table
-     * Note: the hash subfile of the PDB_TYPES only contains a partial table
+     * Note: the hash stream of the PDB_TYPES only contains a partial table
      * (not all the indexes are present, so it requires first a binary search in partial table,
      * followed by a linear search...)
      */
@@ -3429,7 +3429,7 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
     /* parse the remap table
      * => move listed type_id at first position of their hash buckets so that we force remap to them
      */
-    if (ctp->header.type_remap_len)
+    if (ctp->header.type_remap_size)
     {
         const unsigned* remap = (const unsigned*)((const BYTE*)ctp->hash_stream + ctp->header.type_remap_offset);
         unsigned i, capa, count_present;
@@ -3472,7 +3472,7 @@ static void pdb_process_types(const struct msc_debug_info* msc_dbg,
                               const struct pdb_file_info* pdb_file)
 {
     struct codeview_type_parse ctp;
-    BYTE* types_image = pdb_read_file(pdb_file, 2);
+    BYTE* types_image = pdb_read_stream(pdb_file, 2);
 
     if (types_image)
     {
@@ -3513,7 +3513,7 @@ static BOOL pdb_init(const struct pdb_lookup* pdb_lookup, struct pdb_file_info*
         struct PDB_JG_ROOT*         root;
 
         pdb_file->u.jg.toc = pdb_jg_read(pdb, pdb->toc_block, pdb->toc.size);
-        root = pdb_read_jg_file(pdb, pdb_file->u.jg.toc, 1);
+        root = pdb_read_jg_stream(pdb, pdb_file->u.jg.toc, 1);
         if (!root)
         {
             ERR("-Unable to get root from .PDB in %s\n", pdb_lookup->filename);
@@ -3555,9 +3555,9 @@ static BOOL pdb_init(const struct pdb_lookup* pdb_lookup, struct pdb_file_info*
         struct PDB_DS_ROOT*         root;
 
         pdb_file->u.ds.toc =
-            pdb_ds_read(pdb, (const UINT*)((const char*)pdb + pdb->toc_page * pdb->block_size),
+            pdb_ds_read(pdb, (const UINT*)((const char*)pdb + pdb->toc_block * pdb->block_size),
                         pdb->toc_size);
-        root = pdb_read_ds_file(pdb, pdb_file->u.ds.toc, 1);
+        root = pdb_read_ds_stream(pdb, pdb_file->u.ds.toc, 1);
         if (!root)
         {
             ERR("-Unable to get root from .PDB in %s\n", pdb_lookup->filename);
@@ -3589,20 +3589,20 @@ static BOOL pdb_init(const struct pdb_lookup* pdb_lookup, struct pdb_file_info*
 
     if (0) /* some tool to dump the internal files from a PDB file */
     {
-        int     i, num_files;
-        
+        int     i, num_streams;
+
         switch (pdb_file->kind)
         {
-        case PDB_JG: num_files = pdb_file->u.jg.toc->num_files; break;
-        case PDB_DS: num_files = pdb_file->u.ds.toc->num_files; break;
+        case PDB_JG: num_streams = pdb_file->u.jg.toc->num_streams; break;
+        case PDB_DS: num_streams = pdb_file->u.ds.toc->num_streams; break;
         }
 
-        for (i = 1; i < num_files; i++)
+        for (i = 1; i < num_streams; i++)
         {
-            unsigned char* x = pdb_read_file(pdb_file, i);
+            unsigned char* x = pdb_read_stream(pdb_file, i);
             FIXME("********************** [%u]: size=%08x\n",
-                  i, pdb_get_file_size(pdb_file, i));
-            dump(x, pdb_get_file_size(pdb_file, i));
+                  i, pdb_get_stream_size(pdb_file, i));
+            dump(x, pdb_get_stream_size(pdb_file, i));
             pdb_free(x);
         }
     }
@@ -3633,9 +3633,9 @@ static void pdb_process_symbol_imports(const struct process* pcs,
         int                     i = 0;
         struct pdb_file_info    sf0 = pdb_module_info->pdb_files[0];
 
-        imp = (const PDB_SYMBOL_IMPORT*)((const char*)symbols_image + sizeof(PDB_SYMBOLS) + 
-                                         symbols->module_size + symbols->offset_size + 
-                                         symbols->hash_size + symbols->srcmodule_size);
+        imp = (const PDB_SYMBOL_IMPORT*)((const char*)symbols_image + sizeof(PDB_SYMBOLS) +
+                                         symbols->module_size + symbols->sectcontrib_size +
+                                         symbols->segmap_size + symbols->srcmodule_size);
         first = imp;
         last = (const char*)imp + symbols->pdbimport_size;
         while (imp < (const PDB_SYMBOL_IMPORT*)last)
@@ -3711,7 +3711,7 @@ static BOOL pdb_process_internal(const struct process* pcs,
 
     pdb_file->hMap = hMap;
     pdb_file->image = image;
-    symbols_image = pdb_read_file(pdb_file, 3);
+    symbols_image = pdb_read_stream(pdb_file, 3);
     if (symbols_image)
     {
         PDB_SYMBOLS symbols;
@@ -3745,8 +3745,8 @@ static BOOL pdb_process_internal(const struct process* pcs,
             break;
         case sizeof(PDB_STREAM_INDEXES):
             psi = (PDB_STREAM_INDEXES*)((const char*)symbols_image + sizeof(PDB_SYMBOLS) +
-                                        symbols.module_size + symbols.offset_size +
-                                        symbols.hash_size + symbols.srcmodule_size +
+                                        symbols.module_size + symbols.sectcontrib_size +
+                                        symbols.segmap_size + symbols.srcmodule_size +
                                         symbols.pdbimport_size + symbols.unknown2_size);
             pdb_file->fpoext_stream = psi->FPO_EXT;
             break;
@@ -3761,23 +3761,23 @@ static BOOL pdb_process_internal(const struct process* pcs,
                                    pdb_lookup, pdb_module_info, module_index);
         pdb_process_types(msc_dbg, pdb_file);
 
-        ipi_image = pdb_read_file(pdb_file, 4);
+        ipi_image = pdb_read_stream(pdb_file, 4);
         ipi_ok = pdb_init_type_parse(msc_dbg, pdb_file, &ipi_ctp, ipi_image);
 
         /* Read global types first, so that lookup by name in module (=compilation unit)
          * streams' loading can succeed them.
          */
-        globalimage = pdb_read_file(pdb_file, symbols.gsym_file);
+        globalimage = pdb_read_stream(pdb_file, symbols.gsym_stream);
         if (globalimage)
         {
             const BYTE* data;
-            unsigned global_size = pdb_get_file_size(pdb_file, symbols.gsym_file);
+            unsigned global_size = pdb_get_stream_size(pdb_file, symbols.gsym_stream);
 
-            data = pdb_read_file(pdb_file, symbols.global_hash_file);
+            data = pdb_read_stream(pdb_file, symbols.global_hash_stream);
             if (data)
             {
                 codeview_snarf_sym_hashtable(msc_dbg, globalimage, global_size,
-                                             data, pdb_get_file_size(pdb_file, symbols.global_hash_file),
+                                             data, pdb_get_stream_size(pdb_file, symbols.global_hash_stream),
                                              pdb_global_feed_types);
                 pdb_free((void*)data);
             }
@@ -3794,7 +3794,7 @@ static BOOL pdb_process_internal(const struct process* pcs,
             HeapValidate(GetProcessHeap(), 0, NULL);
             pdb_convert_symbol_file(&symbols, &sfile, &size, file);
 
-            modimage = pdb_read_file(pdb_file, sfile.file);
+            modimage = pdb_read_stream(pdb_file, sfile.stream);
             file_name = (const char*)file + size;
             if (modimage)
             {
@@ -3820,20 +3820,20 @@ static BOOL pdb_process_internal(const struct process* pcs,
         if (globalimage)
         {
             const BYTE* data;
-            unsigned global_size = pdb_get_file_size(pdb_file, symbols.gsym_file);
+            unsigned global_size = pdb_get_stream_size(pdb_file, symbols.gsym_stream);
 
-            data = pdb_read_file(pdb_file, symbols.global_hash_file);
+            data = pdb_read_stream(pdb_file, symbols.global_hash_stream);
             if (data)
             {
                 codeview_snarf_sym_hashtable(msc_dbg, globalimage, global_size,
-                                             data, pdb_get_file_size(pdb_file, symbols.global_hash_file),
+                                             data, pdb_get_stream_size(pdb_file, symbols.global_hash_stream),
                                              pdb_global_feed_variables);
                 pdb_free((void*)data);
             }
-            if (!(dbghelp_options & SYMOPT_NO_PUBLICS) && (data = pdb_read_file(pdb_file, symbols.public_file)))
+            if (!(dbghelp_options & SYMOPT_NO_PUBLICS) && (data = pdb_read_stream(pdb_file, symbols.public_stream)))
             {
                 const DBI_PUBLIC_HEADER* pubhdr = (const DBI_PUBLIC_HEADER*)data;
-                codeview_snarf_sym_hashtable(msc_dbg, globalimage, pdb_get_file_size(pdb_file, symbols.gsym_file),
+                codeview_snarf_sym_hashtable(msc_dbg, globalimage, pdb_get_stream_size(pdb_file, symbols.gsym_stream),
                                              (const BYTE*)(pubhdr + 1), pubhdr->hash_size, pdb_global_feed_public);
                 pdb_free((void*)data);
             }
@@ -4209,8 +4209,8 @@ BOOL pdb_virtual_unwind(struct cpu_stack_walk *csw, DWORD_PTR ip,
 
     strbase = pdb_read_strings(&pdb_info->pdb_files[0]);
     if (!strbase) return FALSE;
-    fpoext = pdb_read_file(&pdb_info->pdb_files[0], pdb_info->pdb_files[0].fpoext_stream);
-    size = pdb_get_file_size(&pdb_info->pdb_files[0], pdb_info->pdb_files[0].fpoext_stream);
+    fpoext = pdb_read_stream(&pdb_info->pdb_files[0], pdb_info->pdb_files[0].fpoext_stream);
+    size = pdb_get_stream_size(&pdb_info->pdb_files[0], pdb_info->pdb_files[0].fpoext_stream);
     if (fpoext && (size % sizeof(*fpoext)) == 0)
     {
         size /= sizeof(*fpoext);
diff --git a/dlls/dbghelp/path.c b/dlls/dbghelp/path.c
index d23a4b5733e..fe1da8849eb 100644
--- a/dlls/dbghelp/path.c
+++ b/dlls/dbghelp/path.c
@@ -722,7 +722,7 @@ static BOOL try_match_file(const WCHAR *name, BOOL (*match)(void*, HANDLE, const
     return FALSE;
 }
 
-BOOL search_dll_path(const struct process *process, const WCHAR *name, BOOL (*match)(void*, HANDLE, const WCHAR*), void *param)
+BOOL search_dll_path(const struct process *process, const WCHAR *name, WORD machine, BOOL (*match)(void*, HANDLE, const WCHAR*), void *param)
 {
     const WCHAR *env;
     WCHAR *p, *end;
@@ -733,7 +733,8 @@ BOOL search_dll_path(const struct process *process, const WCHAR *name, BOOL (*ma
 
     name = file_name(name);
 
-    cpu = process_get_cpu(process);
+    cpu = machine == IMAGE_FILE_MACHINE_UNKNOWN ? process_get_cpu(process) : cpu_find(machine);
+
     for (machine_dir = all_machine_dir; machine_dir < all_machine_dir + ARRAY_SIZE(all_machine_dir); machine_dir++)
         if (machine_dir->machine == cpu->machine) break;
     if (machine_dir >= all_machine_dir + ARRAY_SIZE(all_machine_dir)) return FALSE;
diff --git a/dlls/dbghelp/pe_module.c b/dlls/dbghelp/pe_module.c
index 4a7e68d5483..7aeb1cf8901 100644
--- a/dlls/dbghelp/pe_module.c
+++ b/dlls/dbghelp/pe_module.c
@@ -26,6 +26,8 @@
 #include <string.h>
 #include <assert.h>
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "dbghelp_private.h"
 #include "image_private.h"
 #include "winternl.h"
@@ -267,11 +269,6 @@ BOOL pe_map_file(HANDLE file, struct image_file_map* fmap, enum module_type mt)
             switch (nthdr->OptionalHeader.Magic)
             {
             case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
-                if (sizeof(void*) == 8 && !(SymGetOptions() & SYMOPT_INCLUDE_32BIT_MODULES))
-                {
-                    TRACE("Won't load 32bit module in 64bit dbghelp when options don't ask for it\n");
-                    goto error;
-                }
                 fmap->addr_size = 32;
                 memcpy(&fmap->u.pe.opt.header32, &nthdr->OptionalHeader, sizeof(fmap->u.pe.opt.header32));
                 break;
@@ -784,6 +781,7 @@ struct module* pe_load_native_module(struct process* pcs, const WCHAR* name,
     BOOL                        opened = FALSE;
     struct module_format*       modfmt;
     WCHAR                       loaded_name[MAX_PATH];
+    WCHAR*                      real_path = NULL;
 
     loaded_name[0] = '\0';
     if (!hFile)
@@ -795,18 +793,44 @@ struct module* pe_load_native_module(struct process* pcs, const WCHAR* name,
             return NULL;
         opened = TRUE;
     }
-    else if (name) lstrcpyW(loaded_name, name);
+    else
+    {
+        ULONG sz = sizeof(OBJECT_NAME_INFORMATION) + MAX_PATH * sizeof(WCHAR), needed;
+        OBJECT_NAME_INFORMATION *obj_name;
+        NTSTATUS nts;
+
+        obj_name = RtlAllocateHeap(GetProcessHeap(), 0, sz);
+        if (obj_name)
+        {
+            nts = NtQueryObject(hFile, ObjectNameInformation, obj_name, sz, &needed);
+            if (nts == STATUS_BUFFER_OVERFLOW)
+            {
+                sz = needed;
+                obj_name = RtlReAllocateHeap(GetProcessHeap(), 0, obj_name, sz);
+                nts = NtQueryObject(hFile, ObjectNameInformation, obj_name, sz, &needed);
+            }
+            if (!nts)
+            {
+                obj_name->Name.Buffer[obj_name->Name.Length / sizeof(WCHAR)] = L'\0';
+                real_path = wcsdup(obj_name->Name.Buffer);
+            }
+            RtlFreeHeap(GetProcessHeap(), 0, obj_name);
+        }
+        if (name) lstrcpyW(loaded_name, name);
+    }
     if (!(modfmt = HeapAlloc(GetProcessHeap(), 0, sizeof(struct module_format) + sizeof(struct pe_module_info))))
         return NULL;
     modfmt->u.pe_info = (struct pe_module_info*)(modfmt + 1);
     if (pe_map_file(hFile, &modfmt->u.pe_info->fmap, DMT_PE))
     {
         struct builtin_search builtin = { NULL };
-        if (modfmt->u.pe_info->fmap.u.pe.builtin && search_dll_path(pcs, loaded_name, search_builtin_pe, &builtin))
+        if (opened && modfmt->u.pe_info->fmap.u.pe.builtin &&
+            search_dll_path(pcs, loaded_name, modfmt->u.pe_info->fmap.u.pe.file_header.Machine, search_builtin_pe, &builtin))
         {
             TRACE("reloaded %s from %s\n", debugstr_w(loaded_name), debugstr_w(builtin.path));
             image_unmap_file(&modfmt->u.pe_info->fmap);
             modfmt->u.pe_info->fmap = builtin.fmap;
+            real_path = builtin.path;
         }
         if (!base) base = PE_FROM_OPTHDR(&modfmt->u.pe_info->fmap, ImageBase);
         if (!size) size = PE_FROM_OPTHDR(&modfmt->u.pe_info->fmap, SizeOfImage);
@@ -817,7 +841,7 @@ struct module* pe_load_native_module(struct process* pcs, const WCHAR* name,
                             modfmt->u.pe_info->fmap.u.pe.file_header.Machine);
         if (module)
         {
-            module->real_path = builtin.path;
+            module->real_path = real_path;
             modfmt->module = module;
             modfmt->remove = pe_module_remove;
             modfmt->loc_compute = NULL;
@@ -827,7 +851,7 @@ struct module* pe_load_native_module(struct process* pcs, const WCHAR* name,
         else
         {
             ERR("could not load the module '%s'\n", debugstr_w(loaded_name));
-            heap_free(builtin.path);
+            heap_free(real_path);
             image_unmap_file(&modfmt->u.pe_info->fmap);
         }
     }
diff --git a/dlls/dbghelp/tests/Makefile.in b/dlls/dbghelp/tests/Makefile.in
index 31e5b01e8a8..40ec97eca8c 100644
--- a/dlls/dbghelp/tests/Makefile.in
+++ b/dlls/dbghelp/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = dbghelp.dll
-IMPORTS   = dbghelp
+IMPORTS   = dbghelp user32
 
 C_SRCS = \
 	dbghelp.c
diff --git a/dlls/dbghelp/tests/dbghelp.c b/dlls/dbghelp/tests/dbghelp.c
index 73f8ee5f14f..618ee6e8cdb 100644
--- a/dlls/dbghelp/tests/dbghelp.c
+++ b/dlls/dbghelp/tests/dbghelp.c
@@ -16,10 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "windef.h"
+#include "windows.h"
+#include "psapi.h"
 #include "verrsrc.h"
 #include "dbghelp.h"
 #include "wine/test.h"
+#include "winternl.h"
+
+static const BOOL is_win64 = sizeof(void*) > sizeof(int);
 
 #if defined(__i386__) || defined(__x86_64__)
 
@@ -190,6 +194,525 @@ static void test_search_path(void)
     ok(!strcmp(search_path, "."), "Got search path '%s', expected '.'\n", search_path);
 }
 
+static USHORT get_module_machine(const char* path)
+{
+    HANDLE hFile, hMap;
+    void* mapping;
+    IMAGE_NT_HEADERS *nthdr;
+    USHORT machine = IMAGE_FILE_MACHINE_UNKNOWN;
+
+    hFile = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        hMap = CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
+        if (hMap != NULL)
+        {
+            mapping = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
+            if (mapping != NULL)
+            {
+                nthdr = RtlImageNtHeader(mapping);
+                if (nthdr != NULL) machine = nthdr->FileHeader.Machine;
+                UnmapViewOfFile(mapping);
+            }
+            CloseHandle(hMap);
+        }
+        CloseHandle(hFile);
+    }
+    return machine;
+}
+
+static BOOL skip_too_old_dbghelp(HANDLE proc, DWORD64 base)
+{
+    IMAGEHLP_MODULE im0 = {sizeof(im0)};
+    BOOL ret;
+
+    /* test if get module info succeeds with oldest structure format */
+    ret = SymGetModuleInfo(proc, base, &im0);
+    if (ret)
+    {
+        skip("Too old dbghelp. Skipping module tests.\n");
+        ret = SymCleanup(proc);
+        ok(ret, "SymCleanup failed: %lu\n", GetLastError());
+        return TRUE;
+    }
+    ok(ret, "SymGetModuleInfo failed: %lu\n", GetLastError());
+    return FALSE;
+}
+
+static DWORD get_module_size(const char* path)
+{
+    BOOL ret;
+    HANDLE hFile, hMap;
+    void* mapping;
+    IMAGE_NT_HEADERS *nthdr;
+    DWORD size;
+
+    hFile = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
+    ok(hFile != INVALID_HANDLE_VALUE, "Couldn't open file %s (%lu)\n", path, GetLastError());
+    hMap = CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
+    ok(hMap != NULL, "Couldn't create map (%lu)\n", GetLastError());
+    mapping = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
+    ok(mapping != NULL, "Couldn't map (%lu)\n", GetLastError());
+    nthdr = RtlImageNtHeader(mapping);
+    ok(nthdr != NULL, "Cannot get NT headers out of %s\n", path);
+    size = nthdr ? nthdr->OptionalHeader.SizeOfImage : 0;
+    ret = UnmapViewOfFile(mapping);
+    ok(ret, "Couldn't unmap (%lu)\n", GetLastError());
+    CloseHandle(hMap);
+    CloseHandle(hFile);
+    return size;
+}
+
+static BOOL CALLBACK count_module_cb(const char* name, DWORD64 base, void* usr)
+{
+    (*(unsigned*)usr)++;
+    return TRUE;
+}
+
+static unsigned get_module_count(HANDLE proc)
+{
+    unsigned count = 0;
+    BOOL ret;
+
+    ret = SymEnumerateModules64(proc, count_module_cb, &count);
+    ok(ret, "SymEnumerateModules64 failed: %lu\n", GetLastError());
+    return count;
+}
+
+struct nth_module
+{
+    HANDLE              proc;
+    unsigned int        index;
+    BOOL                will_fail;
+    IMAGEHLP_MODULE64   module;
+};
+
+static BOOL CALLBACK nth_module_cb(const char* name, DWORD64 base, void* usr)
+{
+    struct nth_module* nth = usr;
+    BOOL ret;
+
+    if (nth->index--) return TRUE;
+    nth->module.SizeOfStruct = sizeof(nth->module);
+    ret = SymGetModuleInfo64(nth->proc, base, &nth->module);
+    if (nth->will_fail)
+    {
+        ok(!ret, "SymGetModuleInfo64 should have failed\n");
+        nth->module.BaseOfImage = base;
+    }
+    else
+    {
+        ok(ret, "SymGetModuleInfo64 failed: %lu\n", GetLastError());
+        ok(nth->module.BaseOfImage == base, "Wrong base\n");
+    }
+    return FALSE;
+}
+
+static BOOL test_modules(void)
+{
+    BOOL ret;
+    char file_system[MAX_PATH];
+    char file_wow64[MAX_PATH];
+    DWORD64 base;
+    const DWORD64 base1 = 0x00010000;
+    const DWORD64 base2 = 0x08010000;
+    IMAGEHLP_MODULEW64 im;
+    USHORT machine_wow, machine2;
+    HANDLE dummy = (HANDLE)(ULONG_PTR)0xcafef00d;
+    const char* target_dll = "c:\\windows\\system32\\kernel32.dll";
+    unsigned count;
+
+    im.SizeOfStruct = sizeof(im);
+
+    /* can sym load an exec of different bitness even if 32Bit flag not set */
+
+    SymSetOptions(SymGetOptions() & ~SYMOPT_INCLUDE_32BIT_MODULES);
+    ret = SymInitialize(GetCurrentProcess(), 0, FALSE);
+    ok(ret, "SymInitialize failed: %lu\n", GetLastError());
+
+    GetSystemWow64DirectoryA(file_wow64, MAX_PATH);
+    strcat(file_wow64, "\\notepad.exe");
+
+    /* not always present */
+    machine_wow = get_module_machine(file_wow64);
+    if (machine_wow != IMAGE_FILE_MACHINE_UNKNOWN)
+    {
+        base = SymLoadModule(GetCurrentProcess(), NULL, file_wow64, NULL, base2, 0);
+        ok(base == base2, "SymLoadModule failed: %lu\n", GetLastError());
+        ret = SymGetModuleInfoW64(GetCurrentProcess(), base2, &im);
+        if (!ret && skip_too_old_dbghelp(GetCurrentProcess(), base2)) return FALSE;
+        ok(ret, "SymGetModuleInfoW64 failed: %lu\n", GetLastError());
+        ok(im.BaseOfImage == base2, "Wrong base address\n");
+        ok(im.MachineType == machine_wow, "Wrong machine %lx (expecting %u)\n", im.MachineType, machine_wow);
+    }
+
+    GetSystemDirectoryA(file_system, MAX_PATH);
+    strcat(file_system, "\\notepad.exe");
+
+    base = SymLoadModule(GetCurrentProcess(), NULL, file_system, NULL, base1, 0);
+    ok(base == base1, "SymLoadModule failed: %lu\n", GetLastError());
+    ret = SymGetModuleInfoW64(GetCurrentProcess(), base1, &im);
+    if (!ret && skip_too_old_dbghelp(GetCurrentProcess(), base1)) return FALSE;
+    ok(ret, "SymGetModuleInfoW64 failed: %lu\n", GetLastError());
+    ok(im.BaseOfImage == base1, "Wrong base address\n");
+    machine2 = get_module_machine(file_system);
+    ok(machine2 != IMAGE_FILE_MACHINE_UNKNOWN, "Unexpected machine %u\n", machine2);
+    ok(im.MachineType == machine2, "Wrong machine %lx (expecting %u)\n", im.MachineType, machine2);
+
+    /* still can access first module after loading second */
+    if (machine_wow != IMAGE_FILE_MACHINE_UNKNOWN)
+    {
+        ret = SymGetModuleInfoW64(GetCurrentProcess(), base2, &im);
+        ok(ret, "SymGetModuleInfoW64 failed: %lu\n", GetLastError());
+        ok(im.BaseOfImage == base2, "Wrong base address\n");
+        ok(im.MachineType == machine_wow, "Wrong machine %lx (expecting %u)\n", im.MachineType, machine_wow);
+    }
+
+    ret = SymCleanup(GetCurrentProcess());
+    ok(ret, "SymCleanup failed: %lu\n", GetLastError());
+
+    ret = SymInitialize(dummy, NULL, FALSE);
+    ok(ret, "got error %lu\n", GetLastError());
+
+    count = get_module_count(dummy);
+    ok(count == 0, "Unexpected count (%u instead of 0)\n", count);
+
+    /* loading with 0 size succeeds */
+    base = SymLoadModuleEx(dummy, NULL, target_dll, NULL, base1, 0, NULL, 0);
+    ok(base == base1, "SymLoadModuleEx failed: %lu\n", GetLastError());
+
+    ret = SymUnloadModule64(dummy, base1);
+    ok(ret, "SymUnloadModule64 failed: %lu\n", GetLastError());
+
+    count = get_module_count(dummy);
+    ok(count == 0, "Unexpected count (%u instead of 0)\n", count);
+
+    ret = SymCleanup(dummy);
+    ok(ret, "SymCleanup failed: %lu\n", GetLastError());
+
+    return TRUE;
+}
+
+static void test_modules_overlap(void)
+{
+    BOOL ret;
+    DWORD64 base;
+    const DWORD64 base1 = 0x00010000;
+    HANDLE dummy = (HANDLE)(ULONG_PTR)0xcafef00d;
+    const char* target1_dll = "c:\\windows\\system32\\kernel32.dll";
+    const char* target2_dll = "c:\\windows\\system32\\winmm.dll";
+    DWORD imsize = get_module_size(target1_dll);
+    char buffer[512];
+    IMAGEHLP_SYMBOL64* sym = (void*)buffer;
+
+    int i, j;
+    struct test_module
+    {
+        DWORD64             base;
+        DWORD               size;
+        const char*         name;
+    };
+    const struct test
+    {
+        struct test_module  input;
+        DWORD               error_code;
+        struct test_module  outputs[2];
+    }
+    tests[] =
+    {
+        /* cases where first module is left "untouched" and second not loaded */
+        {{base1,              0,          target1_dll}, ERROR_SUCCESS, {{base1, imsize, "kernel32"},{0}}},
+        {{base1,              imsize,     target1_dll}, ERROR_SUCCESS, {{base1, imsize, "kernel32"},{0}}},
+        {{base1,              imsize / 2, target1_dll}, ERROR_SUCCESS, {{base1, imsize, "kernel32"},{0}}},
+        {{base1,              imsize * 2, target1_dll}, ERROR_SUCCESS, {{base1, imsize, "kernel32"},{0}}},
+
+        /* cases where first module is unloaded and replaced by second module */
+        {{base1 + imsize / 2, imsize,     target1_dll}, ~0,            {{base1 + imsize / 2, imsize,     "kernel32"},{0}}},
+        {{base1 + imsize / 3, imsize / 3, target1_dll}, ~0,            {{base1 + imsize / 3, imsize / 3, "kernel32"},{0}}},
+        {{base1 + imsize / 2, imsize,     target2_dll}, ~0,            {{base1 + imsize / 2, imsize,     "winmm"},{0}}},
+        {{base1 + imsize / 3, imsize / 3, target2_dll}, ~0,            {{base1 + imsize / 3, imsize / 3, "winmm"},{0}}},
+
+        /* cases where second module is actually loaded */
+        {{base1 + imsize,     imsize,     target1_dll}, ~0,            {{base1, imsize, "kernel32"}, {base1 + imsize, imsize, "kernel32"}}},
+        {{base1 - imsize / 2, imsize,     target1_dll}, ~0,            {{base1, imsize, "kernel32"}, {base1 - imsize / 2, imsize, NULL}}},
+        /* we mark with a NULL modulename the cases where the module is loaded, but isn't visible
+         * (SymGetModuleInfo fails in callback) as it's base address is inside the first loaded module.
+         */
+        {{base1 + imsize,     imsize,     target2_dll}, ~0,            {{base1, imsize, "kernel32"}, {base1 + imsize, imsize, "winmm"}}},
+        {{base1 - imsize / 2, imsize,     target2_dll}, ~0,            {{base1, imsize, "kernel32"}, {base1 - imsize / 2, imsize, NULL}}},
+    };
+
+    ok(imsize, "Cannot get image size\n");
+
+    for (i = 0; i < ARRAY_SIZE(tests); i++)
+    {
+        ret = SymInitialize(dummy, NULL, FALSE);
+        ok(ret, "SymInitialize failed: %lu\n", GetLastError());
+
+        base = SymLoadModuleEx(dummy, NULL, target1_dll, NULL, base1, 0, NULL, 0);
+        ok(base == base1, "SymLoadModuleEx failed: %lu\n", GetLastError());
+        ret = SymAddSymbol(dummy, base1, "winetest_symbol_virtual", base1 + (3 * imsize) / 4, 13, 0);
+        ok(ret, "SymAddSymbol failed: %lu\n", GetLastError());
+
+        base = SymLoadModuleEx(dummy, NULL, tests[i].input.name, NULL, tests[i].input.base, tests[i].input.size, NULL, 0);
+        if (tests[i].error_code != ~0)
+        {
+            ok(base == 0, "SymLoadModuleEx should have failed\n");
+            ok(GetLastError() == tests[i].error_code, "Wrong error %lu\n", GetLastError());
+        }
+        else
+        {
+            ok(base == tests[i].input.base, "SymLoadModuleEx failed: %lu\n", GetLastError());
+        }
+        for (j = 0; j < ARRAY_SIZE(tests[i].outputs); j++)
+        {
+            struct nth_module nth = {dummy, j, !tests[i].outputs[j].name, {0}};
+
+            ret = SymEnumerateModules64(dummy, nth_module_cb, &nth);
+            ok(ret, "SymEnumerateModules64 failed: %lu\n", GetLastError());
+            if (!tests[i].outputs[j].base)
+            {
+                ok(nth.index != -1, "Got more modules than expected %d, %d\n", nth.index, j);
+                break;
+            }
+            ok(nth.index == -1, "Expecting more modules\n");
+            ok(nth.module.BaseOfImage == tests[i].outputs[j].base, "Wrong base\n");
+            if (!nth.will_fail)
+            {
+                ok(nth.module.ImageSize == tests[i].outputs[j].size, "Wrong size\n");
+                ok(!strcasecmp(nth.module.ModuleName, tests[i].outputs[j].name), "Wrong name\n");
+            }
+        }
+        memset(sym, 0, sizeof(*sym));
+        sym->SizeOfStruct = sizeof(*sym);
+        sym->MaxNameLength = sizeof(buffer) - sizeof(*sym);
+        ret = SymGetSymFromName64(dummy, "winetest_symbol_virtual", sym);
+        if (tests[i].error_code == ERROR_SUCCESS || tests[i].outputs[1].base)
+        {
+            /* first module is not unloaded, so our added symbol should be present, with right attributes */
+            ok(ret, "SymGetSymFromName64 has failed: %lu (%d, %d)\n", GetLastError(), i, j);
+            ok(sym->Address == base1 + (3 * imsize) / 4, "Unexpected size %lu\n", sym->Size);
+            ok(sym->Size == 13, "Unexpected size %lu\n", sym->Size);
+            ok(sym->Flags & SYMFLAG_VIRTUAL, "Unexpected flag %lx\n", sym->Flags);
+        }
+        else
+        {
+            /* the first module is really unloaded, the our added symbol has disappead */
+            ok(!ret, "SymGetSymFromName64 should have failed %lu\n", GetLastError());
+        }
+        ret = SymCleanup(dummy);
+        ok(ret, "SymCleanup failed: %lu\n", GetLastError());
+    }
+}
+
+struct loaded_module_aggregation
+{
+    HANDLE       proc;
+    unsigned int count_32bit;
+    unsigned int count_64bit;
+    unsigned int count_exe;
+    unsigned int count_ntdll;
+    unsigned int count_systemdir;
+    unsigned int count_wowdir;
+};
+
+static BOOL CALLBACK aggregate_cb(PCWSTR imagename, DWORD64 base, ULONG sz, PVOID usr)
+{
+    struct loaded_module_aggregation* aggregation = usr;
+    IMAGEHLP_MODULEW64 im;
+    size_t image_len;
+    BOOL ret, wow64;
+    WCHAR buffer[MAX_PATH];
+
+    memset(&im, 0, sizeof(im));
+    im.SizeOfStruct = sizeof(im);
+
+    image_len = wcslen(imagename);
+
+    ret = SymGetModuleInfoW64(aggregation->proc, base, &im);
+    if (ret)
+        ok(aggregation->count_exe && image_len >= 4 && !wcscmp(imagename + image_len - 4, L".exe"),
+           "%ls shouldn't already be loaded\n", imagename);
+    else
+    {
+        ok(!ret, "Module %ls shouldn't be loaded\n", imagename);
+        ret = SymLoadModuleExW(aggregation->proc, NULL, imagename, NULL, base, sz, NULL, 0);
+        ok(ret || broken(GetLastError() == ERROR_SUCCESS) /* Win10/64 v1607 return this on bcryptPrimitives.DLL */,
+           "SymLoadModuleExW failed on %ls: %lu\n", imagename, GetLastError());
+        ret = SymGetModuleInfoW64(aggregation->proc, base, &im);
+        ok(ret, "SymGetModuleInfoW64 failed: %lu\n", GetLastError());
+    }
+
+    switch (im.MachineType)
+    {
+    case IMAGE_FILE_MACHINE_UNKNOWN:
+        break;
+    case IMAGE_FILE_MACHINE_I386:
+    case IMAGE_FILE_MACHINE_ARM:
+    case IMAGE_FILE_MACHINE_ARMNT:
+        aggregation->count_32bit++;
+        break;
+    case IMAGE_FILE_MACHINE_AMD64:
+    case IMAGE_FILE_MACHINE_ARM64:
+        aggregation->count_64bit++;
+        break;
+    default:
+        ok(0, "Unsupported machine %lx\n", im.MachineType);
+        break;
+    }
+    if (image_len >= 4 && !wcsicmp(imagename + image_len - 4, L".exe"))
+        aggregation->count_exe++;
+    if (!wcsicmp(im.ModuleName, L"ntdll"))
+        aggregation->count_ntdll++;
+    if (GetSystemDirectoryW(buffer, ARRAY_SIZE(buffer)) &&
+        !wcsnicmp(imagename, buffer, wcslen(buffer)))
+        aggregation->count_systemdir++;
+    if (is_win64 && IsWow64Process(aggregation->proc, &wow64) && wow64 &&
+        GetSystemWow64DirectoryW(buffer, ARRAY_SIZE(buffer)) &&
+        !wcsnicmp(imagename, buffer, wcslen(buffer)))
+        aggregation->count_wowdir++;
+
+    return TRUE;
+}
+
+
+static void test_loaded_modules(void)
+{
+    BOOL ret;
+    char buffer[200];
+    PROCESS_INFORMATION pi = {0};
+    STARTUPINFOA si = {0};
+    struct loaded_module_aggregation aggregation = {0};
+
+    ret = GetSystemDirectoryA(buffer, sizeof(buffer));
+    ok(ret, "got error %lu\n", GetLastError());
+    strcat(buffer, "\\notepad.exe");
+
+    /* testing with child process of different machines */
+    ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+    ok(ret, "CreateProcess failed: %lu\n", GetLastError());
+
+    ret = WaitForInputIdle(pi.hProcess, 5000);
+    ok(!ret, "wait timed out\n");
+
+    ret = SymInitialize(pi.hProcess, NULL, FALSE);
+    ok(ret, "SymInitialize failed: %lu\n", GetLastError());
+    memset(&aggregation, 0, sizeof(aggregation));
+    aggregation.proc = pi.hProcess;
+
+    ret = EnumerateLoadedModulesW64(pi.hProcess, aggregate_cb, &aggregation);
+    ok(ret, "EnumerateLoadedModulesW64 failed: %lu\n", GetLastError());
+
+    if (is_win64)
+    {
+        ok(!aggregation.count_32bit && aggregation.count_64bit, "Wrong bitness aggregation count %u %u\n",
+           aggregation.count_32bit, aggregation.count_64bit);
+        ok(aggregation.count_exe == 1 && aggregation.count_ntdll == 1, "Wrong kind aggregation count %u %u\n",
+           aggregation.count_exe, aggregation.count_ntdll);
+        ok(aggregation.count_systemdir > 2 && !aggregation.count_wowdir, "Wrong directory aggregation count %u %u\n",
+           aggregation.count_systemdir, aggregation.count_wowdir);
+    }
+    else
+    {
+        BOOL is_wow64;
+        ret = IsWow64Process(pi.hProcess, &is_wow64);
+        ok(ret, "IsWow64Process failed: %lu\n", GetLastError());
+
+        ok(aggregation.count_32bit && !aggregation.count_64bit, "Wrong bitness aggregation count %u %u\n",
+           aggregation.count_32bit, aggregation.count_64bit);
+        ok(aggregation.count_exe == 1 && aggregation.count_ntdll == 1, "Wrong kind aggregation count %u %u\n",
+           aggregation.count_exe, aggregation.count_ntdll);
+        todo_wine_if(is_wow64)
+        ok(aggregation.count_systemdir > 2 && !aggregation.count_wowdir, "Wrong directory aggregation count %u %u\n",
+           aggregation.count_systemdir, aggregation.count_wowdir);
+    }
+
+    SymCleanup(pi.hProcess);
+    TerminateProcess(pi.hProcess, 0);
+
+    if (is_win64)
+    {
+        ret = GetSystemWow64DirectoryA(buffer, sizeof(buffer));
+        ok(ret, "got error %lu\n", GetLastError());
+        strcat(buffer, "\\notepad.exe");
+
+        SymSetOptions(SymGetOptions() & ~SYMOPT_INCLUDE_32BIT_MODULES);
+
+        ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        if (ret)
+        {
+            ret = WaitForInputIdle(pi.hProcess, 5000);
+            ok(!ret, "wait timed out\n");
+
+            ret = SymInitialize(pi.hProcess, NULL, FALSE);
+            ok(ret, "SymInitialize failed: %lu\n", GetLastError());
+            memset(&aggregation, 0, sizeof(aggregation));
+            aggregation.proc = pi.hProcess;
+
+            ret = EnumerateLoadedModulesW64(pi.hProcess, aggregate_cb, &aggregation);
+            ok(ret, "EnumerateLoadedModulesW64 failed: %lu\n", GetLastError());
+
+            todo_wine
+            ok(aggregation.count_32bit == 1 && aggregation.count_64bit, "Wrong bitness aggregation count %u %u\n",
+               aggregation.count_32bit, aggregation.count_64bit);
+            ok(aggregation.count_exe == 1 && aggregation.count_ntdll == 1, "Wrong kind aggregation count %u %u\n",
+               aggregation.count_exe, aggregation.count_ntdll);
+            todo_wine
+            ok(aggregation.count_systemdir > 2 && aggregation.count_64bit == aggregation.count_systemdir && aggregation.count_wowdir == 1,
+               "Wrong directory aggregation count %u %u\n",
+               aggregation.count_systemdir, aggregation.count_wowdir);
+
+            SymCleanup(pi.hProcess);
+            TerminateProcess(pi.hProcess, 0);
+        }
+        else
+        {
+            if (GetLastError() == ERROR_FILE_NOT_FOUND)
+                skip("Skip wow64 test on non compatible platform\n");
+            else
+                ok(ret, "CreateProcess failed: %lu\n", GetLastError());
+        }
+
+        SymSetOptions(SymGetOptions() | SYMOPT_INCLUDE_32BIT_MODULES);
+
+        ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        if (ret)
+        {
+            struct loaded_module_aggregation aggregation2 = {0};
+
+            ret = WaitForInputIdle(pi.hProcess, 5000);
+            ok(!ret, "wait timed out\n");
+
+            ret = SymInitialize(pi.hProcess, NULL, FALSE);
+            ok(ret, "SymInitialize failed: %lu\n", GetLastError());
+            memset(&aggregation2, 0, sizeof(aggregation2));
+            aggregation2.proc = pi.hProcess;
+            ret = EnumerateLoadedModulesW64(pi.hProcess, aggregate_cb, &aggregation2);
+            ok(ret, "EnumerateLoadedModulesW64 failed: %lu\n", GetLastError());
+
+            ok(aggregation2.count_32bit && aggregation2.count_64bit, "Wrong bitness aggregation count %u %u\n",
+               aggregation2.count_32bit, aggregation2.count_64bit);
+            todo_wine
+            ok(aggregation2.count_exe == 2 && aggregation2.count_ntdll == 2, "Wrong kind aggregation count %u %u\n",
+               aggregation2.count_exe, aggregation2.count_ntdll);
+            todo_wine
+            ok(aggregation2.count_systemdir > 2 && aggregation2.count_64bit == aggregation2.count_systemdir && aggregation2.count_wowdir > 2,
+               "Wrong directory aggregation count %u %u\n",
+               aggregation2.count_systemdir, aggregation2.count_wowdir);
+
+            SymCleanup(pi.hProcess);
+            TerminateProcess(pi.hProcess, 0);
+        }
+        else
+        {
+            if (GetLastError() == ERROR_FILE_NOT_FOUND)
+                skip("Skip wow64 test on non compatible platform\n");
+            else
+                ok(ret, "CreateProcess failed: %lu\n", GetLastError());
+        }
+    }
+}
+
 START_TEST(dbghelp)
 {
     BOOL ret;
@@ -206,4 +729,10 @@ START_TEST(dbghelp)
 
     ret = SymCleanup(GetCurrentProcess());
     ok(ret, "got error %lu\n", GetLastError());
+
+    if (test_modules())
+    {
+        test_modules_overlap();
+        test_loaded_modules();
+    }
 }
diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index fd4c5bd4862..7d9d25e62c7 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -73,7 +73,7 @@ static struct enum_device_entry
         "WINE Direct3D7 RGB Software Emulation using WineD3D",
         "Wine D3D7 RGB",
         &IID_IDirect3DRGBDevice,
-        D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX,
+        D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION,
     },
 };
 
@@ -3883,8 +3883,8 @@ static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBA
         /* RGB, RAMP and MMX devices cannot report HAL hardware flags */
         hal_desc.dwFlags = 0;
         /* RGB, REF, RAMP and MMX devices don't report hardware transform and lighting capability */
-        hal_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX);
-        hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX);
+        hal_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
+        hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
 
         hr = callback((GUID *)&IID_IDirect3DRGBDevice, reference_description,
                 device_name, &hal_desc, &hel_desc, context);
diff --git a/dlls/ddraw/tests/ddraw1.c b/dlls/ddraw/tests/ddraw1.c
index 3d81c590a3a..71c60db3804 100644
--- a/dlls/ddraw/tests/ddraw1.c
+++ b/dlls/ddraw/tests/ddraw1.c
@@ -5869,38 +5869,29 @@ static void test_surface_attachment(void)
 
 static void test_pixel_format(void)
 {
-    HWND window, window2 = NULL;
-    HDC hdc, hdc2 = NULL;
+    HWND window, window2, window3;
     HMODULE gl = NULL;
     int format, test_format;
     PIXELFORMATDESCRIPTOR pfd;
     IDirectDraw *ddraw = NULL;
     IDirectDrawClipper *clipper = NULL;
+    HDC hdc, hdc2, hdc3;
     DDSURFACEDESC ddsd;
     IDirectDrawSurface *primary = NULL, *offscreen;
+    ULONG refcount;
     DDBLTFX fx;
     HRESULT hr;
+    BOOL ret;
 
-    window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
-    if (!window)
-    {
-        skip("Failed to create window\n");
-        return;
-    }
-
-    window2 = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
+    window = create_window();
+    ok(!!window, "Failed to create window.\n");
+    window2 = create_window();
+    ok(!!window2, "Failed to create window.\n");
 
     hdc = GetDC(window);
-    if (!hdc)
-    {
-        skip("Failed to get DC\n");
-        goto cleanup;
-    }
-
-    if (window2)
-        hdc2 = GetDC(window2);
+    ok(!!hdc, "Failed to get DC.\n");
+    hdc2 = GetDC(window2);
+    ok(!!hdc2, "Failed to get DC.\n");
 
     gl = LoadLibraryA("opengl32.dll");
     ok(!!gl, "failed to load opengl32.dll; SetPixelFormat()/GetPixelFormat() may not work right\n");
@@ -5927,14 +5918,10 @@ static void test_pixel_format(void)
         goto cleanup;
     }
 
-    if (!hdc2 || !SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
+    if (!SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
     {
         skip("failed to set pixel format on second window\n");
-        if (hdc2)
-        {
-            ReleaseDC(window2, hdc2);
-            hdc2 = NULL;
-        }
+        goto cleanup;
     }
 
     ddraw = create_ddraw();
@@ -5944,28 +5931,20 @@ static void test_pixel_format(void)
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirectDraw_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
-    if (FAILED(hr))
-    {
-        skip("Failed to set cooperative level, hr %#lx.\n", hr);
-        goto cleanup;
-    }
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        hr = IDirectDraw_CreateClipper(ddraw, 0, &clipper, NULL);
-        ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
-        hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
-        ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDraw_CreateClipper(ddraw, 0, &clipper, NULL);
+    ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
+    hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
+    ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -5977,24 +5956,16 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
-
-    if (clipper)
-    {
-        hr = IDirectDrawSurface_SetClipper(primary, clipper);
-        ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDrawSurface_SetClipper(primary, clipper);
+    ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -6017,24 +5988,82 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    IDirectDrawSurface_Release(offscreen);
+    IDirectDrawSurface_Release(primary);
+    refcount = IDirectDrawClipper_Release(clipper);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+    refcount = IDirectDraw_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    /* Test that creating a device doesn't set a pixel format on a window which
+     * never had one. */
+
+    window3 = create_window();
+    hdc3 = GetDC(window3);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ddraw = create_ddraw();
+    ok(!!ddraw, "Failed to create a ddraw object.\n");
+    hr = IDirectDraw_SetCooperativeLevel(ddraw, window3, DDSCL_NORMAL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
+    hr = IDirectDraw_CreateSurface(ddraw, &ddsd, &primary, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
+    ddsd.dwWidth = ddsd.dwHeight = 64;
+    hr = IDirectDraw_CreateSurface(ddraw, &ddsd, &offscreen, NULL);
+    ok(SUCCEEDED(hr), "Failed to create surface, hr %#lx.\n",hr);
+
+    memset(&fx, 0, sizeof(fx));
+    fx.dwSize = sizeof(fx);
+    hr = IDirectDrawSurface_Blt(offscreen, NULL, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &fx);
+    ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#lx.\n", hr);
+
+    hr = IDirectDrawSurface_Blt(primary, NULL, offscreen, NULL, DDBLT_WAIT, NULL);
+    ok(SUCCEEDED(hr), "Failed to blit to primary surface, hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
 
     IDirectDrawSurface_Release(offscreen);
+    IDirectDrawSurface_Release(primary);
+    refcount = IDirectDraw_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ret = SetPixelFormat(hdc3, format, &pfd);
+    ok(ret, "Failed to set pixel format %d.\n", format);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(test_format == format, "Expected pixel format %d, got %d.\n", format, test_format);
+
+    ReleaseDC(window3, hdc3);
+    DestroyWindow(window3);
 
 cleanup:
-    if (primary) IDirectDrawSurface_Release(primary);
-    if (clipper) IDirectDrawClipper_Release(clipper);
-    if (ddraw) IDirectDraw_Release(ddraw);
-    if (gl) FreeLibrary(gl);
-    if (hdc) ReleaseDC(window, hdc);
-    if (hdc2) ReleaseDC(window2, hdc2);
+    FreeLibrary(gl);
+    ReleaseDC(window2, hdc2);
+    ReleaseDC(window, hdc);
+    DestroyWindow(window2);
     DestroyWindow(window);
-    if (window2) DestroyWindow(window2);
 }
 
 static void test_create_surface_pitch(void)
@@ -15215,6 +15244,10 @@ static HRESULT WINAPI test_enum_devices_caps_callback(GUID *guid, char *device_d
            "RGB Device hal device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
         ok((hel->dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX) == 0,
            "RGB Device hel device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
+        ok((hal->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device hal device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
+        ok((hel->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device hel device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
     }
     else if(IsEqualGUID(&IID_IDirect3DHALDevice, guid))
     {
diff --git a/dlls/ddraw/tests/ddraw2.c b/dlls/ddraw/tests/ddraw2.c
index f4079b1e5e5..eddf846e54b 100644
--- a/dlls/ddraw/tests/ddraw2.c
+++ b/dlls/ddraw/tests/ddraw2.c
@@ -6966,38 +6966,29 @@ static void test_surface_attachment(void)
 
 static void test_pixel_format(void)
 {
-    HWND window, window2 = NULL;
-    HDC hdc, hdc2 = NULL;
+    HWND window, window2, window3;
     HMODULE gl = NULL;
     int format, test_format;
     PIXELFORMATDESCRIPTOR pfd;
     IDirectDraw2 *ddraw = NULL;
     IDirectDrawClipper *clipper = NULL;
+    HDC hdc, hdc2, hdc3;
     DDSURFACEDESC ddsd;
     IDirectDrawSurface *primary = NULL, *offscreen;
+    ULONG refcount;
     DDBLTFX fx;
     HRESULT hr;
+    BOOL ret;
 
-    window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
-    if (!window)
-    {
-        skip("Failed to create window\n");
-        return;
-    }
-
-    window2 = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
+    window = create_window();
+    ok(!!window, "Failed to create window.\n");
+    window2 = create_window();
+    ok(!!window2, "Failed to create window.\n");
 
     hdc = GetDC(window);
-    if (!hdc)
-    {
-        skip("Failed to get DC\n");
-        goto cleanup;
-    }
-
-    if (window2)
-        hdc2 = GetDC(window2);
+    ok(!!hdc, "Failed to get DC.\n");
+    hdc2 = GetDC(window2);
+    ok(!!hdc2, "Failed to get DC.\n");
 
     gl = LoadLibraryA("opengl32.dll");
     ok(!!gl, "failed to load opengl32.dll; SetPixelFormat()/GetPixelFormat() may not work right\n");
@@ -7024,14 +7015,10 @@ static void test_pixel_format(void)
         goto cleanup;
     }
 
-    if (!hdc2 || !SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
+    if (!SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
     {
         skip("failed to set pixel format on second window\n");
-        if (hdc2)
-        {
-            ReleaseDC(window2, hdc2);
-            hdc2 = NULL;
-        }
+        goto cleanup;
     }
 
     ddraw = create_ddraw();
@@ -7041,28 +7028,20 @@ static void test_pixel_format(void)
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirectDraw2_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
-    if (FAILED(hr))
-    {
-        skip("Failed to set cooperative level, hr %#lx.\n", hr);
-        goto cleanup;
-    }
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        hr = IDirectDraw2_CreateClipper(ddraw, 0, &clipper, NULL);
-        ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
-        hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
-        ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDraw2_CreateClipper(ddraw, 0, &clipper, NULL);
+    ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
+    hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
+    ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -7074,24 +7053,16 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
-
-    if (clipper)
-    {
-        hr = IDirectDrawSurface_SetClipper(primary, clipper);
-        ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDrawSurface_SetClipper(primary, clipper);
+    ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -7114,24 +7085,82 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    IDirectDrawSurface_Release(offscreen);
+    IDirectDrawSurface_Release(primary);
+    refcount = IDirectDrawClipper_Release(clipper);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+    refcount = IDirectDraw2_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    /* Test that creating a device doesn't set a pixel format on a window which
+     * never had one. */
+
+    window3 = create_window();
+    hdc3 = GetDC(window3);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ddraw = create_ddraw();
+    ok(!!ddraw, "Failed to create a ddraw object.\n");
+    hr = IDirectDraw2_SetCooperativeLevel(ddraw, window3, DDSCL_NORMAL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
+    hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &primary, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
+    ddsd.dwWidth = ddsd.dwHeight = 64;
+    hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &offscreen, NULL);
+    ok(SUCCEEDED(hr), "Failed to create surface, hr %#lx.\n",hr);
+
+    memset(&fx, 0, sizeof(fx));
+    fx.dwSize = sizeof(fx);
+    hr = IDirectDrawSurface_Blt(offscreen, NULL, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &fx);
+    ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#lx.\n", hr);
+
+    hr = IDirectDrawSurface_Blt(primary, NULL, offscreen, NULL, DDBLT_WAIT, NULL);
+    ok(SUCCEEDED(hr), "Failed to blit to primary surface, hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
 
     IDirectDrawSurface_Release(offscreen);
+    IDirectDrawSurface_Release(primary);
+    refcount = IDirectDraw2_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ret = SetPixelFormat(hdc3, format, &pfd);
+    ok(ret, "Failed to set pixel format %d.\n", format);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(test_format == format, "Expected pixel format %d, got %d.\n", format, test_format);
+
+    ReleaseDC(window3, hdc3);
+    DestroyWindow(window3);
 
 cleanup:
-    if (primary) IDirectDrawSurface_Release(primary);
-    if (clipper) IDirectDrawClipper_Release(clipper);
-    if (ddraw) IDirectDraw2_Release(ddraw);
-    if (gl) FreeLibrary(gl);
-    if (hdc) ReleaseDC(window, hdc);
-    if (hdc2) ReleaseDC(window2, hdc2);
+    FreeLibrary(gl);
+    ReleaseDC(window2, hdc2);
+    ReleaseDC(window, hdc);
+    DestroyWindow(window2);
     DestroyWindow(window);
-    if (window2) DestroyWindow(window2);
 }
 
 static void test_create_surface_pitch(void)
@@ -16161,6 +16190,10 @@ static HRESULT WINAPI test_enum_devices_caps_callback(GUID *guid, char *device_d
            "RGB Device hal device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
         ok((hel->dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX) == 0,
            "RGB Device hel device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
+        ok((hal->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device hal device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
+        ok((hel->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device hel device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
     }
     else if(IsEqualGUID(&IID_IDirect3DHALDevice, guid))
     {
diff --git a/dlls/ddraw/tests/ddraw4.c b/dlls/ddraw/tests/ddraw4.c
index ff38483faf9..a658de37b94 100644
--- a/dlls/ddraw/tests/ddraw4.c
+++ b/dlls/ddraw/tests/ddraw4.c
@@ -8849,38 +8849,29 @@ static void test_private_data(void)
 
 static void test_pixel_format(void)
 {
-    HWND window, window2 = NULL;
-    HDC hdc, hdc2 = NULL;
+    HWND window, window2, window3;
     HMODULE gl = NULL;
     int format, test_format;
     PIXELFORMATDESCRIPTOR pfd;
     IDirectDraw4 *ddraw = NULL;
     IDirectDrawClipper *clipper = NULL;
     DDSURFACEDESC2 ddsd;
+    HDC hdc, hdc2, hdc3;
     IDirectDrawSurface4 *primary = NULL, *offscreen;
+    ULONG refcount;
     DDBLTFX fx;
     HRESULT hr;
+    BOOL ret;
 
-    window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
-    if (!window)
-    {
-        skip("Failed to create window\n");
-        return;
-    }
-
-    window2 = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
+    window = create_window();
+    ok(!!window, "Failed to create window.\n");
+    window2 = create_window();
+    ok(!!window2, "Failed to create window.\n");
 
     hdc = GetDC(window);
-    if (!hdc)
-    {
-        skip("Failed to get DC\n");
-        goto cleanup;
-    }
-
-    if (window2)
-        hdc2 = GetDC(window2);
+    ok(!!hdc, "Failed to get DC.\n");
+    hdc2 = GetDC(window2);
+    ok(!!hdc2, "Failed to get DC.\n");
 
     gl = LoadLibraryA("opengl32.dll");
     ok(!!gl, "failed to load opengl32.dll; SetPixelFormat()/GetPixelFormat() may not work right\n");
@@ -8907,14 +8898,10 @@ static void test_pixel_format(void)
         goto cleanup;
     }
 
-    if (!hdc2 || !SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
+    if (!SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
     {
         skip("failed to set pixel format on second window\n");
-        if (hdc2)
-        {
-            ReleaseDC(window2, hdc2);
-            hdc2 = NULL;
-        }
+        goto cleanup;
     }
 
     ddraw = create_ddraw();
@@ -8924,28 +8911,20 @@ static void test_pixel_format(void)
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirectDraw4_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
-    if (FAILED(hr))
-    {
-        skip("Failed to set cooperative level, hr %#lx.\n", hr);
-        goto cleanup;
-    }
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        hr = IDirectDraw4_CreateClipper(ddraw, 0, &clipper, NULL);
-        ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
-        hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
-        ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDraw4_CreateClipper(ddraw, 0, &clipper, NULL);
+    ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
+    hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
+    ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -8957,24 +8936,16 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
-
-    if (clipper)
-    {
-        hr = IDirectDrawSurface4_SetClipper(primary, clipper);
-        ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDrawSurface4_SetClipper(primary, clipper);
+    ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -8997,24 +8968,82 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    IDirectDrawSurface4_Release(offscreen);
+    IDirectDrawSurface4_Release(primary);
+    refcount = IDirectDrawClipper_Release(clipper);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+    refcount = IDirectDraw4_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    /* Test that creating a device doesn't set a pixel format on a window which
+     * never had one. */
+
+    window3 = create_window();
+    hdc3 = GetDC(window3);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ddraw = create_ddraw();
+    ok(!!ddraw, "Failed to create a ddraw object.\n");
+    hr = IDirectDraw4_SetCooperativeLevel(ddraw, window3, DDSCL_NORMAL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
+    hr = IDirectDraw4_CreateSurface(ddraw, &ddsd, &primary, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
+    ddsd.dwWidth = ddsd.dwHeight = 64;
+    hr = IDirectDraw4_CreateSurface(ddraw, &ddsd, &offscreen, NULL);
+    ok(SUCCEEDED(hr), "Failed to create surface, hr %#lx.\n",hr);
+
+    memset(&fx, 0, sizeof(fx));
+    fx.dwSize = sizeof(fx);
+    hr = IDirectDrawSurface4_Blt(offscreen, NULL, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &fx);
+    ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#lx.\n", hr);
+
+    hr = IDirectDrawSurface4_Blt(primary, NULL, offscreen, NULL, DDBLT_WAIT, NULL);
+    ok(SUCCEEDED(hr), "Failed to blit to primary surface, hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
 
     IDirectDrawSurface4_Release(offscreen);
+    IDirectDrawSurface4_Release(primary);
+    refcount = IDirectDraw4_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ret = SetPixelFormat(hdc3, format, &pfd);
+    ok(ret, "Failed to set pixel format %d.\n", format);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(test_format == format, "Expected pixel format %d, got %d.\n", format, test_format);
+
+    ReleaseDC(window3, hdc3);
+    DestroyWindow(window3);
 
 cleanup:
-    if (primary) IDirectDrawSurface4_Release(primary);
-    if (clipper) IDirectDrawClipper_Release(clipper);
-    if (ddraw) IDirectDraw4_Release(ddraw);
-    if (gl) FreeLibrary(gl);
-    if (hdc) ReleaseDC(window, hdc);
-    if (hdc2) ReleaseDC(window2, hdc2);
+    FreeLibrary(gl);
+    ReleaseDC(window2, hdc2);
+    ReleaseDC(window, hdc);
+    DestroyWindow(window2);
     DestroyWindow(window);
-    if (window2) DestroyWindow(window2);
 }
 
 static void test_create_surface_pitch(void)
@@ -19230,6 +19259,10 @@ static HRESULT WINAPI test_enum_devices_caps_callback(GUID *guid, char *device_d
            "RGB Device hal device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
         ok((hel->dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX) == 0,
            "RGB Device hel device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
+        ok((hal->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device hal device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
+        ok((hel->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device hel device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
     }
     else if(IsEqualGUID(&IID_IDirect3DHALDevice, guid))
     {
diff --git a/dlls/ddraw/tests/ddraw7.c b/dlls/ddraw/tests/ddraw7.c
index 8631f824edd..a1c791a9116 100644
--- a/dlls/ddraw/tests/ddraw7.c
+++ b/dlls/ddraw/tests/ddraw7.c
@@ -8689,38 +8689,29 @@ static void test_private_data(void)
 
 static void test_pixel_format(void)
 {
-    HWND window, window2 = NULL;
-    HDC hdc, hdc2 = NULL;
+    HWND window, window2, window3;
     HMODULE gl = NULL;
     int format, test_format;
     PIXELFORMATDESCRIPTOR pfd;
     IDirectDraw7 *ddraw = NULL;
     IDirectDrawClipper *clipper = NULL;
     DDSURFACEDESC2 ddsd;
+    HDC hdc, hdc2, hdc3;
     IDirectDrawSurface7 *primary = NULL, *offscreen;
+    ULONG refcount;
     DDBLTFX fx;
     HRESULT hr;
+    BOOL ret;
 
-    window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
-    if (!window)
-    {
-        skip("Failed to create window\n");
-        return;
-    }
-
-    window2 = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-            100, 100, 160, 160, NULL, NULL, NULL, NULL);
+    window = create_window();
+    ok(!!window, "Failed to create window.\n");
+    window2 = create_window();
+    ok(!!window2, "Failed to create window.\n");
 
     hdc = GetDC(window);
-    if (!hdc)
-    {
-        skip("Failed to get DC\n");
-        goto cleanup;
-    }
-
-    if (window2)
-        hdc2 = GetDC(window2);
+    ok(!!hdc, "Failed to get DC.\n");
+    hdc2 = GetDC(window2);
+    ok(!!hdc2, "Failed to get DC.\n");
 
     gl = LoadLibraryA("opengl32.dll");
     ok(!!gl, "failed to load opengl32.dll; SetPixelFormat()/GetPixelFormat() may not work right\n");
@@ -8747,14 +8738,10 @@ static void test_pixel_format(void)
         goto cleanup;
     }
 
-    if (!hdc2 || !SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
+    if (!SetPixelFormat(hdc2, format, &pfd) || GetPixelFormat(hdc2) != format)
     {
         skip("failed to set pixel format on second window\n");
-        if (hdc2)
-        {
-            ReleaseDC(window2, hdc2);
-            hdc2 = NULL;
-        }
+        goto cleanup;
     }
 
     ddraw = create_ddraw();
@@ -8764,28 +8751,20 @@ static void test_pixel_format(void)
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirectDraw7_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
-    if (FAILED(hr))
-    {
-        skip("Failed to set cooperative level, hr %#lx.\n", hr);
-        goto cleanup;
-    }
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        hr = IDirectDraw7_CreateClipper(ddraw, 0, &clipper, NULL);
-        ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
-        hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
-        ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDraw7_CreateClipper(ddraw, 0, &clipper, NULL);
+    ok(SUCCEEDED(hr), "Failed to create clipper, hr %#lx.\n", hr);
+    hr = IDirectDrawClipper_SetHWnd(clipper, 0, window2);
+    ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -8797,24 +8776,16 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
-
-    if (clipper)
-    {
-        hr = IDirectDrawSurface7_SetClipper(primary, clipper);
-        ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
-
-        test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    hr = IDirectDrawSurface7_SetClipper(primary, clipper);
+    ok(SUCCEEDED(hr), "Failed to set clipper, hr %#lx.\n", hr);
 
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    test_format = GetPixelFormat(hdc);
+    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
@@ -8837,24 +8808,82 @@ static void test_pixel_format(void)
 
     test_format = GetPixelFormat(hdc);
     ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    test_format = GetPixelFormat(hdc2);
+    ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
 
-    if (hdc2)
-    {
-        test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
-    }
+    IDirectDrawSurface7_Release(offscreen);
+    IDirectDrawSurface7_Release(primary);
+    refcount = IDirectDrawClipper_Release(clipper);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+    refcount = IDirectDraw7_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    /* Test that creating a device doesn't set a pixel format on a window which
+     * never had one. */
+
+    window3 = create_window();
+    hdc3 = GetDC(window3);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ddraw = create_ddraw();
+    ok(!!ddraw, "Failed to create a ddraw object.\n");
+    hr = IDirectDraw7_SetCooperativeLevel(ddraw, window3, DDSCL_NORMAL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
+    hr = IDirectDraw7_CreateSurface(ddraw, &ddsd, &primary, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    memset(&ddsd, 0, sizeof(ddsd));
+    ddsd.dwSize = sizeof(ddsd);
+    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
+    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
+    ddsd.dwWidth = ddsd.dwHeight = 64;
+    hr = IDirectDraw7_CreateSurface(ddraw, &ddsd, &offscreen, NULL);
+    ok(SUCCEEDED(hr), "Failed to create surface, hr %#lx.\n",hr);
+
+    memset(&fx, 0, sizeof(fx));
+    fx.dwSize = sizeof(fx);
+    hr = IDirectDrawSurface7_Blt(offscreen, NULL, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &fx);
+    ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#lx.\n", hr);
+
+    hr = IDirectDrawSurface7_Blt(primary, NULL, offscreen, NULL, DDBLT_WAIT, NULL);
+    ok(SUCCEEDED(hr), "Failed to blit to primary surface, hr %#lx.\n", hr);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
 
     IDirectDrawSurface7_Release(offscreen);
+    IDirectDrawSurface7_Release(primary);
+    refcount = IDirectDraw7_Release(ddraw);
+    ok(!refcount, "Got unexpected refcount %lu.\n", refcount);
+
+    test_format = GetPixelFormat(hdc3);
+    todo_wine ok(!test_format, "Expected no format, got %d.\n", test_format);
+
+    ret = SetPixelFormat(hdc3, format, &pfd);
+    ok(ret, "Failed to set pixel format %d.\n", format);
+
+    test_format = GetPixelFormat(hdc3);
+    ok(test_format == format, "Expected pixel format %d, got %d.\n", format, test_format);
+
+    ReleaseDC(window3, hdc3);
+    DestroyWindow(window3);
 
 cleanup:
-    if (primary) IDirectDrawSurface7_Release(primary);
-    if (clipper) IDirectDrawClipper_Release(clipper);
-    if (ddraw) IDirectDraw7_Release(ddraw);
-    if (gl) FreeLibrary(gl);
-    if (hdc) ReleaseDC(window, hdc);
-    if (hdc2) ReleaseDC(window2, hdc2);
+    FreeLibrary(gl);
+    ReleaseDC(window2, hdc2);
+    ReleaseDC(window, hdc);
+    DestroyWindow(window2);
     DestroyWindow(window);
-    if (window2) DestroyWindow(window2);
 }
 
 static void test_create_surface_pitch(void)
@@ -19446,6 +19475,8 @@ static HRESULT WINAPI test_enum_devices_caps_callback(char *device_desc, char *d
            "RGB Device device caps has D3DDEVCAPS_HWTRANSFORMANDLIGHT set\n");
         ok((device_desc7->dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX) == 0,
            "RGB Device device caps has D3DDEVCAPS_DRAWPRIMITIVES2EX set\n");
+        ok((device_desc7->dwDevCaps & D3DDEVCAPS_HWRASTERIZATION) == 0,
+           "RGB Device device caps has D3DDEVCAPS_HWRASTERIZATION set\n");
     }
     else
     {
diff --git a/dlls/dinput/Makefile.in b/dlls/dinput/Makefile.in
index e1dd52cf67d..280ac49f9aa 100644
--- a/dlls/dinput/Makefile.in
+++ b/dlls/dinput/Makefile.in
@@ -8,6 +8,7 @@ C_SRCS = \
 	config.c \
 	data_formats.c \
 	device.c \
+	dinput.c \
 	dinput_main.c \
 	joystick_hid.c \
 	keyboard.c \
diff --git a/dlls/dinput/ansi.c b/dlls/dinput/ansi.c
index 99ec3c73327..a9e948c97a4 100644
--- a/dlls/dinput/ansi.c
+++ b/dlls/dinput/ansi.c
@@ -33,6 +33,8 @@
 
 #include "wine/debug.h"
 
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
 static struct dinput_device *impl_from_IDirectInputDevice8A( IDirectInputDevice8A *iface )
 {
     return CONTAINING_RECORD( iface, struct dinput_device, IDirectInputDevice8A_iface );
@@ -270,6 +272,7 @@ static HRESULT WINAPI dinput_device_a_QueryInterface( IDirectInputDevice8A *ifac
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, iid %s, out %p.\n", impl, debugstr_guid( iid ), out );
     return IDirectInputDevice8_QueryInterface( iface_w, iid, out );
 }
 
@@ -277,6 +280,7 @@ static ULONG WINAPI dinput_device_a_AddRef( IDirectInputDevice8A *iface_a )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInputDevice8_AddRef( iface_w );
 }
 
@@ -284,6 +288,7 @@ static ULONG WINAPI dinput_device_a_Release( IDirectInputDevice8A *iface_a )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInputDevice8_Release( iface_w );
 }
 
@@ -291,6 +296,7 @@ static HRESULT WINAPI dinput_device_a_GetCapabilities( IDirectInputDevice8A *ifa
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, caps %p.\n", impl, caps );
     return IDirectInputDevice8_GetCapabilities( iface_w, caps );
 }
 
@@ -316,6 +322,8 @@ static HRESULT WINAPI dinput_device_a_EnumObjects( IDirectInputDevice8A *iface_a
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
 
+    TRACE( "impl %p, callback %p, ref %p, flags %#lx.\n", impl, callback, ref, flags );
+
     if (!callback) return DIERR_INVALIDPARAM;
 
     return IDirectInputDevice8_EnumObjects( iface_w, enum_objects_wtoa_callback, &params, flags );
@@ -325,6 +333,7 @@ static HRESULT WINAPI dinput_device_a_GetProperty( IDirectInputDevice8A *iface_a
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, guid %s, header %p.\n", impl, debugstr_guid( guid ), header );
     return IDirectInputDevice8_GetProperty( iface_w, guid, header );
 }
 
@@ -332,6 +341,7 @@ static HRESULT WINAPI dinput_device_a_SetProperty( IDirectInputDevice8A *iface_a
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, guid %s, header %p.\n", impl, debugstr_guid( guid ), header );
     return IDirectInputDevice8_SetProperty( iface_w, guid, header );
 }
 
@@ -339,6 +349,7 @@ static HRESULT WINAPI dinput_device_a_Acquire( IDirectInputDevice8A *iface_a )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInputDevice8_Acquire( iface_w );
 }
 
@@ -346,6 +357,7 @@ static HRESULT WINAPI dinput_device_a_Unacquire( IDirectInputDevice8A *iface_a )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInputDevice8_Unacquire( iface_w );
 }
 
@@ -353,6 +365,7 @@ static HRESULT WINAPI dinput_device_a_GetDeviceState( IDirectInputDevice8A *ifac
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, count %#lx, data %p.\n", impl, count, data );
     return IDirectInputDevice8_GetDeviceState( iface_w, count, data );
 }
 
@@ -361,6 +374,7 @@ static HRESULT WINAPI dinput_device_a_GetDeviceData( IDirectInputDevice8A *iface
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, data_size %#lx, data %p, entries %p, flags %#lx.\n", impl, data_size, data, entries, flags );
     return IDirectInputDevice8_GetDeviceData( iface_w, data_size, data, entries, flags );
 }
 
@@ -368,6 +382,7 @@ static HRESULT WINAPI dinput_device_a_SetDataFormat( IDirectInputDevice8A *iface
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, format %p.\n", impl, format );
     return IDirectInputDevice8_SetDataFormat( iface_w, format );
 }
 
@@ -375,6 +390,7 @@ static HRESULT WINAPI dinput_device_a_SetEventNotification( IDirectInputDevice8A
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, event %p.\n", impl, event );
     return IDirectInputDevice8_SetEventNotification( iface_w, event );
 }
 
@@ -382,6 +398,7 @@ static HRESULT WINAPI dinput_device_a_SetCooperativeLevel( IDirectInputDevice8A
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, window %p, flags %#lx.\n", impl, window, flags );
     return IDirectInputDevice8_SetCooperativeLevel( iface_w, window, flags );
 }
 
@@ -393,6 +410,8 @@ static HRESULT WINAPI dinput_device_a_GetObjectInfo( IDirectInputDevice8A *iface
     DIDEVICEOBJECTINSTANCEW instance_w = {sizeof(instance_w)};
     HRESULT hr;
 
+    TRACE( "impl %p, instance_a %p, obj %#lx, how %#lx.\n", impl, instance_a, obj, how );
+
     if (!instance_a) return E_POINTER;
     if (instance_a->dwSize != sizeof(DIDEVICEOBJECTINSTANCEA) &&
         instance_a->dwSize != sizeof(DIDEVICEOBJECTINSTANCE_DX3A))
@@ -411,6 +430,8 @@ static HRESULT WINAPI dinput_device_a_GetDeviceInfo( IDirectInputDevice8A *iface
     DIDEVICEINSTANCEW instance_w = {sizeof(instance_w)};
     HRESULT hr;
 
+    TRACE( "impl %p, instance_a %p.\n", impl, instance_a );
+
     if (!instance_a) return E_POINTER;
     if (instance_a->dwSize != sizeof(DIDEVICEINSTANCEA) && instance_a->dwSize != sizeof(DIDEVICEINSTANCE_DX3A))
         return DIERR_INVALIDPARAM;
@@ -425,6 +446,7 @@ static HRESULT WINAPI dinput_device_a_RunControlPanel( IDirectInputDevice8A *ifa
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, owner %p, flags %#lx.\n", impl, owner, flags );
     return IDirectInputDevice8_RunControlPanel( iface_w, owner, flags );
 }
 
@@ -432,6 +454,7 @@ static HRESULT WINAPI dinput_device_a_Initialize( IDirectInputDevice8A *iface_a,
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, instance %p, version %#lx, guid %s.\n", impl, instance, version, debugstr_guid( guid ) );
     return IDirectInputDevice8_Initialize( iface_w, instance, version, guid );
 }
 
@@ -440,6 +463,7 @@ static HRESULT WINAPI dinput_device_a_CreateEffect( IDirectInputDevice8A *iface_
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, guid %s, effect %p, out %p, outer %p.\n", impl, debugstr_guid( guid ), effect, out, outer );
     return IDirectInputDevice8_CreateEffect( iface_w, guid, effect, out, outer );
 }
 
@@ -465,6 +489,8 @@ static HRESULT WINAPI dinput_device_a_EnumEffects( IDirectInputDevice8A *iface_a
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
 
+    TRACE( "impl %p, callback %p, ref %p, type %#lx.\n", impl, callback, ref, type );
+
     if (!callback) return DIERR_INVALIDPARAM;
 
     return IDirectInputDevice8_EnumEffects( iface_w, enum_effects_wtoa_callback, &params, type );
@@ -477,6 +503,8 @@ static HRESULT WINAPI dinput_device_a_GetEffectInfo( IDirectInputDevice8A *iface
     DIEFFECTINFOW info_w = {sizeof(info_w)};
     HRESULT hr;
 
+    TRACE( "impl %p, info_a %p, guid %s.\n", impl, info_a, debugstr_guid( guid ) );
+
     if (!info_a) return E_POINTER;
     if (info_a->dwSize != sizeof(DIEFFECTINFOA)) return DIERR_INVALIDPARAM;
 
@@ -490,6 +518,7 @@ static HRESULT WINAPI dinput_device_a_GetForceFeedbackState( IDirectInputDevice8
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, state %p.\n", impl, state );
     return IDirectInputDevice8_GetForceFeedbackState( iface_w, state );
 }
 
@@ -497,6 +526,7 @@ static HRESULT WINAPI dinput_device_a_SendForceFeedbackCommand( IDirectInputDevi
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, flags %#lx.\n", impl, flags );
     return IDirectInputDevice8_SendForceFeedbackCommand( iface_w, flags );
 }
 
@@ -505,6 +535,7 @@ static HRESULT WINAPI dinput_device_a_EnumCreatedEffectObjects( IDirectInputDevi
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, callback %p, ref %p, flags %#lx.\n", impl, callback, ref, flags );
     return IDirectInputDevice8_EnumCreatedEffectObjects( iface_w, callback, ref, flags );
 }
 
@@ -512,6 +543,7 @@ static HRESULT WINAPI dinput_device_a_Escape( IDirectInputDevice8A *iface_a, DIE
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, escape %p.\n", impl, escape );
     return IDirectInputDevice8_Escape( iface_w, escape );
 }
 
@@ -519,6 +551,7 @@ static HRESULT WINAPI dinput_device_a_Poll( IDirectInputDevice8A *iface_a )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInputDevice8_Poll( iface_w );
 }
 
@@ -527,6 +560,7 @@ static HRESULT WINAPI dinput_device_a_SendDeviceData( IDirectInputDevice8A *ifac
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8A( iface_a );
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
+    TRACE( "impl %p, count %#lx, data %p, inout %p, flags %#lx.\n", impl, count, data, inout, flags );
     return IDirectInputDevice8_SendDeviceData( iface_w, count, data, inout, flags );
 }
 
@@ -537,6 +571,9 @@ static HRESULT WINAPI dinput_device_a_EnumEffectsInFile( IDirectInputDevice8A *i
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
     WCHAR buffer[MAX_PATH], *filename_w = buffer;
 
+    TRACE( "impl %p, filename_a %s, callback %p, ref %p, flags %#lx.\n", impl,
+           debugstr_a(filename_a), callback, ref, flags );
+
     if (!filename_a) filename_w = NULL;
     else MultiByteToWideChar( CP_ACP, 0, filename_a, -1, buffer, MAX_PATH );
 
@@ -550,6 +587,9 @@ static HRESULT WINAPI dinput_device_a_WriteEffectToFile( IDirectInputDevice8A *i
     IDirectInputDevice8W *iface_w = IDirectInputDevice8W_from_impl( impl );
     WCHAR buffer[MAX_PATH], *filename_w = buffer;
 
+    TRACE( "impl %p, filename_a %s, entries %#lx, file_effect %p, flags %#lx.\n", impl,
+           debugstr_a(filename_a), entries, file_effect, flags );
+
     if (!filename_a) filename_w = NULL;
     else MultiByteToWideChar( CP_ACP, 0, filename_a, -1, buffer, MAX_PATH );
 
@@ -565,6 +605,8 @@ static HRESULT WINAPI dinput_device_a_BuildActionMap( IDirectInputDevice8A *ifac
     HRESULT hr;
     WCHAR *username_w;
 
+    TRACE( "impl %p, format_a %p, username_a %s, flags %#lx.\n", impl, format_a, debugstr_a(username_a), flags );
+
     if (!format_a) return E_POINTER;
     if (format_a->dwSize != sizeof(DIACTIONFORMATA)) return DIERR_INVALIDPARAM;
     if (format_a->dwActionSize != sizeof(DIACTIONA)) return DIERR_INVALIDPARAM;
@@ -594,6 +636,8 @@ static HRESULT WINAPI dinput_device_a_SetActionMap( IDirectInputDevice8A *iface_
     HRESULT hr;
     WCHAR *username_w;
 
+    TRACE( "impl %p, format_a %p, username_a %s, flags %#lx.\n", impl, format_a, debugstr_a(username_a), flags );
+
     if (!format_a) return E_POINTER;
     if (format_a->dwSize != sizeof(DIACTIONFORMATA)) return DIERR_INVALIDPARAM;
     if (format_a->dwActionSize != sizeof(DIACTIONA)) return DIERR_INVALIDPARAM;
@@ -621,6 +665,8 @@ static HRESULT WINAPI dinput_device_a_GetImageInfo( IDirectInputDevice8A *iface_
     DIDEVICEIMAGEINFOHEADERW header_w = {sizeof(header_w), sizeof(DIDEVICEIMAGEINFOW)};
     HRESULT hr;
 
+    TRACE( "impl %p, header_a %p.\n", impl, header_a );
+
     if (!header_a) return E_POINTER;
     if (header_a->dwSize != sizeof(DIDEVICEIMAGEINFOHEADERA)) return DIERR_INVALIDPARAM;
     if (header_a->dwSizeImageInfo != sizeof(DIDEVICEIMAGEINFOA)) return DIERR_INVALIDPARAM;
@@ -680,6 +726,7 @@ static HRESULT WINAPI dinput8_a_QueryInterface( IDirectInput8A *iface_a, REFIID
 {
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
+    TRACE( "impl %p, iid %s, out %p.\n", impl, debugstr_guid( iid ), out );
     return IDirectInput8_QueryInterface( iface_w, iid, out );
 }
 
@@ -687,6 +734,7 @@ static ULONG WINAPI dinput8_a_AddRef( IDirectInput8A *iface_a )
 {
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInput8_AddRef( iface_w );
 }
 
@@ -694,6 +742,7 @@ static ULONG WINAPI dinput8_a_Release( IDirectInput8A *iface_a )
 {
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInput8_Release( iface_w );
 }
 
@@ -704,6 +753,8 @@ static HRESULT WINAPI dinput8_a_CreateDevice( IDirectInput8A *iface_a, REFGUID g
     IDirectInputDevice8W *outw;
     HRESULT hr;
 
+    TRACE( "impl %p, guid %s, out %p, outer %p.\n", impl, debugstr_guid( guid ), out, outer );
+
     if (!out) return E_POINTER;
 
     hr = IDirectInput8_CreateDevice( iface_w, guid, &outw, outer );
@@ -733,6 +784,8 @@ static HRESULT WINAPI dinput8_a_EnumDevices( IDirectInput8A *iface_a, DWORD type
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
 
+    TRACE( "impl %p, type %#lx, callback %p, ref %p, flags %#lx.\n", impl, type, callback, ref, flags );
+
     if (!callback) return DIERR_INVALIDPARAM;
 
     return IDirectInput8_EnumDevices( iface_w, type, enum_devices_wtoa_callback, &params, flags );
@@ -742,6 +795,7 @@ static HRESULT WINAPI dinput8_a_GetDeviceStatus( IDirectInput8A *iface_a, REFGUI
 {
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
+    TRACE( "impl %p, instance_guid %s.\n", impl, debugstr_guid( instance_guid ) );
     return IDirectInput8_GetDeviceStatus( iface_w, instance_guid );
 }
 
@@ -749,6 +803,7 @@ static HRESULT WINAPI dinput8_a_RunControlPanel( IDirectInput8A *iface_a, HWND o
 {
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
+    TRACE( "impl %p, owner %p, flags %#lx.\n", impl, owner, flags );
     return IDirectInput8_RunControlPanel( iface_w, owner, flags );
 }
 
@@ -756,6 +811,7 @@ static HRESULT WINAPI dinput8_a_Initialize( IDirectInput8A *iface_a, HINSTANCE i
 {
     struct dinput *impl = impl_from_IDirectInput8A( iface_a );
     IDirectInput8W *iface_w = IDirectInput8W_from_impl( impl );
+    TRACE( "impl %p, instance %p, version %#lx.\n", impl, instance, version );
     return IDirectInput8_Initialize( iface_w, instance, version );
 }
 
@@ -766,6 +822,9 @@ static HRESULT WINAPI dinput8_a_FindDevice( IDirectInput8A *iface_a, REFGUID gui
     HRESULT hr;
     WCHAR *name_w;
 
+    TRACE( "impl %p, guid %s, name_a %s, instance_guid %s.\n", impl, debugstr_guid( guid ),
+           debugstr_a(name_a), debugstr_guid( instance_guid ) );
+
     if (FAILED(hr = string_atow( name_a, &name_w ))) return hr;
 
     hr = IDirectInput8_FindDevice( iface_w, guid, name_w, instance_guid );
@@ -800,6 +859,9 @@ static HRESULT WINAPI dinput8_a_EnumDevicesBySemantics( IDirectInput8A *iface_a,
     HRESULT hr;
     WCHAR *username_w;
 
+    TRACE( "impl %p, username_a %s, format_a %p, callback %p, ref %p, flags %#lx.\n", impl,
+           debugstr_a(username_a), format_a, callback, ref, flags );
+
     if (!callback) return DIERR_INVALIDPARAM;
     if (FAILED(hr = string_atow( username_a, &username_w ))) return hr;
 
@@ -829,6 +891,8 @@ static HRESULT WINAPI dinput8_a_ConfigureDevices( IDirectInput8A *iface_a, LPDIC
     HRESULT hr;
     DWORD i;
 
+    TRACE( "impl %p, callback %p, params_a %p, flags %#lx, ref %p.\n", impl, callback, params_a, flags, ref );
+
     if (FAILED(hr = diconfiguredevicesparams_atow( params_a, &params_w ))) return hr;
 
     format_w.dwNumActions = format_a->dwNumActions;
@@ -875,6 +939,7 @@ static HRESULT WINAPI dinput7_a_QueryInterface( IDirectInput7A *iface_a, REFIID
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p, iid %s, out %p.\n", impl, debugstr_guid( iid ), out );
     return IDirectInput7_QueryInterface( iface_w, iid, out );
 }
 
@@ -882,6 +947,7 @@ static ULONG WINAPI dinput7_a_AddRef( IDirectInput7A *iface_a )
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInput7_AddRef( iface_w );
 }
 
@@ -889,6 +955,7 @@ static ULONG WINAPI dinput7_a_Release( IDirectInput7A *iface_a )
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p.\n", impl );
     return IDirectInput7_Release( iface_w );
 }
 
@@ -899,6 +966,8 @@ static HRESULT WINAPI dinput7_a_CreateDevice( IDirectInput7A *iface_a, REFGUID g
     IDirectInputDeviceW *out_w;
     HRESULT hr;
 
+    TRACE( "impl %p, guid %s, out_a %p, outer %p.\n", impl, debugstr_guid( guid ), out_a, outer );
+
     if (!out_a) return E_POINTER;
 
     hr = IDirectInput7_CreateDevice( iface_w, guid, &out_w, outer );
@@ -913,6 +982,8 @@ static HRESULT WINAPI dinput7_a_EnumDevices( IDirectInput7A *iface_a, DWORD type
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
 
+    TRACE( "impl %p, type %#lx, callback %p, ref %p, flags %#lx.\n", impl, type, callback, ref, flags );
+
     if (!callback) return DIERR_INVALIDPARAM;
 
     return IDirectInput7_EnumDevices( iface_w, type, enum_devices_wtoa_callback, &params, flags );
@@ -922,6 +993,7 @@ static HRESULT WINAPI dinput7_a_GetDeviceStatus( IDirectInput7A *iface_a, REFGUI
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p, instance_guid %s.\n", impl, debugstr_guid( instance_guid ) );
     return IDirectInput7_GetDeviceStatus( iface_w, instance_guid );
 }
 
@@ -929,6 +1001,7 @@ static HRESULT WINAPI dinput7_a_RunControlPanel( IDirectInput7A *iface_a, HWND o
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p, owner %p, flags %#lx.\n", impl, owner, flags );
     return IDirectInput7_RunControlPanel( iface_w, owner, flags );
 }
 
@@ -936,6 +1009,7 @@ static HRESULT WINAPI dinput7_a_Initialize( IDirectInput7A *iface_a, HINSTANCE i
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p, instance %p, version %#lx.\n", impl, instance, version );
     return IDirectInput7_Initialize( iface_w, instance, version );
 }
 
@@ -946,6 +1020,9 @@ static HRESULT WINAPI dinput7_a_FindDevice( IDirectInput7A *iface_a, REFGUID gui
     HRESULT hr;
     WCHAR *name_w;
 
+    TRACE( "impl %p, guid %s, name_a %s, instance_guid %s.\n", impl, debugstr_guid( guid ),
+           debugstr_a(name_a), debugstr_guid( instance_guid ) );
+
     if (FAILED(hr = string_atow( name_a, &name_w ))) return hr;
 
     hr = IDirectInput7_FindDevice( iface_w, guid, name_w, instance_guid );
@@ -957,6 +1034,8 @@ static HRESULT WINAPI dinput7_a_CreateDeviceEx( IDirectInput7A *iface_a, REFGUID
 {
     struct dinput *impl = impl_from_IDirectInput7A( iface_a );
     IDirectInput7W *iface_w = IDirectInput7W_from_impl( impl );
+    TRACE( "impl %p, guid %s, iid %s, out %p, outer %p.\n", impl, debugstr_guid( guid ),
+           debugstr_guid( iid ), out, outer );
     return IDirectInput7_CreateDeviceEx( iface_w, guid, iid, out, outer );
 }
 
diff --git a/dlls/dinput/device.c b/dlls/dinput/device.c
index 590151483c9..c001d1ef29a 100644
--- a/dlls/dinput/device.c
+++ b/dlls/dinput/device.c
@@ -19,12 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-/* This file contains all the Device specific functions that can be used as stubs
-   by real device implementations.
-
-   It also contains all the helper functions.
-*/
-
 #include <stdarg.h>
 #include <string.h>
 #include <math.h>
@@ -87,9 +81,6 @@ static inline BOOL is_exclusively_acquired( struct dinput_device *device )
     return device->status == STATUS_ACQUIRED && (device->dwCoopLevel & DISCL_EXCLUSIVE);
 }
 
-/******************************************************************************
- *	Various debugging tools
- */
 static void _dump_cooperativelevel_DI(DWORD dwFlags) {
     if (TRACE_ON(dinput)) {
 	unsigned int   i;
@@ -113,9 +104,6 @@ static void _dump_cooperativelevel_DI(DWORD dwFlags) {
     }
 }
 
-/******************************************************************************
- * Get the default and the app-specific config keys.
- */
 BOOL get_app_key(HKEY *defkey, HKEY *appkey)
 {
     char buffer[MAX_PATH+16];
@@ -148,9 +136,6 @@ BOOL get_app_key(HKEY *defkey, HKEY *appkey)
     return *defkey || *appkey;
 }
 
-/******************************************************************************
- * Get a config key from either the app-specific or the default config
- */
 DWORD get_config_key( HKEY defkey, HKEY appkey, const WCHAR *name, WCHAR *buffer, DWORD size )
 {
     if (appkey && !RegQueryValueExW( appkey, name, 0, NULL, (LPBYTE)buffer, &size )) return 0;
@@ -507,10 +492,6 @@ static BOOL set_app_data( struct dinput_device *dev, int offset, UINT_PTR app_da
     return TRUE;
 }
 
-/******************************************************************************
- *	queue_event - add new event to the ring queue
- */
-
 void queue_event( IDirectInputDevice8W *iface, int inst_id, DWORD data, DWORD time, DWORD seq )
 {
     static ULONGLONG notify_ms = 0;
@@ -561,14 +542,11 @@ void queue_event( IDirectInputDevice8W *iface, int inst_id, DWORD data, DWORD ti
     /* Send event if asked */
 }
 
-/******************************************************************************
- *	Acquire
- */
-
 static HRESULT WINAPI dinput_device_Acquire( IDirectInputDevice8W *iface )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
     HRESULT hr = DI_OK;
+    DWORD pid;
 
     TRACE( "iface %p.\n", iface );
 
@@ -579,6 +557,8 @@ static HRESULT WINAPI dinput_device_Acquire( IDirectInputDevice8W *iface )
         hr = DIERR_INVALIDPARAM;
     else if ((impl->dwCoopLevel & DISCL_FOREGROUND) && impl->win != GetForegroundWindow())
         hr = DIERR_OTHERAPPHASPRIO;
+    else if ((impl->dwCoopLevel & DISCL_FOREGROUND) && (!GetWindowThreadProcessId( impl->win, &pid ) || pid != GetCurrentProcessId()))
+        hr = DIERR_INVALIDPARAM;
     else
     {
         impl->status = STATUS_ACQUIRED;
@@ -588,15 +568,10 @@ static HRESULT WINAPI dinput_device_Acquire( IDirectInputDevice8W *iface )
     if (hr != DI_OK) return hr;
 
     dinput_hooks_acquire_device( iface );
-    check_dinput_hooks( iface, TRUE );
 
     return hr;
 }
 
-/******************************************************************************
- *	Unacquire
- */
-
 static HRESULT WINAPI dinput_device_Unacquire( IDirectInputDevice8W *iface )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
@@ -612,15 +587,10 @@ static HRESULT WINAPI dinput_device_Unacquire( IDirectInputDevice8W *iface )
     if (hr != DI_OK) return hr;
 
     dinput_hooks_unacquire_device( iface );
-    check_dinput_hooks( iface, FALSE );
 
     return hr;
 }
 
-/******************************************************************************
- *	IDirectInputDeviceA
- */
-
 static HRESULT WINAPI dinput_device_SetDataFormat( IDirectInputDevice8W *iface, const DIDATAFORMAT *format )
 {
     struct dinput_device *This = impl_from_IDirectInputDevice8W( iface );
@@ -653,11 +623,6 @@ static HRESULT WINAPI dinput_device_SetDataFormat( IDirectInputDevice8W *iface,
     return res;
 }
 
-/******************************************************************************
-  *     SetCooperativeLevel
-  *
-  *  Set cooperative level and the source window for the events.
-  */
 static HRESULT WINAPI dinput_device_SetCooperativeLevel( IDirectInputDevice8W *iface, HWND hwnd, DWORD flags )
 {
     struct dinput_device *This = impl_from_IDirectInputDevice8W( iface );
@@ -685,7 +650,6 @@ static HRESULT WINAPI dinput_device_SetCooperativeLevel( IDirectInputDevice8W *i
         (IsEqualGUID( &This->guid, &GUID_SysMouse ) || IsEqualGUID( &This->guid, &GUID_SysKeyboard )))
         return DIERR_UNSUPPORTED;
 
-    /* Store the window which asks for the mouse */
     EnterCriticalSection(&This->crit);
     if (This->status == STATUS_ACQUIRED) hr = DIERR_ACQUIRED;
     else
@@ -718,9 +682,6 @@ static HRESULT WINAPI dinput_device_GetDeviceInfo( IDirectInputDevice8W *iface,
     return S_OK;
 }
 
-/******************************************************************************
-  *     SetEventNotification : specifies event to be sent on state change
-  */
 static HRESULT WINAPI dinput_device_SetEventNotification( IDirectInputDevice8W *iface, HANDLE event )
 {
     struct dinput_device *This = impl_from_IDirectInputDevice8W( iface );
@@ -733,27 +694,35 @@ static HRESULT WINAPI dinput_device_SetEventNotification( IDirectInputDevice8W *
     return DI_OK;
 }
 
-void dinput_device_destroy( IDirectInputDevice8W *iface )
+void dinput_device_internal_addref( struct dinput_device *impl )
 {
-    struct dinput_device *This = impl_from_IDirectInputDevice8W( iface );
+    ULONG ref = InterlockedIncrement( &impl->internal_ref );
+    TRACE( "impl %p, internal ref %lu.\n", impl, ref );
+}
 
-    TRACE( "iface %p.\n", iface );
+void dinput_device_internal_release( struct dinput_device *impl )
+{
+    ULONG ref = InterlockedDecrement( &impl->internal_ref );
+    TRACE( "impl %p, internal ref %lu.\n", impl, ref );
 
-    free( This->object_properties );
-    free( This->data_queue );
+    if (!ref)
+    {
+        if (impl->vtbl->destroy) impl->vtbl->destroy( &impl->IDirectInputDevice8W_iface );
 
-    /* Free data format */
-    free( This->device_format.rgodf );
-    dinput_device_release_user_format( This );
+        free( impl->object_properties );
+        free( impl->data_queue );
 
-    /* Free action mapping */
-    free( This->action_map );
+        free( impl->device_format.rgodf );
+        dinput_device_release_user_format( impl );
 
-    IDirectInput_Release(&This->dinput->IDirectInput7A_iface);
-    This->crit.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection(&This->crit);
+        free( impl->action_map );
 
-    free( This );
+        dinput_internal_release( impl->dinput );
+        impl->crit.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection( &impl->crit );
+
+        free( impl );
+    }
 }
 
 static ULONG WINAPI dinput_device_Release( IDirectInputDevice8W *iface )
@@ -766,8 +735,8 @@ static ULONG WINAPI dinput_device_Release( IDirectInputDevice8W *iface )
     if (!ref)
     {
         IDirectInputDevice_Unacquire( iface );
-        if (impl->vtbl->release) impl->vtbl->release( iface );
-        else dinput_device_destroy( iface );
+        input_thread_remove_user();
+        dinput_device_internal_release( impl );
     }
 
     return ref;
@@ -2149,6 +2118,7 @@ void dinput_device_init( struct dinput_device *device, const struct dinput_devic
 {
     device->IDirectInputDevice8A_iface.lpVtbl = &dinput_device_a_vtbl;
     device->IDirectInputDevice8W_iface.lpVtbl = &dinput_device_w_vtbl;
+    device->internal_ref = 1;
     device->ref = 1;
     device->guid = *guid;
     device->instance.dwSize = sizeof(DIDEVICEINSTANCEW);
@@ -2157,9 +2127,10 @@ void dinput_device_init( struct dinput_device *device, const struct dinput_devic
     device->device_gain = 10000;
     device->force_feedback_state = DIGFFS_STOPPED | DIGFFS_EMPTY;
     InitializeCriticalSection( &device->crit );
-    device->dinput = dinput;
-    IDirectInput_AddRef( &dinput->IDirectInput7A_iface );
+    dinput_internal_addref( (device->dinput = dinput) );
     device->vtbl = vtbl;
+
+    input_thread_add_user();
 }
 
 static const GUID *object_instance_guid( const DIDEVICEOBJECTINSTANCEW *instance )
diff --git a/dlls/dinput/device_private.h b/dlls/dinput/device_private.h
index be5d7861fd1..ebe1b49da2f 100644
--- a/dlls/dinput/device_private.h
+++ b/dlls/dinput/device_private.h
@@ -36,7 +36,7 @@ typedef struct
 
 struct dinput_device_vtbl
 {
-    void (*release)( IDirectInputDevice8W *iface );
+    void (*destroy)( IDirectInputDevice8W *iface );
     HRESULT (*poll)( IDirectInputDevice8W *iface );
     HRESULT (*read)( IDirectInputDevice8W *iface );
     HRESULT (*acquire)( IDirectInputDevice8W *iface );
@@ -77,12 +77,13 @@ enum device_status
     STATUS_UNPLUGGED,
 };
 
-/* Device implementation */
 struct dinput_device
 {
     IDirectInputDevice8W        IDirectInputDevice8W_iface;
     IDirectInputDevice8A        IDirectInputDevice8A_iface;
+    LONG                        internal_ref;
     LONG                        ref;
+
     GUID                        guid;
     CRITICAL_SECTION            crit;
     struct dinput              *dinput;
@@ -93,9 +94,8 @@ struct dinput_device
     DWORD                       dwCoopLevel;
     HWND                        win;
     enum device_status          status;
-
     BOOL                        use_raw_input; /* use raw input instead of low-level messages */
-    RAWINPUTDEVICE              raw_device;    /* raw device to (un)register */
+    HHOOK                       cbt_hook;    /* CBT hook to track foreground changes */
 
     LPDIDEVICEOBJECTDATA        data_queue;  /* buffer for 'GetDeviceData'.                 */
     int                         queue_len;   /* valid size of the queue                     */
@@ -126,14 +126,14 @@ struct dinput_device
 
 extern void dinput_device_init( struct dinput_device *device, const struct dinput_device_vtbl *vtbl,
                                 const GUID *guid, struct dinput *dinput );
+extern void dinput_device_internal_addref( struct dinput_device *device );
+extern void dinput_device_internal_release( struct dinput_device *device );
+
 extern HRESULT dinput_device_init_device_format( IDirectInputDevice8W *iface );
-extern void dinput_device_destroy( IDirectInputDevice8W *iface );
 
 extern BOOL get_app_key(HKEY*, HKEY*) DECLSPEC_HIDDEN;
 extern DWORD get_config_key( HKEY, HKEY, const WCHAR *, WCHAR *, DWORD ) DECLSPEC_HIDDEN;
 extern BOOL device_instance_is_disabled( DIDEVICEINSTANCEW *instance, BOOL *override ) DECLSPEC_HIDDEN;
-
-/* Routines to do DataFormat / WineFormat conversions */
 extern void queue_event( IDirectInputDevice8W *iface, int inst_id, DWORD data, DWORD time, DWORD seq ) DECLSPEC_HIDDEN;
 
 extern const GUID dinput_pidvid_guid DECLSPEC_HIDDEN;
diff --git a/dlls/dinput/dinput.c b/dlls/dinput/dinput.c
new file mode 100644
index 00000000000..db367e1f1ba
--- /dev/null
+++ b/dlls/dinput/dinput.c
@@ -0,0 +1,987 @@
+/*
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2002 TransGaming Technologies Inc.
+ * Copyright 2007 Vitaliy Margolen
+ *
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stddef.h>
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+
+#include "wine/asm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+static inline struct dinput *impl_from_IDirectInput7W( IDirectInput7W *iface )
+{
+    return CONTAINING_RECORD( iface, struct dinput, IDirectInput7W_iface );
+}
+
+static inline struct dinput *impl_from_IDirectInput8W( IDirectInput8W *iface )
+{
+    return CONTAINING_RECORD( iface, struct dinput, IDirectInput8W_iface );
+}
+
+static DWORD diactionformat_priorityW( DIACTIONFORMATW *action_format, DWORD genre )
+{
+    int i;
+    DWORD priorityFlags = 0;
+
+    /* If there's at least one action for the device it's priority 1 */
+    for (i = 0; i < action_format->dwNumActions; i++)
+        if ((action_format->rgoAction[i].dwSemantic & genre) == genre)
+            priorityFlags |= DIEDBS_MAPPEDPRI1;
+
+    return priorityFlags;
+}
+
+#if defined __i386__ && defined _MSC_VER
+__declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref)
+{
+    __asm
+    {
+        push ebp
+        mov ebp, esp
+        push [ebp+16]
+        push [ebp+12]
+        call [ebp+8]
+        leave
+        ret
+    }
+}
+#elif defined __i386__ && defined __GNUC__
+extern BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref);
+__ASM_GLOBAL_FUNC( enum_callback_wrapper,
+    "pushl %ebp\n\t"
+    __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
+    __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
+    "movl %esp,%ebp\n\t"
+    __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
+    "pushl 16(%ebp)\n\t"
+    "pushl 12(%ebp)\n\t"
+    "call *8(%ebp)\n\t"
+    "leave\n\t"
+    __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
+    __ASM_CFI(".cfi_same_value %ebp\n\t")
+    "ret" )
+#else
+#define enum_callback_wrapper(callback, instance, ref) (callback)((instance), (ref))
+#endif
+
+static HRESULT WINAPI dinput7_EnumDevices( IDirectInput7W *iface, DWORD type, LPDIENUMDEVICESCALLBACKW callback,
+                                           void *context, DWORD flags )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+
+    TRACE( "iface %p, type %#lx, callback %p, context %p, flags %#lx.\n", iface, type, callback, context, flags );
+
+    if (!callback) return DIERR_INVALIDPARAM;
+
+    if (type > DIDEVTYPE_JOYSTICK) return DIERR_INVALIDPARAM;
+    if (flags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES | DIEDFL_INCLUDEPHANTOMS))
+        return DIERR_INVALIDPARAM;
+
+    return IDirectInput8_EnumDevices( &impl->IDirectInput8W_iface, type, callback, context, flags );
+}
+
+void dinput_internal_addref( struct dinput *impl )
+{
+    ULONG ref = InterlockedIncrement( &impl->internal_ref );
+    TRACE( "impl %p, internal ref %lu.\n", impl, ref );
+}
+
+void dinput_internal_release( struct dinput *impl )
+{
+    ULONG ref = InterlockedDecrement( &impl->internal_ref );
+    TRACE( "impl %p, internal ref %lu.\n", impl, ref );
+
+    if (!ref)
+    {
+        struct DevicePlayer *device_player, *device_player2;
+
+        LIST_FOR_EACH_ENTRY_SAFE( device_player, device_player2, &impl->device_players, struct DevicePlayer, entry )
+            free( device_player );
+
+        free( impl );
+    }
+}
+
+static ULONG WINAPI dinput7_AddRef( IDirectInput7W *iface )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI dinput7_Release( IDirectInput7W *iface )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        input_thread_remove_user();
+        dinput_internal_release( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI dinput7_QueryInterface( IDirectInput7W *iface, REFIID iid, void **out )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (!iid || !out) return E_POINTER;
+
+    *out = NULL;
+
+#if DIRECTINPUT_VERSION == 0x0700
+    if (IsEqualGUID( &IID_IDirectInputA, iid ) ||
+        IsEqualGUID( &IID_IDirectInput2A, iid ) ||
+        IsEqualGUID( &IID_IDirectInput7A, iid ))
+        *out = &impl->IDirectInput7A_iface;
+    else if (IsEqualGUID( &IID_IUnknown, iid ) ||
+             IsEqualGUID( &IID_IDirectInputW, iid ) ||
+             IsEqualGUID( &IID_IDirectInput2W, iid ) ||
+             IsEqualGUID( &IID_IDirectInput7W, iid ))
+        *out = &impl->IDirectInput7W_iface;
+#else
+    if (IsEqualGUID( &IID_IDirectInput8A, iid ))
+        *out = &impl->IDirectInput8A_iface;
+    else if (IsEqualGUID( &IID_IUnknown, iid ) ||
+             IsEqualGUID( &IID_IDirectInput8W, iid ))
+        *out = &impl->IDirectInput8W_iface;
+#endif
+
+    if (IsEqualGUID( &IID_IDirectInputJoyConfig8, iid ))
+        *out = &impl->IDirectInputJoyConfig8_iface;
+
+    if (*out)
+    {
+        IUnknown_AddRef( (IUnknown *)*out );
+        return DI_OK;
+    }
+
+    WARN( "Unsupported interface: %s\n", debugstr_guid( iid ) );
+    return E_NOINTERFACE;
+}
+
+enum directinput_versions
+{
+    DIRECTINPUT_VERSION_300 = 0x0300,
+    DIRECTINPUT_VERSION_500 = 0x0500,
+    DIRECTINPUT_VERSION_50A = 0x050A,
+    DIRECTINPUT_VERSION_5B2 = 0x05B2,
+    DIRECTINPUT_VERSION_602 = 0x0602,
+    DIRECTINPUT_VERSION_61A = 0x061A,
+    DIRECTINPUT_VERSION_700 = 0x0700,
+};
+
+static HRESULT WINAPI dinput7_Initialize( IDirectInput7W *iface, HINSTANCE hinst, DWORD version )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+
+    TRACE( "iface %p, hinst %p, version %#lx.\n", iface, hinst, version );
+
+    if (!hinst)
+        return DIERR_INVALIDPARAM;
+    else if (version == 0)
+        return DIERR_NOTINITIALIZED;
+    else if (version > DIRECTINPUT_VERSION_700)
+        return DIERR_OLDDIRECTINPUTVERSION;
+    else if (version != DIRECTINPUT_VERSION_300 && version != DIRECTINPUT_VERSION_500 &&
+             version != DIRECTINPUT_VERSION_50A && version != DIRECTINPUT_VERSION_5B2 &&
+             version != DIRECTINPUT_VERSION_602 && version != DIRECTINPUT_VERSION_61A &&
+             version != DIRECTINPUT_VERSION_700 && version != DIRECTINPUT_VERSION)
+        return DIERR_BETADIRECTINPUTVERSION;
+
+    if (!impl->dwVersion)
+    {
+        impl->dwVersion = version;
+        impl->evsequence = 1;
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput7_GetDeviceStatus( IDirectInput7W *iface, const GUID *guid )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+    HRESULT hr;
+    IDirectInputDeviceW *device;
+
+    TRACE( "iface %p, guid %s.\n", iface, debugstr_guid( guid ) );
+
+    if (!guid) return E_POINTER;
+    if (!impl->dwVersion) return DIERR_NOTINITIALIZED;
+
+    hr = IDirectInput_CreateDevice( iface, guid, &device, NULL );
+    if (hr != DI_OK) return DI_NOTATTACHED;
+
+    IUnknown_Release( device );
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput7_RunControlPanel( IDirectInput7W *iface, HWND owner, DWORD flags )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+    WCHAR control_exe[] = {L"control.exe"};
+    STARTUPINFOW si = {0};
+    PROCESS_INFORMATION pi;
+
+    TRACE( "iface %p, owner %p, flags %#lx.\n", iface, owner, flags );
+
+    if (owner && !IsWindow( owner )) return E_HANDLE;
+    if (flags) return DIERR_INVALIDPARAM;
+    if (!impl->dwVersion) return DIERR_NOTINITIALIZED;
+
+    if (!CreateProcessW( NULL, control_exe, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi ))
+        return HRESULT_FROM_WIN32(GetLastError());
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput7_FindDevice( IDirectInput7W *iface, const GUID *guid, const WCHAR *name, GUID *instance_guid )
+{
+    FIXME( "iface %p, guid %s, name %s, instance_guid %s stub!\n", iface, debugstr_guid( guid ),
+           debugstr_w(name), debugstr_guid( instance_guid ) );
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput7_CreateDeviceEx( IDirectInput7W *iface, const GUID *guid,
+                                              REFIID iid, void **out, IUnknown *outer )
+{
+    struct dinput *impl = impl_from_IDirectInput7W( iface );
+    IDirectInputDevice8W *device;
+    HRESULT hr;
+
+    TRACE( "iface %p, guid %s, iid %s, out %p, outer %p.\n", iface, debugstr_guid( guid ),
+           debugstr_guid( iid ), out, outer );
+
+    if (!out) return E_POINTER;
+    *out = NULL;
+
+    if (!guid) return E_POINTER;
+    if (!impl->dwVersion) return DIERR_NOTINITIALIZED;
+
+    if (IsEqualGUID( &GUID_SysKeyboard, guid )) hr = keyboard_create_device( impl, guid, &device );
+    else if (IsEqualGUID( &GUID_SysMouse, guid )) hr = mouse_create_device( impl, guid, &device );
+    else hr = hid_joystick_create_device( impl, guid, &device );
+
+    if (FAILED(hr)) return hr;
+
+    if (FAILED(hr = dinput_device_init_device_format( device )))
+    {
+        IDirectInputDevice8_Release( device );
+        return hr;
+    }
+
+    hr = IDirectInputDevice8_QueryInterface( device, iid, out );
+    IDirectInputDevice8_Release( device );
+    return hr;
+}
+
+static HRESULT WINAPI dinput7_CreateDevice( IDirectInput7W *iface, const GUID *guid,
+                                            IDirectInputDeviceW **out, IUnknown *outer )
+{
+    return IDirectInput7_CreateDeviceEx( iface, guid, &IID_IDirectInputDeviceW, (void **)out, outer );
+}
+
+static ULONG WINAPI dinput8_AddRef( IDirectInput8W *iface )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_AddRef( &impl->IDirectInput7W_iface );
+}
+
+static HRESULT WINAPI dinput8_QueryInterface( IDirectInput8W *iface, REFIID iid, void **out )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_QueryInterface( &impl->IDirectInput7W_iface, iid, out );
+}
+
+static ULONG WINAPI dinput8_Release( IDirectInput8W *iface )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_Release( &impl->IDirectInput7W_iface );
+}
+
+static HRESULT WINAPI dinput8_CreateDevice( IDirectInput8W *iface, const GUID *guid,
+                                            IDirectInputDevice8W **out, IUnknown *outer )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_CreateDeviceEx( &impl->IDirectInput7W_iface, guid,
+                                         &IID_IDirectInputDevice8W, (void **)out, outer );
+}
+
+static BOOL try_enum_device( DWORD type, LPDIENUMDEVICESCALLBACKW callback,
+                             DIDEVICEINSTANCEW *instance, void *context, DWORD flags )
+{
+    if (type && (instance->dwDevType & 0xff) != type) return DIENUM_CONTINUE;
+    if ((flags & DIEDFL_FORCEFEEDBACK) && IsEqualGUID( &instance->guidFFDriver, &GUID_NULL ))
+        return DIENUM_CONTINUE;
+    return enum_callback_wrapper( callback, instance, context );
+}
+
+static HRESULT WINAPI dinput8_EnumDevices( IDirectInput8W *iface, DWORD type, LPDIENUMDEVICESCALLBACKW callback, void *context,
+                                           DWORD flags )
+{
+    DIDEVICEINSTANCEW instance = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    DWORD device_class = 0, device_type = 0;
+    unsigned int i = 0;
+    HRESULT hr;
+
+    TRACE( "iface %p, type %#lx, callback %p, context %p, flags %#lx.\n", iface, type, callback, context, flags );
+
+    if (!callback) return DIERR_INVALIDPARAM;
+
+    if ((type > DI8DEVCLASS_GAMECTRL && type < DI8DEVTYPE_DEVICE) || type > DI8DEVTYPE_SUPPLEMENTAL)
+        return DIERR_INVALIDPARAM;
+    if (flags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES |
+                  DIEDFL_INCLUDEPHANTOMS | DIEDFL_INCLUDEHIDDEN))
+        return DIERR_INVALIDPARAM;
+
+    if (!impl->dwVersion) return DIERR_NOTINITIALIZED;
+
+    if (type <= DI8DEVCLASS_GAMECTRL) device_class = type;
+    else device_type = type;
+
+    if (device_class == DI8DEVCLASS_ALL || device_class == DI8DEVCLASS_POINTER)
+    {
+        hr = mouse_enum_device( type, flags, &instance, impl->dwVersion );
+        if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
+            return DI_OK;
+    }
+
+    if (device_class == DI8DEVCLASS_ALL || device_class == DI8DEVCLASS_KEYBOARD)
+    {
+        hr = keyboard_enum_device( type, flags, &instance, impl->dwVersion );
+        if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
+            return DI_OK;
+    }
+
+    if (device_class == DI8DEVCLASS_ALL || device_class == DI8DEVCLASS_GAMECTRL)
+    {
+        do
+        {
+            hr = hid_joystick_enum_device( type, flags, &instance, impl->dwVersion, i++ );
+            if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
+                return DI_OK;
+        } while (SUCCEEDED(hr));
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput8_GetDeviceStatus( IDirectInput8W *iface, const GUID *guid )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_GetDeviceStatus( &impl->IDirectInput7W_iface, guid );
+}
+
+static HRESULT WINAPI dinput8_RunControlPanel( IDirectInput8W *iface, HWND owner, DWORD flags )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_RunControlPanel( &impl->IDirectInput7W_iface, owner, flags );
+}
+
+static HRESULT WINAPI dinput8_Initialize( IDirectInput8W *iface, HINSTANCE hinst, DWORD version )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+
+    TRACE( "iface %p, hinst %p, version %#lx.\n", iface, hinst, version );
+
+    if (!hinst)
+        return DIERR_INVALIDPARAM;
+    else if (version == 0)
+        return DIERR_NOTINITIALIZED;
+    else if (version < DIRECTINPUT_VERSION)
+        return DIERR_BETADIRECTINPUTVERSION;
+    else if (version > DIRECTINPUT_VERSION)
+        return DIERR_OLDDIRECTINPUTVERSION;
+
+    if (!impl->dwVersion)
+    {
+        impl->dwVersion = version;
+        impl->evsequence = 1;
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput8_FindDevice( IDirectInput8W *iface, const GUID *guid, const WCHAR *name, GUID *instance_guid )
+{
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    return IDirectInput7_FindDevice( &impl->IDirectInput7W_iface, guid, name, instance_guid );
+}
+
+static BOOL should_enumerate_device( const WCHAR *username, DWORD flags, struct list *device_players, const GUID *guid )
+{
+    BOOL should_enumerate = TRUE;
+    struct DevicePlayer *device_player;
+
+    /* Check if user owns impl device */
+    if (flags & DIEDBSFL_THISUSER && username && *username)
+    {
+        should_enumerate = FALSE;
+        LIST_FOR_EACH_ENTRY( device_player, device_players, struct DevicePlayer, entry )
+        {
+            if (IsEqualGUID( &device_player->instance_guid, guid ))
+            {
+                if (*device_player->username && !wcscmp( username, device_player->username ))
+                    return TRUE; /* Device username matches */
+                break;
+            }
+        }
+    }
+
+    /* Check if impl device is not owned by anyone */
+    if (flags & DIEDBSFL_AVAILABLEDEVICES)
+    {
+        BOOL found = FALSE;
+        should_enumerate = FALSE;
+        LIST_FOR_EACH_ENTRY( device_player, device_players, struct DevicePlayer, entry )
+        {
+            if (IsEqualGUID( &device_player->instance_guid, guid ))
+            {
+                if (*device_player->username) found = TRUE;
+                break;
+            }
+        }
+        if (!found) return TRUE; /* Device does not have a username */
+    }
+
+    return should_enumerate;
+}
+
+struct enum_device_by_semantics_params
+{
+    IDirectInput8W *iface;
+    const WCHAR *username;
+    DWORD flags;
+
+    DIDEVICEINSTANCEW *instances;
+    DWORD instance_count;
+};
+
+static BOOL CALLBACK enum_device_by_semantics( const DIDEVICEINSTANCEW *instance, void *context )
+{
+    struct enum_device_by_semantics_params *params = context;
+    struct dinput *impl = impl_from_IDirectInput8W( params->iface );
+
+    if (should_enumerate_device( params->username, params->flags, &impl->device_players, &instance->guidInstance ))
+    {
+        params->instance_count++;
+        params->instances = realloc( params->instances, sizeof(DIDEVICEINSTANCEW) * params->instance_count );
+        params->instances[params->instance_count - 1] = *instance;
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT WINAPI dinput8_EnumDevicesBySemantics( IDirectInput8W *iface, const WCHAR *username, DIACTIONFORMATW *action_format,
+                                                      LPDIENUMDEVICESBYSEMANTICSCBW callback, void *context, DWORD flags )
+{
+    struct enum_device_by_semantics_params params = {.iface = iface, .username = username, .flags = flags};
+    DWORD callbackFlags, enum_flags = DIEDFL_ATTACHEDONLY | (flags & DIEDFL_FORCEFEEDBACK);
+    static const GUID *guids[2] = {&GUID_SysKeyboard, &GUID_SysMouse};
+    static const DWORD actionMasks[] = {DIKEYBOARD_MASK, DIMOUSE_MASK};
+    struct dinput *impl = impl_from_IDirectInput8W( iface );
+    IDirectInputDevice8W *device;
+    DIDEVICEINSTANCEW didevi;
+    unsigned int i = 0;
+    HRESULT hr;
+    int remain;
+
+    FIXME( "iface %p, username %s, action_format %p, callback %p, context %p, flags %#lx stub!\n",
+           iface, debugstr_w(username), action_format, callback, context, flags );
+
+    didevi.dwSize = sizeof(didevi);
+
+    hr = IDirectInput8_EnumDevices( &impl->IDirectInput8W_iface, DI8DEVCLASS_GAMECTRL,
+                                    enum_device_by_semantics, &params, enum_flags );
+    if (FAILED(hr))
+    {
+        free( params.instances );
+        return hr;
+    }
+
+    remain = params.instance_count;
+    /* Add keyboard and mouse to remaining device count */
+    if (!(flags & DIEDBSFL_FORCEFEEDBACK))
+    {
+        for (i = 0; i < ARRAY_SIZE(guids); i++)
+        {
+            if (should_enumerate_device( username, flags, &impl->device_players, guids[i] )) remain++;
+        }
+    }
+
+    for (i = 0; i < params.instance_count; i++)
+    {
+        callbackFlags = diactionformat_priorityW( action_format, action_format->dwGenre );
+        IDirectInput_CreateDevice( iface, &params.instances[i].guidInstance, &device, NULL );
+
+        if (callback( &params.instances[i], device, callbackFlags, --remain, context ) == DIENUM_STOP)
+        {
+            free( params.instances );
+            IDirectInputDevice_Release( device );
+            return DI_OK;
+        }
+        IDirectInputDevice_Release( device );
+    }
+
+    free( params.instances );
+
+    if (flags & DIEDBSFL_FORCEFEEDBACK) return DI_OK;
+
+    /* Enumerate keyboard and mouse */
+    for (i = 0; i < ARRAY_SIZE(guids); i++)
+    {
+        if (should_enumerate_device( username, flags, &impl->device_players, guids[i] ))
+        {
+            callbackFlags = diactionformat_priorityW( action_format, actionMasks[i] );
+
+            IDirectInput_CreateDevice( iface, guids[i], &device, NULL );
+            IDirectInputDevice_GetDeviceInfo( device, &didevi );
+
+            if (callback( &didevi, device, callbackFlags, --remain, context ) == DIENUM_STOP)
+            {
+                IDirectInputDevice_Release( device );
+                return DI_OK;
+            }
+            IDirectInputDevice_Release( device );
+        }
+    }
+
+    return DI_OK;
+}
+
+static HRESULT WINAPI dinput8_ConfigureDevices( IDirectInput8W *iface, LPDICONFIGUREDEVICESCALLBACK callback,
+                                                DICONFIGUREDEVICESPARAMSW *params, DWORD flags, void *context )
+{
+    FIXME( "iface %p, callback %p, params %p, flags %#lx, context %p stub!\n", iface, callback,
+           params, flags, context );
+
+    /* Call helper function in config.c to do the real work */
+    return _configure_devices( iface, callback, params, flags, context );
+}
+
+static inline struct dinput *impl_from_IDirectInputJoyConfig8( IDirectInputJoyConfig8 *iface )
+{
+    return CONTAINING_RECORD( iface, struct dinput, IDirectInputJoyConfig8_iface );
+}
+
+static HRESULT WINAPI joy_config_QueryInterface( IDirectInputJoyConfig8 *iface, REFIID iid, void **out )
+{
+    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInput7_QueryInterface( &impl->IDirectInput7W_iface, iid, out );
+}
+
+static ULONG WINAPI joy_config_AddRef( IDirectInputJoyConfig8 *iface )
+{
+    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInput7_AddRef( &impl->IDirectInput7W_iface );
+}
+
+static ULONG WINAPI joy_config_Release( IDirectInputJoyConfig8 *iface )
+{
+    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
+    return IDirectInput7_Release( &impl->IDirectInput7W_iface );
+}
+
+static HRESULT WINAPI joy_config_Acquire( IDirectInputJoyConfig8 *iface )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_Unacquire( IDirectInputJoyConfig8 *iface )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_SetCooperativeLevel( IDirectInputJoyConfig8 *iface, HWND hwnd, DWORD flags )
+{
+    FIXME( "iface %p, hwnd %p, flags %#lx stub!\n", iface, hwnd, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_SendNotify( IDirectInputJoyConfig8 *iface )
+{
+    FIXME( "iface %p stub!\n", iface );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_EnumTypes( IDirectInputJoyConfig8 *iface, LPDIJOYTYPECALLBACK callback, void *context )
+{
+    FIXME( "iface %p, callback %p, context %p stub!\n", iface, callback, context );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_GetTypeInfo( IDirectInputJoyConfig8 *iface, const WCHAR *name,
+                                              DIJOYTYPEINFO *info, DWORD flags )
+{
+    FIXME( "iface %p, name %s, info %p, flags %#lx stub!\n", iface, debugstr_w(name), info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_SetTypeInfo( IDirectInputJoyConfig8 *iface, const WCHAR *name,
+                                              const DIJOYTYPEINFO *info, DWORD flags, WCHAR *new_name )
+{
+    FIXME( "iface %p, name %s, info %p, flags %#lx, new_name %s stub!\n", iface, debugstr_w(name),
+           info, flags, debugstr_w(new_name) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_DeleteType( IDirectInputJoyConfig8 *iface, const WCHAR *name )
+{
+    FIXME( "iface %p, name %s stub!\n", iface, debugstr_w(name) );
+    return E_NOTIMPL;
+}
+
+struct find_device_from_index_params
+{
+    UINT index;
+    DIDEVICEINSTANCEW instance;
+};
+
+static BOOL CALLBACK find_device_from_index( const DIDEVICEINSTANCEW *instance, void *context )
+{
+    struct find_device_from_index_params *params = context;
+    params->instance = *instance;
+    if (!params->index--) return DIENUM_STOP;
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT WINAPI joy_config_GetConfig( IDirectInputJoyConfig8 *iface, UINT id, DIJOYCONFIG *info, DWORD flags )
+{
+    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
+    struct find_device_from_index_params params = {.index = id};
+    HRESULT hr;
+
+    FIXME( "iface %p, id %u, info %p, flags %#lx stub!\n", iface, id, info, flags );
+
+#define X(x) if (flags & x) FIXME("\tflags |= "#x"\n");
+    X(DIJC_GUIDINSTANCE)
+    X(DIJC_REGHWCONFIGTYPE)
+    X(DIJC_GAIN)
+    X(DIJC_CALLOUT)
+#undef X
+
+    hr = IDirectInput8_EnumDevices( &impl->IDirectInput8W_iface, DI8DEVCLASS_GAMECTRL,
+                                    find_device_from_index, &params, 0 );
+    if (FAILED(hr)) return hr;
+    if (params.index != ~0) return DIERR_NOMOREITEMS;
+    if (flags & DIJC_GUIDINSTANCE) info->guidInstance = params.instance.guidInstance;
+    return DI_OK;
+}
+
+static HRESULT WINAPI joy_config_SetConfig( IDirectInputJoyConfig8 *iface, UINT id, const DIJOYCONFIG *info, DWORD flags )
+{
+    FIXME( "iface %p, id %u, info %p, flags %#lx stub!\n", iface, id, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_DeleteConfig( IDirectInputJoyConfig8 *iface, UINT id )
+{
+    FIXME( "iface %p, id %u stub!\n", iface, id );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_GetUserValues( IDirectInputJoyConfig8 *iface, DIJOYUSERVALUES *info, DWORD flags )
+{
+    FIXME( "iface %p, info %p, flags %#lx stub!\n", iface, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_SetUserValues( IDirectInputJoyConfig8 *iface, const DIJOYUSERVALUES *info, DWORD flags )
+{
+    FIXME( "iface %p, info %p, flags %#lx stub!\n", iface, info, flags );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_AddNewHardware( IDirectInputJoyConfig8 *iface, HWND hwnd, const GUID *guid )
+{
+    FIXME( "iface %p, hwnd %p, guid %s stub!\n", iface, hwnd, debugstr_guid( guid ) );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_OpenTypeKey( IDirectInputJoyConfig8 *iface, const WCHAR *name, DWORD security, HKEY *key )
+{
+    FIXME( "iface %p, name %s, security %lu, key %p stub!\n", iface, debugstr_w(name), security, key );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI joy_config_OpenAppStatusKey( IDirectInputJoyConfig8 *iface, HKEY *key )
+{
+    FIXME( "iface %p, key %p stub!\n", iface, key );
+    return E_NOTIMPL;
+}
+
+static const IDirectInput7WVtbl dinput7_vtbl =
+{
+    dinput7_QueryInterface,
+    dinput7_AddRef,
+    dinput7_Release,
+    dinput7_CreateDevice,
+    dinput7_EnumDevices,
+    dinput7_GetDeviceStatus,
+    dinput7_RunControlPanel,
+    dinput7_Initialize,
+    dinput7_FindDevice,
+    dinput7_CreateDeviceEx,
+};
+
+static const IDirectInput8WVtbl dinput8_vtbl =
+{
+    dinput8_QueryInterface,
+    dinput8_AddRef,
+    dinput8_Release,
+    dinput8_CreateDevice,
+    dinput8_EnumDevices,
+    dinput8_GetDeviceStatus,
+    dinput8_RunControlPanel,
+    dinput8_Initialize,
+    dinput8_FindDevice,
+    dinput8_EnumDevicesBySemantics,
+    dinput8_ConfigureDevices,
+};
+
+static const IDirectInputJoyConfig8Vtbl joy_config_vtbl =
+{
+    joy_config_QueryInterface,
+    joy_config_AddRef,
+    joy_config_Release,
+    joy_config_Acquire,
+    joy_config_Unacquire,
+    joy_config_SetCooperativeLevel,
+    joy_config_SendNotify,
+    joy_config_EnumTypes,
+    joy_config_GetTypeInfo,
+    joy_config_SetTypeInfo,
+    joy_config_DeleteType,
+    joy_config_GetConfig,
+    joy_config_SetConfig,
+    joy_config_DeleteConfig,
+    joy_config_GetUserValues,
+    joy_config_SetUserValues,
+    joy_config_AddNewHardware,
+    joy_config_OpenTypeKey,
+    joy_config_OpenAppStatusKey,
+};
+
+static HRESULT dinput_create( IUnknown **out )
+{
+    struct dinput *impl;
+
+    if (!(impl = calloc( 1, sizeof(struct dinput) ))) return E_OUTOFMEMORY;
+    impl->IDirectInput7A_iface.lpVtbl = &dinput7_a_vtbl;
+    impl->IDirectInput7W_iface.lpVtbl = &dinput7_vtbl;
+    impl->IDirectInput8A_iface.lpVtbl = &dinput8_a_vtbl;
+    impl->IDirectInput8W_iface.lpVtbl = &dinput8_vtbl;
+    impl->IDirectInputJoyConfig8_iface.lpVtbl = &joy_config_vtbl;
+    impl->internal_ref = 1;
+    impl->ref = 1;
+
+    list_init( &impl->device_players );
+
+#if DIRECTINPUT_VERSION == 0x0700
+    *out = (IUnknown *)&impl->IDirectInput7W_iface;
+#else
+    *out = (IUnknown *)&impl->IDirectInput8W_iface;
+#endif
+
+    input_thread_add_user();
+    return DI_OK;
+}
+
+struct class_factory
+{
+    IClassFactory IClassFactory_iface;
+};
+
+static inline struct class_factory *impl_from_IClassFactory( IClassFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct class_factory, IClassFactory_iface );
+}
+
+static HRESULT WINAPI class_factory_QueryInterface( IClassFactory *iface, REFIID iid, void **out )
+{
+    struct class_factory *impl = impl_from_IClassFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IClassFactory ))
+        *out = &impl->IClassFactory_iface;
+    else
+    {
+        *out = NULL;
+        WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef( (IUnknown *)*out );
+    return S_OK;
+}
+
+static ULONG WINAPI class_factory_AddRef( IClassFactory *iface )
+{
+    return 2;
+}
+
+static ULONG WINAPI class_factory_Release( IClassFactory *iface )
+{
+    return 1;
+}
+
+static HRESULT WINAPI class_factory_CreateInstance( IClassFactory *iface, IUnknown *outer, REFIID iid, void **out )
+{
+    IUnknown *unknown;
+    HRESULT hr;
+
+    TRACE( "iface %p, outer %p, iid %s, out %p.\n", iface, outer, debugstr_guid( iid ), out );
+
+    if (outer) return CLASS_E_NOAGGREGATION;
+
+    if (FAILED(hr = dinput_create( &unknown ))) return hr;
+    hr = IUnknown_QueryInterface( unknown, iid, out );
+    IUnknown_Release( unknown );
+
+    return hr;
+}
+
+static HRESULT WINAPI class_factory_LockServer( IClassFactory *iface, BOOL lock )
+{
+    FIXME( "iface %p, lock %d stub!\n", iface, lock );
+    return S_OK;
+}
+
+static const IClassFactoryVtbl class_factory_vtbl =
+{
+    class_factory_QueryInterface,
+    class_factory_AddRef,
+    class_factory_Release,
+    class_factory_CreateInstance,
+    class_factory_LockServer,
+};
+
+static struct class_factory class_factory = {{&class_factory_vtbl}};
+
+HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID iid, void **out )
+{
+    TRACE( "clsid %s, iid %s, out %p.\n", debugstr_guid( clsid ), debugstr_guid( iid ), out );
+
+#if DIRECTINPUT_VERSION == 0x0700
+    if (IsEqualCLSID( &CLSID_DirectInput, clsid ))
+        return IClassFactory_QueryInterface( &class_factory.IClassFactory_iface, iid, out );
+#else
+    if (IsEqualCLSID( &CLSID_DirectInput8, clsid ))
+        return IClassFactory_QueryInterface( &class_factory.IClassFactory_iface, iid, out );
+#endif
+
+    WARN( "%s not implemented, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid( clsid ) );
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DirectInputCreateEx( HINSTANCE hinst, DWORD version, REFIID iid, void **out, IUnknown *outer )
+{
+    IUnknown *unknown;
+    HRESULT hr;
+
+    TRACE( "hinst %p, version %#lx, iid %s, out %p, outer %p.\n", hinst, version, debugstr_guid( iid ), out, outer );
+
+    if (!IsEqualGUID( &IID_IDirectInputA, iid ) &&
+        !IsEqualGUID( &IID_IDirectInputW, iid ) &&
+        !IsEqualGUID( &IID_IDirectInput2A, iid ) &&
+        !IsEqualGUID( &IID_IDirectInput2W, iid ) &&
+        !IsEqualGUID( &IID_IDirectInput7A, iid ) &&
+        !IsEqualGUID( &IID_IDirectInput7W, iid ))
+        return DIERR_NOINTERFACE;
+
+    if (FAILED(hr = dinput_create( &unknown ))) return hr;
+    hr = IUnknown_QueryInterface( unknown, iid, out );
+    IUnknown_Release( unknown );
+    if (FAILED(hr)) return hr;
+
+    if (outer || FAILED(hr = IDirectInput7_Initialize( (IDirectInput7W *)unknown, hinst, version )))
+    {
+        IUnknown_Release( unknown );
+        *out = NULL;
+        return hr;
+    }
+
+    return DI_OK;
+}
+
+HRESULT WINAPI DECLSPEC_HOTPATCH DirectInput8Create( HINSTANCE hinst, DWORD version, REFIID iid, void **out, IUnknown *outer )
+{
+    IUnknown *unknown;
+    HRESULT hr;
+
+    TRACE( "hinst %p, version %#lx, iid %s, out %p, outer %p.\n", hinst, version, debugstr_guid( iid ), out, outer );
+
+    if (!out) return E_POINTER;
+
+    if (!IsEqualGUID( &IID_IDirectInput8A, iid ) &&
+        !IsEqualGUID( &IID_IDirectInput8W, iid ) &&
+        !IsEqualGUID( &IID_IUnknown, iid ))
+    {
+        *out = NULL;
+        return DIERR_NOINTERFACE;
+    }
+
+    if (FAILED(hr = dinput_create( &unknown ))) return hr;
+    hr = IUnknown_QueryInterface( unknown, iid, out );
+    IUnknown_Release( unknown );
+    if (FAILED(hr)) return hr;
+
+    if (outer || FAILED(hr = IDirectInput8_Initialize( (IDirectInput8W *)unknown, hinst, version )))
+    {
+        IUnknown_Release( (IUnknown *)unknown );
+        *out = NULL;
+        return hr;
+    }
+
+    return S_OK;
+}
+
+HRESULT WINAPI DECLSPEC_HOTPATCH DirectInputCreateA( HINSTANCE hinst, DWORD version, IDirectInputA **out, IUnknown *outer )
+{
+    return DirectInputCreateEx( hinst, version, &IID_IDirectInput7A, (void **)out, outer );
+}
+
+HRESULT WINAPI DECLSPEC_HOTPATCH DirectInputCreateW( HINSTANCE hinst, DWORD version, IDirectInputW **out, IUnknown *outer )
+{
+    return DirectInputCreateEx( hinst, version, &IID_IDirectInput7W, (void **)out, outer );
+}
diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index d3db22c70b5..0d502821966 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -20,15 +20,6 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-/* Status:
- *
- * - Tomb Raider 2 Demo:
- *   Playable using keyboard only.
- * - WingCommander Prophecy Demo:
- *   Doesn't get Input Focus.
- *
- * - Fallout : works great in X and DGA mode
- */
 
 #include <assert.h>
 #include <stdarg.h>
@@ -44,6 +35,7 @@
 #include "objbase.h"
 #include "rpcproxy.h"
 #include "devguid.h"
+#include "hidusage.h"
 #include "initguid.h"
 #include "dinputd.h"
 
@@ -55,19 +47,24 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);
 
-static const IDirectInput7WVtbl dinput7_vtbl;
-static const IDirectInput8WVtbl dinput8_vtbl;
-static const IDirectInputJoyConfig8Vtbl joy_config_vtbl;
+#define INPUT_THREAD_MAX_DEVICES 128
 
-static inline struct dinput *impl_from_IDirectInput7W( IDirectInput7W *iface )
-{
-    return CONTAINING_RECORD( iface, struct dinput, IDirectInput7W_iface );
-}
+#define INPUT_THREAD_NOTIFY     (WM_USER + 0x10)
+#define NOTIFY_THREAD_STOP      0
+#define NOTIFY_REFRESH_DEVICES  1
+#define NOTIFY_FOREGROUND_LOST  2
 
-static inline struct dinput *impl_from_IDirectInput8W( IDirectInput8W *iface )
+struct input_thread_state
 {
-    return CONTAINING_RECORD( iface, struct dinput, IDirectInput8W_iface );
-}
+    BOOL running;
+    UINT events_count;
+    UINT devices_count;
+    HHOOK mouse_ll_hook;
+    HHOOK keyboard_ll_hook;
+    RAWINPUTDEVICE rawinput_devices[2];
+    struct dinput_device *devices[INPUT_THREAD_MAX_DEVICES];
+    HANDLE events[INPUT_THREAD_MAX_DEVICES];
+};
 
 static inline struct dinput_device *impl_from_IDirectInputDevice8W( IDirectInputDevice8W *iface )
 {
@@ -77,9 +74,9 @@ static inline struct dinput_device *impl_from_IDirectInputDevice8W( IDirectInput
 HINSTANCE DINPUT_instance;
 
 static HWND di_em_win;
-
 static HANDLE dinput_thread;
-static DWORD dinput_thread_id;
+static UINT input_thread_user_count;
+static struct input_thread_state *input_thread_state;
 
 static CRITICAL_SECTION dinput_hook_crit;
 static CRITICAL_SECTION_DEBUG dinput_critsect_debug =
@@ -90,26 +87,17 @@ static CRITICAL_SECTION_DEBUG dinput_critsect_debug =
 };
 static CRITICAL_SECTION dinput_hook_crit = { &dinput_critsect_debug, -1, 0, 0, 0, 0 };
 
-static struct list acquired_mouse_list = LIST_INIT( acquired_mouse_list );
-static struct list acquired_rawmouse_list = LIST_INIT( acquired_rawmouse_list );
-static struct list acquired_keyboard_list = LIST_INIT( acquired_keyboard_list );
 static struct list acquired_device_list = LIST_INIT( acquired_device_list );
 
-static HRESULT initialize_directinput_instance( struct dinput *impl, DWORD version );
-static void uninitialize_directinput_instance( struct dinput *impl );
-
 void dinput_hooks_acquire_device( IDirectInputDevice8W *iface )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
 
     EnterCriticalSection( &dinput_hook_crit );
-    if (IsEqualGUID( &impl->guid, &GUID_SysMouse ))
-        list_add_tail( impl->use_raw_input ? &acquired_rawmouse_list : &acquired_mouse_list, &impl->entry );
-    else if (IsEqualGUID( &impl->guid, &GUID_SysKeyboard ))
-        list_add_tail( &acquired_keyboard_list, &impl->entry );
-    else
-        list_add_tail( &acquired_device_list, &impl->entry );
+    list_add_tail( &acquired_device_list, &impl->entry );
     LeaveCriticalSection( &dinput_hook_crit );
+
+    SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_REFRESH_DEVICES, 0 );
 }
 
 void dinput_hooks_unacquire_device( IDirectInputDevice8W *iface )
@@ -119,266 +107,199 @@ void dinput_hooks_unacquire_device( IDirectInputDevice8W *iface )
     EnterCriticalSection( &dinput_hook_crit );
     list_remove( &impl->entry );
     LeaveCriticalSection( &dinput_hook_crit );
+
+    SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_REFRESH_DEVICES, 0 );
 }
 
-static void dinput_device_internal_unacquire( IDirectInputDevice8W *iface )
+static void unhook_device_window_foreground_changes( struct dinput_device *device )
+{
+    if (!device->cbt_hook) return;
+    UnhookWindowsHookEx( device->cbt_hook );
+    device->cbt_hook = NULL;
+}
+
+static void dinput_device_internal_unacquire( IDirectInputDevice8W *iface, DWORD status )
 {
     struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
 
     TRACE( "iface %p.\n", iface );
 
+    unhook_device_window_foreground_changes( impl );
+
     EnterCriticalSection( &impl->crit );
     if (impl->status == STATUS_ACQUIRED)
     {
         impl->vtbl->unacquire( iface );
-        impl->status = STATUS_UNACQUIRED;
+        impl->status = status;
         list_remove( &impl->entry );
     }
     LeaveCriticalSection( &impl->crit );
 }
 
-static HRESULT dinput_create( IUnknown **out )
+static LRESULT CALLBACK input_thread_ll_hook_proc( int code, WPARAM wparam, LPARAM lparam )
 {
-    struct dinput *impl;
-
-    if (!(impl = calloc( 1, sizeof(struct dinput) ))) return E_OUTOFMEMORY;
-    impl->IDirectInput7A_iface.lpVtbl = &dinput7_a_vtbl;
-    impl->IDirectInput7W_iface.lpVtbl = &dinput7_vtbl;
-    impl->IDirectInput8A_iface.lpVtbl = &dinput8_a_vtbl;
-    impl->IDirectInput8W_iface.lpVtbl = &dinput8_vtbl;
-    impl->IDirectInputJoyConfig8_iface.lpVtbl = &joy_config_vtbl;
-    impl->ref = 1;
-
-#if DIRECTINPUT_VERSION == 0x0700
-    *out = (IUnknown *)&impl->IDirectInput7W_iface;
-#else
-    *out = (IUnknown *)&impl->IDirectInput8W_iface;
-#endif
-    return DI_OK;
-}
-
-/******************************************************************************
- *	DirectInputCreateEx (DINPUT.@)
- */
-HRESULT WINAPI DirectInputCreateEx( HINSTANCE hinst, DWORD version, REFIID iid, void **out, IUnknown *outer )
-{
-    IUnknown *unknown;
-    HRESULT hr;
+    struct input_thread_state *state = input_thread_state;
+    int i, skip = 0;
 
-    TRACE( "hinst %p, version %#lx, iid %s, out %p, outer %p.\n", hinst, version, debugstr_guid( iid ), out, outer );
-
-    if (!IsEqualGUID( &IID_IDirectInputA, iid ) &&
-        !IsEqualGUID( &IID_IDirectInputW, iid ) &&
-        !IsEqualGUID( &IID_IDirectInput2A, iid ) &&
-        !IsEqualGUID( &IID_IDirectInput2W, iid ) &&
-        !IsEqualGUID( &IID_IDirectInput7A, iid ) &&
-        !IsEqualGUID( &IID_IDirectInput7W, iid ))
-        return DIERR_NOINTERFACE;
-
-    if (FAILED(hr = dinput_create( &unknown ))) return hr;
-    hr = IUnknown_QueryInterface( unknown, iid, out );
-    IUnknown_Release( unknown );
-    if (FAILED(hr)) return hr;
+    if (code != HC_ACTION) return CallNextHookEx( 0, code, wparam, lparam );
 
-    if (outer || FAILED(hr = IDirectInput7_Initialize( (IDirectInput7W *)unknown, hinst, version )))
+    for (i = state->events_count; i < state->devices_count; ++i)
     {
-        IUnknown_Release( unknown );
-        *out = NULL;
-        return hr;
+        struct dinput_device *device = state->devices[i];
+        if (device->use_raw_input) continue;
+        if (device->instance.dwDevType & DIDEVTYPE_HID) continue;
+        switch (GET_DIDEVICE_TYPE( device->instance.dwDevType ))
+        {
+        case DIDEVTYPE_MOUSE:
+        case DI8DEVTYPE_MOUSE:
+            TRACE( "calling dinput_mouse_hook (%p %Ix %Ix)\n", device, wparam, lparam );
+            skip |= dinput_mouse_hook( &device->IDirectInputDevice8W_iface, wparam, lparam );
+            break;
+        case DIDEVTYPE_KEYBOARD:
+        case DI8DEVTYPE_KEYBOARD:
+            TRACE( "calling dinput_keyboard_hook (%p %Ix %Ix)\n", device, wparam, lparam );
+            skip |= dinput_keyboard_hook( &device->IDirectInputDevice8W_iface, wparam, lparam );
+            break;
+        }
     }
 
-    return DI_OK;
+    return skip ? 1 : CallNextHookEx( 0, code, wparam, lparam );
 }
 
-/******************************************************************************
- *	DirectInput8Create (DINPUT8.@)
- */
-HRESULT WINAPI DECLSPEC_HOTPATCH DirectInput8Create( HINSTANCE hinst, DWORD version, REFIID iid, void **out, IUnknown *outer )
+static void dinput_unacquire_window_devices( HWND window )
 {
-    IUnknown *unknown;
-    HRESULT hr;
-
-    TRACE( "hinst %p, version %#lx, iid %s, out %p, outer %p.\n", hinst, version, debugstr_guid( iid ), out, outer );
-
-    if (!out) return E_POINTER;
-
-    if (!IsEqualGUID( &IID_IDirectInput8A, iid ) &&
-        !IsEqualGUID( &IID_IDirectInput8W, iid ) &&
-        !IsEqualGUID( &IID_IUnknown, iid ))
-    {
-        *out = NULL;
-        return DIERR_NOINTERFACE;
-    }
+    struct dinput_device *impl, *next;
 
-    if (FAILED(hr = dinput_create( &unknown ))) return hr;
-    hr = IUnknown_QueryInterface( unknown, iid, out );
-    IUnknown_Release( unknown );
-    if (FAILED(hr)) return hr;
+    EnterCriticalSection( &dinput_hook_crit );
 
-    if (outer || FAILED(hr = IDirectInput8_Initialize( (IDirectInput8W *)unknown, hinst, version )))
+    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_device_list, struct dinput_device, entry )
     {
-        IUnknown_Release( (IUnknown *)unknown );
-        *out = NULL;
-        return hr;
+        if (window != impl->win) continue;
+        TRACE( "%p window is not foreground - unacquiring %p\n", impl->win, impl );
+        dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface, STATUS_UNACQUIRED );
     }
 
-    return S_OK;
-}
-
-/******************************************************************************
- *	DirectInputCreateA (DINPUT.@)
- */
-HRESULT WINAPI DECLSPEC_HOTPATCH DirectInputCreateA( HINSTANCE hinst, DWORD version, IDirectInputA **out, IUnknown *outer )
-{
-    return DirectInputCreateEx( hinst, version, &IID_IDirectInput7A, (void **)out, outer );
+    LeaveCriticalSection( &dinput_hook_crit );
 }
 
-/******************************************************************************
- *	DirectInputCreateW (DINPUT.@)
- */
-HRESULT WINAPI DECLSPEC_HOTPATCH DirectInputCreateW( HINSTANCE hinst, DWORD version, IDirectInputW **out, IUnknown *outer )
+static void dinput_unacquire_devices(void)
 {
-    return DirectInputCreateEx( hinst, version, &IID_IDirectInput7W, (void **)out, outer );
-}
+    struct dinput_device *impl, *next;
 
-static DWORD diactionformat_priorityW( DIACTIONFORMATW *action_format, DWORD genre )
-{
-    int i;
-    DWORD priorityFlags = 0;
+    EnterCriticalSection( &dinput_hook_crit );
 
-    /* If there's at least one action for the device it's priority 1 */
-    for (i = 0; i < action_format->dwNumActions; i++)
-        if ((action_format->rgoAction[i].dwSemantic & genre) == genre)
-            priorityFlags |= DIEDBS_MAPPEDPRI1;
+    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_device_list, struct dinput_device, entry )
+        dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface, STATUS_UNACQUIRED );
 
-    return priorityFlags;
+    LeaveCriticalSection( &dinput_hook_crit );
 }
 
-#if defined __i386__ && defined _MSC_VER
-__declspec(naked) BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref)
+static LRESULT CALLBACK cbt_hook_proc( int code, WPARAM wparam, LPARAM lparam )
 {
-    __asm
+    if (code == HCBT_ACTIVATE && di_em_win)
     {
-        push ebp
-        mov ebp, esp
-        push [ebp+16]
-        push [ebp+12]
-        call [ebp+8]
-        leave
-        ret
+        CBTACTIVATESTRUCT *data = (CBTACTIVATESTRUCT *)lparam;
+        SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_FOREGROUND_LOST,
+                      (LPARAM)data->hWndActive );
     }
-}
-#elif defined __i386__ && defined __GNUC__
-extern BOOL enum_callback_wrapper(void *callback, const void *instance, void *ref);
-__ASM_GLOBAL_FUNC( enum_callback_wrapper,
-    "pushl %ebp\n\t"
-    __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
-    __ASM_CFI(".cfi_rel_offset %ebp,0\n\t")
-    "movl %esp,%ebp\n\t"
-    __ASM_CFI(".cfi_def_cfa_register %ebp\n\t")
-    "pushl 16(%ebp)\n\t"
-    "pushl 12(%ebp)\n\t"
-    "call *8(%ebp)\n\t"
-    "leave\n\t"
-    __ASM_CFI(".cfi_def_cfa %esp,4\n\t")
-    __ASM_CFI(".cfi_same_value %ebp\n\t")
-    "ret" )
-#else
-#define enum_callback_wrapper(callback, instance, ref) (callback)((instance), (ref))
-#endif
-
-/******************************************************************************
- *	IDirectInputW_EnumDevices
- */
-static HRESULT WINAPI dinput7_EnumDevices( IDirectInput7W *iface, DWORD type, LPDIENUMDEVICESCALLBACKW callback,
-                                           void *context, DWORD flags )
-{
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
 
-    TRACE( "iface %p, type %#lx, callback %p, context %p, flags %#lx.\n", iface, type, callback, context, flags );
-
-    if (!callback) return DIERR_INVALIDPARAM;
-
-    if (type > DIDEVTYPE_JOYSTICK) return DIERR_INVALIDPARAM;
-    if (flags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES | DIEDFL_INCLUDEPHANTOMS))
-        return DIERR_INVALIDPARAM;
-
-    return IDirectInput8_EnumDevices( &impl->IDirectInput8W_iface, type, callback, context, flags );
+    return CallNextHookEx( 0, code, wparam, lparam );
 }
 
-static ULONG WINAPI dinput7_AddRef( IDirectInput7W *iface )
+static void hook_device_window_foreground_changes( struct dinput_device *device )
 {
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
-    ULONG ref = InterlockedIncrement( &impl->ref );
-    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
-    return ref;
+    DWORD tid, pid;
+    if (!(tid = GetWindowThreadProcessId( device->win, &pid ))) return;
+    device->cbt_hook = SetWindowsHookExW( WH_CBT, cbt_hook_proc, DINPUT_instance, tid );
 }
 
-static ULONG WINAPI dinput7_Release( IDirectInput7W *iface )
+static void input_thread_update_device_list( struct input_thread_state *state )
 {
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
-    ULONG ref = InterlockedDecrement( &impl->ref );
+    RAWINPUTDEVICE rawinput_keyboard = {.usUsagePage = HID_USAGE_PAGE_GENERIC, .usUsage = HID_USAGE_GENERIC_KEYBOARD, .dwFlags = RIDEV_REMOVE};
+    RAWINPUTDEVICE rawinput_mouse = {.usUsagePage = HID_USAGE_PAGE_GENERIC, .usUsage = HID_USAGE_GENERIC_MOUSE, .dwFlags = RIDEV_REMOVE};
+    UINT count = 0, keyboard_ll_count = 0, mouse_ll_count = 0;
+    struct dinput_device *device;
 
-    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
-
-    if (ref == 0)
+    EnterCriticalSection( &dinput_hook_crit );
+    LIST_FOR_EACH_ENTRY( device, &acquired_device_list, struct dinput_device, entry )
     {
-        uninitialize_directinput_instance( impl );
-        free( impl );
-    }
-
-    return ref;
-}
-
-static HRESULT WINAPI dinput7_QueryInterface( IDirectInput7W *iface, REFIID iid, void **out )
-{
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
+        unhook_device_window_foreground_changes( device );
+        if (device->dwCoopLevel & DISCL_FOREGROUND) hook_device_window_foreground_changes( device );
 
-    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
-
-    if (!iid || !out) return E_POINTER;
+        if (!device->read_event || !device->vtbl->read) continue;
+        state->events[count] = device->read_event;
+        dinput_device_internal_addref( (state->devices[count] = device) );
+        if (++count >= INPUT_THREAD_MAX_DEVICES) break;
+    }
+    state->events_count = count;
 
-    *out = NULL;
+    LIST_FOR_EACH_ENTRY( device, &acquired_device_list, struct dinput_device, entry )
+    {
+        RAWINPUTDEVICE *rawinput_device = NULL;
 
-#if DIRECTINPUT_VERSION == 0x0700
-    if (IsEqualGUID( &IID_IDirectInputA, iid ) ||
-        IsEqualGUID( &IID_IDirectInput2A, iid ) ||
-        IsEqualGUID( &IID_IDirectInput7A, iid ))
-        *out = &impl->IDirectInput7A_iface;
-    else if (IsEqualGUID( &IID_IUnknown, iid ) ||
-             IsEqualGUID( &IID_IDirectInputW, iid ) ||
-             IsEqualGUID( &IID_IDirectInput2W, iid ) ||
-             IsEqualGUID( &IID_IDirectInput7W, iid ))
-        *out = &impl->IDirectInput7W_iface;
+        if (device->read_event && device->vtbl->read) continue;
+        switch (GET_DIDEVICE_TYPE( device->instance.dwDevType ))
+        {
+        case DIDEVTYPE_MOUSE:
+        case DI8DEVTYPE_MOUSE:
+            if (device->dwCoopLevel & DISCL_EXCLUSIVE) rawinput_mouse.dwFlags |= RIDEV_CAPTUREMOUSE;
+            if (!device->use_raw_input) mouse_ll_count++;
+            else rawinput_device = &rawinput_mouse;
+            break;
+        case DIDEVTYPE_KEYBOARD:
+        case DI8DEVTYPE_KEYBOARD:
+            if (device->dwCoopLevel & DISCL_EXCLUSIVE) rawinput_keyboard.dwFlags |= RIDEV_NOHOTKEYS;
+            if (!device->use_raw_input) keyboard_ll_count++;
+            else rawinput_device = &rawinput_keyboard;
+            break;
+        }
 
-#else
-    if (IsEqualGUID( &IID_IDirectInput8A, iid ))
-        *out = &impl->IDirectInput8A_iface;
-    else if (IsEqualGUID( &IID_IUnknown, iid ) ||
-             IsEqualGUID( &IID_IDirectInput8W, iid ))
-        *out = &impl->IDirectInput8W_iface;
+        if (rawinput_device)
+        {
+            if (device->dwCoopLevel & DISCL_BACKGROUND) rawinput_device->dwFlags |= RIDEV_INPUTSINK;
+            if (device->dwCoopLevel & DISCL_EXCLUSIVE) rawinput_device->dwFlags |= RIDEV_NOLEGACY;
+            rawinput_device->dwFlags &= ~RIDEV_REMOVE;
+            rawinput_device->hwndTarget = di_em_win;
+        }
 
-#endif
+        if (count < INPUT_THREAD_MAX_DEVICES) dinput_device_internal_addref( (state->devices[count++] = device) );
+    }
+    state->devices_count = count;
+    LeaveCriticalSection( &dinput_hook_crit );
 
-    if (IsEqualGUID( &IID_IDirectInputJoyConfig8, iid ))
-        *out = &impl->IDirectInputJoyConfig8_iface;
+    if (keyboard_ll_count && !state->keyboard_ll_hook)
+        state->keyboard_ll_hook = SetWindowsHookExW( WH_KEYBOARD_LL, input_thread_ll_hook_proc, DINPUT_instance, 0 );
+    else if (!keyboard_ll_count && state->keyboard_ll_hook)
+    {
+        UnhookWindowsHookEx( state->keyboard_ll_hook );
+        state->keyboard_ll_hook = NULL;
+    }
 
-    if (*out)
+    if (mouse_ll_count && !state->mouse_ll_hook)
+        state->mouse_ll_hook = SetWindowsHookExW( WH_MOUSE_LL, input_thread_ll_hook_proc, DINPUT_instance, 0 );
+    else if (!mouse_ll_count && state->mouse_ll_hook)
     {
-        IUnknown_AddRef( (IUnknown *)*out );
-        return DI_OK;
+        UnhookWindowsHookEx( state->mouse_ll_hook );
+        state->mouse_ll_hook = NULL;
     }
 
-    WARN( "Unsupported interface: %s\n", debugstr_guid( iid ) );
-    return E_NOINTERFACE;
+    if (!rawinput_mouse.hwndTarget != !state->rawinput_devices[0].hwndTarget &&
+        !RegisterRawInputDevices( &rawinput_mouse, 1, sizeof(RAWINPUTDEVICE) ))
+        WARN( "Failed to (un)register rawinput mouse device.\n" );
+    if (!rawinput_keyboard.hwndTarget != !state->rawinput_devices[1].hwndTarget &&
+        !RegisterRawInputDevices( &rawinput_keyboard, 1, sizeof(RAWINPUTDEVICE) ))
+        WARN( "Failed to (un)register rawinput mouse device.\n" );
+
+    state->rawinput_devices[0] = rawinput_mouse;
+    state->rawinput_devices[1] = rawinput_keyboard;
 }
 
 static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
-    struct dinput_device *impl;
-    RAWINPUT ri;
-    UINT size = sizeof(ri);
+    struct input_thread_state *state = input_thread_state;
     int rim = GET_RAWINPUT_CODE_WPARAM( wparam );
+    UINT i, size = sizeof(RAWINPUT);
+    RAWINPUT ri;
 
     TRACE( "%p %d %Ix %Ix\n", hwnd, msg, wparam, lparam );
 
@@ -387,15 +308,54 @@ static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPAR
         size = GetRawInputData( (HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER) );
         if (size == (UINT)-1 || size < sizeof(RAWINPUTHEADER))
             WARN( "Unable to read raw input data\n" );
-        else if (ri.header.dwType == RIM_TYPEMOUSE)
+        else if (ri.header.dwType == RIM_TYPEHID)
+            WARN( "Unexpected HID rawinput message\n" );
+        else
         {
-            EnterCriticalSection( &dinput_hook_crit );
-            LIST_FOR_EACH_ENTRY( impl, &acquired_rawmouse_list, struct dinput_device, entry )
-                dinput_mouse_rawinput_hook( &impl->IDirectInputDevice8W_iface, wparam, lparam, &ri );
-            LeaveCriticalSection( &dinput_hook_crit );
+            for (i = state->events_count; i < state->devices_count; ++i)
+            {
+                struct dinput_device *device = state->devices[i];
+                if (!device->use_raw_input) continue;
+                if (device->instance.dwDevType & DIDEVTYPE_HID) continue;
+                switch (GET_DIDEVICE_TYPE( device->instance.dwDevType ))
+                {
+                case DIDEVTYPE_MOUSE:
+                case DI8DEVTYPE_MOUSE:
+                    if (ri.header.dwType != RIM_TYPEMOUSE) break;
+                    dinput_mouse_rawinput_hook( &device->IDirectInputDevice8W_iface, wparam, lparam, &ri );
+                    break;
+                case DIDEVTYPE_KEYBOARD:
+                case DI8DEVTYPE_KEYBOARD:
+                    if (ri.header.dwType != RIM_TYPEKEYBOARD) break;
+                    dinput_keyboard_rawinput_hook( &device->IDirectInputDevice8W_iface, wparam, lparam, &ri );
+                    break;
+                default: break;
+                }
+            }
         }
     }
 
+    if (msg == INPUT_THREAD_NOTIFY)
+    {
+        TRACE( "Processing hook change notification wparam %#Ix, lparam %#Ix.\n", wparam, lparam );
+
+        switch (wparam)
+        {
+        case NOTIFY_THREAD_STOP:
+            state->running = FALSE;
+            break;
+        case NOTIFY_REFRESH_DEVICES:
+            while (state->devices_count--) dinput_device_internal_release( state->devices[state->devices_count] );
+            input_thread_update_device_list( state );
+            break;
+        case NOTIFY_FOREGROUND_LOST:
+            dinput_unacquire_window_devices( (HWND)lparam );
+            break;
+        }
+
+        return 0;
+    }
+
     return DefWindowProcW( hwnd, msg, wparam, lparam );
 }
 
@@ -419,1000 +379,89 @@ static void unregister_di_em_win_class(void)
         WARN( "Unable to unregister message window class\n" );
 }
 
-static HRESULT initialize_directinput_instance( struct dinput *impl, DWORD version )
-{
-    if (!impl->initialized)
-    {
-        impl->dwVersion = version;
-        impl->evsequence = 1;
-
-        list_init( &impl->device_players );
-
-        impl->initialized = TRUE;
-    }
-
-    return DI_OK;
-}
-
-static void uninitialize_directinput_instance( struct dinput *impl )
-{
-    if (impl->initialized)
-    {
-        struct DevicePlayer *device_player, *device_player2;
-
-        LIST_FOR_EACH_ENTRY_SAFE ( device_player, device_player2, &impl->device_players, struct DevicePlayer, entry )
-            free( device_player );
-
-        impl->initialized = FALSE;
-    }
-}
-
-enum directinput_versions
-{
-    DIRECTINPUT_VERSION_300 = 0x0300,
-    DIRECTINPUT_VERSION_500 = 0x0500,
-    DIRECTINPUT_VERSION_50A = 0x050A,
-    DIRECTINPUT_VERSION_5B2 = 0x05B2,
-    DIRECTINPUT_VERSION_602 = 0x0602,
-    DIRECTINPUT_VERSION_61A = 0x061A,
-    DIRECTINPUT_VERSION_700 = 0x0700,
-};
-
-static HRESULT WINAPI dinput7_Initialize( IDirectInput7W *iface, HINSTANCE hinst, DWORD version )
-{
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
-
-    TRACE( "iface %p, hinst %p, version %#lx.\n", iface, hinst, version );
-
-    if (!hinst)
-        return DIERR_INVALIDPARAM;
-    else if (version == 0)
-        return DIERR_NOTINITIALIZED;
-    else if (version > DIRECTINPUT_VERSION_700)
-        return DIERR_OLDDIRECTINPUTVERSION;
-    else if (version != DIRECTINPUT_VERSION_300 && version != DIRECTINPUT_VERSION_500 &&
-             version != DIRECTINPUT_VERSION_50A && version != DIRECTINPUT_VERSION_5B2 &&
-             version != DIRECTINPUT_VERSION_602 && version != DIRECTINPUT_VERSION_61A &&
-             version != DIRECTINPUT_VERSION_700 && version != DIRECTINPUT_VERSION)
-        return DIERR_BETADIRECTINPUTVERSION;
-
-    return initialize_directinput_instance( impl, version );
-}
-
-static HRESULT WINAPI dinput7_GetDeviceStatus( IDirectInput7W *iface, const GUID *guid )
-{
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
-    HRESULT hr;
-    IDirectInputDeviceW *device;
-
-    TRACE( "iface %p, guid %s.\n", iface, debugstr_guid( guid ) );
-
-    if (!guid) return E_POINTER;
-    if (!impl->initialized) return DIERR_NOTINITIALIZED;
-
-    hr = IDirectInput_CreateDevice( iface, guid, &device, NULL );
-    if (hr != DI_OK) return DI_NOTATTACHED;
-
-    IUnknown_Release( device );
-
-    return DI_OK;
-}
-
-static HRESULT WINAPI dinput7_RunControlPanel( IDirectInput7W *iface, HWND owner, DWORD flags )
-{
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
-    WCHAR control_exe[] = {L"control.exe"};
-    STARTUPINFOW si = {0};
-    PROCESS_INFORMATION pi;
-
-    TRACE( "iface %p, owner %p, flags %#lx.\n", iface, owner, flags );
-
-    if (owner && !IsWindow( owner )) return E_HANDLE;
-    if (flags) return DIERR_INVALIDPARAM;
-    if (!impl->initialized) return DIERR_NOTINITIALIZED;
-
-    if (!CreateProcessW( NULL, control_exe, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi ))
-        return HRESULT_FROM_WIN32(GetLastError());
-
-    return DI_OK;
-}
-
-static HRESULT WINAPI dinput7_FindDevice( IDirectInput7W *iface, const GUID *guid, const WCHAR *name, GUID *instance_guid )
-{
-    FIXME( "iface %p, guid %s, name %s, instance_guid %s stub!\n", iface, debugstr_guid( guid ),
-           debugstr_w(name), debugstr_guid( instance_guid ) );
-    return DI_OK;
-}
-
-static HRESULT WINAPI dinput7_CreateDeviceEx( IDirectInput7W *iface, const GUID *guid,
-                                              REFIID iid, void **out, IUnknown *outer )
-{
-    struct dinput *impl = impl_from_IDirectInput7W( iface );
-    IDirectInputDevice8W *device;
-    HRESULT hr;
-
-    TRACE( "iface %p, guid %s, iid %s, out %p, outer %p.\n", iface, debugstr_guid( guid ),
-           debugstr_guid( iid ), out, outer );
-
-    if (!out) return E_POINTER;
-    *out = NULL;
-
-    if (!guid) return E_POINTER;
-    if (!impl->initialized) return DIERR_NOTINITIALIZED;
-
-    if (IsEqualGUID( &GUID_SysKeyboard, guid )) hr = keyboard_create_device( impl, guid, &device );
-    else if (IsEqualGUID( &GUID_SysMouse, guid )) hr = mouse_create_device( impl, guid, &device );
-    else hr = hid_joystick_create_device( impl, guid, &device );
-
-    if (FAILED(hr)) return hr;
-
-    if (FAILED(hr = dinput_device_init_device_format( device )))
-    {
-        IDirectInputDevice8_Release( device );
-        return hr;
-    }
-
-    hr = IDirectInputDevice8_QueryInterface( device, iid, out );
-    IDirectInputDevice8_Release( device );
-    return hr;
-}
-
-static HRESULT WINAPI dinput7_CreateDevice( IDirectInput7W *iface, const GUID *guid,
-                                            IDirectInputDeviceW **out, IUnknown *outer )
-{
-    return IDirectInput7_CreateDeviceEx( iface, guid, &IID_IDirectInputDeviceW, (void **)out, outer );
-}
-
-/*******************************************************************************
- *      DirectInput8
- */
-
-static ULONG WINAPI dinput8_AddRef( IDirectInput8W *iface )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_AddRef( &impl->IDirectInput7W_iface );
-}
-
-static HRESULT WINAPI dinput8_QueryInterface( IDirectInput8W *iface, REFIID iid, void **out )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_QueryInterface( &impl->IDirectInput7W_iface, iid, out );
-}
-
-static ULONG WINAPI dinput8_Release( IDirectInput8W *iface )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_Release( &impl->IDirectInput7W_iface );
-}
-
-static HRESULT WINAPI dinput8_CreateDevice( IDirectInput8W *iface, const GUID *guid,
-                                            IDirectInputDevice8W **out, IUnknown *outer )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_CreateDeviceEx( &impl->IDirectInput7W_iface, guid,
-                                         &IID_IDirectInputDevice8W, (void **)out, outer );
-}
-
-static BOOL try_enum_device( DWORD type, LPDIENUMDEVICESCALLBACKW callback,
-                             DIDEVICEINSTANCEW *instance, void *context, DWORD flags )
-{
-    if (type && (instance->dwDevType & 0xff) != type) return DIENUM_CONTINUE;
-    if ((flags & DIEDFL_FORCEFEEDBACK) && IsEqualGUID( &instance->guidFFDriver, &GUID_NULL ))
-        return DIENUM_CONTINUE;
-    return enum_callback_wrapper( callback, instance, context );
-}
-
-static HRESULT WINAPI dinput8_EnumDevices( IDirectInput8W *iface, DWORD type, LPDIENUMDEVICESCALLBACKW callback, void *context,
-                                           DWORD flags )
-{
-    DIDEVICEINSTANCEW instance = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    DWORD device_class = 0, device_type = 0;
-    unsigned int i = 0;
-    HRESULT hr;
-
-    TRACE( "iface %p, type %#lx, callback %p, context %p, flags %#lx.\n", iface, type, callback, context, flags );
-
-    if (!callback) return DIERR_INVALIDPARAM;
-
-    if ((type > DI8DEVCLASS_GAMECTRL && type < DI8DEVTYPE_DEVICE) || type > DI8DEVTYPE_SUPPLEMENTAL)
-        return DIERR_INVALIDPARAM;
-    if (flags & ~(DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK | DIEDFL_INCLUDEALIASES |
-                  DIEDFL_INCLUDEPHANTOMS | DIEDFL_INCLUDEHIDDEN))
-        return DIERR_INVALIDPARAM;
-
-    if (!impl->initialized) return DIERR_NOTINITIALIZED;
-
-    if (type <= DI8DEVCLASS_GAMECTRL) device_class = type;
-    else device_type = type;
-
-    if (device_class == DI8DEVCLASS_ALL || device_class == DI8DEVCLASS_POINTER)
-    {
-        hr = mouse_enum_device( type, flags, &instance, impl->dwVersion );
-        if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
-            return DI_OK;
-    }
-
-    if (device_class == DI8DEVCLASS_ALL || device_class == DI8DEVCLASS_KEYBOARD)
-    {
-        hr = keyboard_enum_device( type, flags, &instance, impl->dwVersion );
-        if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
-            return DI_OK;
-    }
-
-    if (device_class == DI8DEVCLASS_ALL || device_class == DI8DEVCLASS_GAMECTRL)
-    {
-        do
-        {
-            hr = hid_joystick_enum_device( type, flags, &instance, impl->dwVersion, i++ );
-            if (hr == DI_OK && try_enum_device( device_type, callback, &instance, context, flags ) == DIENUM_STOP)
-                return DI_OK;
-        } while (SUCCEEDED(hr));
-    }
-
-    return DI_OK;
-}
-
-static HRESULT WINAPI dinput8_GetDeviceStatus( IDirectInput8W *iface, const GUID *guid )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_GetDeviceStatus( &impl->IDirectInput7W_iface, guid );
-}
-
-static HRESULT WINAPI dinput8_RunControlPanel( IDirectInput8W *iface, HWND owner, DWORD flags )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_RunControlPanel( &impl->IDirectInput7W_iface, owner, flags );
-}
-
-static HRESULT WINAPI dinput8_Initialize( IDirectInput8W *iface, HINSTANCE hinst, DWORD version )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-
-    TRACE( "iface %p, hinst %p, version %#lx.\n", iface, hinst, version );
-
-    if (!hinst)
-        return DIERR_INVALIDPARAM;
-    else if (version == 0)
-        return DIERR_NOTINITIALIZED;
-    else if (version < DIRECTINPUT_VERSION)
-        return DIERR_BETADIRECTINPUTVERSION;
-    else if (version > DIRECTINPUT_VERSION)
-        return DIERR_OLDDIRECTINPUTVERSION;
-
-    return initialize_directinput_instance( impl, version );
-}
-
-static HRESULT WINAPI dinput8_FindDevice( IDirectInput8W *iface, const GUID *guid, const WCHAR *name, GUID *instance_guid )
-{
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    return IDirectInput7_FindDevice( &impl->IDirectInput7W_iface, guid, name, instance_guid );
-}
-
-static BOOL should_enumerate_device( const WCHAR *username, DWORD flags, struct list *device_players, const GUID *guid )
-{
-    BOOL should_enumerate = TRUE;
-    struct DevicePlayer *device_player;
-
-    /* Check if user owns impl device */
-    if (flags & DIEDBSFL_THISUSER && username && *username)
-    {
-        should_enumerate = FALSE;
-        LIST_FOR_EACH_ENTRY(device_player, device_players, struct DevicePlayer, entry)
-        {
-            if (IsEqualGUID(&device_player->instance_guid, guid))
-            {
-                if (*device_player->username && !wcscmp( username, device_player->username ))
-                    return TRUE; /* Device username matches */
-                break;
-            }
-        }
-    }
-
-    /* Check if impl device is not owned by anyone */
-    if (flags & DIEDBSFL_AVAILABLEDEVICES)
-    {
-        BOOL found = FALSE;
-        should_enumerate = FALSE;
-        LIST_FOR_EACH_ENTRY(device_player, device_players, struct DevicePlayer, entry)
-        {
-            if (IsEqualGUID(&device_player->instance_guid, guid))
-            {
-                if (*device_player->username)
-                    found = TRUE;
-                break;
-            }
-        }
-        if (!found)
-            return TRUE; /* Device does not have a username */
-    }
-
-    return should_enumerate;
-}
-
-struct enum_device_by_semantics_params
-{
-    IDirectInput8W *iface;
-    const WCHAR *username;
-    DWORD flags;
-
-    DIDEVICEINSTANCEW *instances;
-    DWORD instance_count;
-};
-
-static BOOL CALLBACK enum_device_by_semantics( const DIDEVICEINSTANCEW *instance, void *context )
-{
-    struct enum_device_by_semantics_params *params = context;
-    struct dinput *impl = impl_from_IDirectInput8W( params->iface );
-
-    if (should_enumerate_device( params->username, params->flags, &impl->device_players, &instance->guidInstance ))
-    {
-        params->instance_count++;
-        params->instances = realloc( params->instances, sizeof(DIDEVICEINSTANCEW) * params->instance_count );
-        params->instances[params->instance_count - 1] = *instance;
-    }
-
-    return DIENUM_CONTINUE;
-}
-
-static HRESULT WINAPI dinput8_EnumDevicesBySemantics( IDirectInput8W *iface, const WCHAR *username, DIACTIONFORMATW *action_format,
-                                                      LPDIENUMDEVICESBYSEMANTICSCBW callback, void *context, DWORD flags )
-{
-    struct enum_device_by_semantics_params params = {.iface = iface, .username = username, .flags = flags};
-    DWORD callbackFlags, enum_flags = DIEDFL_ATTACHEDONLY | (flags & DIEDFL_FORCEFEEDBACK);
-    static const GUID *guids[2] = {&GUID_SysKeyboard, &GUID_SysMouse};
-    static const DWORD actionMasks[] = { DIKEYBOARD_MASK, DIMOUSE_MASK };
-    struct dinput *impl = impl_from_IDirectInput8W( iface );
-    DIDEVICEINSTANCEW didevi;
-    IDirectInputDevice8W *lpdid;
-    unsigned int i = 0;
-    HRESULT hr;
-    int remain;
-
-    FIXME( "iface %p, username %s, action_format %p, callback %p, context %p, flags %#lx stub!\n",
-           iface, debugstr_w(username), action_format, callback, context, flags );
-
-    didevi.dwSize = sizeof(didevi);
-
-    hr = IDirectInput8_EnumDevices( &impl->IDirectInput8W_iface, DI8DEVCLASS_GAMECTRL,
-                                    enum_device_by_semantics, &params, enum_flags );
-    if (FAILED(hr))
-    {
-        free( params.instances );
-        return hr;
-    }
-
-    remain = params.instance_count;
-    /* Add keyboard and mouse to remaining device count */
-    if (!(flags & DIEDBSFL_FORCEFEEDBACK))
-    {
-        for (i = 0; i < ARRAY_SIZE(guids); i++)
-        {
-            if (should_enumerate_device( username, flags, &impl->device_players, guids[i] )) remain++;
-        }
-    }
-
-    for (i = 0; i < params.instance_count; i++)
-    {
-        callbackFlags = diactionformat_priorityW( action_format, action_format->dwGenre );
-        IDirectInput_CreateDevice( iface, &params.instances[i].guidInstance, &lpdid, NULL );
-
-        if (callback( &params.instances[i], lpdid, callbackFlags, --remain, context ) == DIENUM_STOP)
-        {
-            free( params.instances );
-            IDirectInputDevice_Release(lpdid);
-            return DI_OK;
-        }
-        IDirectInputDevice_Release(lpdid);
-    }
-
-    free( params.instances );
-
-    if (flags & DIEDBSFL_FORCEFEEDBACK) return DI_OK;
-
-    /* Enumerate keyboard and mouse */
-    for (i = 0; i < ARRAY_SIZE(guids); i++)
-    {
-        if (should_enumerate_device( username, flags, &impl->device_players, guids[i] ))
-        {
-            callbackFlags = diactionformat_priorityW( action_format, actionMasks[i] );
-
-            IDirectInput_CreateDevice(iface, guids[i], &lpdid, NULL);
-            IDirectInputDevice_GetDeviceInfo(lpdid, &didevi);
-
-            if (callback( &didevi, lpdid, callbackFlags, --remain, context ) == DIENUM_STOP)
-            {
-                IDirectInputDevice_Release(lpdid);
-                return DI_OK;
-            }
-            IDirectInputDevice_Release(lpdid);
-        }
-    }
-
-    return DI_OK;
-}
-
-static HRESULT WINAPI dinput8_ConfigureDevices( IDirectInput8W *iface, LPDICONFIGUREDEVICESCALLBACK callback,
-                                                DICONFIGUREDEVICESPARAMSW *params, DWORD flags, void *context )
-{
-    FIXME( "iface %p, callback %p, params %p, flags %#lx, context %p stub!\n", iface, callback,
-           params, flags, context );
-
-    /* Call helper function in config.c to do the real work */
-    return _configure_devices( iface, callback, params, flags, context );
-}
-
-/*****************************************************************************
- * IDirectInputJoyConfig8 interface
- */
-
-static inline struct dinput *impl_from_IDirectInputJoyConfig8( IDirectInputJoyConfig8 *iface )
-{
-    return CONTAINING_RECORD( iface, struct dinput, IDirectInputJoyConfig8_iface );
-}
-
-static HRESULT WINAPI joy_config_QueryInterface( IDirectInputJoyConfig8 *iface, REFIID iid, void **out )
-{
-    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
-    return IDirectInput7_QueryInterface( &impl->IDirectInput7W_iface, iid, out );
-}
-
-static ULONG WINAPI joy_config_AddRef( IDirectInputJoyConfig8 *iface )
-{
-    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
-    return IDirectInput7_AddRef( &impl->IDirectInput7W_iface );
-}
-
-static ULONG WINAPI joy_config_Release( IDirectInputJoyConfig8 *iface )
-{
-    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
-    return IDirectInput7_Release( &impl->IDirectInput7W_iface );
-}
-
-static HRESULT WINAPI joy_config_Acquire( IDirectInputJoyConfig8 *iface )
-{
-    FIXME( "iface %p stub!\n", iface );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_Unacquire( IDirectInputJoyConfig8 *iface )
-{
-    FIXME( "iface %p stub!\n", iface );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_SetCooperativeLevel( IDirectInputJoyConfig8 *iface, HWND hwnd, DWORD flags )
-{
-    FIXME( "iface %p, hwnd %p, flags %#lx stub!\n", iface, hwnd, flags );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_SendNotify( IDirectInputJoyConfig8 *iface )
-{
-    FIXME( "iface %p stub!\n", iface );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_EnumTypes( IDirectInputJoyConfig8 *iface, LPDIJOYTYPECALLBACK callback, void *context )
-{
-    FIXME( "iface %p, callback %p, context %p stub!\n", iface, callback, context );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_GetTypeInfo( IDirectInputJoyConfig8 *iface, const WCHAR *name,
-                                              DIJOYTYPEINFO *info, DWORD flags )
-{
-    FIXME( "iface %p, name %s, info %p, flags %#lx stub!\n", iface, debugstr_w(name), info, flags );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_SetTypeInfo( IDirectInputJoyConfig8 *iface, const WCHAR *name,
-                                              const DIJOYTYPEINFO *info, DWORD flags, WCHAR *new_name )
-{
-    FIXME( "iface %p, name %s, info %p, flags %#lx, new_name %s stub!\n",
-           iface, debugstr_w(name), info, flags, debugstr_w(new_name) );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_DeleteType( IDirectInputJoyConfig8 *iface, const WCHAR *name )
-{
-    FIXME( "iface %p, name %s stub!\n", iface, debugstr_w(name) );
-    return E_NOTIMPL;
-}
-
-struct find_device_from_index_params
-{
-    UINT index;
-    DIDEVICEINSTANCEW instance;
-};
-
-static BOOL CALLBACK find_device_from_index( const DIDEVICEINSTANCEW *instance, void *context )
-{
-    struct find_device_from_index_params *params = context;
-    params->instance = *instance;
-    if (!params->index--) return DIENUM_STOP;
-    return DIENUM_CONTINUE;
-}
-
-static HRESULT WINAPI joy_config_GetConfig( IDirectInputJoyConfig8 *iface, UINT id, DIJOYCONFIG *info, DWORD flags )
-{
-    struct dinput *impl = impl_from_IDirectInputJoyConfig8( iface );
-    struct find_device_from_index_params params = {.index = id};
-    HRESULT hr;
-
-    FIXME( "iface %p, id %u, info %p, flags %#lx stub!\n", iface, id, info, flags );
-
-#define X(x) if (flags & x) FIXME("\tflags |= "#x"\n");
-    X(DIJC_GUIDINSTANCE)
-    X(DIJC_REGHWCONFIGTYPE)
-    X(DIJC_GAIN)
-    X(DIJC_CALLOUT)
-#undef X
-
-    hr = IDirectInput8_EnumDevices( &impl->IDirectInput8W_iface, DI8DEVCLASS_GAMECTRL,
-                                    find_device_from_index, &params, 0 );
-    if (FAILED(hr)) return hr;
-    if (params.index != ~0) return DIERR_NOMOREITEMS;
-    if (flags & DIJC_GUIDINSTANCE) info->guidInstance = params.instance.guidInstance;
-    return DI_OK;
-}
-
-static HRESULT WINAPI joy_config_SetConfig( IDirectInputJoyConfig8 *iface, UINT id, const DIJOYCONFIG *info, DWORD flags )
-{
-    FIXME( "iface %p, id %u, info %p, flags %#lx stub!\n", iface, id, info, flags );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_DeleteConfig( IDirectInputJoyConfig8 *iface, UINT id )
-{
-    FIXME( "iface %p, id %u stub!\n", iface, id );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_GetUserValues( IDirectInputJoyConfig8 *iface, DIJOYUSERVALUES *info, DWORD flags )
-{
-    FIXME( "iface %p, info %p, flags %#lx stub!\n", iface, info, flags );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_SetUserValues( IDirectInputJoyConfig8 *iface, const DIJOYUSERVALUES *info, DWORD flags )
-{
-    FIXME( "iface %p, info %p, flags %#lx stub!\n", iface, info, flags );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_AddNewHardware( IDirectInputJoyConfig8 *iface, HWND hwnd, const GUID *guid )
-{
-    FIXME( "iface %p, hwnd %p, guid %s stub!\n", iface, hwnd, debugstr_guid( guid ) );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_OpenTypeKey( IDirectInputJoyConfig8 *iface, const WCHAR *name, DWORD security, HKEY *key )
-{
-    FIXME( "iface %p, name %s, security %lu, key %p stub!\n", iface, debugstr_w(name), security, key );
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI joy_config_OpenAppStatusKey( IDirectInputJoyConfig8 *iface, HKEY *key )
-{
-    FIXME( "iface %p, key %p stub!\n", iface, key );
-    return E_NOTIMPL;
-}
-
-static const IDirectInput7WVtbl dinput7_vtbl =
-{
-    dinput7_QueryInterface,
-    dinput7_AddRef,
-    dinput7_Release,
-    dinput7_CreateDevice,
-    dinput7_EnumDevices,
-    dinput7_GetDeviceStatus,
-    dinput7_RunControlPanel,
-    dinput7_Initialize,
-    dinput7_FindDevice,
-    dinput7_CreateDeviceEx,
-};
-
-static const IDirectInput8WVtbl dinput8_vtbl =
-{
-    dinput8_QueryInterface,
-    dinput8_AddRef,
-    dinput8_Release,
-    dinput8_CreateDevice,
-    dinput8_EnumDevices,
-    dinput8_GetDeviceStatus,
-    dinput8_RunControlPanel,
-    dinput8_Initialize,
-    dinput8_FindDevice,
-    dinput8_EnumDevicesBySemantics,
-    dinput8_ConfigureDevices,
-};
-
-static const IDirectInputJoyConfig8Vtbl joy_config_vtbl =
-{
-    joy_config_QueryInterface,
-    joy_config_AddRef,
-    joy_config_Release,
-    joy_config_Acquire,
-    joy_config_Unacquire,
-    joy_config_SetCooperativeLevel,
-    joy_config_SendNotify,
-    joy_config_EnumTypes,
-    joy_config_GetTypeInfo,
-    joy_config_SetTypeInfo,
-    joy_config_DeleteType,
-    joy_config_GetConfig,
-    joy_config_SetConfig,
-    joy_config_DeleteConfig,
-    joy_config_GetUserValues,
-    joy_config_SetUserValues,
-    joy_config_AddNewHardware,
-    joy_config_OpenTypeKey,
-    joy_config_OpenAppStatusKey,
-};
-
-struct class_factory
-{
-    IClassFactory IClassFactory_iface;
-};
-
-static inline struct class_factory *impl_from_IClassFactory( IClassFactory *iface )
-{
-    return CONTAINING_RECORD( iface, struct class_factory, IClassFactory_iface );
-}
-
-static HRESULT WINAPI class_factory_QueryInterface( IClassFactory *iface, REFIID iid, void **out )
-{
-    struct class_factory *impl = impl_from_IClassFactory(iface);
-
-    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
-
-    if (IsEqualGUID(iid, &IID_IUnknown) ||
-        IsEqualGUID(iid, &IID_IClassFactory))
-        *out = &impl->IClassFactory_iface;
-    else
-    {
-        *out = NULL;
-        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
-        return E_NOINTERFACE;
-    }
-
-    IUnknown_AddRef((IUnknown *)*out);
-    return S_OK;
-}
-
-static ULONG WINAPI class_factory_AddRef( IClassFactory *iface )
-{
-    return 2;
-}
-
-static ULONG WINAPI class_factory_Release( IClassFactory *iface )
-{
-    return 1;
-}
-
-static HRESULT WINAPI class_factory_CreateInstance( IClassFactory *iface, IUnknown *outer, REFIID iid, void **out )
-{
-    IUnknown *unknown;
-    HRESULT hr;
-
-    TRACE( "iface %p, outer %p, iid %s, out %p.\n", iface, outer, debugstr_guid( iid ), out );
-
-    if (outer) return CLASS_E_NOAGGREGATION;
-
-    if (FAILED(hr = dinput_create( &unknown ))) return hr;
-    hr = IUnknown_QueryInterface( unknown, iid, out );
-    IUnknown_Release( unknown );
-
-    return hr;
-}
-
-static HRESULT WINAPI class_factory_LockServer( IClassFactory *iface, BOOL lock )
-{
-    FIXME( "iface %p, lock %d stub!\n", iface, lock );
-    return S_OK;
-}
-
-static const IClassFactoryVtbl class_factory_vtbl =
-{
-    class_factory_QueryInterface,
-    class_factory_AddRef,
-    class_factory_Release,
-    class_factory_CreateInstance,
-    class_factory_LockServer,
-};
-
-static struct class_factory class_factory = {{&class_factory_vtbl}};
-
-/***********************************************************************
- *		DllGetClassObject (DINPUT.@)
- */
-HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID iid, void **out )
-{
-    TRACE( "clsid %s, iid %s, out %p.\n", debugstr_guid( clsid ), debugstr_guid( iid ), out );
-
-#if DIRECTINPUT_VERSION == 0x0700
-    if (IsEqualCLSID( &CLSID_DirectInput, clsid ))
-        return IClassFactory_QueryInterface( &class_factory.IClassFactory_iface, iid, out );
-#else
-    if (IsEqualCLSID( &CLSID_DirectInput8, clsid ))
-        return IClassFactory_QueryInterface( &class_factory.IClassFactory_iface, iid, out );
-#endif
-
-    WARN( "%s not implemented, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid( clsid ) );
-    return CLASS_E_CLASSNOTAVAILABLE;
-}
-
-/******************************************************************************
- *	DInput hook thread
- */
-
-static LRESULT CALLBACK LL_hook_proc( int code, WPARAM wparam, LPARAM lparam )
-{
-    struct dinput_device *impl;
-    int skip = 0;
-
-    if (code != HC_ACTION) return CallNextHookEx( 0, code, wparam, lparam );
-
-    EnterCriticalSection( &dinput_hook_crit );
-    LIST_FOR_EACH_ENTRY( impl, &acquired_mouse_list, struct dinput_device, entry )
-    {
-        TRACE( "calling dinput_mouse_hook (%p %Ix %Ix)\n", impl, wparam, lparam );
-        skip |= dinput_mouse_hook( &impl->IDirectInputDevice8W_iface, wparam, lparam );
-    }
-    LIST_FOR_EACH_ENTRY( impl, &acquired_keyboard_list, struct dinput_device, entry )
-    {
-        if (impl->use_raw_input) continue;
-        TRACE( "calling dinput_keyboard_hook (%p %Ix %Ix)\n", impl, wparam, lparam );
-        skip |= dinput_keyboard_hook( &impl->IDirectInputDevice8W_iface, wparam, lparam );
-    }
-    LeaveCriticalSection( &dinput_hook_crit );
-
-    return skip ? 1 : CallNextHookEx( 0, code, wparam, lparam );
-}
-
-static LRESULT CALLBACK callwndproc_proc( int code, WPARAM wparam, LPARAM lparam )
-{
-    struct dinput_device *impl, *next;
-    CWPSTRUCT *msg = (CWPSTRUCT *)lparam;
-    HWND foreground;
-
-    if (code != HC_ACTION || (msg->message != WM_KILLFOCUS &&
-        msg->message != WM_ACTIVATEAPP && msg->message != WM_ACTIVATE))
-        return CallNextHookEx( 0, code, wparam, lparam );
-
-    foreground = GetForegroundWindow();
-
-    EnterCriticalSection( &dinput_hook_crit );
-    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_device_list, struct dinput_device, entry )
-    {
-        if (msg->hwnd == impl->win && msg->hwnd != foreground)
-        {
-            TRACE( "%p window is not foreground - unacquiring %p\n", impl->win, impl );
-            dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface );
-        }
-    }
-    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_mouse_list, struct dinput_device, entry )
-    {
-        if (msg->hwnd == impl->win && msg->hwnd != foreground)
-        {
-            TRACE( "%p window is not foreground - unacquiring %p\n", impl->win, impl );
-            dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface );
-        }
-    }
-    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_rawmouse_list, struct dinput_device, entry )
-    {
-        if (msg->hwnd == impl->win && msg->hwnd != foreground)
-        {
-            TRACE( "%p window is not foreground - unacquiring %p\n", impl->win, impl );
-            dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface );
-        }
-    }
-    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_keyboard_list, struct dinput_device, entry )
-    {
-        if (msg->hwnd == impl->win && msg->hwnd != foreground)
-        {
-            TRACE( "%p window is not foreground - unacquiring %p\n", impl->win, impl );
-            dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface );
-        }
-    }
-    LeaveCriticalSection( &dinput_hook_crit );
-
-    return CallNextHookEx( 0, code, wparam, lparam );
-}
-
 static DWORD WINAPI dinput_thread_proc( void *params )
 {
-    HANDLE events[128], start_event = params;
-    static HHOOK kbd_hook, mouse_hook;
-    struct dinput_device *impl, *next;
-    SIZE_T events_count = 0;
-    HANDLE finished_event;
+    struct input_thread_state state = {.running = TRUE};
+    struct dinput_device *device;
+    HANDLE start_event = params;
     DWORD ret;
     MSG msg;
 
     di_em_win = CreateWindowW( L"DIEmWin", L"DIEmWin", 0, 0, 0, 0, 0, HWND_MESSAGE, 0, DINPUT_instance, NULL );
-
-    /* Force creation of the message queue */
-    PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE );
+    input_thread_state = &state;
     SetEvent( start_event );
 
-    while ((ret = MsgWaitForMultipleObjectsEx( events_count, events, INFINITE, QS_ALLINPUT, 0 )) <= events_count)
+    while (state.running && (ret = MsgWaitForMultipleObjectsEx( state.events_count, state.events, INFINITE, QS_ALLINPUT, 0 )) <= state.events_count)
     {
-        UINT kbd_cnt = 0, mice_cnt = 0;
-
-        if (ret < events_count)
+        if (ret < state.events_count)
         {
-            EnterCriticalSection( &dinput_hook_crit );
-            LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_device_list, struct dinput_device, entry )
+            if ((device = state.devices[ret]) && FAILED( device->vtbl->read( &device->IDirectInputDevice8W_iface ) ))
             {
-                if (impl->read_event == events[ret])
-                {
-                    if (FAILED( impl->vtbl->read( &impl->IDirectInputDevice8W_iface ) ))
-                    {
-                        dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface );
-                        impl->status = STATUS_UNPLUGGED;
-                    }
-                    break;
-                }
+                EnterCriticalSection( &dinput_hook_crit );
+                dinput_device_internal_unacquire( &device->IDirectInputDevice8W_iface, STATUS_UNPLUGGED );
+                LeaveCriticalSection( &dinput_hook_crit );
+
+                state.events[ret] = state.events[--state.events_count];
+                state.devices[ret] = state.devices[state.events_count];
+                state.devices[state.events_count] = state.devices[--state.devices_count];
+                dinput_device_internal_release( device );
             }
-            LeaveCriticalSection( &dinput_hook_crit );
         }
 
         while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
         {
-            if (msg.message != WM_USER+0x10)
-            {
-                TranslateMessage(&msg);
-                DispatchMessageW(&msg);
-                continue;
-            }
-
-            finished_event = (HANDLE)msg.lParam;
-
-            TRACE( "Processing hook change notification wparam %#Ix, lparam %#Ix.\n", msg.wParam, msg.lParam );
-
-            if (!msg.wParam)
-            {
-                if (kbd_hook) UnhookWindowsHookEx( kbd_hook );
-                if (mouse_hook) UnhookWindowsHookEx( mouse_hook );
-                kbd_hook = mouse_hook = NULL;
-                goto done;
-            }
-
-            EnterCriticalSection( &dinput_hook_crit );
-            kbd_cnt = list_count( &acquired_keyboard_list );
-            mice_cnt = list_count( &acquired_mouse_list );
-            LeaveCriticalSection( &dinput_hook_crit );
-
-            if (kbd_cnt && !kbd_hook)
-                kbd_hook = SetWindowsHookExW( WH_KEYBOARD_LL, LL_hook_proc, DINPUT_instance, 0 );
-            else if (!kbd_cnt && kbd_hook)
-            {
-                UnhookWindowsHookEx( kbd_hook );
-                kbd_hook = NULL;
-            }
-
-            if (mice_cnt && !mouse_hook)
-                mouse_hook = SetWindowsHookExW( WH_MOUSE_LL, LL_hook_proc, DINPUT_instance, 0 );
-            else if (!mice_cnt && mouse_hook)
-            {
-                UnhookWindowsHookEx( mouse_hook );
-                mouse_hook = NULL;
-            }
-
-            SetEvent(finished_event);
-        }
-
-        events_count = 0;
-        EnterCriticalSection( &dinput_hook_crit );
-        LIST_FOR_EACH_ENTRY( impl, &acquired_device_list, struct dinput_device, entry )
-        {
-            if (!impl->read_event || !impl->vtbl->read) continue;
-            if (events_count >= ARRAY_SIZE(events)) break;
-            events[events_count++] = impl->read_event;
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
         }
-        LeaveCriticalSection( &dinput_hook_crit );
     }
 
-    if (ret != events_count) ERR("Unexpected termination, ret %#lx\n", ret);
+    if (state.running)
+    {
+        ERR( "Unexpected termination, ret %#lx\n", ret );
+        dinput_unacquire_devices();
+    }
 
-done:
+    while (state.devices_count--) dinput_device_internal_release( state.devices[state.devices_count] );
+    if (state.keyboard_ll_hook) UnhookWindowsHookEx( state.keyboard_ll_hook );
+    if (state.mouse_ll_hook) UnhookWindowsHookEx( state.mouse_ll_hook );
     DestroyWindow( di_em_win );
     di_em_win = NULL;
     return 0;
 }
 
-static BOOL WINAPI dinput_thread_start_once( INIT_ONCE *once, void *param, void **context )
+void input_thread_add_user(void)
 {
-    HANDLE start_event;
-
-    start_event = CreateEventW( NULL, FALSE, FALSE, NULL );
-    if (!start_event) ERR( "failed to create start event, error %lu\n", GetLastError() );
-
-    dinput_thread = CreateThread( NULL, 0, dinput_thread_proc, start_event, 0, &dinput_thread_id );
-    if (!dinput_thread) ERR( "failed to create internal thread, error %lu\n", GetLastError() );
-
-    WaitForSingleObject( start_event, INFINITE );
-    CloseHandle( start_event );
-
-    return TRUE;
-}
-
-static void dinput_thread_start(void)
-{
-    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
-    InitOnceExecuteOnce( &init_once, dinput_thread_start_once, NULL, NULL );
-}
-
-static void dinput_thread_stop(void)
-{
-    PostThreadMessageW( dinput_thread_id, WM_USER + 0x10, 0, 0 );
-    if (WaitForSingleObject( dinput_thread, 500 ) == WAIT_TIMEOUT)
-        WARN("Timeout while waiting for internal thread\n");
-    CloseHandle( dinput_thread );
-}
-
-void check_dinput_hooks( IDirectInputDevice8W *iface, BOOL acquired )
-{
-    static HHOOK callwndproc_hook;
-    static ULONG foreground_cnt;
-    struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
-    HANDLE hook_change_finished_event = NULL;
-
-    dinput_thread_start();
+    EnterCriticalSection( &dinput_hook_crit );
+    if (!input_thread_user_count++)
+    {
+        HANDLE start_event;
 
-    EnterCriticalSection(&dinput_hook_crit);
+        TRACE( "Starting input thread.\n" );
 
-    if (impl->dwCoopLevel & DISCL_FOREGROUND)
-    {
-        if (acquired)
-            foreground_cnt++;
+        if (!(start_event = CreateEventW( NULL, FALSE, FALSE, NULL )))
+            ERR( "Failed to create start event, error %lu\n", GetLastError() );
+        else if (!(dinput_thread = CreateThread( NULL, 0, dinput_thread_proc, start_event, 0, NULL )))
+            ERR( "Failed to create internal thread, error %lu\n", GetLastError() );
         else
-            foreground_cnt--;
-    }
+            WaitForSingleObject( start_event, INFINITE );
 
-    if (foreground_cnt && !callwndproc_hook)
-        callwndproc_hook = SetWindowsHookExW( WH_CALLWNDPROC, callwndproc_proc,
-                                              DINPUT_instance, GetCurrentThreadId() );
-    else if (!foreground_cnt && callwndproc_hook)
-    {
-        UnhookWindowsHookEx( callwndproc_hook );
-        callwndproc_hook = NULL;
+        CloseHandle( start_event );
     }
+    LeaveCriticalSection( &dinput_hook_crit );
+}
 
-    if (impl->use_raw_input)
+void input_thread_remove_user(void)
+{
+    EnterCriticalSection( &dinput_hook_crit );
+    if (!--input_thread_user_count)
     {
-        if (acquired)
-        {
-            impl->raw_device.dwFlags = 0;
-            if (impl->dwCoopLevel & DISCL_BACKGROUND)
-                impl->raw_device.dwFlags |= RIDEV_INPUTSINK;
-            if (impl->dwCoopLevel & DISCL_EXCLUSIVE)
-                impl->raw_device.dwFlags |= RIDEV_NOLEGACY;
-            if ((impl->dwCoopLevel & DISCL_EXCLUSIVE) && impl->raw_device.usUsage == 2)
-                impl->raw_device.dwFlags |= RIDEV_CAPTUREMOUSE;
-            if ((impl->dwCoopLevel & DISCL_EXCLUSIVE) && impl->raw_device.usUsage == 6)
-                impl->raw_device.dwFlags |= RIDEV_NOHOTKEYS;
-            impl->raw_device.hwndTarget = di_em_win;
-        }
-        else
-        {
-            impl->raw_device.dwFlags = RIDEV_REMOVE;
-            impl->raw_device.hwndTarget = NULL;
-        }
+        TRACE( "Stopping input thread.\n" );
 
-        if (!RegisterRawInputDevices( &impl->raw_device, 1, sizeof(RAWINPUTDEVICE) ))
-            WARN( "Unable to (un)register raw device %x:%x\n", impl->raw_device.usUsagePage, impl->raw_device.usUsage );
+        SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_THREAD_STOP, 0 );
+        WaitForSingleObject( dinput_thread, INFINITE );
+        CloseHandle( dinput_thread );
     }
-
-    hook_change_finished_event = CreateEventW( NULL, FALSE, FALSE, NULL );
-    PostThreadMessageW( dinput_thread_id, WM_USER + 0x10, 1, (LPARAM)hook_change_finished_event );
-
-    LeaveCriticalSection(&dinput_hook_crit);
-
-    WaitForSingleObject(hook_change_finished_event, INFINITE);
-    CloseHandle(hook_change_finished_event);
+    LeaveCriticalSection( &dinput_hook_crit );
 }
 
 void check_dinput_events(void)
@@ -1444,7 +493,6 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, void *reserved )
         break;
       case DLL_PROCESS_DETACH:
         if (reserved) break;
-        dinput_thread_stop();
         unregister_di_em_win_class();
         break;
     }
diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
index de48c4c5298..944d12b860f 100644
--- a/dlls/dinput/dinput_private.h
+++ b/dlls/dinput/dinput_private.h
@@ -29,7 +29,6 @@
 
 extern HINSTANCE DINPUT_instance;
 
-/* Implementation specification */
 struct dinput
 {
     IDirectInput7A IDirectInput7A_iface;
@@ -37,9 +36,9 @@ struct dinput
     IDirectInput8A IDirectInput8A_iface;
     IDirectInput8W IDirectInput8W_iface;
     IDirectInputJoyConfig8 IDirectInputJoyConfig8_iface;
+    LONG internal_ref;
     LONG ref;
 
-    BOOL initialized;
     DWORD dwVersion;            /* direct input version number */
     DWORD evsequence;           /* unique sequence number for events */
     struct list device_players; /* device instance guid to player name */
@@ -48,6 +47,9 @@ struct dinput
 extern const IDirectInput7AVtbl dinput7_a_vtbl DECLSPEC_HIDDEN;
 extern const IDirectInput8AVtbl dinput8_a_vtbl DECLSPEC_HIDDEN;
 
+extern void dinput_internal_addref( struct dinput *dinput );
+extern void dinput_internal_release( struct dinput *dinput );
+
 extern HRESULT mouse_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version );
 extern HRESULT mouse_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out );
 extern HRESULT keyboard_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version );
@@ -61,14 +63,18 @@ struct DevicePlayer {
     struct list entry;
 };
 
+extern void input_thread_add_user(void);
+extern void input_thread_remove_user(void);
+
 extern void dinput_hooks_acquire_device( IDirectInputDevice8W *iface );
 extern void dinput_hooks_unacquire_device( IDirectInputDevice8W *iface );
 extern int dinput_mouse_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam );
 extern int dinput_keyboard_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam );
 extern void dinput_mouse_rawinput_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam,
                                         RAWINPUT *raw );
+extern void dinput_keyboard_rawinput_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam,
+                                           RAWINPUT *raw );
 
-extern void check_dinput_hooks( IDirectInputDevice8W *iface, BOOL acquired ) DECLSPEC_HIDDEN;
 extern void check_dinput_events(void) DECLSPEC_HIDDEN;
 
 extern HRESULT _configure_devices(IDirectInput8W *iface, LPDICONFIGUREDEVICESCALLBACK lpdiCallback, LPDICONFIGUREDEVICESPARAMSW lpdiCDParams, DWORD dwFlags, LPVOID pvRefData) DECLSPEC_HIDDEN;
diff --git a/dlls/dinput/joystick_hid.c b/dlls/dinput/joystick_hid.c
index 41fd0e24963..6846410e02c 100644
--- a/dlls/dinput/joystick_hid.c
+++ b/dlls/dinput/joystick_hid.c
@@ -172,7 +172,6 @@ struct pid_effect_state
 struct hid_joystick
 {
     struct dinput_device base;
-    LONG internal_ref;
 
     HANDLE device;
     OVERLAPPED read_ovl;
@@ -775,30 +774,18 @@ static void set_report_value( struct hid_joystick *impl, char *report_buf,
                                              caps->usage_page, caps->usage_min, status );
 }
 
-static void hid_joystick_addref( IDirectInputDevice8W *iface )
+static void hid_joystick_destroy( IDirectInputDevice8W *iface )
 {
     struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
-    ULONG ref = InterlockedIncrement( &impl->internal_ref );
-    TRACE( "iface %p, internal ref %lu.\n", iface, ref );
-}
-
-static void hid_joystick_release( IDirectInputDevice8W *iface )
-{
-    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
-    ULONG ref = InterlockedDecrement( &impl->internal_ref );
-    TRACE( "iface %p, internal ref %lu.\n", iface, ref );
+    TRACE( "iface %p.\n", iface );
 
-    if (!ref)
-    {
-        free( impl->usages_buf );
-        free( impl->feature_report_buf );
-        free( impl->output_report_buf );
-        free( impl->input_report_buf );
-        HidD_FreePreparsedData( impl->preparsed );
-        CloseHandle( impl->base.read_event );
-        CloseHandle( impl->device );
-        dinput_device_destroy( iface );
-    }
+    free( impl->usages_buf );
+    free( impl->feature_report_buf );
+    free( impl->output_report_buf );
+    free( impl->input_report_buf );
+    HidD_FreePreparsedData( impl->preparsed );
+    CloseHandle( impl->base.read_event );
+    CloseHandle( impl->device );
 }
 
 static HRESULT hid_joystick_get_property( IDirectInputDevice8W *iface, DWORD property,
@@ -1367,7 +1354,7 @@ static HRESULT hid_joystick_enum_objects( IDirectInputDevice8W *iface, const DIP
 
 static const struct dinput_device_vtbl hid_joystick_vtbl =
 {
-    hid_joystick_release,
+    hid_joystick_destroy,
     NULL,
     hid_joystick_read,
     hid_joystick_acquire,
@@ -2036,7 +2023,6 @@ HRESULT hid_joystick_create_device( struct dinput *dinput, const GUID *guid, IDi
     impl->base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": hid_joystick.base.crit");
     impl->base.dwCoopLevel = DISCL_NONEXCLUSIVE | DISCL_BACKGROUND;
     impl->base.read_event = CreateEventW( NULL, TRUE, FALSE, NULL );
-    impl->internal_ref = 1;
 
     if (memcmp( device_path_guid.Data4, guid->Data4, sizeof(device_path_guid.Data4) ))
         hr = hid_joystick_device_open( -1, guid, &impl->base.instance, impl->device_path, &impl->device, &impl->preparsed,
@@ -2163,7 +2149,7 @@ static ULONG WINAPI hid_joystick_effect_Release( IDirectInputEffect *iface )
         EnterCriticalSection( &impl->joystick->base.crit );
         list_remove( &impl->entry );
         LeaveCriticalSection( &impl->joystick->base.crit );
-        hid_joystick_release( &impl->joystick->base.IDirectInputDevice8W_iface );
+        dinput_device_internal_release( &impl->joystick->base );
         free( impl->set_envelope_buf );
         free( impl->type_specific_buf );
         free( impl->effect_update_buf );
@@ -2641,7 +2627,9 @@ static HRESULT WINAPI hid_joystick_effect_SetParameters( IDirectInputEffect *ifa
         impl->params.cbTypeSpecificParams = params->cbTypeSpecificParams;
     }
 
-    if ((flags & DIEP_ENVELOPE) && params->lpEnvelope)
+    if (!(flags & DIEP_ENVELOPE))
+        TRACE( "Keeping previous effect envelope\n" );
+    else if (params->lpEnvelope)
     {
         if (params->lpEnvelope->dwSize != sizeof(DIENVELOPE)) return DIERR_INVALIDPARAM;
         impl->params.lpEnvelope = &impl->envelope;
@@ -2649,6 +2637,13 @@ static HRESULT WINAPI hid_joystick_effect_SetParameters( IDirectInputEffect *ifa
             impl->modified |= DIEP_ENVELOPE;
         memcpy( impl->params.lpEnvelope, params->lpEnvelope, sizeof(DIENVELOPE) );
     }
+    else
+    {
+        flags &= ~DIEP_ENVELOPE;
+        impl->flags &= ~DIEP_ENVELOPE;
+        impl->modified &= ~DIEP_ENVELOPE;
+        impl->params.lpEnvelope = NULL;
+    }
 
     if (flags & DIEP_DURATION)
     {
@@ -3146,7 +3141,7 @@ static HRESULT hid_joystick_create_effect( IDirectInputDevice8W *iface, IDirectI
     impl->IDirectInputEffect_iface.lpVtbl = &hid_joystick_effect_vtbl;
     impl->ref = 1;
     impl->joystick = joystick;
-    hid_joystick_addref( &joystick->base.IDirectInputDevice8W_iface );
+    dinput_device_internal_addref( &joystick->base );
 
     EnterCriticalSection( &joystick->base.crit );
     list_add_tail( &joystick->effect_list, &impl->entry );
diff --git a/dlls/dinput/keyboard.c b/dlls/dinput/keyboard.c
index 873a2d98434..c49796cfa2d 100644
--- a/dlls/dinput/keyboard.c
+++ b/dlls/dinput/keyboard.c
@@ -83,22 +83,13 @@ static BYTE map_dik_code(DWORD scanCode, DWORD vkCode, DWORD subType, DWORD vers
     return (BYTE)scanCode;
 }
 
-int dinput_keyboard_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam )
+static void keyboard_handle_event( struct keyboard *impl, DWORD vkey, DWORD scan_code, BOOL up )
 {
-    struct keyboard *impl = impl_from_IDirectInputDevice8W( iface );
     BYTE new_diks, subtype = GET_DIDEVICE_SUBTYPE( impl->base.instance.dwDevType );
-    int dik_code, ret = impl->base.dwCoopLevel & DISCL_EXCLUSIVE;
-    KBDLLHOOKSTRUCT *hook = (KBDLLHOOKSTRUCT *)lparam;
-    DWORD scan_code;
-
-    if (wparam != WM_KEYDOWN && wparam != WM_KEYUP &&
-        wparam != WM_SYSKEYDOWN && wparam != WM_SYSKEYUP)
-        return 0;
-
-    TRACE( "iface %p, wparam %#Ix, lparam %#Ix, vkCode %#lx, scanCode %#lx.\n", iface, wparam,
-           lparam, hook->vkCode, hook->scanCode );
+    IDirectInputDevice8W *iface = &impl->base.IDirectInputDevice8W_iface;
+    int dik_code;
 
-    switch (hook->vkCode)
+    switch (vkey)
     {
         /* R-Shift is special - it is an extended key with separate scan code */
         case VK_RSHIFT  : dik_code = DIK_RSHIFT; break;
@@ -106,25 +97,53 @@ int dinput_keyboard_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lpa
         case VK_NUMLOCK : dik_code = DIK_NUMLOCK; break;
         case VK_SUBTRACT: dik_code = DIK_SUBTRACT; break;
         default:
-            scan_code = hook->scanCode & 0xff;
-            if (hook->flags & LLKHF_EXTENDED) scan_code |= 0x100;
-            dik_code = map_dik_code( scan_code, hook->vkCode, subtype, impl->base.dinput->dwVersion );
+            dik_code = map_dik_code( scan_code, vkey, subtype, impl->base.dinput->dwVersion );
+            break;
     }
-    new_diks = hook->flags & LLKHF_UP ? 0 : 0x80;
+    new_diks = (up ? 0 : 0x80);
 
     /* returns now if key event already known */
-    if (new_diks == impl->base.device_state[dik_code]) return ret;
+    if (new_diks == impl->base.device_state[dik_code]) return;
 
     impl->base.device_state[dik_code] = new_diks;
-    TRACE( " setting key %02x to %02x\n", dik_code, impl->base.device_state[dik_code] );
+    TRACE( "setting key %02x to %02x\n", dik_code, impl->base.device_state[dik_code] );
 
     EnterCriticalSection( &impl->base.crit );
     queue_event( iface, DIDFT_MAKEINSTANCE( dik_code ) | DIDFT_PSHBUTTON, new_diks,
                  GetCurrentTime(), impl->base.dinput->evsequence++ );
     if (impl->base.hEvent) SetEvent( impl->base.hEvent );
     LeaveCriticalSection( &impl->base.crit );
+}
+
+void dinput_keyboard_rawinput_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam, RAWINPUT *ri )
+{
+    struct keyboard *impl = impl_from_IDirectInputDevice8W( iface );
+    DWORD scan_code;
+
+    TRACE("(%p) wparam %Ix, lparam %Ix\n", iface, wparam, lparam);
 
-    return ret;
+    scan_code = ri->data.keyboard.MakeCode & 0xff;
+    if (ri->data.keyboard.Flags & RI_KEY_E0) scan_code |= 0x100;
+    keyboard_handle_event( impl, ri->data.keyboard.VKey, scan_code, ri->data.keyboard.Flags & RI_KEY_BREAK );
+}
+
+int dinput_keyboard_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam )
+{
+    struct keyboard *impl = impl_from_IDirectInputDevice8W( iface );
+    KBDLLHOOKSTRUCT *hook = (KBDLLHOOKSTRUCT *)lparam;
+    DWORD scan_code;
+
+    TRACE( "iface %p, wparam %#Ix, lparam %#Ix, vkCode %#lx, scanCode %#lx.\n", iface, wparam,
+           lparam, hook->vkCode, hook->scanCode );
+
+    if (wparam != WM_KEYDOWN && wparam != WM_KEYUP && wparam != WM_SYSKEYDOWN && wparam != WM_SYSKEYUP)
+        return 0;
+
+    scan_code = hook->scanCode & 0xff;
+    if (hook->flags & LLKHF_EXTENDED) scan_code |= 0x100;
+    keyboard_handle_event( impl, hook->vkCode, scan_code, hook->flags & LLKHF_UP );
+
+    return impl->base.dwCoopLevel & DISCL_EXCLUSIVE;
 }
 
 static DWORD get_keyboard_subtype(void)
@@ -182,6 +201,9 @@ HRESULT keyboard_create_device( struct dinput *dinput, const GUID *guid, IDirect
     impl->base.caps.dwFirmwareRevision = 100;
     impl->base.caps.dwHardwareRevision = 100;
 
+    if (dinput->dwVersion >= 0x0800)
+        impl->base.use_raw_input = TRUE;
+
     *out = &impl->base.IDirectInputDevice8W_iface;
     return DI_OK;
 }
diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
index ee172547a30..502ee797716 100644
--- a/dlls/dinput/mouse.c
+++ b/dlls/dinput/mouse.c
@@ -148,11 +148,7 @@ HRESULT mouse_create_device( struct dinput *dinput, const GUID *guid, IDirectInp
     if (hkey) RegCloseKey(hkey);
 
     if (dinput->dwVersion >= 0x0800)
-    {
         impl->base.use_raw_input = TRUE;
-        impl->base.raw_device.usUsagePage = 1; /* HID generic device page */
-        impl->base.raw_device.usUsage = 2;     /* HID generic mouse */
-    }
 
     *out = &impl->base.IDirectInputDevice8W_iface;
     return DI_OK;
@@ -256,7 +252,6 @@ void dinput_mouse_rawinput_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPA
     LeaveCriticalSection( &impl->base.crit );
 }
 
-/* low-level mouse hook */
 int dinput_mouse_hook( IDirectInputDevice8W *iface, WPARAM wparam, LPARAM lparam )
 {
     MSLLHOOKSTRUCT *hook = (MSLLHOOKSTRUCT *)lparam;
@@ -416,7 +411,6 @@ static HRESULT mouse_acquire( IDirectInputDevice8W *iface )
     DIMOUSESTATE2 *state = (DIMOUSESTATE2 *)impl->base.device_state;
     POINT point;
 
-    /* Init the mouse state */
     GetCursorPos( &point );
     if (impl->base.user_format.dwFlags & DIDF_ABSAXIS)
     {
@@ -436,7 +430,7 @@ static HRESULT mouse_acquire( IDirectInputDevice8W *iface )
 
     if (impl->base.dwCoopLevel & DISCL_EXCLUSIVE)
     {
-        ShowCursor( FALSE ); /* hide cursor */
+        ShowCursor( FALSE );
         warp_check( impl, TRUE );
     }
     else if (impl->warp_override == WARP_FORCE_ON)
@@ -461,7 +455,7 @@ static HRESULT mouse_unacquire( IDirectInputDevice8W *iface )
     if (impl->base.dwCoopLevel & DISCL_EXCLUSIVE)
     {
         ClipCursor( NULL );
-        ShowCursor( TRUE ); /* show cursor */
+        ShowCursor( TRUE );
         impl->clipped = FALSE;
     }
 
diff --git a/dlls/dinput/tests/device8.c b/dlls/dinput/tests/device8.c
index 86f0360c0f1..1f29c9af519 100644
--- a/dlls/dinput/tests/device8.c
+++ b/dlls/dinput/tests/device8.c
@@ -116,7 +116,6 @@ static HRESULT create_dinput_device( DWORD version, const GUID *guid, IDirectInp
     ok( hr == DI_OK, "CreateDevice returned %#lx\n", hr );
 
     ref = IDirectInput_Release( dinput );
-    todo_wine
     ok( ref == 0, "Release returned %ld\n", ref );
 
     return DI_OK;
@@ -1100,15 +1099,11 @@ static void test_mouse_keyboard(void)
     raw_devices_count = ARRAY_SIZE(raw_devices);
     memset(raw_devices, 0, sizeof(raw_devices));
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-    todo_wine
     ok(hr == 1, "GetRegisteredRawInputDevices returned %ld, raw_devices_count: %d\n", hr, raw_devices_count);
-    todo_wine
     ok(raw_devices[0].usUsagePage == HID_USAGE_PAGE_GENERIC, "got usUsagePage: %x\n", raw_devices[0].usUsagePage);
-    todo_wine
     ok(raw_devices[0].usUsage == HID_USAGE_GENERIC_KEYBOARD, "got usUsage: %x\n", raw_devices[0].usUsage);
     todo_wine
     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %#lx\n", raw_devices[0].dwFlags);
-    todo_wine
     ok(raw_devices[0].hwndTarget != NULL, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
     hr = IDirectInputDevice8_Unacquire(di_keyboard);
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %#lx\n", hr);
@@ -1140,7 +1135,6 @@ static void test_mouse_keyboard(void)
     ok(raw_devices[0].usUsagePage == HID_USAGE_PAGE_GENERIC, "got usUsagePage: %x\n", raw_devices[0].usUsagePage);
     ok(raw_devices[0].usUsage == HID_USAGE_GENERIC_MOUSE, "got usUsage: %x\n", raw_devices[0].usUsage);
     ok(raw_devices[0].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %#lx\n", raw_devices[0].dwFlags);
-    todo_wine
     ok(raw_devices[0].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[0].hwndTarget);
     hr = IDirectInputDevice8_Unacquire(di_mouse);
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %#lx\n", hr);
@@ -1186,9 +1180,6 @@ static void test_mouse_keyboard(void)
     ok(raw_devices[1].hwndTarget == hwnd, "Unexpected raw device target: %p\n", raw_devices[1].hwndTarget);
     ok(raw_devices[2].usUsagePage == HID_USAGE_PAGE_GENERIC, "got usUsagePage: %x\n", raw_devices[1].usUsagePage);
     ok(raw_devices[2].usUsage == HID_USAGE_GENERIC_KEYBOARD, "got usUsage: %x\n", raw_devices[1].usUsage);
-    todo_wine
-    ok(raw_devices[2].dwFlags == RIDEV_INPUTSINK, "Unexpected raw device flags: %#lx\n", raw_devices[1].dwFlags);
-    todo_wine
     ok(raw_devices[2].hwndTarget == di_hwnd, "Unexpected raw device target: %p\n", raw_devices[1].hwndTarget);
     hr = IDirectInputDevice8_Unacquire(di_keyboard);
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %#lx\n", hr);
@@ -1196,7 +1187,6 @@ static void test_mouse_keyboard(void)
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %#lx\n", hr);
     raw_devices_count = ARRAY_SIZE(raw_devices);
     GetRegisteredRawInputDevices(NULL, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-    todo_wine
     ok(raw_devices_count == 1, "Unexpected raw devices registered: %d\n", raw_devices_count);
 
     IDirectInputDevice8_SetCooperativeLevel(di_mouse, hwnd, DISCL_FOREGROUND|DISCL_EXCLUSIVE);
@@ -1211,7 +1201,6 @@ static void test_mouse_keyboard(void)
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
     ok(hr == 3, "GetRegisteredRawInputDevices returned %ld, raw_devices_count: %d\n", hr, raw_devices_count);
     ok(raw_devices[0].dwFlags == (RIDEV_CAPTUREMOUSE|RIDEV_NOLEGACY), "Unexpected raw device flags: %#lx\n", raw_devices[0].dwFlags);
-    todo_wine
     ok(raw_devices[2].dwFlags == (RIDEV_NOHOTKEYS|RIDEV_NOLEGACY), "Unexpected raw device flags: %#lx\n", raw_devices[1].dwFlags);
     hr = IDirectInputDevice8_Unacquire(di_keyboard);
     ok(SUCCEEDED(hr), "IDirectInputDevice8_Acquire failed: %#lx\n", hr);
@@ -1220,7 +1209,6 @@ static void test_mouse_keyboard(void)
 
     raw_devices_count = ARRAY_SIZE(raw_devices);
     hr = GetRegisteredRawInputDevices(raw_devices, &raw_devices_count, sizeof(RAWINPUTDEVICE));
-    todo_wine
     ok(hr == 1, "GetRegisteredRawInputDevices returned %ld, raw_devices_count: %d\n", hr, raw_devices_count);
     ok(raw_devices[0].usUsagePage == HID_USAGE_PAGE_GENERIC, "got usUsagePage: %x\n", raw_devices[0].usUsagePage);
     ok(raw_devices[0].usUsage == HID_USAGE_GENERIC_GAMEPAD, "got usUsage: %x\n", raw_devices[0].usUsage);
diff --git a/dlls/dinput/tests/force_feedback.c b/dlls/dinput/tests/force_feedback.c
index 1e68748a07d..52afccf6db1 100644
--- a/dlls/dinput/tests/force_feedback.c
+++ b/dlls/dinput/tests/force_feedback.c
@@ -458,14 +458,6 @@ static void test_periodic_effect( IDirectInputDevice8W *device, HANDLE file, DWO
             .report_len = 2,
             .report_buf = {0x05,0x19},
         },
-        /* set envelope (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 6,
-            .report_len = 7,
-            .report_buf = {0x06,0x19,0x4c,0x01,0x00,0x04,0x00},
-            .todo = TRUE, .wine_only = TRUE,
-        },
         /* update effect */
         {
             .code = IOCTL_HID_WRITE_REPORT,
@@ -4734,6 +4726,8 @@ static void check_result_async_( int line, IAsyncOperation_ForceFeedbackLoadEffe
 struct bool_async_handler
 {
     IAsyncOperationCompletedHandler_boolean IAsyncOperationCompletedHandler_boolean_iface;
+    LONG refcount;
+
     IAsyncOperation_boolean *async;
     AsyncStatus status;
     BOOL invoked;
@@ -4763,12 +4757,16 @@ static HRESULT WINAPI bool_async_handler_QueryInterface( IAsyncOperationComplete
 
 static ULONG WINAPI bool_async_handler_AddRef( IAsyncOperationCompletedHandler_boolean *iface )
 {
-    return 2;
+    struct bool_async_handler *impl = impl_from_IAsyncOperationCompletedHandler_boolean( iface );
+    return InterlockedIncrement( &impl->refcount );
 }
 
 static ULONG WINAPI bool_async_handler_Release( IAsyncOperationCompletedHandler_boolean *iface )
 {
-    return 1;
+    struct bool_async_handler *impl = impl_from_IAsyncOperationCompletedHandler_boolean( iface );
+    ULONG ref = InterlockedDecrement( &impl->refcount );
+    if (!ref) free( impl );
+    return ref;
 }
 
 static HRESULT WINAPI bool_async_handler_Invoke( IAsyncOperationCompletedHandler_boolean *iface,
@@ -4797,28 +4795,46 @@ static IAsyncOperationCompletedHandler_booleanVtbl bool_async_handler_vtbl =
     bool_async_handler_Invoke,
 };
 
-static struct bool_async_handler default_bool_async_handler = {{&bool_async_handler_vtbl}};
+static IAsyncOperationCompletedHandler_boolean *bool_async_handler_create( HANDLE event )
+{
+    struct bool_async_handler *impl;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return NULL;
+    impl->IAsyncOperationCompletedHandler_boolean_iface.lpVtbl = &bool_async_handler_vtbl;
+    impl->event = event;
+    impl->refcount = 1;
+
+    return &impl->IAsyncOperationCompletedHandler_boolean_iface;
+}
 
 #define await_bool( a ) await_bool_( __LINE__, a )
 static void await_bool_( int line, IAsyncOperation_boolean *async )
 {
-    struct bool_async_handler handler = default_bool_async_handler;
+    IAsyncOperationCompletedHandler_boolean *handler;
+    HANDLE event;
     HRESULT hr;
     DWORD ret;
 
-    handler.event = CreateEventW( NULL, FALSE, FALSE, NULL );
-    ok_(__FILE__, line)( !!handler.event, "CreateEventW failed, error %lu\n", GetLastError() );
-    hr = IAsyncOperation_boolean_put_Completed( async, &handler.IAsyncOperationCompletedHandler_boolean_iface );
+    event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ok_(__FILE__, line)( !!event, "CreateEventW failed, error %lu\n", GetLastError() );
+
+    handler = bool_async_handler_create( event );
+    ok_(__FILE__, line)( !!handler, "bool_async_handler_create failed\n" );
+    hr = IAsyncOperation_boolean_put_Completed( async, handler );
     ok_(__FILE__, line)( hr == S_OK, "put_Completed returned %#lx\n", hr );
-    ret = WaitForSingleObject( handler.event, 5000 );
+    IAsyncOperationCompletedHandler_boolean_Release( handler );
+
+    ret = WaitForSingleObject( event, 5000 );
     ok_(__FILE__, line)( !ret, "WaitForSingleObject returned %#lx\n", ret );
-    ret = CloseHandle( handler.event );
+    ret = CloseHandle( event );
     ok_(__FILE__, line)( ret, "CloseHandle failed, error %lu\n", GetLastError() );
 }
 
 struct result_async_handler
 {
     IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult_iface;
+    LONG refcount;
+
     IAsyncOperation_ForceFeedbackLoadEffectResult *async;
     AsyncStatus status;
     BOOL invoked;
@@ -4848,12 +4864,16 @@ static HRESULT WINAPI result_async_handler_QueryInterface( IAsyncOperationComple
 
 static ULONG WINAPI result_async_handler_AddRef( IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult *iface )
 {
-    return 2;
+    struct result_async_handler *impl = impl_from_IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult( iface );
+    return InterlockedIncrement( &impl->refcount );
 }
 
 static ULONG WINAPI result_async_handler_Release( IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult *iface )
 {
-    return 1;
+    struct result_async_handler *impl = impl_from_IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult( iface );
+    ULONG ref = InterlockedDecrement( &impl->refcount );
+    if (!ref) free( impl );
+    return ref;
 }
 
 static HRESULT WINAPI result_async_handler_Invoke( IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult *iface,
@@ -4882,22 +4902,38 @@ static IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResultVtbl result_
     result_async_handler_Invoke,
 };
 
-static struct result_async_handler default_result_async_handler = {{&result_async_handler_vtbl}};
+static IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult *result_async_handler_create( HANDLE event )
+{
+    struct result_async_handler *impl;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return NULL;
+    impl->IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult_iface.lpVtbl = &result_async_handler_vtbl;
+    impl->event = event;
+    impl->refcount = 1;
+
+    return &impl->IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult_iface;
+}
 
 #define await_result( a ) await_result_( __LINE__, a )
 static void await_result_( int line, IAsyncOperation_ForceFeedbackLoadEffectResult *async )
 {
-    struct result_async_handler handler = default_result_async_handler;
+    IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult *handler;
+    HANDLE event;
     HRESULT hr;
     DWORD ret;
 
-    handler.event = CreateEventW( NULL, FALSE, FALSE, NULL );
-    ok_(__FILE__, line)( !!handler.event, "CreateEventW failed, error %lu\n", GetLastError() );
-    hr = IAsyncOperation_ForceFeedbackLoadEffectResult_put_Completed( async, &handler.IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult_iface );
+    event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ok_(__FILE__, line)( !!event, "CreateEventW failed, error %lu\n", GetLastError() );
+
+    handler = result_async_handler_create( event );
+    ok_(__FILE__, line)( !!handler, "result_async_handler_create failed\n" );
+    hr = IAsyncOperation_ForceFeedbackLoadEffectResult_put_Completed( async, handler );
     ok_(__FILE__, line)( hr == S_OK, "put_Completed returned %#lx\n", hr );
-    ret = WaitForSingleObject( handler.event, 5000 );
+    IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult_Release( handler );
+
+    ret = WaitForSingleObject( event, 5000 );
     ok_(__FILE__, line)( !ret, "WaitForSingleObject returned %#lx\n", ret );
-    ret = CloseHandle( handler.event );
+    ret = CloseHandle( event );
     ok_(__FILE__, line)( ret, "CloseHandle failed, error %lu\n", GetLastError() );
 }
 
@@ -5683,14 +5719,6 @@ static void test_windows_gaming_input(void)
             .report_len = 10,
             .report_buf = {7,0x01,0x10,0x27,0x00,0x00,0x70,0xff,0xe8,0x03},
         },
-        /* set envelope (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 8,
-            .report_len = 8,
-            .report_buf = {8,0x01,0x00,0x00,0x00,0x00,0x00,0x00},
-            .todo = TRUE, .wine_only = TRUE,
-        },
         /* update effect */
         {
             .code = IOCTL_HID_WRITE_REPORT,
@@ -5822,29 +5850,12 @@ static void test_windows_gaming_input(void)
             .report_len = 4,
             .report_buf = {9,0x01,0x18,0xfc},
         },
-        /* set envelope (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 8,
-            .report_len = 8,
-            .report_buf = {8,0x01,0x00,0x00,0x00,0x00,0x00,0x00},
-            .todo = TRUE, .wine_only = TRUE,
-        },
-        /* update effect (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 3,
-            .report_len = 18,
-            .report_buf = {3,0x01,0x04,0x04,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x7f,0x99,0x00,0x00,0x00},
-            .wine_only = TRUE, .todo = TRUE,
-        },
         /* update effect */
         {
             .code = IOCTL_HID_WRITE_REPORT,
             .report_id = 3,
             .report_len = 18,
             .report_buf = {3,0x01,0x04,0x04,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x7f,0x4e,0x01,0x00,0x00},
-            .todo = TRUE,
         },
     };
     struct hid_expect expect_create_ramp[] =
@@ -5908,29 +5919,12 @@ static void test_windows_gaming_input(void)
             .report_len = 6,
             .report_buf = {10,0x01,0xe8,0x03,0xa0,0x0f},
         },
-        /* set envelope (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 8,
-            .report_len = 8,
-            .report_buf = {8,0x01,0x00,0x00,0x00,0x00,0x00,0x00},
-            .todo = TRUE, .wine_only = TRUE,
-        },
-        /* update effect (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 3,
-            .report_len = 18,
-            .report_buf = {3,0x01,0x05,0x04,0x8f,0xe4,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x4e,0x01,0x00,0x00},
-            .todo = TRUE, .wine_only = TRUE,
-        },
         /* update effect */
         {
             .code = IOCTL_HID_WRITE_REPORT,
             .report_id = 3,
             .report_len = 18,
             .report_buf = {3,0x01,0x05,0x04,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x4e,0x01,0x00,0x00},
-            .todo = TRUE,
         },
     };
     struct hid_expect expect_create_ramp_neg[] =
@@ -5956,29 +5950,12 @@ static void test_windows_gaming_input(void)
             .report_len = 6,
             .report_buf = {10,0x01,0x18,0xfc,0x60,0xf0},
         },
-        /* set envelope (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 8,
-            .report_len = 8,
-            .report_buf = {8,0x01,0x00,0x00,0x00,0x00,0x00,0x00},
-            .todo = TRUE, .wine_only = TRUE,
-        },
-        /* update effect (wine) */
-        {
-            .code = IOCTL_HID_WRITE_REPORT,
-            .report_id = 3,
-            .report_len = 18,
-            .report_buf = {3,0x01,0x05,0x04,0x8f,0xe4,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x99,0x00,0x00,0x00},
-            .wine_only = TRUE, .todo = TRUE,
-        },
         /* update effect */
         {
             .code = IOCTL_HID_WRITE_REPORT,
             .report_id = 3,
             .report_len = 18,
             .report_buf = {3,0x01,0x05,0x04,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x4e,0x01,0x00,0x00},
-            .todo = TRUE,
         },
     };
     struct hid_expect expect_effect_start =
@@ -6038,7 +6015,7 @@ static void test_windows_gaming_input(void)
     IRawGameControllerStatics *controller_statics;
     EventRegistrationToken controller_added_token;
     IPeriodicForceEffectFactory *periodic_factory;
-    struct bool_async_handler bool_async_handler;
+    struct bool_async_handler *bool_async_handler;
     ForceFeedbackEffectAxes supported_axes, axes;
     IVectorView_ForceFeedbackMotor *motors_view;
     IConditionForceEffect *condition_effect;
@@ -6201,21 +6178,27 @@ static void test_windows_gaming_input(void)
     hr = IAsyncOperation_boolean_get_Completed( bool_async, &tmp_handler );
     ok( hr == S_OK, "get_Completed returned %#lx\n", hr );
     ok( tmp_handler == NULL, "got handler %p\n", tmp_handler );
-    bool_async_handler = default_bool_async_handler;
-    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler.IAsyncOperationCompletedHandler_boolean_iface );
+
+    bool_async_handler = impl_from_IAsyncOperationCompletedHandler_boolean( bool_async_handler_create( NULL ) );
+    ok( !!bool_async_handler, "bool_async_handler_create failed\n" );
+    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler->IAsyncOperationCompletedHandler_boolean_iface );
     ok( hr == S_OK, "put_Completed returned %#lx\n", hr );
-    ok( bool_async_handler.invoked, "handler not invoked\n" );
-    ok( bool_async_handler.async == bool_async, "got async %p\n", bool_async_handler.async );
-    ok( bool_async_handler.status == Completed, "got status %u\n", bool_async_handler.status );
+    ok( bool_async_handler->invoked, "handler not invoked\n" );
+    ok( bool_async_handler->async == bool_async, "got async %p\n", bool_async_handler->async );
+    ok( bool_async_handler->status == Completed, "got status %u\n", bool_async_handler->status );
     hr = IAsyncOperation_boolean_get_Completed( bool_async, &tmp_handler );
     ok( hr == S_OK, "get_Completed returned %#lx\n", hr );
     ok( tmp_handler == NULL, "got handler %p\n", tmp_handler );
-    bool_async_handler = default_bool_async_handler;
-    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler.IAsyncOperationCompletedHandler_boolean_iface );
+    IAsyncOperationCompletedHandler_boolean_Release( &bool_async_handler->IAsyncOperationCompletedHandler_boolean_iface );
+
+    bool_async_handler = impl_from_IAsyncOperationCompletedHandler_boolean( bool_async_handler_create( NULL ) );
+    ok( !!bool_async_handler, "bool_async_handler_create failed\n" );
+    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler->IAsyncOperationCompletedHandler_boolean_iface );
     ok( hr == E_ILLEGAL_DELEGATE_ASSIGNMENT, "put_Completed returned %#lx\n", hr );
-    ok( !bool_async_handler.invoked, "handler invoked\n" );
-    ok( bool_async_handler.async == NULL, "got async %p\n", bool_async_handler.async );
-    ok( bool_async_handler.status == Started, "got status %u\n", bool_async_handler.status );
+    ok( !bool_async_handler->invoked, "handler invoked\n" );
+    ok( bool_async_handler->async == NULL, "got async %p\n", bool_async_handler->async );
+    ok( bool_async_handler->status == Started, "got status %u\n", bool_async_handler->status );
+    IAsyncOperationCompletedHandler_boolean_Release( &bool_async_handler->IAsyncOperationCompletedHandler_boolean_iface );
 
     hr = IAsyncOperation_boolean_QueryInterface( bool_async, &IID_IAsyncInfo, (void **)&async_info );
     ok( hr == S_OK, "QueryInterface returned %#lx\n", hr );
@@ -6236,12 +6219,14 @@ static void test_windows_gaming_input(void)
     wait_hid_expect( file, 100 );
     check_bool_async( bool_async, 1, Error, 0x8685400d, FALSE );
 
-    bool_async_handler = default_bool_async_handler;
-    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler.IAsyncOperationCompletedHandler_boolean_iface );
+    bool_async_handler = impl_from_IAsyncOperationCompletedHandler_boolean( bool_async_handler_create( NULL ) );
+    ok( !!bool_async_handler, "bool_async_handler_create failed\n" );
+    hr = IAsyncOperation_boolean_put_Completed( bool_async, &bool_async_handler->IAsyncOperationCompletedHandler_boolean_iface );
     ok( hr == S_OK, "put_Completed returned %#lx\n", hr );
-    ok( bool_async_handler.invoked, "handler not invoked\n" );
-    ok( bool_async_handler.async == bool_async, "got async %p\n", bool_async_handler.async );
-    ok( bool_async_handler.status == Error, "got status %u\n", bool_async_handler.status );
+    ok( bool_async_handler->invoked, "handler not invoked\n" );
+    ok( bool_async_handler->async == bool_async, "got async %p\n", bool_async_handler->async );
+    ok( bool_async_handler->status == Error, "got status %u\n", bool_async_handler->status );
+    IAsyncOperationCompletedHandler_boolean_Release( &bool_async_handler->IAsyncOperationCompletedHandler_boolean_iface );
 
     hr = IAsyncOperation_boolean_QueryInterface( bool_async, &IID_IAsyncInfo, (void **)&async_info );
     ok( hr == S_OK, "QueryInterface returned %#lx\n", hr );
diff --git a/dlls/dinput/tests/hid.c b/dlls/dinput/tests/hid.c
index 5200892e95b..facbf69fcec 100644
--- a/dlls/dinput/tests/hid.c
+++ b/dlls/dinput/tests/hid.c
@@ -1841,6 +1841,11 @@ static void test_hidp( HANDLE file, HANDLE async_file, int report_id, BOOL polle
     ok( buffer[0] == (char)0xcd, "got report value %#x\n", buffer[0] );
     ok( buffer[1] == (char)0xcd, "got report value %#x\n", buffer[1] );
 
+    status = HidP_GetUsageValue( HidP_Input, HID_USAGE_PAGE_GENERIC, 0, 0, &value, preparsed_data, report, caps.InputReportByteLength );
+    ok( status == HIDP_STATUS_USAGE_NOT_FOUND, "HidP_GetUsageValue returned %#lx\n", status );
+    status = HidP_GetUsageValue( HidP_Input, 0, 0, HID_USAGE_GENERIC_X, &value, preparsed_data, report, caps.InputReportByteLength );
+    ok( status == HIDP_STATUS_USAGE_NOT_FOUND, "HidP_GetUsageValue returned %#lx\n", status );
+
     report[16] = 0xff;
     report[17] = 0xff;
     status = HidP_GetUsageValue( HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_HATSWITCH,
@@ -3684,7 +3689,6 @@ HRESULT dinput_test_create_device( DWORD version, DIDEVICEINSTANCEW *devinst, ID
         ok( hr == DI_OK, "CreateDevice returned %#lx\n", hr );
 
         ref = IDirectInput8_Release( di8 );
-        todo_wine
         ok( ref == 0, "Release returned %ld\n", ref );
     }
     else
@@ -3711,7 +3715,6 @@ HRESULT dinput_test_create_device( DWORD version, DIDEVICEINSTANCEW *devinst, ID
         ok( hr == DI_OK, "CreateDevice returned %#lx\n", hr );
 
         ref = IDirectInput_Release( di );
-        todo_wine
         ok( ref == 0, "Release returned %ld\n", ref );
     }
 
diff --git a/dlls/dinput8/Makefile.in b/dlls/dinput8/Makefile.in
index 164f2458da7..1d1b52c00ac 100644
--- a/dlls/dinput8/Makefile.in
+++ b/dlls/dinput8/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	config.c \
 	data_formats.c \
 	device.c \
+	dinput.c \
 	dinput_main.c \
 	joystick_hid.c \
 	keyboard.c \
diff --git a/dlls/dplayx/tests/dplayx.c b/dlls/dplayx/tests/dplayx.c
index 6cc149bac95..ba0f73194f6 100644
--- a/dlls/dplayx/tests/dplayx.c
+++ b/dlls/dplayx/tests/dplayx.c
@@ -6906,9 +6906,9 @@ START_TEST(dplayx)
     }
     strcat(path, "\\dplayx.dll");
 
-    if (!winetest_interactive && is_stub_dll(path))
+    if (!winetest_interactive && (GetFileAttributesA(path) == INVALID_FILE_ATTRIBUTES || is_stub_dll(path)))
     {
-        win_skip("dpnet is a stub dll, skipping tests\n");
+        win_skip("dplayx is missing or a stub dll, skipping tests\n");
         return;
     }
 
diff --git a/dlls/dpnet/tests/client.c b/dlls/dpnet/tests/client.c
index 2f7d6335a97..069966e666c 100644
--- a/dlls/dpnet/tests/client.c
+++ b/dlls/dpnet/tests/client.c
@@ -307,7 +307,7 @@ static void test_enum_hosts(void)
     hr = IDirectPlay8Client_CancelAsyncOperation(client, async, 0);
     ok(hr == S_OK, "IDirectPlay8Client_CancelAsyncOperation failed with 0x%08lx\n", hr);
     todo_wine ok(lastAsyncCode == DPNERR_USERCANCEL, "got 0x%08lx\n", lastAsyncCode);
-    todo_wine ok(lastAsyncHandle == async, "got 0x%08lx\n", async);
+    todo_wine ok(lastAsyncHandle == async, "got 0x%08lx\n", lastAsyncHandle);
 
     hr = IDirectPlay8Client_Initialize(client2, NULL, DirectPlayMessageHandler, 0);
     ok(hr == S_OK, "got %lx\n", hr);
@@ -322,7 +322,7 @@ static void test_enum_hosts(void)
     ok(hr == S_OK, "IDirectPlay8Client_CancelAsyncOperation failed with 0x%08lx\n", hr);
     flaky
     todo_wine ok(lastAsyncCode == DPNERR_USERCANCEL, "got 0x%08lx\n", lastAsyncCode);
-    todo_wine ok(lastAsyncHandle == async2, "got 0x%08lx\n", async2);
+    todo_wine ok(lastAsyncHandle == async2, "got 0x%08lx\n", lastAsyncHandle);
 
     IDirectPlay8Address_Release(local);
     IDirectPlay8Address_Release(host);
@@ -745,7 +745,7 @@ static void test_enum_hosts_peer(void)
     hr = IDirectPlay8Peer_CancelAsyncOperation(peer, async, 0);
     todo_wine ok(hr == S_OK, "IDirectPlay8Peer_CancelAsyncOperation failed with 0x%08lx\n", hr);
     todo_wine ok(lastAsyncCode == DPNERR_USERCANCEL, "got 0x%08lx\n", lastAsyncCode);
-    todo_wine ok(lastAsyncHandle == async, "got 0x%08lx\n", async);
+    todo_wine ok(lastAsyncHandle == async, "got 0x%08lx\n", lastAsyncHandle);
 
     lastAsyncCode = E_FAIL;
     lastAsyncHandle = 0xdeadbeef;
@@ -754,7 +754,7 @@ static void test_enum_hosts_peer(void)
     flaky
     todo_wine ok(lastAsyncCode == DPNERR_USERCANCEL, "got 0x%08lx\n", lastAsyncCode);
     flaky
-    todo_wine ok(lastAsyncHandle == async2, "got 0x%08lx\n", async2);
+    todo_wine ok(lastAsyncHandle == async2, "got 0x%08lx\n", lastAsyncHandle);
 
     IDirectPlay8Peer_Release(peer2);
     IDirectPlay8Address_Release(local);
diff --git a/dlls/dwrite/analyzer.c b/dlls/dwrite/analyzer.c
index 5489efa93b8..4e503eb8b5c 100644
--- a/dlls/dwrite/analyzer.c
+++ b/dlls/dwrite/analyzer.c
@@ -551,7 +551,10 @@ struct dwrite_fontfallback_builder
     size_t mappings_size;
 };
 
-static struct fallback_data system_fallback;
+static struct fallback_data system_fallback =
+{
+    .locales = LIST_INIT(system_fallback.locales),
+};
 
 static void release_fallback_mapping(struct fallback_mapping *mapping)
 {
diff --git a/dlls/dwrite/bidi.c b/dlls/dwrite/bidi.c
index 142c82f19d0..796f276e2e9 100644
--- a/dlls/dwrite/bidi.c
+++ b/dlls/dwrite/bidi.c
@@ -632,23 +632,27 @@ static BracketPair *bidi_compute_bracket_pairs(IsolatedRun *iso_run)
     WCHAR *open_stack;
     int *stack_index;
     int stack_top = iso_run->length;
-    BracketPair *out = NULL;
+    BracketPair *out;
     int pair_count = 0;
     int i;
 
     open_stack = malloc(sizeof(WCHAR) * iso_run->length);
     stack_index = malloc(sizeof(int) * iso_run->length);
+    out = malloc(sizeof(BracketPair) * iso_run->length);
+
+    if (!open_stack || !stack_index || !out) {
+        free(open_stack);
+        free(stack_index);
+        free(out);
+        return NULL;
+    }
+
+    out[0].start = -1;
 
     for (i = 0; i < iso_run->length; i++) {
         unsigned short ubv = get_table_entry_16(bidi_bracket_table, iso_run->item[i].ch);
         if (ubv)
         {
-            if (!out)
-            {
-                out = malloc(sizeof(BracketPair));
-                out[0].start = -1;
-            }
-
             if ((ubv >> 8) == 0) {
                 stack_top--;
                 open_stack[stack_top] = iso_run->item[i].ch + (signed char)(ubv & 0xff);
@@ -668,7 +672,6 @@ static BracketPair *bidi_compute_bracket_pairs(IsolatedRun *iso_run)
                         out[pair_count].start = stack_index[j];
                         out[pair_count].end = i;
                         pair_count++;
-                        out = realloc(out, sizeof(BracketPair) * (pair_count+1));
                         out[pair_count].start = -1;
                         stack_top = j+1;
                         break;
diff --git a/dlls/dwrite/tests/layout.c b/dlls/dwrite/tests/layout.c
index f9f4f46f584..c8c706a7395 100644
--- a/dlls/dwrite/tests/layout.c
+++ b/dlls/dwrite/tests/layout.c
@@ -5309,12 +5309,12 @@ static void test_system_fallback(void)
         if (!font) continue;
 
         get_font_name(font, name, ARRAY_SIZE(name));
-    todo_wine
+        todo_wine
         ok(!wcscmp(name, tests[i].name), "%u: unexpected name %s.\n", i, wine_dbgstr_w(name));
 
         hr = IDWriteFont_HasCharacter(font, g_source[0], &exists);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    todo_wine
+        todo_wine
         ok(exists, "%s missing character %#x\n", wine_dbgstr_w(name), g_source[0]);
 
         IDWriteFont_Release(font);
diff --git a/dlls/dxdiagn/provider.c b/dlls/dxdiagn/provider.c
index ed59f84bef2..d4a58dc45bc 100644
--- a/dlls/dxdiagn/provider.c
+++ b/dlls/dxdiagn/provider.c
@@ -697,7 +697,7 @@ static HRESULT build_systeminfo_tree(IDxDiagContainerImpl_Container *node)
     args[0] = usedpage_mb;
     args[1] = availpage_mb;
     FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, localized_pagefile_fmt,
-                   0, 0, print_buf, ARRAY_SIZE(print_buf), (__ms_va_list*)args);
+                   0, 0, print_buf, ARRAY_SIZE(print_buf), (va_list *)args);
 
     hr = add_bstr_property(node, L"szPageFileLocalized", print_buf);
     if (FAILED(hr))
diff --git a/dlls/dxgi/resource.c b/dlls/dxgi/resource.c
index 86ad4ec3f09..9699b7672f9 100644
--- a/dlls/dxgi/resource.c
+++ b/dlls/dxgi/resource.c
@@ -350,9 +350,35 @@ static HRESULT STDMETHODCALLTYPE dxgi_resource_GetSharedHandle(IDXGIResource *if
 
 static HRESULT STDMETHODCALLTYPE dxgi_resource_GetUsage(IDXGIResource *iface, DXGI_USAGE *usage)
 {
-    FIXME("iface %p, usage %p stub!\n", iface, usage);
+    struct dxgi_resource *resource = impl_from_IDXGIResource(iface);
+    struct wined3d_resource_desc resource_desc;
 
-    return E_NOTIMPL;
+    TRACE("iface %p, usage %p.\n", iface, usage);
+
+    wined3d_resource_get_desc(resource->wined3d_resource, &resource_desc);
+
+    *usage = dxgi_usage_from_wined3d_bind_flags(resource_desc.bind_flags);
+
+    if (resource_desc.resource_type != WINED3D_RTYPE_BUFFER)
+    {
+        struct wined3d_texture *texture = wined3d_texture_from_resource(resource->wined3d_resource);
+        struct wined3d_swapchain_desc swapchain_desc;
+        struct wined3d_swapchain *swapchain;
+
+        if ((swapchain = wined3d_texture_get_swapchain(texture)))
+        {
+            *usage |= DXGI_USAGE_BACK_BUFFER;
+
+            wined3d_swapchain_get_desc(swapchain, &swapchain_desc);
+            if (swapchain_desc.swap_effect == WINED3D_SWAP_EFFECT_DISCARD)
+                *usage |= DXGI_USAGE_DISCARD_ON_PRESENT;
+
+            if (wined3d_swapchain_get_back_buffer(swapchain, 0) != texture)
+                *usage |= DXGI_USAGE_READ_ONLY;
+        }
+    }
+
+    return S_OK;
 }
 
 static HRESULT STDMETHODCALLTYPE dxgi_resource_SetEvictionPriority(IDXGIResource *iface, UINT eviction_priority)
diff --git a/dlls/dxgi/tests/dxgi.c b/dlls/dxgi/tests/dxgi.c
index 73ea891119f..e0465b90ed0 100644
--- a/dlls/dxgi/tests/dxgi.c
+++ b/dlls/dxgi/tests/dxgi.c
@@ -4016,6 +4016,7 @@ static void test_swapchain_resize(IUnknown *device, BOOL is_d3d12)
 {
     DXGI_SWAP_CHAIN_DESC swapchain_desc;
     DXGI_SWAP_EFFECT swap_effect;
+    IDXGIResource *dxgi_resource;
     IDXGISwapChain3 *swapchain3;
     IUnknown *present_queue[2];
     IDXGISwapChain *swapchain;
@@ -4056,13 +4057,18 @@ static void test_swapchain_resize(IUnknown *device, BOOL is_d3d12)
 
     hr = IDXGIFactory_CreateSwapChain(factory, device, &swapchain_desc, &swapchain);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_IDXGISurface, (void **)&surface);
+
     expected_hr = is_d3d12 ? E_NOINTERFACE : S_OK;
+    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_IDXGIResource, (void **)&dxgi_resource);
+    ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok(!dxgi_resource || hr == S_OK, "Got unexpected pointer %p.\n", dxgi_resource);
+    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_IDXGISurface, (void **)&surface);
     ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
     ok(!surface || hr == S_OK, "Got unexpected pointer %p.\n", surface);
     hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_ID3D10Texture2D, (void **)&texture);
     ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
     ok(!texture || hr == S_OK, "Got unexpected pointer %p.\n", texture);
+
     expected_hr = is_d3d12 ? S_OK : E_NOINTERFACE;
     hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_ID3D12Resource, (void **)&resource);
     ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
@@ -4175,16 +4181,23 @@ static void test_swapchain_resize(IUnknown *device, BOOL is_d3d12)
         check_resource_desc(resource, &swapchain_desc);
         ID3D12Resource_Release(resource);
     }
+    if (dxgi_resource)
+        IDXGIResource_Release(dxgi_resource);
 
     hr = IDXGISwapChain_ResizeBuffers(swapchain, 2, 320, 240, DXGI_FORMAT_B8G8R8A8_UNORM, 0);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
-    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_IDXGISurface, (void **)&surface);
+
     expected_hr = is_d3d12 ? E_NOINTERFACE : S_OK;
+    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_IDXGIResource, (void **)&dxgi_resource);
+    ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok(!surface || hr == S_OK, "Got unexpected pointer %p.\n", surface);
+    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_IDXGISurface, (void **)&surface);
     ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
     ok(!surface || hr == S_OK, "Got unexpected pointer %p.\n", surface);
     hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_ID3D10Texture2D, (void **)&texture);
     ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
     ok(!texture || hr == S_OK, "Got unexpected pointer %p.\n", texture);
+
     expected_hr = is_d3d12 ? S_OK : E_NOINTERFACE;
     hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_ID3D12Resource, (void **)&resource);
     ok(hr == expected_hr, "Got unexpected hr %#lx, expected %#lx.\n", hr, expected_hr);
@@ -4246,6 +4259,8 @@ static void test_swapchain_resize(IUnknown *device, BOOL is_d3d12)
         check_resource_desc(resource, &swapchain_desc);
         ID3D12Resource_Release(resource);
     }
+    if (dxgi_resource)
+        IDXGIResource_Release(dxgi_resource);
 
     hr = IDXGISwapChain_ResizeBuffers(swapchain, 0, 0, 0, DXGI_FORMAT_UNKNOWN, 0);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
@@ -4495,9 +4510,7 @@ static void test_swapchain_parameters(void)
 
         expected_usage = DXGI_USAGE_RENDER_TARGET_OUTPUT | DXGI_USAGE_BACK_BUFFER;
         hr = IDXGIResource_GetUsage(resource, &usage);
-        todo_wine
         ok(hr == S_OK, "Got unexpected hr %#lx, test %u.\n", hr, i);
-        todo_wine
         ok((usage & expected_usage) == expected_usage, "Got usage %x, expected %x, test %u.\n",
                 usage, expected_usage, i);
 
@@ -4534,9 +4547,7 @@ static void test_swapchain_parameters(void)
                 broken_usage |= DXGI_USAGE_READ_ONLY;
 
             hr = IDXGIResource_GetUsage(resource, &usage);
-            todo_wine
             ok(hr == S_OK, "Got unexpected hr %#lx, test %u, buffer %u.\n", hr, i, j);
-            todo_wine
             ok(usage == expected_usage || broken(usage == broken_usage),
                     "Got usage %x, expected %x, test %u, buffer %u.\n",
                     usage, expected_usage, i, j);
@@ -4607,9 +4618,7 @@ static void test_swapchain_parameters(void)
         ok(hr == S_OK, "Got unexpected hr %#lx, test %u.\n", hr, i);
         expected_usage = usage | DXGI_USAGE_BACK_BUFFER | DXGI_USAGE_DISCARD_ON_PRESENT;
         hr = IDXGIResource_GetUsage(resource, &usage);
-        todo_wine
         ok(hr == S_OK, "Got unexpected hr %#lx, test %u.\n", hr, i);
-        todo_wine_if(i != 7)
         ok(usage == expected_usage, "Got usage %x, expected %x, test %u.\n", usage, expected_usage, i);
         IDXGIResource_Release(resource);
 
diff --git a/dlls/dxgi/utils.c b/dlls/dxgi/utils.c
index d701725afa9..08e3a0d39db 100644
--- a/dlls/dxgi/utils.c
+++ b/dlls/dxgi/utils.c
@@ -494,9 +494,6 @@ DXGI_USAGE dxgi_usage_from_wined3d_bind_flags(unsigned int wined3d_bind_flags)
     if (wined3d_bind_flags & WINED3D_BIND_UNORDERED_ACCESS)
         dxgi_usage |= DXGI_USAGE_UNORDERED_ACCESS;
 
-    wined3d_bind_flags &= ~(WINED3D_BIND_SHADER_RESOURCE | WINED3D_BIND_RENDER_TARGET | WINED3D_BIND_UNORDERED_ACCESS);
-    if (wined3d_bind_flags)
-        FIXME("Unhandled wined3d bind flags %#x.\n", wined3d_bind_flags);
     return dxgi_usage;
 }
 
@@ -575,7 +572,7 @@ HRESULT wined3d_swapchain_desc_from_dxgi(struct wined3d_swapchain_desc *wined3d_
 
     if (dxgi_desc->Scaling != DXGI_SCALING_STRETCH)
         FIXME("Ignoring scaling %#x.\n", dxgi_desc->Scaling);
-    if (dxgi_desc->AlphaMode != DXGI_ALPHA_MODE_IGNORE)
+    if (dxgi_desc->AlphaMode != DXGI_ALPHA_MODE_UNSPECIFIED && dxgi_desc->AlphaMode != DXGI_ALPHA_MODE_IGNORE)
         FIXME("Ignoring alpha mode %#x.\n", dxgi_desc->AlphaMode);
     if (dxgi_fullscreen_desc && dxgi_fullscreen_desc->ScanlineOrdering)
         FIXME("Unhandled scanline ordering %#x.\n", dxgi_fullscreen_desc->ScanlineOrdering);
diff --git a/dlls/gdi32/tests/driver.c b/dlls/gdi32/tests/driver.c
index b2d2a0545ff..94f93d61207 100644
--- a/dlls/gdi32/tests/driver.c
+++ b/dlls/gdi32/tests/driver.c
@@ -712,6 +712,7 @@ static void test_D3DKMTCheckOcclusion(void)
         ShowWindow(hwnd, SW_MINIMIZE);
         occlusion_desc.hWnd = hwnd;
         status = pD3DKMTCheckOcclusion(&occlusion_desc);
+        flaky
         ok(status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status);
         ShowWindow(hwnd, SW_SHOWNORMAL);
 
@@ -798,11 +799,13 @@ static void test_D3DKMTCheckOcclusion(void)
 
     occlusion_desc.hWnd = hwnd;
     status = pD3DKMTCheckOcclusion(&occlusion_desc);
+    flaky
     ok(status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status);
 
     check_owner_desc.hAdapter = open_adapter_gdi_desc.hAdapter;
     check_owner_desc.VidPnSourceId = open_adapter_gdi_desc.VidPnSourceId;
     status = pD3DKMTCheckVidPnExclusiveOwnership(&check_owner_desc);
+    flaky
     ok(status == STATUS_SUCCESS || status == STATUS_GRAPHICS_PRESENT_UNOCCLUDED, "Got unexpected return code %#lx.\n", status);
 
     destroy_device_desc.hDevice = create_device_desc.hDevice;
diff --git a/dlls/gdiplus/font.c b/dlls/gdiplus/font.c
index 03678623606..96d3c5630bc 100644
--- a/dlls/gdiplus/font.c
+++ b/dlls/gdiplus/font.c
@@ -1396,7 +1396,7 @@ static WCHAR *load_ttf_name_id( const BYTE *mem, DWORD_PTR size, DWORD id )
     const tt_header *header;
     const tt_name_table *name_table;
     const tt_name_record *name_record;
-    DWORD pos, ofs, count;
+    DWORD pos, ofs = 0, count;
     int i, res, best_lang = 0, best_index = -1;
 
     if (sizeof(tt_header) > size)
diff --git a/dlls/hhctrl.ocx/chm.c b/dlls/hhctrl.ocx/chm.c
index fb982303a3c..4be86bd165a 100644
--- a/dlls/hhctrl.ocx/chm.c
+++ b/dlls/hhctrl.ocx/chm.c
@@ -82,7 +82,7 @@ static BOOL ReadChmSystem(CHMInfo *chm)
 {
     IStream *stream;
     DWORD ver=0xdeadbeef, read, buf_size;
-    char *buf;
+    char *buf, *new_buf;
     HRESULT hres;
 
     struct {
@@ -101,16 +101,27 @@ static BOOL ReadChmSystem(CHMInfo *chm)
     IStream_Read(stream, &ver, sizeof(ver), &read);
     TRACE("version is %lx\n", ver);
 
-    buf = malloc(8 * sizeof(DWORD));
-    buf_size = 8*sizeof(DWORD);
+    buf_size = 8 * sizeof(DWORD);
+    buf = malloc(buf_size);
+    if(!buf) {
+        IStream_Release(stream);
+        return FALSE;
+    }
 
     while(1) {
         hres = IStream_Read(stream, &entry, sizeof(entry), &read);
         if(hres != S_OK)
             break;
 
-        if(entry.len > buf_size)
-            buf = realloc(buf, buf_size=entry.len);
+        if(entry.len > buf_size) {
+            new_buf = realloc(buf, entry.len);
+            if(!new_buf) {
+                hres = E_OUTOFMEMORY;
+                break;
+            }
+            buf = new_buf;
+            buf_size = entry.len;
+        }
 
         hres = IStream_Read(stream, buf, entry.len, &read);
         if(hres != S_OK)
diff --git a/dlls/hhctrl.ocx/search.c b/dlls/hhctrl.ocx/search.c
index c6fe30afc14..64b71e87ac7 100644
--- a/dlls/hhctrl.ocx/search.c
+++ b/dlls/hhctrl.ocx/search.c
@@ -72,7 +72,7 @@ static void fill_search_tree(HWND hwndList, SearchItem *item)
  */
 static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *needle)
 {
-    char *buffer = malloc(BLOCK_SIZE);
+    char *buffer = NULL, *new_buffer;
     strbuf_t content, node, node_name;
     IStream *temp_stream = NULL;
     DWORD i, buffer_size = 0;
@@ -84,7 +84,7 @@ static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *
     hres = IStorage_OpenStream(pStorage, file, NULL, STGM_READ, 0, &temp_stream);
     if(FAILED(hres)) {
         FIXME("Could not open '%s' stream: %08lx\n", debugstr_w(file), hres);
-        goto cleanup;
+        return NULL;
     }
 
     strbuf_init(&node);
@@ -110,7 +110,9 @@ static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *
                 title[wlen] = 0;
             }
 
-            buffer = realloc(buffer, buffer_size + textlen + 1);
+            new_buffer = realloc(buffer, buffer_size + textlen + 1);
+            if(!new_buffer) goto cleanup;
+            buffer = new_buffer;
             memcpy(&buffer[buffer_size], text, textlen);
             buffer[buffer_size + textlen] = '\0';
             buffer_size += textlen;
@@ -130,14 +132,14 @@ static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *
     if(strstr(buffer, needle))
         found = TRUE;
 
+cleanup:
     strbuf_free(&node);
     strbuf_free(&content);
     strbuf_free(&node_name);
 
-cleanup:
     free(buffer);
-    if(temp_stream)
-        IStream_Release(temp_stream);
+    IStream_Release(temp_stream);
+
     if(!found)
     {
         free(title);
diff --git a/dlls/hid/hidp.c b/dlls/hid/hidp.c
index 83a4638b6ad..c24a98155b0 100644
--- a/dlls/hid/hidp.c
+++ b/dlls/hid/hidp.c
@@ -68,14 +68,17 @@ static NTSTATUS get_value_caps_range( struct hid_preparsed_data *preparsed, HIDP
     return HIDP_STATUS_SUCCESS;
 }
 
+#define USAGE_MASK  0xffff
+#define USAGE_ANY  0x10000
+
 struct caps_filter
 {
     BOOLEAN buttons;
     BOOLEAN values;
     BOOLEAN array;
-    USAGE   usage_page;
+    DWORD   usage_page;
     USHORT  collection;
-    USAGE   usage;
+    DWORD   usage;
     UCHAR   report_id;
 };
 
@@ -84,10 +87,10 @@ static BOOL match_value_caps( const struct hid_value_caps *caps, const struct ca
     if (!caps->usage_min && !caps->usage_max) return FALSE;
     if (filter->buttons && !(caps->flags & HID_VALUE_CAPS_IS_BUTTON)) return FALSE;
     if (filter->values && (caps->flags & HID_VALUE_CAPS_IS_BUTTON)) return FALSE;
-    if (filter->usage_page && filter->usage_page != caps->usage_page) return FALSE;
+    if (filter->usage_page != USAGE_ANY && (filter->usage_page & USAGE_MASK) != caps->usage_page) return FALSE;
     if (filter->collection && filter->collection != caps->link_collection) return FALSE;
-    if (!filter->usage) return TRUE;
-    return caps->usage_min <= filter->usage && caps->usage_max >= filter->usage;
+    if (filter->usage == USAGE_ANY) return TRUE;
+    return caps->usage_min <= (filter->usage & USAGE_MASK) && caps->usage_max >= (filter->usage & USAGE_MASK);
 }
 
 typedef NTSTATUS (*enum_value_caps_callback)( const struct hid_value_caps *caps, void *user );
@@ -384,7 +387,7 @@ NTSTATUS WINAPI HidP_GetUsages( HIDP_REPORT_TYPE report_type, USAGE usage_page,
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
     struct get_usage_params params = {.usages = usages, .usages_end = usages + *usages_len, .report_buf = report_buf};
-    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection};
+    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection, .usage = USAGE_ANY};
     NTSTATUS status;
     USHORT limit = -1;
 
@@ -441,7 +444,7 @@ static NTSTATUS get_usage_list_length( const struct hid_value_caps *caps, void *
 ULONG WINAPI HidP_MaxUsageListLength( HIDP_REPORT_TYPE report_type, USAGE usage_page, PHIDP_PREPARSED_DATA preparsed_data )
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
-    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page};
+    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page | USAGE_ANY, .usage = USAGE_ANY};
     USHORT limit = -1;
     ULONG count = 0;
 
@@ -590,7 +593,7 @@ NTSTATUS WINAPI HidP_SetUsages( HIDP_REPORT_TYPE report_type, USAGE usage_page,
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
     struct set_usage_params params = {.report_buf = report_buf};
-    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection};
+    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection, .usage = USAGE_ANY};
     NTSTATUS status;
     USHORT limit = 1;
     ULONG i, count = *usage_count;
@@ -656,7 +659,7 @@ NTSTATUS WINAPI HidP_UnsetUsages( HIDP_REPORT_TYPE report_type, USAGE usage_page
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
     struct unset_usage_params params = {.report_buf = report_buf, .found = FALSE};
-    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection};
+    struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection, .usage = USAGE_ANY};
     NTSTATUS status;
     USHORT limit = 1;
     ULONG i, count = *usage_count;
@@ -739,7 +742,7 @@ NTSTATUS WINAPI HidP_GetSpecificButtonCaps( HIDP_REPORT_TYPE report_type, USAGE
                                             PHIDP_PREPARSED_DATA preparsed_data )
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
-    const struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page, .collection = collection, .usage = usage};
+    const struct caps_filter filter = {.buttons = TRUE, .usage_page = usage_page | USAGE_ANY, .collection = collection, .usage = usage | USAGE_ANY};
 
     TRACE( "report_type %d, usage_page %u, collection %u, usage %u, caps %p, caps_count %p, preparsed_data %p.\n",
            report_type, usage_page, collection, usage, caps, caps_count, preparsed_data );
@@ -806,7 +809,7 @@ NTSTATUS WINAPI HidP_GetSpecificValueCaps( HIDP_REPORT_TYPE report_type, USAGE u
                                            PHIDP_PREPARSED_DATA preparsed_data )
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
-    const struct caps_filter filter = {.values = TRUE, .usage_page = usage_page, .collection = collection, .usage = usage};
+    const struct caps_filter filter = {.values = TRUE, .usage_page = usage_page | USAGE_ANY, .collection = collection, .usage = usage | USAGE_ANY};
 
     TRACE( "report_type %d, usage_page %u, collection %u, usage %u, caps %p, caps_count %p, preparsed_data %p.\n",
            report_type, usage_page, collection, usage, caps, caps_count, preparsed_data );
@@ -869,7 +872,7 @@ NTSTATUS WINAPI HidP_GetUsagesEx( HIDP_REPORT_TYPE report_type, USHORT collectio
 {
     struct get_usage_and_page_params params = {.usages = usages, .usages_end = usages + *usages_len, .report_buf = report_buf};
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
-    struct caps_filter filter = {.buttons = TRUE, .collection = collection};
+    struct caps_filter filter = {.buttons = TRUE, .usage_page = USAGE_ANY, .collection = collection, .usage = USAGE_ANY};
     NTSTATUS status;
     USHORT limit = -1;
 
@@ -899,7 +902,7 @@ static NTSTATUS count_data( const struct hid_value_caps *caps, void *user )
 ULONG WINAPI HidP_MaxDataListLength( HIDP_REPORT_TYPE report_type, PHIDP_PREPARSED_DATA preparsed_data )
 {
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
-    struct caps_filter filter = {};
+    struct caps_filter filter = {.usage_page = USAGE_ANY, .usage = USAGE_ANY};
     USHORT limit = -1;
     ULONG count = 0;
 
@@ -981,7 +984,7 @@ NTSTATUS WINAPI HidP_GetData( HIDP_REPORT_TYPE report_type, HIDP_DATA *data, ULO
 {
     struct find_all_data_params params = {.data = data, .data_end = data + *data_len, .report_buf = report_buf};
     struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)preparsed_data;
-    struct caps_filter filter = {};
+    struct caps_filter filter = {.usage_page = USAGE_ANY, .usage = USAGE_ANY};
     NTSTATUS status;
     USHORT limit = -1;
 
diff --git a/dlls/http.sys/http.c b/dlls/http.sys/http.c
index 680ef30730c..c2234aa14ad 100644
--- a/dlls/http.sys/http.c
+++ b/dlls/http.sys/http.c
@@ -1199,19 +1199,18 @@ static void WINAPI unload(DRIVER_OBJECT *driver)
 NTSTATUS WINAPI DriverEntry(DRIVER_OBJECT *driver, UNICODE_STRING *path)
 {
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING string;
+    UNICODE_STRING device_http = RTL_CONSTANT_STRING(L"\\Device\\Http");
+    UNICODE_STRING device_http_req_queue = RTL_CONSTANT_STRING(L"\\Device\\Http\\ReqQueue");
     WSADATA wsadata;
     NTSTATUS ret;
 
     TRACE("driver %p, path %s.\n", driver, debugstr_w(path->Buffer));
 
-    RtlInitUnicodeString(&string, L"\\Device\\Http");
-    attr.ObjectName = &string;
+    attr.ObjectName = &device_http;
     if ((ret = NtCreateDirectoryObject(&directory_obj, 0, &attr)) && ret != STATUS_OBJECT_NAME_COLLISION)
         ERR("Failed to create \\Device\\Http directory, status %#lx.\n", ret);
 
-    RtlInitUnicodeString(&string, L"\\Device\\Http\\ReqQueue");
-    if ((ret = IoCreateDevice(driver, 0, &string, FILE_DEVICE_UNKNOWN, 0, FALSE, &device_obj)))
+    if ((ret = IoCreateDevice(driver, 0, &device_http_req_queue, FILE_DEVICE_UNKNOWN, 0, FALSE, &device_obj)))
     {
         ERR("Failed to create request queue device, status %#lx.\n", ret);
         NtClose(directory_obj);
diff --git a/dlls/httpapi/httpapi_main.c b/dlls/httpapi/httpapi_main.c
index 10131fdd029..b808b627174 100644
--- a/dlls/httpapi/httpapi_main.c
+++ b/dlls/httpapi/httpapi_main.c
@@ -185,7 +185,7 @@ ULONG WINAPI HttpSetServiceConfiguration( HANDLE handle, HTTP_SERVICE_CONFIG_ID
 ULONG WINAPI HttpCreateHttpHandle(HANDLE *handle, ULONG reserved)
 {
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING string;
+    UNICODE_STRING string = RTL_CONSTANT_STRING(L"\\Device\\Http\\ReqQueue");
     IO_STATUS_BLOCK iosb;
 
     TRACE("handle %p, reserved %#lx.\n", handle, reserved);
@@ -193,7 +193,6 @@ ULONG WINAPI HttpCreateHttpHandle(HANDLE *handle, ULONG reserved)
     if (!handle)
         return ERROR_INVALID_PARAMETER;
 
-    RtlInitUnicodeString(&string, L"\\Device\\Http\\ReqQueue");
     attr.ObjectName = &string;
     return RtlNtStatusToDosError(NtCreateFile(handle, 0, &attr, &iosb, NULL,
             FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, 0));
@@ -741,7 +740,7 @@ ULONG WINAPI HttpCreateRequestQueue(HTTPAPI_VERSION version, const WCHAR *name,
         SECURITY_ATTRIBUTES *sa, ULONG flags, HANDLE *handle)
 {
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING string;
+    UNICODE_STRING string = RTL_CONSTANT_STRING(L"\\Device\\Http\\ReqQueue");
     IO_STATUS_BLOCK iosb;
 
     TRACE("version %u.%u, name %s, sa %p, flags %#lx, handle %p.\n",
@@ -753,7 +752,6 @@ ULONG WINAPI HttpCreateRequestQueue(HTTPAPI_VERSION version, const WCHAR *name,
     if (flags)
         FIXME("Unhandled flags %#lx.\n", flags);
 
-    RtlInitUnicodeString(&string, L"\\Device\\Http\\ReqQueue");
     attr.ObjectName = &string;
     if (sa && sa->bInheritHandle)
         attr.Attributes |= OBJ_INHERIT;
diff --git a/dlls/ieframe/tests/webbrowser.c b/dlls/ieframe/tests/webbrowser.c
index 584da6e9022..15ce0272654 100644
--- a/dlls/ieframe/tests/webbrowser.c
+++ b/dlls/ieframe/tests/webbrowser.c
@@ -2021,7 +2021,7 @@ static void test_ClientSite(IWebBrowser2 *unk, IOleClientSite *client, BOOL stop
 
     if(client) {
         DWORD count = pSetQueryNetSessionCount(SESSION_QUERY);
-        ok(count == session_count + 1, "count = %lu expected %lu\n", count, session_count + 1);
+        ok(count >= session_count + 1, "count = %lu expected %lu\n", count, session_count + 1);
 
         CHECK_CALLED(GetContainer);
         CHECK_CALLED(Site_GetWindow);
diff --git a/dlls/imm32/imm.c b/dlls/imm32/imm.c
index fa2e0705db1..3d9cbf7e198 100644
--- a/dlls/imm32/imm.c
+++ b/dlls/imm32/imm.c
@@ -33,7 +33,7 @@
 #include "winerror.h"
 #include "wine/debug.h"
 #include "imm.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 #include "winnls.h"
 #include "winreg.h"
 #include "wine/list.h"
@@ -62,13 +62,13 @@ typedef struct _tagImmHkl{
     HWND        UIWnd;
 
     /* Function Pointers */
-    BOOL (WINAPI *pImeInquire)(IMEINFO *, WCHAR *, const WCHAR *);
+    BOOL (WINAPI *pImeInquire)(IMEINFO *, WCHAR *, DWORD);
     BOOL (WINAPI *pImeConfigure)(HKL, HWND, DWORD, void *);
     BOOL (WINAPI *pImeDestroy)(UINT);
     LRESULT (WINAPI *pImeEscape)(HIMC, UINT, void *);
     BOOL (WINAPI *pImeSelect)(HIMC, BOOL);
     BOOL (WINAPI *pImeSetActiveContext)(HIMC, BOOL);
-    UINT (WINAPI *pImeToAsciiEx)(UINT, UINT, const BYTE *, DWORD *, UINT, HIMC);
+    UINT (WINAPI *pImeToAsciiEx)(UINT, UINT, const BYTE *, TRANSMSGLIST *, UINT, HIMC);
     BOOL (WINAPI *pNotifyIME)(HIMC, DWORD, DWORD, DWORD);
     BOOL (WINAPI *pImeRegisterWord)(const WCHAR *, DWORD, const WCHAR *);
     BOOL (WINAPI *pImeUnregisterWord)(const WCHAR *, DWORD, const WCHAR *);
@@ -97,12 +97,6 @@ typedef struct tagInputContextData
 
 #define WINE_IMC_VALID_MAGIC 0x56434D49
 
-typedef struct _tagTRANSMSG {
-    UINT message;
-    WPARAM wParam;
-    LPARAM lParam;
-} TRANSMSG, *LPTRANSMSG;
-
 struct coinit_spy
 {
     IInitializeSpy IInitializeSpy_iface;
@@ -508,7 +502,7 @@ static ImmHkl *IMM_GetImmHkl(HKL hkl)
     if (ptr->hIME)
     {
         LOAD_FUNCPTR(ImeInquire);
-        if (!ptr->pImeInquire || !ptr->pImeInquire(&ptr->imeInfo, ptr->imeClassName, NULL))
+        if (!ptr->pImeInquire || !ptr->pImeInquire(&ptr->imeInfo, ptr->imeClassName, 0))
         {
             FreeLibrary(ptr->hIME);
             ptr->hIME = NULL;
@@ -2377,6 +2371,9 @@ BOOL WINAPI ImmSetCompositionStringA(
     if (!data)
         return FALSE;
 
+    if (IMM_IsCrossThreadAccess(NULL, hIMC))
+        return FALSE;
+
     if (!(dwIndex == SCS_SETSTR ||
           dwIndex == SCS_CHANGEATTR ||
           dwIndex == SCS_CHANGECLAUSE ||
@@ -2432,6 +2429,9 @@ BOOL WINAPI ImmSetCompositionStringW(
     if (!data)
         return FALSE;
 
+    if (IMM_IsCrossThreadAccess(NULL, hIMC))
+        return FALSE;
+
     if (!(dwIndex == SCS_SETSTR ||
           dwIndex == SCS_CHANGEATTR ||
           dwIndex == SCS_CHANGECLAUSE ||
@@ -2998,7 +2998,7 @@ BOOL WINAPI ImmTranslateMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lKeyD
     HIMC imc = ImmGetContext(hwnd);
     BYTE state[256];
     UINT scancode;
-    LPVOID list = 0;
+    TRANSMSGLIST *list = NULL;
     UINT msg_count;
     UINT uVirtKey;
     static const DWORD list_count = 10;
@@ -3014,7 +3014,7 @@ BOOL WINAPI ImmTranslateMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lKeyD
     scancode = lKeyData >> 0x10 & 0xff;
 
     list = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, list_count * sizeof(TRANSMSG) + sizeof(DWORD));
-    ((DWORD*)list)[0] = list_count;
+    list->uMsgCount = list_count;
 
     if (data->immKbd->imeInfo.fdwProperty & IME_PROP_KBD_CHAR_FIRST)
     {
@@ -3034,7 +3034,7 @@ BOOL WINAPI ImmTranslateMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lKeyD
     if (msg_count && msg_count <= list_count)
     {
         UINT i;
-        LPTRANSMSG msgs = (LPTRANSMSG)((LPBYTE)list + sizeof(DWORD));
+        LPTRANSMSG msgs = list->TransMsg;
 
         for (i = 0; i < msg_count; i++)
             ImmInternalPostIMEMessage(data, msgs[i].message, msgs[i].wParam, msgs[i].lParam);
@@ -3116,7 +3116,7 @@ BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
  *              ImmGetHotKey(IMM32.@)
  */
 
-BOOL WINAPI ImmGetHotKey(DWORD hotkey, UINT *modifiers, UINT *key, HKL hkl)
+BOOL WINAPI ImmGetHotKey(DWORD hotkey, UINT *modifiers, UINT *key, HKL *hkl)
 {
     FIXME("%lx, %p, %p, %p: stub\n", hotkey, modifiers, key, hkl);
     return FALSE;
diff --git a/dlls/imm32/tests/imm32.c b/dlls/imm32/tests/imm32.c
index 75b5cde6c7b..a97457320ce 100644
--- a/dlls/imm32/tests/imm32.c
+++ b/dlls/imm32/tests/imm32.c
@@ -25,7 +25,7 @@
 #include "winuser.h"
 #include "wingdi.h"
 #include "imm.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 
 BOOL WINAPI ImmSetActiveContext(HWND, HIMC, BOOL);
 
@@ -93,12 +93,6 @@ typedef struct
     } u;
 } TEST_INPUT;
 
-typedef struct _tagTRANSMSG {
-    UINT message;
-    WPARAM wParam;
-    LPARAM lParam;
-} TRANSMSG, *LPTRANSMSG;
-
 static UINT (WINAPI *pSendInput) (UINT, INPUT*, size_t);
 
 static LRESULT CALLBACK get_msg_filter(int nCode, WPARAM wParam, LPARAM lParam)
@@ -984,6 +978,14 @@ static void test_ImmThreads(void)
     rc = ImmSetCompositionFontA(threadinfo.u_himc, &lf);
     ok(rc == 0, "ImmSetCompositionFont should fail\n");
 
+    /* CompositionString */
+    rc = ImmSetCompositionStringA(himc, SCS_SETSTR, "a", 2, NULL, 0);
+    ok(rc, "failed.\n");
+    rc = ImmSetCompositionStringA(otherHimc, SCS_SETSTR, "a", 2, NULL, 0);
+    ok(!rc, "should fail.\n");
+    rc = ImmSetCompositionStringA(threadinfo.u_himc, SCS_SETSTR, "a", 2, NULL, 0);
+    ok(!rc, "should fail.\n");
+
     /* CompositionWindow */
     rc = ImmSetCompositionWindow(himc, &cf);
     ok(rc != 0, "ImmSetCompositionWindow failed\n");
diff --git a/dlls/inetcomm/mimeole.c b/dlls/inetcomm/mimeole.c
index 232e09aa075..dd2c00b01fa 100644
--- a/dlls/inetcomm/mimeole.c
+++ b/dlls/inetcomm/mimeole.c
@@ -485,7 +485,7 @@ static inline propschema *impl_from_IMimePropertySchema(IMimePropertySchema *ifa
  */
 static HRESULT copy_headers_to_buf(IStream *stm, char **ptr)
 {
-    char *buf = NULL;
+    char *buf = NULL, *new_buf;
     DWORD size = PARSER_BUF_SIZE, offset = 0, last_end = 0;
     HRESULT hr;
     BOOL done = FALSE;
@@ -497,18 +497,14 @@ static HRESULT copy_headers_to_buf(IStream *stm, char **ptr)
         char *end;
         DWORD read;
 
-        if(!buf)
-            buf = malloc(size + 1);
-        else
-        {
-            size *= 2;
-            buf = realloc(buf, size + 1);
-        }
-        if(!buf)
+        if(buf) size *= 2;
+        new_buf = realloc(buf, size + 1);
+        if(!new_buf)
         {
             hr = E_OUTOFMEMORY;
             goto fail;
         }
+        buf = new_buf;
 
         hr = IStream_Read(stm, buf + offset, size - offset, &read);
         if(FAILED(hr)) goto fail;
diff --git a/dlls/iphlpapi/iphlpapi_main.c b/dlls/iphlpapi/iphlpapi_main.c
index f8fb5de3f0e..6286c168277 100644
--- a/dlls/iphlpapi/iphlpapi_main.c
+++ b/dlls/iphlpapi/iphlpapi_main.c
@@ -959,12 +959,14 @@ static DWORD unicast_addresses_alloc( IP_ADAPTER_ADDRESSES *aa, ULONG family, UL
             {
                 SOCKADDR_IN *in = (SOCKADDR_IN *)addr->Address.lpSockaddr;
                 in->sin_addr = key4->addr;
+                aa->Ipv4Enabled = TRUE;
             }
             else
             {
                 SOCKADDR_IN6 *in6 = (SOCKADDR_IN6 *)addr->Address.lpSockaddr;
                 in6->sin6_addr = key6->addr;
                 in6->sin6_scope_id = dyn[i].scope_id;
+                aa->Ipv6Enabled = TRUE;
             }
             addr->PrefixOrigin = rw[i].prefix_origin;
             addr->SuffixOrigin = rw[i].suffix_origin;
diff --git a/dlls/iphlpapi/tests/iphlpapi.c b/dlls/iphlpapi/tests/iphlpapi.c
index 1a0cb76bcf5..b8fa82d2a56 100644
--- a/dlls/iphlpapi/tests/iphlpapi.c
+++ b/dlls/iphlpapi/tests/iphlpapi.c
@@ -1818,6 +1818,11 @@ static void test_GetAdaptersAddresses(void)
             if (ua->Flags & IP_ADAPTER_ADDRESS_DNS_ELIGIBLE)
                 dns_eligible_found = TRUE;
 
+            if(ua->Address.lpSockaddr->sa_family == AF_INET)
+                ok(aa->Ipv4Enabled == TRUE, "expected Ipv4Enabled flag to be set in interface %ls\n", aa->FriendlyName);
+            else if(ua->Address.lpSockaddr->sa_family == AF_INET6)
+                ok(aa->Ipv6Enabled == TRUE, "expected Ipv6Enabled flag to be set in interface %ls\n", aa->FriendlyName);
+
             ua = ua->Next;
         }
         for (i = 0, temp[0] = '\0'; i < ARRAY_SIZE(aa->ZoneIndices); i++)
diff --git a/dlls/ir50_32/Makefile.in b/dlls/ir50_32/Makefile.in
new file mode 100644
index 00000000000..2db9c8076c9
--- /dev/null
+++ b/dlls/ir50_32/Makefile.in
@@ -0,0 +1,8 @@
+MODULE       = ir50_32.dll
+IMPORTS      = user32 mfplat mfuuid
+DELAYIMPORTS = winegstreamer
+
+C_SRCS = \
+	ir50.c
+
+RC_SRCS = ir50_32.rc
diff --git a/dlls/ir50_32/ir50.c b/dlls/ir50_32/ir50.c
new file mode 100644
index 00000000000..87807aba25f
--- /dev/null
+++ b/dlls/ir50_32/ir50.c
@@ -0,0 +1,412 @@
+/*
+ * Intel Indeo 5 Video Decoder
+ * Copyright 2023 Shaun Ren for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "commdlg.h"
+#include "vfw.h"
+#include "initguid.h"
+#include "ir50_private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ir50_32);
+
+static HINSTANCE IR50_32_hModule;
+
+#define IV50_MAGIC mmioFOURCC('I','V','5','0')
+#define compare_fourcc(fcc1, fcc2) (((fcc1)^(fcc2))&~0x20202020)
+
+DEFINE_MEDIATYPE_GUID(MFVideoFormat_IV50, MAKEFOURCC('I','V','5','0'));
+
+static inline UINT64
+make_uint64( UINT32 high, UINT32 low )
+{
+    return ((UINT64)high << 32) | low;
+}
+
+
+static LRESULT
+IV50_Open( const ICINFO *icinfo )
+{
+    IMFTransform *decoder = NULL;
+
+    TRACE("DRV_OPEN %p\n", icinfo);
+
+    if ( icinfo && compare_fourcc( icinfo->fccType, ICTYPE_VIDEO ) )
+        return 0;
+
+    if ( FAILED(winegstreamer_create_video_decoder( &decoder )) )
+        return 0;
+
+    return (LRESULT)decoder;
+}
+
+static LRESULT
+IV50_DecompressQuery( LPBITMAPINFO in, LPBITMAPINFO out )
+{
+    TRACE("ICM_DECOMPRESS_QUERY %p %p\n", in, out);
+
+    TRACE("in->planes  = %d\n", in->bmiHeader.biPlanes);
+    TRACE("in->bpp     = %d\n", in->bmiHeader.biBitCount);
+    TRACE("in->height  = %ld\n", in->bmiHeader.biHeight);
+    TRACE("in->width   = %ld\n", in->bmiHeader.biWidth);
+    TRACE("in->compr   = %#lx\n", in->bmiHeader.biCompression);
+
+    if ( in->bmiHeader.biCompression != IV50_MAGIC )
+    {
+        TRACE("can't do %#lx compression\n", in->bmiHeader.biCompression);
+        return ICERR_BADFORMAT;
+    }
+
+    /* output must be same dimensions as input */
+    if ( out )
+    {
+        TRACE("out->planes = %d\n", out->bmiHeader.biPlanes);
+        TRACE("out->bpp    = %d\n", out->bmiHeader.biBitCount);
+        TRACE("out->height = %ld\n", out->bmiHeader.biHeight);
+        TRACE("out->width  = %ld\n", out->bmiHeader.biWidth);
+        TRACE("out->compr  = %#lx\n", out->bmiHeader.biCompression);
+
+        if ( out->bmiHeader.biCompression != BI_RGB )
+        {
+            TRACE("incompatible compression requested\n");
+            return ICERR_BADFORMAT;
+        }
+
+        if ( out->bmiHeader.biBitCount != 32 && out->bmiHeader.biBitCount != 16 )
+        {
+            TRACE("incompatible depth requested\n");
+            return ICERR_BADFORMAT;
+        }
+
+        if ( in->bmiHeader.biPlanes != out->bmiHeader.biPlanes ||
+             in->bmiHeader.biHeight != abs(out->bmiHeader.biHeight) ||
+             in->bmiHeader.biWidth  != out->bmiHeader.biWidth )
+        {
+            TRACE("incompatible output dimensions requested\n");
+            return ICERR_BADFORMAT;
+        }
+    }
+
+    return ICERR_OK;
+}
+
+static LRESULT
+IV50_DecompressGetFormat( LPBITMAPINFO in, LPBITMAPINFO out )
+{
+    DWORD size;
+
+    TRACE("ICM_DECOMPRESS_GETFORMAT %p %p\n", in, out);
+
+    if ( !in )
+        return ICERR_BADPARAM;
+
+    if ( in->bmiHeader.biCompression != IV50_MAGIC )
+        return ICERR_BADFORMAT;
+
+    size = in->bmiHeader.biSize;
+    if ( out )
+    {
+        memcpy( out, in, size );
+        out->bmiHeader.biHeight = abs(in->bmiHeader.biHeight);
+        out->bmiHeader.biCompression = BI_RGB;
+        out->bmiHeader.biBitCount = 32;
+        out->bmiHeader.biSizeImage = out->bmiHeader.biWidth * out->bmiHeader.biHeight * 4;
+        return ICERR_OK;
+    }
+
+    return size;
+}
+
+static LRESULT IV50_DecompressBegin( IMFTransform *decoder, LPBITMAPINFO in, LPBITMAPINFO out )
+{
+    IMFMediaType *input_type, *output_type;
+    const GUID *output_subtype;
+    LRESULT r = ICERR_INTERNAL;
+
+    TRACE("ICM_DECOMPRESS_BEGIN %p %p %p\n", decoder, in, out);
+
+    if ( !decoder )
+        return ICERR_BADPARAM;
+
+    if ( out->bmiHeader.biBitCount == 32 )
+        output_subtype = &MFVideoFormat_RGB32;
+    else if ( out->bmiHeader.biBitCount == 16 )
+        output_subtype = &MFVideoFormat_RGB555;
+    else
+        return ICERR_BADFORMAT;
+
+    if ( FAILED(MFCreateMediaType( &input_type )) )
+        return ICERR_INTERNAL;
+
+    if ( FAILED(MFCreateMediaType( &output_type )) )
+    {
+        IMFMediaType_Release( input_type );
+        return ICERR_INTERNAL;
+    }
+
+    if ( FAILED(IMFMediaType_SetGUID( input_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video )) ||
+         FAILED(IMFMediaType_SetGUID( input_type, &MF_MT_SUBTYPE, &MFVideoFormat_IV50 )) )
+        goto done;
+    if ( FAILED(IMFMediaType_SetUINT64(
+                    input_type, &MF_MT_FRAME_SIZE,
+                    make_uint64( in->bmiHeader.biWidth, in->bmiHeader.biHeight ) )) )
+        goto done;
+
+    if ( FAILED(IMFMediaType_SetGUID( output_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video )) ||
+         FAILED(IMFMediaType_SetGUID( output_type, &MF_MT_SUBTYPE, output_subtype )) )
+        goto done;
+    if ( FAILED(IMFMediaType_SetUINT64(
+                    output_type, &MF_MT_FRAME_SIZE,
+                    make_uint64( out->bmiHeader.biWidth, abs(out->bmiHeader.biHeight) ) )) )
+        goto done;
+
+    if ( FAILED(IMFTransform_SetInputType( decoder, 0, input_type, 0 )) ||
+         FAILED(IMFTransform_SetOutputType( decoder, 0, output_type, 0 )) )
+        goto done;
+
+    r = ICERR_OK;
+
+done:
+    IMFMediaType_Release( input_type );
+    IMFMediaType_Release( output_type );
+    return r;
+}
+
+static LRESULT IV50_Decompress( IMFTransform *decoder, ICDECOMPRESS *icd, DWORD size )
+{
+    IMFSample *in_sample = NULL, *out_sample = NULL;
+    IMFMediaBuffer *in_buf = NULL, *out_buf = NULL;
+    MFT_OUTPUT_DATA_BUFFER mft_buf;
+    DWORD mft_status;
+    BYTE *data;
+    HRESULT hr;
+    LRESULT r = ICERR_INTERNAL;
+
+    TRACE("ICM_DECOMPRESS %p %p %lu\n", decoder, icd, size);
+
+    if ( FAILED(MFCreateSample( &in_sample )) )
+        return ICERR_INTERNAL;
+
+    if ( FAILED(MFCreateMemoryBuffer( icd->lpbiInput->biSizeImage, &in_buf )) )
+        goto done;
+
+    if ( FAILED(IMFSample_AddBuffer( in_sample, in_buf )) )
+        goto done;
+
+    if ( FAILED(MFCreateSample( &out_sample )) )
+        goto done;
+
+    if ( FAILED(MFCreateMemoryBuffer( icd->lpbiOutput->biSizeImage, &out_buf )) )
+        goto done;
+
+    if ( FAILED(IMFSample_AddBuffer( out_sample, out_buf )) )
+        goto done;
+
+    if ( FAILED(IMFMediaBuffer_Lock( in_buf, &data, NULL, NULL )))
+        goto done;
+
+    memcpy( data, icd->lpInput, icd->lpbiInput->biSizeImage );
+
+    if ( FAILED(IMFMediaBuffer_Unlock( in_buf )) )
+        goto done;
+
+    if ( FAILED(IMFMediaBuffer_SetCurrentLength( in_buf, icd->lpbiInput->biSizeImage )) )
+        goto done;
+
+    if ( FAILED(IMFTransform_ProcessInput( decoder, 0, in_sample, 0 )) )
+        goto done;
+
+    memset( &mft_buf, 0, sizeof(mft_buf) );
+    mft_buf.pSample = out_sample;
+
+    hr = IMFTransform_ProcessOutput( decoder, 0, 1, &mft_buf, &mft_status );
+    if ( SUCCEEDED(hr) && (mft_status & MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) )
+        hr = IMFTransform_ProcessOutput( decoder, 0, 1, &mft_buf, &mft_status );
+
+    if ( SUCCEEDED(hr) )
+    {
+        LONG width = icd->lpbiOutput->biWidth * (icd->lpbiOutput->biBitCount / 8);
+        LONG height = abs( icd->lpbiOutput->biHeight );
+        LONG data_stride = (width + 3) & ~3;
+        LONG out_stride = icd->lpbiOutput->biHeight >= 0 ? -data_stride : data_stride;
+        BYTE *output_start = (BYTE *)icd->lpOutput;
+
+        if (out_stride < 0)
+            output_start += (height - 1) * abs(out_stride);
+
+        if ( FAILED(IMFMediaBuffer_Lock( out_buf, &data, NULL, NULL )))
+            goto done;
+
+        MFCopyImage( output_start, out_stride, data, data_stride, width, height );
+
+        IMFMediaBuffer_Unlock( out_buf );
+        r = ICERR_OK;
+    }
+    else if ( hr == MF_E_TRANSFORM_NEED_MORE_INPUT )
+    {
+        TRACE("no output received.\n");
+        r = ICERR_OK;
+    }
+
+done:
+    if ( in_buf )
+        IMFMediaBuffer_Release( in_buf );
+    if ( in_sample )
+        IMFSample_Release( in_sample );
+    if ( out_buf )
+        IMFMediaBuffer_Release( out_buf );
+    if ( out_sample )
+        IMFSample_Release( out_sample );
+
+    return r;
+}
+
+static LRESULT IV50_GetInfo( ICINFO *icinfo, DWORD dwSize )
+{
+    TRACE("ICM_GETINFO %p %lu\n", icinfo, dwSize);
+
+    if ( !icinfo ) return sizeof(ICINFO);
+    if ( dwSize < sizeof(ICINFO) ) return 0;
+
+    icinfo->dwSize       = sizeof(ICINFO);
+    icinfo->fccType      = ICTYPE_VIDEO;
+    icinfo->fccHandler   = IV50_MAGIC;
+    icinfo->dwFlags      = 0;
+    icinfo->dwVersion    = ICVERSION;
+    icinfo->dwVersionICM = ICVERSION;
+
+    LoadStringW( IR50_32_hModule, IDS_NAME, icinfo->szName, ARRAY_SIZE(icinfo->szName) );
+    LoadStringW( IR50_32_hModule, IDS_DESCRIPTION, icinfo->szDescription, ARRAY_SIZE(icinfo->szDescription) );
+    /* msvfw32 will fill icinfo->szDriver for us */
+
+    return sizeof(ICINFO);
+}
+
+/***********************************************************************
+ *              DriverProc (IR50_32.@)
+ */
+LRESULT WINAPI IV50_DriverProc( DWORD_PTR dwDriverId, HDRVR hdrvr, UINT msg,
+                                LPARAM lParam1, LPARAM lParam2 )
+{
+    IMFTransform *decoder = (IMFTransform *) dwDriverId;
+    LRESULT r = ICERR_UNSUPPORTED;
+
+    TRACE("%Id %p %04x %08Ix %08Ix\n", dwDriverId, hdrvr, msg, lParam1, lParam2);
+
+    switch( msg )
+    {
+    case DRV_LOAD:
+        TRACE("DRV_LOAD\n");
+        r = 1;
+        break;
+
+    case DRV_OPEN:
+        r = IV50_Open((ICINFO *)lParam2);
+        break;
+
+    case DRV_CLOSE:
+        TRACE("DRV_CLOSE\n");
+        if ( decoder )
+            IMFTransform_Release( decoder );
+        r = 1;
+        break;
+
+    case DRV_ENABLE:
+    case DRV_DISABLE:
+    case DRV_FREE:
+        break;
+
+    case ICM_GETINFO:
+        r = IV50_GetInfo( (ICINFO *) lParam1, (DWORD) lParam2 );
+        break;
+
+    case ICM_DECOMPRESS_QUERY:
+        r = IV50_DecompressQuery( (LPBITMAPINFO) lParam1, (LPBITMAPINFO) lParam2 );
+        break;
+
+    case ICM_DECOMPRESS_GET_FORMAT:
+        r = IV50_DecompressGetFormat( (LPBITMAPINFO) lParam1, (LPBITMAPINFO) lParam2 );
+        break;
+
+    case ICM_DECOMPRESS_GET_PALETTE:
+        FIXME("ICM_DECOMPRESS_GET_PALETTE\n");
+        break;
+
+    case ICM_DECOMPRESS:
+        r = IV50_Decompress( decoder, (ICDECOMPRESS *) lParam1, (DWORD) lParam2 );
+        break;
+
+    case ICM_DECOMPRESS_BEGIN:
+        r = IV50_DecompressBegin( decoder, (LPBITMAPINFO) lParam1, (LPBITMAPINFO) lParam2 );
+        break;
+
+    case ICM_DECOMPRESS_END:
+        r = ICERR_UNSUPPORTED;
+        break;
+
+    case ICM_DECOMPRESSEX_QUERY:
+        FIXME("ICM_DECOMPRESSEX_QUERY\n");
+        break;
+
+    case ICM_DECOMPRESSEX:
+        FIXME("ICM_DECOMPRESSEX\n");
+        break;
+
+    case ICM_COMPRESS_QUERY:
+        r = ICERR_BADFORMAT;
+        /* fall through */
+    case ICM_COMPRESS_GET_FORMAT:
+    case ICM_COMPRESS_END:
+    case ICM_COMPRESS:
+        FIXME("compression not implemented\n");
+        break;
+
+    case ICM_CONFIGURE:
+        break;
+
+    default:
+        FIXME("Unknown message: %04x %Id %Id\n", msg, lParam1, lParam2);
+    }
+
+    return r;
+}
+
+/***********************************************************************
+ *              DllMain
+ */
+BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
+{
+    TRACE("(%p,%lu,%p)\n", hModule, dwReason, lpReserved);
+
+    switch (dwReason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(hModule);
+        IR50_32_hModule = hModule;
+        break;
+    }
+    return TRUE;
+}
diff --git a/dlls/ir50_32/ir50_32.rc b/dlls/ir50_32/ir50_32.rc
new file mode 100644
index 00000000000..fd98f76fbf6
--- /dev/null
+++ b/dlls/ir50_32/ir50_32.rc
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2023 Shaun Ren for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "ir50_private.h"
+
+#pragma makedep po
+
+LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT
+
+STRINGTABLE
+{
+    IDS_NAME        "Indeo5"
+    IDS_DESCRIPTION "Indeo Video Interactive version 5 video codec"
+}
diff --git a/dlls/ir50_32/ir50_32.spec b/dlls/ir50_32/ir50_32.spec
new file mode 100644
index 00000000000..e5c54ef9c56
--- /dev/null
+++ b/dlls/ir50_32/ir50_32.spec
@@ -0,0 +1 @@
+@ stdcall -private DriverProc(long long long long long) IV50_DriverProc
diff --git a/dlls/ir50_32/ir50_private.h b/dlls/ir50_32/ir50_private.h
new file mode 100644
index 00000000000..c0b96bc17e4
--- /dev/null
+++ b/dlls/ir50_32/ir50_private.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2023 Shaun Ren for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __IR50_PRIVATE_H
+#define __IR50_PRIVATE_H
+
+#include <windef.h>
+
+#define COBJMACROS
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mfidl.h"
+#include "mftransform.h"
+
+#define IDS_NAME        100
+#define IDS_DESCRIPTION 101
+
+HRESULT WINAPI winegstreamer_create_video_decoder(IMFTransform **out);
+
+#endif /* __IR50_PRIVATE_H */
diff --git a/dlls/irprops.cpl/Makefile.in b/dlls/irprops.cpl/Makefile.in
index 7270ca32b83..89f72d17b0c 100644
--- a/dlls/irprops.cpl/Makefile.in
+++ b/dlls/irprops.cpl/Makefile.in
@@ -1 +1,2 @@
-MODULE    = irprops.cpl
+MODULE  = irprops.cpl
+IMPORTS = bluetoothapis
diff --git a/dlls/irprops.cpl/irprops.cpl.spec b/dlls/irprops.cpl/irprops.cpl.spec
index 252410f589f..b2bdf3c3b2a 100644
--- a/dlls/irprops.cpl/irprops.cpl.spec
+++ b/dlls/irprops.cpl/irprops.cpl.spec
@@ -8,30 +8,30 @@
 @ stub BluetoothEnumerateInstalledServices
 @ stub BluetoothFindBrowseGroupClose
 @ stub BluetoothFindClassIdClose
-@ stdcall BluetoothFindDeviceClose(ptr) bthprops.cpl.BluetoothFindDeviceClose
+@ stdcall -import BluetoothFindDeviceClose(ptr)
 @ stub BluetoothFindFirstBrowseGroup
 @ stub BluetoothFindFirstClassId
-@ stdcall BluetoothFindFirstDevice(ptr ptr) bthprops.cpl.BluetoothFindFirstDevice
+@ stdcall -import BluetoothFindFirstDevice(ptr ptr)
 @ stub BluetoothFindFirstProfileDescriptor
 @ stub BluetoothFindFirstProtocolDescriptorStack
 @ stub BluetoothFindFirstProtocolEntry
-@ stdcall BluetoothFindFirstRadio(ptr ptr) bthprops.cpl.BluetoothFindFirstRadio
+@ stdcall -import BluetoothFindFirstRadio(ptr ptr)
 @ stub BluetoothFindFirstService
 @ stub BluetoothFindNextBrowseGroup
 @ stub BluetoothFindNextClassId
-@ stdcall BluetoothFindNextDevice(ptr ptr) bthprops.cpl.BluetoothFindNextDevice
+@ stdcall -import BluetoothFindNextDevice(ptr ptr)
 @ stub BluetoothFindNextProfileDescriptor
 @ stub BluetoothFindNextProtocolDescriptorStack
 @ stub BluetoothFindNextProtocolEntry
-@ stdcall BluetoothFindNextRadio(ptr ptr) bthprops.cpl.BluetoothFindNextRadio
+@ stdcall -import BluetoothFindNextRadio(ptr ptr)
 @ stub BluetoothFindNextService
 @ stub BluetoothFindProfileDescriptorClose
 @ stub BluetoothFindProtocolDescriptorStackClose
 @ stub BluetoothFindProtocolEntryClose
-@ stdcall BluetoothFindRadioClose(ptr) bthprops.cpl.BluetoothFindRadioClose
+@ stdcall -import BluetoothFindRadioClose(ptr)
 @ stub BluetoothFindServiceClose
 @ stub BluetoothGetDeviceInfo
-@ stdcall BluetoothGetRadioInfo(ptr ptr) bthprops.cpl.BluetoothGetRadioInfo
+@ stdcall -import BluetoothGetRadioInfo(ptr ptr)
 @ stub BluetoothIsConnectable
 @ stub BluetoothIsDiscoverable
 @ stub BluetoothMapClassOfDeviceToImageIndex
@@ -47,6 +47,6 @@
 @ stub BluetoothSelectDevicesFree
 @ stub BluetoothSendAuthenticationResponse
 @ stub BluetoothSetServiceState
-@ stub BluetoothUnregisterAuthentication
+@ stdcall -import BluetoothUnregisterAuthentication(long)
 @ stub BluetoothUpdateDeviceRecord
 #@ stub CPlApplet
diff --git a/dlls/joy.cpl/dinput.c b/dlls/joy.cpl/dinput.c
index 521634ff7da..f624e650147 100644
--- a/dlls/joy.cpl/dinput.c
+++ b/dlls/joy.cpl/dinput.c
@@ -236,7 +236,7 @@ static BOOL CALLBACK enum_devices( const DIDEVICEINSTANCEW *instance, void *cont
     if (!(entry = calloc( 1, sizeof(*entry) ))) return DIENUM_STOP;
 
     IDirectInput8_CreateDevice( dinput, &instance->guidInstance, &entry->device, NULL );
-    IDirectInputDevice8_SetDataFormat( entry->device, &c_dfDIJoystick );
+    IDirectInputDevice8_SetDataFormat( entry->device, &c_dfDIJoystick2 );
     IDirectInputDevice8_GetCapabilities( entry->device, &caps );
 
     list_add_tail( &devices, &entry->entry );
@@ -266,7 +266,7 @@ static DWORD WINAPI input_thread( void *param )
     while (WaitForMultipleObjects( 2, events, FALSE, INFINITE ) != 0)
     {
         IDirectInputEffect *effect;
-        DIJOYSTATE state = {0};
+        DIJOYSTATE2 state = {0};
         unsigned int i;
 
         SendMessageW( dialog_hwnd, WM_USER, 0, 0 );
@@ -417,7 +417,8 @@ static void draw_button_view( HDC hdc, RECT rect, BOOL set, const WCHAR *name )
     SelectObject( hdc, GetStockObject( DC_BRUSH ) );
     SelectObject( hdc, GetStockObject( DC_PEN ) );
 
-    Ellipse( hdc, rect.left, rect.top, rect.right, rect.bottom );
+    if (rect.right - rect.left < 16) Rectangle( hdc, rect.left, rect.top, rect.right, rect.bottom );
+    else Ellipse( hdc, rect.left, rect.top, rect.right, rect.bottom );
 
     color = SetTextColor( hdc, GetSysColor( set ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT ) );
     font = SelectObject( hdc, GetStockObject( ANSI_VAR_FONT ) );
@@ -436,7 +437,7 @@ LRESULT CALLBACK test_di_axes_window_proc( HWND hwnd, UINT msg, WPARAM wparam, L
     {
         DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
         IDirectInputDevice8W *device;
-        DIJOYSTATE state = {0};
+        DIJOYSTATE2 state = {0};
         RECT rect, tmp_rect;
         PAINTSTRUCT paint;
         HDC hdc;
@@ -502,7 +503,7 @@ LRESULT CALLBACK test_di_povs_window_proc( HWND hwnd, UINT msg, WPARAM wparam, L
     {
         DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
         IDirectInputDevice8W *device;
-        DIJOYSTATE state = {0};
+        DIJOYSTATE2 state = {0};
         PAINTSTRUCT paint;
         RECT rect;
         HDC hdc;
@@ -546,7 +547,7 @@ LRESULT CALLBACK test_di_buttons_window_proc( HWND hwnd, UINT msg, WPARAM wparam
         DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
         UINT i, j, offs, size, step, space = 2;
         IDirectInputDevice8W *device;
-        DIJOYSTATE state = {0};
+        DIJOYSTATE2 state = {0};
         PAINTSTRUCT paint;
         RECT rect;
         HDC hdc;
@@ -559,11 +560,12 @@ LRESULT CALLBACK test_di_buttons_window_proc( HWND hwnd, UINT msg, WPARAM wparam
         }
 
         if (caps.dwButtons <= 48) step = 16;
-        else step = 32;
+        else step = 24;
 
         hdc = BeginPaint( hwnd, &paint );
 
         GetClientRect( hwnd, &rect );
+        FillRect( hdc, &rect, (HBRUSH)(COLOR_WINDOW + 1) );
 
         size = (rect.right - rect.left - space) / step;
         offs = (rect.right - rect.left - step * size - space) / 2;
@@ -578,7 +580,8 @@ LRESULT CALLBACK test_di_buttons_window_proc( HWND hwnd, UINT msg, WPARAM wparam
             for (j = 0; j < step && i < caps.dwButtons; j++, i++)
             {
                 WCHAR buffer[3];
-                swprintf( buffer, ARRAY_SIZE(buffer), L"%d", i );
+                if (step == 24) swprintf( buffer, ARRAY_SIZE(buffer), L"%02x", i );
+                else swprintf( buffer, ARRAY_SIZE(buffer), L"%d", i );
                 draw_button_view( hdc, rect, state.rgbButtons[i], buffer );
                 OffsetRect( &rect, size, 0 );
             }
@@ -674,7 +677,7 @@ static void create_device_views( HWND hwnd )
     GetClientRect( parent, &rect );
     rect.top += 10;
 
-    margin = (rect.bottom - rect.top) * 10 / 100;
+    margin = (rect.bottom - rect.top) * 5 / 100;
     InflateRect( &rect, -margin, -margin );
 
     CreateWindowW( L"JoyCplDInputButtons", NULL, WS_CHILD | WS_VISIBLE, rect.left, rect.top,
@@ -762,6 +765,8 @@ INT_PTR CALLBACK test_di_dialog_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM
 
             SendDlgItemMessageW( hwnd, IDC_DI_EFFECTS, LB_SETCURSEL, 0, 0 );
             handle_di_effects_change( hwnd );
+
+            update_device_views( hwnd );
             break;
 
         case MAKEWPARAM( IDC_DI_EFFECTS, LBN_SELCHANGE ):
@@ -792,7 +797,16 @@ INT_PTR CALLBACK test_di_dialog_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM
         case PSN_RESET:
         case PSN_KILLACTIVE:
             SetEvent( thread_stop );
-            MsgWaitForMultipleObjects( 1, &thread, FALSE, INFINITE, 0 );
+            /* wait for the input thread to stop, processing any WM_USER message from it */
+            while (MsgWaitForMultipleObjects( 1, &thread, FALSE, INFINITE, QS_ALLINPUT ) == 1)
+            {
+                MSG msg;
+                while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
+                {
+                    TranslateMessage( &msg );
+                    DispatchMessageW( &msg );
+                }
+            }
             CloseHandle( state_event );
             CloseHandle( thread_stop );
             CloseHandle( thread );
diff --git a/dlls/joy.cpl/joy.rc b/dlls/joy.cpl/joy.rc
index 08f6fa12e0c..76d8bb401e4 100644
--- a/dlls/joy.cpl/joy.rc
+++ b/dlls/joy.cpl/joy.rc
@@ -57,9 +57,9 @@ FONT 8, "Ms Shell Dlg"
     COMBOBOX        IDC_DI_DEVICES, 15, 10, 291, 60, CBS_DROPDOWNLIST | CBS_HASSTRINGS
     GROUPBOX        "Axes", IDC_DI_AXES, 15, 30, 214, 60
     GROUPBOX        "POVs", IDC_DI_POVS, 246, 30, 60, 60
-    GROUPBOX        "Buttons", IDC_DI_BUTTONS, 15, 100, 291, 70
-    LTEXT           "Force Feedback Effect", IDC_STATIC, 15, 180, 291, 10
-    LISTBOX         IDC_DI_EFFECTS, 15, 190, 291, 70, WS_TABSTOP | WS_VSCROLL | LBS_NOTIFY
+    GROUPBOX        "Buttons", IDC_DI_BUTTONS, 15, 100, 291, 86
+    LTEXT           "Force Feedback Effect", IDC_STATIC, 15, 196, 291, 10
+    LISTBOX         IDC_DI_EFFECTS, 15, 206, 291, 54, WS_TABSTOP | WS_VSCROLL | LBS_NOTIFY
     LTEXT           "Press any button in the controller to activate the chosen effect. The effect direction can be changed with the controller axis.",
                     IDC_STATIC, 15, 260, 291, 25
 }
diff --git a/dlls/joy.cpl/xinput.c b/dlls/joy.cpl/xinput.c
index 757b99fa333..f652c9ad171 100644
--- a/dlls/joy.cpl/xinput.c
+++ b/dlls/joy.cpl/xinput.c
@@ -428,7 +428,16 @@ extern INT_PTR CALLBACK test_xi_dialog_proc( HWND hwnd, UINT msg, WPARAM wparam,
         case PSN_RESET:
         case PSN_KILLACTIVE:
             SetEvent( thread_stop );
-            MsgWaitForMultipleObjects( 1, &thread, FALSE, INFINITE, 0 );
+            /* wait for the input thread to stop, processing any WM_USER message from it */
+            while (MsgWaitForMultipleObjects( 1, &thread, FALSE, INFINITE, QS_ALLINPUT ) == 1)
+            {
+                MSG msg;
+                while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
+                {
+                    TranslateMessage( &msg );
+                    DispatchMessageW( &msg );
+                }
+            }
             CloseHandle( thread_stop );
             CloseHandle( thread );
             dialog_hwnd = 0;
diff --git a/dlls/jscript/dispex.c b/dlls/jscript/dispex.c
index 2c35f2ae9cc..dd91a577159 100644
--- a/dlls/jscript/dispex.c
+++ b/dlls/jscript/dispex.c
@@ -572,9 +572,9 @@ static HRESULT invoke_prop_func(jsdisp_t *This, IDispatch *jsthis, dispex_prop_t
 
         TRACE("call %s %p\n", debugstr_w(prop->name), get_object(prop->u.val));
 
-        return disp_call_value(This->ctx, get_object(prop->u.val),
-                               jsval_disp(jsthis ? jsthis : (IDispatch*)&This->IDispatchEx_iface),
-                               flags, argc, argv, r);
+        return disp_call_value_with_caller(This->ctx, get_object(prop->u.val),
+                jsval_disp(jsthis ? jsthis : (IDispatch*)&This->IDispatchEx_iface),
+                flags, argc, argv, r, caller);
     }
     case PROP_ACCESSOR:
     case PROP_IDX: {
@@ -585,9 +585,9 @@ static HRESULT invoke_prop_func(jsdisp_t *This, IDispatch *jsthis, dispex_prop_t
             return hres;
 
         if(is_object_instance(val)) {
-            hres = disp_call_value(This->ctx, get_object(val),
-                                   jsval_disp(jsthis ? jsthis : (IDispatch*)&This->IDispatchEx_iface),
-                                   flags, argc, argv, r);
+            hres = disp_call_value_with_caller(This->ctx, get_object(val),
+                    jsval_disp(jsthis ? jsthis : (IDispatch*)&This->IDispatchEx_iface),
+                    flags, argc, argv, r, caller);
         }else {
             FIXME("invoke %s\n", debugstr_jsval(val));
             hres = E_NOTIMPL;
@@ -1900,6 +1900,7 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
         VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
 {
     jsdisp_t *This = impl_from_IDispatchEx(iface);
+    IServiceProvider *prev_caller;
     dispex_prop_t *prop;
     jsexcept_t ei;
     HRESULT hres;
@@ -1917,6 +1918,11 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
 
     enter_script(This->ctx, &ei);
 
+    prev_caller = This->ctx->jscaller->caller;
+    This->ctx->jscaller->caller = pspCaller;
+    if(pspCaller)
+        IServiceProvider_AddRef(pspCaller);
+
     switch(wFlags) {
     case DISPATCH_METHOD|DISPATCH_PROPERTYGET:
         wFlags = DISPATCH_METHOD;
@@ -2000,6 +2006,9 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
         break;
     }
 
+    This->ctx->jscaller->caller = prev_caller;
+    if(pspCaller)
+        IServiceProvider_Release(pspCaller);
     return leave_script(This->ctx, hres);
 }
 
@@ -2355,7 +2364,7 @@ HRESULT jsdisp_call(jsdisp_t *disp, DISPID id, WORD flags, unsigned argc, jsval_
     if(!prop)
         return DISP_E_MEMBERNOTFOUND;
 
-    return invoke_prop_func(disp, to_disp(disp), prop, flags, argc, argv, r, NULL);
+    return invoke_prop_func(disp, to_disp(disp), prop, flags, argc, argv, r, &disp->ctx->jscaller->IServiceProvider_iface);
 }
 
 HRESULT jsdisp_call_name(jsdisp_t *disp, const WCHAR *name, WORD flags, unsigned argc, jsval_t *argv, jsval_t *r)
@@ -2370,10 +2379,11 @@ HRESULT jsdisp_call_name(jsdisp_t *disp, const WCHAR *name, WORD flags, unsigned
     if(!prop || prop->type == PROP_DELETED)
         return JS_E_INVALID_PROPERTY;
 
-    return invoke_prop_func(disp, to_disp(disp), prop, flags, argc, argv, r, NULL);
+    return invoke_prop_func(disp, to_disp(disp), prop, flags, argc, argv, r, &disp->ctx->jscaller->IServiceProvider_iface);
 }
 
-static HRESULT disp_invoke(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD flags, DISPPARAMS *params, VARIANT *r)
+static HRESULT disp_invoke(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD flags, DISPPARAMS *params, VARIANT *r,
+        IServiceProvider *caller)
 {
     IDispatchEx *dispex;
     EXCEPINFO ei;
@@ -2382,7 +2392,7 @@ static HRESULT disp_invoke(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD f
     memset(&ei, 0, sizeof(ei));
     hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
     if(SUCCEEDED(hres)) {
-        hres = IDispatchEx_InvokeEx(dispex, id, ctx->lcid, flags, params, r, &ei, &ctx->jscaller->IServiceProvider_iface);
+        hres = IDispatchEx_InvokeEx(dispex, id, ctx->lcid, flags, params, r, &ei, caller);
         IDispatchEx_Release(dispex);
     }else {
         UINT err = 0;
@@ -2480,7 +2490,7 @@ HRESULT disp_call(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD flags, uns
     }
 
     V_VT(&retv) = VT_EMPTY;
-    hres = disp_invoke(ctx, disp, id, flags, &dp, ret ? &retv : NULL);
+    hres = disp_invoke(ctx, disp, id, flags, &dp, ret ? &retv : NULL, &ctx->jscaller->IServiceProvider_iface);
 
     for(i=0; i<argc; i++)
         VariantClear(dp.rgvarg+argc-i-1);
@@ -2520,8 +2530,8 @@ HRESULT disp_call_name(script_ctx_t *ctx, IDispatch *disp, const WCHAR *name, WO
     return disp_call(ctx, disp, id, flags, argc, argv, ret);
 }
 
-HRESULT disp_call_value(script_ctx_t *ctx, IDispatch *disp, jsval_t vthis, WORD flags, unsigned argc, jsval_t *argv,
-        jsval_t *r)
+HRESULT disp_call_value_with_caller(script_ctx_t *ctx, IDispatch *disp, jsval_t vthis, WORD flags, unsigned argc,
+        jsval_t *argv, jsval_t *r, IServiceProvider *caller)
 {
     VARIANT buf[6], retv, *args = buf;
     IDispatch *jsthis;
@@ -2577,7 +2587,7 @@ HRESULT disp_call_value(script_ctx_t *ctx, IDispatch *disp, jsval_t vthis, WORD
 
     if(SUCCEEDED(hres)) {
         V_VT(&retv) = VT_EMPTY;
-        hres = disp_invoke(ctx, disp, DISPID_VALUE, flags, &dp, r ? &retv : NULL);
+        hres = disp_invoke(ctx, disp, DISPID_VALUE, flags, &dp, r ? &retv : NULL, caller);
     }
 
     for(i = 0; i < argc; i++)
@@ -2656,7 +2666,7 @@ HRESULT disp_propput(script_ctx_t *ctx, IDispatch *disp, DISPID id, jsval_t val)
         if(V_VT(&var) == VT_DISPATCH)
             flags |= DISPATCH_PROPERTYPUTREF;
 
-        hres = disp_invoke(ctx, disp, id, flags, &dp, NULL);
+        hres = disp_invoke(ctx, disp, id, flags, &dp, NULL, &ctx->jscaller->IServiceProvider_iface);
         VariantClear(&var);
     }
 
@@ -2764,7 +2774,7 @@ HRESULT disp_propget(script_ctx_t *ctx, IDispatch *disp, DISPID id, jsval_t *val
         jsdisp_release(jsdisp);
 
     V_VT(&var) = VT_EMPTY;
-    hres = disp_invoke(ctx, disp, id, INVOKE_PROPERTYGET, &dp, &var);
+    hres = disp_invoke(ctx, disp, id, INVOKE_PROPERTYGET, &dp, &var, &ctx->jscaller->IServiceProvider_iface);
     if(SUCCEEDED(hres)) {
         hres = variant_to_jsval(ctx, &var, val);
         VariantClear(&var);
diff --git a/dlls/jscript/jscript.c b/dlls/jscript/jscript.c
index f5331a13b96..401f6ca85b0 100644
--- a/dlls/jscript/jscript.c
+++ b/dlls/jscript/jscript.c
@@ -428,6 +428,17 @@ static void release_named_item_list(JScript *This)
     }
 }
 
+static HRESULT exec_global_code(script_ctx_t *ctx, bytecode_t *code, jsval_t *r)
+{
+    IServiceProvider *prev_caller = ctx->jscaller->caller;
+    HRESULT hres;
+
+    ctx->jscaller->caller = SP_CALLER_UNINITIALIZED;
+    hres = exec_source(ctx, EXEC_GLOBAL, code, &code->global_code, NULL, NULL, NULL, 0, NULL, r);
+    ctx->jscaller->caller = prev_caller;
+    return hres;
+}
+
 static void exec_queued_code(JScript *This)
 {
     bytecode_t *iter;
@@ -436,7 +447,7 @@ static void exec_queued_code(JScript *This)
 
     LIST_FOR_EACH_ENTRY(iter, &This->queued_code, bytecode_t, entry) {
         enter_script(This->ctx, &ei);
-        hres = exec_source(This->ctx, EXEC_GLOBAL, iter, &iter->global_code, NULL, NULL, NULL, 0, NULL, NULL);
+        hres = exec_global_code(This->ctx, iter, NULL);
         leave_script(This->ctx, hres);
         if(FAILED(hres))
             break;
@@ -1103,7 +1114,7 @@ static HRESULT WINAPI JScriptParse_ParseScriptText(IActiveScriptParse *iface,
     if(dwFlags & SCRIPTTEXT_ISEXPRESSION) {
         jsval_t r;
 
-        hres = exec_source(This->ctx, EXEC_GLOBAL, code, &code->global_code, NULL, NULL, NULL, 0, NULL, &r);
+        hres = exec_global_code(This->ctx, code, &r);
         if(SUCCEEDED(hres)) {
             if(pvarResult)
                 hres = jsval_to_variant(r, pvarResult);
@@ -1122,7 +1133,7 @@ static HRESULT WINAPI JScriptParse_ParseScriptText(IActiveScriptParse *iface,
     if(!pvarResult && !is_started(This->ctx)) {
         list_add_tail(&This->queued_code, &code->entry);
     }else {
-        hres = exec_source(This->ctx, EXEC_GLOBAL, code, &code->global_code, NULL, NULL, NULL, 0, NULL, NULL);
+        hres = exec_global_code(This->ctx, code, NULL);
         if(code->is_persistent)
             list_add_tail(&This->persistent_code, &code->entry);
         else
diff --git a/dlls/jscript/jscript.h b/dlls/jscript/jscript.h
index b633f390508..32c2d8eb726 100644
--- a/dlls/jscript/jscript.h
+++ b/dlls/jscript/jscript.h
@@ -240,7 +240,7 @@ HRESULT init_dispex_from_constr(jsdisp_t*,script_ctx_t*,const builtin_info_t*,js
 
 HRESULT disp_call(script_ctx_t*,IDispatch*,DISPID,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT disp_call_name(script_ctx_t*,IDispatch*,const WCHAR*,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
-HRESULT disp_call_value(script_ctx_t*,IDispatch*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
+HRESULT disp_call_value_with_caller(script_ctx_t*,IDispatch*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*,IServiceProvider*) DECLSPEC_HIDDEN;
 HRESULT jsdisp_call_value(jsdisp_t*,jsval_t,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT jsdisp_call(jsdisp_t*,DISPID,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
 HRESULT jsdisp_call_name(jsdisp_t*,const WCHAR*,WORD,unsigned,jsval_t*,jsval_t*) DECLSPEC_HIDDEN;
@@ -331,12 +331,15 @@ typedef struct {
 
 void release_cc(cc_ctx_t*) DECLSPEC_HIDDEN;
 
+#define SP_CALLER_UNINITIALIZED ((IServiceProvider*)IntToPtr(-1))
+
 typedef struct {
     IServiceProvider IServiceProvider_iface;
 
     LONG ref;
 
     script_ctx_t *ctx;
+    IServiceProvider *caller;
 } JSCaller;
 
 #include "jsval.h"
@@ -480,6 +483,12 @@ static inline DWORD make_grfdex(script_ctx_t *ctx, DWORD flags)
     return ((ctx->version & 0xff) << 28) | flags;
 }
 
+static inline HRESULT disp_call_value(script_ctx_t *ctx, IDispatch *disp, jsval_t vthis, WORD flags, unsigned argc,
+        jsval_t *argv, jsval_t *r)
+{
+    return disp_call_value_with_caller(ctx, disp, vthis, flags, argc, argv, r, &ctx->jscaller->IServiceProvider_iface);
+}
+
 #define FACILITY_JSCRIPT 10
 
 #define MAKE_JSERROR(code) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_JSCRIPT, code)
diff --git a/dlls/jscript/jsutils.c b/dlls/jscript/jsutils.c
index 3dfcd08f14c..a26b63833ee 100644
--- a/dlls/jscript/jsutils.c
+++ b/dlls/jscript/jsutils.c
@@ -1034,6 +1034,14 @@ static HRESULT WINAPI JSCaller_QueryService(IServiceProvider *iface, REFGUID gui
 {
     JSCaller *This = impl_from_IServiceProvider(iface);
 
+    if(IsEqualGUID(guidService, &SID_GetCaller)) {
+        TRACE("(%p)->(SID_GetCaller)\n", This);
+        *ppv = NULL;
+        if(!This->caller)
+            return S_OK;
+        return (This->caller == SP_CALLER_UNINITIALIZED) ? E_NOINTERFACE : IServiceProvider_QueryInterface(This->caller, riid, ppv);
+    }
+
     if(IsEqualGUID(guidService, &SID_VariantConversion) && This->ctx && This->ctx->active_script) {
         TRACE("(%p)->(SID_VariantConversion)\n", This);
         return IActiveScript_QueryInterface(This->ctx->active_script, riid, ppv);
@@ -1063,6 +1071,7 @@ HRESULT create_jscaller(script_ctx_t *ctx)
     ret->IServiceProvider_iface.lpVtbl = &ServiceProviderVtbl;
     ret->ref = 1;
     ret->ctx = ctx;
+    ret->caller = SP_CALLER_UNINITIALIZED;
 
     ctx->jscaller = ret;
     return S_OK;
diff --git a/dlls/jscript/tests/caller.c b/dlls/jscript/tests/caller.c
index 836f5a820a1..8a1ebb83a33 100644
--- a/dlls/jscript/tests/caller.c
+++ b/dlls/jscript/tests/caller.c
@@ -74,14 +74,23 @@ static const CLSID CLSID_JScript =
 #define CLEAR_CALLED(func) \
     expect_ ## func = called_ ## func = FALSE
 
+DEFINE_EXPECT(sp_caller_QI_NULL);
 DEFINE_EXPECT(testArgConv);
+DEFINE_EXPECT(testGetCaller);
+DEFINE_EXPECT(testGetCallerJS);
+DEFINE_EXPECT(testGetCallerNested);
 DEFINE_EXPECT(OnEnterScript);
 DEFINE_EXPECT(OnLeaveScript);
 
+static IActiveScriptParse *active_script_parser;
 static IVariantChangeType *script_change_type;
 static IDispatch *stored_obj;
+static IServiceProvider *test_get_caller_sp;
 
 #define DISPID_TEST_TESTARGCONV      0x1000
+#define DISPID_TEST_TESTGETCALLER    0x1001
+#define DISPID_TEST_TESTGETCALLERJS  0x1002
+#define DISPID_TEST_TESTGETCALLERNESTED 0x1003
 
 typedef struct {
     int int_result;
@@ -254,6 +263,55 @@ static void test_caller(IServiceProvider *caller, IDispatch *arg_obj)
     IVariantChangeType_Release(change_type);
 }
 
+static IServiceProvider sp_caller_obj;
+
+static HRESULT WINAPI sp_caller_QueryInterface(IServiceProvider *iface, REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IServiceProvider, riid))
+        *ppv = &sp_caller_obj;
+    else {
+        ok(IsEqualGUID(&IID_NULL, riid), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+        CHECK_EXPECT(sp_caller_QI_NULL);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    return S_OK;
+}
+
+static ULONG WINAPI sp_caller_AddRef(IServiceProvider *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI sp_caller_Release(IServiceProvider *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI sp_caller_QueryService(IServiceProvider *iface, REFGUID guidService,
+        REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(guidService, &SID_GetCaller)) {
+        ok(IsEqualGUID(riid, &IID_IServiceProvider), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+        *ppv = NULL;
+        return S_OK;
+    }
+
+    ok(0, "unexpected guidService %s with riid %s\n", wine_dbgstr_guid(guidService), wine_dbgstr_guid(riid));
+    *ppv = NULL;
+    return E_NOINTERFACE;
+}
+
+static const IServiceProviderVtbl sp_caller_vtbl = {
+    sp_caller_QueryInterface,
+    sp_caller_AddRef,
+    sp_caller_Release,
+    sp_caller_QueryService
+};
+
+static IServiceProvider sp_caller_obj = { &sp_caller_vtbl };
+
 static HRESULT WINAPI DispatchEx_QueryInterface(IDispatchEx *iface, REFIID riid, void **ppv)
 {
     if(IsEqualGUID(riid, &IID_IUnknown)) {
@@ -350,6 +408,21 @@ static HRESULT WINAPI Test_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD gr
         *pid = DISPID_TEST_TESTARGCONV;
         return S_OK;
     }
+    if(!lstrcmpW(bstrName, L"testGetCaller")) {
+        ok(grfdex == fdexNameCaseSensitive, "grfdex = %lx\n", grfdex);
+        *pid = DISPID_TEST_TESTGETCALLER;
+        return S_OK;
+    }
+    if(!lstrcmpW(bstrName, L"testGetCallerJS")) {
+        ok(grfdex == fdexNameCaseSensitive, "grfdex = %lx\n", grfdex);
+        *pid = DISPID_TEST_TESTGETCALLERJS;
+        return S_OK;
+    }
+    if(!lstrcmpW(bstrName, L"testGetCallerNested")) {
+        ok(grfdex == fdexNameCaseSensitive, "grfdex = %lx\n", grfdex);
+        *pid = DISPID_TEST_TESTGETCALLERNESTED;
+        return S_OK;
+    }
 
     return E_NOTIMPL;
 }
@@ -357,6 +430,9 @@ static HRESULT WINAPI Test_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD gr
 static HRESULT WINAPI Test_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
         VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
 {
+    IServiceProvider *caller = (void*)0xdeadbeef;
+    HRESULT hres;
+
     ok(pspCaller != NULL, "pspCaller == NULL\n");
 
     switch(id) {
@@ -380,6 +456,80 @@ static HRESULT WINAPI Test_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WO
         IDispatch_AddRef(stored_obj);
         break;
 
+    case DISPID_TEST_TESTGETCALLER: {
+        void *iface = (void*)0xdeadbeef;
+
+        CHECK_EXPECT(testGetCaller);
+        CHECK_CALLED(OnEnterScript);
+
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %x\n", wFlags);
+        ok(pdp != NULL, "pdp == NULL\n");
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pvarRes, "pvarRes != NULL\n");
+        ok(pei != NULL, "pei == NULL\n");
+
+        SET_EXPECT(OnEnterScript);
+        SET_EXPECT(OnLeaveScript);
+        SET_EXPECT(testGetCallerNested);
+        hres = IActiveScriptParse_ParseScriptText(active_script_parser, L"testGetCallerNested(1,2)",
+                                                  NULL, NULL, NULL, 0, 0, 0, NULL, NULL);
+        ok(hres == S_OK, "ParseScriptText failed: %08lx\n", hres);
+        CHECK_CALLED(testGetCallerNested);
+        CHECK_CALLED(OnLeaveScript);
+        CHECK_CALLED(OnEnterScript);
+        SET_EXPECT(OnLeaveScript);
+
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_IServiceProvider, (void**)&caller);
+        ok(hres == S_OK, "Could not get SID_GetCaller service: %08lx\n", hres);
+        ok(caller == test_get_caller_sp, "caller != test_get_caller_sp\n");
+        if(caller) IServiceProvider_Release(caller);
+
+        if(test_get_caller_sp)
+            SET_EXPECT(sp_caller_QI_NULL);
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_NULL, &iface);
+        ok(hres == (test_get_caller_sp ? E_NOINTERFACE : S_OK), "Could not query SID_GetCaller with IID_NULL: %08lx\n", hres);
+        ok(iface == NULL, "iface != NULL\n");
+        if(test_get_caller_sp)
+            CHECK_CALLED(sp_caller_QI_NULL);
+        break;
+    }
+
+    case DISPID_TEST_TESTGETCALLERJS:
+        CHECK_EXPECT(testGetCallerJS);
+
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %x\n", wFlags);
+        ok(pdp != NULL, "pdp == NULL\n");
+        ok(pdp->cArgs == 1, "cArgs = %d\n", pdp->cArgs);
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pvarRes, "pvarRes != NULL\n");
+        ok(pei != NULL, "pei == NULL\n");
+        ok(V_VT(pdp->rgvarg) == VT_I4, "V_VT(rgvarg) = %d\n", V_VT(pdp->rgvarg));
+        ok(V_I4(pdp->rgvarg) == 42, "V_I4(rgvarg) = %ld\n", V_I4(pdp->rgvarg));
+
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_IServiceProvider, (void**)&caller);
+        ok(hres == E_NOINTERFACE, "QueryService(SID_GetCaller) returned: %08lx\n", hres);
+        ok(caller == NULL, "caller != NULL\n");
+        break;
+
+    case DISPID_TEST_TESTGETCALLERNESTED:
+        CHECK_EXPECT(testGetCallerNested);
+
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %x\n", wFlags);
+        ok(pdp != NULL, "pdp == NULL\n");
+        ok(pdp->cArgs == 2, "cArgs = %d\n", pdp->cArgs);
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pvarRes, "pvarRes != NULL\n");
+        ok(pei != NULL, "pei == NULL\n");
+        ok(V_VT(&pdp->rgvarg[0]) == VT_I4, "V_VT(rgvarg[0]) = %d\n", V_VT(&pdp->rgvarg[0]));
+        ok(V_VT(&pdp->rgvarg[1]) == VT_I4, "V_VT(rgvarg[1]) = %d\n", V_VT(&pdp->rgvarg[1]));
+        ok(V_I4(&pdp->rgvarg[0]) == 2, "V_I4(rgvarg[0]) = %ld\n", V_I4(&pdp->rgvarg[0]));
+        ok(V_I4(&pdp->rgvarg[1]) == 1, "V_I4(rgvarg[1]) = %ld\n", V_I4(&pdp->rgvarg[1]));
+
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_IServiceProvider, (void**)&caller);
+        ok(hres == E_NOINTERFACE, "QueryService(SID_GetCaller) returned: %08lx\n", hres);
+        ok(caller == NULL, "caller != NULL\n");
+        break;
+
     default:
         ok(0, "unexpected call\n");
         return E_NOTIMPL;
@@ -542,22 +692,32 @@ static IActiveScriptParse *create_script(void)
 
 static void run_scripts(void)
 {
-    IActiveScriptParse *parser;
+    IActiveScript *active_script;
+    DISPPARAMS dp = { 0 };
+    IDispatchEx *dispex;
+    IDispatch *disp;
+    DISPID dispid;
     HRESULT hres;
+    VARIANT var;
+    BSTR bstr;
 
-    parser = create_script();
+    active_script_parser = create_script();
 
-    hres = IActiveScriptParse_QueryInterface(parser, &IID_IVariantChangeType, (void**)&script_change_type);
+    hres = IActiveScriptParse_QueryInterface(active_script_parser, &IID_IVariantChangeType, (void**)&script_change_type);
     ok(hres == S_OK, "Could not get IVariantChangeType iface: %08lx\n", hres);
 
     SET_EXPECT(OnEnterScript); /* checked in callback */
     SET_EXPECT(testArgConv);
-    parse_script(parser,
+    SET_EXPECT(testGetCallerJS);
+    parse_script(active_script_parser,
                  L"var obj = {"
                  L"    toString: function() { return 'strval'; },"
                  L"    valueOf: function()  { return 10; }"
                  L"};"
-                 L"testArgConv(obj);");
+                 L"testArgConv(obj);"
+                 L"function testGetCallerFunc() { testGetCaller(); };"
+                 L"testGetCallerJS(42);");
+    CHECK_CALLED(testGetCallerJS);
     CHECK_CALLED(testArgConv);
     CHECK_CALLED(OnLeaveScript); /* set in callback */
 
@@ -565,7 +725,47 @@ static void run_scripts(void)
     IDispatch_Release(stored_obj);
     IVariantChangeType_Release(script_change_type);
 
-    IActiveScriptParse_Release(parser);
+    hres = IActiveScriptParse_QueryInterface(active_script_parser, &IID_IActiveScript, (void**)&active_script);
+    ok(hres == S_OK, "Could not get IActiveScript: %08lx\n", hres);
+    hres = IActiveScript_GetScriptDispatch(active_script, NULL, &disp);
+    ok(hres == S_OK, "GetScriptDispatch failed: %08lx\n", hres);
+    IActiveScript_Release(active_script);
+    hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
+    ok(hres == S_OK, "Could not get IDispatchEx: %08lx\n", hres);
+    IDispatch_Release(disp);
+    bstr = SysAllocString(L"testGetCallerFunc");
+    hres = IDispatchEx_GetDispID(dispex, bstr, 0, &dispid);
+    ok(hres == S_OK, "GetDispID failed: %08lx\n", hres);
+    SysFreeString(bstr);
+
+    hres = IDispatchEx_InvokeEx(dispex, dispid, 0, DISPATCH_PROPERTYGET, &dp, &var, NULL, NULL);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    ok(V_VT(&var) == VT_DISPATCH, "V_VT(testGetCallerFunc) = %d\n", V_VT(&var));
+    ok(V_DISPATCH(&var) != NULL, "V_DISPATCH(testGetCallerFunc) = NULL\n");
+    IDispatchEx_Release(dispex);
+    hres = IDispatch_QueryInterface(V_DISPATCH(&var), &IID_IDispatchEx, (void**)&dispex);
+    ok(hres == S_OK, "Could not get IDispatchEx: %08lx\n", hres);
+    IDispatch_Release(V_DISPATCH(&var));
+
+    SET_EXPECT(OnEnterScript);
+    SET_EXPECT(OnLeaveScript);
+    SET_EXPECT(testGetCaller);
+    hres = IDispatchEx_InvokeEx(dispex, DISPID_VALUE, 0, DISPATCH_METHOD, &dp, NULL, NULL, NULL);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    CHECK_CALLED(testGetCaller);
+    CHECK_CALLED(OnLeaveScript);
+    test_get_caller_sp = &sp_caller_obj;
+    SET_EXPECT(OnEnterScript);
+    SET_EXPECT(OnLeaveScript);
+    SET_EXPECT(testGetCaller);
+    hres = IDispatchEx_InvokeEx(dispex, DISPID_VALUE, 0, DISPATCH_METHOD, &dp, NULL, NULL, test_get_caller_sp);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    CHECK_CALLED(testGetCaller);
+    CHECK_CALLED(OnLeaveScript);
+    IDispatchEx_Release(dispex);
+
+    IActiveScriptParse_Release(active_script_parser);
+    active_script_parser = NULL;
 }
 
 static BOOL check_jscript(void)
diff --git a/dlls/jscript/tests/run.c b/dlls/jscript/tests/run.c
index 21f09474fee..c5d9c47e63c 100644
--- a/dlls/jscript/tests/run.c
+++ b/dlls/jscript/tests/run.c
@@ -114,6 +114,9 @@ DEFINE_EXPECT(testobj_newenum);
 DEFINE_EXPECT(testobj_getidfail_d);
 DEFINE_EXPECT(testobj_tolocalestr_d);
 DEFINE_EXPECT(testobj_tolocalestr_i);
+DEFINE_EXPECT(test_caller_get);
+DEFINE_EXPECT(test_caller_null);
+DEFINE_EXPECT(test_caller_obj);
 DEFINE_EXPECT(testdestrobj);
 DEFINE_EXPECT(enumvariant_next_0);
 DEFINE_EXPECT(enumvariant_next_1);
@@ -333,6 +336,44 @@ static IEnumVARIANTVtbl testEnumVARIANTVtbl = {
 
 static IEnumVARIANT testEnumVARIANT = { &testEnumVARIANTVtbl };
 
+static HRESULT WINAPI sp_QueryInterface(IServiceProvider *iface, REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IServiceProvider, riid)) {
+        *ppv = iface;
+        return S_OK;
+    }
+
+    ok(0, "unexpected call %s\n", wine_dbgstr_guid(riid));
+    *ppv = NULL;
+    return E_NOTIMPL;
+}
+
+static ULONG WINAPI sp_AddRef(IServiceProvider *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI sp_Release(IServiceProvider *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI sp_QueryService(IServiceProvider *iface, REFGUID guidService, REFIID riid, void **ppv)
+{
+    ok(0, "unexpected call %s\n", wine_dbgstr_guid(guidService));
+    *ppv = NULL;
+    return E_NOTIMPL;
+}
+
+static const IServiceProviderVtbl sp_vtbl = {
+    sp_QueryInterface,
+    sp_AddRef,
+    sp_Release,
+    sp_QueryService
+};
+
+static IServiceProvider sp_obj = { &sp_vtbl };
+
 static HRESULT WINAPI DispatchEx_QueryInterface(IDispatchEx *iface, REFIID riid, void **ppv)
 {
     *ppv = NULL;
@@ -629,6 +670,61 @@ static IDispatchExVtbl testObjVtbl = {
 
 static IDispatchEx testObj = { &testObjVtbl };
 
+static HRESULT WINAPI testcallerobj_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
+        VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
+{
+    ok(id == DISPID_VALUE, "id = %ld\n", id);
+    ok(pdp != NULL, "pdp == NULL\n");
+    ok(pvarRes != NULL, "pvarRes == NULL\n");
+    ok(V_VT(pvarRes) == VT_EMPTY, "V_VT(pvarRes) = %d\n", V_VT(pvarRes));
+    if(wFlags == DISPATCH_PROPERTYGET) {
+        CHECK_EXPECT(test_caller_get);
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pdp->cNamedArgs, "cNamedArgs = %d\n", pdp->cNamedArgs);
+        ok(pei != NULL, "pei == NULL\n");
+        ok(pspCaller != NULL, "pspCaller == NULL\n");
+        ok(pspCaller != &sp_obj, "pspCaller == sp_obj\n");
+        V_VT(pvarRes) = VT_DISPATCH;
+        V_DISPATCH(pvarRes) = (IDispatch*)iface;
+    }else if(pspCaller) {
+        CHECK_EXPECT(test_caller_obj);
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %04x\n", wFlags);
+        ok(pdp->rgdispidNamedArgs != NULL, "rgdispidNamedArgs == NULL\n");
+        ok(pdp->cNamedArgs == 1, "cNamedArgs = %d\n", pdp->cNamedArgs);
+        ok(pspCaller == &sp_obj, "pspCaller != sp_obj\n");
+        V_VT(pvarRes) = VT_I4;
+        V_I4(pvarRes) = 137;
+    }else {
+        CHECK_EXPECT(test_caller_null);
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %04x\n", wFlags);
+        ok(pdp->rgdispidNamedArgs != NULL, "rgdispidNamedArgs == NULL\n");
+        ok(pdp->cNamedArgs == 1, "cNamedArgs = %d\n", pdp->cNamedArgs);
+        V_VT(pvarRes) = VT_I4;
+        V_I4(pvarRes) = 42;
+    }
+    return S_OK;
+}
+
+static IDispatchExVtbl testcallerobj_vtbl = {
+    DispatchEx_QueryInterface,
+    DispatchEx_AddRef,
+    DispatchEx_Release,
+    DispatchEx_GetTypeInfoCount,
+    DispatchEx_GetTypeInfo,
+    DispatchEx_GetIDsOfNames,
+    DispatchEx_Invoke,
+    DispatchEx_GetDispID,
+    testcallerobj_InvokeEx,
+    DispatchEx_DeleteMemberByName,
+    DispatchEx_DeleteMemberByDispID,
+    DispatchEx_GetMemberProperties,
+    DispatchEx_GetMemberName,
+    DispatchEx_GetNextDispID,
+    DispatchEx_GetNameSpaceParent
+};
+
+static IDispatchEx testcallerobj = { &testcallerobj_vtbl };
+
 static LONG test_destr_ref;
 
 static ULONG WINAPI testDestrObj_AddRef(IDispatchEx *iface)
@@ -3214,6 +3310,7 @@ static void test_script_exprs(void)
 
 static void test_invokeex(void)
 {
+    static DISPID propput_dispid = DISPID_PROPERTYPUT;
     DISPPARAMS dp = {NULL}, dp_max = {NULL};
     DISPID func_id, max_id, prop_id;
     IActiveScript *script;
@@ -3442,6 +3539,52 @@ static void test_invokeex(void)
 
     IDispatchEx_Release(dispex);
     IActiveScript_Release(script);
+
+    /* test InvokeEx with host prop and custom caller */
+    hres = parse_script_expr(L"var o = {}; o", &v, &script);
+    ok(hres == S_OK, "parse_script_expr failed: %08lx\n", hres);
+    ok(V_VT(&v) == VT_DISPATCH, "V_VT(v) = %d\n", V_VT(&v));
+
+    hres = IDispatch_QueryInterface(V_DISPATCH(&v), &IID_IDispatchEx, (void**)&dispex);
+    ok(hres == S_OK, "Could not get IDispatchEx iface: %08lx\n", hres);
+    VariantClear(&v);
+
+    str = SysAllocString(L"caller");
+    hres = IDispatchEx_GetDispID(dispex, str, fdexNameEnsure, &func_id);
+    SysFreeString(str);
+    ok(hres == S_OK, "GetDispID failed: %08lx\n", hres);
+
+    SET_EXPECT(test_caller_get);
+    dp.cArgs = dp.cNamedArgs = 1;
+    dp.rgvarg = &arg;
+    dp.rgdispidNamedArgs = &propput_dispid;
+    V_VT(&arg) = VT_DISPATCH;
+    V_DISPATCH(&arg) = (IDispatch*)&testcallerobj;
+    hres = IDispatchEx_InvokeEx(dispex, func_id, 0, DISPATCH_PROPERTYPUT, &dp, NULL, NULL, NULL);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    todo_wine
+    CHECK_CALLED(test_caller_get);
+
+    SET_EXPECT(test_caller_null);
+    dp.cArgs = dp.cNamedArgs = 0;
+    dp.rgvarg = NULL;
+    dp.rgdispidNamedArgs = NULL;
+    hres = IDispatchEx_InvokeEx(dispex, func_id, 0, DISPATCH_METHOD, &dp, &v, NULL, NULL);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    ok(V_VT(&v) == VT_I4, "V_VT(v) = %d\n", V_VT(&v));
+    ok(V_I4(&v) == 42, "V_I4(v) = %s\n", wine_dbgstr_variant(&v));
+    CHECK_CALLED(test_caller_null);
+    V_VT(&v) = VT_EMPTY;
+
+    SET_EXPECT(test_caller_obj);
+    hres = IDispatchEx_InvokeEx(dispex, func_id, 0, DISPATCH_METHOD, &dp, &v, NULL, &sp_obj);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    ok(V_VT(&v) == VT_I4, "V_VT(v) = %d\n", V_VT(&v));
+    ok(V_I4(&v) == 137, "V_I4(v) = %s\n", wine_dbgstr_variant(&v));
+    CHECK_CALLED(test_caller_obj);
+
+    IDispatchEx_Release(dispex);
+    IActiveScript_Release(script);
 }
 
 static void test_destructors(void)
diff --git a/dlls/jsproxy/tests/jsproxy.c b/dlls/jsproxy/tests/jsproxy.c
index 59b3c5dfb9e..505d1a9398a 100644
--- a/dlls/jsproxy/tests/jsproxy.c
+++ b/dlls/jsproxy/tests/jsproxy.c
@@ -49,6 +49,11 @@ static void test_InternetInitializeAutoProxyDll(void)
     ret = pInternetInitializeAutoProxyDll( 0, NULL, NULL, NULL, &buf );
     err = GetLastError();
     ok( !ret, "unexpected success\n" );
+    if (!ret && err == 0xdeadbeef)
+    {
+        win_skip("InternetInitializeAutoProxyDll() is not supported on Windows 11\n");
+        return;
+    }
     ok( err == ERROR_INVALID_PARAMETER, "got %lu\n", err );
 
     buf.dwScriptBufferSize = strlen(script) + 1;
@@ -58,6 +63,7 @@ static void test_InternetInitializeAutoProxyDll(void)
     ret = pInternetGetProxyInfo( url, strlen(url), host, strlen(host), &proxy, &len );
     ok( ret, "got %lu\n", GetLastError() );
     ok( !strcmp( proxy, "DIRECT" ), "got \"%s\"\n", proxy );
+    ok( len == strlen(proxy) + 1, "got len=%ld for \"%s\"\n", len, proxy );
     GlobalFree( proxy );
 
     buf.dwScriptBufferSize = strlen(script2) + 1;
@@ -68,6 +74,7 @@ static void test_InternetInitializeAutoProxyDll(void)
     ret = pInternetGetProxyInfo( url, strlen(url), host, strlen(host), &proxy, &len );
     ok( ret, "got %lu\n", GetLastError() );
     ok( !strcmp( proxy, "PROXY 10.0.0.1:8080" ), "got \"%s\"\n", proxy );
+    ok( len == strlen(proxy) + 1, "got len=%ld for \"%s\"\n", len, proxy );
     GlobalFree( proxy );
 
     buf.dwScriptBufferSize = strlen(script2) + 2;
@@ -77,6 +84,7 @@ static void test_InternetInitializeAutoProxyDll(void)
     ret = pInternetGetProxyInfo( url, strlen(url), host, strlen(host), &proxy, &len );
     ok( ret, "got %lu\n", GetLastError() );
     ok( !strcmp( proxy, "PROXY 10.0.0.1:8080" ), "got \"%s\"\n", proxy );
+    ok( len == strlen(proxy) + 1, "got len=%ld for \"%s\"\n", len, proxy );
     GlobalFree( proxy );
 
     buf.lpszScriptBuffer = script3;
@@ -105,6 +113,11 @@ static void test_InternetGetProxyInfo(void)
     SetLastError( 0xdeadbeef );
     ret = pInternetGetProxyInfo( url, strlen(url), host, strlen(host), &proxy, &len );
     err = GetLastError();
+    if (!ret && err == 0xdeadbeef)
+    {
+        win_skip("InternetGetProxyInfo() is not supported on Windows 11\n");
+        return;
+    }
     ok( !ret, "unexpected success\n" );
     ok( err == ERROR_CAN_NOT_COMPLETE, "got %lu\n", err );
 
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index 2dd3eac3c26..028cf96d8cc 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -143,9 +143,9 @@ BOOL WINAPI CopyFileExA(LPCSTR sourceFilename, LPCSTR destFilename,
  */
 BOOL WINAPI MoveFileTransactedA(const char *source, const char *dest, LPPROGRESS_ROUTINE progress, void *data, DWORD flags, HANDLE handle)
 {
-    FIXME("(%s, %s, %p, %p, %ld, %p)\n", debugstr_a(source), debugstr_a(dest), progress, data, flags, handle);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    FIXME("(%s, %s, %p, %p, %ld, %p) semi-stub\n", debugstr_a(source), debugstr_a(dest), progress, data, flags, handle);
+
+    return MoveFileWithProgressA(source, dest, progress, data, flags);
 }
 
 /**************************************************************************
@@ -153,9 +153,9 @@ BOOL WINAPI MoveFileTransactedA(const char *source, const char *dest, LPPROGRESS
  */
 BOOL WINAPI MoveFileTransactedW(const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUTINE progress, void *data, DWORD flags, HANDLE handle)
 {
-    FIXME("(%s, %s, %p, %p, %ld, %p)\n", debugstr_w(source), debugstr_w(dest), progress, data, flags, handle);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    FIXME("(%s, %s, %p, %p, %ld, %p) semi-stub\n", debugstr_w(source), debugstr_w(dest), progress, data, flags, handle);
+
+    return MoveFileWithProgressW(source, dest, progress, data, flags);
 }
 
 /**************************************************************************
diff --git a/dlls/kernel32/tests/debugger.c b/dlls/kernel32/tests/debugger.c
index a3f09abaa70..2491b1093f1 100644
--- a/dlls/kernel32/tests/debugger.c
+++ b/dlls/kernel32/tests/debugger.c
@@ -134,7 +134,7 @@ static void save_blackbox(const char* logfile, void* blackbox, int size, const c
     DWORD written;
     BOOL ret;
 
-    hFile = CreateFileA(logfile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, 0);
+    hFile = CreateFileA(logfile, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, 0);
     ok(hFile != INVALID_HANDLE_VALUE, "Couldn't create %s: %lu\n", logfile, GetLastError());
     if (hFile == INVALID_HANDLE_VALUE)
         return;
@@ -156,7 +156,7 @@ static int _load_blackbox(unsigned int line, const char* logfile, void* blackbox
     BOOL ret;
     char buf[4096];
 
-    hFile = CreateFileA(logfile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
+    hFile = CreateFileA(logfile, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
     if (hFile == INVALID_HANDLE_VALUE)
     {
         ok_(__FILE__, line)(0, "unable to open '%s': %#lx\n", logfile, GetLastError());
@@ -391,12 +391,25 @@ static void next_event_(unsigned line, struct debugger_context *ctx, unsigned ti
     ctx->current_thread = get_debuggee_thread(ctx, ctx->ev.dwThreadId);
 }
 
+static DWORD event_mask(DWORD ev)
+{
+    return (ev >= 1 && ev <= 7) ? (1LU << ev) : 0;
+}
+
+#define next_event_filter(a, b,c) next_event_filter_(__LINE__, (a), (b), (c))
+static void next_event_filter_(unsigned line, struct debugger_context *ctx, DWORD timeout, DWORD mask)
+{
+    do
+    {
+        next_event_(line, ctx, timeout);
+    } while (event_mask(ctx->ev.dwDebugEventCode) & mask);
+}
+
 #define wait_for_breakpoint(a) wait_for_breakpoint_(__LINE__,a)
 static void wait_for_breakpoint_(unsigned line, struct debugger_context *ctx)
 {
-    do next_event_(line, ctx, WAIT_EVENT_TIMEOUT);
-    while (ctx->ev.dwDebugEventCode == LOAD_DLL_DEBUG_EVENT || ctx->ev.dwDebugEventCode == UNLOAD_DLL_DEBUG_EVENT
-           || ctx->ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT);
+    next_event_filter_(line, ctx, WAIT_EVENT_TIMEOUT,
+                       event_mask(LOAD_DLL_DEBUG_EVENT) | event_mask(UNLOAD_DLL_DEBUG_EVENT) | event_mask(CREATE_THREAD_DEBUG_EVENT));
 
     ok_(__FILE__,line)(ctx->ev.dwDebugEventCode == EXCEPTION_DEBUG_EVENT, "dwDebugEventCode = %ld\n", ctx->ev.dwDebugEventCode);
     ok_(__FILE__,line)(ctx->ev.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT, "ExceptionCode = %lx\n",
@@ -439,15 +452,20 @@ static void process_attach_events(struct debugger_context *ctx, BOOL pass_except
     /* Win11 doesn't generate it at this point (Win <= 10 do) */
     if (ctx->ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT)
     {
-        DWORD last_thread;
+        DWORD last_threads[5];
+        unsigned thd_idx = 0, i;
 
         /* sometimes (at least Win10) several thread creations are reported here */
         do
         {
-            last_thread = ctx->ev.dwThreadId;
+            if (thd_idx < ARRAY_SIZE(last_threads))
+                last_threads[thd_idx++] = ctx->ev.dwThreadId;
             next_event(ctx, WAIT_EVENT_TIMEOUT);
         } while (ctx->ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT);
-        ok(ctx->ev.dwThreadId == last_thread, "unexpected thread\n");
+        ok(thd_idx <= ARRAY_SIZE(last_threads), "too many threads created\n");
+        for (i = 0; i < thd_idx; i++)
+            if (last_threads[i] == ctx->ev.dwThreadId) break;
+        ok(i < thd_idx, "unexpected thread\n");
 
         ok(ctx->ev.dwDebugEventCode == EXCEPTION_DEBUG_EVENT, "dwDebugEventCode = %ld\n", ctx->ev.dwDebugEventCode);
         ok(ctx->ev.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT, "ExceptionCode = %lx\n",
@@ -983,6 +1001,17 @@ static void test_debug_loop(int argc, char **argv)
         win_skip("CheckRemoteDebuggerPresent not available, skipping test.\n");
         return;
     }
+    if (sizeof(void *) > sizeof(int))
+    {
+        WCHAR buffer[MAX_PATH];
+        GetSystemWow64DirectoryW( buffer, MAX_PATH );
+        wcscat( buffer, L"\\oleacc.dll" );
+        if (GetFileAttributesW( buffer ) == INVALID_FILE_ATTRIBUTES)
+        {
+            skip("Skipping test on 64bit only configuration\n");
+            return;
+        }
+    }
 
     pid = GetCurrentProcessId();
     ret = DebugActiveProcess(pid);
@@ -1290,11 +1319,10 @@ static void expect_exception_(unsigned line, struct debugger_context *ctx, DWORD
                        ctx->ev.u.Exception.ExceptionRecord.ExceptionCode, exception_code);
 }
 
-#define expect_breakpoint_exception(a,b) expect_breakpoint_exception_(__LINE__,a,b)
-static void expect_breakpoint_exception_(unsigned line, struct debugger_context *ctx, const void *expect_addr)
+#define check_breakpoint_exception(a,b) expect_breakpoint_exception_(__LINE__,a,b)
+static void check_breakpoint_exception_(unsigned line, struct debugger_context *ctx, const void *expect_addr)
 {
     struct debuggee_thread *thread;
-    expect_exception_(line, ctx, EXCEPTION_BREAKPOINT);
     if (!expect_addr) return;
     ok_(__FILE__,line)(ctx->ev.u.Exception.ExceptionRecord.ExceptionAddress == expect_addr,
                        "ExceptionAddress = %p expected %p\n", ctx->ev.u.Exception.ExceptionRecord.ExceptionAddress, expect_addr);
@@ -1304,6 +1332,13 @@ static void expect_breakpoint_exception_(unsigned line, struct debugger_context
                        get_ip(&thread->ctx), expect_addr);
 }
 
+#define expect_breakpoint_exception(a,b) expect_breakpoint_exception_(__LINE__,a,b)
+static void expect_breakpoint_exception_(unsigned line, struct debugger_context *ctx, const void *expect_addr)
+{
+    expect_exception_(line, ctx, EXCEPTION_BREAKPOINT);
+    check_breakpoint_exception_(line, ctx, expect_addr);
+}
+
 #define single_step(a,b,c) single_step_(__LINE__,a,b,c)
 static void single_step_(unsigned line, struct debugger_context *ctx, struct debuggee_thread *thread, void *expect_addr)
 {
@@ -1586,15 +1621,31 @@ static void test_debugger(const char *argv0)
         ok(pNtResumeProcess != NULL, "pNtResumeProcess not found\n");
         if (pNtSuspendProcess && pNtResumeProcess)
         {
+            DWORD action = DBG_REPLY_LATER;
             status = pNtSuspendProcess(pi.hProcess);
             ok(!status, "NtSuspendProcess failed, last error:%lu\n", GetLastError());
-            ret = ContinueDebugEvent(ctx.ev.dwProcessId, ctx.ev.dwThreadId, DBG_REPLY_LATER);
-            ok(ret, "ContinueDebugEvent failed, last error:%lu\n", GetLastError());
-            ok(!WaitForDebugEvent(&ctx.ev, POLL_EVENT_TIMEOUT), "WaitForDebugEvent succeeded.\n");
+            do
+            {
+                ret = ContinueDebugEvent(ctx.ev.dwProcessId, ctx.ev.dwThreadId, action);
+                ok(ret, "ContinueDebugEvent failed, last error:%lu\n", GetLastError());
+                ret = WaitForDebugEvent(&ctx.ev, POLL_EVENT_TIMEOUT);
+                ok(!ret || ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT, "WaitForDebugEvent succeeded.\n");
+                if (ret) add_thread(&ctx, ctx.ev.dwThreadId);
+                action = DBG_CONTINUE;
+            } while (ret);
 
             status = NtResumeThread(thread_b, NULL);
             ok(!status, "NtResumeThread failed, last error:%lu\n", GetLastError());
-            ok(!WaitForDebugEvent(&ctx.ev, POLL_EVENT_TIMEOUT), "WaitForDebugEvent succeeded.\n");
+            while (WaitForDebugEvent(&ctx.ev, POLL_EVENT_TIMEOUT))
+            {
+                ok(ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT, "Unexpected debug event %lx\n", ctx.ev.dwDebugEventCode);
+                if (ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT)
+                {
+                    add_thread(&ctx, ctx.ev.dwThreadId);
+                    ret = ContinueDebugEvent(ctx.ev.dwProcessId, ctx.ev.dwThreadId, DBG_CONTINUE);
+                    ok(ret, "ContinueDebugEvent failed, last error:%lu\n", GetLastError());
+                }
+            }
 
             status = pNtResumeProcess(pi.hProcess);
             ok(!status, "pNtResumeProcess failed, last error:%lu\n", GetLastError());
@@ -1710,6 +1761,8 @@ static void test_debugger(const char *argv0)
 
     if (sizeof(loop_code) > 1)
     {
+        unsigned event_order = 0;
+
         memset(buf, OP_BP, sizeof(buf));
         memcpy(proc_code, &loop_code, sizeof(loop_code));
         ret = WriteProcessMemory(pi.hProcess, mem, buf, sizeof(buf), NULL);
@@ -1720,11 +1773,16 @@ static void test_debugger(const char *argv0)
         worker_cnt = 20;
         for (i = 0; i < worker_cnt; i++)
         {
-            thread = CreateRemoteThread(pi.hProcess, NULL, 0, (void*)thread_proc, NULL, 0, NULL);
+            DWORD tid;
+            thread = CreateRemoteThread(pi.hProcess, NULL, 0, (void*)thread_proc, NULL, 0, &tid);
             ok(thread != NULL, "CreateRemoteThread failed: %lu\n", GetLastError());
 
-            next_event(&ctx, WAIT_EVENT_TIMEOUT);
-            ok(ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT, "dwDebugEventCode = %ld\n", ctx.ev.dwDebugEventCode);
+            do
+            {
+                next_event(&ctx, WAIT_EVENT_TIMEOUT);
+                ok(ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT, "dwDebugEventCode = %ld\n", ctx.ev.dwDebugEventCode);
+            } while (ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT && ctx.ev.dwThreadId != tid);
+            ok(ctx.ev.u.CreateThread.lpStartAddress == (void*)thread_proc, "Unexpected thread's start address\n");
 
             ret = CloseHandle(thread);
             ok(ret, "CloseHandle failed, last error %ld.\n", GetLastError());
@@ -1734,13 +1792,19 @@ static void test_debugger(const char *argv0)
         ret = WriteProcessMemory(pi.hProcess, thread_proc + 1, &byte, 1, NULL);
         ok(ret, "WriteProcessMemory failed: %lu\n", GetLastError());
 
-        expect_breakpoint_exception(&ctx, thread_proc + 1);
+        wait_for_breakpoint(&ctx);
+        check_breakpoint_exception(&ctx, thread_proc + 1);
         exception_cnt = 1;
 
         byte = 0xc3; /* ret */
         ret = WriteProcessMemory(pi.hProcess, thread_proc + 1, &byte, 1, NULL);
         ok(ret, "WriteProcessMemory failed: %lu\n", GetLastError());
 
+        /* One would expect that we get all exception debug events (for the worker threads
+         * that hit the BP instruction), then the exit thread events for all created threads.
+         * It happens that on Windows, the exception & exit thread events can be intertwined.
+         * So detect this situation.
+         */
         for (;;)
         {
             DEBUG_EVENT ev;
@@ -1753,26 +1817,31 @@ static void test_debugger(const char *argv0)
             ret = WaitForDebugEvent(&ev, 10);
             ok(GetLastError() == ERROR_SEM_TIMEOUT, "WaitForDebugEvent returned %x(%lu)\n", ret, GetLastError());
 
-            next_event(&ctx, POLL_EVENT_TIMEOUT);
-            if (ctx.ev.dwDebugEventCode != EXCEPTION_DEBUG_EVENT) break;
+            for (;;)
+            {
+                next_event_filter(&ctx, POLL_EVENT_TIMEOUT, event_mask(CREATE_THREAD_DEBUG_EVENT));
+                if (ctx.ev.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) break;
+                if (ctx.ev.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
+                {
+                    if (event_order == 0) event_order = 1; /* first exit thread event */
+                    if (!--worker_cnt) break;
+                }
+            }
+            if (!worker_cnt) break;
+
+            ok(ctx.ev.dwDebugEventCode == EXCEPTION_DEBUG_EVENT, "dwDebugEventCode = %ld\n", ctx.ev.dwDebugEventCode);
             trace("exception at %p in thread %04lx\n", ctx.ev.u.Exception.ExceptionRecord.ExceptionAddress, ctx.ev.dwThreadId);
             ok(ctx.ev.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT, "ExceptionCode = %lx\n",
                ctx.ev.u.Exception.ExceptionRecord.ExceptionCode);
             ok(ctx.ev.u.Exception.ExceptionRecord.ExceptionAddress == thread_proc + 1,
                "ExceptionAddress = %p\n", ctx.ev.u.Exception.ExceptionRecord.ExceptionAddress);
             exception_cnt++;
+            if (event_order == 1) event_order = 2; /* exception debug event after exit thread event */
         }
 
         trace("received %u exceptions\n", exception_cnt);
-
-        for (;;)
-        {
-            ok(ctx.ev.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT
-               || broken(ctx.ev.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT), /* sometimes happens on vista */
-               "dwDebugEventCode = %ld\n", ctx.ev.dwDebugEventCode);
-            if (ctx.ev.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT && !--worker_cnt) break;
-            next_event(&ctx, WAIT_EVENT_TIMEOUT);
-        }
+        ok(!worker_cnt, "Missing %u exit thread events\n", worker_cnt);
+        ok(event_order == 1 || broken(event_order == 2), "Intertwined exit thread & exception debug events\n");
     }
 
     if (OP_BP)
@@ -1846,7 +1915,7 @@ static void test_debugger(const char *argv0)
         SetEvent(event);
         ResumeThread(ctx.main_thread->handle);
 
-        next_event(&ctx, 2000);
+        next_event_filter(&ctx, 2000, event_mask(CREATE_THREAD_DEBUG_EVENT));
         ok(ctx.ev.dwDebugEventCode == EXCEPTION_DEBUG_EVENT, "dwDebugEventCode = %ld\n", ctx.ev.dwDebugEventCode);
         ok(ctx.ev.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT, "ExceptionCode = %lx\n",
            ctx.ev.u.Exception.ExceptionRecord.ExceptionCode);
@@ -2029,6 +2098,7 @@ static void test_kill_on_exit(const char *argv0)
     HANDLE event, debug, thread;
     DWORD exit_code, tid;
     ULONG val;
+    BOOL ret;
 
     event = CreateEventW(&sa, FALSE, FALSE, NULL);
     ok(event != NULL, "CreateEvent failed: %lu\n", GetLastError());
@@ -2100,29 +2170,46 @@ static void test_kill_on_exit(const char *argv0)
     CloseHandle( pi.hThread );
     CloseHandle( thread );
 
-    /* but not on forced exit */
+    /* checking on forced exit */
     status = pNtCreateDebugObject( &debug, DEBUG_ALL_ACCESS, &attr, DEBUG_KILL_ON_CLOSE );
     ok( !status, "NtCreateDebugObject failed %lx\n", status );
     thread = CreateThread(NULL, 0, debug_and_wait, &debug, 0, &tid);
     Sleep( 100 );
     ok( debug != 0, "no debug port\n" );
-    val = 1;
+    val = DEBUG_KILL_ON_CLOSE;
     status = pNtSetInformationDebugObject( debug, DebugObjectKillProcessOnExitInformation,
                                            &val, sizeof(val), NULL );
     ok( status == STATUS_SUCCESS, "NtSetInformationDebugObject failed %lx\n", status );
     TerminateThread( thread, 0 );
-    status = pNtSetInformationDebugObject( debug, DebugObjectKillProcessOnExitInformation,
-                                           &val, sizeof(val), NULL );
-    ok( status == STATUS_SUCCESS, "NtSetInformationDebugObject failed %lx\n", status );
-    WaitForSingleObject( pi.hProcess, 300 );
-    GetExitCodeProcess( pi.hProcess, &exit_code );
-    todo_wine
-    ok( exit_code == STATUS_DEBUGGER_INACTIVE || broken(exit_code == STILL_ACTIVE), /* wow64 */
-        "exit code = %08lx\n", exit_code);
+
+    status = WaitForSingleObject( pi.hProcess, 1500 );
+    if (status != WAIT_OBJECT_0)
+    {
+        todo_wine /* Wine doesn't handle debug port of TerminateThread */
+        ok(broken(sizeof(void*) == sizeof(int)), /* happens consistently on 32bit on Win7, 10 & 11 */
+           "Terminating thread should terminate debuggee\n");
+
+        ret = TerminateProcess( pi.hProcess, 0 );
+        ok(ret, "TerminateProcess failed: %lu\n", GetLastError());
+        CloseHandle( debug );
+    }
+    else
+    {
+        ok(status == WAIT_OBJECT_0, "debuggee didn't terminate %lx\n", status);
+        ret = GetExitCodeProcess( pi.hProcess, &exit_code );
+        ok(ret, "No exit code: %lu\n", GetLastError());
+        todo_wine
+        ok( exit_code == STATUS_DEBUGGER_INACTIVE || broken(exit_code == STILL_ACTIVE), /* wow64 */
+            "exit code = %08lx\n", exit_code);
+        status = pNtSetInformationDebugObject( debug, DebugObjectKillProcessOnExitInformation,
+                                               &val, sizeof(val), NULL );
+        todo_wine
+        ok( status == STATUS_INVALID_HANDLE, "NtSetInformationDebugObject failed %lx\n", status );
+    }
+
     CloseHandle( pi.hProcess );
     CloseHandle( pi.hThread );
     CloseHandle( thread );
-    CloseHandle( debug );
 
     debug = 0;
     thread = CreateThread(NULL, 0, create_debug_port, &debug, 0, &tid);
@@ -2133,10 +2220,13 @@ static void test_kill_on_exit(const char *argv0)
                                            &val, sizeof(val), NULL );
     ok( status == STATUS_SUCCESS, "NtSetInformationDebugObject failed %lx\n", status );
     TerminateThread( thread, 0 );
+    Sleep( 200 );
     status = pNtSetInformationDebugObject( debug, DebugObjectKillProcessOnExitInformation,
                                            &val, sizeof(val), NULL );
-    ok( status == STATUS_SUCCESS, "NtSetInformationDebugObject failed %lx\n", status );
-    CloseHandle( debug );
+    todo_wine
+    ok( status == STATUS_INVALID_HANDLE  || broken( status == STATUS_SUCCESS ),
+        "NtSetInformationDebugObject failed %lx\n", status );
+    if (status != STATUS_INVALID_HANDLE) CloseHandle( debug );
     CloseHandle( thread );
 
     CloseHandle( event );
diff --git a/dlls/kernel32/tests/file.c b/dlls/kernel32/tests/file.c
index b29e2c3dc4e..73ae75d52af 100644
--- a/dlls/kernel32/tests/file.c
+++ b/dlls/kernel32/tests/file.c
@@ -3142,7 +3142,9 @@ static void test_MapFile(void)
 static void test_GetFileType(void)
 {
     DWORD type, type2;
-    HANDLE h = CreateFileA( filename, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0 );
+    HANDLE h, h2;
+    BOOL ret;
+    h = CreateFileA( filename, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0 );
     ok( h != INVALID_HANDLE_VALUE, "open %s failed\n", filename );
     type = GetFileType(h);
     ok( type == FILE_TYPE_DISK, "expected type disk got %ld\n", type );
@@ -3158,6 +3160,73 @@ static void test_GetFileType(void)
     type = GetFileType( (HANDLE)STD_OUTPUT_HANDLE );
     type2 = GetFileType( h );
     ok(type == type2, "expected type %ld for STD_OUTPUT_HANDLE got %ld\n", type2, type);
+
+    ret = CreatePipe( &h, &h2, NULL, 0 );
+    ok( ret, "CreatePipe failed\n" );
+    type = GetFileType( h );
+    ok( type == FILE_TYPE_PIPE, "expected type pipe got %ld\n", type );
+    type = GetFileType( h2 );
+    ok( type == FILE_TYPE_PIPE, "expected type pipe got %ld\n", type );
+    CloseHandle( h2 );
+    CloseHandle( h );
+
+    h = CreateNamedPipeW( L"\\\\.\\pipe\\wine_test", PIPE_ACCESS_DUPLEX, 0, 2, 32, 32, 0, NULL );
+    ok( h != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n" );
+    type = GetFileType( h );
+    ok( type == FILE_TYPE_PIPE, "expected type pipe got %ld\n", type );
+    CloseHandle( h );
+
+    h = CreateFileA( filename, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0 );
+    ok( h != INVALID_HANDLE_VALUE, "open %s failed\n", filename );
+    h2 = CreateFileMappingW( h, NULL, PAGE_READWRITE, 0, 0x1000, NULL );
+    ok( h2 != NULL, "CreateFileMapping failed\n" );
+    SetLastError( 12345678 );
+    type = GetFileType( h2 );
+    todo_wine
+    ok( type == FILE_TYPE_UNKNOWN, "expected type unknown got %ld\n", type );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE got %lx\n", GetLastError() );
+    CloseHandle( h2 );
+    CloseHandle( h );
+    DeleteFileA( filename );
+
+    h = CreateFileMappingW( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 0x1000, NULL );
+    ok( h != NULL, "CreateFileMapping failed\n" );
+    SetLastError( 12345678 );
+    type = GetFileType( h );
+    todo_wine
+    ok( type == FILE_TYPE_UNKNOWN, "expected type unknown got %ld\n", type );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE got %lx\n", GetLastError() );
+    CloseHandle( h );
+
+    h = CreateMailslotW( L"\\\\.\\mailslot\\wine_test", 0, 0, NULL );
+    ok( h != INVALID_HANDLE_VALUE, "CreateMailslot failed\n" );
+    SetLastError( 12345678 );
+    type = GetFileType( h );
+    todo_wine
+    ok( type == FILE_TYPE_UNKNOWN, "expected type unknown got %ld\n", type );
+    todo_wine
+    ok( GetLastError() == NO_ERROR, "expected ERROR_NO_ERROR got %lx\n", GetLastError() );
+    CloseHandle( h );
+
+    SetLastError( 12345678 );
+    type = GetFileType( GetCurrentProcess() );
+    ok( type == FILE_TYPE_UNKNOWN, "expected type unknown got %ld\n", type );
+    ok( GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE got %lx\n", GetLastError() );
+
+    SetLastError( 12345678 );
+    type = GetFileType( GetCurrentThread() );
+    ok( type == FILE_TYPE_UNKNOWN, "expected type unknown got %ld\n", type );
+    ok( GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE got %lx\n", GetLastError() );
+
+    h = CreateMutexW( NULL, TRUE, NULL );
+    ok( h != NULL, "CreateMutex failed\n" );
+    SetLastError( 12345678 );
+    type = GetFileType( h );
+    ok( type == FILE_TYPE_UNKNOWN, "expected type unknown got %ld\n", type );
+    ok( GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE got %lx\n", GetLastError() );
+    CloseHandle( h );
 }
 
 static int completion_count;
diff --git a/dlls/kernel32/tests/heap.c b/dlls/kernel32/tests/heap.c
index a81cb1b7a15..b0b56132393 100644
--- a/dlls/kernel32/tests/heap.c
+++ b/dlls/kernel32/tests/heap.c
@@ -827,11 +827,8 @@ static void test_HeapCreate(void)
     size = 0;
     SetLastError( 0xdeadbeef );
     ret = pHeapQueryInformation( 0, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
-    todo_wine
     ok( !ret, "HeapQueryInformation succeeded\n" );
-    todo_wine
     ok( GetLastError() == ERROR_NOACCESS, "got error %lu\n", GetLastError() );
-    todo_wine
     ok( size == 0, "got size %Iu\n", size );
 
     size = 0;
@@ -871,7 +868,6 @@ static void test_HeapCreate(void)
     ok( ret, "HeapSetInformation failed, error %lu\n", GetLastError() );
     ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
     ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( compat_info == 2, "got HeapCompatibilityInformation %lu\n", compat_info );
 
     /* cannot be undone */
@@ -879,25 +875,44 @@ static void test_HeapCreate(void)
     compat_info = 0;
     SetLastError( 0xdeadbeef );
     ret = pHeapSetInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info) );
-    todo_wine
     ok( !ret, "HeapSetInformation succeeded\n" );
-    todo_wine
     ok( GetLastError() == ERROR_GEN_FAILURE, "got error %lu\n", GetLastError() );
     compat_info = 1;
     SetLastError( 0xdeadbeef );
     ret = pHeapSetInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info) );
-    todo_wine
     ok( !ret, "HeapSetInformation succeeded\n" );
-    todo_wine
     ok( GetLastError() == ERROR_GEN_FAILURE, "got error %lu\n", GetLastError() );
     ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
     ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( compat_info == 2, "got HeapCompatibilityInformation %lu\n", compat_info );
 
     ret = HeapDestroy( heap );
     ok( ret, "HeapDestroy failed, error %lu\n", GetLastError() );
 
+
+    /* cannot set LFH with HEAP_NO_SERIALIZE */
+
+    heap = HeapCreate( HEAP_NO_SERIALIZE, 0, 0 );
+    ok( !!heap, "HeapCreate failed, error %lu\n", GetLastError() );
+    ok( !((ULONG_PTR)heap & 0xffff), "wrong heap alignment\n" );
+
+    ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
+    ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
+    ok( compat_info == 0, "got HeapCompatibilityInformation %lu\n", compat_info );
+
+    compat_info = 2;
+    SetLastError( 0xdeadbeef );
+    ret = pHeapSetInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info) );
+    ok( !ret, "HeapSetInformation succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
+    ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
+    ok( compat_info == 0, "got HeapCompatibilityInformation %lu\n", compat_info );
+
+    ret = HeapDestroy( heap );
+    ok( ret, "HeapDestroy failed, error %lu\n", GetLastError() );
+
+
     /* some allocation pattern automatically enables LFH */
 
     heap = HeapCreate( 0, 0, 0 );
@@ -913,7 +928,6 @@ static void test_HeapCreate(void)
 
     ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
     ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( compat_info == 2, "got HeapCompatibilityInformation %lu\n", compat_info );
 
     ret = HeapDestroy( heap );
@@ -931,7 +945,6 @@ static void test_HeapCreate(void)
     ok( ret, "HeapSetInformation failed, error %lu\n", GetLastError() );
     ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
     ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( compat_info == 2, "got HeapCompatibilityInformation %lu\n", compat_info );
 
     for (i = 0; i < 0x11; i++) ptrs[i] = pHeapAlloc( heap, 0, 24 + 2 * sizeof(void *) );
@@ -973,6 +986,7 @@ static void test_HeapCreate(void)
     ok( entries[0].cbData <= 0x1000 /* sizeof(*heap) */, "got cbData %#lx\n", entries[0].cbData );
     ok( entries[0].cbOverhead == 0, "got cbOverhead %#x\n", entries[0].cbOverhead );
     ok( entries[0].iRegionIndex == 0, "got iRegionIndex %d\n", entries[0].iRegionIndex );
+    todo_wine /* Wine currently reports the LFH group as a single block here */
     ok( entries[1].wFlags == 0, "got wFlags %#x\n", entries[1].wFlags );
 
     for (i = 0; i < 0x12; i++)
@@ -1053,6 +1067,7 @@ static void test_HeapCreate(void)
     for (i = 1; i < count - 2; i++)
     {
         if (entries[i].wFlags != PROCESS_HEAP_ENTRY_BUSY) continue;
+        todo_wine /* Wine currently reports the LFH group as a single block */
         ok( entries[i].cbData == 0x18 + 2 * sizeof(void *), "got cbData %#lx\n", entries[i].cbData );
         ok( entries[i].cbOverhead == 0x8, "got cbOverhead %#x\n", entries[i].cbOverhead );
     }
@@ -1205,7 +1220,6 @@ static void test_HeapCreate(void)
 
     ret = pHeapQueryInformation( heap, HeapCompatibilityInformation, &compat_info, sizeof(compat_info), &size );
     ok( ret, "HeapQueryInformation failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( compat_info == 2, "got HeapCompatibilityInformation %lu\n", compat_info );
 
     /* locking is serialized */
@@ -1232,7 +1246,6 @@ static void test_HeapCreate(void)
     thread_params.flags = 0;
     SetEvent( thread_params.start_event );
     res = WaitForSingleObject( thread_params.ready_event, 100 );
-    todo_wine
     ok( !res, "WaitForSingleObject returned %#lx, error %lu\n", res, GetLastError() );
     ret = HeapUnlock( heap );
     ok( ret, "HeapUnlock failed, error %lu\n", GetLastError() );
@@ -1679,9 +1692,7 @@ static void test_GlobalAlloc(void)
     ok( size == small_size, "GlobalSize returned %Iu\n", size );
     SetLastError( 0xdeadbeef );
     tmp_mem = GlobalReAlloc( mem, small_size, 0 );
-    todo_wine
     ok( !tmp_mem, "GlobalReAlloc succeeded\n" );
-    todo_wine
     ok( GetLastError() == ERROR_NOT_ENOUGH_MEMORY, "got error %lu\n", GetLastError() );
     if (tmp_mem) mem = tmp_mem;
     tmp_mem = GlobalReAlloc( mem, 1024 * 1024, GMEM_MODIFY );
@@ -1697,7 +1708,6 @@ static void test_GlobalAlloc(void)
     ok( !!mem, "GlobalAlloc failed, error %lu\n", GetLastError() );
     tmp_mem = GlobalReAlloc( mem, small_size + 1, GMEM_MOVEABLE );
     ok( !!tmp_mem, "GlobalReAlloc failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( tmp_mem != mem, "GlobalReAlloc didn't relocate memory\n" );
     ptr = GlobalLock( tmp_mem );
     ok( !!ptr, "GlobalLock failed, error %lu\n", GetLastError() );
@@ -1844,8 +1854,8 @@ static void test_GlobalAlloc(void)
         {
             ok( !is_mem_entry( tmp_mem ), "unexpected moveable %p\n", tmp_mem );
             if (flags == GMEM_MODIFY) ok( tmp_mem == mem, "GlobalReAlloc returned %p\n", tmp_mem );
-            else if (flags != GMEM_MOVEABLE) todo_wine_if(!flags) ok( !tmp_mem, "GlobalReAlloc succeeded\n" );
-            else todo_wine ok( tmp_mem != mem, "GlobalReAlloc returned %p\n", tmp_mem );
+            else if (flags != GMEM_MOVEABLE) ok( !tmp_mem, "GlobalReAlloc succeeded\n" );
+            else ok( tmp_mem != mem, "GlobalReAlloc returned %p\n", tmp_mem );
         }
         else
         {
@@ -1859,7 +1869,7 @@ static void test_GlobalAlloc(void)
 
         size = GlobalSize( mem );
         if (flags == GMEM_MOVEABLE) ok( size == 0 || broken( size == 1 ) /* w7 */, "GlobalSize returned %Iu\n", size );
-        else todo_wine_if(!flags) ok( size == small_size, "GlobalSize returned %Iu\n", size );
+        else ok( size == small_size, "GlobalSize returned %Iu\n", size );
 
         mem = GlobalFree( mem );
         ok( !mem, "GlobalFree failed, error %lu\n", GetLastError() );
@@ -2417,9 +2427,7 @@ static void test_LocalAlloc(void)
     ok( size == small_size, "LocalSize returned %Iu\n", size );
     SetLastError( 0xdeadbeef );
     tmp_mem = LocalReAlloc( mem, small_size, 0 );
-    todo_wine
     ok( !tmp_mem, "LocalReAlloc succeeded\n" );
-    todo_wine
     ok( GetLastError() == ERROR_NOT_ENOUGH_MEMORY, "got error %lu\n", GetLastError() );
     if (tmp_mem) mem = tmp_mem;
     tmp_mem = LocalReAlloc( mem, 1024 * 1024, LMEM_MODIFY );
@@ -2435,7 +2443,6 @@ static void test_LocalAlloc(void)
     ok( !!mem, "LocalAlloc failed, error %lu\n", GetLastError() );
     tmp_mem = LocalReAlloc( mem, small_size + 1, LMEM_MOVEABLE );
     ok( !!tmp_mem, "LocalReAlloc failed, error %lu\n", GetLastError() );
-    todo_wine
     ok( tmp_mem != mem, "LocalReAlloc didn't relocate memory\n" );
     ptr = LocalLock( tmp_mem );
     ok( !!ptr, "LocalLock failed, error %lu\n", GetLastError() );
@@ -2528,13 +2535,13 @@ static void test_LocalAlloc(void)
         tmp_mem = LocalReAlloc( mem, 0, flags );
         ok( !is_mem_entry( tmp_mem ), "unexpected moveable %p\n", tmp_mem );
         if (flags & LMEM_MODIFY) ok( tmp_mem == mem, "LocalReAlloc returned %p\n", tmp_mem );
-        else if (flags != LMEM_MOVEABLE) todo_wine_if(!flags) ok( !tmp_mem, "LocalReAlloc succeeded\n" );
-        else todo_wine ok( tmp_mem != mem, "LocalReAlloc returned %p\n", tmp_mem );
+        else if (flags != LMEM_MOVEABLE) ok( !tmp_mem, "LocalReAlloc succeeded\n" );
+        else ok( tmp_mem != mem, "LocalReAlloc returned %p\n", tmp_mem );
         if (tmp_mem) mem = tmp_mem;
 
         size = LocalSize( mem );
         if (flags == LMEM_MOVEABLE) ok( size == 0 || broken( size == 1 ) /* w7 */, "LocalSize returned %Iu\n", size );
-        else todo_wine_if(!flags) ok( size == small_size, "LocalSize returned %Iu\n", size );
+        else ok( size == small_size, "LocalSize returned %Iu\n", size );
 
         mem = LocalFree( mem );
         ok( !mem, "LocalFree failed, error %lu\n", GetLastError() );
diff --git a/dlls/kernel32/tests/locale.c b/dlls/kernel32/tests/locale.c
index 886240cc22c..b2c581dc518 100644
--- a/dlls/kernel32/tests/locale.c
+++ b/dlls/kernel32/tests/locale.c
@@ -1404,6 +1404,7 @@ static void test_GetNumberFormatA(void)
   static char szComma[] = { ',', '\0' };
   int ret;
   LCID lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
+  WCHAR grouping[32], t1000[8], dec[8], frac[8], lzero[8];
   char buffer[BUFFER_SIZE];
   NUMBERFMTA format;
 
@@ -1522,6 +1523,22 @@ static void test_GetNumberFormatA(void)
   ret = GetNumberFormatA(lcid, 0, "123456789", &format, buffer, ARRAY_SIZE(buffer));
   expect_str(ret, buffer, "1234,567,89.0");
 
+  format.Grouping = 203;
+  ret = GetNumberFormatA(lcid, 0, "123456789", &format, buffer, ARRAY_SIZE(buffer));
+  expect_str(ret, buffer, "1,234,567,,89.0");
+
+  format.Grouping = 2030;
+  ret = GetNumberFormatA(lcid, 0, "123456789", &format, buffer, ARRAY_SIZE(buffer));
+  expect_str(ret, buffer, "1234,567,,89.0");
+
+  format.Grouping = 2003;
+  ret = GetNumberFormatA(lcid, 0, "123456789", &format, buffer, ARRAY_SIZE(buffer));
+  expect_str(ret, buffer, "1,234,567,,,89.0");
+
+  format.Grouping = 1200;
+  ret = GetNumberFormatA(lcid, 0, "123456789", &format, buffer, ARRAY_SIZE(buffer));
+  expect_str(ret, buffer, "123456,,78,9.0");
+
   /* Grouping of a negative number */
   format.NegativeOrder = NEG_LEFT;
   format.Grouping = 3;
@@ -1563,6 +1580,67 @@ static void test_GetNumberFormatA(void)
     ret = GetNumberFormatA(lcid, NUO, "-12345", NULL, buffer, ARRAY_SIZE(buffer));
     expect_str(ret, buffer, "-12\xa0\x33\x34\x35,00"); /* Non breaking space */
   }
+
+  /* Test the actual LOCALE_SGROUPING string, the rules for repeats are opposite */
+  if (GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, grouping, ARRAY_SIZE(grouping)) &&
+      GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, t1000, ARRAY_SIZE(t1000)) &&
+      GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, dec, ARRAY_SIZE(dec)) &&
+      GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_IDIGITS, frac, ARRAY_SIZE(frac)) &&
+      GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_ILZERO, lzero, ARRAY_SIZE(lzero)))
+  {
+    static const struct
+    {
+        const char *grouping;
+        const char *expected;
+    } tests[] = {
+        { "3;0",                "1,234,567,890.54321" },
+        { "2;3",                "12345,678,90.54321" },
+        { "1",                  "123456789,0.54321" },
+        { "1;0",                "1,2,3,4,5,6,7,8,9,0.54321" },
+        { "1;0;3",              "123456,789,,0.54321" },
+        { "0",                  "1234567890.54321" },
+        { "0;0",                "1234567890.54321" },
+        { "0;1",                "123456789,0.54321" },
+        { "0;0;0",              "1234567890.54321" },
+        { "0;1;0",              "1,2,3,4,5,6,7,8,9,0.54321" },
+        { "2;0;0",              "12345678,90.54321" },
+        { "2;0;0;0",            "12345678,,90.54321" },
+        { "2;0;0;0;0",          "12345678,,,90.54321" },
+        { "2;0;0;1;0",          "1,2,3,4,5,6,7,8,,,90.54321" },
+        { "1;3;2",              "1234,56,789,0.54321" },
+        { "1;3;2;0",            "12,34,56,789,0.54321" },
+        { "3;1;1;2;0",          "1,23,45,6,7,890.54321" },
+        { "6;1",                "123,4,567890.54321" },
+    };
+    unsigned i;
+
+    SetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, ",");
+    SetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, ".");
+    SetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_IDIGITS, "5");
+    SetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ILZERO, "0");
+
+    for (i = 0; i < ARRAY_SIZE(tests); i++)
+    {
+      SetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, tests[i].grouping);
+      SetLastError(0xdeadbeef);
+      ret = GetNumberFormatA(LOCALE_USER_DEFAULT, 0, "1234567890.54321", NULL, buffer, ARRAY_SIZE(buffer));
+      if (ret)
+      {
+        ok(GetLastError() == 0xdeadbeef, "[%u] unexpected error %lu\n", i, GetLastError());
+        ok(ret == strlen(tests[i].expected) + 1, "[%u] unexpected ret %d\n", i, ret);
+        ok(!strcmp(buffer, tests[i].expected), "[%u] unexpected string %s\n", i, buffer);
+      }
+      else
+        ok(0, "[%u] expected success, got error %ld\n", i, GetLastError());
+    }
+
+    /* Restore */
+    ok(SetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, grouping), "Restoring SGROUPING failed\n");
+    ok(SetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, t1000), "Restoring STHOUSAND failed\n");
+    ok(SetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, dec), "Restoring SDECIMAL failed\n");
+    ok(SetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_IDIGITS, frac), "Restoring IDIGITS failed\n");
+    ok(SetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_ILZERO, lzero), "Restoring ILZERO failed\n");
+  }
 }
 
 static void test_GetNumberFormatEx(void)
diff --git a/dlls/kernel32/tests/module.c b/dlls/kernel32/tests/module.c
index 9efbdba336d..956595bf2a1 100644
--- a/dlls/kernel32/tests/module.c
+++ b/dlls/kernel32/tests/module.c
@@ -953,6 +953,10 @@ static void init_pointers(void)
 
 static void testGetModuleHandleEx(void)
 {
+    static const char longname[] = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+                                   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+                                   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+                                   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
     static const WCHAR kernel32W[] = {'k','e','r','n','e','l','3','2',0};
     static const WCHAR nosuchmodW[] = {'n','o','s','u','c','h','m','o','d',0};
     BOOL ret;
@@ -986,6 +990,20 @@ static void testGetModuleHandleEx(void)
     ok( error == ERROR_MOD_NOT_FOUND, "got %lu\n", error );
     ok( mod == NULL, "got %p\n", mod );
 
+    SetLastError( 0xdeadbeef );
+    ret = GetModuleHandleExA( 0, longname, NULL );
+    error = GetLastError();
+    ok( !ret, "unexpected success\n" );
+    ok( error == ERROR_INVALID_PARAMETER, "got %lu\n", error );
+
+    SetLastError( 0xdeadbeef );
+    mod = (HMODULE)0xdeadbeef;
+    ret = GetModuleHandleExA( 0, longname, &mod );
+    error = GetLastError();
+    ok( !ret, "unexpected success\n" );
+    ok( error == ERROR_MOD_NOT_FOUND, "got %lu\n", error );
+    ok( mod == NULL, "got %p\n", mod );
+
     SetLastError( 0xdeadbeef );
     ret = GetModuleHandleExW( 0, NULL, NULL );
     error = GetLastError();
diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index 5ac6ed57bbe..1e30ba73bbf 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -3710,7 +3710,7 @@ static void test_process_info(HANDLE hproc)
         0 /* FIXME: sizeof(?) ProcessTlsInformation */,
         sizeof(ULONG) /* ProcessCookie */,
         sizeof(SECTION_IMAGE_INFORMATION) /* ProcessImageInformation */,
-        0 /* FIXME: sizeof(PROCESS_CYCLE_TIME_INFORMATION) ProcessCycleTime */,
+        sizeof(PROCESS_CYCLE_TIME_INFORMATION) /* ProcessCycleTime */,
         sizeof(ULONG) /* ProcessPagePriority */,
         40 /* ProcessInstrumentationCallback */,
         0 /* FIXME: sizeof(PROCESS_STACK_ALLOCATION_INFORMATION) ProcessThreadStackAllocation */,
@@ -3780,6 +3780,7 @@ static void test_process_info(HANDLE hproc)
         case ProcessHandleCount:
         case ProcessImageFileName:
         case ProcessImageInformation:
+        case ProcessCycleTime:
         case ProcessPagePriority:
         case ProcessImageFileNameWin32:
             ok(status == STATUS_SUCCESS, "for info %lu expected STATUS_SUCCESS, got %08lx (ret_len %lu)\n", i, status, ret_len);
diff --git a/dlls/kernel32/tests/resource.rc b/dlls/kernel32/tests/resource.rc
index 58902e7a015..0db0ddf2bd8 100644
--- a/dlls/kernel32/tests/resource.rc
+++ b/dlls/kernel32/tests/resource.rc
@@ -25,4 +25,5 @@
     MENUITEM "foo", 1
 }
 
+/* @makedep: wine_test.manifest */
 124 24 wine_test.manifest
diff --git a/dlls/kernel32/tests/volume.c b/dlls/kernel32/tests/volume.c
index eb0b5fec772..5d2d971232f 100644
--- a/dlls/kernel32/tests/volume.c
+++ b/dlls/kernel32/tests/volume.c
@@ -87,7 +87,7 @@ static void test_query_dos_deviceA(void)
         for (;;) {
             if (!*p) break;
             ret2 = QueryDosDeviceA( p, buffer2, sizeof(buffer2) );
-            /* Win10+ exposes security device which requires extra priviledges to be queried. So skip it */
+            /* Win10+ exposes the security device which requires extra privileges to be queried. So skip it */
             ok(ret2 || broken( !strcmp( p, "MSSECFLTSYS" ) && GetLastError() == ERROR_ACCESS_DENIED ),
                "QueryDosDeviceA failed to return current mapping for %s, last error %lu\n", p, GetLastError());
             p += strlen(p) + 1;
diff --git a/dlls/kernelbase/console.c b/dlls/kernelbase/console.c
index 7cd87f53b3c..fa143857bc2 100644
--- a/dlls/kernelbase/console.c
+++ b/dlls/kernelbase/console.c
@@ -205,12 +205,11 @@ static COORD get_console_font_size( HANDLE handle, DWORD index )
 static HANDLE create_console_server( void )
 {
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING string;
+    UNICODE_STRING string = RTL_CONSTANT_STRING( L"\\Device\\ConDrv\\Server" );
     IO_STATUS_BLOCK iosb;
     HANDLE handle;
     NTSTATUS status;
 
-    RtlInitUnicodeString( &string, L"\\Device\\ConDrv\\Server" );
     attr.ObjectName = &string;
     attr.Attributes = OBJ_INHERIT;
     status = NtCreateFile( &handle, FILE_WRITE_PROPERTIES | FILE_READ_PROPERTIES | SYNCHRONIZE,
@@ -222,12 +221,11 @@ static HANDLE create_console_server( void )
 static HANDLE create_console_reference( HANDLE root )
 {
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING string;
+    UNICODE_STRING string = RTL_CONSTANT_STRING( L"Reference" );
     IO_STATUS_BLOCK iosb;
     HANDLE handle;
     NTSTATUS status;
 
-    RtlInitUnicodeString( &string, L"Reference" );
     attr.RootDirectory = root;
     attr.ObjectName = &string;
     status = NtCreateFile( &handle, FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_PROPERTIES |
@@ -466,7 +464,7 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateConsoleScreenBuffer( DWORD access, DWORD s
 {
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
     IO_STATUS_BLOCK iosb;
-    UNICODE_STRING name;
+    UNICODE_STRING name = RTL_CONSTANT_STRING( L"\\Device\\ConDrv\\ScreenBuffer" );
     HANDLE handle;
     NTSTATUS status;
 
@@ -478,7 +476,6 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateConsoleScreenBuffer( DWORD access, DWORD s
 	return INVALID_HANDLE_VALUE;
     }
 
-    RtlInitUnicodeString( &name, L"\\Device\\ConDrv\\ScreenBuffer" );
     attr.ObjectName = &name;
     attr.SecurityDescriptor = sa ? sa->lpSecurityDescriptor : NULL;
     if (sa && sa->bInheritHandle) attr.Attributes |= OBJ_INHERIT;
diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
index cd8e0d7f87d..4eff7ad1cca 100644
--- a/dlls/kernelbase/debug.c
+++ b/dlls/kernelbase/debug.c
@@ -398,7 +398,7 @@ static void format_exception_msg( const EXCEPTION_POINTERS *ptr, char *buffer, i
 static BOOL start_debugger( EXCEPTION_POINTERS *epointers, HANDLE event )
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
+    UNICODE_STRING nameW = RTL_CONSTANT_STRING( L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug" );
     WCHAR *cmdline, *env, *p, *format = NULL;
     HANDLE dbg_key;
     DWORD autostart = TRUE;
@@ -416,7 +416,6 @@ static BOOL start_debugger( EXCEPTION_POINTERS *epointers, HANDLE event )
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &nameW, L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug" );
 
     if (!NtOpenKey( &dbg_key, KEY_READ, &attr ))
     {
@@ -772,19 +771,19 @@ struct module_iterator
 };
 
 
-static BOOL init_module_iterator( struct module_iterator *iter, HANDLE process )
+/* Caller must ensure that wow64=TRUE is only passed from 64bit for 'process' being a wow64 process */
+static BOOL init_module_iterator( struct module_iterator *iter, HANDLE process, BOOL wow64 )
 {
     PROCESS_BASIC_INFORMATION pbi;
     PPEB_LDR_DATA ldr_data;
 
-    if (!IsWow64Process( process, &iter->wow64 )) return FALSE;
-
     /* get address of PEB */
     if (!set_ntstatus( NtQueryInformationProcess( process, ProcessBasicInformation,
                                                   &pbi, sizeof(pbi), NULL )))
         return FALSE;
 
-    if (is_win64 && iter->wow64)
+    iter->wow64 = wow64;
+    if (wow64)
     {
         PEB_LDR_DATA32 *ldr_data32_ptr;
         DWORD ldr_data32, first_module;
@@ -807,6 +806,12 @@ static BOOL init_module_iterator( struct module_iterator *iter, HANDLE process )
     if (!ReadProcessMemory( process, &pbi.PebBaseAddress->LdrData, &ldr_data, sizeof(ldr_data), NULL ))
         return FALSE;
 
+    /* This happens when running "old" wow64 configuration. Mark it as such. */
+    if (!ldr_data)
+    {
+        SetLastError( ERROR_EMPTY );
+        return FALSE;
+    }
     /* read address of first module from LdrData */
     if (!ReadProcessMemory( process, &ldr_data->InLoadOrderModuleList.Flink,
                             &iter->current, sizeof(iter->current), NULL ))
@@ -849,7 +854,7 @@ static BOOL get_ldr_module( HANDLE process, HMODULE module, LDR_DATA_TABLE_ENTRY
     struct module_iterator iter;
     INT ret;
 
-    if (!init_module_iterator( &iter, process )) return FALSE;
+    if (!init_module_iterator( &iter, process, FALSE )) return FALSE;
 
     while ((ret = module_iterator_next( &iter )) > 0)
         /* When hModule is NULL we return the process image - which will be
@@ -870,7 +875,14 @@ static BOOL get_ldr_module32( HANDLE process, HMODULE module, LDR_DATA_TABLE_ENT
     struct module_iterator iter;
     INT ret;
 
-    if (!init_module_iterator( &iter, process )) return FALSE;
+#ifdef _WIN64
+    if ((ULONG_PTR)module >> 32)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return FALSE;
+    }
+#endif
+    if (!init_module_iterator( &iter, process, TRUE )) return FALSE;
 
     while ((ret = module_iterator_next( &iter )) > 0)
         /* When hModule is NULL we return the process image - which will be
@@ -937,60 +949,133 @@ BOOL WINAPI /* DECLSPEC_HOTPATCH */ EnumPageFilesW( PENUM_PAGE_FILE_CALLBACKW ca
 BOOL WINAPI DECLSPEC_HOTPATCH EnumProcessModules( HANDLE process, HMODULE *module,
                                                   DWORD count, DWORD *needed )
 {
-    struct module_iterator iter;
-    DWORD size = 0;
-    INT ret;
+    return EnumProcessModulesEx( process, module, count, needed, LIST_MODULES_DEFAULT );
+}
 
-    if (process == GetCurrentProcess())
-    {
-        PPEB_LDR_DATA ldr_data = NtCurrentTeb()->Peb->LdrData;
-        PLIST_ENTRY head = &ldr_data->InLoadOrderModuleList;
-        PLIST_ENTRY entry = head->Flink;
 
-        if (count && !module)
-        {
-            SetLastError( ERROR_NOACCESS );
-            return FALSE;
-        }
-        while (entry != head)
-        {
-            LDR_DATA_TABLE_ENTRY *ldr = CONTAINING_RECORD( entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
-            if (count >= sizeof(HMODULE))
-            {
-                *module++ = ldr->DllBase;
-                count -= sizeof(HMODULE);
-            }
-            size += sizeof(HMODULE);
-            entry = entry->Flink;
-        }
-        if (!needed)
-        {
-            SetLastError( ERROR_NOACCESS );
-            return FALSE;
-        }
-        *needed = size;
-        return TRUE;
+struct module_push
+{
+    HMODULE *module;
+    unsigned count;
+    unsigned size;
+};
+
+static void module_push( struct module_push *mp, HMODULE module )
+{
+    if (mp->count >= sizeof(HMODULE))
+    {
+        *mp->module++ = module;
+        mp->count -= sizeof(HMODULE);
     }
+    mp->size += sizeof(HMODULE);
+}
+
+static void module_push_iter( struct module_push *mp, struct module_iterator *iter )
+{
+    if (is_win64 && iter->wow64)
+        module_push( mp, (HMODULE) (DWORD_PTR)iter->ldr_module32.BaseAddress );
+    else
+        module_push( mp, iter->ldr_module.DllBase );
+}
+
+static int module_push_all( struct module_push *mp, struct module_iterator *iter )
+{
+    int ret;
+
+    while ((ret = module_iterator_next( iter )) > 0)
+        module_push_iter( mp, iter );
+
+    return ret;
+}
+
+/***********************************************************************
+ *         EnumProcessModulesEx   (kernelbase.@)
+ *         K32EnumProcessModulesEx   (kernelbase.@)
+ */
+BOOL WINAPI EnumProcessModulesEx( HANDLE process, HMODULE *module, DWORD count,
+                                  DWORD *needed, DWORD filter )
+{
+    struct module_push mp = {module, count, 0};
+    unsigned list_mode;
+    BOOL target_wow64;
+    INT ret = 0;
+
+    TRACE( "(%p, %p, %ld, %p, %ld)\n", process, module, count, needed, filter );
 
-    if (!init_module_iterator( &iter, process )) return FALSE;
+    if (process != GetCurrentProcess())
+    {
+        if (!IsWow64Process( process, &target_wow64 )) return FALSE;
+    }
+    else target_wow64 = is_wow64;
 
+    if (filter & ~LIST_MODULES_ALL)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+    list_mode = filter & LIST_MODULES_ALL;
+    /* Can't access 64bit process from (wow64) 32bit */
+    if (is_wow64 && !target_wow64)
+    {
+        SetLastError( ERROR_PARTIAL_COPY );
+        return FALSE;
+    }
     if (count && !module)
     {
         SetLastError( ERROR_NOACCESS );
         return FALSE;
     }
 
-    while ((ret = module_iterator_next( &iter )) > 0)
+    if (process == GetCurrentProcess())
+    {
+        if (!(is_win64 && list_mode == LIST_MODULES_32BIT))
+        {
+            PPEB_LDR_DATA ldr_data = NtCurrentTeb()->Peb->LdrData;
+            PLIST_ENTRY head = &ldr_data->InLoadOrderModuleList;
+            PLIST_ENTRY entry = head->Flink;
+
+            while (entry != head)
+            {
+                LDR_DATA_TABLE_ENTRY *ldr = CONTAINING_RECORD( entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
+                module_push( &mp, ldr->DllBase );
+                entry = entry->Flink;
+            }
+        }
+    }
+    else
     {
-        if (count >= sizeof(HMODULE))
+        struct module_iterator iter;
+
+        if (is_win64 && target_wow64 && (list_mode & LIST_MODULES_32BIT))
         {
-            if (sizeof(void *) == 8 && iter.wow64)
-                *module++ = (HMODULE) (DWORD_PTR)iter.ldr_module32.BaseAddress;
+            if (!init_module_iterator( &iter, process, TRUE ) || module_push_all( &mp, &iter ) < 0)
+                return FALSE;
+        }
+        if (!(is_win64 && list_mode == LIST_MODULES_32BIT))
+        {
+            if (init_module_iterator( &iter, process, FALSE ))
+            {
+                if (is_win64 && target_wow64 && (list_mode & LIST_MODULES_64BIT))
+                    /* Don't add main module twice in _ALL mode */
+                    ret = module_iterator_next( &iter );
+                if (ret >= 0) ret = module_push_all( &mp, &iter );
+            }
+            else if (GetLastError() == ERROR_EMPTY)
+            {
+                /* We're running on "old" wow configuration.
+                 * Fallback to PEB32 to get at least main module if requested.
+                 */
+                if (list_mode == LIST_MODULES_DEFAULT)
+                {
+                    if (init_module_iterator( &iter, process, TRUE ) && module_iterator_next( &iter ) > 0)
+                        module_push_iter( &mp, &iter );
+                    else
+                        ret = -1;
+                }
+            }
             else
-                *module++ = iter.ldr_module.DllBase;
-            count -= sizeof(HMODULE);
+                return FALSE;
         }
-        size += sizeof(HMODULE);
     }
 
     if (!needed)
@@ -998,23 +1083,11 @@ BOOL WINAPI DECLSPEC_HOTPATCH EnumProcessModules( HANDLE process, HMODULE *modul
         SetLastError( ERROR_NOACCESS );
         return FALSE;
     }
-    *needed = size;
+    *needed = mp.size;
     return ret == 0;
 }
 
 
-/***********************************************************************
- *         EnumProcessModulesEx   (kernelbase.@)
- *         K32EnumProcessModulesEx   (kernelbase.@)
- */
-BOOL WINAPI EnumProcessModulesEx( HANDLE process, HMODULE *module, DWORD count,
-                                  DWORD *needed, DWORD filter )
-{
-    FIXME( "(%p, %p, %ld, %p, %ld) semi-stub\n", process, module, count, needed, filter );
-    return EnumProcessModules( process, module, count, needed );
-}
-
-
 /***********************************************************************
  *         EnumProcesses   (kernelbase.@)
  *         K32EnumProcesses   (kernelbase.@)
@@ -1189,7 +1262,7 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetModuleBaseNameA( HANDLE process, HMODULE modul
 DWORD WINAPI DECLSPEC_HOTPATCH GetModuleBaseNameW( HANDLE process, HMODULE module,
                                                    WCHAR *name, DWORD size )
 {
-    BOOL wow64;
+    BOOL wow64, found = FALSE;
 
     if (!IsWow64Process( process, &wow64 )) return 0;
 
@@ -1197,13 +1270,15 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetModuleBaseNameW( HANDLE process, HMODULE modul
     {
         LDR_DATA_TABLE_ENTRY32 ldr_module32;
 
-        if (!get_ldr_module32(process, module, &ldr_module32)) return 0;
-        size = min( ldr_module32.BaseDllName.Length / sizeof(WCHAR), size );
-        if (!ReadProcessMemory( process, (void *)(DWORD_PTR)ldr_module32.BaseDllName.Buffer,
-                                name, size * sizeof(WCHAR), NULL ))
-            return 0;
+        if (get_ldr_module32(process, module, &ldr_module32))
+        {
+            size = min( ldr_module32.BaseDllName.Length / sizeof(WCHAR), size );
+            if (ReadProcessMemory( process, (void *)(DWORD_PTR)ldr_module32.BaseDllName.Buffer,
+                                   name, size * sizeof(WCHAR), NULL ))
+                found = TRUE;
+        }
     }
-    else
+    if (!found)
     {
         LDR_DATA_TABLE_ENTRY ldr_module;
 
@@ -1269,7 +1344,7 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameExA( HANDLE process, HMODULE mod
 DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameExW( HANDLE process, HMODULE module,
                                                      WCHAR *name, DWORD size )
 {
-    BOOL wow64;
+    BOOL wow64, found = FALSE;
     DWORD len;
 
     if (!size) return 0;
@@ -1280,13 +1355,15 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameExW( HANDLE process, HMODULE mod
     {
         LDR_DATA_TABLE_ENTRY32 ldr_module32;
 
-        if (!get_ldr_module32( process, module, &ldr_module32 )) return 0;
-        len = ldr_module32.FullDllName.Length / sizeof(WCHAR);
-        if (!ReadProcessMemory( process, (void *)(DWORD_PTR)ldr_module32.FullDllName.Buffer,
-                                name, min( len, size ) * sizeof(WCHAR), NULL ))
-            return 0;
+        if (get_ldr_module32( process, module, &ldr_module32 ))
+        {
+            len = ldr_module32.FullDllName.Length / sizeof(WCHAR);
+            if (ReadProcessMemory( process, (void *)(DWORD_PTR)ldr_module32.FullDllName.Buffer,
+                                   name, min( len, size ) * sizeof(WCHAR), NULL ))
+                found = TRUE;
+        }
     }
-    else
+    if (!found)
     {
         LDR_DATA_TABLE_ENTRY ldr_module;
 
@@ -1316,7 +1393,7 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameExW( HANDLE process, HMODULE mod
  */
 BOOL WINAPI GetModuleInformation( HANDLE process, HMODULE module, MODULEINFO *modinfo, DWORD count )
 {
-    BOOL wow64;
+    BOOL wow64, found = FALSE;
 
     if (count < sizeof(MODULEINFO))
     {
@@ -1330,12 +1407,15 @@ BOOL WINAPI GetModuleInformation( HANDLE process, HMODULE module, MODULEINFO *mo
     {
         LDR_DATA_TABLE_ENTRY32 ldr_module32;
 
-        if (!get_ldr_module32( process, module, &ldr_module32 )) return FALSE;
-        modinfo->lpBaseOfDll = (void *)(DWORD_PTR)ldr_module32.BaseAddress;
-        modinfo->SizeOfImage = ldr_module32.SizeOfImage;
-        modinfo->EntryPoint  = (void *)(DWORD_PTR)ldr_module32.EntryPoint;
+        if (get_ldr_module32( process, module, &ldr_module32 ))
+        {
+            modinfo->lpBaseOfDll = (void *)(DWORD_PTR)ldr_module32.BaseAddress;
+            modinfo->SizeOfImage = ldr_module32.SizeOfImage;
+            modinfo->EntryPoint  = (void *)(DWORD_PTR)ldr_module32.EntryPoint;
+            found = TRUE;
+        }
     }
-    else
+    if (!found)
     {
         LDR_DATA_TABLE_ENTRY ldr_module;
 
diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index ac04388acde..b676c50c416 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -148,7 +148,9 @@ static BOOL add_boot_rename_entry( LPCWSTR source, LPCWSTR dest, DWORD flags )
     static const int info_size = FIELD_OFFSET( KEY_VALUE_PARTIAL_INFORMATION, Data );
 
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW, source_name, dest_name;
+    UNICODE_STRING session_manager = RTL_CONSTANT_STRING( L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );
+    UNICODE_STRING pending_file_rename_operations = RTL_CONSTANT_STRING( L"PendingFileRenameOperations" );
+    UNICODE_STRING source_name, dest_name;
     KEY_VALUE_PARTIAL_INFORMATION *info;
     BOOL rc = FALSE;
     HANDLE key = 0;
@@ -172,11 +174,10 @@ static BOOL add_boot_rename_entry( LPCWSTR source, LPCWSTR dest, DWORD flags )
 
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
-    attr.ObjectName = &nameW;
+    attr.ObjectName = &session_manager;
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &nameW, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );
 
     if (NtCreateKey( &key, KEY_ALL_ACCESS, &attr, 0, NULL, 0, NULL ) != STATUS_SUCCESS)
     {
@@ -194,14 +195,12 @@ static BOOL add_boot_rename_entry( LPCWSTR source, LPCWSTR dest, DWORD flags )
     }
     else len2 = sizeof(WCHAR); /* minimum is the 0 characters for the empty second string */
 
-    RtlInitUnicodeString( &nameW, L"PendingFileRenameOperations" );
-
     /* First we check if the key exists and if so how many bytes it already contains. */
-    if (NtQueryValueKey( key, &nameW, KeyValuePartialInformation,
+    if (NtQueryValueKey( key, &pending_file_rename_operations, KeyValuePartialInformation,
                          NULL, 0, &size ) == STATUS_BUFFER_TOO_SMALL)
     {
         if (!(buffer = HeapAlloc( GetProcessHeap(), 0, size + len1 + len2 + sizeof(WCHAR) ))) goto done;
-        if (NtQueryValueKey( key, &nameW, KeyValuePartialInformation, buffer, size, &size )) goto done;
+        if (NtQueryValueKey( key, &pending_file_rename_operations, KeyValuePartialInformation, buffer, size, &size )) goto done;
         info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
         if (info->Type != REG_MULTI_SZ) goto done;
         if (size > sizeof(info)) size -= sizeof(WCHAR);  /* remove terminating null (will be added back later) */
@@ -231,7 +230,7 @@ static BOOL add_boot_rename_entry( LPCWSTR source, LPCWSTR dest, DWORD flags )
     p = (WCHAR *)(buffer + size);
     *p = 0;
     size += sizeof(WCHAR);
-    rc = !NtSetValueKey( key, &nameW, 0, REG_MULTI_SZ, buffer + info_size, size - info_size );
+    rc = !NtSetValueKey( key, &pending_file_rename_operations, 0, REG_MULTI_SZ, buffer + info_size, size - info_size );
 
  done:
     RtlFreeUnicodeString( &source_name );
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 95d4b64d76e..80cc163468c 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1234,8 +1234,8 @@
 @ stdcall QueryFullProcessImageNameW(ptr long ptr ptr)
 # @ stub QueryIdleProcessorCycleTime
 # @ stub QueryIdleProcessorCycleTimeEx
-# @ stub QueryInterruptTime
-# @ stub QueryInterruptTimePrecise
+@ stdcall QueryInterruptTime(ptr)
+@ stdcall QueryInterruptTimePrecise(ptr)
 @ stdcall QueryMemoryResourceNotification(ptr ptr)
 # @ stub QueryOptionalDelayLoadedAPI
 @ stdcall QueryPerformanceCounter(ptr) ntdll.RtlQueryPerformanceCounter
@@ -1250,7 +1250,7 @@
 @ stdcall QueryThreadCycleTime(long ptr)
 @ stdcall QueryThreadpoolStackInformation(ptr ptr)
 @ stdcall QueryUnbiasedInterruptTime(ptr) ntdll.RtlQueryUnbiasedInterruptTime
-# @ stub QueryUnbiasedInterruptTimePrecise
+@ stdcall QueryUnbiasedInterruptTimePrecise(ptr)
 @ stdcall QueryVirtualMemoryInformation(long ptr long ptr long ptr)
 @ stdcall QueryWorkingSet(long ptr long)
 @ stdcall QueryWorkingSetEx(long ptr long)
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 0fd2d7b7c99..22dff7ba56b 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -352,10 +352,21 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExA( DWORD flags, LPCSTR name, HMOD
 {
     WCHAR *nameW;
 
+    if (!module)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+
     if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
         return GetModuleHandleExW( flags, (LPCWSTR)name, module );
 
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return FALSE;
+    if (!(nameW = file_name_AtoW( name, FALSE )))
+    {
+        *module = NULL;
+        SetLastError( ERROR_MOD_NOT_FOUND );
+        return FALSE;
+    }
     return GetModuleHandleExW( flags, nameW, module );
 }
 
diff --git a/dlls/kernelbase/locale.c b/dlls/kernelbase/locale.c
index 1e96e49622e..632f5b6d88a 100644
--- a/dlls/kernelbase/locale.c
+++ b/dlls/kernelbase/locale.c
@@ -3915,21 +3915,25 @@ static int find_substring( const struct sortguid *sortid, DWORD flags, const WCH
 
     for (start = 0; start < srclen; start++)
     {
+        pos = start;
         for (len = start + 1; len <= srclen; len++)
         {
-            pos = start;
             while (pos < len && s.primary_pos <= val.key_primary.len)
             {
                 while (pos < len && !s.key_primary.len)
                     pos += append_weights( sortid, flags, src, srclen, pos,
                                            case_mask, except, compr_tables, &s, TRUE );
 
-                if (s.primary_pos + s.key_primary.len > val.key_primary.len) goto next;
-                if (memcmp( primary, val.key_primary.buf + s.primary_pos, s.key_primary.len )) goto next;
+                if (s.primary_pos + s.key_primary.len > val.key_primary.len ||
+                    memcmp( primary, val.key_primary.buf + s.primary_pos, s.key_primary.len ))
+                {
+                    len = srclen + 1;
+                    goto next;
+                }
                 s.primary_pos += s.key_primary.len;
                 s.key_primary.len = 0;
             }
-            if (s.primary_pos < val.key_primary.len) goto next;
+            if (s.primary_pos < val.key_primary.len) continue;
 
             have_extra = remove_unneeded_weights( sortid, &s );
             if (compare_sortkeys( &s.key_diacritic, &val.key_diacritic, FALSE )) goto next;
@@ -3953,6 +3957,7 @@ static int find_substring( const struct sortguid *sortid, DWORD flags, const WCH
             s.key_primary.len = s.key_diacritic.len = s.key_case.len = s.key_special.len = 0;
             s.key_extra[0].len = s.key_extra[1].len = s.key_extra[2].len = s.key_extra[3].len = 0;
             s.primary_pos = 0;
+            pos = start;
         }
         if (flags & FIND_STARTSWITH) break;
         if (flags & FIND_FROMSTART && found != -1) break;
@@ -7245,8 +7250,20 @@ BOOL WINAPI SetUserGeoName(PWSTR geo_name)
 
 static void grouping_to_string( UINT grouping, WCHAR *buffer )
 {
+    UINT last_digit = grouping % 10;
     WCHAR tmp[10], *p = tmp;
 
+    /* The string is confusingly different when it comes to repetitions (trailing zeros). For a string,
+     * a 0 signals that the format needs to be repeated, which is the opposite of the grouping integer. */
+    if (last_digit == 0)
+    {
+        grouping /= 10;
+
+        /* Special case: two or more trailing zeros result in zero-sided groupings, with no repeats */
+        if (grouping % 10 == 0)
+            last_digit = ~0;
+    }
+
     while (grouping)
     {
         *p++ = '0' + grouping % 10;
@@ -7257,6 +7274,17 @@ static void grouping_to_string( UINT grouping, WCHAR *buffer )
         *buffer++ = *(--p);
         if (p > tmp) *buffer++ = ';';
     }
+    if (last_digit != 0)
+    {
+        *buffer++ = ';';
+        *buffer++ = '0';
+        if (last_digit == ~0)
+        {
+            /* Add another trailing zero due to the weird way trailing zeros work in grouping string */
+            *buffer++ = ';';
+            *buffer++ = '0';
+        }
+    }
     *buffer = 0;
 }
 
@@ -7272,9 +7300,9 @@ static WCHAR *prepend_str( WCHAR *end, const WCHAR *str )
 static WCHAR *format_number( WCHAR *end, const WCHAR *value, const WCHAR *decimal_sep,
                              const WCHAR *thousand_sep, const WCHAR *grouping, UINT digits, BOOL lzero )
 {
+    BOOL round = FALSE, repeat = FALSE;
+    UINT i, len = 0, prev = ~0;
     const WCHAR *frac = NULL;
-    BOOL round = FALSE;
-    UINT i, len = 0;
 
     *(--end) = 0;
 
@@ -7327,9 +7355,43 @@ static WCHAR *format_number( WCHAR *end, const WCHAR *value, const WCHAR *decima
     }
     if (len) lzero = FALSE;
 
+    /* leading 0s are ignored */
+    while (grouping[0] == '0' && grouping[1] == ';')
+        grouping += 2;
+
     while (len)
     {
-        UINT limit = *grouping == '0' ? ~0u : *grouping - '0';
+        UINT limit = prev;
+
+        if (!repeat)
+        {
+            limit = *grouping - '0';
+            if (grouping[1] == ';')
+            {
+                grouping += 2;
+                if (limit)
+                    prev = limit;
+                else
+                {
+                    /* Trailing 0;0 is a special case */
+                    prev = ~0;
+                    if (grouping[0] == '0' && grouping[1] != ';')
+                    {
+                        repeat = TRUE;
+                        limit = prev;
+                    }
+                }
+            }
+            else
+            {
+                repeat = TRUE;
+                if (!limit)
+                    limit = prev;
+                else
+                    prev = ~0;
+            }
+        }
+
         while (len && limit--)
         {
             WCHAR ch = value[--len];
@@ -7345,7 +7407,6 @@ static WCHAR *format_number( WCHAR *end, const WCHAR *value, const WCHAR *decima
             *(--end) = ch;
         }
         if (len) end = prepend_str( end, thousand_sep );
-        if (grouping[1] == ';') grouping += 2;
     }
     if (round) *(--end) = '1';
     else if (lzero) *(--end) = '0';
@@ -7356,7 +7417,7 @@ static WCHAR *format_number( WCHAR *end, const WCHAR *value, const WCHAR *decima
 static int get_number_format( const NLS_LOCALE_DATA *locale, DWORD flags, const WCHAR *value,
                               const NUMBERFMTW *format, WCHAR *buffer, int len )
 {
-    WCHAR *num, fmt_decimal[4], fmt_thousand[4], fmt_neg[5], grouping[20], output[256];
+    WCHAR *num, fmt_decimal[4], fmt_thousand[4], fmt_neg[5], grouping[24], output[256];
     const WCHAR *decimal_sep = fmt_decimal, *thousand_sep = fmt_thousand;
     DWORD digits, lzero, order;
     int ret = 0;
diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 39de15066d4..837bdfd5e87 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -1074,10 +1074,13 @@ BOOL WINAPI DECLSPEC_HOTPATCH ProcessIdToSessionId( DWORD pid, DWORD *id )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH QueryProcessCycleTime( HANDLE process, ULONG64 *cycle )
 {
-    static int once;
-    if (!once++) FIXME( "(%p,%p): stub!\n", process, cycle );
-    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
-    return FALSE;
+    PROCESS_CYCLE_TIME_INFORMATION time;
+
+    if (!set_ntstatus( NtQueryInformationProcess( process, ProcessCycleTime, &time, sizeof(time), NULL ) ))
+        return FALSE;
+
+    *cycle = time.AccumulatedCycles;
+    return TRUE;
 }
 
 
diff --git a/dlls/kernelbase/registry.c b/dlls/kernelbase/registry.c
index 91462d80e06..0137cbe6cad 100644
--- a/dlls/kernelbase/registry.c
+++ b/dlls/kernelbase/registry.c
@@ -107,7 +107,7 @@ static BOOL is_wow6432node( const UNICODE_STRING *name )
 static HANDLE open_wow6432node( HANDLE key )
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
+    UNICODE_STRING nameW = RTL_CONSTANT_STRING( L"Wow6432Node" );
     HANDLE ret;
 
     attr.Length = sizeof(attr);
@@ -116,7 +116,6 @@ static HANDLE open_wow6432node( HANDLE key )
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &nameW, L"Wow6432Node" );
     if (NtOpenKeyEx( &ret, MAXIMUM_ALLOWED, &attr, 0 )) ret = 0;
     return ret;
 }
@@ -2312,7 +2311,7 @@ LSTATUS WINAPI RegLoadKeyW( HKEY hkey, LPCWSTR subkey, LPCWSTR filename )
  */
 LSTATUS WINAPI RegLoadKeyA( HKEY hkey, LPCSTR subkey, LPCSTR filename )
 {
-    UNICODE_STRING subkeyW, filenameW;
+    UNICODE_STRING subkeyW = { 0, 0, NULL }, filenameW = { 0, 0, NULL };
     STRING subkeyA, filenameA;
     NTSTATUS status;
     LONG ret;
@@ -2320,8 +2319,6 @@ LSTATUS WINAPI RegLoadKeyA( HKEY hkey, LPCSTR subkey, LPCSTR filename )
     RtlInitAnsiString(&subkeyA, subkey);
     RtlInitAnsiString(&filenameA, filename);
 
-    RtlInitUnicodeString(&subkeyW, NULL);
-    RtlInitUnicodeString(&filenameW, NULL);
     if (!(status = RtlAnsiStringToUnicodeString(&subkeyW, &subkeyA, TRUE)) &&
         !(status = RtlAnsiStringToUnicodeString(&filenameW, &filenameA, TRUE)))
     {
diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 60b33af99c3..eabde0530d9 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -205,6 +205,47 @@ ULONGLONG WINAPI DECLSPEC_HOTPATCH GetTickCount64(void)
 }
 
 
+/******************************************************************************
+ *           QueryInterruptTime  (kernelbase.@)
+ */
+void WINAPI DECLSPEC_HOTPATCH QueryInterruptTime( ULONGLONG *time )
+{
+    ULONG high, low;
+
+    do
+    {
+        high = user_shared_data->InterruptTime.High1Time;
+        low = user_shared_data->InterruptTime.LowPart;
+    }
+    while (high != user_shared_data->InterruptTime.High2Time);
+    *time = (ULONGLONG)high << 32 | low;
+}
+
+
+/******************************************************************************
+ *           QueryInterruptTimePrecise  (kernelbase.@)
+ */
+void WINAPI DECLSPEC_HOTPATCH QueryInterruptTimePrecise( ULONGLONG *time )
+{
+    static int once;
+    if (!once++) FIXME( "(%p) semi-stub\n", time );
+
+    QueryInterruptTime( time );
+}
+
+
+/***********************************************************************
+ *           QueryUnbiasedInterruptTimePrecise  (kernelbase.@)
+ */
+void WINAPI DECLSPEC_HOTPATCH QueryUnbiasedInterruptTimePrecise( ULONGLONG *time )
+{
+    static int once;
+    if (!once++) FIXME( "(%p): semi-stub.\n", time );
+
+    RtlQueryUnbiasedInterruptTime( time );
+}
+
+
 /***********************************************************************
  * Waits
  ***********************************************************************/
@@ -1264,12 +1305,12 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateNamedPipeW( LPCWSTR name, DWORD open_mode,
     if (instances >= PIPE_UNLIMITED_INSTANCES) instances = ~0U;
 
     time.QuadPart = (ULONGLONG)timeout * -10000;
-    SetLastError( 0 );
     status = NtCreateNamedPipeFile( &handle, access, &attr, &iosb, sharing,
-                                    FILE_OVERWRITE_IF, options, pipe_type,
+                                    FILE_OPEN_IF, options, pipe_type,
                                     read_mode, non_block, instances, in_buff, out_buff, &time );
     RtlFreeUnicodeString( &nt_name );
     if (!set_ntstatus( status )) return INVALID_HANDLE_VALUE;
+    SetLastError( iosb.Information == FILE_CREATED ? ERROR_SUCCESS : ERROR_ALREADY_EXISTS );
     return handle;
 }
 
@@ -1307,7 +1348,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreatePipe( HANDLE *read_pipe, HANDLE *write_pipe,
                   GetCurrentProcessId(), ++index );
         RtlInitUnicodeString( &nt_name, name );
         if (!NtCreateNamedPipeFile( read_pipe, GENERIC_READ | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
-                                    &attr, &iosb, FILE_SHARE_WRITE, FILE_OVERWRITE_IF,
+                                    &attr, &iosb, FILE_SHARE_WRITE, FILE_OPEN_IF,
                                     FILE_SYNCHRONOUS_IO_NONALERT,
                                     FALSE, FALSE, FALSE, 1, size, size, &timeout ))
             break;
diff --git a/dlls/kernelbase/tests/process.c b/dlls/kernelbase/tests/process.c
index ed213f1f7b6..b8c3bbb7276 100644
--- a/dlls/kernelbase/tests/process.c
+++ b/dlls/kernelbase/tests/process.c
@@ -421,6 +421,21 @@ static void test_MapViewOfFileFromApp(void)
     ok(ret, "Failed to delete a test file.\n");
 }
 
+static void test_QueryProcessCycleTime(void)
+{
+    ULONG64 cycles1, cycles2;
+    BOOL ret;
+
+    ret = QueryProcessCycleTime( GetCurrentProcess(), &cycles1 );
+    ok( ret, "QueryProcessCycleTime failed, error %lu.\n", GetLastError() );
+
+    ret = QueryProcessCycleTime( GetCurrentProcess(), &cycles2 );
+    ok( ret, "QueryProcessCycleTime failed, error %lu.\n", GetLastError() );
+
+    todo_wine
+    ok( cycles2 > cycles1, "CPU cycles used by process should be increasing.\n" );
+}
+
 static void init_funcs(void)
 {
     HMODULE hmod = GetModuleHandleA("kernelbase.dll");
@@ -453,4 +468,5 @@ START_TEST(process)
     test_OpenFileMappingFromApp();
     test_CreateFileMappingFromApp();
     test_MapViewOfFileFromApp();
+    test_QueryProcessCycleTime();
 }
diff --git a/dlls/kernelbase/volume.c b/dlls/kernelbase/volume.c
index 39386867aa3..d39613175f9 100644
--- a/dlls/kernelbase/volume.c
+++ b/dlls/kernelbase/volume.c
@@ -433,7 +433,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH DefineDosDeviceW( DWORD flags, const WCHAR *device
  */
 DWORD WINAPI QueryDosDeviceW( LPCWSTR devname, LPWSTR target, DWORD bufsize )
 {
-    UNICODE_STRING nt_name;
     NTSTATUS status;
 
     if (!bufsize)
@@ -471,12 +470,11 @@ DWORD WINAPI QueryDosDeviceW( LPCWSTR devname, LPWSTR target, DWORD bufsize )
     }
     else  /* return a list of all devices */
     {
+        UNICODE_STRING nt_name = RTL_CONSTANT_STRING( L"\\DosDevices" );
         OBJECT_ATTRIBUTES attr;
         HANDLE handle;
         WCHAR *p = target;
 
-        RtlInitUnicodeString( &nt_name, L"\\DosDevices\\" );
-        nt_name.Length -= sizeof(WCHAR);  /* without trailing slash */
         attr.Length = sizeof(attr);
         attr.RootDirectory = 0;
         attr.ObjectName = &nt_name;
@@ -517,12 +515,11 @@ DWORD WINAPI QueryDosDeviceW( LPCWSTR devname, LPWSTR target, DWORD bufsize )
 DWORD WINAPI DECLSPEC_HOTPATCH GetLogicalDrives(void)
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nt_name;
+    UNICODE_STRING nt_name = RTL_CONSTANT_STRING( L"\\DosDevices\\" );
     DWORD bitmask = 0;
     NTSTATUS status;
     HANDLE handle;
 
-    RtlInitUnicodeString( &nt_name, L"\\DosDevices\\" );
     nt_name.Length -= sizeof(WCHAR);  /* without trailing slash */
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
diff --git a/dlls/krnl386.exe16/relay.c b/dlls/krnl386.exe16/relay.c
index 1532df52676..8b53f6bfd05 100644
--- a/dlls/krnl386.exe16/relay.c
+++ b/dlls/krnl386.exe16/relay.c
@@ -85,27 +85,23 @@ static const char **build_list( const WCHAR *buffer )
 void RELAY16_InitDebugLists(void)
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING name;
     char buffer[1024];
     HANDLE root, hkey;
     DWORD count;
     WCHAR *str;
-    static const WCHAR configW[] = {'S','o','f','t','w','a','r','e','\\',
-                                    'W','i','n','e','\\',
-                                    'D','e','b','u','g',0};
-    static const WCHAR RelayIncludeW[] = {'R','e','l','a','y','I','n','c','l','u','d','e',0};
-    static const WCHAR RelayExcludeW[] = {'R','e','l','a','y','E','x','c','l','u','d','e',0};
-    static const WCHAR SnoopIncludeW[] = {'S','n','o','o','p','I','n','c','l','u','d','e',0};
-    static const WCHAR SnoopExcludeW[] = {'S','n','o','o','p','E','x','c','l','u','d','e',0};
+    UNICODE_STRING config = RTL_CONSTANT_STRING( L"Software\\Wine\\Debug" );
+    UNICODE_STRING relay_include = RTL_CONSTANT_STRING( L"RelayInclude" );
+    UNICODE_STRING relay_exclude = RTL_CONSTANT_STRING( L"RelayExclude" );
+    UNICODE_STRING snoop_include = RTL_CONSTANT_STRING( L"SnoopInclude" );
+    UNICODE_STRING snoop_exclude = RTL_CONSTANT_STRING( L"SnoopExclude" );
 
     RtlOpenCurrentUser( KEY_READ, &root );
     attr.Length = sizeof(attr);
     attr.RootDirectory = root;
-    attr.ObjectName = &name;
+    attr.ObjectName = &config;
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &name, configW );
 
     /* @@ Wine registry key: HKCU\Software\Wine\Debug */
     if (NtOpenKey( &hkey, KEY_READ, &attr )) hkey = 0;
@@ -113,26 +109,22 @@ void RELAY16_InitDebugLists(void)
     if (!hkey) return;
 
     str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)buffer)->Data;
-    RtlInitUnicodeString( &name, RelayIncludeW );
-    if (!NtQueryValueKey( hkey, &name, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
+    if (!NtQueryValueKey( hkey, &relay_include, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
     {
         debug_relay_includelist = build_list( str );
     }
 
-    RtlInitUnicodeString( &name, RelayExcludeW );
-    if (!NtQueryValueKey( hkey, &name, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
+    if (!NtQueryValueKey( hkey, &relay_exclude, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
     {
         debug_relay_excludelist = build_list( str );
     }
 
-    RtlInitUnicodeString( &name, SnoopIncludeW );
-    if (!NtQueryValueKey( hkey, &name, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
+    if (!NtQueryValueKey( hkey, &snoop_include, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
     {
         debug_snoop_includelist = build_list( str );
     }
 
-    RtlInitUnicodeString( &name, SnoopExcludeW );
-    if (!NtQueryValueKey( hkey, &name, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
+    if (!NtQueryValueKey( hkey, &snoop_exclude, KeyValuePartialInformation, buffer, sizeof(buffer), &count ))
     {
         debug_snoop_excludelist = build_list( str );
     }
diff --git a/dlls/krnl386.exe16/selector.c b/dlls/krnl386.exe16/selector.c
index 7d2984cf777..f0c29c8b10d 100644
--- a/dlls/krnl386.exe16/selector.c
+++ b/dlls/krnl386.exe16/selector.c
@@ -515,7 +515,7 @@ static struct mapls_entry *first_entry;
  *
  * Maps linear pointer to segmented.
  */
-SEGPTR WINAPI MapLS( LPCVOID ptr )
+SEGPTR WINAPI MapLS( void *ptr )
 {
     struct mapls_entry *entry, *free = NULL;
     const void *base;
diff --git a/dlls/krnl386.exe16/thunk.c b/dlls/krnl386.exe16/thunk.c
index 6b289eac65e..27fc14b5810 100644
--- a/dlls/krnl386.exe16/thunk.c
+++ b/dlls/krnl386.exe16/thunk.c
@@ -989,15 +989,7 @@ DWORD WINAPIV SSCall(
 	FARPROC fun,	/* [in] function to call */
 	...		/* [in/out] arguments */
 ) {
-    DWORD i,ret;
-    DWORD *args = ((DWORD *)&fun) + 1;
-
-    TRACE("(%ld,0x%08lx,%p,[",nr,flags,fun);
-    for (i = 0; i < nr/4; i++) TRACE("0x%08lx,",args[i]);
-    TRACE("])\n");
-    ret = call_entry_point( fun, nr / sizeof(DWORD), args );
-    TRACE(" returning %ld ...\n",ret);
-    return ret;
+    return call_entry_point( fun, nr / sizeof(DWORD), (DWORD *)&fun + 1 );
 }
 
 /**********************************************************************
diff --git a/dlls/ktmw32/ktmw32_main.c b/dlls/ktmw32/ktmw32_main.c
index 710683aff36..af9db28530f 100644
--- a/dlls/ktmw32/ktmw32_main.c
+++ b/dlls/ktmw32/ktmw32_main.c
@@ -22,39 +22,59 @@
 
 #include "windef.h"
 #include "winbase.h"
-#include "wine/debug.h"
+#include "winternl.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(ktmw32);
+static inline BOOL set_ntstatus( NTSTATUS status )
+{
+    if (status) RtlSetLastWin32Error( RtlNtStatusToDosError( status ));
+    return !status;
+}
 
+static inline LARGE_INTEGER *get_nt_timeout( LARGE_INTEGER *time, DWORD timeout )
+{
+    if (timeout == INFINITE) return NULL;
+    time->QuadPart = (ULONGLONG)timeout * -10000;
+    return time;
+}
 
 /***********************************************************************
  * CommitTransaction (ktmw32.@)
  */
 BOOL WINAPI CommitTransaction(HANDLE transaction)
 {
-    FIXME("(%p): stub\n", transaction);
-    return TRUE;
+    return set_ntstatus( NtCommitTransaction( transaction, TRUE ));
 }
 
 /***********************************************************************
  * CreateTransaction (ktmw32.@)
  */
-HANDLE WINAPI CreateTransaction(LPSECURITY_ATTRIBUTES pattr, LPGUID pguid, DWORD options,
-                                DWORD level, DWORD flags, DWORD timeout, LPWSTR description)
+HANDLE WINAPI CreateTransaction( SECURITY_ATTRIBUTES *sa, GUID *guid, DWORD options, DWORD level, DWORD flags,
+        DWORD timeout, WCHAR *desc )
 {
+    ULONG obj_flags = OBJ_CASE_INSENSITIVE;
+    UNICODE_STRING desc_str;
+    OBJECT_ATTRIBUTES attr;
+    LARGE_INTEGER time;
+    HANDLE handle;
+
+    if (sa && sa->bInheritHandle) obj_flags |= OBJ_INHERIT;
+    InitializeObjectAttributes( &attr, NULL, obj_flags, 0, sa ? sa->lpSecurityDescriptor : NULL );
+
+    RtlInitUnicodeString( &desc_str, desc );
 
-    FIXME("(%p %p 0x%lx 0x%lx 0x%lx, %lu, %s): stub\n",
-            pattr, pguid, options, level, flags, timeout, debugstr_w(description));
+    if (!set_ntstatus( NtCreateTransaction( &handle, 0 /* FIXME */, &attr, guid, NULL, options, level, flags,
+            get_nt_timeout( &time, timeout ), &desc_str )))
+    {
+        return INVALID_HANDLE_VALUE;
+    }
 
-    return (HANDLE) 1;
+    return handle;
 }
 
 /***********************************************************************
- * Rollback Transaction (ktmw32.@)
+ * RollbackTransaction (ktmw32.@)
  */
 BOOL WINAPI RollbackTransaction(HANDLE transaction)
 {
-    FIXME("stub: %p\n", transaction);
-    SetLastError(ERROR_ACCESS_DENIED);
-    return FALSE;
+    return set_ntstatus( NtRollbackTransaction( transaction, TRUE ));
 }
diff --git a/dlls/localspl/provider.c b/dlls/localspl/provider.c
index 790d9d64c00..d09ac4420c3 100644
--- a/dlls/localspl/provider.c
+++ b/dlls/localspl/provider.c
@@ -3008,7 +3008,7 @@ static void fill_builtin_form_info( BYTE **base, WCHAR **strings, const struct b
                                     DWORD size, DWORD *used )
 {
     FORM_INFO_2W *info = *(FORM_INFO_2W**)base;
-    DWORD name_len = wcslen( form->name ) + 1, res_len, keyword_len, total_size;
+    DWORD name_len = wcslen( form->name ) + 1, res_len = 0, keyword_len, total_size;
     static const WCHAR dll_name[] = L"localspl.dll";
     const WCHAR *resource;
 
@@ -3697,7 +3697,7 @@ static BOOL WINAPI fpScheduleJob(HANDLE hprinter, DWORD job_id)
     }
 
     port = job->port;
-    if (!port)
+    if (!port || !*port)
         port = printer->info->port;
     TRACE("need to schedule job %ld filename %s to port %s\n", job->id,
             debugstr_w(job->filename), debugstr_w(port));
diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index b2371763150..85baf07d05a 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -3388,8 +3388,9 @@ static void session_request_sample(struct media_session *session, IMFStreamSink
         return;
     }
 
-    if (SUCCEEDED(session_request_sample_from_node(session, upstream_node, upstream_output)))
-        sink_node->u.sink.requests++;
+    sink_node->u.sink.requests++;
+    if (FAILED(session_request_sample_from_node(session, upstream_node, upstream_output)))
+        sink_node->u.sink.requests--;
     IMFTopologyNode_Release(upstream_node);
 }
 
diff --git a/dlls/mf/tests/transform.c b/dlls/mf/tests/transform.c
index 3c068aae743..7d217dfe8c0 100644
--- a/dlls/mf/tests/transform.c
+++ b/dlls/mf/tests/transform.c
@@ -55,6 +55,97 @@ DEFINE_GUID(MFVideoFormat_WMV_Unknown,0x7ce12ca9,0xbfbf,0x43d9,0x9d,0x00,0x82,0x
 
 DEFINE_GUID(mft_output_sample_incomplete,0xffffff,0xffff,0xffff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff);
 
+struct media_buffer
+{
+    IMediaBuffer IMediaBuffer_iface;
+    LONG refcount;
+    DWORD length;
+    DWORD max_length;
+    BYTE data[];
+};
+
+static inline struct media_buffer *impl_from_IMediaBuffer(IMediaBuffer *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_buffer, IMediaBuffer_iface);
+}
+
+static HRESULT WINAPI media_buffer_QueryInterface(IMediaBuffer *iface, REFIID iid, void **obj)
+{
+    if (IsEqualIID(iid, &IID_IMediaBuffer)
+            || IsEqualIID(iid, &IID_IUnknown))
+    {
+        *obj = iface;
+        return S_OK;
+    }
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI media_buffer_AddRef(IMediaBuffer *iface)
+{
+    struct media_buffer *buffer = impl_from_IMediaBuffer(iface);
+    return InterlockedIncrement(&buffer->refcount);
+}
+
+static ULONG WINAPI media_buffer_Release(IMediaBuffer *iface)
+{
+    struct media_buffer *buffer = impl_from_IMediaBuffer(iface);
+    ULONG ref = InterlockedDecrement(&buffer->refcount);
+    if (!ref)
+        free(buffer);
+    return ref;
+}
+
+static HRESULT WINAPI media_buffer_SetLength(IMediaBuffer *iface, DWORD length)
+{
+    struct media_buffer *buffer = impl_from_IMediaBuffer(iface);
+    if (length > buffer->max_length)
+        return E_INVALIDARG;
+    buffer->length = length;
+    return S_OK;
+}
+
+static HRESULT WINAPI media_buffer_GetMaxLength(IMediaBuffer *iface, DWORD *max_length)
+{
+    struct media_buffer *buffer = impl_from_IMediaBuffer(iface);
+    if (!max_length)
+        return E_POINTER;
+    *max_length = buffer->max_length;
+    return S_OK;
+}
+
+static HRESULT WINAPI media_buffer_GetBufferAndLength(IMediaBuffer *iface, BYTE **data, DWORD *length)
+{
+    struct media_buffer *buffer = impl_from_IMediaBuffer(iface);
+    if (!data || ! length)
+        return E_POINTER;
+    *data = buffer->data;
+    *length = buffer->length;
+    return S_OK;
+}
+
+static IMediaBufferVtbl media_buffer_vtbl = {
+    media_buffer_QueryInterface,
+    media_buffer_AddRef,
+    media_buffer_Release,
+    media_buffer_SetLength,
+    media_buffer_GetMaxLength,
+    media_buffer_GetBufferAndLength,
+};
+
+HRESULT media_buffer_create(DWORD max_length, struct media_buffer **ret)
+{
+    struct media_buffer *buffer;
+
+    if (!(buffer = calloc(1, offsetof(struct media_buffer, data[max_length]))))
+        return E_OUTOFMEMORY;
+    buffer->IMediaBuffer_iface.lpVtbl = &media_buffer_vtbl;
+    buffer->refcount = 1;
+    buffer->length = 0;
+    buffer->max_length = max_length;
+    *ret = buffer;
+    return S_OK;
+}
+
 static BOOL is_compressed_subtype(const GUID *subtype)
 {
     if (IsEqualGUID(subtype, &MEDIASUBTYPE_WMV1)
@@ -327,11 +418,14 @@ static void init_dmo_media_type_video(DMO_MEDIA_TYPE *media_type,
 {
     VIDEOINFOHEADER *header = (VIDEOINFOHEADER *)(media_type + 1);
     BOOL compressed = is_compressed_subtype(subtype);
+    ULONG codec_data_size = compressed ? 4 : 0;
+
+    memset(media_type, 0, sizeof(*media_type) + sizeof(*header) + codec_data_size);
 
-    memset(header, 0, sizeof(*header));
     header->bmiHeader.biSize = sizeof(header->bmiHeader);
     header->bmiHeader.biWidth = width;
     header->bmiHeader.biHeight = height;
+    header->bmiHeader.biPlanes = 1;
     header->bmiHeader.biBitCount = subtype_to_bpp(subtype);
     header->bmiHeader.biCompression = subtype_to_compression(subtype);
 
@@ -342,7 +436,7 @@ static void init_dmo_media_type_video(DMO_MEDIA_TYPE *media_type,
     media_type->lSampleSize = 0;
     media_type->formattype = FORMAT_VideoInfo;
     media_type->pUnk = NULL;
-    media_type->cbFormat = sizeof(*header) + 4; /* 4 bytes codec data. */
+    media_type->cbFormat = sizeof(*header) + codec_data_size;
     media_type->pbFormat = (BYTE *)header;
 }
 
@@ -1178,9 +1272,11 @@ static void check_video_info_header_(int line, VIDEOINFOHEADER *info, const VIDE
     ok_(__FILE__, line)(info->bmiHeader.biYPelsPerMeter == expected->bmiHeader.biYPelsPerMeter,
             "Got unexpected bmiHeader.xxxxxx %ld, expected %ld.\n",
             info->bmiHeader.biYPelsPerMeter, expected->bmiHeader.biYPelsPerMeter);
+    todo_wine_if(expected->bmiHeader.biClrUsed != 0)
     ok_(__FILE__, line)(info->bmiHeader.biClrUsed == expected->bmiHeader.biClrUsed,
             "Got unexpected bmiHeader.biClrUsed %lu, expected %lu.\n",
             info->bmiHeader.biClrUsed, expected->bmiHeader.biClrUsed);
+    todo_wine_if(expected->bmiHeader.biClrImportant != 0)
     ok_(__FILE__, line)(info->bmiHeader.biClrImportant == expected->bmiHeader.biClrImportant,
             "Got unexpected bmiHeader.biClrImportant %lu, expected %lu.\n",
             info->bmiHeader.biClrImportant, expected->bmiHeader.biClrImportant);
@@ -1208,6 +1304,7 @@ static void check_dmo_media_type_(int line, DMO_MEDIA_TYPE *media_type, const DM
             "Got unexpected formattype %s.\n",
             debugstr_guid(&media_type->formattype));
     ok_(__FILE__, line)(media_type->pUnk == NULL, "Got unexpected pUnk %p.\n", media_type->pUnk);
+    todo_wine_if(expected->cbFormat && expected->cbFormat != sizeof(VIDEOINFOHEADER))
     ok_(__FILE__, line)(media_type->cbFormat == expected->cbFormat,
             "Got unexpected cbFormat %lu, expected %lu.\n",
             media_type->cbFormat, expected->cbFormat);
@@ -1320,11 +1417,11 @@ static void check_dmo_set_input_type(IMediaObject *media_object, const GUID *sub
     {
         flag = flags[i];
         hr = IMediaObject_SetInputType(media_object, 1, NULL, flag);
-        ok(hr == DMO_E_INVALIDSTREAMINDEX, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+        ok(hr == DMO_E_INVALIDSTREAMINDEX, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
         hr = IMediaObject_SetInputType(media_object, 1, &bad_media_type, flag);
-        ok(hr == DMO_E_INVALIDSTREAMINDEX, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+        ok(hr == DMO_E_INVALIDSTREAMINDEX, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
         hr = IMediaObject_SetInputType(media_object, 1, good_media_type, flag);
-        ok(hr == DMO_E_INVALIDSTREAMINDEX, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+        ok(hr == DMO_E_INVALIDSTREAMINDEX, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
     }
 
     /* Test unaccepted type. */
@@ -1334,10 +1431,10 @@ static void check_dmo_set_input_type(IMediaObject *media_object, const GUID *sub
         if (!(flag & DMO_SET_TYPEF_CLEAR))
         {
             hr = IMediaObject_SetInputType(media_object, 0, NULL, flag);
-            ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+            ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
         }
         hr = IMediaObject_SetInputType(media_object, 0, &bad_media_type, flag);
-        ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+        ok(hr == DMO_E_TYPE_NOT_ACCEPTED, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
     }
 
     /* Test clearing the type. */
@@ -1345,7 +1442,7 @@ static void check_dmo_set_input_type(IMediaObject *media_object, const GUID *sub
     {
         flag = DMO_SET_TYPEF_CLEAR | flags[i];
         hr = IMediaObject_SetInputType(media_object, 0, NULL, flag);
-        ok(hr == S_OK, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+        ok(hr == S_OK, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
     }
 
     /* Test accepted type. */
@@ -1353,7 +1450,7 @@ static void check_dmo_set_input_type(IMediaObject *media_object, const GUID *sub
     {
         flag = flags[i];
         hr = IMediaObject_SetInputType(media_object, 0, good_media_type, flag);
-        ok(hr == S_OK, "SetInputType returned %#lx for flag %#lx.", hr, flag);
+        ok(hr == S_OK, "SetInputType returned %#lx for flag %#lx.\n", hr, flag);
     }
 
     /* Test unconsidered header member.*/
@@ -1520,6 +1617,49 @@ static void check_dmo_set_output_type(IMediaObject *media_object, const GUID *su
     }
 }
 
+#define check_dmo_output_data_buffer(a, b, c) check_dmo_output_data_buffer_(__LINE__, a, b, c)
+static DWORD check_dmo_output_data_buffer_(int line, DMO_OUTPUT_DATA_BUFFER *output_data_buffer,
+        const struct sample_desc *sample_desc, const WCHAR *expect_data_filename)
+{
+    const struct buffer_desc *buffer_desc = &sample_desc->buffers[0];
+    DWORD diff, data_length, buffer_length, expect_length;
+    BYTE *data, *buffer;
+    HRESULT hr;
+
+    if (output_data_buffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_TIME)
+        ok_(__FILE__, line)(output_data_buffer->rtTimestamp == sample_desc->sample_time,
+                "Unexpected time %I64d, expected %I64d.\n",
+                output_data_buffer->rtTimestamp, sample_desc->sample_time);
+    if (output_data_buffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH)
+        ok_(__FILE__, line)(output_data_buffer->rtTimelength == sample_desc->sample_duration,
+                "Unexpected duration %I64d, expected %I64d.\n",
+                output_data_buffer->rtTimelength, sample_desc->sample_duration);
+
+    load_resource(expect_data_filename, (const BYTE **)&data, &data_length);
+
+    expect_length = buffer_desc->length;
+    if (expect_length == -1)
+    {
+        expect_length = *(DWORD *)data;
+        data += sizeof(DWORD);
+        data_length = data_length - sizeof(DWORD);
+    }
+
+    hr = IMediaBuffer_GetBufferAndLength(output_data_buffer->pBuffer, &buffer, &buffer_length);
+    ok(hr == S_OK, "GetBufferAndLength returned %#lx.\n", hr);
+    ok_(__FILE__, line)(buffer_length == expect_length, "Unexpected length %#lx, expected %#lx\n", buffer_length, expect_length);
+
+    diff = 0;
+    if (data_length < buffer_length)
+        ok_(__FILE__, line)(0, "Missing %#lx bytes\n", buffer_length - data_length);
+    else if (!buffer_desc->compare)
+        diff = compare_bytes(buffer, &buffer_length, NULL, data);
+    else
+        diff = buffer_desc->compare(buffer, &buffer_length, &buffer_desc->rect, data);
+
+    return diff;
+}
+
 
 static HRESULT WINAPI test_unk_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
 {
@@ -2220,7 +2360,7 @@ failed:
     CoUninitialize();
 }
 
-static void test_aac_decoder(void)
+static void test_aac_decoder_subtype(const struct attribute_desc *input_type_desc)
 {
     const GUID *const class_id = &CLSID_MSAACDecMFT;
     const struct transform_info expect_mft_info =
@@ -2310,19 +2450,6 @@ static void test_aac_decoder(void)
         /* more AAC decoder specific attributes from CODECAPI */
         {0},
     };
-    const struct attribute_desc input_type_desc[] =
-    {
-        ATTR_GUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio, .required = TRUE),
-        ATTR_GUID(MF_MT_SUBTYPE, MFAudioFormat_AAC, .required = TRUE),
-        ATTR_UINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, 44100, .required = TRUE),
-        ATTR_BLOB(MF_MT_USER_DATA, aac_codec_data, sizeof(aac_codec_data), .required = TRUE),
-        ATTR_UINT32(MF_MT_AUDIO_BITS_PER_SAMPLE, 16),
-        ATTR_UINT32(MF_MT_AUDIO_NUM_CHANNELS, 1),
-        ATTR_UINT32(MF_MT_AUDIO_AVG_BYTES_PER_SECOND, 12000),
-        ATTR_UINT32(MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION, 41),
-        ATTR_UINT32(MF_MT_AAC_PAYLOAD_TYPE, 0),
-        {0},
-    };
     static const struct attribute_desc output_type_desc[] =
     {
         ATTR_GUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio, .required = TRUE),
@@ -2370,6 +2497,7 @@ static void test_aac_decoder(void)
     IMFMediaType *media_type;
     IMFTransform *transform;
     const BYTE *aacenc_data;
+    DWORD flags;
     HRESULT hr;
 
     hr = CoInitialize(NULL);
@@ -2449,10 +2577,23 @@ static void test_aac_decoder(void)
     ok(aacenc_data_len == 24861, "got length %lu\n", aacenc_data_len);
 
     input_sample = create_sample(aacenc_data + sizeof(DWORD), *(DWORD *)aacenc_data);
+
+    flags = 0;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(flags == MFT_INPUT_STATUS_ACCEPT_DATA, "Got flags %#lx.\n", flags);
     hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
     ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
+    flags = 0xdeadbeef;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(!flags, "Got flags %#lx.\n", flags);
     hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
     ok(hr == MF_E_NOTACCEPTING, "ProcessInput returned %#lx\n", hr);
+    flags = 0xdeadbeef;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(!flags, "Got flags %#lx.\n", flags);
 
     /* As output_info.dwFlags doesn't have MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES
      * IMFTransform_ProcessOutput needs a sample or returns MF_E_TRANSFORM_NEED_MORE_INPUT */
@@ -2460,11 +2601,19 @@ static void test_aac_decoder(void)
     hr = check_mft_process_output(transform, NULL, &output_status);
     ok(hr == E_INVALIDARG, "ProcessOutput returned %#lx\n", hr);
     ok(output_status == 0, "got output[0].dwStatus %#lx\n", output_status);
+    flags = 0xdeadbeef;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(!flags, "Got flags %#lx.\n", flags);
     hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
     ok(hr == MF_E_NOTACCEPTING, "ProcessInput returned %#lx\n", hr);
 
     hr = IMFTransform_ProcessMessage(transform, MFT_MESSAGE_COMMAND_DRAIN, 0);
     ok(hr == S_OK, "ProcessMessage returned %#lx\n", hr);
+    flags = 0xdeadbeef;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(!flags, "Got flags %#lx.\n", flags);
     hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
     ok(hr == MF_E_NOTACCEPTING, "ProcessInput returned %#lx\n", hr);
 
@@ -2484,6 +2633,12 @@ static void test_aac_decoder(void)
         winetest_pop_context();
     }
     ok(hr == MF_E_TRANSFORM_NEED_MORE_INPUT, "ProcessOutput returned %#lx\n", hr);
+
+    flags = 0;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(flags == MFT_INPUT_STATUS_ACCEPT_DATA, "Got flags %#lx.\n", flags);
+
     ok(output_status == MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE, "got output[0].dwStatus %#lx\n", output_status);
     ret = IMFSample_Release(output_sample);
     ok(ret == 0, "Release returned %lu\n", ret);
@@ -2514,6 +2669,36 @@ failed:
     CoUninitialize();
 }
 
+static void test_aac_decoder(void)
+{
+    static const BYTE aac_raw_codec_data[] = {0x12, 0x08};
+    static const struct attribute_desc raw_aac_input_type_desc[] =
+    {
+        ATTR_GUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio, .required = TRUE),
+        ATTR_GUID(MF_MT_SUBTYPE, MFAudioFormat_RAW_AAC1, .required = TRUE),
+        ATTR_UINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, 44100, .required = TRUE),
+        ATTR_UINT32(MF_MT_AUDIO_NUM_CHANNELS, 1),
+        ATTR_BLOB(MF_MT_USER_DATA, aac_raw_codec_data, sizeof(aac_raw_codec_data), .required = TRUE),
+        {0},
+    };
+    static const struct attribute_desc aac_input_type_desc[] =
+    {
+        ATTR_GUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio, .required = TRUE),
+        ATTR_GUID(MF_MT_SUBTYPE, MFAudioFormat_AAC, .required = TRUE),
+        ATTR_UINT32(MF_MT_AUDIO_SAMPLES_PER_SECOND, 44100, .required = TRUE),
+        ATTR_BLOB(MF_MT_USER_DATA, aac_codec_data, sizeof(aac_codec_data), .required = TRUE),
+        ATTR_UINT32(MF_MT_AUDIO_BITS_PER_SAMPLE, 16),
+        ATTR_UINT32(MF_MT_AUDIO_NUM_CHANNELS, 1),
+        ATTR_UINT32(MF_MT_AUDIO_AVG_BYTES_PER_SECOND, 12000),
+        ATTR_UINT32(MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION, 41),
+        ATTR_UINT32(MF_MT_AAC_PAYLOAD_TYPE, 0),
+        {0},
+    };
+
+    test_aac_decoder_subtype(aac_input_type_desc);
+    test_aac_decoder_subtype(raw_aac_input_type_desc);
+}
+
 static const BYTE wma_codec_data[10] = {0, 0x44, 0, 0, 0x17, 0, 0, 0, 0, 0};
 static const ULONG wmaenc_block_size = 1487;
 static const ULONG wmadec_block_size = 0x2000;
@@ -3224,7 +3409,7 @@ static void test_h264_decoder(void)
     {
         ATTR_UINT32(MF_LOW_LATENCY, 0),
         ATTR_UINT32(MF_SA_D3D_AWARE, 1, .todo = TRUE),
-        ATTR_UINT32(MF_SA_D3D11_AWARE, 1, .todo = TRUE),
+        ATTR_UINT32(MF_SA_D3D11_AWARE, 1),
         ATTR_UINT32(MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER, 0, .todo = TRUE),
         /* more H264 decoder specific attributes from CODECAPI */
         {0},
@@ -3502,6 +3687,7 @@ static void test_h264_decoder(void)
     IMFMediaType *media_type;
     IMFTransform *transform;
     ULONG i, ret, ref;
+    DWORD flags;
     HRESULT hr;
 
     hr = CoInitialize(NULL);
@@ -3538,6 +3724,11 @@ static void test_h264_decoder(void)
     hr = IMFTransform_GetOutputAvailableType(transform, 0, 0, &media_type);
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetOutputAvailableType returned %#lx\n", hr);
 
+    flags = 0xdeadbeef;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "Got %#lx\n", hr);
+    ok(flags == 0xdeadbeef, "Got flags %#lx.\n", flags);
+
     /* setting output media type first doesn't work */
     check_mft_set_output_type(transform, output_type_desc, MF_E_TRANSFORM_TYPE_NOT_SET);
     check_mft_get_output_current_type(transform, NULL);
@@ -3626,12 +3817,20 @@ static void test_h264_decoder(void)
         ret = IMFSample_Release(output_sample);
         ok(ret == 0, "Release returned %lu\n", ret);
 
+        flags = 0;
+        hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+        ok(hr == S_OK, "Got %#lx\n", hr);
+        ok(flags == MFT_INPUT_STATUS_ACCEPT_DATA, "Got flags %#lx.\n", flags);
         hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
         ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
         ret = IMFSample_Release(input_sample);
         ok(ret <= 1, "Release returned %lu\n", ret);
         input_sample = next_h264_sample(&h264_encoded_data, &h264_encoded_data_len);
 
+        flags = 0;
+        hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+        ok(hr == S_OK, "Got %#lx\n", hr);
+        ok(flags == MFT_INPUT_STATUS_ACCEPT_DATA, "Got flags %#lx.\n", flags);
         hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
         ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
         ret = IMFSample_Release(input_sample);
@@ -3754,6 +3953,23 @@ static void test_h264_decoder(void)
     ret = IMFSample_Release(output_sample);
     ok(ret == 0, "Release returned %lu\n", ret);
 
+    do
+    {
+        flags = 0;
+        hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+        ok(hr == S_OK, "Got %#lx\n", hr);
+        ok(flags == MFT_INPUT_STATUS_ACCEPT_DATA, "Got flags %#lx.\n", flags);
+        hr = IMFTransform_ProcessInput(transform, 0, input_sample, 0);
+        ok(hr == S_OK || hr == MF_E_NOTACCEPTING, "Got %#lx\n", hr);
+        input_sample = next_h264_sample(&h264_encoded_data, &h264_encoded_data_len);
+    } while (hr == S_OK);
+
+    ok(hr == MF_E_NOTACCEPTING, "Got %#lx\n", hr);
+    flags = 0;
+    hr = IMFTransform_GetInputStatus(transform, 0, &flags);
+    ok(hr == S_OK, "Got %#lx\n", hr);
+    ok(flags == MFT_INPUT_STATUS_ACCEPT_DATA, "Got flags %#lx.\n", flags);
+
     ret = IMFTransform_Release(transform);
     ok(ret == 0, "Release returned %lu\n", ret);
     ret = IMFSample_Release(input_sample);
@@ -4996,11 +5212,26 @@ static void test_wmv_decoder_media_object(void)
         {MFMediaType_Video, MEDIASUBTYPE_RGB555, TRUE, FALSE, 512,  FORMAT_VideoInfo, NULL, 88,   (BYTE *)&expected_output_info[11]},
         {MFMediaType_Video, MEDIASUBTYPE_RGB8,   TRUE, FALSE, 256,  FORMAT_VideoInfo, NULL, 1112, (BYTE *)&expected_output_info[12]},
     };
-    DMO_MEDIA_TYPE media_type, *input_type;
+    const DWORD data_width = 96, data_height = 96;
+    const POINT test_size[] = {{16, 16}, {96, 96}, {320, 240}};
+    const struct buffer_desc output_buffer_desc_nv12 =
+    {
+        .length = data_width * data_height * 3 / 2,
+        .compare = compare_nv12, .dump = dump_nv12, .rect = {.right = 82, .bottom = 84},
+    };
+    const struct sample_desc output_sample_desc_nv12 =
+    {
+        .sample_time = 0, .sample_duration = 333333,
+        .buffer_count = 1, .buffers = &output_buffer_desc_nv12,
+    };
+    DWORD in_count, out_count, size, expected_size, alignment, wmv_data_length, status, expected_status, diff;
+    struct media_buffer *input_media_buffer = NULL, *output_media_buffer = NULL;
+    DMO_OUTPUT_DATA_BUFFER output_data_buffer;
+    DMO_MEDIA_TYPE media_type, *type;
     IMediaObject *media_object;
-    DWORD in_count, out_count;
+    const BYTE *wmv_data;
     char buffer[1024];
-    ULONG ret, i;
+    ULONG ret, i, j;
     HRESULT hr;
 
     winetest_push_context("wmvdec");
@@ -5012,7 +5243,7 @@ static void test_wmv_decoder_media_object(void)
         return;
     }
 
-    input_type = (DMO_MEDIA_TYPE *)buffer;
+    type = (DMO_MEDIA_TYPE *)buffer;
 
     hr = CoInitialize(NULL);
     ok(hr == S_OK, "CoInitialize failed, hr %#lx.\n", hr);
@@ -5062,30 +5293,112 @@ static void test_wmv_decoder_media_object(void)
     hr = IMediaObject_SetInputType(media_object, 0, NULL, DMO_SET_TYPEF_CLEAR);
     ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
     hr = IMediaObject_GetOutputType(media_object, 0, 0, &media_type);
-    todo_wine
     ok(hr == DMO_E_TYPE_NOT_SET, "GetOutputType returned %#lx.\n", hr);
 
     /* Test GetOutputType after setting input type. */
-    init_dmo_media_type_video(input_type, &expected_input_types[0].subtype, 16, 16);
-    hr = IMediaObject_SetInputType(media_object, 0, input_type, 0);
+    init_dmo_media_type_video(type, &expected_input_types[0].subtype, 16, 16);
+    hr = IMediaObject_SetInputType(media_object, 0, type, 0);
     ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
-    todo_wine
     check_dmo_get_output_type(media_object, expected_output_types, ARRAY_SIZE(expected_output_types));
 
     /* Test SetOutputType without setting input type. */
     hr = IMediaObject_SetInputType(media_object, 0, NULL, DMO_SET_TYPEF_CLEAR);
     ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
     hr = IMediaObject_SetOutputType(media_object, 0, &media_type, 0);
-    todo_wine
     ok(hr == DMO_E_TYPE_NOT_SET, "SetOutputType returned %#lx.\n", hr);
 
     /* Test SetOutputType after setting input type. */
-    init_dmo_media_type_video(input_type, &expected_input_types[0].subtype, 16, 16);
-    hr = IMediaObject_SetInputType(media_object, 0, input_type, 0);
+    init_dmo_media_type_video(type, &expected_input_types[0].subtype, 16, 16);
+    hr = IMediaObject_SetInputType(media_object, 0, type, 0);
     ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
-    todo_wine
     check_dmo_set_output_type(media_object, &MEDIASUBTYPE_RGB24);
 
+    /* Test GetOutputSizeInfo. */
+    hr = IMediaObject_SetOutputType(media_object, 0, NULL, DMO_SET_TYPEF_CLEAR);
+    ok(hr == S_OK, "SetOutputType returned %#lx.\n", hr);
+    hr = IMediaObject_GetOutputSizeInfo(media_object, 0, &size, &alignment);
+    ok(hr == DMO_E_TYPE_NOT_SET, "GetOutputSizeInfo returned %#lx.\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(expected_output_types); ++i)
+    {
+        const GUID *subtype = &expected_output_types[i].subtype;
+        if (IsEqualGUID(subtype, &MEDIASUBTYPE_RGB565)
+                || IsEqualGUID(subtype, &MEDIASUBTYPE_RGB8))
+        {
+            skip("Skipping GetOutputSizeInfo tests for video subtype %s.\n", debugstr_guid(subtype));
+            continue;
+        }
+
+        winetest_push_context("out %lu", i);
+        for (j = 0; j < ARRAY_SIZE(test_size); ++j)
+        {
+            init_dmo_media_type_video(type, &expected_output_types[i].subtype, test_size[j].x, test_size[j].y);
+            hr = IMediaObject_SetOutputType(media_object, 0, type, 0);
+            todo_wine_if(IsEqualGUID(subtype, &MEDIASUBTYPE_NV11)
+                    || IsEqualGUID(subtype, &MEDIASUBTYPE_IYUV))
+            ok(hr == S_OK, "SetOutputType returned %#lx.\n", hr);
+            if (hr != S_OK)
+                continue;
+
+            size = 0xdeadbeef;
+            alignment = 0xdeadbeef;
+            hr = MFCalculateImageSize(subtype, test_size[j].x, test_size[j].y, (UINT32 *)&expected_size);
+            ok(hr == S_OK, "MFCalculateImageSize returned %#lx.\n", hr);
+
+            hr = IMediaObject_GetOutputSizeInfo(media_object, 0, &size, &alignment);
+            ok(hr == S_OK, "GetOutputSizeInfo returned %#lx.\n", hr);
+            ok(size == expected_size, "Got unexpected size %lu, expected %lu.\n", size, expected_size);
+            ok(alignment == 1, "Got unexpected alignment %lu.\n", alignment);
+        }
+        winetest_pop_context();
+    }
+
+    /* Test ProcessInput. */
+    load_resource(L"wmvencdata.bin", &wmv_data, &wmv_data_length);
+    wmv_data_length = *((DWORD *)wmv_data);
+    wmv_data += sizeof(DWORD);
+    hr = media_buffer_create(wmv_data_length, &input_media_buffer);
+    ok(hr == S_OK, "Failed to create input media buffer.\n");
+    memcpy(input_media_buffer->data, wmv_data, wmv_data_length);
+    input_media_buffer->length = wmv_data_length;
+
+    init_dmo_media_type_video(type, &MEDIASUBTYPE_WMV1, data_width, data_height);
+    hr = IMediaObject_SetInputType(media_object, 0, type, 0);
+    ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
+    init_dmo_media_type_video(type, &MEDIASUBTYPE_NV12, data_width, data_height);
+    hr = IMediaObject_SetOutputType(media_object, 0, type, 0);
+    ok(hr == S_OK, "SetOutputType returned %#lx.\n", hr);
+
+    hr = IMediaObject_ProcessInput(media_object, 0, &input_media_buffer->IMediaBuffer_iface, 0, 0, 333333);
+    todo_wine
+    ok(hr == S_OK, "ProcessInput returned %#lx.\n", hr);
+
+    /* Test ProcessOutput. */
+    hr = IMediaObject_GetOutputSizeInfo(media_object, 0, &size, &alignment);
+    ok(hr == S_OK, "GetOutputSizeInfo returned %#lx.\n", hr);
+    hr = media_buffer_create(size, &output_media_buffer);
+    ok(hr == S_OK, "Failed to create output media buffer.\n");
+    output_data_buffer.pBuffer = &output_media_buffer->IMediaBuffer_iface;
+    output_data_buffer.dwStatus = 0xdeadbeef;
+    output_data_buffer.rtTimestamp = 0xdeadbeef;
+    output_data_buffer.rtTimelength = 0xdeadbeef;
+    hr = IMediaObject_ProcessOutput(media_object, 0, 1, &output_data_buffer, &status);
+    todo_wine
+    ok(hr == S_OK, "ProcessOutput returned %#lx.\n", hr);
+    expected_status = DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT | DMO_OUTPUT_DATA_BUFFERF_TIME | DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
+    todo_wine
+    ok(output_data_buffer.dwStatus == expected_status, "Got unexpected dwStatus %#lx.\n", output_data_buffer.dwStatus);
+    if (hr == S_OK)
+    {
+    diff = check_dmo_output_data_buffer(&output_data_buffer, &output_sample_desc_nv12, L"nv12frame.bmp");
+    ok(diff == 0, "Got %lu%% diff.\n", diff);
+    }
+
+    ret = IMediaBuffer_Release(&output_media_buffer->IMediaBuffer_iface);
+    ok(ret == 0, "Release returned %lu\n", ret);
+    ret = IMediaBuffer_Release(&input_media_buffer->IMediaBuffer_iface);
+    ok(ret == 0, "Release returned %lu\n", ret);
+
     ret = IMediaObject_Release(media_object);
     ok(ret == 0, "Release returned %lu\n", ret);
     CoUninitialize();
@@ -5752,8 +6065,8 @@ static void test_video_processor(void)
                 && !IsEqualGUID(&guid, &MEDIASUBTYPE_Y42T))
         {
             hr = MFCalculateImageSize(&guid, 16, 16, (UINT32 *)&input_info.cbSize);
-            todo_wine_if(IsEqualGUID(&guid, &MFVideoFormat_NV11) || IsEqualGUID(&guid, &MFVideoFormat_YVYU)
-                    || IsEqualGUID(&guid, &MFVideoFormat_Y216) || IsEqualGUID(&guid, &MFVideoFormat_v410)
+            todo_wine_if(IsEqualGUID(&guid, &MFVideoFormat_Y216)
+                    || IsEqualGUID(&guid, &MFVideoFormat_v410)
                     || IsEqualGUID(&guid, &MFVideoFormat_Y41P))
             ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
         }
diff --git a/dlls/mfplat/buffer.c b/dlls/mfplat/buffer.c
index e3d38438b88..a221c6d55b8 100644
--- a/dlls/mfplat/buffer.c
+++ b/dlls/mfplat/buffer.c
@@ -1357,6 +1357,7 @@ static HRESULT create_2d_buffer(DWORD width, DWORD height, DWORD fourcc, BOOL bo
             break;
         case MAKEFOURCC('I','M','C','2'):
         case MAKEFOURCC('I','M','C','4'):
+        case MAKEFOURCC('N','V','1','1'):
             plane_size = stride * 3 / 2 * height;
             break;
         case MAKEFOURCC('N','V','1','2'):
@@ -1379,6 +1380,7 @@ static HRESULT create_2d_buffer(DWORD width, DWORD height, DWORD fourcc, BOOL bo
         case MAKEFOURCC('I','M','C','3'):
         case MAKEFOURCC('I','M','C','4'):
         case MAKEFOURCC('Y','V','1','2'):
+        case MAKEFOURCC('N','V','1','1'):
             row_alignment = MF_128_BYTE_ALIGNMENT;
             break;
         default:
@@ -1397,6 +1399,7 @@ static HRESULT create_2d_buffer(DWORD width, DWORD height, DWORD fourcc, BOOL bo
         case MAKEFOURCC('Y','V','1','2'):
         case MAKEFOURCC('I','M','C','2'):
         case MAKEFOURCC('I','M','C','4'):
+        case MAKEFOURCC('N','V','1','1'):
             max_length = pitch * height * 3 / 2;
             break;
         default:
diff --git a/dlls/mfplat/mediatype.c b/dlls/mfplat/mediatype.c
index c1c8d0048c3..245922ba068 100644
--- a/dlls/mfplat/mediatype.c
+++ b/dlls/mfplat/mediatype.c
@@ -2631,7 +2631,7 @@ static int __cdecl uncompressed_video_format_compare(const void *a, const void *
 
 static const struct uncompressed_video_format video_formats[] =
 {
-    { &MFVideoFormat_RGB24,         4, 3, 1, 0 },
+    { &MFVideoFormat_RGB24,         3, 3, 1, 0 },
     { &MFVideoFormat_ARGB32,        4, 3, 1, 0 },
     { &MFVideoFormat_RGB32,         4, 3, 1, 0 },
     { &MFVideoFormat_RGB565,        2, 3, 1, 0 },
@@ -2646,13 +2646,20 @@ static const struct uncompressed_video_format video_formats[] =
     { &MFVideoFormat_IMC3,          2, 3, 0, 1 },
     { &MFVideoFormat_IMC4,          1, 0, 0, 1 },
     { &MFVideoFormat_IYUV,          1, 0, 0, 1 },
+    { &MFVideoFormat_NV11,          1, 0, 0, 1 },
     { &MFVideoFormat_NV12,          1, 0, 0, 1 },
     { &MFVideoFormat_D16,           2, 3, 0, 0 },
     { &MFVideoFormat_L16,           2, 3, 0, 0 },
     { &MFVideoFormat_UYVY,          2, 0, 0, 1 },
     { &MFVideoFormat_YUY2,          2, 0, 0, 1 },
     { &MFVideoFormat_YV12,          1, 0, 0, 1 },
+    { &MFVideoFormat_YVYU,          2, 0, 0, 1 },
     { &MFVideoFormat_A16B16G16R16F, 8, 3, 1, 0 },
+    { &MEDIASUBTYPE_RGB8,           1, 3, 1, 0 },
+    { &MEDIASUBTYPE_RGB565,         2, 3, 1, 0 },
+    { &MEDIASUBTYPE_RGB555,         2, 3, 1, 0 },
+    { &MEDIASUBTYPE_RGB24,          3, 3, 1, 0 },
+    { &MEDIASUBTYPE_RGB32,          4, 3, 1, 0 },
 };
 
 static struct uncompressed_video_format *mf_get_video_format(const GUID *subtype)
@@ -2732,6 +2739,9 @@ HRESULT WINAPI MFCalculateImageSize(REFGUID subtype, UINT32 width, UINT32 height
             /* 2 x 2 block, interleaving UV for half the height */
             *size = ((width + 1) & ~1) * height * 3 / 2;
             break;
+        case MAKEFOURCC('N','V','1','1'):
+            *size = ((width + 3) & ~3) * height * 3 / 2;
+            break;
         case D3DFMT_L8:
         case D3DFMT_L16:
         case D3DFMT_D16:
@@ -2772,6 +2782,7 @@ HRESULT WINAPI MFGetPlaneSize(DWORD fourcc, DWORD width, DWORD height, DWORD *si
         case MAKEFOURCC('Y','V','1','2'):
         case MAKEFOURCC('I','4','2','0'):
         case MAKEFOURCC('I','Y','U','V'):
+        case MAKEFOURCC('N','V','1','1'):
             *size = stride * height * 3 / 2;
             break;
         default:
diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index f1f61e25d00..33b17b8df41 100644
--- a/dlls/mfplat/tests/mfplat.c
+++ b/dlls/mfplat/tests/mfplat.c
@@ -4390,11 +4390,7 @@ static void test_MFCalculateImageSize(void)
                 IsEqualGUID(ptr->subtype, &MFVideoFormat_A2R10G10B10);
 
         hr = MFCalculateImageSize(ptr->subtype, ptr->width, ptr->height, &size);
-        todo_wine_if(is_MEDIASUBTYPE_RGB(ptr->subtype) || IsEqualGUID(ptr->subtype, &MFVideoFormat_NV11))
         ok(hr == S_OK || (is_broken && hr == E_INVALIDARG), "%u: failed to calculate image size, hr %#lx.\n", i, hr);
-        todo_wine_if(is_MEDIASUBTYPE_RGB(ptr->subtype)
-                || IsEqualGUID(ptr->subtype, &MFVideoFormat_NV11)
-                || (IsEqualGUID(ptr->subtype, &MFVideoFormat_RGB24) && ptr->width % 4 == 0))
         ok(size == ptr->size, "%u: unexpected image size %u, expected %u. Size %u x %u, format %s.\n", i, size, ptr->size,
                 ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->subtype->Data1, 4));
     }
@@ -4426,8 +4422,6 @@ static void test_MFGetPlaneSize(void)
 
         hr = pMFGetPlaneSize(ptr->subtype->Data1, ptr->width, ptr->height, &size);
         ok(hr == S_OK, "%u: failed to get plane size, hr %#lx.\n", i, hr);
-        todo_wine_if(IsEqualGUID(ptr->subtype, &MFVideoFormat_NV11)
-                || (IsEqualGUID(ptr->subtype, &MFVideoFormat_RGB24) && ptr->width % 4 == 0))
         ok(size == plane_size, "%u: unexpected plane size %lu, expected %u. Size %u x %u, format %s.\n", i, size, plane_size,
                 ptr->width, ptr->height, wine_dbgstr_an((char*)&ptr->subtype->Data1, 4));
     }
@@ -5764,9 +5758,7 @@ static void test_MFGetStrideForBitmapInfoHeader(void)
     for (i = 0; i < ARRAY_SIZE(stride_tests); ++i)
     {
         hr = pMFGetStrideForBitmapInfoHeader(stride_tests[i].subtype->Data1, stride_tests[i].width, &stride);
-        todo_wine_if(IsEqualGUID(stride_tests[i].subtype, &MFVideoFormat_NV11))
         ok(hr == S_OK, "%u: failed to get stride, hr %#lx.\n", i, hr);
-        todo_wine_if(IsEqualGUID(stride_tests[i].subtype, &MFVideoFormat_NV11))
         ok(stride == stride_tests[i].stride, "%u: format %s, unexpected stride %ld, expected %ld.\n", i,
                 wine_dbgstr_an((char *)&stride_tests[i].subtype->Data1, 4), stride, stride_tests[i].stride);
     }
@@ -5979,10 +5971,7 @@ static void test_MFCreate2DMediaBuffer(void)
             continue;
 
         hr = pMFCreate2DMediaBuffer(ptr->width, ptr->height, ptr->subtype->Data1, FALSE, &buffer);
-        todo_wine_if(IsEqualGUID(ptr->subtype, &MFVideoFormat_NV11))
         ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
-        if (hr != S_OK)
-            continue;
 
         hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
@@ -5994,13 +5983,11 @@ static void test_MFCreate2DMediaBuffer(void)
 
         hr = IMF2DBuffer_GetContiguousLength(_2dbuffer, &length);
         ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-        todo_wine_if(IsEqualGUID(ptr->subtype, &MFVideoFormat_RGB24) && ptr->width % 4 == 0)
         ok(length == ptr->contiguous_length, "%d: unexpected contiguous length %lu for %u x %u, format %s.\n",
                 i, length, ptr->width, ptr->height, wine_dbgstr_guid(ptr->subtype));
 
         hr = IMFMediaBuffer_Lock(buffer, &data, &length2, NULL);
         ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
-        todo_wine_if(IsEqualGUID(ptr->subtype, &MFVideoFormat_RGB24) && ptr->width % 4 == 0)
         ok(length2 == ptr->contiguous_length, "%d: unexpected linear buffer length %lu for %u x %u, format %s.\n",
                 i, length2, ptr->width, ptr->height, wine_dbgstr_guid(ptr->subtype));
 
@@ -6125,10 +6112,7 @@ static void test_MFCreate2DMediaBuffer(void)
             continue;
 
         hr = pMFCreate2DMediaBuffer(ptr->width, ptr->height, ptr->subtype->Data1, FALSE, &buffer);
-        todo_wine_if(IsEqualGUID(ptr->subtype, &MFVideoFormat_NV11))
         ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
-        if (hr != S_OK)
-            continue;
 
         hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2dbuffer);
         ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
diff --git a/dlls/mfplay/tests/mfplay.c b/dlls/mfplay/tests/mfplay.c
index 6cecd3bbdd9..fa66ccae57e 100644
--- a/dlls/mfplay/tests/mfplay.c
+++ b/dlls/mfplay/tests/mfplay.c
@@ -437,6 +437,75 @@ static void test_media_item(void)
     IMFPMediaPlayer_Release(player);
 }
 
+#define check_media_language(player, resource_name, expected_lang) \
+    _check_media_language(__LINE__, FALSE, player, resource_name, expected_lang)
+#define todo_check_media_language(player, resource_name, expected_lang) \
+    _check_media_language(__LINE__, TRUE, player, resource_name, expected_lang)
+static void _check_media_language(unsigned line, BOOL todo, IMFPMediaPlayer *player,
+                                  const WCHAR *resource_name, const WCHAR *expected_lang)
+{
+    WCHAR *filename;
+    IMFPMediaItem *item;
+    PROPVARIANT propvar;
+    const WCHAR *lang = NULL;
+    HRESULT hr;
+
+    filename = load_resource(resource_name);
+
+    hr = IMFPMediaPlayer_CreateMediaItemFromURL(player, filename, TRUE, 123, &item);
+    ok_(__FILE__, line)(hr == S_OK || broken(hr == MF_E_UNSUPPORTED_BYTESTREAM_TYPE) /* win8 - win10 1507 */,
+                        "Unexpected hr %#lx.\n", hr);
+    if (hr != S_OK)
+    {
+        DeleteFileW(filename);
+        return;
+    }
+
+    hr = IMFPMediaItem_GetStreamAttribute(item, 0, &MF_SD_LANGUAGE, &propvar);
+    ok_(__FILE__, line)(hr == S_OK || hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+
+    if (hr == S_OK)
+    {
+        ok_(__FILE__, line)(propvar.vt == VT_LPWSTR, "Unexpected vt %u.\n", propvar.vt);
+        if (propvar.vt == VT_LPWSTR)
+            lang = propvar.pwszVal;
+    }
+
+    todo_wine_if(todo)
+    {
+        if (expected_lang)
+            ok_(__FILE__, line)(lang && !wcscmp(lang, expected_lang), "Unexpected value %s.\n", debugstr_w(lang));
+        else
+            ok_(__FILE__, line)(!lang, "Unexpected value %s.\n", debugstr_w(lang));
+    }
+
+    PropVariantClear(&propvar);
+    IMFPMediaItem_Release(item);
+    DeleteFileW(filename);
+}
+
+static void test_media_language(void)
+{
+    IMFPMediaPlayer *player;
+    HRESULT hr;
+
+    hr = MFPCreateMediaPlayer(NULL, FALSE, 0, NULL, NULL, &player);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    check_media_language(player, L"test-eng.mp4", L"en");
+    check_media_language(player, L"test-ang.mp4", NULL);
+    check_media_language(player, L"test-und.mp4", NULL);
+    check_media_language(player, L"test-en-US.mp4", L"en");
+
+    check_media_language(player, L"test-en.wma", L"en");
+    check_media_language(player, L"test-eng.wma", L"eng");
+    check_media_language(player, L"test-ang.wma", L"ang");
+    check_media_language(player, L"test-und.wma", L"und");
+    todo_check_media_language(player, L"test-en-US.wma", L"en-US");
+
+    IMFPMediaPlayer_Release(player);
+}
+
 static void test_video_control(void)
 {
     MFVideoNormalizedRect rect;
@@ -599,6 +668,7 @@ START_TEST(mfplay)
     test_create_player();
     test_shutdown();
     test_media_item();
+    test_media_language();
     test_video_control();
     test_duration();
     test_playback_rate();
diff --git a/dlls/mfplay/tests/resource.rc b/dlls/mfplay/tests/resource.rc
index 38c4a5f9e01..bccf60db9ed 100644
--- a/dlls/mfplay/tests/resource.rc
+++ b/dlls/mfplay/tests/resource.rc
@@ -20,3 +20,30 @@
 
 /* @makedep: test.mp4 */
 test.mp4 RCDATA test.mp4
+
+/* @makedep: test-eng.mp4 */
+test-eng.mp4 RCDATA test-eng.mp4
+
+/* @makedep: test-ang.mp4 */
+test-ang.mp4 RCDATA test-ang.mp4
+
+/* @makedep: test-und.mp4 */
+test-und.mp4 RCDATA test-und.mp4
+
+/* @makedep: test-en-US.mp4 */
+test-en-US.mp4 RCDATA test-en-US.mp4
+
+/* @makedep: test-en.wma */
+test-en.wma RCDATA test-en.wma
+
+/* @makedep: test-eng.wma */
+test-eng.wma RCDATA test-eng.wma
+
+/* @makedep: test-ang.wma */
+test-ang.wma RCDATA test-ang.wma
+
+/* @makedep: test-und.wma */
+test-und.wma RCDATA test-und.wma
+
+/* @makedep: test-en-US.wma */
+test-en-US.wma RCDATA test-en-US.wma
diff --git a/dlls/mfplay/tests/test-ang.mp4 b/dlls/mfplay/tests/test-ang.mp4
new file mode 100644
index 00000000000..864e5347eab
Binary files /dev/null and b/dlls/mfplay/tests/test-ang.mp4 differ
diff --git a/dlls/mfplay/tests/test-ang.wma b/dlls/mfplay/tests/test-ang.wma
new file mode 100644
index 00000000000..ab15ca3c5af
Binary files /dev/null and b/dlls/mfplay/tests/test-ang.wma differ
diff --git a/dlls/mfplay/tests/test-en-US.mp4 b/dlls/mfplay/tests/test-en-US.mp4
new file mode 100644
index 00000000000..e023fd5af40
Binary files /dev/null and b/dlls/mfplay/tests/test-en-US.mp4 differ
diff --git a/dlls/mfplay/tests/test-en-US.wma b/dlls/mfplay/tests/test-en-US.wma
new file mode 100644
index 00000000000..61939c4deb5
Binary files /dev/null and b/dlls/mfplay/tests/test-en-US.wma differ
diff --git a/dlls/mfplay/tests/test-en.wma b/dlls/mfplay/tests/test-en.wma
new file mode 100644
index 00000000000..b3a9187785e
Binary files /dev/null and b/dlls/mfplay/tests/test-en.wma differ
diff --git a/dlls/mfplay/tests/test-eng.mp4 b/dlls/mfplay/tests/test-eng.mp4
new file mode 100644
index 00000000000..7be1ad4e0e3
Binary files /dev/null and b/dlls/mfplay/tests/test-eng.mp4 differ
diff --git a/dlls/mfplay/tests/test-eng.wma b/dlls/mfplay/tests/test-eng.wma
new file mode 100644
index 00000000000..730516354e3
Binary files /dev/null and b/dlls/mfplay/tests/test-eng.wma differ
diff --git a/dlls/mfplay/tests/test-und.mp4 b/dlls/mfplay/tests/test-und.mp4
new file mode 100644
index 00000000000..302afb13c72
Binary files /dev/null and b/dlls/mfplay/tests/test-und.mp4 differ
diff --git a/dlls/mfplay/tests/test-und.wma b/dlls/mfplay/tests/test-und.wma
new file mode 100644
index 00000000000..54243cee77f
Binary files /dev/null and b/dlls/mfplay/tests/test-und.wma differ
diff --git a/dlls/mfreadwrite/tests/mfplat.c b/dlls/mfreadwrite/tests/mfplat.c
index 14e92cceab2..83091b59380 100644
--- a/dlls/mfreadwrite/tests/mfplat.c
+++ b/dlls/mfreadwrite/tests/mfplat.c
@@ -17,6 +17,7 @@
  */
 
 #include <stdarg.h>
+#include <stdbool.h>
 #include <string.h>
 
 #define COBJMACROS
@@ -668,7 +669,7 @@ static struct async_callback *create_async_callback(void)
     return callback;
 }
 
-static void test_source_reader(void)
+static void test_source_reader(const char *filename, bool video)
 {
     IMFMediaType *mediatype, *mediatype2;
     DWORD stream_flags, actual_index;
@@ -689,17 +690,29 @@ static void test_source_reader(void)
         return;
     }
 
-    stream = get_resource_stream("test.wav");
+    winetest_push_context("%s", filename);
 
-    hr = MFCreateSourceReaderFromByteStream(stream, NULL, &reader);
+    stream = get_resource_stream(filename);
+
+    /* Create the source reader with video processing enabled. This allows
+     * outputting RGB formats. */
+    MFCreateAttributes(&attributes, 1);
+    hr = IMFAttributes_SetUINT32(attributes, &MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING, TRUE);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = MFCreateSourceReaderFromByteStream(stream, attributes, &reader);
     if (FAILED(hr))
     {
         skip("MFCreateSourceReaderFromByteStream() failed, is G-Streamer missing?\n");
         IMFByteStream_Release(stream);
+        IMFAttributes_Release(attributes);
+        winetest_pop_context();
         return;
     }
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
 
+    IMFAttributes_Release(attributes);
+
     /* Access underlying media source object. */
     hr = IMFSourceReader_GetServiceForStream(reader, MF_SOURCE_READER_MEDIASOURCE, &GUID_NULL, &IID_IMFMediaSource,
             (void **)&source);
@@ -707,8 +720,17 @@ static void test_source_reader(void)
     IMFMediaSource_Release(source);
 
     /* Stream selection. */
+    selected = FALSE;
     hr = IMFSourceReader_GetStreamSelection(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, &selected);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    if (video)
+    {
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(selected, "Unexpected selection.\n");
+    }
+    else
+    {
+        ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    }
 
     hr = IMFSourceReader_GetStreamSelection(reader, 100, &selected);
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
@@ -724,7 +746,7 @@ static void test_source_reader(void)
     ok(selected, "Unexpected selection.\n");
 
     hr = IMFSourceReader_SetStreamSelection(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, TRUE);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == (video ? S_OK : MF_E_INVALIDSTREAMNUMBER), "Unexpected hr %#lx.\n", hr);
 
     hr = IMFSourceReader_SetStreamSelection(reader, 100, TRUE);
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
@@ -747,7 +769,19 @@ static void test_source_reader(void)
 
     /* Native media type. */
     hr = IMFSourceReader_GetNativeMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &mediatype);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    if (video)
+    {
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFSourceReader_GetNativeMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &mediatype2);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(mediatype != mediatype2, "Unexpected media type instance.\n");
+        IMFMediaType_Release(mediatype2);
+        IMFMediaType_Release(mediatype);
+    }
+    else
+    {
+        ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    }
 
     hr = IMFSourceReader_GetNativeMediaType(reader, 100, 0, &mediatype);
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
@@ -769,7 +803,85 @@ static void test_source_reader(void)
 
     /* Current media type. */
     hr = IMFSourceReader_GetCurrentMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, &mediatype);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    if (video)
+    {
+        GUID subtype;
+        UINT32 stride;
+        UINT64 framesize;
+
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+        hr = IMFMediaType_GetGUID(mediatype, &MF_MT_SUBTYPE, &subtype);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        todo_wine ok(IsEqualGUID(&subtype, &MFVideoFormat_H264), "Got subtype %s.\n", debugstr_guid(&subtype));
+
+        hr = IMFMediaType_GetUINT64(mediatype, &MF_MT_FRAME_SIZE, &framesize);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(framesize == ((UINT64)160 << 32 | 120), "Got frame size %ux%u.\n",
+                (unsigned int)(framesize >> 32), (unsigned int)framesize);
+
+        hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_DEFAULT_STRIDE, &stride);
+        ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+
+        IMFMediaType_Release(mediatype);
+
+        /* Set the type to a YUV format. */
+
+        hr = MFCreateMediaType(&mediatype);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFMediaType_SetGUID(mediatype, &MF_MT_SUBTYPE, &MFVideoFormat_NV12);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFSourceReader_SetCurrentMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, NULL, mediatype);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        IMFMediaType_Release(mediatype);
+
+        hr = IMFSourceReader_GetCurrentMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, &mediatype);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+        hr = IMFMediaType_GetGUID(mediatype, &MF_MT_SUBTYPE, &subtype);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(IsEqualGUID(&subtype, &MFVideoFormat_NV12), "Got subtype %s.\n", debugstr_guid(&subtype));
+
+        hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_DEFAULT_STRIDE, &stride);
+        todo_wine ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        todo_wine ok(stride == 160, "Got stride %u.\n", stride);
+
+        IMFMediaType_Release(mediatype);
+
+        /* Set the type to an RGB format. */
+
+        hr = MFCreateMediaType(&mediatype);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFMediaType_SetGUID(mediatype, &MF_MT_SUBTYPE, &MFVideoFormat_RGB32);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        hr = IMFSourceReader_SetCurrentMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, NULL, mediatype);
+        todo_wine ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        IMFMediaType_Release(mediatype);
+
+        if (hr == S_OK)
+        {
+            hr = IMFSourceReader_GetCurrentMediaType(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, &mediatype);
+            ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+            hr = IMFMediaType_GetGUID(mediatype, &MF_MT_SUBTYPE, &subtype);
+            ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+            ok(IsEqualGUID(&subtype, &MFVideoFormat_RGB32), "Got subtype %s.\n", debugstr_guid(&subtype));
+
+            hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_DEFAULT_STRIDE, &stride);
+            todo_wine ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+            todo_wine ok(stride == 160 * 4, "Got stride %u.\n", stride);
+
+            IMFMediaType_Release(mediatype);
+        }
+    }
+    else
+    {
+        ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    }
 
     hr = IMFSourceReader_GetCurrentMediaType(reader, 100, &mediatype);
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
@@ -782,55 +894,64 @@ static void test_source_reader(void)
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
     IMFMediaType_Release(mediatype);
 
-    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_AUDIO_STREAM, 0, &actual_index, &stream_flags,
-            &timestamp, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    if (hr != S_OK)
-        goto skip_read_sample;
-    ok(!actual_index, "Unexpected stream index %lu.\n", actual_index);
-    ok(!stream_flags, "Unexpected stream flags %#lx.\n", stream_flags);
-    IMFSample_Release(sample);
-
-    /* There is no video stream. */
-    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &actual_index, &stream_flags,
-            &timestamp, &sample);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
-    ok(actual_index == MF_SOURCE_READER_FIRST_VIDEO_STREAM, "Unexpected stream index %lu.\n", actual_index);
-    ok(stream_flags == MF_SOURCE_READERF_ERROR, "Unexpected stream flags %#lx.\n", stream_flags);
+    for (;;)
+    {
+        hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_AUDIO_STREAM, 0, &actual_index, &stream_flags,
+                &timestamp, &sample);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        todo_wine_if (video) ok(!actual_index, "Unexpected stream index %lu.\n", actual_index);
+        ok(!(stream_flags & ~MF_SOURCE_READERF_ENDOFSTREAM), "Unexpected stream flags %#lx.\n", stream_flags);
 
-    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, NULL, &stream_flags, &timestamp,
-            &sample);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+        if (stream_flags & MF_SOURCE_READERF_ENDOFSTREAM)
+        {
+            ok(!sample, "Unexpected sample object.\n");
+            break;
+        }
 
-    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, NULL, NULL, &timestamp, &sample);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+        IMFSample_Release(sample);
+    }
 
-    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_AUDIO_STREAM, 0, &actual_index, &stream_flags,
+    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &actual_index, &stream_flags,
             &timestamp, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!actual_index, "Unexpected stream index %lu.\n", actual_index);
-    /* TODO: gstreamer outputs .wav sample in increments of 4096, instead of 4410 */
-    todo_wine
-{
-    ok(stream_flags == MF_SOURCE_READERF_ENDOFSTREAM, "Unexpected stream flags %#lx.\n", stream_flags);
-    ok(!sample, "Unexpected sample object.\n");
-}
-    if(!stream_flags)
+    if (video)
     {
-        IMFSample_Release(sample);
+        for (;;)
+        {
+            hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM,
+                    0, &actual_index, &stream_flags, &timestamp, &sample);
+            ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+            todo_wine ok(actual_index == 1, "Unexpected stream index %lu.\n", actual_index);
+            ok(!(stream_flags & ~MF_SOURCE_READERF_ENDOFSTREAM), "Unexpected stream flags %#lx.\n", stream_flags);
 
-        hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_AUDIO_STREAM, 0, &actual_index, &stream_flags,
-                &timestamp, &sample);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        ok(!actual_index, "Unexpected stream index %lu.\n", actual_index);
-        ok(stream_flags == MF_SOURCE_READERF_ENDOFSTREAM, "Unexpected stream flags %#lx.\n", stream_flags);
-        ok(!sample, "Unexpected sample object.\n");
+            if (stream_flags & MF_SOURCE_READERF_ENDOFSTREAM)
+            {
+                ok(!sample, "Unexpected sample object.\n");
+                break;
+            }
+
+            IMFSample_Release(sample);
+        }
+    }
+    else
+    {
+        hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM,
+                0, &actual_index, &stream_flags, &timestamp, &sample);
+        ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+        ok(actual_index == MF_SOURCE_READER_FIRST_VIDEO_STREAM, "Unexpected stream index %lu.\n", actual_index);
+        ok(stream_flags == MF_SOURCE_READERF_ERROR, "Unexpected stream flags %#lx.\n", stream_flags);
+
+        hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM,
+                0, NULL, &stream_flags, &timestamp, &sample);
+        ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
     }
 
+    hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, NULL, NULL, &timestamp, &sample);
+    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+
     hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_AUDIO_STREAM, MF_SOURCE_READER_CONTROLF_DRAIN,
             &actual_index, &stream_flags, &timestamp, &sample);
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(actual_index == 0, "Unexpected stream index %lu\n", actual_index);
+    todo_wine_if (video) ok(actual_index == 0, "Unexpected stream index %lu.\n", actual_index);
     ok(stream_flags == MF_SOURCE_READERF_ENDOFSTREAM, "Unexpected stream flags %#lx.\n", stream_flags);
     ok(!sample, "Unexpected sample object.\n");
 
@@ -851,7 +972,7 @@ static void test_source_reader(void)
     hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_FIRST_AUDIO_STREAM, MF_SOURCE_READER_CONTROLF_DRAIN,
             &actual_index, &stream_flags, NULL, &sample);
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!actual_index, "Unexpected stream index %lu\n", actual_index);
+    todo_wine_if (video) ok(!actual_index, "Unexpected stream index %lu.\n", actual_index);
     ok(stream_flags == MF_SOURCE_READERF_ENDOFSTREAM, "Unexpected stream flags %#lx.\n", stream_flags);
     ok(!sample, "Unexpected sample object.\n");
 
@@ -862,11 +983,9 @@ static void test_source_reader(void)
     ok(stream_flags == MF_SOURCE_READERF_ENDOFSTREAM, "Unexpected stream flags %#lx.\n", stream_flags);
     ok(!sample, "Unexpected sample object.\n");
 
-skip_read_sample:
-
     /* Flush. */
     hr = IMFSourceReader_Flush(reader, MF_SOURCE_READER_FIRST_VIDEO_STREAM);
-    ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == (video ? S_OK : MF_E_INVALIDSTREAMNUMBER), "Unexpected hr %#lx.\n", hr);
 
     hr = IMFSourceReader_Flush(reader, 100);
     ok(hr == MF_E_INVALIDSTREAMNUMBER, "Unexpected hr %#lx.\n", hr);
@@ -902,6 +1021,8 @@ skip_read_sample:
     IMFSourceReader_Release(reader);
 
     IMFByteStream_Release(stream);
+
+    winetest_pop_context();
 }
 
 static void test_source_reader_from_media_source(void)
@@ -1323,7 +1444,8 @@ START_TEST(mfplat)
     init_functions();
 
     test_factory();
-    test_source_reader();
+    test_source_reader("test.wav", false);
+    test_source_reader("test.mp4", true);
     test_source_reader_from_media_source();
     test_reader_d3d9();
     test_sink_writer();
diff --git a/dlls/mfreadwrite/tests/resource.rc b/dlls/mfreadwrite/tests/resource.rc
index f54212a8c8f..5a737b1ad85 100644
--- a/dlls/mfreadwrite/tests/resource.rc
+++ b/dlls/mfreadwrite/tests/resource.rc
@@ -18,5 +18,10 @@
 
 #include "windef.h"
 
+/* ffmpeg -f lavfi -i "sine=frequency=600" -t 0.1 -ar 44100 -f wav -acodec pcm_u8 test.wav */
 /* @makedep: test.wav */
 test.wav RCDATA test.wav
+
+/* ffmpeg -f lavfi -i smptebars -f lavfi -i "sine=frequency=1000" -t 1.0 -r 25 -f mp4 -vcodec h264 -vf scale=160x120 -acodec aac test.mp4 */
+/* @makedep: test.mp4 */
+test.mp4 RCDATA test.mp4
diff --git a/dlls/mfreadwrite/tests/test.mp4 b/dlls/mfreadwrite/tests/test.mp4
new file mode 100644
index 00000000000..c7f9e27bde2
Binary files /dev/null and b/dlls/mfreadwrite/tests/test.mp4 differ
diff --git a/dlls/mfsrcsnk/mfsrcsnk.spec b/dlls/mfsrcsnk/mfsrcsnk.spec
index ab9f2e4c207..485fba3bb31 100644
--- a/dlls/mfsrcsnk/mfsrcsnk.spec
+++ b/dlls/mfsrcsnk/mfsrcsnk.spec
@@ -1,3 +1,4 @@
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stdcall MFCreateWAVEMediaSink(ptr ptr ptr)
diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
index 22c17025e87..33ce1f248e5 100644
--- a/dlls/mountmgr.sys/device.c
+++ b/dlls/mountmgr.sys/device.c
@@ -899,6 +899,14 @@ static BOOL get_volume_device_info( struct volume *volume )
     }
     else
     {
+        if(GetLastError() == ERROR_NOT_READY)
+        {
+            TRACE( "%s: removable drive with no inserted media\n", debugstr_a(unix_device) );
+            volume->fs_type = FS_UNKNOWN;
+            CloseHandle( handle );
+            return TRUE;
+        }
+
         volume->fs_type = VOLUME_ReadFATSuperblock( handle, superblock );
         if (volume->fs_type == FS_UNKNOWN) volume->fs_type = VOLUME_ReadCDSuperblock( handle, superblock );
     }
diff --git a/dlls/mountmgr.sys/mountmgr.c b/dlls/mountmgr.sys/mountmgr.c
index 9f72eedb33b..ec22a8eb9bc 100644
--- a/dlls/mountmgr.sys/mountmgr.c
+++ b/dlls/mountmgr.sys/mountmgr.c
@@ -618,7 +618,11 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
 #ifdef _WIN64
     HKEY wow64_ports_key = NULL;
 #endif
-    UNICODE_STRING nameW, linkW;
+    UNICODE_STRING device_mount_point_manager = RTL_CONSTANT_STRING( L"\\Device\\MountPointManager" );
+    UNICODE_STRING object_mount_point_manager = RTL_CONSTANT_STRING( L"\\??\\MountPointManager" );
+    UNICODE_STRING driver_harddisk = RTL_CONSTANT_STRING( L"\\Driver\\Harddisk" );
+    UNICODE_STRING driver_serial = RTL_CONSTANT_STRING( L"\\Driver\\Serial" );
+    UNICODE_STRING driver_parallel = RTL_CONSTANT_STRING( L"\\Driver\\Parallel" );
     DEVICE_OBJECT *device;
     HKEY devicemap_key;
     NTSTATUS status;
@@ -631,10 +635,8 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
 
     driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = mountmgr_ioctl;
 
-    RtlInitUnicodeString( &nameW, L"\\Device\\MountPointManager" );
-    RtlInitUnicodeString( &linkW, L"\\??\\MountPointManager" );
-    if (!(status = IoCreateDevice( driver, 0, &nameW, 0, 0, FALSE, &device )))
-        status = IoCreateSymbolicLink( &linkW, &nameW );
+    if (!(status = IoCreateDevice( driver, 0, &device_mount_point_manager, 0, 0, FALSE, &device )))
+        status = IoCreateSymbolicLink( &object_mount_point_manager, &device_mount_point_manager );
     if (status)
     {
         FIXME( "failed to create device error %lx\n", status );
@@ -648,8 +650,7 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
                           KEY_ALL_ACCESS, NULL, &devicemap_key, NULL ))
         RegCloseKey( devicemap_key );
 
-    RtlInitUnicodeString( &nameW, L"\\Driver\\Harddisk" );
-    status = IoCreateDriver( &nameW, harddisk_driver_entry );
+    status = IoCreateDriver( &driver_harddisk, harddisk_driver_entry );
 
     thread = CreateThread( NULL, 0, device_op_thread, NULL, 0, NULL );
     CloseHandle( CreateThread( NULL, 0, run_loop_thread, thread, 0, NULL ));
@@ -664,11 +665,8 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
     RegCloseKey( wow64_ports_key );
 #endif
 
-    RtlInitUnicodeString( &nameW, L"\\Driver\\Serial" );
-    IoCreateDriver( &nameW, serial_driver_entry );
-
-    RtlInitUnicodeString( &nameW, L"\\Driver\\Parallel" );
-    IoCreateDriver( &nameW, parallel_driver_entry );
+    IoCreateDriver( &driver_serial, serial_driver_entry );
+    IoCreateDriver( &driver_parallel, parallel_driver_entry );
 
     return status;
 }
diff --git a/dlls/msado15/main.c b/dlls/msado15/main.c
index edbbaeb9e6e..187c3cf7518 100644
--- a/dlls/msado15/main.c
+++ b/dlls/msado15/main.c
@@ -147,6 +147,7 @@ static REFIID tid_ids[] = {
     &IID_Field,
     &IID_Fields,
     &IID_Properties,
+    &IID_Property,
     &IID__Recordset,
     &IID__Stream,
 };
diff --git a/dlls/msado15/msado15_private.h b/dlls/msado15/msado15_private.h
index 71344934b95..f7062c94b27 100644
--- a/dlls/msado15/msado15_private.h
+++ b/dlls/msado15/msado15_private.h
@@ -33,6 +33,7 @@ typedef enum tid_t {
     Field_tid,
     Fields_tid,
     Properties_tid,
+    Property_tid,
     Recordset_tid,
     Stream_tid,
     LAST_tid
diff --git a/dlls/msado15/recordset.c b/dlls/msado15/recordset.c
index aa2db6e2968..c9309336cb6 100644
--- a/dlls/msado15/recordset.c
+++ b/dlls/msado15/recordset.c
@@ -48,6 +48,7 @@ struct recordset
     CursorTypeEnum     cursor_type;
     IRowset           *row_set;
     EditModeEnum      editmode;
+    VARIANT            filter;
 };
 
 struct fields
@@ -73,6 +74,9 @@ struct field
     LONG                attrs;
     LONG                index;
     struct recordset   *recordset;
+
+    /* Field Properties */
+    VARIANT             optimize;
 };
 
 static inline struct field *impl_from_Field( Field *iface )
@@ -197,8 +201,10 @@ static HRESULT WINAPI field_get_Properties( Field *iface, Properties **obj )
 
 static HRESULT WINAPI field_get_ActualSize( Field *iface, ADO_LONGPTR *size )
 {
-    FIXME( "%p, %p\n", iface, size );
-    return E_NOTIMPL;
+    struct field *field = impl_from_Field( iface );
+    FIXME( "%p, %p\n", field, size );
+    *size = 0;
+    return S_OK;
 }
 
 static HRESULT WINAPI field_get_Attributes( Field *iface, LONG *attrs )
@@ -564,10 +570,193 @@ static HRESULT WINAPI field_props_Refresh(Properties *iface)
     return E_NOTIMPL;
 }
 
+
+struct field_property
+{
+    Property Property_iface;
+    LONG refs;
+    VARIANT *value;
+};
+
+static inline struct field_property *impl_from_Property( Property *iface )
+{
+    return CONTAINING_RECORD( iface, struct field_property, Property_iface );
+}
+
+static ULONG WINAPI field_property_AddRef(Property *iface)
+{
+    struct field_property *property = impl_from_Property( iface );
+    LONG refs = InterlockedIncrement( &property->refs );
+    TRACE( "%p new refcount %ld\n", property, refs );
+    return refs;
+}
+
+static ULONG WINAPI field_property_Release(Property *iface)
+{
+    struct field_property *property = impl_from_Property( iface );
+    LONG refs = InterlockedDecrement( &property->refs );
+    TRACE( "%p new refcount %ld\n", property, refs );
+    if (!refs)
+    {
+        free( property );
+    }
+    return refs;
+}
+
+static HRESULT WINAPI field_property_QueryInterface(Property *iface, REFIID riid, void **obj)
+{
+    struct field_property *property = impl_from_Property( iface );
+    TRACE( "%p, %s, %p\n", property, debugstr_guid(riid), obj );
+
+    if (IsEqualGUID( riid, &IID_Property )
+        || IsEqualGUID( riid, &IID_IDispatch )
+        || IsEqualGUID( riid, &IID_IUnknown ))
+    {
+        *obj = iface;
+    }
+    else
+    {
+        FIXME( "interface %s not implemented\n", debugstr_guid(riid) );
+        return E_NOINTERFACE;
+    }
+    field_property_AddRef( iface );
+    return S_OK;
+}
+
+static HRESULT WINAPI field_property_GetTypeInfoCount(Property *iface, UINT *count)
+{
+    struct field_property *property = impl_from_Property( iface );
+    TRACE( "%p, %p\n", property, count );
+    *count = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI field_property_GetTypeInfo(Property *iface, UINT index, LCID lcid, ITypeInfo **info)
+{
+    struct field_property *property = impl_from_Property( iface );
+    TRACE( "%p, %u, %lu, %p\n", property, index, lcid, info );
+    return get_typeinfo(Property_tid, info);
+}
+
+static HRESULT WINAPI field_property_GetIDsOfNames(Property *iface, REFIID riid, LPOLESTR *names, UINT count,
+                                                    LCID lcid, DISPID *dispid)
+{
+    struct field_property *property = impl_from_Property( iface );
+    HRESULT hr;
+    ITypeInfo *typeinfo;
+
+    TRACE( "%p, %s, %p, %u, %lu, %p\n", property, debugstr_guid(riid), names, count, lcid, dispid );
+
+    hr = get_typeinfo(Property_tid, &typeinfo);
+    if(SUCCEEDED(hr))
+    {
+        hr = ITypeInfo_GetIDsOfNames(typeinfo, names, count, dispid);
+        ITypeInfo_Release(typeinfo);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI field_property_Invoke(Property *iface, DISPID member, REFIID riid, LCID lcid,
+    WORD flags, DISPPARAMS *params, VARIANT *result, EXCEPINFO *excep_info, UINT *arg_err)
+{
+    struct field_property *property = impl_from_Property( iface );
+    HRESULT hr;
+    ITypeInfo *typeinfo;
+
+    TRACE( "%p, %ld, %s, %ld, %d, %p, %p, %p, %p\n", property, member, debugstr_guid(riid), lcid, flags, params,
+           result, excep_info, arg_err );
+
+    hr = get_typeinfo(Property_tid, &typeinfo);
+    if(SUCCEEDED(hr))
+    {
+        hr = ITypeInfo_Invoke(typeinfo, &property->Property_iface, member, flags, params,
+                               result, excep_info, arg_err);
+        ITypeInfo_Release(typeinfo);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI field_property_get_Value(Property *iface, VARIANT *val)
+{
+    struct field_property *property = impl_from_Property( iface );
+    TRACE("%p, %p\n", property, val);
+    VariantCopy(val, property->value);
+    return S_OK;
+}
+
+static HRESULT WINAPI field_property_put_Value(Property *iface, VARIANT val)
+{
+    struct field_property *property = impl_from_Property( iface );
+    TRACE("%p, %s\n", property, debugstr_variant(&val));
+    VariantCopy(property->value, &val);
+    return S_OK;
+}
+
+static HRESULT WINAPI field_property_get_Name(Property *iface, BSTR *str)
+{
+    FIXME("\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI field_property_get_Type(Property *iface, DataTypeEnum *type)
+{
+    FIXME("\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI field_property_get_Attributes(Property *iface, LONG *attributes)
+{
+    FIXME("\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI field_property_put_Attributes(Property *iface, LONG attributes)
+{
+    FIXME("\n");
+    return E_NOTIMPL;
+}
+
+static struct PropertyVtbl field_property_vtbl =
+{
+    field_property_QueryInterface,
+    field_property_AddRef,
+    field_property_Release,
+    field_property_GetTypeInfoCount,
+    field_property_GetTypeInfo,
+    field_property_GetIDsOfNames,
+    field_property_Invoke,
+    field_property_get_Value,
+    field_property_put_Value,
+    field_property_get_Name,
+    field_property_get_Type,
+    field_property_get_Attributes,
+    field_property_put_Attributes
+};
+
 static HRESULT WINAPI field_props_get_Item(Properties *iface, VARIANT index, Property **object)
 {
     struct field *field = impl_from_Properties( iface );
-    FIXME( "%p, %s, %p\n", field, debugstr_variant(&index), object);
+    struct field_property *prop;
+
+    TRACE( "%p, %s, %p\n", field, debugstr_variant(&index), object);
+
+    if (V_VT(&index) == VT_BSTR)
+    {
+        if(!wcscmp(L"Optimize", V_BSTR(&index)))
+        {
+            prop = malloc (sizeof(struct field_property));
+            prop->Property_iface.lpVtbl = &field_property_vtbl;
+            prop->value = &field->optimize;
+
+            *object = &prop->Property_iface;
+            return S_OK;
+        }
+    }
+
+    FIXME("Unsupported property %s\n", debugstr_variant(&index));
+
     return MAKE_ADO_HRESULT(adErrItemNotFound);
 }
 
@@ -1588,14 +1777,30 @@ static HRESULT WINAPI recordset_get_EditMode( _Recordset *iface, EditModeEnum *m
 
 static HRESULT WINAPI recordset_get_Filter( _Recordset *iface, VARIANT *criteria )
 {
-    FIXME( "%p, %p\n", iface, criteria );
-    return E_NOTIMPL;
+    struct recordset *recordset = impl_from_Recordset( iface );
+    TRACE( "%p, %p\n", iface, criteria );
+
+    if (!criteria) return MAKE_ADO_HRESULT( adErrInvalidArgument );
+
+    VariantCopy(criteria, &recordset->filter);
+    return S_OK;
 }
 
 static HRESULT WINAPI recordset_put_Filter( _Recordset *iface, VARIANT criteria )
 {
-    FIXME( "%p, %s\n", iface, debugstr_variant(&criteria) );
-    return E_NOTIMPL;
+    struct recordset *recordset = impl_from_Recordset( iface );
+    TRACE( "%p, %s\n", recordset, debugstr_variant(&criteria) );
+
+    if (V_VT(&criteria) != VT_I2 && V_VT(&criteria) != VT_I4 && V_VT(&criteria) != VT_BSTR)
+        return MAKE_ADO_HRESULT( adErrInvalidArgument );
+
+    if (V_VT(&criteria) == VT_BSTR && recordset->state == adStateOpen)
+    {
+        FIXME("Validating fields not preformed\n");
+    }
+
+    VariantCopy(&recordset->filter, &criteria);
+    return S_OK;
 }
 
 static HRESULT WINAPI recordset_get_PageCount( _Recordset *iface, ADO_LONGPTR *count )
@@ -2131,6 +2336,7 @@ HRESULT Recordset_create( void **obj )
     recordset->cursor_type = adOpenForwardOnly;
     recordset->row_set = NULL;
     recordset->editmode = adEditNone;
+    VariantInit( &recordset->filter );
 
     *obj = &recordset->Recordset_iface;
     TRACE( "returning iface %p\n", *obj );
diff --git a/dlls/msado15/tests/msado15.c b/dlls/msado15/tests/msado15.c
index b39adf58b22..724787870e0 100644
--- a/dlls/msado15/tests/msado15.c
+++ b/dlls/msado15/tests/msado15.c
@@ -59,7 +59,7 @@ static void test_Recordset(void)
     CursorTypeEnum cursor;
     BSTR name;
     HRESULT hr;
-    VARIANT bookmark;
+    VARIANT bookmark, filter;
     EditModeEnum editmode;
 
     hr = CoCreateInstance( &CLSID_Recordset, NULL, CLSCTX_INPROC_SERVER, &IID__Recordset, (void **)&recordset );
@@ -123,6 +123,26 @@ static void test_Recordset(void)
     hr = _Recordset_put_Bookmark( recordset, bookmark );
     ok( hr == MAKE_ADO_HRESULT( adErrObjectClosed ), "got %08lx\n", hr );
 
+    VariantInit( &filter );
+    hr = _Recordset_put_Filter( recordset, filter );
+    ok( hr == MAKE_ADO_HRESULT( adErrInvalidArgument ), "got %08lx\n", hr );
+
+    V_VT(&filter) = VT_BSTR;
+    V_BSTR(&filter) = SysAllocString( L"field1 = 1" );
+    hr = _Recordset_put_Filter( recordset, filter );
+    ok( hr == S_OK, "got %08lx\n", hr );
+    VariantClear(&filter);
+
+    V_VT(&filter) = VT_I4;
+    V_I4(&filter) = 0;
+    hr = _Recordset_put_Filter( recordset, filter );
+    ok( hr == S_OK, "got %08lx\n", hr );
+
+    V_VT(&filter) = VT_I2;
+    V_I2(&filter) = 0;
+    hr = _Recordset_put_Filter( recordset, filter );
+    ok( hr == S_OK, "got %08lx\n", hr );
+
     VariantInit( &missing );
     hr = _Recordset_AddNew( recordset, missing, missing );
     ok( hr == MAKE_ADO_HRESULT( adErrObjectClosed ), "got %08lx\n", hr );
@@ -248,6 +268,23 @@ static void test_Recordset(void)
     ok( fields2 == fields, "expected same object\n" );
     Fields_Release( fields2 );
 
+    V_VT(&filter) = VT_BSTR;
+    V_BSTR(&filter) = SysAllocString( L"field1 = 1" );
+    hr = _Recordset_put_Filter( recordset, filter );
+    todo_wine ok( hr == MAKE_ADO_HRESULT( adErrItemNotFound ), "got %08lx\n", hr );
+    VariantClear(&filter);
+
+    V_VT(&filter) = VT_BSTR;
+    V_BSTR(&filter) = SysAllocString( L"field = 1" );
+    hr = _Recordset_put_Filter( recordset, filter );
+    ok( hr == S_OK, "got %08lx\n", hr );
+    VariantClear(&filter);
+
+    V_VT(&filter) = VT_I4;
+    V_I4(&filter) = 0;
+    hr = _Recordset_put_Filter( recordset, filter );
+    ok( hr == S_OK, "got %08lx\n", hr );
+
     count = -1;
     hr = Fields_get_Count( fields2, &count );
     ok( count == 1, "got %ld\n", count );
diff --git a/dlls/msauddecmft/Makefile.in b/dlls/msauddecmft/Makefile.in
new file mode 100644
index 00000000000..abce4d1cfe4
--- /dev/null
+++ b/dlls/msauddecmft/Makefile.in
@@ -0,0 +1 @@
+MODULE    = msauddecmft.dll
diff --git a/dlls/msauddecmft/msauddecmft.spec b/dlls/msauddecmft/msauddecmft.spec
new file mode 100644
index 00000000000..a9b7505d360
--- /dev/null
+++ b/dlls/msauddecmft/msauddecmft.spec
@@ -0,0 +1,4 @@
+@ stdcall -private DllCanUnloadNow()
+@ stub DllGetClassObject
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
diff --git a/dlls/msdasql/msdasql_main.c b/dlls/msdasql/msdasql_main.c
index 017a2517a72..2f25498abca 100644
--- a/dlls/msdasql/msdasql_main.c
+++ b/dlls/msdasql/msdasql_main.c
@@ -530,26 +530,35 @@ static ULONG WINAPI dbinit_Release(IDBInitialize *iface)
 static HRESULT WINAPI dbinit_Initialize(IDBInitialize *iface)
 {
     struct msdasql *provider = impl_from_IDBInitialize(iface);
-    int i;
+    int i, len;
     SQLRETURN ret;
+    WCHAR connection[1024], *p = connection, outstr[1024];
 
     FIXME("%p semi-stub\n", provider);
 
-    for(i=0; i < sizeof(provider->properties); i++)
+    *p = 0;
+    for(i=0; i < ARRAY_SIZE(provider->properties); i++)
     {
         if (provider->properties[i].id == DBPROP_INIT_DATASOURCE)
-            break;
-    }
-
-    if (i >= sizeof(provider->properties))
-    {
-        ERR("Datasource not found\n");
-        return E_FAIL;
+        {
+            len = swprintf(p, ARRAY_SIZE(connection) - (p - connection),
+                           L"DSN=%s;", V_BSTR(&provider->properties[i].value));
+            p+= len;
+        }
+        else if (provider->properties[i].id == DBPROP_INIT_PROVIDERSTRING)
+        {
+            if (V_VT(&provider->properties[i].value) == VT_BSTR && SysStringLen(V_BSTR(&provider->properties[i].value)) )
+            {
+                len = swprintf(p, ARRAY_SIZE(connection) - (p - connection),
+                               L"%s;", V_BSTR(&provider->properties[i].value));
+                p+= len;
+            }
+        }
     }
 
-    ret = SQLConnectW( provider->hdbc, (SQLWCHAR *)V_BSTR(&provider->properties[i].value),
-        SQL_NTS, NULL, SQL_NTS, NULL, SQL_NTS );
-    TRACE("SQLConnectW ret %d\n", ret);
+    ret = SQLDriverConnectW( provider->hdbc, NULL, connection, wcslen(connection),
+                             outstr, ARRAY_SIZE(outstr), NULL, 0);
+    TRACE("SQLDriverConnectW ret %d\n", ret);
     if (ret != SQL_SUCCESS)
     {
         dump_sql_diag_records(SQL_HANDLE_DBC, provider->hdbc);
diff --git a/dlls/msdasql/session.c b/dlls/msdasql/session.c
index 67dc30bf09e..588be365b72 100644
--- a/dlls/msdasql/session.c
+++ b/dlls/msdasql/session.c
@@ -1029,9 +1029,10 @@ static HRESULT WINAPI rowset_colsinfo_GetColumnInfo(IColumnsInfo *iface, DBORDIN
             dbcolumn[i].pTypeInfo = NULL;
             dbcolumn[i].iOrdinal = i+1;
 
-            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_UNSIGNED, NULL, 0, NULL, &length);
+            ret = SQLColAttributesW (rowset->hstmt, i+1, SQL_DESC_UNSIGNED, NULL, 0, NULL, &length);
             if (!SQL_SUCCEEDED(ret))
             {
+                dump_sql_diag_records(SQL_HANDLE_STMT, rowset->hstmt);
                 CoTaskMemFree(ptr);
                 CoTaskMemFree(dbcolumn);
                 ERR("Failed to get column %d attribute\n", i+1);
@@ -1043,7 +1044,7 @@ static HRESULT WINAPI rowset_colsinfo_GetColumnInfo(IColumnsInfo *iface, DBORDIN
 
             dbcolumn[i].dwFlags = DBCOLUMNFLAGS_WRITE;
 
-            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_LENGTH, NULL, 0, NULL, &length);
+            ret = SQLColAttributesW(rowset->hstmt, i+1, SQL_DESC_LENGTH, NULL, 0, NULL, &length);
             if (!SQL_SUCCEEDED(ret))
             {
                 CoTaskMemFree(ptr);
@@ -1062,7 +1063,7 @@ static HRESULT WINAPI rowset_colsinfo_GetColumnInfo(IColumnsInfo *iface, DBORDIN
             if (is_fixed_length(ColumnDataType))
                 dbcolumn[i].dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
 
-            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_SCALE, NULL, 0, NULL, &length);
+            ret = SQLColAttributesW(rowset->hstmt, i+1, SQL_DESC_SCALE, NULL, 0, NULL, &length);
             if (!SQL_SUCCEEDED(ret))
             {
                 CoTaskMemFree(ptr);
@@ -1074,7 +1075,7 @@ static HRESULT WINAPI rowset_colsinfo_GetColumnInfo(IColumnsInfo *iface, DBORDIN
                 length = 255;
             dbcolumn[i].bScale = length;
 
-            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_PRECISION, NULL, 0, NULL, &length);
+            ret = SQLColAttributesW(rowset->hstmt, i+1, SQL_DESC_PRECISION, NULL, 0, NULL, &length);
             if (!SQL_SUCCEEDED(ret))
             {
                 CoTaskMemFree(ptr);
@@ -1242,6 +1243,7 @@ static HRESULT WINAPI command_Execute(ICommandText *iface, IUnknown *outer, REFI
     RETCODE ret;
     SQLHSTMT hstmt = command->hstmt;
     SQLLEN results = -1;
+    BOOL free_hstmt = TRUE;
 
     TRACE("%p, %p, %s, %p %p %p\n", command, outer, debugstr_guid(riid), params, affected, rowset);
 
@@ -1272,21 +1274,23 @@ static HRESULT WINAPI command_Execute(ICommandText *iface, IUnknown *outer, REFI
         msrowset->refs = 1;
         ICommandText_QueryInterface(iface, &IID_IUnknown, (void**)&msrowset->caller);
         msrowset->hstmt = hstmt;
+        free_hstmt = FALSE;
 
         hr = IRowset_QueryInterface(&msrowset->IRowset_iface, riid, (void**)rowset);
         IRowset_Release(&msrowset->IRowset_iface);
     }
-    else
+
+    if (affected)
     {
         ret = SQLRowCount(hstmt, &results);
         if (ret != SQL_SUCCESS)
             ERR("SQLRowCount failed (%d)\n", ret);
 
-        SQLFreeStmt(hstmt, SQL_CLOSE);
+        *affected = results;
     }
 
-    if (affected)
-        *affected = results;
+    if (free_hstmt)
+        SQLFreeStmt(hstmt, SQL_CLOSE);
 
     return hr;
 }
diff --git a/dlls/msdasql/tests/provider.c b/dlls/msdasql/tests/provider.c
index 72e13154846..bb549bb2262 100644
--- a/dlls/msdasql/tests/provider.c
+++ b/dlls/msdasql/tests/provider.c
@@ -569,6 +569,13 @@ static void test_command_rowset(IUnknown *cmd)
     if (unk)
         IUnknown_Release(unk);
 
+    /* Ensure all rows are deleted - Interactive Test */
+    hr = ICommandText_SetCommandText(command_text, &DBGUID_DEFAULT, L"delete from testing");
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+
+    hr = ICommandText_Execute(command_text, NULL, &IID_NULL, NULL, NULL, NULL);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+
     hr = ICommandText_SetCommandText(command_text, &DBGUID_DEFAULT, L"insert into testing values(1, 'red', 1.0)");
     ok(hr == S_OK, "got 0x%08lx\n", hr);
 
@@ -594,7 +601,7 @@ static void test_command_rowset(IUnknown *cmd)
         DBCOLUMNINFO *dbcolinfo;
         OLECHAR *stringsbuffer;
 
-        todo_wine ok(affected == -1, "got %Id\n", affected);
+        ok(affected == -1 || affected == 1, "got %Iu\n", affected);
 
         hr = IUnknown_QueryInterface(unk, &IID_IRowset, (void**)&rowset);
         ok(hr == S_OK, "got 0x%08lx\n", hr);
diff --git a/dlls/mshtml/dispex.c b/dlls/mshtml/dispex.c
index 1d00012572b..817d77dda7d 100644
--- a/dlls/mshtml/dispex.c
+++ b/dlls/mshtml/dispex.c
@@ -2003,7 +2003,17 @@ void dispex_traverse(DispatchEx *This, nsCycleCollectionTraversalCallback *cb)
             note_cc_edge((nsISupports*)V_DISPATCH(&prop->var), "dispex_data", cb);
     }
 
-    /* FIXME: Traverse func_disps */
+    if(This->dynamic_data->func_disps) {
+        func_obj_entry_t *iter = This->dynamic_data->func_disps, *end = iter + This->info->func_disp_cnt;
+
+        for(iter = This->dynamic_data->func_disps; iter < end; iter++) {
+            if(!iter->func_obj)
+                continue;
+            note_cc_edge((nsISupports*)&iter->func_obj->dispex.IDispatchEx_iface, "func_obj", cb);
+            if(V_VT(&iter->val) == VT_DISPATCH)
+                note_cc_edge((nsISupports*)V_DISPATCH(&iter->val), "func_val", cb);
+        }
+    }
 }
 
 void dispex_unlink(DispatchEx *This)
@@ -2014,12 +2024,23 @@ void dispex_unlink(DispatchEx *This)
         return;
 
     for(prop = This->dynamic_data->props; prop < This->dynamic_data->props + This->dynamic_data->prop_cnt; prop++) {
-        if(V_VT(&prop->var) == VT_DISPATCH) {
-            V_VT(&prop->var) = VT_EMPTY;
-            IDispatch_Release(V_DISPATCH(&prop->var));
-        }else {
-            VariantClear(&prop->var);
+        VariantClear(&prop->var);
+        prop->flags |= DYNPROP_DELETED;
+    }
+
+    if(This->dynamic_data->func_disps) {
+        func_obj_entry_t *iter = This->dynamic_data->func_disps, *end = iter + This->info->func_disp_cnt;
+
+        for(iter = This->dynamic_data->func_disps; iter < end; iter++) {
+            if(!iter->func_obj)
+                continue;
+            iter->func_obj->obj = NULL;
+            IDispatchEx_Release(&iter->func_obj->dispex.IDispatchEx_iface);
+            VariantClear(&iter->val);
         }
+
+        free(This->dynamic_data->func_disps);
+        This->dynamic_data->func_disps = NULL;
     }
 }
 
diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 90c4706abee..2b885d479ab 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -487,56 +487,40 @@ static HRESULT WINAPI HTMLDocument_get_Script(IHTMLDocument2 *iface, IDispatch *
 static HRESULT WINAPI HTMLDocument_get_all(IHTMLDocument2 *iface, IHTMLElementCollection **p)
 {
     HTMLDocumentNode *This = impl_from_IHTMLDocument2(iface);
-    nsIDOMElement *nselem = NULL;
-    HTMLDOMNode *node;
-    nsresult nsres;
-    HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
+    *p = create_all_collection(&This->node, FALSE);
 
-    if(!This->dom_document) {
-        WARN("NULL dom_document\n");
-        return E_UNEXPECTED;
-    }
-
-    nsres = nsIDOMDocument_GetDocumentElement(This->dom_document, &nselem);
-    if(NS_FAILED(nsres)) {
-        ERR("GetDocumentElement failed: %08lx\n", nsres);
-        return E_FAIL;
-    }
-
-    if(!nselem) {
-        *p = NULL;
-        return S_OK;
-    }
-
-    hres = get_node((nsIDOMNode*)nselem, TRUE, &node);
-    nsIDOMElement_Release(nselem);
-    if(FAILED(hres))
-        return hres;
-
-    *p = create_all_collection(node, TRUE);
-    node_release(node);
-    return hres;
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLDocument_get_body(IHTMLDocument2 *iface, IHTMLElement **p)
 {
     HTMLDocumentNode *This = impl_from_IHTMLDocument2(iface);
-    nsIDOMHTMLElement *nsbody = NULL;
+    nsIDOMElement *nsbody = NULL;
     HTMLElement *element;
+    nsresult nsres;
     HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
 
     if(This->html_document) {
-        nsresult nsres;
-
-        nsres = nsIDOMHTMLDocument_GetBody(This->html_document, &nsbody);
+        nsres = nsIDOMHTMLDocument_GetBody(This->html_document, (nsIDOMHTMLElement **)&nsbody);
         if(NS_FAILED(nsres)) {
             TRACE("Could not get body: %08lx\n", nsres);
             return E_UNEXPECTED;
         }
+    }else {
+        nsAString nsnode_name;
+        nsIDOMDocumentFragment *frag;
+
+        nsres = nsIDOMNode_QueryInterface(This->node.nsnode, &IID_nsIDOMDocumentFragment, (void**)&frag);
+        if(!NS_FAILED(nsres)) {
+            nsAString_InitDepend(&nsnode_name, L"BODY");
+            nsIDOMDocumentFragment_QuerySelector(frag, &nsnode_name, &nsbody);
+            nsAString_Finish(&nsnode_name);
+            nsIDOMDocumentFragment_Release(frag);
+        }
     }
 
     if(!nsbody) {
@@ -544,8 +528,8 @@ static HRESULT WINAPI HTMLDocument_get_body(IHTMLDocument2 *iface, IHTMLElement
         return S_OK;
     }
 
-    hres = get_element((nsIDOMElement*)nsbody, &element);
-    nsIDOMHTMLElement_Release(nsbody);
+    hres = get_element(nsbody, &element);
+    nsIDOMElement_Release(nsbody);
     if(FAILED(hres))
         return hres;
 
@@ -1175,6 +1159,9 @@ static HRESULT WINAPI HTMLDocument_get_domain(IHTMLDocument2 *iface, BSTR *p)
         return E_NOTIMPL;
     }
 
+    if(This->outer_window && !This->outer_window->uri)
+        return E_FAIL;
+
     nsAString_Init(&nsstr, NULL);
     nsres = nsIDOMHTMLDocument_GetDomain(This->html_document, &nsstr);
     if(NS_SUCCEEDED(nsres) && This->outer_window && This->outer_window->uri) {
diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index b66b0c22552..f8b2eb46e6c 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -529,6 +529,7 @@ HRESULT create_element(HTMLDocumentNode *doc, const WCHAR *tag, HTMLElement **re
 typedef struct {
     DispatchEx dispex;
     IHTMLRect IHTMLRect_iface;
+    IHTMLRect2 IHTMLRect2_iface;
 
     LONG ref;
 
@@ -550,6 +551,8 @@ static HRESULT WINAPI HTMLRect_QueryInterface(IHTMLRect *iface, REFIID riid, voi
         *ppv = &This->IHTMLRect_iface;
     }else if(IsEqualGUID(&IID_IHTMLRect, riid)) {
         *ppv = &This->IHTMLRect_iface;
+    }else if (IsEqualGUID(&IID_IHTMLRect2, riid)) {
+        *ppv = &This->IHTMLRect2_iface;
     }else if(dispex_query_interface(&This->dispex, riid, ppv)) {
         return *ppv ? S_OK : E_NOINTERFACE;
     }else {
@@ -723,6 +726,91 @@ static HRESULT WINAPI HTMLRect_get_bottom(IHTMLRect *iface, LONG *p)
     return S_OK;
 }
 
+static inline HTMLRect *impl_from_IHTMLRect2(IHTMLRect2 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLRect, IHTMLRect2_iface);
+}
+
+static HRESULT WINAPI HTMLRect2_QueryInterface(IHTMLRect2 *iface, REFIID riid, void **ppv)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IHTMLRect_QueryInterface(&This->IHTMLRect_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLRect2_AddRef(IHTMLRect2 *iface)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IHTMLRect_AddRef(&This->IHTMLRect_iface);
+}
+
+static ULONG WINAPI HTMLRect2_Release(IHTMLRect2 *iface)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IHTMLRect_Release(&This->IHTMLRect_iface);
+}
+
+static HRESULT WINAPI HTMLRect2_GetTypeInfoCount(IHTMLRect2 *iface, UINT *pctinfo)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLRect2_GetTypeInfo(IHTMLRect2 *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IDispatchEx_GetTypeInfo(&This->dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLRect2_GetIDsOfNames(IHTMLRect2 *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IDispatchEx_GetIDsOfNames(&This->dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLRect2_Invoke(IHTMLRect2 *iface, DISPID dispIdMember,
+        REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+        VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    return IDispatchEx_Invoke(&This->dispex.IDispatchEx_iface, dispIdMember, riid, lcid, wFlags,
+            pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLRect2_get_width(IHTMLRect2 *iface, FLOAT *p)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    nsresult nsres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    nsres = nsIDOMClientRect_GetWidth(This->nsrect, p);
+    if (NS_FAILED(nsres)) {
+        ERR("GetWidth failed: %08lx\n", nsres);
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI HTMLRect2_get_height(IHTMLRect2 *iface, FLOAT *p)
+{
+    HTMLRect *This = impl_from_IHTMLRect2(iface);
+    nsresult nsres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    nsres = nsIDOMClientRect_GetHeight(This->nsrect, p);
+    if (NS_FAILED(nsres)) {
+        ERR("GetHeight failed: %08lx\n", nsres);
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
 static const IHTMLRectVtbl HTMLRectVtbl = {
     HTMLRect_QueryInterface,
     HTMLRect_AddRef,
@@ -741,6 +829,24 @@ static const IHTMLRectVtbl HTMLRectVtbl = {
     HTMLRect_get_bottom
 };
 
+static const IHTMLRect2Vtbl HTMLRect2Vtbl = {
+    HTMLRect2_QueryInterface,
+    HTMLRect2_AddRef,
+    HTMLRect2_Release,
+    HTMLRect2_GetTypeInfoCount,
+    HTMLRect2_GetTypeInfo,
+    HTMLRect2_GetIDsOfNames,
+    HTMLRect2_Invoke,
+    HTMLRect2_get_width,
+    HTMLRect2_get_height,
+};
+
+void HTMLRect_init_dispex_info(dispex_data_t *info, compat_mode_t mode)
+{
+    if (mode >= COMPAT_MODE_IE9)
+        dispex_info_add_interface(info, IHTMLRect2_tid, NULL);
+}
+
 static const tid_t HTMLRect_iface_tids[] = {
     IHTMLRect_tid,
     0
@@ -749,7 +855,8 @@ static dispex_static_data_t HTMLRect_dispex = {
     L"ClientRect",
     NULL,
     IHTMLRect_tid,
-    HTMLRect_iface_tids
+    HTMLRect_iface_tids,
+    HTMLRect_init_dispex_info
 };
 
 static HRESULT create_html_rect(nsIDOMClientRect *nsrect, compat_mode_t compat_mode, IHTMLRect **ret)
@@ -761,6 +868,7 @@ static HRESULT create_html_rect(nsIDOMClientRect *nsrect, compat_mode_t compat_m
         return E_OUTOFMEMORY;
 
     rect->IHTMLRect_iface.lpVtbl = &HTMLRectVtbl;
+    rect->IHTMLRect2_iface.lpVtbl = &HTMLRect2Vtbl;
     rect->ref = 1;
 
     init_dispatch(&rect->dispex, (IUnknown*)&rect->IHTMLRect_iface, &HTMLRect_dispex, compat_mode);
diff --git a/dlls/mshtml/htmlframe.c b/dlls/mshtml/htmlframe.c
index e1b1562b0dc..38bb53dc551 100644
--- a/dlls/mshtml/htmlframe.c
+++ b/dlls/mshtml/htmlframe.c
@@ -48,9 +48,14 @@ static HRESULT set_frame_doc(HTMLFrameBase *frame, nsIDOMDocument *nsdoc)
         return E_FAIL;
 
     window = mozwindow_to_window(mozwindow);
-    if(!window && frame->element.node.doc->browser)
+    if(!window && frame->element.node.doc->browser) {
         hres = create_outer_window(frame->element.node.doc->browser, mozwindow,
                 frame->element.node.doc->outer_window, &window);
+
+        /* Don't hold ref to the created window; the parent keeps ref to it */
+        if(SUCCEEDED(hres))
+            IHTMLWindow2_Release(&window->base.IHTMLWindow2_iface);
+    }
     mozIDOMWindowProxy_Release(mozwindow);
     if(FAILED(hres))
         return hres;
diff --git a/dlls/mshtml/htmlimg.c b/dlls/mshtml/htmlimg.c
index c0333cab858..01cc8405f87 100644
--- a/dlls/mshtml/htmlimg.c
+++ b/dlls/mshtml/htmlimg.c
@@ -855,8 +855,10 @@ static ULONG WINAPI HTMLImageElementFactory_Release(IHTMLImageElementFactory *if
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
-    if(!ref)
+    if(!ref) {
+        release_dispex(&This->dispex);
         free(This);
+    }
 
     return ref;
 }
diff --git a/dlls/mshtml/htmllocation.c b/dlls/mshtml/htmllocation.c
index 5376b3b8329..d9e458d9c5f 100644
--- a/dlls/mshtml/htmllocation.c
+++ b/dlls/mshtml/htmllocation.c
@@ -36,32 +36,19 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 
-static HRESULT get_url(HTMLLocation *This, const WCHAR **ret)
+static inline HTMLOuterWindow *get_window(HTMLLocation *This)
 {
-    if(!This->window || !This->window->base.outer_window || !This->window->base.outer_window->url) {
-        FIXME("No current URL\n");
-        return E_NOTIMPL;
-    }
-
-    *ret = This->window->base.outer_window->url;
-    return S_OK;
+    return CONTAINING_RECORD(This, HTMLOuterWindow, location);
 }
 
 static IUri *get_uri(HTMLLocation *This)
 {
-    if(!This->window || !This->window->base.outer_window)
-        return NULL;
-    return This->window->base.outer_window->uri;
+    return get_window(This)->uri;
 }
 
 static HRESULT get_url_components(HTMLLocation *This, URL_COMPONENTSW *url)
 {
-    const WCHAR *doc_url;
-    HRESULT hres;
-
-    hres = get_url(This, &doc_url);
-    if(FAILED(hres))
-        return hres;
+    const WCHAR *doc_url = get_window(This)->url ? get_window(This)->url : L"about:blank";
 
     if(!InternetCrackUrlW(doc_url, 0, 0, url)) {
         FIXME("InternetCrackUrlW failed: 0x%08lx\n", GetLastError());
@@ -106,28 +93,13 @@ static HRESULT WINAPI HTMLLocation_QueryInterface(IHTMLLocation *iface, REFIID r
 static ULONG WINAPI HTMLLocation_AddRef(IHTMLLocation *iface)
 {
     HTMLLocation *This = impl_from_IHTMLLocation(iface);
-    LONG ref = InterlockedIncrement(&This->ref);
-
-    TRACE("(%p) ref=%ld\n", This, ref);
-
-    return ref;
+    return IHTMLWindow2_AddRef(&get_window(This)->base.IHTMLWindow2_iface);
 }
 
 static ULONG WINAPI HTMLLocation_Release(IHTMLLocation *iface)
 {
     HTMLLocation *This = impl_from_IHTMLLocation(iface);
-    LONG ref = InterlockedDecrement(&This->ref);
-
-    TRACE("(%p) ref=%ld\n", This, ref);
-
-    if(!ref) {
-        if(This->window)
-            This->window->location = NULL;
-        release_dispex(&This->dispex);
-        free(This);
-    }
-
-    return ref;
+    return IHTMLWindow2_Release(&get_window(This)->base.IHTMLWindow2_iface);
 }
 
 static HRESULT WINAPI HTMLLocation_GetTypeInfoCount(IHTMLLocation *iface, UINT *pctinfo)
@@ -167,12 +139,7 @@ static HRESULT WINAPI HTMLLocation_put_href(IHTMLLocation *iface, BSTR v)
 
     TRACE("(%p)->(%s)\n", This, debugstr_w(v));
 
-    if(!This->window || !This->window->base.outer_window) {
-        FIXME("No window available\n");
-        return E_FAIL;
-    }
-
-    return navigate_url(This->window->base.outer_window, v, This->window->base.outer_window->uri, BINDING_NAVIGATED);
+    return navigate_url(get_window(This), v, get_uri(This), BINDING_NAVIGATED);
 }
 
 static HRESULT WINAPI HTMLLocation_get_href(IHTMLLocation *iface, BSTR *p)
@@ -295,10 +262,8 @@ static HRESULT WINAPI HTMLLocation_get_protocol(IHTMLLocation *iface, BSTR *p)
     if(!p)
         return E_POINTER;
 
-    if(!(uri = get_uri(This))) {
-        FIXME("No current URI\n");
-        return E_NOTIMPL;
-    }
+    if(!(uri = get_uri(This)))
+        return (*p = SysAllocString(L"about:")) ? S_OK : E_OUTOFMEMORY;
 
     hres = IUri_GetSchemeName(uri, &protocol);
     if(FAILED(hres))
@@ -388,8 +353,8 @@ static HRESULT WINAPI HTMLLocation_get_hostname(IHTMLLocation *iface, BSTR *p)
         return E_POINTER;
 
     if(!(uri = get_uri(This))) {
-        FIXME("No current URI\n");
-        return E_NOTIMPL;
+        *p = NULL;
+        return S_OK;
     }
 
     hres = IUri_GetHost(uri, &hostname);
@@ -425,8 +390,8 @@ static HRESULT WINAPI HTMLLocation_get_port(IHTMLLocation *iface, BSTR *p)
         return E_POINTER;
 
     if(!(uri = get_uri(This))) {
-        FIXME("No current URI\n");
-        return E_NOTIMPL;
+        *p = NULL;
+        return S_OK;
     }
 
     hres = IUri_GetPort(uri, &port);
@@ -466,10 +431,8 @@ static HRESULT WINAPI HTMLLocation_get_pathname(IHTMLLocation *iface, BSTR *p)
     if(!p)
         return E_POINTER;
 
-    if(!(uri = get_uri(This))) {
-        FIXME("No current URI\n");
-        return E_NOTIMPL;
-    }
+    if(!(uri = get_uri(This)))
+        return (*p = SysAllocString(L"blank")) ? S_OK : E_OUTOFMEMORY;
 
     hres = IUri_GetPath(uri, &path);
     if(FAILED(hres))
@@ -504,8 +467,8 @@ static HRESULT WINAPI HTMLLocation_get_search(IHTMLLocation *iface, BSTR *p)
         return E_POINTER;
 
     if(!(uri = get_uri(This))) {
-        FIXME("No current URI\n");
-        return E_NOTIMPL;
+        *p = NULL;
+        return S_OK;
     }
 
     hres = IUri_GetQuery(uri, &query);
@@ -529,11 +492,6 @@ static HRESULT WINAPI HTMLLocation_put_hash(IHTMLLocation *iface, BSTR v)
 
     TRACE("(%p)->(%s)\n", This, debugstr_w(v));
 
-    if(!This->window || !This->window->base.outer_window) {
-        FIXME("No window available\n");
-        return E_FAIL;
-    }
-
     if(hash[0] != '#') {
         unsigned size = (1 /* # */ + wcslen(v) + 1) * sizeof(WCHAR);
         if(!(hash = malloc(size)))
@@ -542,7 +500,7 @@ static HRESULT WINAPI HTMLLocation_put_hash(IHTMLLocation *iface, BSTR v)
         memcpy(hash + 1, v, size - sizeof(WCHAR));
     }
 
-    hres = navigate_url(This->window->base.outer_window, hash, This->window->base.outer_window->uri, BINDING_NAVIGATED);
+    hres = navigate_url(get_window(This), hash, get_uri(This), BINDING_NAVIGATED);
 
     if(hash != v)
         free(hash);
@@ -562,8 +520,8 @@ static HRESULT WINAPI HTMLLocation_get_hash(IHTMLLocation *iface, BSTR *p)
         return E_POINTER;
 
     if(!(uri = get_uri(This))) {
-        FIXME("No current URI\n");
-        return E_NOTIMPL;
+        *p = NULL;
+        return S_OK;
     }
 
     hres = IUri_GetFragment(uri, &hash);
@@ -585,18 +543,13 @@ static HRESULT WINAPI HTMLLocation_reload(IHTMLLocation *iface, VARIANT_BOOL fla
 
     TRACE("(%p)->(%x)\n", This, flag);
 
-    if(!This->window) {
-        FIXME("No window available\n");
-        return E_FAIL;
-    }
-
     /* reload is supposed to fail if called from a script with different origin, but IE doesn't care */
-    if(!is_main_content_window(This->window->base.outer_window)) {
+    if(!is_main_content_window(get_window(This))) {
         FIXME("Unsupported on iframe\n");
         return E_NOTIMPL;
     }
 
-    return reload_page(This->window->base.outer_window);
+    return reload_page(get_window(This));
 }
 
 static HRESULT WINAPI HTMLLocation_replace(IHTMLLocation *iface, BSTR bstr)
@@ -605,13 +558,7 @@ static HRESULT WINAPI HTMLLocation_replace(IHTMLLocation *iface, BSTR bstr)
 
     TRACE("(%p)->(%s)\n", This, debugstr_w(bstr));
 
-    if(!This->window || !This->window->base.outer_window) {
-        FIXME("No window available\n");
-        return E_FAIL;
-    }
-
-    return navigate_url(This->window->base.outer_window, bstr, This->window->base.outer_window->uri,
-            BINDING_NAVIGATED|BINDING_REPLACE);
+    return navigate_url(get_window(This), bstr, get_uri(This), BINDING_NAVIGATED | BINDING_REPLACE);
 }
 
 static HRESULT WINAPI HTMLLocation_assign(IHTMLLocation *iface, BSTR bstr)
@@ -665,28 +612,16 @@ static const tid_t HTMLLocation_iface_tids[] = {
     0
 };
 static dispex_static_data_t HTMLLocation_dispex = {
-    L"Object",
+    L"Location",
     NULL,
     DispHTMLLocation_tid,
     HTMLLocation_iface_tids
 };
 
-
-HRESULT HTMLLocation_Create(HTMLInnerWindow *window, HTMLLocation **ret)
+void HTMLLocation_Init(HTMLLocation *location)
 {
-    HTMLLocation *location;
-
-    location = malloc(sizeof(*location));
-    if(!location)
-        return E_OUTOFMEMORY;
-
     location->IHTMLLocation_iface.lpVtbl = &HTMLLocationVtbl;
-    location->ref = 1;
-    location->window = window;
 
     init_dispatch(&location->dispex, (IUnknown*)&location->IHTMLLocation_iface, &HTMLLocation_dispex,
-                  dispex_compat_mode(&window->event_target.dispex));
-
-    *ret = location;
-    return S_OK;
+                  COMPAT_MODE_QUIRKS);
 }
diff --git a/dlls/mshtml/htmlselect.c b/dlls/mshtml/htmlselect.c
index 4dfbbd916a7..c5610b41a1d 100644
--- a/dlls/mshtml/htmlselect.c
+++ b/dlls/mshtml/htmlselect.c
@@ -646,7 +646,6 @@ static dispex_static_data_t HTMLOptionElementFactory_dispex = {
     &HTMLOptionElementFactory_dispex_vtbl,
     IHTMLOptionElementFactory_tid,
     HTMLOptionElementFactory_iface_tids,
-    HTMLElement_init_dispex_info
 };
 
 HRESULT HTMLOptionElementFactory_Create(HTMLInnerWindow *window, HTMLOptionElementFactory **ret_ptr)
diff --git a/dlls/mshtml/htmlwindow.c b/dlls/mshtml/htmlwindow.c
index 732f5ec7316..ed497eacf4e 100644
--- a/dlls/mshtml/htmlwindow.c
+++ b/dlls/mshtml/htmlwindow.c
@@ -67,19 +67,13 @@ static inline BOOL is_outer_window(HTMLWindow *window)
     return &window->outer_window->base == window;
 }
 
-static HRESULT get_location(HTMLInnerWindow *This, HTMLLocation **ret)
+static void get_location(HTMLOuterWindow *This, HTMLLocation **ret)
 {
-    if(!This->location) {
-        HRESULT hres;
-
-        hres = HTMLLocation_Create(This, &This->location);
-        if(FAILED(hres))
-            return hres;
-    }
+    if(!This->location.dispex.outer)
+        HTMLLocation_Init(&This->location);
 
-    IHTMLLocation_AddRef(&This->location->IHTMLLocation_iface);
-    *ret = This->location;
-    return S_OK;
+    IHTMLLocation_AddRef(&This->location.IHTMLLocation_iface);
+    *ret = &This->location;
 }
 
 void get_top_window(HTMLOuterWindow *window, HTMLOuterWindow **ret)
@@ -133,6 +127,9 @@ static void detach_inner_window(HTMLInnerWindow *window)
     if(doc)
         detach_document_node(doc);
 
+    if(outer_window && outer_window->location.dispex.outer)
+        dispex_unlink(&outer_window->location.dispex);
+
     abort_window_bindings(window);
     remove_target_tasks(window->task_magic);
     release_script_hosts(window);
@@ -237,6 +234,9 @@ static void release_outer_window(HTMLOuterWindow *This)
     if(This->base.inner_window)
         detach_inner_window(This->base.inner_window);
 
+    if(This->location.dispex.outer)
+        release_dispex(&This->location.dispex);
+
     if(This->frame_element)
         This->frame_element->content_window = NULL;
 
@@ -269,11 +269,6 @@ static void release_inner_window(HTMLInnerWindow *This)
         free(This->global_props[i].name);
     free(This->global_props);
 
-    if(This->location) {
-        This->location->window = NULL;
-        IHTMLLocation_Release(&This->location->IHTMLLocation_iface);
-    }
-
     if(This->image_factory) {
         This->image_factory->window = NULL;
         IHTMLImageElementFactory_Release(&This->image_factory->IHTMLImageElementFactory_iface);
@@ -805,14 +800,10 @@ static HRESULT WINAPI HTMLWindow2_get_location(IHTMLWindow2 *iface, IHTMLLocatio
 {
     HTMLWindow *This = impl_from_IHTMLWindow2(iface);
     HTMLLocation *location;
-    HRESULT hres;
 
     TRACE("(%p)->(%p)\n", This, p);
 
-    hres = get_location(This->inner_window, &location);
-    if(FAILED(hres))
-        return hres;
-
+    get_location(This->outer_window, &location);
     *p = &location->IHTMLLocation_iface;
     return S_OK;
 }
@@ -2038,6 +2029,11 @@ static HRESULT WINAPI HTMLWindow5_get_XMLHttpRequest(IHTMLWindow5 *iface, VARIAN
 
     TRACE("(%p)->(%p)\n", This, p);
 
+    if(This->outer_window->readystate == READYSTATE_UNINITIALIZED) {
+        V_VT(p) = VT_EMPTY;
+        return S_OK;
+    }
+
     if(!window->xhr_factory) {
         HRESULT hres;
 
@@ -3593,8 +3589,6 @@ static HRESULT WINAPI WindowDispEx_GetDispID(IDispatchEx *iface, BSTR bstrName,
         if(SUCCEEDED(hres) && frame) {
             global_prop_t *prop;
 
-            IHTMLWindow2_Release(&frame->base.IHTMLWindow2_iface);
-
             prop = alloc_global_prop(window, GLOBAL_FRAMEVAR, bstrName);
             if(!prop)
                 return E_OUTOFMEMORY;
@@ -3919,9 +3913,7 @@ static HRESULT IHTMLWindow2_location_hook(DispatchEx *dispex, WORD flags, DISPPA
 
     TRACE("forwarding to location.href\n");
 
-    hres = get_location(This, &location);
-    if(FAILED(hres))
-        return hres;
+    get_location(This->base.outer_window, &location);
 
     hres = IDispatchEx_InvokeEx(&location->dispex.IDispatchEx_iface, DISPID_VALUE, 0, flags, dp, res, ei, caller);
     IHTMLLocation_Release(&location->IHTMLLocation_iface);
diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index 14c34f2f36a..a45a2c111dc 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -407,6 +407,7 @@ void set_statustext(HTMLDocumentObj* doc, INT id, LPCWSTR arg)
     if(!p) {
         len = 255;
         p = malloc(len * sizeof(WCHAR));
+        if (!p) return;
         len = LoadStringW(hInst, id, p, len) + 1;
         p = realloc(p, len * sizeof(WCHAR));
         if(InterlockedCompareExchangePointer((void**)&status_strings[index], p, NULL)) {
@@ -420,6 +421,7 @@ void set_statustext(HTMLDocumentObj* doc, INT id, LPCWSTR arg)
 
         len = lstrlenW(p) + lstrlenW(arg) - 1;
         buf = malloc(len * sizeof(WCHAR));
+        if (!buf) return;
 
         swprintf(buf, len, p, arg);
 
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index d5a9e02aa13..bec982a75fc 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -237,6 +237,7 @@ typedef struct EventTarget EventTarget;
     XIID(IHTMLPerformanceTiming) \
     XIID(IHTMLPluginsCollection) \
     XIID(IHTMLRect) \
+    XIID(IHTMLRect2) \
     XIID(IHTMLRectCollection) \
     XIID(IHTMLScreen) \
     XIID(IHTMLScriptElement) \
@@ -489,10 +490,6 @@ typedef struct {
 struct HTMLLocation {
     DispatchEx dispex;
     IHTMLLocation IHTMLLocation_iface;
-
-    LONG ref;
-
-    HTMLInnerWindow *window;
 };
 
 typedef struct {
@@ -575,6 +572,7 @@ struct HTMLOuterWindow {
     unsigned readystate_pending;
 
     HTMLInnerWindow *pending_window;
+    HTMLLocation location;
     IMoniker *mon;
     IUri *uri;
     IUri *uri_nofrag;
@@ -618,8 +616,6 @@ struct HTMLInnerWindow {
 
     LONG task_magic;
 
-    HTMLLocation *location;
-
     IMoniker *mon;
     nsChannelBSC *bscallback;
     struct list bindings;
@@ -993,7 +989,7 @@ void get_top_window(HTMLOuterWindow*,HTMLOuterWindow**) DECLSPEC_HIDDEN;
 HRESULT HTMLOptionElementFactory_Create(HTMLInnerWindow*,HTMLOptionElementFactory**) DECLSPEC_HIDDEN;
 HRESULT HTMLImageElementFactory_Create(HTMLInnerWindow*,HTMLImageElementFactory**) DECLSPEC_HIDDEN;
 HRESULT HTMLXMLHttpRequestFactory_Create(HTMLInnerWindow*,HTMLXMLHttpRequestFactory**) DECLSPEC_HIDDEN;
-HRESULT HTMLLocation_Create(HTMLInnerWindow*,HTMLLocation**) DECLSPEC_HIDDEN;
+void HTMLLocation_Init(HTMLLocation*) DECLSPEC_HIDDEN;
 HRESULT create_navigator(compat_mode_t,IOmNavigator**) DECLSPEC_HIDDEN;
 HRESULT create_html_screen(compat_mode_t,IHTMLScreen**) DECLSPEC_HIDDEN;
 HRESULT create_performance(HTMLInnerWindow*,IHTMLPerformance**) DECLSPEC_HIDDEN;
diff --git a/dlls/mshtml/nsembed.c b/dlls/mshtml/nsembed.c
index b7518f55ef9..b6d7b53f815 100644
--- a/dlls/mshtml/nsembed.c
+++ b/dlls/mshtml/nsembed.c
@@ -2268,7 +2268,7 @@ static HRESULT init_browser(GeckoBrowser *browser)
     nsres = nsIWebBrowser_QueryInterface(browser->webbrowser, &IID_nsIScrollable, (void**)&scrollable);
     if(NS_SUCCEEDED(nsres)) {
         nsres = nsIScrollable_SetDefaultScrollbarPreferences(scrollable,
-                ScrollOrientation_Y, Scrollbar_Always);
+                ScrollOrientation_Y, Scrollbar_Auto);
         if(NS_FAILED(nsres))
             ERR("Could not set default Y scrollbar prefs: %08lx\n", nsres);
 
diff --git a/dlls/mshtml/oleobj.c b/dlls/mshtml/oleobj.c
index d1853435606..c01c18b5fa8 100644
--- a/dlls/mshtml/oleobj.c
+++ b/dlls/mshtml/oleobj.c
@@ -363,7 +363,7 @@ static void update_hostinfo(HTMLDocumentObj *This, DOCHOSTUIINFO *hostinfo)
     nsres = nsIWebBrowser_QueryInterface(This->nscontainer->webbrowser, &IID_nsIScrollable, (void**)&scrollable);
     if(NS_SUCCEEDED(nsres)) {
         nsres = nsIScrollable_SetDefaultScrollbarPreferences(scrollable, ScrollOrientation_Y,
-                (hostinfo->dwFlags & DOCHOSTUIFLAG_SCROLL_NO) ? Scrollbar_Never : Scrollbar_Always);
+                (hostinfo->dwFlags & DOCHOSTUIFLAG_SCROLL_NO) ? Scrollbar_Never : Scrollbar_Auto);
         if(NS_FAILED(nsres))
             ERR("Could not set default Y scrollbar prefs: %08lx\n", nsres);
 
diff --git a/dlls/mshtml/script.c b/dlls/mshtml/script.c
index 5321080a8f9..8b1c1f11938 100644
--- a/dlls/mshtml/script.c
+++ b/dlls/mshtml/script.c
@@ -91,12 +91,12 @@ struct ScriptHost {
 
 static ScriptHost *get_elem_script_host(HTMLInnerWindow*,HTMLScriptElement*);
 
-static BOOL set_script_prop(ScriptHost *script_host, DWORD property, VARIANT *val)
+static BOOL set_script_prop(IActiveScript *script, DWORD property, VARIANT *val)
 {
     IActiveScriptProperty *script_prop;
     HRESULT hres;
 
-    hres = IActiveScript_QueryInterface(script_host->script, &IID_IActiveScriptProperty,
+    hres = IActiveScript_QueryInterface(script, &IID_IActiveScriptProperty,
             (void**)&script_prop);
     if(FAILED(hres)) {
         WARN("Could not get IActiveScriptProperty iface: %08lx\n", hres);
@@ -113,7 +113,7 @@ static BOOL set_script_prop(ScriptHost *script_host, DWORD property, VARIANT *va
     return TRUE;
 }
 
-static BOOL init_script_engine(ScriptHost *script_host)
+static BOOL init_script_engine(ScriptHost *script_host, IActiveScript *script)
 {
     compat_mode_t compat_mode;
     IObjectSafety *safety;
@@ -122,13 +122,13 @@ static BOOL init_script_engine(ScriptHost *script_host)
     VARIANT var;
     HRESULT hres;
 
-    hres = IActiveScript_QueryInterface(script_host->script, &IID_IActiveScriptParse, (void**)&script_host->parse);
+    hres = IActiveScript_QueryInterface(script, &IID_IActiveScriptParse, (void**)&script_host->parse);
     if(FAILED(hres)) {
         WARN("Could not get IActiveScriptParse: %08lx\n", hres);
         return FALSE;
     }
 
-    hres = IActiveScript_QueryInterface(script_host->script, &IID_IObjectSafety, (void**)&safety);
+    hres = IActiveScript_QueryInterface(script, &IID_IObjectSafety, (void**)&safety);
     if(FAILED(hres)) {
         FIXME("Could not get IObjectSafety: %08lx\n", hres);
         return FALSE;
@@ -162,16 +162,16 @@ static BOOL init_script_engine(ScriptHost *script_host)
     }
     V_VT(&var) = VT_I4;
     V_I4(&var) = script_mode;
-    if(!set_script_prop(script_host, SCRIPTPROP_INVOKEVERSIONING, &var) && (script_mode & SCRIPTLANGUAGEVERSION_HTML)) {
+    if(!set_script_prop(script, SCRIPTPROP_INVOKEVERSIONING, &var) && (script_mode & SCRIPTLANGUAGEVERSION_HTML)) {
         /* If this failed, we're most likely using native jscript. */
         WARN("Failed to set script mode to HTML version.\n");
         V_I4(&var) = compat_mode < COMPAT_MODE_IE8 ? SCRIPTLANGUAGEVERSION_5_7 : SCRIPTLANGUAGEVERSION_5_8;
-        set_script_prop(script_host, SCRIPTPROP_INVOKEVERSIONING, &var);
+        set_script_prop(script, SCRIPTPROP_INVOKEVERSIONING, &var);
     }
 
     V_VT(&var) = VT_BOOL;
     V_BOOL(&var) = VARIANT_TRUE;
-    set_script_prop(script_host, SCRIPTPROP_HACK_TRIDENTEVENTSINK, &var);
+    set_script_prop(script, SCRIPTPROP_HACK_TRIDENTEVENTSINK, &var);
 
     hres = IActiveScriptParse_InitNew(script_host->parse);
     if(FAILED(hres)) {
@@ -179,36 +179,60 @@ static BOOL init_script_engine(ScriptHost *script_host)
         return FALSE;
     }
 
-    hres = IActiveScript_SetScriptSite(script_host->script, &script_host->IActiveScriptSite_iface);
+    hres = IActiveScript_SetScriptSite(script, &script_host->IActiveScriptSite_iface);
     if(FAILED(hres)) {
         WARN("SetScriptSite failed: %08lx\n", hres);
-        IActiveScript_Close(script_host->script);
+        IActiveScript_Close(script);
         return FALSE;
     }
 
-    hres = IActiveScript_GetScriptState(script_host->script, &state);
+    hres = IActiveScript_GetScriptState(script, &state);
     if(FAILED(hres))
         WARN("GetScriptState failed: %08lx\n", hres);
     else if(state != SCRIPTSTATE_INITIALIZED)
         FIXME("state = %x\n", state);
 
-    hres = IActiveScript_SetScriptState(script_host->script, SCRIPTSTATE_STARTED);
+    hres = IActiveScript_SetScriptState(script, SCRIPTSTATE_STARTED);
     if(FAILED(hres)) {
         WARN("Starting script failed: %08lx\n", hres);
         return FALSE;
     }
 
-    hres = IActiveScript_AddNamedItem(script_host->script, L"window",
+    hres = IActiveScript_AddNamedItem(script, L"window",
             SCRIPTITEM_ISVISIBLE|SCRIPTITEM_ISSOURCE|SCRIPTITEM_GLOBALMEMBERS);
     if(SUCCEEDED(hres)) {
+        ScriptHost *first_host;
+
         V_VT(&var) = VT_BOOL;
         V_BOOL(&var) = VARIANT_TRUE;
-        set_script_prop(script_host, SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION, &var);
+
+        LIST_FOR_EACH_ENTRY(first_host, &script_host->window->script_hosts, ScriptHost, entry) {
+            if(first_host->script) {
+                V_BOOL(&var) = VARIANT_FALSE;
+                break;
+            }
+        }
+        set_script_prop(script, SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION, &var);
+
+        /* if this was second engine initialized, also set it to first engine, since it used to be TRUE */
+        if(!V_BOOL(&var)) {
+            struct list *iter = &first_host->entry;
+            BOOL is_second_init = TRUE;
+
+            while((iter = list_next(&script_host->window->script_hosts, iter))) {
+                if(LIST_ENTRY(iter, ScriptHost, entry)->script) {
+                    is_second_init = FALSE;
+                    break;
+                }
+            }
+            if(is_second_init)
+                set_script_prop(first_host->script, SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION, &var);
+        }
     }else {
        WARN("AddNamedItem failed: %08lx\n", hres);
     }
 
-    hres = IActiveScript_QueryInterface(script_host->script, &IID_IActiveScriptParseProcedure2,
+    hres = IActiveScript_QueryInterface(script, &IID_IActiveScriptParseProcedure2,
                                         (void**)&script_host->parse_proc);
     if(FAILED(hres)) {
         /* FIXME: QI for IActiveScriptParseProcedure */
@@ -690,6 +714,7 @@ static const IServiceProviderVtbl ASServiceProviderVtbl = {
 
 static ScriptHost *create_script_host(HTMLInnerWindow *window, const GUID *guid)
 {
+    IActiveScript *script;
     ScriptHost *ret;
     HRESULT hres;
 
@@ -711,11 +736,15 @@ static ScriptHost *create_script_host(HTMLInnerWindow *window, const GUID *guid)
     list_add_tail(&window->script_hosts, &ret->entry);
 
     hres = CoCreateInstance(&ret->guid, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
-            &IID_IActiveScript, (void**)&ret->script);
+            &IID_IActiveScript, (void**)&script);
     if(FAILED(hres))
         WARN("Could not load script engine: %08lx\n", hres);
-    else if(!init_script_engine(ret))
-        release_script_engine(ret);
+    else {
+        BOOL succeeded = init_script_engine(ret, script);
+        ret->script = script;
+        if(!succeeded)
+            release_script_engine(ret);
+    }
 
     return ret;
 }
diff --git a/dlls/mshtml/tests/documentmode.js b/dlls/mshtml/tests/documentmode.js
index 760d8db5e38..cd639712a9f 100644
--- a/dlls/mshtml/tests/documentmode.js
+++ b/dlls/mshtml/tests/documentmode.js
@@ -557,6 +557,23 @@ sync_test("stylesheet_props", function() {
     test_exposed("rules", true);
 });
 
+sync_test("rect_props", function() {
+    document.body.innerHTML = '<div>test</div>';
+    var elem = document.body.firstChild;
+    var rect = elem.getBoundingClientRect();
+    function test_exposed(prop, expect) {
+        if(expect)
+            ok(prop in rect, prop + " not found in rect object.");
+        else
+            ok(!(prop in rect), prop + " found in rect object.");
+    }
+
+    var v = document.documentMode;
+
+    test_exposed("width", v >= 9);
+    test_exposed("height", v >= 9);
+});
+
 sync_test("xhr open", function() {
     var e = false;
     try {
diff --git a/dlls/mshtml/tests/dom.c b/dlls/mshtml/tests/dom.c
index 6a960bfa21f..39af8faa8d5 100644
--- a/dlls/mshtml/tests/dom.c
+++ b/dlls/mshtml/tests/dom.c
@@ -1350,6 +1350,7 @@ static IHTMLDocument2 *_get_doc_node(unsigned line, IHTMLDocument2 *doc)
     hres = IHTMLWindow2_get_document(window, &ret);
     ok_(__FILE__,line)(hres == S_OK, "get_document failed: %08lx\n", hres);
     ok_(__FILE__,line)(ret != NULL, "document = NULL\n");
+    IHTMLWindow2_Release(window);
 
     return ret;
 }
@@ -6313,6 +6314,7 @@ static void test_location(IHTMLDocument2 *doc)
     ok(hres == S_OK, "get_location failed: %08lx\n", hres);
     ok(location == location2, "location != location2\n");
     IHTMLLocation_Release(location2);
+    IHTMLWindow2_Release(window);
 
     test_ifaces((IUnknown*)location, location_iids);
     test_disp2((IUnknown*)location, &DIID_DispHTMLLocation, &IID_IHTMLLocation, NULL, L"about:blank");
@@ -7564,6 +7566,7 @@ static void test_xhr(IHTMLDocument2 *doc)
     SysFreeString(str);
 
     IHTMLWindow2_Release(window);
+    IDispatchEx_Release(dispex);
 }
 
 static void test_defaults(IHTMLDocument2 *doc)
@@ -10984,7 +10987,7 @@ static IHTMLDocument2 *create_docfrag(IHTMLDocument2 *doc)
 static void test_docfrag(IHTMLDocument2 *doc)
 {
     IHTMLDocument2 *frag, *owner_doc, *doc_node;
-    IHTMLElement *div, *body, *br;
+    IHTMLElement *div, *main_body, *frag_body, *br,*html;
     IHTMLElementCollection *col;
     IHTMLLocation *location;
     HRESULT hres;
@@ -10998,20 +11001,38 @@ static void test_docfrag(IHTMLDocument2 *doc)
         ET_BR
     };
 
+    static const elem_type_t empty_types[] = {};
+
+    static const elem_type_t frag_types[] = {
+            ET_HTML,
+            ET_DIV,
+            ET_DIV,
+            ET_BODY
+    };
+
     frag = create_docfrag(doc);
 
     test_disp((IUnknown*)frag, &DIID_DispHTMLDocument, &CLSID_HTMLDocument, L"[object]");
 
-    body = (void*)0xdeadbeef;
-    hres = IHTMLDocument2_get_body(frag, &body);
+    frag_body = (void*)0xdeadbeef;
+    hres = IHTMLDocument2_get_body(frag, &frag_body);
     ok(hres == S_OK, "get_body failed: %08lx\n", hres);
-    ok(!body, "body != NULL\n");
+    ok(!frag_body, "body != NULL\n");
 
     location = (void*)0xdeadbeef;
     hres = IHTMLDocument2_get_location(frag, &location);
     ok(hres == E_UNEXPECTED, "get_location failed: %08lx\n", hres);
     ok(location == (void*)0xdeadbeef, "location changed\n");
 
+    col = NULL;
+    hres = IHTMLDocument2_get_all(frag, &col);
+    ok(hres == S_OK, "get_all failed: %08lx\n", hres);
+    ok(col != NULL, "got null elements collection\n");
+    if (col) {
+        test_elem_collection((IUnknown *) col, empty_types, ARRAY_SIZE(empty_types));
+        IHTMLElementCollection_Release(col);
+    }
+
     br = test_create_elem(doc, L"BR");
     test_elem_source_index(br, -1);
     test_node_append_child((IUnknown*)frag, (IUnknown*)br);
@@ -11030,6 +11051,52 @@ static void test_docfrag(IHTMLDocument2 *doc)
     test_elem_collection((IUnknown*)col, all_types, ARRAY_SIZE(all_types));
     IHTMLElementCollection_Release(col);
 
+    html = test_create_elem(doc, L"HTML");
+    test_elem_source_index(html, -1);
+    test_node_append_child((IUnknown*)frag, (IUnknown*)html);
+    test_elem_source_index(html, 0);
+
+    div = test_create_elem(doc, L"DIV");
+    test_elem_source_index(div, -1);
+    test_node_append_child((IUnknown*)html, (IUnknown*)div);
+    test_elem_source_index(div, 1);
+    IHTMLElement_Release(div);
+
+    div = test_create_elem(doc, L"DIV");
+    test_elem_source_index(div, -1);
+    test_node_append_child((IUnknown*)html, (IUnknown*)div);
+    test_elem_source_index(div, 2);
+
+    frag_body = test_create_elem(doc, L"BODY");
+    test_elem_source_index(frag_body, -1);
+    test_node_append_child((IUnknown*)div, (IUnknown*)frag_body);
+    test_elem_source_index(frag_body, 3);
+    IHTMLElement_Release(frag_body);
+    IHTMLElement_Release(div);
+    IHTMLElement_Release(html);
+
+    hres = IHTMLDocument2_get_body(doc, &main_body);
+    ok(hres == S_OK, "get_body failed: %08lx\n", hres);
+    ok(main_body != NULL, "body == NULL\n");
+
+    hres = IHTMLDocument2_get_body(frag, &frag_body);
+    ok(hres == S_OK, "get_body failed: %08lx\n", hres);
+    ok(frag_body != NULL, "body == NULL\n");
+    if (frag_body) {
+        ok(!iface_cmp((IUnknown *) frag_body, (IUnknown *) main_body), "frag_body == main_body\n");
+        IHTMLElement_Release(frag_body);
+    }
+    IHTMLElement_Release(main_body);
+
+    col = NULL;
+    hres = IHTMLDocument2_get_all(frag, &col);
+    ok(hres == S_OK, "get_all failed: %08lx\n", hres);
+    ok(col != NULL, "got null elements collection\n");
+    if (col) {
+        test_elem_collection((IUnknown *) col, frag_types, ARRAY_SIZE(frag_types));
+        IHTMLElementCollection_Release(col);
+    }
+
     div = test_create_elem(frag, L"div");
     owner_doc = get_owner_doc((IUnknown*)div);
     doc_node = get_doc_node(doc);
@@ -11733,13 +11800,27 @@ static void test_quirks_mode(void)
 
 static void test_document_mode_lock(void)
 {
+    IHTMLOptionElementFactory *option, *option2;
+    IHTMLDocument2 *doc, *doc_node, *doc_node2;
+    IHTMLImageElementFactory *image, *image2;
+    IOmNavigator *navigator, *navigator2;
+    IHTMLLocation *location, *location2;
+    IHTMLPerformance *perf, *perf2;
+    IOmHistory *history, *history2;
+    IHTMLScreen *screen, *screen2;
     IEventTarget *event_target;
     IPersistStreamInit *init;
-    IHTMLDocument2 *doc;
+    IHTMLWindow7 *window7;
+    IHTMLWindow5 *window5;
+    IHTMLWindow2 *window;
+    IDispatchEx *dispex;
     IStream *stream;
+    DISPID dispid;
     HRESULT hres;
     HGLOBAL mem;
+    VARIANT var;
     SIZE_T len;
+    BSTR bstr;
     MSG msg;
 
     notif_doc = doc = create_document();
@@ -11751,6 +11832,57 @@ static void test_document_mode_lock(void)
     ok(hres == E_NOINTERFACE, "QueryInterface(IID_IEventTarget) returned %08lx.\n", hres);
     ok(event_target == NULL, "event_target != NULL\n");
 
+    hres = IHTMLDocument2_get_parentWindow(doc, &window);
+    ok(hres == S_OK, "get_parentWindow failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_document(window, &doc_node);
+    ok(hres == S_OK, "get_document failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_location(window, &location);
+    ok(hres == S_OK, "get_location failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_navigator(window, &navigator);
+    ok(hres == S_OK, "get_navigator failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_history(window, &history);
+    ok(hres == S_OK, "get_history failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_screen(window, &screen);
+    ok(hres == S_OK, "get_screen failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_Image(window, &image);
+    ok(hres == S_OK, "get_image failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_Option(window, &option);
+    ok(hres == S_OK, "get_option failed: %08lx\n", hres);
+
+    V_VT(&var) = VT_NULL;
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow5, (void**)&window5);
+    ok(hres == S_OK, "Could not get IHTMLWindow5: %08lx\n", hres);
+    hres = IHTMLWindow5_get_XMLHttpRequest(window5, &var);
+    ok(hres == S_OK, "get_XMLHttpRequest failed: %08lx\n", hres);
+    ok(V_VT(&var) == VT_EMPTY, "V_VT(XMLHttpRequest) = %d\n", V_VT(&var));
+    IHTMLWindow5_Release(window5);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow7, (void**)&window7);
+    ok(hres == S_OK, "Could not get IHTMLWindow7: %08lx\n", hres);
+    hres = IHTMLWindow7_get_performance(window7, &var);
+    ok(hres == S_OK, "get_performance failed: %08lx\n", hres);
+    ok(V_VT(&var) == VT_DISPATCH, "V_VT(performance) = %d\n", V_VT(&var));
+    hres = IDispatch_QueryInterface(V_DISPATCH(&var), &IID_IHTMLPerformance, (void**)&perf);
+    ok(hres == S_OK, "Could not get IHTMLPerformance: %08lx\n", hres);
+    IHTMLWindow7_Release(window7);
+    IHTMLWindow2_Release(window);
+    VariantClear(&var);
+
+    bstr = SysAllocString(L"wineTestProp");
+    hres = IHTMLLocation_QueryInterface(location, &IID_IDispatchEx, (void**)&dispex);
+    ok(hres == S_OK, "Could not get IDispatchEx: %08lx\n", hres);
+    hres = IDispatchEx_GetDispID(dispex, bstr, fdexNameEnsure, &dispid);
+    ok(hres == S_OK, "GetDispID(wineTestProp) returned: %08lx\n", hres);
+    IDispatchEx_Release(dispex);
+    SysFreeString(bstr);
+
     len = strlen(doc_blank_ie9);
     mem = GlobalAlloc(0, len);
     memcpy(mem, doc_blank_ie9, len);
@@ -11777,6 +11909,68 @@ static void test_document_mode_lock(void)
     ok(event_target != NULL, "event_target == NULL\n");
     IEventTarget_Release(event_target);
 
+    hres = IHTMLDocument2_get_parentWindow(doc, &window);
+    ok(hres == S_OK, "get_parentWindow failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_document(window, &doc_node2);
+    ok(hres == S_OK, "get_document failed: %08lx\n", hres);
+    ok(doc_node != doc_node2, "doc_node == doc_node2\n");
+    IHTMLDocument2_Release(doc_node2);
+    IHTMLDocument2_Release(doc_node);
+
+    hres = IHTMLWindow2_get_location(window, &location2);
+    ok(hres == S_OK, "get_location failed: %08lx\n", hres);
+    ok(location == location2, "location != location2\n");
+
+    bstr = SysAllocString(L"wineTestProp");
+    hres = IHTMLLocation_GetIDsOfNames(location2, &IID_NULL, &bstr, 1, 0, &dispid);
+    ok(hres == DISP_E_UNKNOWNNAME, "GetIDsOfNames(wineTestProp) returned: %08lx\n", hres);
+    IHTMLLocation_Release(location2);
+    IHTMLLocation_Release(location);
+    SysFreeString(bstr);
+
+    hres = IHTMLWindow2_get_navigator(window, &navigator2);
+    ok(hres == S_OK, "get_navigator failed: %08lx\n", hres);
+    ok(navigator != navigator2, "navigator == navigator2\n");
+    IOmNavigator_Release(navigator2);
+    IOmNavigator_Release(navigator);
+
+    hres = IHTMLWindow2_get_history(window, &history2);
+    ok(hres == S_OK, "get_history failed: %08lx\n", hres);
+    ok(history != history2, "history == history2\n");
+    IOmHistory_Release(history2);
+    IOmHistory_Release(history);
+
+    hres = IHTMLWindow2_get_screen(window, &screen2);
+    ok(hres == S_OK, "get_screen failed: %08lx\n", hres);
+    ok(screen != screen2, "screen == screen2\n");
+    IHTMLScreen_Release(screen2);
+    IHTMLScreen_Release(screen);
+
+    hres = IHTMLWindow2_get_Image(window, &image2);
+    ok(hres == S_OK, "get_image failed: %08lx\n", hres);
+    ok(image != image2, "image == image2\n");
+    IHTMLImageElementFactory_Release(image2);
+    IHTMLImageElementFactory_Release(image);
+
+    hres = IHTMLWindow2_get_Option(window, &option2);
+    ok(hres == S_OK, "get_option failed: %08lx\n", hres);
+    ok(option != option2, "option == option2\n");
+    IHTMLOptionElementFactory_Release(option2);
+    IHTMLOptionElementFactory_Release(option);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow7, (void**)&window7);
+    ok(hres == S_OK, "Could not get IHTMLWindow7: %08lx\n", hres);
+    hres = IHTMLWindow7_get_performance(window7, &var);
+    ok(hres == S_OK, "get_performance failed: %08lx\n", hres);
+    ok(V_VT(&var) == VT_DISPATCH, "V_VT(performance) = %d\n", V_VT(&var));
+    hres = IDispatch_QueryInterface(V_DISPATCH(&var), &IID_IHTMLPerformance, (void**)&perf2);
+    ok(hres == S_OK, "Could not get IHTMLPerformance: %08lx\n", hres);
+    ok(perf != perf2, "perf == perf2\n");
+    IHTMLWindow7_Release(window7);
+    IHTMLWindow2_Release(window);
+    VariantClear(&var);
+
     set_client_site(doc, FALSE);
     IHTMLDocument2_Release(doc);
 }
diff --git a/dlls/mshtml/tests/dom.js b/dlls/mshtml/tests/dom.js
index 5a31b869c8f..e5a07027f7c 100644
--- a/dlls/mshtml/tests/dom.js
+++ b/dlls/mshtml/tests/dom.js
@@ -293,6 +293,8 @@ sync_test("rects", function() {
     ok(rects.length === 1, "rect.length = " + rects.length);
     ok(rects[0].top === rect.top, "rects[0].top = " + rects[0].top + " rect.top = " + rect.top);
     ok(rects[0].bottom === rect.bottom, "rects[0].bottom = " + rects[0].bottom + " rect.bottom = " + rect.bottom);
+    ok(rect.height === rect.bottom - rect.top, "rect.height = " + rect.height + " rect.bottom = " + rect.bottom + " rect.top = " + rect.top);
+    ok(rect.width === rect.right - rect.left, "rect.width = " + rect.width + " rect.right = " + rect.right + " rect.left = " + rect.left);
 
     elem = document.createElement("style");
     rects = elem.getClientRects();
diff --git a/dlls/mshtml/tests/events.c b/dlls/mshtml/tests/events.c
index cd6006805d4..a410b464756 100644
--- a/dlls/mshtml/tests/events.c
+++ b/dlls/mshtml/tests/events.c
@@ -1270,6 +1270,7 @@ static HRESULT WINAPI submit_onclick_attached_check_cancel(IDispatchEx *iface, D
     ok(event != NULL, "event == NULL\n");
 
     test_event_cancelbubble(event, VARIANT_TRUE);
+    IHTMLEventObj_Release(event);
     return S_OK;
 }
 
@@ -3133,10 +3134,24 @@ static void test_iframe_connections(IHTMLDocument2 *doc)
 
 static void test_doc_obj(IHTMLDocument2 *doc)
 {
+    static DISPID propput_dispid = DISPID_PROPERTYPUT;
     DISPID dispid, import_node_id, has_own_prop_id;
+    IHTMLOptionElementFactory *option, *option2;
+    IHTMLImageElementFactory *image, *image2;
+    IHTMLXMLHttpRequestFactory *xhr, *xhr2;
+    IHTMLDocument2 *doc_node, *doc_node2;
+    IOmNavigator *navigator, *navigator2;
+    IHTMLLocation *location, *location2;
     int orig_doc_mode = document_mode;
+    IHTMLStorage *storage, *storage2;
+    IHTMLPerformance *perf, *perf2;
+    IOmHistory *history, *history2;
+    IHTMLScreen *screen, *screen2;
     IEventTarget *event_target;
     DISPPARAMS dp = { 0 };
+    IHTMLWindow7 *window7;
+    IHTMLWindow6 *window6;
+    IHTMLWindow5 *window5;
     IDispatchEx *dispex;
     IHTMLElement *body;
     VARIANT res, arg;
@@ -3155,7 +3170,7 @@ static void test_doc_obj(IHTMLDocument2 *doc)
         ok(!!event_target, "event_target = NULL\n");
 
         bstr = SysAllocString(L"click");
-        IEventTarget_addEventListener(event_target, bstr, (IDispatch*)&docobj_onclick_obj, TRUE);
+        hres = IEventTarget_addEventListener(event_target, bstr, (IDispatch*)&docobj_onclick_obj, TRUE);
         ok(hres == S_OK, "addEventListener failed: %08lx\n", hres);
         SysFreeString(bstr);
 
@@ -3245,6 +3260,76 @@ static void test_doc_obj(IHTMLDocument2 *doc)
         SysFreeString(V_BSTR(&arg));
     }
 
+    /* test window props during navigation */
+    hres = IHTMLWindow2_get_document(window, &doc_node);
+    ok(hres == S_OK, "get_document failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_location(window, &location);
+    ok(hres == S_OK, "get_location failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_navigator(window, &navigator);
+    ok(hres == S_OK, "get_navigator failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_history(window, &history);
+    ok(hres == S_OK, "get_history failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_screen(window, &screen);
+    ok(hres == S_OK, "get_screen failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_Image(window, &image);
+    ok(hres == S_OK, "get_image failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_get_Option(window, &option);
+    ok(hres == S_OK, "get_option failed: %08lx\n", hres);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow5, (void**)&window5);
+    ok(hres == S_OK, "Could not get IHTMLWindow5: %08lx\n", hres);
+    hres = IHTMLWindow5_get_XMLHttpRequest(window5, &res);
+    ok(hres == S_OK, "get_XMLHttpRequest failed: %08lx\n", hres);
+    ok(V_VT(&res) == VT_DISPATCH, "V_VT(XMLHttpRequest) = %d\n", V_VT(&res));
+    hres = IDispatch_QueryInterface(V_DISPATCH(&res), &IID_IHTMLXMLHttpRequestFactory, (void**)&xhr);
+    ok(hres == S_OK, "Could not get IHTMLXMLHttpRequestFactory: %08lx\n", hres);
+    IHTMLWindow5_Release(window5);
+    VariantClear(&res);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow6, (void**)&window6);
+    ok(hres == S_OK, "Could not get IHTMLWindow6: %08lx\n", hres);
+    hres = IHTMLWindow6_get_sessionStorage(window6, &storage);
+    ok(hres == S_OK, "get_sessionStorage failed: %08lx\n", hres);
+    IHTMLWindow6_Release(window6);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow7, (void**)&window7);
+    ok(hres == S_OK, "Could not get IHTMLWindow7: %08lx\n", hres);
+    hres = IHTMLWindow7_get_performance(window7, &res);
+    ok(hres == S_OK, "get_performance failed: %08lx\n", hres);
+    ok(V_VT(&res) == VT_DISPATCH, "V_VT(performance) = %d\n", V_VT(&res));
+    hres = IDispatch_QueryInterface(V_DISPATCH(&res), &IID_IHTMLPerformance, (void**)&perf);
+    ok(hres == S_OK, "Could not get IHTMLPerformance: %08lx\n", hres);
+    IHTMLWindow7_Release(window7);
+    VariantClear(&res);
+
+    /* Add props to location, since it gets lost on navigation, despite being same object */
+    bstr = SysAllocString(L"wineTestProp");
+    hres = IHTMLLocation_QueryInterface(location, &IID_IDispatchEx, (void**)&dispex);
+    ok(hres == S_OK, "Could not get IDispatchEx: %08lx\n", hres);
+    hres = IDispatchEx_GetDispID(dispex, bstr, fdexNameEnsure, &dispid);
+    ok(hres == S_OK, "GetDispID(wineTestProp) returned: %08lx\n", hres);
+    SysFreeString(bstr);
+
+    dp.cArgs = dp.cNamedArgs = 1;
+    dp.rgdispidNamedArgs = &propput_dispid;
+    dp.rgvarg = &arg;
+    V_VT(&arg) = VT_I4;
+    V_I4(&arg) = 42;
+    bstr = SysAllocString(L"reload");
+    hres = IDispatchEx_GetDispID(dispex, bstr, 0, &dispid);
+    ok(hres == S_OK, "GetDispID(reload) returned: %08lx\n", hres);
+    hres = IDispatchEx_InvokeEx(dispex, dispid, 0, DISPATCH_PROPERTYPUT, &dp, NULL, NULL, NULL);
+    todo_wine_if(document_mode < 9)
+    ok(hres == (document_mode < 9 ? E_NOTIMPL : S_OK), "InvokeEx returned: %08lx\n", hres);
+    IDispatchEx_Release(dispex);
+    SysFreeString(bstr);
+
     /* Navigate to a different document mode page, checking using the same doc obj.
        Test that it breaks COM rules, since IEventTarget is conditionally exposed.
        All the events registered on the old doc node are also removed.
@@ -3285,6 +3370,98 @@ static void test_doc_obj(IHTMLDocument2 *doc)
         ok(hres == S_OK, "GetIDsOfNames(importNode) returned: %08lx\n", hres);
         ok(dispid != import_node_id, "importNode on new doc node == old created importNode\n");
     }
+
+    hres = IHTMLWindow2_get_document(window, &doc_node2);
+    ok(hres == S_OK, "get_document failed: %08lx\n", hres);
+    ok(doc_node != doc_node2, "doc_node == doc_node2\n");
+    IHTMLDocument2_Release(doc_node2);
+    IHTMLDocument2_Release(doc_node);
+
+    hres = IHTMLWindow2_get_location(window, &location2);
+    ok(hres == S_OK, "get_location failed: %08lx\n", hres);
+    ok(location == location2, "location != location2\n");
+
+    bstr = SysAllocString(L"wineTestProp");
+    hres = IHTMLLocation_GetIDsOfNames(location2, &IID_NULL, &bstr, 1, 0, &dispid);
+    ok(hres == DISP_E_UNKNOWNNAME, "GetIDsOfNames(wineTestProp) returned: %08lx\n", hres);
+    SysFreeString(bstr);
+
+    memset(&dp, 0, sizeof(dp));
+    bstr = SysAllocString(L"reload");
+    hres = IHTMLLocation_GetIDsOfNames(location2, &IID_NULL, &bstr, 1, 0, &dispid);
+    ok(hres == S_OK, "GetIDsOfNames(reload) returned: %08lx\n", hres);
+    hres = IHTMLLocation_Invoke(location2, dispid, &IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &res, NULL, NULL);
+    ok(hres == S_OK, "Invoke failed: %08lx\n", hres);
+    ok(V_VT(&res) == VT_DISPATCH, "VT = %d\n", V_VT(&res));
+    IHTMLLocation_Release(location2);
+    IHTMLLocation_Release(location);
+    SysFreeString(bstr);
+    VariantClear(&res);
+
+    hres = IHTMLWindow2_get_navigator(window, &navigator2);
+    ok(hres == S_OK, "get_navigator failed: %08lx\n", hres);
+    ok(navigator != navigator2, "navigator == navigator2\n");
+    IOmNavigator_Release(navigator2);
+    IOmNavigator_Release(navigator);
+
+    hres = IHTMLWindow2_get_history(window, &history2);
+    ok(hres == S_OK, "get_history failed: %08lx\n", hres);
+    ok(history != history2, "history == history2\n");
+    IOmHistory_Release(history2);
+    IOmHistory_Release(history);
+
+    hres = IHTMLWindow2_get_screen(window, &screen2);
+    ok(hres == S_OK, "get_screen failed: %08lx\n", hres);
+    ok(screen != screen2, "screen == screen2\n");
+    IHTMLScreen_Release(screen2);
+    IHTMLScreen_Release(screen);
+
+    hres = IHTMLWindow2_get_Image(window, &image2);
+    ok(hres == S_OK, "get_image failed: %08lx\n", hres);
+    ok(image != image2, "image == image2\n");
+    IHTMLImageElementFactory_Release(image2);
+    IHTMLImageElementFactory_Release(image);
+
+    hres = IHTMLWindow2_get_Option(window, &option2);
+    ok(hres == S_OK, "get_option failed: %08lx\n", hres);
+    ok(option != option2, "option == option2\n");
+    IHTMLOptionElementFactory_Release(option2);
+    IHTMLOptionElementFactory_Release(option);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow5, (void**)&window5);
+    ok(hres == S_OK, "Could not get IHTMLWindow5: %08lx\n", hres);
+    hres = IHTMLWindow5_get_XMLHttpRequest(window5, &res);
+    ok(hres == S_OK, "get_XMLHttpRequest failed: %08lx\n", hres);
+    ok(V_VT(&res) == VT_DISPATCH, "V_VT(XMLHttpRequest) = %d\n", V_VT(&res));
+    hres = IDispatch_QueryInterface(V_DISPATCH(&res), &IID_IHTMLXMLHttpRequestFactory, (void**)&xhr2);
+    ok(hres == S_OK, "Could not get IHTMLXMLHttpRequestFactory: %08lx\n", hres);
+    ok(xhr != xhr2, "xhr == xhr2\n");
+    IHTMLXMLHttpRequestFactory_Release(xhr2);
+    IHTMLXMLHttpRequestFactory_Release(xhr);
+    IHTMLWindow5_Release(window5);
+    VariantClear(&res);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow6, (void**)&window6);
+    ok(hres == S_OK, "Could not get IHTMLWindow6: %08lx\n", hres);
+    hres = IHTMLWindow6_get_sessionStorage(window6, &storage2);
+    ok(hres == S_OK, "get_sessionStorage failed: %08lx\n", hres);
+    ok(storage != storage2, "storage == storage2\n");
+    IHTMLStorage_Release(storage2);
+    IHTMLStorage_Release(storage);
+    IHTMLWindow6_Release(window6);
+
+    hres = IHTMLWindow2_QueryInterface(window, &IID_IHTMLWindow7, (void**)&window7);
+    ok(hres == S_OK, "Could not get IHTMLWindow7: %08lx\n", hres);
+    hres = IHTMLWindow7_get_performance(window7, &res);
+    ok(hres == S_OK, "get_performance failed: %08lx\n", hres);
+    ok(V_VT(&res) == VT_DISPATCH, "V_VT(performance) = %d\n", V_VT(&res));
+    hres = IDispatch_QueryInterface(V_DISPATCH(&res), &IID_IHTMLPerformance, (void**)&perf2);
+    ok(hres == S_OK, "Could not get IHTMLPerformance: %08lx\n", hres);
+    ok(perf != perf2, "perf == perf2\n");
+    IHTMLPerformance_Release(perf2);
+    IHTMLPerformance_Release(perf);
+    IHTMLWindow7_Release(window7);
+    VariantClear(&res);
 }
 
 static void test_create_event(IHTMLDocument2 *doc)
diff --git a/dlls/mshtml/tests/htmllocation.c b/dlls/mshtml/tests/htmllocation.c
index 0b241085af2..222b9553816 100644
--- a/dlls/mshtml/tests/htmllocation.c
+++ b/dlls/mshtml/tests/htmllocation.c
@@ -39,6 +39,18 @@ struct location_test {
 };
 
 static const struct location_test location_tests[] = {
+    {
+        "Empty",
+        NULL,
+        "about:blank",
+        "about:",
+        NULL,
+        NULL,
+        NULL,
+        "blank",
+        NULL,
+        NULL
+    },
     {
         "HTTP",
         "http://www.winehq.org?search#hash",
@@ -187,7 +199,7 @@ static void test_hostname(IHTMLLocation *loc, IHTMLDocument2 *doc, const struct
     SysFreeString(str);
 
     hres = IHTMLDocument2_get_domain(doc, &str);
-    ok(hres == S_OK, "%s: get_domain failed: 0x%08lx\n", test->name, hres);
+    ok(hres == (test->url ? S_OK : E_FAIL), "%s: get_domain failed: 0x%08lx\n", test->name, hres);
     if(hres == S_OK)
         ok(str_eq_wa(str, test->hostname ? test->hostname : ""),
                 "%s: expected retrieved domain to be L\"%s\", was: %s\n",
@@ -280,7 +292,7 @@ static void perform_test(const struct location_test* test)
     WCHAR url[INTERNET_MAX_URL_LENGTH];
     HRESULT hres;
     IBindCtx *bc;
-    IMoniker *url_mon;
+    IMoniker *url_mon = NULL;
     IPersistMoniker *persist_mon;
     IHTMLDocument2 *doc;
     IHTMLDocument6 *doc6;
@@ -291,12 +303,14 @@ static void perform_test(const struct location_test* test)
     if(FAILED(hres))
         return;
 
-    MultiByteToWideChar(CP_ACP, 0, test->url, -1, url, ARRAY_SIZE(url));
-    hres = CreateURLMoniker(NULL, url, &url_mon);
-    ok(hres == S_OK, "%s: CreateURLMoniker failed: 0x%08lx\n", test->name, hres);
-    if(FAILED(hres)){
-        IBindCtx_Release(bc);
-        return;
+    if(test->url) {
+        MultiByteToWideChar(CP_ACP, 0, test->url, -1, url, ARRAY_SIZE(url));
+        hres = CreateURLMoniker(NULL, url, &url_mon);
+        ok(hres == S_OK, "%s: CreateURLMoniker failed: 0x%08lx\n", test->name, hres);
+        if(FAILED(hres)){
+            IBindCtx_Release(bc);
+            return;
+        }
     }
 
     hres = CoCreateInstance(&CLSID_HTMLDocument, NULL,
@@ -307,7 +321,7 @@ static void perform_test(const struct location_test* test)
 #endif
     ok(hres == S_OK, "%s: CoCreateInstance failed: 0x%08lx\n", test->name, hres);
     if(FAILED(hres)){
-        IMoniker_Release(url_mon);
+        if(url_mon) IMoniker_Release(url_mon);
         IBindCtx_Release(bc);
         return;
     }
@@ -317,38 +331,39 @@ static void perform_test(const struct location_test* test)
         IHTMLDocument6_Release(doc6);
     }else{
         win_skip("%s: Could not get IHTMLDocument6, probably too old IE. Requires IE 8+\n", test->name);
-        IMoniker_Release(url_mon);
+        if(url_mon) IMoniker_Release(url_mon);
         IBindCtx_Release(bc);
         return;
     }
 
-    hres = IHTMLDocument2_QueryInterface(doc, &IID_IPersistMoniker,
-            (void**)&persist_mon);
-    ok(hres == S_OK, "%s: IHTMlDocument2_QueryInterface failed: 0x%08lx\n", test->name, hres);
-    if(FAILED(hres)){
-        IHTMLDocument2_Release(doc);
-        IMoniker_Release(url_mon);
-        IBindCtx_Release(bc);
-        return;
-    }
-
-    hres = IPersistMoniker_Load(persist_mon, FALSE, url_mon, bc,
-            STGM_SHARE_EXCLUSIVE | STGM_READWRITE);
-    ok(hres == S_OK, "%s: IPersistMoniker_Load failed: 0x%08lx\n", test->name, hres);
-    if(FAILED(hres)){
+    if(url_mon) {
+        hres = IHTMLDocument2_QueryInterface(doc, &IID_IPersistMoniker,
+                (void**)&persist_mon);
+        ok(hres == S_OK, "%s: IHTMlDocument2_QueryInterface failed: 0x%08lx\n", test->name, hres);
+        if(FAILED(hres)){
+            IHTMLDocument2_Release(doc);
+            IMoniker_Release(url_mon);
+            IBindCtx_Release(bc);
+            return;
+        }
+
+        hres = IPersistMoniker_Load(persist_mon, FALSE, url_mon, bc,
+                STGM_SHARE_EXCLUSIVE | STGM_READWRITE);
+        ok(hres == S_OK, "%s: IPersistMoniker_Load failed: 0x%08lx\n", test->name, hres);
         IPersistMoniker_Release(persist_mon);
-        IHTMLDocument2_Release(doc);
         IMoniker_Release(url_mon);
-        IBindCtx_Release(bc);
-        return;
+
+        if(FAILED(hres)){
+            IHTMLDocument2_Release(doc);
+            IBindCtx_Release(bc);
+            return;
+        }
     }
 
     hres = IHTMLDocument2_get_location(doc, &location);
     ok(hres == S_OK, "%s: IHTMLDocument2_get_location failed: 0x%08lx\n", test->name, hres);
     if(FAILED(hres)){
-        IPersistMoniker_Release(persist_mon);
         IHTMLDocument2_Release(doc);
-        IMoniker_Release(url_mon);
         IBindCtx_Release(bc);
         return;
     }
@@ -363,9 +378,7 @@ static void perform_test(const struct location_test* test)
     test_hash(location, test);
 
     IHTMLLocation_Release(location);
-    IPersistMoniker_Release(persist_mon);
     IHTMLDocument2_Release(doc);
-    IMoniker_Release(url_mon);
     IBindCtx_Release(bc);
 }
 
diff --git a/dlls/mshtml/tests/script.c b/dlls/mshtml/tests/script.c
index 8d9ff3cd3f7..2bcd588f51f 100644
--- a/dlls/mshtml/tests/script.c
+++ b/dlls/mshtml/tests/script.c
@@ -103,21 +103,32 @@ const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY =
 
 
 DEFINE_EXPECT(CreateInstance);
+DEFINE_EXPECT(CreateInstance2);
 DEFINE_EXPECT(GetInterfaceSafetyOptions);
 DEFINE_EXPECT(SetInterfaceSafetyOptions);
+DEFINE_EXPECT(GetInterfaceSafetyOptions2);
+DEFINE_EXPECT(SetInterfaceSafetyOptions2);
 DEFINE_EXPECT(InitNew);
+DEFINE_EXPECT(InitNew2);
 DEFINE_EXPECT(Close);
+DEFINE_EXPECT(Close2);
 DEFINE_EXPECT(SetProperty_HACK_TRIDENTEVENTSINK);
 DEFINE_EXPECT(SetProperty_INVOKEVERSIONING);
 DEFINE_EXPECT(SetProperty_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
 DEFINE_EXPECT(SetProperty_ABBREVIATE_GLOBALNAME_RESOLUTION_TRUE);
+DEFINE_EXPECT(SetProperty2_HACK_TRIDENTEVENTSINK);
+DEFINE_EXPECT(SetProperty2_INVOKEVERSIONING);
+DEFINE_EXPECT(SetProperty2_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
 DEFINE_EXPECT(SetScriptSite);
+DEFINE_EXPECT(SetScriptSite2);
 DEFINE_EXPECT(GetScriptState);
 DEFINE_EXPECT(SetScriptState_STARTED);
 DEFINE_EXPECT(SetScriptState_CONNECTED);
 DEFINE_EXPECT(SetScriptState_DISCONNECTED);
 DEFINE_EXPECT(AddNamedItem);
+DEFINE_EXPECT(AddNamedItem2);
 DEFINE_EXPECT(ParseScriptText_script);
+DEFINE_EXPECT(ParseScriptText_script2);
 DEFINE_EXPECT(ParseScriptText_execScript);
 DEFINE_EXPECT(GetScriptDispatch);
 DEFINE_EXPECT(funcDisp);
@@ -140,7 +151,6 @@ DEFINE_EXPECT(ChangeType_bstr);
 DEFINE_EXPECT(ChangeType_dispatch);
 DEFINE_EXPECT(GetTypeInfo);
 
-#define TESTSCRIPT_CLSID "{178fc163-f585-4e24-9c13-4bb7faf80746}"
 #define TESTACTIVEX_CLSID "{178fc163-f585-4e24-9c13-4bb7faf80646}"
 
 #define DISPID_SCRIPT_TESTPROP   0x100000
@@ -161,8 +171,10 @@ DEFINE_EXPECT(GetTypeInfo);
 #define DISPID_EXTERNAL_TESTHOSTCTX    0x30000C
 #define DISPID_EXTERNAL_GETMIMETYPE    0x30000D
 
-static const GUID CLSID_TestScript =
-    {0x178fc163,0xf585,0x4e24,{0x9c,0x13,0x4b,0xb7,0xfa,0xf8,0x07,0x46}};
+static const GUID CLSID_TestScript[] = {
+    {0x178fc163,0xf585,0x4e24,{0x9c,0x13,0x4b,0xb7,0xfa,0xf8,0x07,0x46}},
+    {0x178fc163,0xf585,0x4e24,{0x9c,0x13,0x4b,0xb7,0xfa,0xf8,0x08,0x46}},
+};
 static const GUID CLSID_TestActiveX =
     {0x178fc163,0xf585,0x4e24,{0x9c,0x13,0x4b,0xb7,0xfa,0xf8,0x06,0x46}};
 
@@ -178,25 +190,25 @@ static HRESULT ax_getopt_hres = S_OK, ax_setopt_dispex_hres = S_OK;
 static HRESULT ax_setopt_disp_caller_hres = S_OK, ax_setopt_disp_data_hres = S_OK;
 static BOOL skip_loadobject_tests;
 
-static IActiveScriptSite *site;
-static SCRIPTSTATE state;
+static IActiveScriptSite *site, *site2;
+static SCRIPTSTATE state, state2;
 
-static BOOL init_key(const char *key_name, const char *def_value, BOOL init)
+static BOOL init_key(const WCHAR *key_name, const WCHAR *def_value, BOOL init)
 {
     HKEY hkey;
     DWORD res;
 
     if(!init) {
-        RegDeleteKeyA(HKEY_CLASSES_ROOT, key_name);
+        RegDeleteKeyW(HKEY_CLASSES_ROOT, key_name);
         return TRUE;
     }
 
-    res = RegCreateKeyA(HKEY_CLASSES_ROOT, key_name, &hkey);
+    res = RegCreateKeyW(HKEY_CLASSES_ROOT, key_name, &hkey);
     if(res != ERROR_SUCCESS)
         return FALSE;
 
     if(def_value)
-        res = RegSetValueA(hkey, NULL, REG_SZ, def_value, strlen(def_value));
+        res = RegSetValueW(hkey, NULL, REG_SZ, def_value, wcslen(def_value));
 
     RegCloseKey(hkey);
 
@@ -1927,9 +1939,9 @@ static IObjectSafety AXObjectSafety = { &AXObjectSafetyVtbl };
 
 static BOOL set_safe_reg(BOOL safe_call, BOOL safe_data)
 {
-    return init_key("CLSID\\"TESTACTIVEX_CLSID"\\Implemented Categories\\{7dd95801-9882-11cf-9fa9-00aa006c42c4}",
+    return init_key(L"CLSID\\"TESTACTIVEX_CLSID"\\Implemented Categories\\{7dd95801-9882-11cf-9fa9-00aa006c42c4}",
                     NULL, safe_call)
-        && init_key("CLSID\\"TESTACTIVEX_CLSID"\\Implemented Categories\\{7dd95802-9882-11cf-9fa9-00aa006c42c4}",
+        && init_key(L"CLSID\\"TESTACTIVEX_CLSID"\\Implemented Categories\\{7dd95802-9882-11cf-9fa9-00aa006c42c4}",
                     NULL, safe_data);
 }
 
@@ -3336,6 +3348,252 @@ static const IActiveScriptVtbl ActiveScriptVtbl = {
 
 static IActiveScript ActiveScript = { &ActiveScriptVtbl };
 
+static HRESULT WINAPI ObjectSafety2_GetInterfaceSafetyOptions(IObjectSafety *iface, REFIID riid,
+        DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
+{
+    CHECK_EXPECT(GetInterfaceSafetyOptions2);
+
+    ok(IsEqualGUID(&IID_IActiveScriptParse, riid), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+    ok(pdwSupportedOptions != NULL, "pdwSupportedOptions == NULL\n");
+    ok(pdwEnabledOptions != NULL, "pdwEnabledOptions == NULL\n");
+
+    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_DISPEX | INTERFACE_USES_SECURITY_MANAGER;
+    *pdwEnabledOptions = INTERFACE_USES_DISPEX;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI ObjectSafety2_SetInterfaceSafetyOptions(IObjectSafety *iface, REFIID riid,
+        DWORD dwOptionSetMask, DWORD dwEnabledOptions)
+{
+    CHECK_EXPECT(SetInterfaceSafetyOptions2);
+
+    ok(IsEqualGUID(&IID_IActiveScriptParse, riid), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+
+    ok(dwOptionSetMask == (INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_DISPEX | INTERFACE_USES_SECURITY_MANAGER),
+       "dwOptionSetMask = %08lx\n", dwOptionSetMask);
+    ok(dwEnabledOptions == (INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_DISPEX | INTERFACE_USES_SECURITY_MANAGER),
+       "dwEnabledOptions = %08lx\n", dwOptionSetMask);
+
+    return S_OK;
+}
+
+static const IObjectSafetyVtbl ObjectSafety2Vtbl = {
+    ObjectSafety_QueryInterface,
+    ObjectSafety_AddRef,
+    ObjectSafety_Release,
+    ObjectSafety2_GetInterfaceSafetyOptions,
+    ObjectSafety2_SetInterfaceSafetyOptions
+};
+
+static IObjectSafety ObjectSafety2 = { &ObjectSafety2Vtbl };
+
+static HRESULT WINAPI ActiveScriptProperty2_SetProperty(IActiveScriptProperty *iface, DWORD dwProperty,
+        VARIANT *pvarIndex, VARIANT *pvarValue)
+{
+    switch(dwProperty) {
+    case SCRIPTPROP_HACK_TRIDENTEVENTSINK:
+        CHECK_EXPECT(SetProperty2_HACK_TRIDENTEVENTSINK);
+        ok(V_VT(pvarValue) == VT_BOOL, "V_VT(pvarValue) = %d\n", V_VT(pvarValue));
+        ok(V_BOOL(pvarValue) == VARIANT_TRUE, "V_BOOL(pvarValue) = %x\n", V_BOOL(pvarValue));
+        break;
+    case SCRIPTPROP_INVOKEVERSIONING:
+        CHECK_EXPECT(SetProperty2_INVOKEVERSIONING);
+        ok(V_VT(pvarValue) == VT_I4, "V_VT(pvarValue) = %d\n", V_VT(pvarValue));
+        ok(V_I4(pvarValue) == 1, "V_I4(pvarValue) = %ld\n", V_I4(pvarValue));
+        break;
+    case SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION:
+        CHECK_EXPECT(SetProperty2_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
+        ok(V_VT(pvarValue) == VT_BOOL, "V_VT(pvarValue) = %d\n", V_VT(pvarValue));
+        ok(!V_BOOL(pvarValue), "ABBREVIATE_GLOBALNAME_RESOLUTION is TRUE\n");
+        break;
+    case 0x70000003: /* Undocumented property set by IE10 */
+        return E_NOTIMPL;
+    default:
+        ok(0, "unexpected property %08lx\n", dwProperty);
+        return E_NOTIMPL;
+    }
+
+    ok(!pvarIndex, "pvarIndex != NULL\n");
+    ok(pvarValue != NULL, "pvarValue == NULL\n");
+
+    return S_OK;
+}
+
+static const IActiveScriptPropertyVtbl ActiveScriptProperty2Vtbl = {
+    ActiveScriptProperty_QueryInterface,
+    ActiveScriptProperty_AddRef,
+    ActiveScriptProperty_Release,
+    ActiveScriptProperty_GetProperty,
+    ActiveScriptProperty2_SetProperty
+};
+
+static IActiveScriptProperty ActiveScriptProperty2 = { &ActiveScriptProperty2Vtbl };
+
+static HRESULT WINAPI ActiveScriptParse2_InitNew(IActiveScriptParse *iface)
+{
+    CHECK_EXPECT(InitNew2);
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScriptParse2_ParseScriptText(IActiveScriptParse *iface, LPCOLESTR pstrCode,
+        LPCOLESTR pstrItemName, IUnknown *punkContext, LPCOLESTR pstrDelimiter, CTXARG_T dwSourceContextCookie,
+        ULONG ulStartingLine, DWORD dwFlags, VARIANT *pvarResult, EXCEPINFO *pexcepinfo)
+{
+    ok(pvarResult != NULL, "pvarResult == NULL\n");
+    ok(pexcepinfo != NULL, "pexcepinfo == NULL\n");
+
+    if(!lstrcmpW(pstrCode, L"second script")) {
+        CHECK_EXPECT(ParseScriptText_script2);
+        ok(!lstrcmpW(pstrItemName, L"window"), "pstrItemName = %s\n", wine_dbgstr_w(pstrItemName));
+        ok(!lstrcmpW(pstrDelimiter, L"</SCRIPT>"), "pstrDelimiter = %s\n", wine_dbgstr_w(pstrDelimiter));
+        ok(dwFlags == (SCRIPTTEXT_ISVISIBLE | SCRIPTTEXT_HOSTMANAGESSOURCE), "dwFlags = %08lx\n", dwFlags);
+        return S_OK;
+    }
+
+    ok(0, "unexpected script %s\n", wine_dbgstr_w(pstrCode));
+    return E_FAIL;
+}
+
+static const IActiveScriptParseVtbl ActiveScriptParse2Vtbl = {
+    ActiveScriptParse_QueryInterface,
+    ActiveScriptParse_AddRef,
+    ActiveScriptParse_Release,
+    ActiveScriptParse2_InitNew,
+    ActiveScriptParse_AddScriptlet,
+    ActiveScriptParse2_ParseScriptText
+};
+
+static IActiveScriptParse ActiveScriptParse2 = { &ActiveScriptParse2Vtbl };
+
+static HRESULT WINAPI ActiveScript2_QueryInterface(IActiveScript *iface, REFIID riid, void **ppv)
+{
+    *ppv = NULL;
+
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IActiveScript, riid)) {
+        *ppv = iface;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(&IID_IActiveScriptParse, riid)) {
+        *ppv = &ActiveScriptParse2;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(&IID_IActiveScriptParseProcedure2, riid)) {
+        *ppv = &ActiveScriptParseProcedure;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(&IID_IActiveScriptProperty, riid)) {
+        *ppv = &ActiveScriptProperty2;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(&IID_IObjectSafety, riid)) {
+        *ppv = &ObjectSafety2;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(&IID_IActiveScriptDebug, riid))
+        return E_NOINTERFACE;
+
+    trace("QI(%s)\n", wine_dbgstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI ActiveScript2_SetScriptSite(IActiveScript *iface, IActiveScriptSite *pass)
+{
+    HRESULT hres;
+
+    CHECK_EXPECT(SetScriptSite2);
+    ok(pass != NULL, "pass == NULL\n");
+    ok(pass != site, "pass == site\n");
+
+    hres = IActiveScriptSite_OnStateChange(pass, (state2 = SCRIPTSTATE_INITIALIZED));
+    ok(hres == S_OK, "OnStateChange failed: %08lx\n", hres);
+
+    site2 = pass;
+    IActiveScriptSite_AddRef(site2);
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScript2_SetScriptState(IActiveScript *iface, SCRIPTSTATE ss)
+{
+    HRESULT hres = IActiveScriptSite_OnStateChange(site2, (state2 = ss));
+    ok(hres == S_OK, "OnStateChange failed: %08lx\n", hres);
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScript2_GetScriptState(IActiveScript *iface, SCRIPTSTATE *pssState)
+{
+    *pssState = state2;
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScript2_Close(IActiveScript *iface)
+{
+    CHECK_EXPECT(Close2);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ActiveScript2_AddNamedItem(IActiveScript *iface, LPCOLESTR pstrName, DWORD dwFlags)
+{
+    IHTMLWindow2 *window, *window2;
+    IUnknown *unk = NULL;
+    HRESULT hres;
+
+    CHECK_EXPECT(AddNamedItem2);
+    ok(!wcscmp(pstrName, L"window"), "pstrName = %s\n", wine_dbgstr_w(pstrName));
+    ok(dwFlags == (SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS), "dwFlags = %lx\n", dwFlags);
+
+    hres = IActiveScriptSite_GetItemInfo(site2, L"window", SCRIPTINFO_IUNKNOWN, &unk, NULL);
+    ok(hres == S_OK, "GetItemInfo failed: %08lx\n", hres);
+    ok(unk != NULL, "unk == NULL\n");
+
+    /* Native is pretty broken here, it gives a different IUnknown than first site's SCRIPTINFO_IUNKNOWN,
+     * and querying for IDispatchEx gives different interfaces on both these *and* our window_dispex!
+     * That said, querying for IHTMLWindow2 *does* give the same interface for both?!?
+     */
+    hres = IDispatchEx_QueryInterface(window_dispex, &IID_IHTMLWindow2, (void**)&window);
+    ok(hres == S_OK, "Could not get IHTMLWindow2 interface: %08lx\n", hres);
+    hres = IUnknown_QueryInterface(unk, &IID_IHTMLWindow2, (void**)&window2);
+    ok(hres == S_OK, "Could not get IHTMLWindow2 interface: %08lx\n", hres);
+    ok(window == window2, "first site window != second site window\n");
+    IHTMLWindow2_Release(window2);
+    IHTMLWindow2_Release(window);
+
+    IUnknown_Release(unk);
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScript2_GetScriptDispatch(IActiveScript *iface, LPCOLESTR pstrItemName, IDispatch **ppdisp)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static const IActiveScriptVtbl ActiveScript2Vtbl = {
+    ActiveScript2_QueryInterface,
+    ActiveScript_AddRef,
+    ActiveScript_Release,
+    ActiveScript2_SetScriptSite,
+    ActiveScript_GetScriptSite,
+    ActiveScript2_SetScriptState,
+    ActiveScript2_GetScriptState,
+    ActiveScript2_Close,
+    ActiveScript2_AddNamedItem,
+    ActiveScript_AddTypeLib,
+    ActiveScript2_GetScriptDispatch,
+    ActiveScript_GetCurrentScriptThreadID,
+    ActiveScript_GetScriptThreadID,
+    ActiveScript_GetScriptThreadState,
+    ActiveScript_InterruptScriptThread,
+    ActiveScript_Clone
+};
+
+static IActiveScript ActiveScript2 = { &ActiveScript2Vtbl };
+
 static HRESULT WINAPI ClassFactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppv)
 {
     *ppv = NULL;
@@ -3388,7 +3646,25 @@ static const IClassFactoryVtbl ClassFactoryVtbl = {
     ClassFactory_LockServer
 };
 
-static IClassFactory script_cf = { &ClassFactoryVtbl };
+static HRESULT WINAPI ClassFactory2_CreateInstance(IClassFactory *iface, IUnknown *outer, REFIID riid, void **ppv)
+{
+    CHECK_EXPECT(CreateInstance2);
+
+    ok(!outer, "outer = %p\n", outer);
+    ok(IsEqualGUID(&IID_IActiveScript, riid), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+    *ppv = &ActiveScript2;
+    return S_OK;
+}
+
+static const IClassFactoryVtbl ClassFactory2Vtbl = {
+    ClassFactory_QueryInterface,
+    ClassFactory_AddRef,
+    ClassFactory_Release,
+    ClassFactory2_CreateInstance,
+    ClassFactory_LockServer
+};
+
+static IClassFactory script_cf[] = { { &ClassFactoryVtbl }, { &ClassFactory2Vtbl } };
 
 typedef struct {
     IInternetProtocolEx IInternetProtocolEx_iface;
@@ -3901,9 +4177,50 @@ static IClassFactory protocol_cf = { &ProtocolCFVtbl };
 static const char simple_script_str[] =
     "<html><head></head><body>"
     "<div id=\"divid\"></div>"
-    "<script language=\"TestScript\">simple script</script>"
+    "<script language=\"TestScript1\">simple script</script>"
     "</body></html>";
 
+static void test_insert_script_elem(IHTMLDocument2 *doc, const WCHAR *code, const WCHAR *lang)
+{
+    IHTMLDOMNode *node, *body_node, *inserted_node;
+    IHTMLScriptElement *script;
+    IHTMLElement *elem, *body;
+    HRESULT hres;
+    BSTR bstr;
+
+    bstr = SysAllocString(L"script");
+    hres = IHTMLDocument2_createElement(doc, bstr, &elem);
+    ok(hres == S_OK, "createElement failed: %08lx\n", hres);
+    SysFreeString(bstr);
+
+    bstr = SysAllocString(lang);
+    hres = IHTMLElement_put_language(elem, bstr);
+    ok(hres == S_OK, "put_language failed: %08lx\n", hres);
+    SysFreeString(bstr);
+
+    bstr = SysAllocString(code);
+    hres = IHTMLElement_QueryInterface(elem, &IID_IHTMLScriptElement, (void**)&script);
+    ok(hres == S_OK, "Could not get IHTMLScriptElement iface: %08lx\n", hres);
+    hres = IHTMLScriptElement_put_text(script, bstr);
+    ok(hres == S_OK, "put_text failed: %08lx\n", hres);
+    IHTMLScriptElement_Release(script);
+    SysFreeString(bstr);
+
+    hres = IHTMLDocument2_get_body(doc, &body);
+    ok(hres == S_OK, "get_body failed: %08lx\n", hres);
+    hres = IHTMLElement_QueryInterface(elem, &IID_IHTMLDOMNode, (void**)&node);
+    ok(hres == S_OK, "Could not get IHTMLDOMNode iface: %08lx\n", hres);
+    hres = IHTMLElement_QueryInterface(body, &IID_IHTMLDOMNode, (void**)&body_node);
+    ok(hres == S_OK, "Could not get IHTMLDOMNode iface: %08lx\n", hres);
+    hres = IHTMLDOMNode_appendChild(body_node, node, &inserted_node);
+    ok(hres == S_OK, "appendChild failed: %08lx\n", hres);
+    IHTMLDOMNode_Release(inserted_node);
+    IHTMLDOMNode_Release(body_node);
+    IHTMLDOMNode_Release(node);
+    IHTMLElement_Release(body);
+    IHTMLElement_Release(elem);
+}
+
 static void test_exec_script(IHTMLDocument2 *doc, const WCHAR *codew, const WCHAR *langw)
 {
     IHTMLWindow2 *window;
@@ -3974,20 +4291,50 @@ static void test_simple_script(void)
     CHECK_CALLED(ParseScriptText_script);
     CHECK_CALLED(SetScriptState_CONNECTED);
 
-    test_exec_script(doc, L"execScript call", L"TestScript");
+    SET_EXPECT(CreateInstance2);
+    SET_EXPECT(GetInterfaceSafetyOptions2);
+    SET_EXPECT(SetInterfaceSafetyOptions2);
+    SET_EXPECT(SetProperty2_INVOKEVERSIONING);
+    SET_EXPECT(SetProperty2_HACK_TRIDENTEVENTSINK);
+    SET_EXPECT(InitNew2);
+    SET_EXPECT(SetScriptSite2);
+    SET_EXPECT(AddNamedItem2);
+    SET_EXPECT(SetProperty_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
+    SET_EXPECT(SetProperty2_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
+    SET_EXPECT(ParseScriptText_script2);
+
+    test_insert_script_elem(doc, L"second script", L"TestScript2");
+
+    CHECK_CALLED(CreateInstance2);
+    CHECK_CALLED(GetInterfaceSafetyOptions2);
+    CHECK_CALLED(SetInterfaceSafetyOptions2);
+    CHECK_CALLED(SetProperty2_INVOKEVERSIONING);
+    CHECK_CALLED(SetProperty2_HACK_TRIDENTEVENTSINK);
+    CHECK_CALLED(InitNew2);
+    CHECK_CALLED(SetScriptSite2);
+    CHECK_CALLED(AddNamedItem2);
+    CHECK_CALLED(SetProperty_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
+    CHECK_CALLED(SetProperty2_ABBREVIATE_GLOBALNAME_RESOLUTION_FALSE);
+    CHECK_CALLED(ParseScriptText_script2);
+
+    test_exec_script(doc, L"execScript call", L"TestScript1");
 
     if(site)
         IActiveScriptSite_Release(site);
+    if(site2)
+        IActiveScriptSite_Release(site2);
     if(window_dispex)
         IDispatchEx_Release(window_dispex);
 
     SET_EXPECT(SetScriptState_DISCONNECTED);
     SET_EXPECT(Close);
+    SET_EXPECT(Close2);
 
     IHTMLDocument2_Release(doc);
 
     CHECK_CALLED(SetScriptState_DISCONNECTED);
     CHECK_CALLED(Close);
+    CHECK_CALLED(Close2);
 }
 
 static void run_from_moniker(IMoniker *mon)
@@ -4193,16 +4540,33 @@ static void run_js_tests(void)
 
 static BOOL init_registry(BOOL init)
 {
-    return init_key("TestScript\\CLSID", TESTSCRIPT_CLSID, init)
-        && init_key("CLSID\\"TESTSCRIPT_CLSID"\\Implemented Categories\\{F0B7A1A1-9847-11CF-8F20-00805F2CD064}",
-                    NULL, init)
-        && init_key("CLSID\\"TESTSCRIPT_CLSID"\\Implemented Categories\\{F0B7A1A2-9847-11CF-8F20-00805F2CD064}",
-                    NULL, init);
+    static const WCHAR fmt[] = L"CLSID\\%s\\Implemented Categories\\{%08lX-9847-11CF-8F20-00805F2CD064}";
+    WCHAR *clsid, buf[ARRAY_SIZE(fmt) + 40];
+    BOOL ret = TRUE;
+    HRESULT hres;
+    unsigned i;
+
+    for(i = 0; i < ARRAY_SIZE(CLSID_TestScript) && ret; i++) {
+        hres = StringFromCLSID(&CLSID_TestScript[i], &clsid);
+        ok(hres == S_OK, "StringFromCLSID failed: %08lx\n", hres);
+
+        swprintf(buf, ARRAY_SIZE(buf), L"TestScript%u\\CLSID", i + 1);
+        if((ret = init_key(buf, clsid, init))) {
+            swprintf(buf, ARRAY_SIZE(buf), fmt, clsid, 0xf0b7a1a1);
+            if((ret = init_key(buf, NULL, init))) {
+                swprintf(buf, ARRAY_SIZE(buf), fmt, clsid, 0xf0b7a1a2);
+                ret = init_key(buf, NULL, init);
+            }
+        }
+        CoTaskMemFree(clsid);
+    }
+    return ret;
 }
 
 static BOOL register_script_engine(void)
 {
     DWORD regid;
+    unsigned i;
     HRESULT hres;
 
     if(!init_registry(TRUE)) {
@@ -4210,9 +4574,11 @@ static BOOL register_script_engine(void)
         return FALSE;
     }
 
-    hres = CoRegisterClassObject(&CLSID_TestScript, (IUnknown *)&script_cf,
-                                 CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, &regid);
-    ok(hres == S_OK, "Could not register script engine: %08lx\n", hres);
+    for(i = 0; i < ARRAY_SIZE(CLSID_TestScript); i++) {
+        hres = CoRegisterClassObject(&CLSID_TestScript[i], (IUnknown *)&script_cf[i],
+                                     CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE, &regid);
+        ok(hres == S_OK, "Could not register TestScript%u engine: %08lx\n", i + 1, hres);
+    }
 
     return TRUE;
 }
@@ -4299,7 +4665,7 @@ START_TEST(script)
                 test_simple_script();
                 init_registry(FALSE);
             }else {
-                skip("Could not register TestScript engine\n");
+                skip("Could not register TestScript engines\n");
             }
             run_js_tests();
         }else {
diff --git a/dlls/msi/action.c b/dlls/msi/action.c
index d856e94efa7..8b3d1c42aa5 100644
--- a/dlls/msi/action.c
+++ b/dlls/msi/action.c
@@ -69,8 +69,7 @@ static INT ui_actionstart(MSIPACKAGE *package, LPCWSTR action, LPCWSTR descripti
     return rc;
 }
 
-static void ui_actioninfo(MSIPACKAGE *package, LPCWSTR action, BOOL start, 
-                          INT rc)
+static void ui_actioninfo(MSIPACKAGE *package, const WCHAR *action, BOOL start, INT rc)
 {
     MSIRECORD *row;
     WCHAR *template;
@@ -815,11 +814,6 @@ UINT msi_load_all_components( MSIPACKAGE *package )
     return r;
 }
 
-typedef struct {
-    MSIPACKAGE *package;
-    MSIFEATURE *feature;
-} _ilfs;
-
 static UINT add_feature_component( MSIFEATURE *feature, MSICOMPONENT *comp )
 {
     ComponentList *cl;
@@ -846,22 +840,28 @@ static UINT add_feature_child( MSIFEATURE *parent, MSIFEATURE *child )
     return ERROR_SUCCESS;
 }
 
+struct package_feature
+{
+    MSIPACKAGE *package;
+    MSIFEATURE *feature;
+};
+
 static UINT iterate_load_featurecomponents(MSIRECORD *row, LPVOID param)
 {
-    _ilfs* ilfs = param;
+    struct package_feature *package_feature = param;
     LPCWSTR component;
     MSICOMPONENT *comp;
 
     component = MSI_RecordGetString(row,1);
 
     /* check to see if the component is already loaded */
-    comp = msi_get_loaded_component( ilfs->package, component );
+    comp = msi_get_loaded_component( package_feature->package, component );
     if (!comp)
     {
         WARN("ignoring unknown component %s\n", debugstr_w(component));
         return ERROR_SUCCESS;
     }
-    add_feature_component( ilfs->feature, comp );
+    add_feature_component( package_feature->feature, comp );
     comp->Enabled = TRUE;
 
     return ERROR_SUCCESS;
@@ -872,7 +872,7 @@ static UINT load_feature(MSIRECORD *row, LPVOID param)
     MSIPACKAGE *package = param;
     MSIFEATURE *feature;
     MSIQUERY *view;
-    _ilfs ilfs;
+    struct package_feature package_feature;
     UINT rc;
 
     /* fill in the data */
@@ -912,10 +912,10 @@ static UINT load_feature(MSIRECORD *row, LPVOID param)
     if (rc != ERROR_SUCCESS)
         return ERROR_SUCCESS;
 
-    ilfs.package = package;
-    ilfs.feature = feature;
+    package_feature.package = package;
+    package_feature.feature = feature;
 
-    rc = MSI_IterateRecords(view, NULL, iterate_load_featurecomponents , &ilfs);
+    rc = MSI_IterateRecords(view, NULL, iterate_load_featurecomponents, &package_feature);
     msiobj_release(&view->hdr);
     return rc;
 }
@@ -2068,8 +2068,7 @@ static UINT calculate_file_cost( MSIPACKAGE *package )
 
         set_target_path( package, file );
 
-        if ((comp->assembly && !comp->assembly->installed) ||
-            msi_get_file_attributes( package, file->TargetPath ) == INVALID_FILE_ATTRIBUTES)
+        if (msi_get_file_attributes( package, file->TargetPath ) == INVALID_FILE_ATTRIBUTES)
         {
             comp->Cost += file->FileSize;
             continue;
@@ -3419,19 +3418,19 @@ static UINT ACTION_ProcessComponents(MSIPACKAGE *package)
     return ERROR_SUCCESS;
 }
 
-typedef struct {
+struct typelib
+{
     CLSID       clsid;
     LPWSTR      source;
-
     LPWSTR      path;
     ITypeLib    *ptLib;
-} typelib_struct;
+};
 
 static BOOL CALLBACK Typelib_EnumResNameProc( HMODULE hModule, LPCWSTR lpszType, 
                                        LPWSTR lpszName, LONG_PTR lParam)
 {
     TLIBATTR *attr;
-    typelib_struct *tl_struct = (typelib_struct*) lParam;
+    struct typelib *tl_struct = (struct typelib *)lParam;
     int sz;
     HRESULT res;
 
@@ -3477,7 +3476,7 @@ static BOOL CALLBACK Typelib_EnumResNameProc( HMODULE hModule, LPCWSTR lpszType,
     return TRUE;
 }
 
-static HMODULE msi_load_library( MSIPACKAGE *package, const WCHAR *filename, DWORD flags )
+static HMODULE load_library( MSIPACKAGE *package, const WCHAR *filename, DWORD flags )
 {
     HMODULE module;
     msi_disable_fs_redirection( package );
@@ -3486,7 +3485,7 @@ static HMODULE msi_load_library( MSIPACKAGE *package, const WCHAR *filename, DWO
     return module;
 }
 
-static HRESULT msi_load_typelib( MSIPACKAGE *package, const WCHAR *filename, REGKIND kind, ITypeLib **lib )
+static HRESULT load_typelib( MSIPACKAGE *package, const WCHAR *filename, REGKIND kind, ITypeLib **lib )
 {
     HRESULT hr;
     msi_disable_fs_redirection( package );
@@ -3501,7 +3500,7 @@ static UINT ITERATE_RegisterTypeLibraries(MSIRECORD *row, LPVOID param)
     LPCWSTR component;
     MSICOMPONENT *comp;
     MSIFILE *file;
-    typelib_struct tl_struct;
+    struct typelib tl_struct;
     ITypeLib *tlib;
     HMODULE module;
     HRESULT hr;
@@ -3525,7 +3524,7 @@ static UINT ITERATE_RegisterTypeLibraries(MSIRECORD *row, LPVOID param)
     }
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, row);
 
-    module = msi_load_library( package, file->TargetPath, LOAD_LIBRARY_AS_DATAFILE );
+    module = load_library( package, file->TargetPath, LOAD_LIBRARY_AS_DATAFILE );
     if (module)
     {
         LPCWSTR guid;
@@ -3562,7 +3561,7 @@ static UINT ITERATE_RegisterTypeLibraries(MSIRECORD *row, LPVOID param)
     }
     else
     {
-        hr = msi_load_typelib( package, file->TargetPath, REGKIND_REGISTER, &tlib );
+        hr = load_typelib( package, file->TargetPath, REGKIND_REGISTER, &tlib );
         if (FAILED(hr))
         {
             ERR( "failed to load type library: %#lx\n", hr );
@@ -3656,7 +3655,7 @@ static UINT ACTION_UnregisterTypeLibraries( MSIPACKAGE *package )
 static WCHAR *get_link_file( MSIPACKAGE *package, MSIRECORD *row )
 {
     LPCWSTR directory, extension, link_folder;
-    LPWSTR link_file, filename;
+    WCHAR *link_file = NULL, *filename, *new_filename;
 
     directory = MSI_RecordGetString( row, 2 );
     link_folder = msi_get_target_folder( package, directory );
@@ -3669,18 +3668,22 @@ static WCHAR *get_link_file( MSIPACKAGE *package, MSIRECORD *row )
     msi_create_full_path( package, link_folder );
 
     filename = msi_dup_record_field( row, 3 );
+    if (!filename) return NULL;
     msi_reduce_to_long_filename( filename );
 
     extension = wcsrchr( filename, '.' );
     if (!extension || wcsicmp( extension, L".lnk" ))
     {
         int len = lstrlenW( filename );
-        filename = realloc( filename, len * sizeof(WCHAR) + sizeof(L".lnk") );
+        new_filename = realloc( filename, len * sizeof(WCHAR) + sizeof(L".lnk") );
+        if (!new_filename) goto done;
+        filename = new_filename;
         memcpy( filename + len, L".lnk", sizeof(L".lnk") );
     }
     link_file = msi_build_directory_name( 2, link_folder, filename );
-    free( filename );
 
+done:
+    free( filename );
     return link_file;
 }
 
@@ -3936,7 +3939,7 @@ static UINT ITERATE_PublishIcon(MSIRECORD *row, LPVOID param)
     return ERROR_SUCCESS;
 }
 
-static UINT msi_publish_icons(MSIPACKAGE *package)
+static UINT publish_icons(MSIPACKAGE *package)
 {
     MSIQUERY *view;
     UINT r;
@@ -3952,7 +3955,7 @@ static UINT msi_publish_icons(MSIPACKAGE *package)
     return ERROR_SUCCESS;
 }
 
-static UINT msi_publish_sourcelist(MSIPACKAGE *package, HKEY hkey)
+static UINT publish_sourcelist(MSIPACKAGE *package, HKEY hkey)
 {
     UINT r;
     HKEY source;
@@ -4006,7 +4009,7 @@ static UINT msi_publish_sourcelist(MSIPACKAGE *package, HKEY hkey)
     return ERROR_SUCCESS;
 }
 
-static UINT msi_publish_product_properties(MSIPACKAGE *package, HKEY hkey)
+static UINT publish_product_properties(MSIPACKAGE *package, HKEY hkey)
 {
     WCHAR *buffer, *ptr, *guids, packcode[SQUASHED_GUID_SIZE];
     DWORD langid;
@@ -4052,7 +4055,7 @@ static UINT msi_publish_product_properties(MSIPACKAGE *package, HKEY hkey)
     return ERROR_SUCCESS;
 }
 
-static UINT msi_publish_upgrade_code(MSIPACKAGE *package)
+static UINT publish_upgrade_code(MSIPACKAGE *package)
 {
     UINT r;
     HKEY hkey;
@@ -4080,7 +4083,7 @@ static UINT msi_publish_upgrade_code(MSIPACKAGE *package)
     return ERROR_SUCCESS;
 }
 
-static BOOL msi_check_publish(MSIPACKAGE *package)
+static BOOL check_publish(MSIPACKAGE *package)
 {
     MSIFEATURE *feature;
 
@@ -4094,7 +4097,7 @@ static BOOL msi_check_publish(MSIPACKAGE *package)
     return FALSE;
 }
 
-static BOOL msi_check_unpublish(MSIPACKAGE *package)
+static BOOL check_unpublish(MSIPACKAGE *package)
 {
     MSIFEATURE *feature;
 
@@ -4108,7 +4111,7 @@ static BOOL msi_check_unpublish(MSIPACKAGE *package)
     return TRUE;
 }
 
-static UINT msi_publish_patches( MSIPACKAGE *package )
+static UINT publish_patches( MSIPACKAGE *package )
 {
     WCHAR patch_squashed[GUID_SIZE];
     HKEY patches_key = NULL, product_patches_key = NULL, product_key;
@@ -4222,7 +4225,7 @@ static UINT ACTION_PublishProduct(MSIPACKAGE *package)
 
     if (!list_empty(&package->patches))
     {
-        rc = msi_publish_patches(package);
+        rc = publish_patches(package);
         if (rc != ERROR_SUCCESS)
             goto end;
     }
@@ -4256,7 +4259,7 @@ static UINT ACTION_PublishProduct(MSIPACKAGE *package)
     }
 
     /* FIXME: also need to publish if the product is in advertise mode */
-    if (!republish && !msi_check_publish(package))
+    if (!republish && !check_publish(package))
     {
         if (hukey)
             RegCloseKey(hukey);
@@ -4276,19 +4279,19 @@ static UINT ACTION_PublishProduct(MSIPACKAGE *package)
     if (rc != ERROR_SUCCESS)
         goto end;
 
-    rc = msi_publish_upgrade_code(package);
+    rc = publish_upgrade_code(package);
     if (rc != ERROR_SUCCESS)
         goto end;
 
-    rc = msi_publish_product_properties(package, hukey);
+    rc = publish_product_properties(package, hukey);
     if (rc != ERROR_SUCCESS)
         goto end;
 
-    rc = msi_publish_sourcelist(package, hukey);
+    rc = publish_sourcelist(package, hukey);
     if (rc != ERROR_SUCCESS)
         goto end;
 
-    rc = msi_publish_icons(package);
+    rc = publish_icons(package);
 
 end:
     uirow = MSI_CreateRecord( 1 );
@@ -4708,7 +4711,7 @@ static UINT ACTION_PublishFeatures(MSIPACKAGE *package)
     if (package->script == SCRIPT_NONE)
         return msi_schedule_action(package, SCRIPT_INSTALL, L"PublishFeatures");
 
-    if (!msi_check_publish(package))
+    if (!check_publish(package))
         return ERROR_SUCCESS;
 
     rc = MSIREG_OpenFeaturesKey(package->ProductCode, NULL, package->Context,
@@ -4811,7 +4814,7 @@ end:
     return rc;
 }
 
-static UINT msi_unpublish_feature(MSIPACKAGE *package, MSIFEATURE *feature)
+static UINT unpublish_feature(MSIPACKAGE *package, MSIFEATURE *feature)
 {
     UINT r;
     HKEY hkey;
@@ -4850,18 +4853,18 @@ static UINT ACTION_UnpublishFeatures(MSIPACKAGE *package)
     if (package->script == SCRIPT_NONE)
         return msi_schedule_action(package, SCRIPT_INSTALL, L"UnpublishFeatures");
 
-    if (!msi_check_unpublish(package))
+    if (!check_unpublish(package))
         return ERROR_SUCCESS;
 
     LIST_FOR_EACH_ENTRY(feature, &package->features, MSIFEATURE, entry)
     {
-        msi_unpublish_feature(package, feature);
+        unpublish_feature(package, feature);
     }
 
     return ERROR_SUCCESS;
 }
 
-static UINT msi_publish_install_properties(MSIPACKAGE *package, HKEY hkey)
+static UINT publish_install_properties(MSIPACKAGE *package, HKEY hkey)
 {
     static const WCHAR *propval[] =
     {
@@ -4960,8 +4963,7 @@ static UINT ACTION_RegisterProduct(MSIPACKAGE *package)
         return msi_schedule_action(package, SCRIPT_INSTALL, L"RegisterProduct");
 
     /* FIXME: also need to publish if the product is in advertise mode */
-    if (!msi_get_property_int( package->db, L"ProductToBeRegistered", 0 )
-            && !msi_check_publish(package))
+    if (!msi_get_property_int( package->db, L"ProductToBeRegistered", 0 ) && !check_publish(package))
         return ERROR_SUCCESS;
 
     rc = MSIREG_OpenUninstallKey(package->ProductCode, package->platform, &hkey, TRUE);
@@ -4972,11 +4974,11 @@ static UINT ACTION_RegisterProduct(MSIPACKAGE *package)
     if (rc != ERROR_SUCCESS)
         goto done;
 
-    rc = msi_publish_install_properties(package, hkey);
+    rc = publish_install_properties(package, hkey);
     if (rc != ERROR_SUCCESS)
         goto done;
 
-    rc = msi_publish_install_properties(package, props);
+    rc = publish_install_properties(package, props);
     if (rc != ERROR_SUCCESS)
         goto done;
 
@@ -5031,7 +5033,7 @@ static UINT ITERATE_UnpublishIcon( MSIRECORD *row, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_unpublish_icons( MSIPACKAGE *package )
+static UINT unpublish_icons( MSIPACKAGE *package )
 {
     MSIQUERY *view;
     UINT r;
@@ -5113,7 +5115,7 @@ static UINT ACTION_UnpublishProduct(MSIPACKAGE *package)
     TRACE("removing local package %s\n", debugstr_w(package->localfile));
     package->delete_on_close = TRUE;
 
-    msi_unpublish_icons( package );
+    unpublish_icons( package );
     return ERROR_SUCCESS;
 }
 
@@ -5134,6 +5136,8 @@ static BOOL is_full_uninstall( MSIPACKAGE *package )
 static UINT ACTION_InstallFinalize(MSIPACKAGE *package)
 {
     UINT rc;
+    MSIFILE *file;
+    MSIFILEPATCH *patch;
 
     /* first do the same as an InstallExecute */
     rc = execute_script(package, SCRIPT_INSTALL);
@@ -5145,6 +5149,44 @@ static UINT ACTION_InstallFinalize(MSIPACKAGE *package)
     if (rc != ERROR_SUCCESS)
         return rc;
 
+    /* install global assemblies */
+    LIST_FOR_EACH_ENTRY( file, &package->files, MSIFILE, entry )
+    {
+        MSICOMPONENT *comp = file->Component;
+
+        if (!msi_is_global_assembly( comp ) || (file->state != msifs_missing && file->state != msifs_overwrite))
+            continue;
+
+        rc = msi_install_assembly( package, comp );
+        if (rc != ERROR_SUCCESS)
+        {
+            ERR("Failed to install assembly\n");
+            return ERROR_INSTALL_FAILURE;
+        }
+        file->state = msifs_installed;
+    }
+
+    /* patch global assemblies */
+    LIST_FOR_EACH_ENTRY( patch, &package->filepatches, MSIFILEPATCH, entry )
+    {
+        MSICOMPONENT *comp = patch->File->Component;
+
+        if (!msi_is_global_assembly( comp ) || !patch->path) continue;
+
+        rc = msi_patch_assembly( package, comp->assembly, patch );
+        if (rc && !(patch->Attributes & msidbPatchAttributesNonVital))
+        {
+            ERR("Failed to apply patch to file: %s\n", debugstr_w(patch->File->File));
+            return rc;
+        }
+
+        if ((rc = msi_install_assembly( package, comp )))
+        {
+            ERR("Failed to install patched assembly\n");
+            return rc;
+        }
+    }
+
     if (is_full_uninstall(package))
         rc = ACTION_UnpublishProduct(package);
 
@@ -5256,7 +5298,7 @@ static UINT ACTION_RegisterUser(MSIPACKAGE *package)
     if (package->script == SCRIPT_NONE)
         return msi_schedule_action(package, SCRIPT_INSTALL, L"RegisterUser");
 
-    if (msi_check_unpublish(package))
+    if (check_unpublish(package))
     {
         MSIREG_DeleteUserDataProductKey(package->ProductCode, package->Context);
         goto end;
@@ -5793,7 +5835,7 @@ static UINT ACTION_InstallServices( MSIPACKAGE *package )
 }
 
 /* converts arg1[~]arg2[~]arg3 to a list of ptrs to the strings */
-static LPCWSTR *msi_service_args_to_vector(LPWSTR args, DWORD *numargs)
+static const WCHAR **service_args_to_vector(WCHAR *args, DWORD *numargs)
 {
     LPCWSTR *vector, *temp_vector;
     LPWSTR p, q;
@@ -5889,7 +5931,7 @@ static UINT ITERATE_StartService(MSIRECORD *rec, LPVOID param)
         goto done;
     }
 
-    vector = msi_service_args_to_vector(args, &numargs);
+    vector = service_args_to_vector(args, &numargs);
 
     if (!StartServiceW(service, numargs, vector) &&
         GetLastError() != ERROR_SERVICE_ALREADY_RUNNING)
@@ -7329,21 +7371,11 @@ static UINT ACTION_MigrateFeatureStates( MSIPACKAGE *package )
     return ERROR_SUCCESS;
 }
 
-static BOOL msi_bind_image( MSIPACKAGE *package, const char *filename, const char *path )
+static void bind_image( MSIPACKAGE *package, const char *filename, const char *path )
 {
-    BOOL ret;
     msi_disable_fs_redirection( package );
-    ret = BindImage( filename, path, NULL );
+    if (!BindImage( filename, path, NULL )) WARN( "failed to bind image %lu\n", GetLastError() );
     msi_revert_fs_redirection( package );
-    return ret;
-}
-
-static void bind_image( MSIPACKAGE *package, const char *filename, const char *path )
-{
-    if (!msi_bind_image( package, filename, path ))
-    {
-        WARN( "failed to bind image %lu\n", GetLastError() );
-    }
 }
 
 static UINT ITERATE_BindImage( MSIRECORD *rec, LPVOID param )
@@ -7398,7 +7430,7 @@ static UINT ACTION_BindImage( MSIPACKAGE *package )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_unimplemented_action_stub( MSIPACKAGE *package, LPCSTR action, LPCWSTR table )
+static UINT unimplemented_action_stub( MSIPACKAGE *package, LPCSTR action, LPCWSTR table )
 {
     MSIQUERY *view;
     DWORD count = 0;
@@ -7418,27 +7450,27 @@ static UINT msi_unimplemented_action_stub( MSIPACKAGE *package, LPCSTR action, L
 
 static UINT ACTION_IsolateComponents( MSIPACKAGE *package )
 {
-    return msi_unimplemented_action_stub( package, "IsolateComponents", L"IsolateComponent" );
+    return unimplemented_action_stub( package, "IsolateComponents", L"IsolateComponent" );
 }
 
 static UINT ACTION_RMCCPSearch( MSIPACKAGE *package )
 {
-    return msi_unimplemented_action_stub( package, "RMCCPSearch", L"CCPSearch" );
+    return unimplemented_action_stub( package, "RMCCPSearch", L"CCPSearch" );
 }
 
 static UINT ACTION_RegisterComPlus( MSIPACKAGE *package )
 {
-    return msi_unimplemented_action_stub( package, "RegisterComPlus", L"Complus" );
+    return unimplemented_action_stub( package, "RegisterComPlus", L"Complus" );
 }
 
 static UINT ACTION_UnregisterComPlus( MSIPACKAGE *package )
 {
-    return msi_unimplemented_action_stub( package, "UnregisterComPlus", L"Complus" );
+    return unimplemented_action_stub( package, "UnregisterComPlus", L"Complus" );
 }
 
 static UINT ACTION_InstallSFPCatalogFile( MSIPACKAGE *package )
 {
-    return msi_unimplemented_action_stub( package, "InstallSFPCatalogFile", L"SFPCatalog" );
+    return unimplemented_action_stub( package, "InstallSFPCatalogFile", L"SFPCatalog" );
 }
 
 static const struct
diff --git a/dlls/msi/alter.c b/dlls/msi/alter.c
index 00ba4fce590..0b2b3cf5bc9 100644
--- a/dlls/msi/alter.c
+++ b/dlls/msi/alter.c
@@ -34,18 +34,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
-typedef struct tagMSIALTERVIEW
+struct alter_view
 {
     MSIVIEW        view;
     MSIDATABASE   *db;
     MSIVIEW       *table;
     column_info   *colinfo;
     INT hold;
-} MSIALTERVIEW;
+};
 
 static UINT ALTER_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p %d %d %p\n", av, row, col, val );
 
@@ -54,7 +54,7 @@ static UINT ALTER_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *
 
 static UINT ALTER_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm)
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p %d %d %p\n", av, row, col, stm );
 
@@ -63,7 +63,7 @@ static UINT ALTER_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, ISt
 
 static UINT ALTER_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
     UINT ref;
 
     TRACE("%p %p\n", av, record);
@@ -86,7 +86,7 @@ static UINT ALTER_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 
 static UINT ALTER_close( struct tagMSIVIEW *view )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p\n", av );
 
@@ -95,7 +95,7 @@ static UINT ALTER_close( struct tagMSIVIEW *view )
 
 static UINT ALTER_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p %p %p\n", av, rows, cols );
 
@@ -105,7 +105,7 @@ static UINT ALTER_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *col
 static UINT ALTER_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                    UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p %d %p %p %p %p\n", av, n, name, type, temporary, table_name );
 
@@ -115,7 +115,7 @@ static UINT ALTER_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *nam
 static UINT ALTER_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                           MSIRECORD *rec, UINT row )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p %d %p\n", av, eModifyMode, rec );
 
@@ -124,7 +124,7 @@ static UINT ALTER_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 
 static UINT ALTER_delete( struct tagMSIVIEW *view )
 {
-    MSIALTERVIEW *av = (MSIALTERVIEW*)view;
+    struct alter_view *av = (struct alter_view *)view;
 
     TRACE("%p\n", av );
     if (av->table)
@@ -159,7 +159,7 @@ static const MSIVIEWOPS alter_ops =
 
 UINT ALTER_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR name, column_info *colinfo, int hold )
 {
-    MSIALTERVIEW *av;
+    struct alter_view *av;
     UINT r;
 
     TRACE("%p %p %s %d\n", view, colinfo, debugstr_w(name), hold );
diff --git a/dlls/msi/appsearch.c b/dlls/msi/appsearch.c
index 9693fc92833..381e74317fe 100644
--- a/dlls/msi/appsearch.c
+++ b/dlls/msi/appsearch.c
@@ -34,7 +34,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
-typedef struct tagMSISIGNATURE
+struct signature
 {
     LPCWSTR  Name;     /* NOT owned by this structure */
     LPWSTR   File;
@@ -47,7 +47,7 @@ typedef struct tagMSISIGNATURE
     FILETIME MinTime;
     FILETIME MaxTime;
     LPWSTR   Languages;
-}MSISIGNATURE;
+};
 
 void msi_parse_version_string(LPCWSTR verStr, PDWORD ms, PDWORD ls)
 {
@@ -80,7 +80,7 @@ void msi_parse_version_string(LPCWSTR verStr, PDWORD ms, PDWORD ls)
  * Returns ERROR_SUCCESS upon success (where not finding the record counts as
  * success), something else on error.
  */
-static UINT get_signature( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHAR *name )
+static UINT get_signature( MSIPACKAGE *package, struct signature *sig, const WCHAR *name )
 {
     WCHAR *minVersion, *maxVersion, *p;
     MSIRECORD *row;
@@ -148,13 +148,13 @@ static UINT get_signature( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHAR *
 }
 
 /* Frees any memory allocated in sig */
-static void free_signature( MSISIGNATURE *sig )
+static void free_signature( struct signature *sig )
 {
     free(sig->File);
     free(sig->Languages);
 }
 
-static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
+static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, struct signature *sig )
 {
     VS_FIXEDFILEINFO *info;
     DWORD attr;
@@ -220,7 +220,7 @@ done:
     return val;
 }
 
-static UINT search_components( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig )
+static UINT search_components( MSIPACKAGE *package, WCHAR **appValue, struct signature *sig )
 {
     MSIRECORD *row, *rec;
     LPCWSTR signature, guid;
@@ -341,9 +341,9 @@ static void convert_reg_value( DWORD regType, const BYTE *value, DWORD sz, WCHAR
     }
 }
 
-static UINT search_directory( MSIPACKAGE *, MSISIGNATURE *, const WCHAR *, int, WCHAR ** );
+static UINT search_directory( MSIPACKAGE *, struct signature *, const WCHAR *, int, WCHAR ** );
 
-static UINT search_reg( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig )
+static UINT search_reg( MSIPACKAGE *package, WCHAR **appValue, struct signature *sig )
 {
     const WCHAR *keyPath, *valueName;
     WCHAR *deformatted = NULL, *ptr = NULL, *end;
@@ -494,7 +494,7 @@ static LPWSTR get_ini_field(LPWSTR buf, int field)
     return wcsdup(beg);
 }
 
-static UINT search_ini( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig )
+static UINT search_ini( MSIPACKAGE *package, WCHAR **appValue, struct signature *sig )
 {
     MSIRECORD *row;
     LPWSTR fileName, section, key;
@@ -652,7 +652,7 @@ done:
  * Return ERROR_SUCCESS in case of success (whether or not the file matches),
  * something else if an install-halting error occurs.
  */
-static UINT file_version_matches( MSIPACKAGE *package, const MSISIGNATURE *sig, const WCHAR *filePath,
+static UINT file_version_matches( MSIPACKAGE *package, const struct signature *sig, const WCHAR *filePath,
                                   BOOL *matches )
 {
     UINT len;
@@ -712,7 +712,7 @@ static UINT file_version_matches( MSIPACKAGE *package, const MSISIGNATURE *sig,
  * Return ERROR_SUCCESS in case of success (whether or not the file matches),
  * something else if an install-halting error occurs.
  */
-static UINT file_matches_sig( MSIPACKAGE *package, const MSISIGNATURE *sig, const WIN32_FIND_DATAW *findData,
+static UINT file_matches_sig( MSIPACKAGE *package, const struct signature *sig, const WIN32_FIND_DATAW *findData,
                               const WCHAR *fullFilePath, BOOL *matches )
 {
     UINT rc = ERROR_SUCCESS;
@@ -757,7 +757,7 @@ static UINT file_matches_sig( MSIPACKAGE *package, const MSISIGNATURE *sig, cons
  * Returns ERROR_SUCCESS on success (which may include non-critical errors),
  * something else on failures which should halt the install.
  */
-static UINT recurse_search_directory( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig, const WCHAR *dir,
+static UINT recurse_search_directory( MSIPACKAGE *package, WCHAR **appValue, struct signature *sig, const WCHAR *dir,
                                       int depth )
 {
     HANDLE hFind;
@@ -871,11 +871,11 @@ static BOOL is_full_path( const WCHAR *path )
     return ret;
 }
 
-static UINT search_directory( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHAR *path, int depth, WCHAR **appValue )
+static UINT search_directory( MSIPACKAGE *package, struct signature *sig, const WCHAR *path, int depth, WCHAR **appValue )
 {
     UINT rc;
     DWORD attr;
-    LPWSTR val = NULL;
+    WCHAR *val = NULL, *new_val;
 
     TRACE("%p, %p, %s, %d, %p\n", package, sig, debugstr_w(path), depth, appValue);
 
@@ -920,11 +920,18 @@ static UINT search_directory( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHA
     if (attr != INVALID_FILE_ATTRIBUTES && (attr & FILE_ATTRIBUTE_DIRECTORY) &&
         val && val[lstrlenW(val) - 1] != '\\')
     {
-        val = realloc(val, (wcslen(val) + 2) * sizeof(WCHAR));
-        if (!val)
+        new_val = realloc(val, (wcslen(val) + 2) * sizeof(WCHAR));
+        if (!new_val)
+        {
+            free(val);
+            val = NULL;
             rc = ERROR_OUTOFMEMORY;
+        }
         else
+        {
+            val = new_val;
             PathAddBackslashW(val);
+        }
     }
 
     *appValue = val;
@@ -933,9 +940,9 @@ static UINT search_directory( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHA
     return rc;
 }
 
-static UINT search_sig_name( MSIPACKAGE *, const WCHAR *, MSISIGNATURE *, WCHAR ** );
+static UINT search_sig_name( MSIPACKAGE *, const WCHAR *, struct signature *, WCHAR ** );
 
-static UINT search_dr( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig )
+static UINT search_dr( MSIPACKAGE *package, WCHAR **appValue, struct signature *sig )
 {
     LPWSTR parent = NULL;
     LPCWSTR parentName;
@@ -961,7 +968,7 @@ static UINT search_dr( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
     parentName = MSI_RecordGetString(row, 2);
     if (parentName)
     {
-        MSISIGNATURE parentSig;
+        struct signature parentSig;
 
         search_sig_name( package, parentName, &parentSig, &parent );
         free_signature( &parentSig );
@@ -1010,7 +1017,7 @@ static UINT search_dr( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
     return rc;
 }
 
-static UINT search_sig_name( MSIPACKAGE *package, const WCHAR *sigName, MSISIGNATURE *sig, WCHAR **appValue )
+static UINT search_sig_name( MSIPACKAGE *package, const WCHAR *sigName, struct signature *sig, WCHAR **appValue )
 {
     UINT rc;
 
@@ -1038,7 +1045,7 @@ static UINT ITERATE_AppSearch(MSIRECORD *row, LPVOID param)
     MSIPACKAGE *package = param;
     LPCWSTR propName, sigName;
     LPWSTR value = NULL;
-    MSISIGNATURE sig;
+    struct signature sig;
     MSIRECORD *uirow;
     UINT r;
 
@@ -1095,7 +1102,7 @@ static UINT ITERATE_CCPSearch(MSIRECORD *row, LPVOID param)
     MSIPACKAGE *package = param;
     LPCWSTR signature;
     LPWSTR value = NULL;
-    MSISIGNATURE sig;
+    struct signature sig;
     UINT r = ERROR_SUCCESS;
 
     signature = MSI_RecordGetString(row, 1);
diff --git a/dlls/msi/assembly.c b/dlls/msi/assembly.c
index 7f75d225be0..47e8071502c 100644
--- a/dlls/msi/assembly.c
+++ b/dlls/msi/assembly.c
@@ -30,55 +30,52 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
-static BOOL load_fusion_dlls( MSIPACKAGE *package )
+static void load_fusion_dlls( MSIPACKAGE *package )
 {
     HRESULT (WINAPI *pLoadLibraryShim)( const WCHAR *, const WCHAR *, void *, HMODULE * );
     WCHAR path[MAX_PATH];
     DWORD len = GetSystemDirectoryW( path, MAX_PATH );
 
     lstrcpyW( path + len, L"\\mscoree.dll" );
-    if (package->hmscoree || !(package->hmscoree = LoadLibraryW( path ))) return TRUE;
+    if (!package->hmscoree && !(package->hmscoree = LoadLibraryW( path ))) return;
     if (!(pLoadLibraryShim = (void *)GetProcAddress( package->hmscoree, "LoadLibraryShim" )))
     {
         FreeLibrary( package->hmscoree );
         package->hmscoree = NULL;
-        return TRUE;
+        return;
     }
 
-    pLoadLibraryShim( L"fusion.dll", L"v1.0.3705", NULL, &package->hfusion10 );
-    pLoadLibraryShim( L"fusion.dll", L"v1.1.4322", NULL, &package->hfusion11 );
-    pLoadLibraryShim( L"fusion.dll", L"v2.0.50727", NULL, &package->hfusion20 );
-    pLoadLibraryShim( L"fusion.dll", L"v4.0.30319", NULL, &package->hfusion40 );
-
-    return TRUE;
+    if (!package->hfusion10) pLoadLibraryShim( L"fusion.dll", L"v1.0.3705", NULL, &package->hfusion10 );
+    if (!package->hfusion11) pLoadLibraryShim( L"fusion.dll", L"v1.1.4322", NULL, &package->hfusion11 );
+    if (!package->hfusion20) pLoadLibraryShim( L"fusion.dll", L"v2.0.50727", NULL, &package->hfusion20 );
+    if (!package->hfusion40) pLoadLibraryShim( L"fusion.dll", L"v4.0.30319", NULL, &package->hfusion40 );
 }
 
-BOOL msi_init_assembly_caches( MSIPACKAGE *package )
+static BOOL init_assembly_caches( MSIPACKAGE *package )
 {
     HRESULT (WINAPI *pCreateAssemblyCache)( IAssemblyCache **, DWORD );
 
-    if (package->cache_sxs) return TRUE;
-    if (CreateAssemblyCache( &package->cache_sxs, 0 ) != S_OK) return FALSE;
+    if (!package->cache_sxs && CreateAssemblyCache( &package->cache_sxs, 0 ) != S_OK) return FALSE;
 
-    if (!load_fusion_dlls( package )) return FALSE;
+    load_fusion_dlls( package );
     package->pGetFileVersion = (void *)GetProcAddress( package->hmscoree, "GetFileVersion" ); /* missing from v1.0.3705 */
 
-    if (package->hfusion10)
+    if (package->hfusion10 && !package->cache_net[CLR_VERSION_V10])
     {
         pCreateAssemblyCache = (void *)GetProcAddress( package->hfusion10, "CreateAssemblyCache" );
         pCreateAssemblyCache( &package->cache_net[CLR_VERSION_V10], 0 );
     }
-    if (package->hfusion11)
+    if (package->hfusion11 && !package->cache_net[CLR_VERSION_V11])
     {
         pCreateAssemblyCache = (void *)GetProcAddress( package->hfusion11, "CreateAssemblyCache" );
         pCreateAssemblyCache( &package->cache_net[CLR_VERSION_V11], 0 );
     }
-    if (package->hfusion20)
+    if (package->hfusion20 && !package->cache_net[CLR_VERSION_V20])
     {
         pCreateAssemblyCache = (void *)GetProcAddress( package->hfusion20, "CreateAssemblyCache" );
         pCreateAssemblyCache( &package->cache_net[CLR_VERSION_V20], 0 );
     }
-    if (package->hfusion40)
+    if (package->hfusion40 && !package->cache_net[CLR_VERSION_V40])
     {
         pCreateAssemblyCache = (void *)GetProcAddress( package->hfusion40, "CreateAssemblyCache" );
         pCreateAssemblyCache( &package->cache_net[CLR_VERSION_V40], 0 );
@@ -219,31 +216,13 @@ done:
     return display_name;
 }
 
-static BOOL is_assembly_installed( IAssemblyCache *cache, const WCHAR *display_name )
-{
-    HRESULT hr;
-    ASSEMBLY_INFO info;
-
-    if (!cache) return FALSE;
-
-    memset( &info, 0, sizeof(info) );
-    info.cbAssemblyInfo = sizeof(info);
-    hr = IAssemblyCache_QueryAssemblyInfo( cache, 0, display_name, &info );
-    if (hr == S_OK /* sxs version */ || hr == E_NOT_SUFFICIENT_BUFFER)
-    {
-        return (info.dwAssemblyFlags == ASSEMBLYINFO_FLAG_INSTALLED);
-    }
-    TRACE( "QueryAssemblyInfo returned %#lx\n", hr );
-    return FALSE;
-}
-
 WCHAR *msi_get_assembly_path( MSIPACKAGE *package, const WCHAR *displayname )
 {
     HRESULT hr;
     ASSEMBLY_INFO info;
-    IAssemblyCache *cache = package->cache_net[CLR_VERSION_V40];
+    IAssemblyCache *cache;
 
-    if (!cache) return NULL;
+    if (!init_assembly_caches( package ) || !(cache = package->cache_net[CLR_VERSION_V40])) return NULL;
 
     memset( &info, 0, sizeof(info) );
     info.cbAssemblyInfo = sizeof(info);
@@ -270,7 +249,8 @@ IAssemblyEnum *msi_create_assembly_enum( MSIPACKAGE *package, const WCHAR *displ
     WCHAR *str;
     DWORD len = 0;
 
-    if (!package->pCreateAssemblyNameObject || !package->pCreateAssemblyEnum) return NULL;
+    if (!init_assembly_caches( package ) || !package->pCreateAssemblyNameObject || !package->pCreateAssemblyEnum)
+        return NULL;
 
     hr = package->pCreateAssemblyNameObject( &name, displayname, CANOF_PARSE_DISPLAY_NAME, NULL );
     if (FAILED( hr )) return NULL;
@@ -309,13 +289,6 @@ static const WCHAR *clr_version[] =
     L"v4.0.30319"
 };
 
-static const WCHAR *get_clr_version_str( enum clr_version version )
-{
-    if (version >= ARRAY_SIZE( clr_version )) return L"unknown";
-    return clr_version[version];
-}
-
-/* assembly caches must be initialized */
 MSIASSEMBLY *msi_load_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
 {
     MSIRECORD *rec;
@@ -351,34 +324,6 @@ MSIASSEMBLY *msi_load_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
     }
     TRACE("display name %s\n", debugstr_w(a->display_name));
 
-    if (a->application)
-    {
-        /* We can't check the manifest here because the target path may still change.
-           So we assume that the assembly is not installed and lean on the InstallFiles
-           action to determine which files need to be installed.
-         */
-        a->installed = FALSE;
-    }
-    else
-    {
-        if (a->attributes == msidbAssemblyAttributesWin32)
-            a->installed = is_assembly_installed( package->cache_sxs, a->display_name );
-        else
-        {
-            UINT i;
-            for (i = 0; i < CLR_VERSION_MAX; i++)
-            {
-                a->clr_version[i] = is_assembly_installed( package->cache_net[i], a->display_name );
-                if (a->clr_version[i])
-                {
-                    TRACE("runtime version %s\n", debugstr_w(get_clr_version_str( i )));
-                    a->installed = TRUE;
-                    break;
-                }
-            }
-        }
-    }
-    TRACE("assembly is %s\n", a->installed ? "installed" : "not installed");
     msiobj_release( &rec->hdr );
     return a;
 }
@@ -416,6 +361,8 @@ UINT msi_install_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
     MSIASSEMBLY *assembly = comp->assembly;
     MSIFEATURE *feature = NULL;
 
+    if (!init_assembly_caches( package )) return ERROR_FUNCTION_FAILED;
+
     if (comp->assembly->feature)
         feature = msi_get_loaded_feature( package, comp->assembly->feature );
 
@@ -449,7 +396,6 @@ UINT msi_install_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
         return ERROR_FUNCTION_FAILED;
     }
     if (feature) feature->Action = INSTALLSTATE_LOCAL;
-    assembly->installed = TRUE;
     return ERROR_SUCCESS;
 }
 
@@ -460,6 +406,8 @@ UINT msi_uninstall_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
     MSIASSEMBLY *assembly = comp->assembly;
     MSIFEATURE *feature = NULL;
 
+    if (!init_assembly_caches( package )) return ERROR_FUNCTION_FAILED;
+
     if (comp->assembly->feature)
         feature = msi_get_loaded_feature( package, comp->assembly->feature );
 
@@ -491,7 +439,6 @@ UINT msi_uninstall_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
         }
     }
     if (feature) feature->Action = INSTALLSTATE_ABSENT;
-    assembly->installed = FALSE;
     return ERROR_SUCCESS;
 }
 
diff --git a/dlls/msi/automation.c b/dlls/msi/automation.c
index 99852938b0e..36891cc62da 100644
--- a/dlls/msi/automation.c
+++ b/dlls/msi/automation.c
@@ -41,33 +41,30 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
 #define REG_INDEX_CLASSES_ROOT 0
 #define REG_INDEX_DYN_DATA 6
 
-typedef struct AutomationObject AutomationObject;
+struct automation_object;
 
-/* function that is called from AutomationObject::Invoke, specific to this type of object */
-typedef HRESULT (*auto_invoke_func)(AutomationObject* This,
-    DISPID dispIdMember, REFIID riid, LCID lcid, WORD flags, DISPPARAMS* pDispParams,
-    VARIANT* result, EXCEPINFO* ei, UINT* arg_err);
-/* function that is called from AutomationObject::Release when the object is being freed
-   to free any private data structures (or NULL) */
-typedef void (*auto_free_func)(AutomationObject* This);
-
-typedef struct {
+struct tid_id
+{
     REFIID riid;
-    auto_invoke_func fn_invoke;
-    auto_free_func fn_free;
-} tid_id_t;
-
+    /* function that is called from AutomationObject::Invoke, specific to this type of object */
+    HRESULT (*fn_invoke)(struct automation_object *, DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *,
+                         EXCEPINFO *, UINT *);
+    /* function that is called from AutomationObject::Release when the object is being freed
+       to free any private data structures (or NULL) */
+    void (*fn_free)(struct automation_object *);
+};
 
-static HRESULT database_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
-static HRESULT installer_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
-static HRESULT record_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
-static HRESULT session_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
-static HRESULT list_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
-static void    list_free(AutomationObject*);
-static HRESULT summaryinfo_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
-static HRESULT view_invoke(AutomationObject*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static HRESULT database_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static HRESULT installer_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static HRESULT record_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static HRESULT session_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static HRESULT list_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static void    list_free(struct automation_object*);
+static HRESULT summaryinfo_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
+static HRESULT view_invoke(struct automation_object*,DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
 
-static tid_id_t tid_ids[] = {
+static struct tid_id tid_ids[] =
+{
     { &DIID_Database,    database_invoke },
     { &DIID_Installer,   installer_invoke },
     { &DIID_Record,      record_invoke },
@@ -137,10 +134,11 @@ void release_typelib(void)
 }
 
 /*
- * AutomationObject - "base" class for all automation objects. For each interface, we implement Invoke function
- *                    called from AutomationObject::Invoke.
+ * struct automation_object - "base" class for all automation objects. For each interface, we implement Invoke
+ * function called from AutomationObject::Invoke.
  */
-struct AutomationObject {
+struct automation_object
+{
     IDispatch IDispatch_iface;
     IProvideMultipleClassInfo IProvideMultipleClassInfo_iface;
     LONG ref;
@@ -152,46 +150,49 @@ struct AutomationObject {
     MSIHANDLE msiHandle;
 };
 
-typedef struct {
-    AutomationObject autoobj;
+struct list_object
+{
+    struct automation_object autoobj;
     int count;
     VARIANT *data;
-} ListObject;
+};
 
 static HRESULT create_database(MSIHANDLE, IDispatch**);
-static HRESULT create_list_enumerator(ListObject*, void**);
+static HRESULT create_list_enumerator(struct list_object *, void **);
 static HRESULT create_summaryinfo(MSIHANDLE, IDispatch**);
 static HRESULT create_view(MSIHANDLE, IDispatch**);
 
-/* ListEnumerator - IEnumVARIANT implementation for MSI automation lists */
-typedef struct {
+/* struct list_enumerator - IEnumVARIANT implementation for MSI automation lists */
+struct list_enumerator
+{
     IEnumVARIANT IEnumVARIANT_iface;
     LONG ref;
 
-    /* Current position and pointer to AutomationObject that stores actual data */
+    /* Current position and pointer to struct automation_object that stores actual data */
     ULONG pos;
-    ListObject *list;
-} ListEnumerator;
+    struct list_object *list;
+};
 
-typedef struct {
-    AutomationObject autoobj;
+struct session_object
+{
+    struct automation_object autoobj;
     IDispatch *installer;
-} SessionObject;
+};
 
-static inline AutomationObject *impl_from_IProvideMultipleClassInfo( IProvideMultipleClassInfo *iface )
+static inline struct automation_object *impl_from_IProvideMultipleClassInfo( IProvideMultipleClassInfo *iface )
 {
-    return CONTAINING_RECORD(iface, AutomationObject, IProvideMultipleClassInfo_iface);
+    return CONTAINING_RECORD(iface, struct automation_object, IProvideMultipleClassInfo_iface);
 }
 
-static inline AutomationObject *impl_from_IDispatch( IDispatch *iface )
+static inline struct automation_object *impl_from_IDispatch( IDispatch *iface )
 {
-    return CONTAINING_RECORD(iface, AutomationObject, IDispatch_iface);
+    return CONTAINING_RECORD(iface, struct automation_object, IDispatch_iface);
 }
 
 /* AutomationObject methods */
 static HRESULT WINAPI AutomationObject_QueryInterface(IDispatch* iface, REFIID riid, void** ppvObject)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
 
     TRACE("(%p/%p)->(%s,%p)\n", iface, This, debugstr_guid(riid), ppvObject);
 
@@ -221,7 +222,7 @@ static HRESULT WINAPI AutomationObject_QueryInterface(IDispatch* iface, REFIID r
 
 static ULONG WINAPI AutomationObject_AddRef(IDispatch* iface)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
 
     TRACE("(%p/%p)\n", iface, This);
 
@@ -230,7 +231,7 @@ static ULONG WINAPI AutomationObject_AddRef(IDispatch* iface)
 
 static ULONG WINAPI AutomationObject_Release(IDispatch* iface)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p/%p)\n", iface, This);
@@ -249,7 +250,7 @@ static HRESULT WINAPI AutomationObject_GetTypeInfoCount(
         IDispatch* iface,
         UINT* pctinfo)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
 
     TRACE("(%p/%p)->(%p)\n", iface, This, pctinfo);
     *pctinfo = 1;
@@ -262,7 +263,7 @@ static HRESULT WINAPI AutomationObject_GetTypeInfo(
         LCID lcid,
         ITypeInfo** ppTInfo)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
     HRESULT hr;
 
     TRACE( "(%p/%p)->(%u, %ld, %p)\n", iface, This, iTInfo, lcid, ppTInfo );
@@ -283,7 +284,7 @@ static HRESULT WINAPI AutomationObject_GetIDsOfNames(
         LCID lcid,
         DISPID* rgDispId)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
     ITypeInfo *ti;
     HRESULT hr;
 
@@ -324,7 +325,7 @@ static HRESULT WINAPI AutomationObject_Invoke(
         EXCEPINFO* pExcepInfo,
         UINT* puArgErr)
 {
-    AutomationObject *This = impl_from_IDispatch(iface);
+    struct automation_object *This = impl_from_IDispatch(iface);
     HRESULT hr;
     unsigned int uArgErr;
     VARIANT varResultDummy;
@@ -437,25 +438,25 @@ static HRESULT WINAPI ProvideMultipleClassInfo_QueryInterface(
   REFIID     riid,
   VOID**     ppvoid)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
     return IDispatch_QueryInterface(&This->IDispatch_iface, riid, ppvoid);
 }
 
 static ULONG WINAPI ProvideMultipleClassInfo_AddRef(IProvideMultipleClassInfo* iface)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
     return IDispatch_AddRef(&This->IDispatch_iface);
 }
 
 static ULONG WINAPI ProvideMultipleClassInfo_Release(IProvideMultipleClassInfo* iface)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
     return IDispatch_Release(&This->IDispatch_iface);
 }
 
 static HRESULT WINAPI ProvideMultipleClassInfo_GetClassInfo(IProvideMultipleClassInfo* iface, ITypeInfo** ppTI)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
     HRESULT hr;
 
     TRACE("(%p/%p)->(%p)\n", iface, This, ppTI);
@@ -469,7 +470,7 @@ static HRESULT WINAPI ProvideMultipleClassInfo_GetClassInfo(IProvideMultipleClas
 
 static HRESULT WINAPI ProvideMultipleClassInfo_GetGUID(IProvideMultipleClassInfo* iface, DWORD dwGuidKind, GUID* pGUID)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
     TRACE("(%p/%p)->(%lu, %s)\n", iface, This, dwGuidKind, debugstr_guid(pGUID));
 
     if (dwGuidKind != GUIDKIND_DEFAULT_SOURCE_DISP_IID)
@@ -482,7 +483,7 @@ static HRESULT WINAPI ProvideMultipleClassInfo_GetGUID(IProvideMultipleClassInfo
 
 static HRESULT WINAPI ProvideMultipleClassInfo_GetMultiTypeInfoCount(IProvideMultipleClassInfo* iface, ULONG* pcti)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
 
     TRACE("(%p/%p)->(%p)\n", iface, This, pcti);
     *pcti = 1;
@@ -498,7 +499,7 @@ static HRESULT WINAPI ProvideMultipleClassInfo_GetInfoOfIndex(IProvideMultipleCl
         IID* piidPrimary,
         IID* piidSource)
 {
-    AutomationObject *This = impl_from_IProvideMultipleClassInfo(iface);
+    struct automation_object *This = impl_from_IProvideMultipleClassInfo(iface);
 
     TRACE("(%p/%p)->(%lu, %#lx, %p, %p, %p, %p, %p)\n", iface, This, iti, dwFlags, ti, pdwTIFlags, pcdispidReserved,
           piidPrimary, piidSource);
@@ -541,7 +542,7 @@ static const IProvideMultipleClassInfoVtbl ProvideMultipleClassInfoVtbl =
     ProvideMultipleClassInfo_GetInfoOfIndex
 };
 
-static void init_automation_object(AutomationObject *This, MSIHANDLE msiHandle, tid_t tid)
+static void init_automation_object(struct automation_object *This, MSIHANDLE msiHandle, tid_t tid)
 {
     TRACE("%p, %lu, %s\n", This, msiHandle, debugstr_guid(get_riid_from_tid(tid)));
 
@@ -556,15 +557,15 @@ static void init_automation_object(AutomationObject *This, MSIHANDLE msiHandle,
  * ListEnumerator methods
  */
 
-static inline ListEnumerator *impl_from_IEnumVARIANT(IEnumVARIANT* iface)
+static inline struct list_enumerator *impl_from_IEnumVARIANT(IEnumVARIANT* iface)
 {
-    return CONTAINING_RECORD(iface, ListEnumerator, IEnumVARIANT_iface);
+    return CONTAINING_RECORD(iface, struct list_enumerator, IEnumVARIANT_iface);
 }
 
 static HRESULT WINAPI ListEnumerator_QueryInterface(IEnumVARIANT* iface, REFIID riid,
         void** ppvObject)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
 
     TRACE("(%p/%p)->(%s,%p)\n", iface, This, debugstr_guid(riid), ppvObject);
 
@@ -590,7 +591,7 @@ static HRESULT WINAPI ListEnumerator_QueryInterface(IEnumVARIANT* iface, REFIID
 
 static ULONG WINAPI ListEnumerator_AddRef(IEnumVARIANT* iface)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
 
     TRACE("(%p/%p)\n", iface, This);
 
@@ -599,7 +600,7 @@ static ULONG WINAPI ListEnumerator_AddRef(IEnumVARIANT* iface)
 
 static ULONG WINAPI ListEnumerator_Release(IEnumVARIANT* iface)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p/%p)\n", iface, This);
@@ -616,7 +617,7 @@ static ULONG WINAPI ListEnumerator_Release(IEnumVARIANT* iface)
 static HRESULT WINAPI ListEnumerator_Next(IEnumVARIANT* iface, ULONG celt, VARIANT* rgVar,
         ULONG* fetched)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
     ULONG i, local;
 
     TRACE("%p, %lu, %p, %p\n", iface, celt, rgVar, fetched);
@@ -640,7 +641,7 @@ static HRESULT WINAPI ListEnumerator_Next(IEnumVARIANT* iface, ULONG celt, VARIA
 
 static HRESULT WINAPI ListEnumerator_Skip(IEnumVARIANT* iface, ULONG celt)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
 
     TRACE("%p, %lu\n", iface, celt);
 
@@ -656,7 +657,7 @@ static HRESULT WINAPI ListEnumerator_Skip(IEnumVARIANT* iface, ULONG celt)
 
 static HRESULT WINAPI ListEnumerator_Reset(IEnumVARIANT* iface)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
 
     TRACE("(%p)\n", iface);
 
@@ -666,7 +667,7 @@ static HRESULT WINAPI ListEnumerator_Reset(IEnumVARIANT* iface)
 
 static HRESULT WINAPI ListEnumerator_Clone(IEnumVARIANT* iface, IEnumVARIANT **ppEnum)
 {
-    ListEnumerator *This = impl_from_IEnumVARIANT(iface);
+    struct list_enumerator *This = impl_from_IEnumVARIANT(iface);
     HRESULT hr;
 
     TRACE("(%p,%p)\n", iface, ppEnum);
@@ -697,13 +698,13 @@ static const struct IEnumVARIANTVtbl ListEnumerator_Vtbl =
 };
 
 /* Create a list enumerator, placing the result in the pointer ppObj.  */
-static HRESULT create_list_enumerator(ListObject *list, void **ppObj)
+static HRESULT create_list_enumerator(struct list_object *list, void **ppObj)
 {
-    ListEnumerator *object;
+    struct list_enumerator *object;
 
     TRACE("(%p, %p)\n", list, ppObj);
 
-    object = malloc(sizeof(ListEnumerator));
+    object = malloc(sizeof(*object));
 
     /* Set all the VTable references */
     object->IEnumVARIANT_iface.lpVtbl = &ListEnumerator_Vtbl;
@@ -752,7 +753,7 @@ static HRESULT DispGetParam_CopyOnly(
 }
 
 static HRESULT summaryinfo_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -904,7 +905,7 @@ static HRESULT summaryinfo_invoke(
 }
 
 static HRESULT record_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -996,7 +997,7 @@ static HRESULT record_invoke(
 
 static HRESULT create_record(MSIHANDLE msiHandle, IDispatch **disp)
 {
-    AutomationObject *record;
+    struct automation_object *record;
 
     record = malloc(sizeof(*record));
     if (!record) return E_OUTOFMEMORY;
@@ -1009,7 +1010,7 @@ static HRESULT create_record(MSIHANDLE msiHandle, IDispatch **disp)
 }
 
 static HRESULT list_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -1019,7 +1020,7 @@ static HRESULT list_invoke(
         EXCEPINFO* pExcepInfo,
         UINT* puArgErr)
 {
-    ListObject *list = CONTAINING_RECORD(This, ListObject, autoobj);
+    struct list_object *list = CONTAINING_RECORD(This, struct list_object, autoobj);
     IUnknown *pUnk = NULL;
     HRESULT hr;
 
@@ -1065,9 +1066,9 @@ static HRESULT list_invoke(
     return S_OK;
 }
 
-static void list_free(AutomationObject *This)
+static void list_free(struct automation_object *This)
 {
-    ListObject *list = CONTAINING_RECORD(This, ListObject, autoobj);
+    struct list_object *list = CONTAINING_RECORD(This, struct list_object, autoobj);
     int i;
 
     for (i = 0; i < list->count; i++)
@@ -1105,11 +1106,11 @@ static HRESULT get_products_count(const WCHAR *product, int *len)
 
 static HRESULT create_list(const WCHAR *product, IDispatch **dispatch)
 {
-    ListObject *list;
+    struct list_object *list;
     HRESULT hr;
     int i;
 
-    list = calloc(1, sizeof(ListObject));
+    list = calloc(1, sizeof(*list));
     if (!list) return E_OUTOFMEMORY;
 
     init_automation_object(&list->autoobj, 0, StringList_tid);
@@ -1151,7 +1152,7 @@ static HRESULT create_list(const WCHAR *product, IDispatch **dispatch)
 }
 
 static HRESULT view_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -1176,7 +1177,7 @@ static HRESULT view_invoke(
             {
                 hr = DispGetParam(pDispParams, 0, VT_DISPATCH, &varg0, puArgErr);
                 if (SUCCEEDED(hr) && V_DISPATCH(&varg0) != NULL)
-                    MsiViewExecute(This->msiHandle, ((AutomationObject *)V_DISPATCH(&varg0))->msiHandle);
+                    MsiViewExecute(This->msiHandle, ((struct automation_object *)V_DISPATCH(&varg0))->msiHandle);
                 else
                     MsiViewExecute(This->msiHandle, 0);
             }
@@ -1211,7 +1212,8 @@ static HRESULT view_invoke(
                 hr = DispGetParam(pDispParams, 1, VT_DISPATCH, &varg1, puArgErr);
                 if (FAILED(hr)) return hr;
                 if (!V_DISPATCH(&varg1)) return DISP_E_EXCEPTION;
-                if ((ret = MsiViewModify(This->msiHandle, V_I4(&varg0), ((AutomationObject *)V_DISPATCH(&varg1))->msiHandle)) != ERROR_SUCCESS)
+                if ((ret = MsiViewModify(This->msiHandle, V_I4(&varg0),
+                                         ((struct automation_object *)V_DISPATCH(&varg1))->msiHandle)) != ERROR_SUCCESS)
                 {
                     VariantClear(&varg1);
                     ERR("MsiViewModify returned %d\n", ret);
@@ -1255,7 +1257,7 @@ static HRESULT DatabaseImpl_LastErrorRecord(WORD wFlags,
 }
 
 HRESULT database_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -1340,7 +1342,7 @@ HRESULT database_invoke(
 }
 
 static HRESULT session_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -1350,7 +1352,7 @@ static HRESULT session_invoke(
         EXCEPINFO* pExcepInfo,
         UINT* puArgErr)
 {
-    SessionObject *session = CONTAINING_RECORD(This, SessionObject, autoobj);
+    struct session_object *session = CONTAINING_RECORD(This, struct session_object, autoobj);
     WCHAR *szString;
     DWORD dwLen = 0;
     MSIHANDLE msiHandle;
@@ -1521,7 +1523,7 @@ static HRESULT session_invoke(
 
             V_VT(pVarResult) = VT_I4;
             V_I4(pVarResult) =
-                MsiProcessMessage(This->msiHandle, V_I4(&varg0), ((AutomationObject *)V_DISPATCH(&varg1))->msiHandle);
+                MsiProcessMessage(This->msiHandle, V_I4(&varg0), ((struct automation_object *)V_DISPATCH(&varg1))->msiHandle);
             break;
 
         case DISPID_SESSION_SETINSTALLLEVEL:
@@ -1682,7 +1684,7 @@ static HRESULT InstallerImpl_CreateRecord(WORD wFlags,
     return create_record(hrec, &V_DISPATCH(pVarResult));
 }
 
-static HRESULT InstallerImpl_OpenPackage(AutomationObject* This,
+static HRESULT InstallerImpl_OpenPackage(struct automation_object *This,
                                          WORD wFlags,
                                          DISPPARAMS* pDispParams,
                                          VARIANT* pVarResult,
@@ -2319,7 +2321,7 @@ static HRESULT InstallerImpl_RelatedProducts(WORD flags,
 }
 
 static HRESULT installer_invoke(
-        AutomationObject* This,
+        struct automation_object *This,
         DISPID dispIdMember,
         REFIID riid,
         LCID lcid,
@@ -2420,14 +2422,14 @@ static HRESULT installer_invoke(
 
 HRESULT create_msiserver(IUnknown *outer, void **ppObj)
 {
-    AutomationObject *installer;
+    struct automation_object *installer;
 
     TRACE("(%p %p)\n", outer, ppObj);
 
     if (outer)
         return CLASS_E_NOAGGREGATION;
 
-    installer = malloc(sizeof(AutomationObject));
+    installer = malloc(sizeof(*installer));
     if (!installer) return E_OUTOFMEMORY;
 
     init_automation_object(installer, 0, Installer_tid);
@@ -2439,9 +2441,9 @@ HRESULT create_msiserver(IUnknown *outer, void **ppObj)
 
 HRESULT create_session(MSIHANDLE msiHandle, IDispatch *installer, IDispatch **disp)
 {
-    SessionObject *session;
+    struct session_object *session;
 
-    session = malloc(sizeof(SessionObject));
+    session = malloc(sizeof(*session));
     if (!session) return E_OUTOFMEMORY;
 
     init_automation_object(&session->autoobj, msiHandle, Session_tid);
@@ -2454,11 +2456,11 @@ HRESULT create_session(MSIHANDLE msiHandle, IDispatch *installer, IDispatch **di
 
 static HRESULT create_database(MSIHANDLE msiHandle, IDispatch **dispatch)
 {
-    AutomationObject *database;
+    struct automation_object *database;
 
     TRACE("%lu %p\n", msiHandle, dispatch);
 
-    database = malloc(sizeof(AutomationObject));
+    database = malloc(sizeof(*database));
     if (!database) return E_OUTOFMEMORY;
 
     init_automation_object(database, msiHandle, Database_tid);
@@ -2470,11 +2472,11 @@ static HRESULT create_database(MSIHANDLE msiHandle, IDispatch **dispatch)
 
 static HRESULT create_view(MSIHANDLE msiHandle, IDispatch **dispatch)
 {
-    AutomationObject *view;
+    struct automation_object *view;
 
     TRACE("%lu %p\n", msiHandle, dispatch);
 
-    view = malloc(sizeof(AutomationObject));
+    view = malloc(sizeof(*view));
     if (!view) return E_OUTOFMEMORY;
 
     init_automation_object(view, msiHandle, View_tid);
@@ -2486,7 +2488,7 @@ static HRESULT create_view(MSIHANDLE msiHandle, IDispatch **dispatch)
 
 static HRESULT create_summaryinfo(MSIHANDLE msiHandle, IDispatch **disp)
 {
-    AutomationObject *info;
+    struct automation_object *info;
 
     info = malloc(sizeof(*info));
     if (!info) return E_OUTOFMEMORY;
diff --git a/dlls/msi/create.c b/dlls/msi/create.c
index c9aa8f18f23..0202a67ca18 100644
--- a/dlls/msi/create.c
+++ b/dlls/msi/create.c
@@ -38,7 +38,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 /* below is the query interface to a table */
 
-typedef struct tagMSICREATEVIEW
+struct create_view
 {
     MSIVIEW          view;
     MSIDATABASE     *db;
@@ -46,11 +46,11 @@ typedef struct tagMSICREATEVIEW
     BOOL             bIsTemp;
     BOOL             hold;
     column_info     *col_info;
-} MSICREATEVIEW;
+};
 
 static UINT CREATE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
 
     TRACE("%p %d %d %p\n", cv, row, col, val );
 
@@ -59,7 +59,7 @@ static UINT CREATE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT
 
 static UINT CREATE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
     BOOL persist = (cv->bIsTemp) ? MSICONDITION_FALSE : MSICONDITION_TRUE;
 
     TRACE("%p Table %s (%s)\n", cv, debugstr_w(cv->name),
@@ -73,7 +73,7 @@ static UINT CREATE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 
 static UINT CREATE_close( struct tagMSIVIEW *view )
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
 
     TRACE("%p\n", cv);
 
@@ -82,7 +82,7 @@ static UINT CREATE_close( struct tagMSIVIEW *view )
 
 static UINT CREATE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
 
     TRACE("%p %p %p\n", cv, rows, cols );
 
@@ -92,7 +92,7 @@ static UINT CREATE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *co
 static UINT CREATE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                     UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
 
     TRACE("%p %d %p %p %p %p\n", cv, n, name, type, temporary, table_name );
 
@@ -102,7 +102,7 @@ static UINT CREATE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *na
 static UINT CREATE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                            MSIRECORD *rec, UINT row)
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
 
     TRACE("%p %d %p\n", cv, eModifyMode, rec );
 
@@ -111,7 +111,7 @@ static UINT CREATE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 
 static UINT CREATE_delete( struct tagMSIVIEW *view )
 {
-    MSICREATEVIEW *cv = (MSICREATEVIEW*)view;
+    struct create_view *cv = (struct create_view *)view;
 
     TRACE("%p\n", cv );
 
@@ -160,7 +160,7 @@ static UINT check_columns( const column_info *col_info )
 UINT CREATE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR table,
                         column_info *col_info, BOOL hold )
 {
-    MSICREATEVIEW *cv = NULL;
+    struct create_view *cv = NULL;
     UINT r;
     column_info *col;
     BOOL temp = TRUE;
diff --git a/dlls/msi/custom.c b/dlls/msi/custom.c
index 035b2dd2c0f..8b020db260d 100644
--- a/dlls/msi/custom.c
+++ b/dlls/msi/custom.c
@@ -43,27 +43,27 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
 #define CUSTOM_ACTION_TYPE_MASK 0x3F
 
-typedef struct tagMSIRUNNINGACTION
+struct running_action
 {
     struct list entry;
     HANDLE handle;
     BOOL   process;
     LPWSTR name;
-} MSIRUNNINGACTION;
+};
 
 typedef UINT (WINAPI *MsiCustomActionEntryPoint)( MSIHANDLE );
 
-static CRITICAL_SECTION msi_custom_action_cs;
-static CRITICAL_SECTION_DEBUG msi_custom_action_cs_debug =
+static CRITICAL_SECTION custom_action_cs;
+static CRITICAL_SECTION_DEBUG custom_action_cs_debug =
 {
-    0, 0, &msi_custom_action_cs,
-    { &msi_custom_action_cs_debug.ProcessLocksList,
-      &msi_custom_action_cs_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": msi_custom_action_cs") }
+    0, 0, &custom_action_cs,
+    { &custom_action_cs_debug.ProcessLocksList,
+      &custom_action_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": custom_action_cs") }
 };
-static CRITICAL_SECTION msi_custom_action_cs = { &msi_custom_action_cs_debug, -1, 0, 0, 0, 0 };
+static CRITICAL_SECTION custom_action_cs = { &custom_action_cs_debug, -1, 0, 0, 0, 0 };
 
-static struct list msi_pending_custom_actions = LIST_INIT( msi_pending_custom_actions );
+static struct list pending_custom_actions = LIST_INIT( pending_custom_actions );
 
 void  __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
 {
@@ -171,8 +171,8 @@ static BOOL check_execution_scheduling_options(MSIPACKAGE *package, LPCWSTR acti
  *
  *    [CustomActionData<=>UserSID<=>ProductCode]Action
  */
-static LPWSTR msi_get_deferred_action(LPCWSTR action, LPCWSTR actiondata,
-                                      LPCWSTR usersid, LPCWSTR prodcode)
+static WCHAR *get_deferred_action(const WCHAR *action, const WCHAR *actiondata, const WCHAR *usersid,
+                                  const WCHAR *prodcode)
 {
     LPWSTR deferred;
     DWORD len;
@@ -298,9 +298,9 @@ static MSIBINARY *get_temp_binary(MSIPACKAGE *package, LPCWSTR source)
 static void file_running_action(MSIPACKAGE* package, HANDLE Handle,
                                 BOOL process, LPCWSTR name)
 {
-    MSIRUNNINGACTION *action;
+    struct running_action *action;
 
-    action = malloc( sizeof(MSIRUNNINGACTION) );
+    action = malloc( sizeof(*action) );
 
     action->handle = Handle;
     action->process = process;
@@ -373,7 +373,8 @@ static UINT wait_process_handle(MSIPACKAGE* package, UINT type,
     return rc;
 }
 
-typedef struct _msi_custom_action_info {
+typedef struct
+{
     struct list entry;
     MSIPACKAGE *package;
     LPWSTR source;
@@ -383,11 +384,11 @@ typedef struct _msi_custom_action_info {
     INT type;
     GUID guid;
     DWORD arch;
-} msi_custom_action_info;
+} custom_action_info;
 
-static void free_custom_action_data( msi_custom_action_info *info )
+static void free_custom_action_data( custom_action_info *info )
 {
-    EnterCriticalSection( &msi_custom_action_cs );
+    EnterCriticalSection( &custom_action_cs );
 
     list_remove( &info->entry );
     if (info->handle)
@@ -398,10 +399,10 @@ static void free_custom_action_data( msi_custom_action_info *info )
     msiobj_release( &info->package->hdr );
     free( info );
 
-    LeaveCriticalSection( &msi_custom_action_cs );
+    LeaveCriticalSection( &custom_action_cs );
 }
 
-static UINT wait_thread_handle( msi_custom_action_info *info )
+static UINT wait_thread_handle( custom_action_info *info )
 {
     UINT rc = ERROR_SUCCESS;
 
@@ -424,14 +425,14 @@ static UINT wait_thread_handle( msi_custom_action_info *info )
     return rc;
 }
 
-static msi_custom_action_info *find_action_by_guid( const GUID *guid )
+static custom_action_info *find_action_by_guid( const GUID *guid )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     BOOL found = FALSE;
 
-    EnterCriticalSection( &msi_custom_action_cs );
+    EnterCriticalSection( &custom_action_cs );
 
-    LIST_FOR_EACH_ENTRY( info, &msi_pending_custom_actions, msi_custom_action_info, entry )
+    LIST_FOR_EACH_ENTRY( info, &pending_custom_actions, custom_action_info, entry )
     {
         if (IsEqualGUID( &info->guid, guid ))
         {
@@ -440,7 +441,7 @@ static msi_custom_action_info *find_action_by_guid( const GUID *guid )
         }
     }
 
-    LeaveCriticalSection( &msi_custom_action_cs );
+    LeaveCriticalSection( &custom_action_cs );
 
     if (!found)
         return NULL;
@@ -642,7 +643,7 @@ void custom_stop_server(HANDLE process, HANDLE pipe)
 
 static DWORD WINAPI custom_client_thread(void *arg)
 {
-    msi_custom_action_info *info = arg;
+    custom_action_info *info = arg;
     DWORD64 thread64;
     HANDLE process;
     HANDLE thread;
@@ -663,23 +664,23 @@ static DWORD WINAPI custom_client_thread(void *arg)
         pipe = info->package->custom_server_64_pipe;
     }
 
-    EnterCriticalSection(&msi_custom_action_cs);
+    EnterCriticalSection(&custom_action_cs);
 
     if (!WriteFile(pipe, &info->guid, sizeof(info->guid), &size, NULL) ||
         size != sizeof(info->guid))
     {
         ERR("failed to write to custom action client pipe: %lu\n", GetLastError());
-        LeaveCriticalSection(&msi_custom_action_cs);
+        LeaveCriticalSection(&custom_action_cs);
         return GetLastError();
     }
     if (!ReadFile(pipe, &thread64, sizeof(thread64), &size, NULL) || size != sizeof(thread64))
     {
         ERR("failed to read from custom action client pipe: %lu\n", GetLastError());
-        LeaveCriticalSection(&msi_custom_action_cs);
+        LeaveCriticalSection(&custom_action_cs);
         return GetLastError();
     }
 
-    LeaveCriticalSection(&msi_custom_action_cs);
+    LeaveCriticalSection(&custom_action_cs);
 
     if (DuplicateHandle(process, (HANDLE)(DWORD_PTR)thread64, GetCurrentProcess(),
         &thread, 0, FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
@@ -740,10 +741,10 @@ static BOOL get_binary_type( const WCHAR *name, DWORD *type )
     }
 }
 
-static msi_custom_action_info *do_msidbCustomActionTypeDll(
+static custom_action_info *do_msidbCustomActionTypeDll(
     MSIPACKAGE *package, INT type, LPCWSTR source, LPCWSTR target, LPCWSTR action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     RPC_STATUS status;
     BOOL ret;
 
@@ -759,9 +760,9 @@ static msi_custom_action_info *do_msidbCustomActionTypeDll(
     info->action = wcsdup( action );
     CoCreateGuid( &info->guid );
 
-    EnterCriticalSection( &msi_custom_action_cs );
-    list_add_tail( &msi_pending_custom_actions, &info->entry );
-    LeaveCriticalSection( &msi_custom_action_cs );
+    EnterCriticalSection( &custom_action_cs );
+    list_add_tail( &pending_custom_actions, &info->entry );
+    LeaveCriticalSection( &custom_action_cs );
 
     if (!package->rpc_server_started)
     {
@@ -813,7 +814,7 @@ static msi_custom_action_info *do_msidbCustomActionTypeDll(
 static UINT HANDLE_CustomType1( MSIPACKAGE *package, const WCHAR *source, const WCHAR *target,
                                 INT type, const WCHAR *action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     MSIBINARY *binary;
 
     if (!(binary = get_temp_binary(package, source)))
@@ -915,7 +916,7 @@ static UINT HANDLE_CustomType2( MSIPACKAGE *package, const WCHAR *source, const
 static UINT HANDLE_CustomType17( MSIPACKAGE *package, const WCHAR *source, const WCHAR *target,
                                  INT type, const WCHAR *action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     MSIFILE *file;
 
     TRACE("%s %s\n", debugstr_w(source), debugstr_w(target));
@@ -1148,7 +1149,7 @@ static UINT HANDLE_CustomType34( MSIPACKAGE *package, const WCHAR *source, const
 
 static DWORD ACTION_CallScript( const GUID *guid )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     MSIHANDLE hPackage;
     UINT r = ERROR_FUNCTION_FAILED;
 
@@ -1189,10 +1190,10 @@ static DWORD WINAPI ScriptThread( LPVOID arg )
     return rc;
 }
 
-static msi_custom_action_info *do_msidbCustomActionTypeScript(
+static custom_action_info *do_msidbCustomActionTypeScript(
     MSIPACKAGE *package, INT type, LPCWSTR script, LPCWSTR function, LPCWSTR action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
 
     info = malloc( sizeof *info );
     if (!info)
@@ -1206,9 +1207,9 @@ static msi_custom_action_info *do_msidbCustomActionTypeScript(
     info->action = wcsdup( action );
     CoCreateGuid( &info->guid );
 
-    EnterCriticalSection( &msi_custom_action_cs );
-    list_add_tail( &msi_pending_custom_actions, &info->entry );
-    LeaveCriticalSection( &msi_custom_action_cs );
+    EnterCriticalSection( &custom_action_cs );
+    list_add_tail( &pending_custom_actions, &info->entry );
+    LeaveCriticalSection( &custom_action_cs );
 
     info->handle = CreateThread( NULL, 0, ScriptThread, &info->guid, 0, NULL );
     if (!info->handle)
@@ -1223,7 +1224,7 @@ static msi_custom_action_info *do_msidbCustomActionTypeScript(
 static UINT HANDLE_CustomType37_38( MSIPACKAGE *package, const WCHAR *source, const WCHAR *target,
                                     INT type, const WCHAR *action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
 
     TRACE("%s %s\n", debugstr_w(source), debugstr_w(target));
 
@@ -1235,7 +1236,7 @@ static UINT HANDLE_CustomType5_6( MSIPACKAGE *package, const WCHAR *source, cons
                                   INT type, const WCHAR *action )
 {
     MSIRECORD *row = NULL;
-    msi_custom_action_info *info;
+    custom_action_info *info;
     CHAR *buffer = NULL;
     WCHAR *bufferw = NULL;
     DWORD sz = 0;
@@ -1282,7 +1283,7 @@ done:
 static UINT HANDLE_CustomType21_22( MSIPACKAGE *package, const WCHAR *source, const WCHAR *target,
                                     INT type, const WCHAR *action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     MSIFILE *file;
     HANDLE hFile;
     DWORD sz, szHighWord = 0, read;
@@ -1341,7 +1342,7 @@ done:
 static UINT HANDLE_CustomType53_54( MSIPACKAGE *package, const WCHAR *source, const WCHAR *target,
                                     INT type, const WCHAR *action )
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
     WCHAR *prop;
 
     TRACE("%s %s\n", debugstr_w(source), debugstr_w(target));
@@ -1377,7 +1378,7 @@ static UINT defer_custom_action( MSIPACKAGE *package, const WCHAR *action, UINT
     WCHAR *actiondata = msi_dup_property( package->db, action );
     WCHAR *usersid = msi_dup_property( package->db, L"UserSID" );
     WCHAR *prodcode = msi_dup_property( package->db, L"ProductCode" );
-    WCHAR *deferred = msi_get_deferred_action( action, actiondata, usersid, prodcode );
+    WCHAR *deferred = get_deferred_action( action, actiondata, usersid, prodcode );
 
     if (!deferred)
     {
@@ -1558,11 +1559,11 @@ void ACTION_FinishCustomActions(const MSIPACKAGE* package)
     struct list *item;
     HANDLE *wait_handles;
     unsigned int handle_count, i;
-    msi_custom_action_info *info, *cursor;
+    custom_action_info *info, *cursor;
 
     while ((item = list_head( &package->RunningActions )))
     {
-        MSIRUNNINGACTION *action = LIST_ENTRY( item, MSIRUNNINGACTION, entry );
+        struct running_action *action = LIST_ENTRY( item, struct running_action, entry );
 
         list_remove( &action->entry );
 
@@ -1574,13 +1575,13 @@ void ACTION_FinishCustomActions(const MSIPACKAGE* package)
         free( action );
     }
 
-    EnterCriticalSection( &msi_custom_action_cs );
+    EnterCriticalSection( &custom_action_cs );
 
-    handle_count = list_count( &msi_pending_custom_actions );
+    handle_count = list_count( &pending_custom_actions );
     wait_handles = malloc( handle_count * sizeof(HANDLE) );
 
     handle_count = 0;
-    LIST_FOR_EACH_ENTRY_SAFE( info, cursor, &msi_pending_custom_actions, msi_custom_action_info, entry )
+    LIST_FOR_EACH_ENTRY_SAFE( info, cursor, &pending_custom_actions, custom_action_info, entry )
     {
         if (info->package == package )
         {
@@ -1589,7 +1590,7 @@ void ACTION_FinishCustomActions(const MSIPACKAGE* package)
         }
     }
 
-    LeaveCriticalSection( &msi_custom_action_cs );
+    LeaveCriticalSection( &custom_action_cs );
 
     for (i = 0; i < handle_count; i++)
     {
@@ -1598,18 +1599,18 @@ void ACTION_FinishCustomActions(const MSIPACKAGE* package)
     }
     free( wait_handles );
 
-    EnterCriticalSection( &msi_custom_action_cs );
-    LIST_FOR_EACH_ENTRY_SAFE( info, cursor, &msi_pending_custom_actions, msi_custom_action_info, entry )
+    EnterCriticalSection( &custom_action_cs );
+    LIST_FOR_EACH_ENTRY_SAFE( info, cursor, &pending_custom_actions, custom_action_info, entry )
     {
         if (info->package == package)
             free_custom_action_data( info );
     }
-    LeaveCriticalSection( &msi_custom_action_cs );
+    LeaveCriticalSection( &custom_action_cs );
 }
 
 UINT __cdecl s_remote_GetActionInfo(const GUID *guid, WCHAR **name, int *type, WCHAR **dll, char **func, MSIHANDLE *hinst)
 {
-    msi_custom_action_info *info;
+    custom_action_info *info;
 
     info = find_action_by_guid(guid);
     if (!info)
diff --git a/dlls/msi/database.c b/dlls/msi/database.c
index c0845fbadcb..20c74c4d742 100644
--- a/dlls/msi/database.c
+++ b/dlls/msi/database.c
@@ -347,7 +347,7 @@ end:
     return r;
 }
 
-static LPWSTR msi_read_text_archive(LPCWSTR path, DWORD *len)
+static WCHAR *read_text_archive(const WCHAR *path, DWORD *len)
 {
     HANDLE file;
     LPSTR data = NULL;
@@ -377,7 +377,7 @@ done:
     return wdata;
 }
 
-static void msi_parse_line(LPWSTR *line, LPWSTR **entries, DWORD *num_entries, DWORD *len)
+static void parse_line(WCHAR **line, WCHAR ***entries, DWORD *num_entries, DWORD *len)
 {
     LPWSTR ptr = *line, save;
     DWORD i, count = 1, chars_left = *len;
@@ -446,7 +446,7 @@ static void msi_parse_line(LPWSTR *line, LPWSTR **entries, DWORD *num_entries, D
         *num_entries = count;
 }
 
-static LPWSTR msi_build_createsql_prelude(LPWSTR table)
+static WCHAR *build_createsql_prelude(const WCHAR *table)
 {
     LPWSTR prelude;
     DWORD size;
@@ -460,7 +460,7 @@ static LPWSTR msi_build_createsql_prelude(LPWSTR table)
     return prelude;
 }
 
-static LPWSTR msi_build_createsql_columns(LPWSTR *columns_data, LPWSTR *types, DWORD num_columns)
+static WCHAR *build_createsql_columns(WCHAR **columns_data, WCHAR **types, DWORD num_columns)
 {
     LPWSTR columns, p;
     LPCWSTR type;
@@ -547,7 +547,7 @@ static LPWSTR msi_build_createsql_columns(LPWSTR *columns_data, LPWSTR *types, D
     return columns;
 }
 
-static LPWSTR msi_build_createsql_postlude(LPWSTR *primary_keys, DWORD num_keys)
+static WCHAR *build_createsql_postlude(WCHAR **primary_keys, DWORD num_keys)
 {
     LPWSTR postlude, keys, ptr;
     DWORD size, i;
@@ -579,7 +579,8 @@ done:
     return postlude;
 }
 
-static UINT msi_add_table_to_db(MSIDATABASE *db, LPWSTR *columns, LPWSTR *types, LPWSTR *labels, DWORD num_labels, DWORD num_columns)
+static UINT add_table_to_db(MSIDATABASE *db, WCHAR **columns, WCHAR **types, WCHAR **labels, DWORD num_labels,
+                            DWORD num_columns)
 {
     UINT r = ERROR_OUTOFMEMORY;
     DWORD size;
@@ -587,9 +588,9 @@ static UINT msi_add_table_to_db(MSIDATABASE *db, LPWSTR *columns, LPWSTR *types,
     LPWSTR create_sql = NULL;
     LPWSTR prelude, columns_sql, postlude;
 
-    prelude = msi_build_createsql_prelude(labels[0]);
-    columns_sql = msi_build_createsql_columns(columns, types, num_columns);
-    postlude = msi_build_createsql_postlude(labels + 1, num_labels - 1); /* skip over table name */
+    prelude = build_createsql_prelude(labels[0]);
+    columns_sql = build_createsql_columns(columns, types, num_columns);
+    postlude = build_createsql_postlude(labels + 1, num_labels - 1); /* skip over table name */
 
     if (!prelude || !columns_sql || !postlude)
         goto done;
@@ -619,7 +620,7 @@ done:
     return r;
 }
 
-static LPWSTR msi_import_stream_filename(LPCWSTR path, LPCWSTR name)
+static WCHAR *import_stream_filename(const WCHAR *path, const WCHAR *name)
 {
     DWORD len;
     LPWSTR fullname, ptr;
@@ -667,7 +668,7 @@ static UINT construct_record(DWORD num_columns, LPWSTR *types,
                 if (*data[i])
                 {
                     UINT r;
-                    LPWSTR file = msi_import_stream_filename(path, data[i]);
+                    WCHAR *file = import_stream_filename(path, data[i]);
                     if (!file)
                         return ERROR_FUNCTION_FAILED;
 
@@ -687,10 +688,8 @@ static UINT construct_record(DWORD num_columns, LPWSTR *types,
     return ERROR_SUCCESS;
 }
 
-static UINT msi_add_records_to_table(MSIDATABASE *db, LPWSTR *columns, LPWSTR *types,
-                                     LPWSTR *labels, LPWSTR **records,
-                                     int num_columns, int num_records,
-                                     LPWSTR path)
+static UINT add_records_to_table(MSIDATABASE *db, WCHAR **columns, WCHAR **types, WCHAR **labels, WCHAR ***records,
+                                 int num_columns, int num_records, WCHAR *path)
 {
     UINT r;
     int i;
@@ -750,7 +749,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
     lstrcatW( path, L"\\" );
     lstrcatW( path, file );
 
-    data = msi_read_text_archive( path, &len );
+    data = read_text_archive( path, &len );
     if (!data)
     {
         free(path);
@@ -758,9 +757,9 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
     }
 
     ptr = data;
-    msi_parse_line( &ptr, &columns, &num_columns, &len );
-    msi_parse_line( &ptr, &types, &num_types, &len );
-    msi_parse_line( &ptr, &labels, &num_labels, &len );
+    parse_line( &ptr, &columns, &num_columns, &len );
+    parse_line( &ptr, &types, &num_types, &len );
+    parse_line( &ptr, &labels, &num_labels, &len );
 
     if (num_columns == 1 && !columns[0][0] && num_labels == 1 && !labels[0][0] &&
         num_types == 2 && !wcscmp( types[1], L"_ForceCodepage" ))
@@ -785,7 +784,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
     /* read in the table records */
     while (len)
     {
-        msi_parse_line( &ptr, &records[num_records], NULL, &len );
+        parse_line( &ptr, &records[num_records], NULL, &len );
 
         num_records++;
         temp_records = realloc(records, (num_records + 1) * sizeof(WCHAR **));
@@ -810,7 +809,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
     {
         if (!TABLE_Exists(db, labels[0]))
         {
-            r = msi_add_table_to_db( db, columns, types, labels, num_labels, num_columns );
+            r = add_table_to_db( db, columns, types, labels, num_labels, num_columns );
             if (r != ERROR_SUCCESS)
             {
                 r = ERROR_FUNCTION_FAILED;
@@ -818,7 +817,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
             }
         }
 
-        r = msi_add_records_to_table( db, columns, types, labels, records, num_columns, num_records, path );
+        r = add_records_to_table( db, columns, types, labels, records, num_columns, num_records, path );
     }
 
 done:
@@ -880,7 +879,7 @@ end:
     return r;
 }
 
-static UINT msi_export_field( HANDLE handle, MSIRECORD *row, UINT field )
+static UINT export_field( HANDLE handle, MSIRECORD *row, UINT field )
 {
     char *buffer;
     BOOL ret;
@@ -923,7 +922,7 @@ static UINT msi_export_field( HANDLE handle, MSIRECORD *row, UINT field )
     return ret ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
 }
 
-static UINT msi_export_stream( const WCHAR *folder, const WCHAR *table, MSIRECORD *row, UINT field, UINT start )
+static UINT export_stream( const WCHAR *folder, const WCHAR *table, MSIRECORD *row, UINT field, UINT start )
 {
     WCHAR stream[MAX_STREAM_NAME_LEN + 1], *path;
     DWORD sz, read_size, write_size;
@@ -981,7 +980,7 @@ struct row_export_info
     const WCHAR *table;
 };
 
-static UINT msi_export_record( struct row_export_info *row_export_info, MSIRECORD *row, UINT start )
+static UINT export_record( struct row_export_info *row_export_info, MSIRECORD *row, UINT start )
 {
     HANDLE handle = row_export_info->handle;
     UINT i, count, r = ERROR_SUCCESS;
@@ -991,15 +990,15 @@ static UINT msi_export_record( struct row_export_info *row_export_info, MSIRECOR
     count = MSI_RecordGetFieldCount( row );
     for (i = start; i <= count; i++)
     {
-        r = msi_export_field( handle, row, i );
+        r = export_field( handle, row, i );
         if (r == ERROR_INVALID_PARAMETER)
         {
-            r = msi_export_stream( row_export_info->folder, row_export_info->table, row, i, start );
+            r = export_stream( row_export_info->folder, row_export_info->table, row, i, start );
             if (r != ERROR_SUCCESS)
                 return r;
 
             /* exporting a binary stream, repeat the "Name" field */
-            r = msi_export_field( handle, row, start );
+            r = export_field( handle, row, start );
             if (r != ERROR_SUCCESS)
                 return r;
         }
@@ -1013,12 +1012,12 @@ static UINT msi_export_record( struct row_export_info *row_export_info, MSIRECOR
     return r;
 }
 
-static UINT msi_export_row( MSIRECORD *row, void *arg )
+static UINT export_row( MSIRECORD *row, void *arg )
 {
-    return msi_export_record( arg, row, 1 );
+    return export_record( arg, row, 1 );
 }
 
-static UINT msi_export_forcecodepage( HANDLE handle, UINT codepage )
+static UINT export_forcecodepage( HANDLE handle, UINT codepage )
 {
     static const char fmt[] = "\r\n\r\n%u\t_ForceCodepage\r\n";
     char data[sizeof(fmt) + 10];
@@ -1030,7 +1029,7 @@ static UINT msi_export_forcecodepage( HANDLE handle, UINT codepage )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_export_summaryinformation( MSIDATABASE *db, HANDLE handle )
+static UINT export_summaryinformation( MSIDATABASE *db, HANDLE handle )
 {
     static const char header[] = "PropertyId\tValue\r\n"
                                  "i2\tl255\r\n"
@@ -1075,13 +1074,13 @@ static UINT MSI_DatabaseExport( MSIDATABASE *db, LPCWSTR table, LPCWSTR folder,
     if (!wcscmp( table, L"_ForceCodepage" ))
     {
         UINT codepage = msi_get_string_table_codepage( db->strings );
-        r = msi_export_forcecodepage( handle, codepage );
+        r = export_forcecodepage( handle, codepage );
         goto done;
     }
 
     if (!wcscmp( table, L"_SummaryInformation" ))
     {
-        r = msi_export_summaryinformation( db, handle );
+        r = export_summaryinformation( db, handle );
         goto done;
     }
 
@@ -1094,7 +1093,7 @@ static UINT MSI_DatabaseExport( MSIDATABASE *db, LPCWSTR table, LPCWSTR folder,
         r = MSI_ViewGetColumnInfo(view, MSICOLINFO_NAMES, &rec);
         if (r == ERROR_SUCCESS)
         {
-            msi_export_record( &row_export_info, rec, 1 );
+            export_record( &row_export_info, rec, 1 );
             msiobj_release( &rec->hdr );
         }
 
@@ -1102,7 +1101,7 @@ static UINT MSI_DatabaseExport( MSIDATABASE *db, LPCWSTR table, LPCWSTR folder,
         r = MSI_ViewGetColumnInfo(view, MSICOLINFO_TYPES, &rec);
         if (r == ERROR_SUCCESS)
         {
-            msi_export_record( &row_export_info, rec, 1 );
+            export_record( &row_export_info, rec, 1 );
             msiobj_release( &rec->hdr );
         }
 
@@ -1111,12 +1110,12 @@ static UINT MSI_DatabaseExport( MSIDATABASE *db, LPCWSTR table, LPCWSTR folder,
         if (r == ERROR_SUCCESS)
         {
             MSI_RecordSetStringW( rec, 0, table );
-            msi_export_record( &row_export_info, rec, 0 );
+            export_record( &row_export_info, rec, 0 );
             msiobj_release( &rec->hdr );
         }
 
         /* write out row 4 onwards, the data */
-        r = MSI_IterateRecords( view, 0, msi_export_row, &row_export_info );
+        r = MSI_IterateRecords( view, 0, export_row, &row_export_info );
         msiobj_release( &view->hdr );
     }
 
@@ -1207,7 +1206,7 @@ UINT WINAPI MsiDatabaseMergeA( MSIHANDLE hDatabase, MSIHANDLE hDatabaseMerge, co
     return r;
 }
 
-typedef struct _tagMERGETABLE
+struct merge_table
 {
     struct list entry;
     struct list rows;
@@ -1219,22 +1218,22 @@ typedef struct _tagMERGETABLE
     DWORD numtypes;
     LPWSTR *labels;
     DWORD numlabels;
-} MERGETABLE;
+};
 
-typedef struct _tagMERGEROW
+struct merge_row
 {
     struct list entry;
     MSIRECORD *data;
-} MERGEROW;
+};
 
-typedef struct _tagMERGEDATA
+struct merge_data
 {
     MSIDATABASE *db;
     MSIDATABASE *merge;
-    MERGETABLE *curtable;
+    struct merge_table *curtable;
     MSIQUERY *curview;
     struct list *tabledata;
-} MERGEDATA;
+};
 
 static BOOL merge_type_match(LPCWSTR type1, LPCWSTR type2)
 {
@@ -1412,7 +1411,7 @@ static LPWSTR get_key_value(MSIQUERY *view, LPCWSTR key, MSIRECORD *rec)
 static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
                                     LPWSTR table, MSIRECORD *rec)
 {
-    LPWSTR query = NULL, clause = NULL, val;
+    WCHAR *query = NULL, *clause = NULL, *new_clause, *val;
     LPCWSTR setptr, key;
     DWORD size, oldsize;
     MSIRECORD *keys;
@@ -1422,10 +1421,6 @@ static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
     if (r != ERROR_SUCCESS)
         return NULL;
 
-    clause = calloc(1, sizeof(WCHAR));
-    if (!clause)
-        goto done;
-
     size = 1;
     count = MSI_RecordGetFieldCount(keys);
     for (i = 1; i <= count; i++)
@@ -1440,12 +1435,13 @@ static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
 
         oldsize = size;
         size += lstrlenW(setptr) + lstrlenW(key) + lstrlenW(val) - 4;
-        clause = realloc(clause, size * sizeof(WCHAR));
-        if (!clause)
+        new_clause = realloc(clause, size * sizeof(WCHAR));
+        if (!new_clause)
         {
             free(val);
             goto done;
         }
+        clause = new_clause;
 
         swprintf(clause + oldsize - 1, size - (oldsize - 1), setptr, key, val);
         free(val);
@@ -1466,9 +1462,9 @@ done:
 
 static UINT merge_diff_row(MSIRECORD *rec, LPVOID param)
 {
-    MERGEDATA *data = param;
-    MERGETABLE *table = data->curtable;
-    MERGEROW *mergerow;
+    struct merge_data *data = param;
+    struct merge_table *table = data->curtable;
+    struct merge_row *mergerow;
     MSIQUERY *dbview = NULL;
     MSIRECORD *row = NULL;
     LPWSTR query = NULL;
@@ -1500,7 +1496,7 @@ static UINT merge_diff_row(MSIRECORD *rec, LPVOID param)
         r = ERROR_SUCCESS;
     }
 
-    mergerow = malloc(sizeof(MERGEROW));
+    mergerow = malloc(sizeof(*mergerow));
     if (!mergerow)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1524,7 +1520,7 @@ done:
     return r;
 }
 
-static UINT msi_get_table_labels(MSIDATABASE *db, LPCWSTR table, LPWSTR **labels, DWORD *numlabels)
+static UINT get_table_labels(MSIDATABASE *db, const WCHAR *table, WCHAR ***labels, DWORD *numlabels)
 {
     UINT r, i, count;
     MSIRECORD *prec = NULL;
@@ -1553,7 +1549,7 @@ end:
     return r;
 }
 
-static UINT msi_get_query_columns(MSIQUERY *query, LPWSTR **columns, DWORD *numcolumns)
+static UINT get_query_columns(MSIQUERY *query, WCHAR ***columns, DWORD *numcolumns)
 {
     UINT r, i, count;
     MSIRECORD *prec = NULL;
@@ -1582,7 +1578,7 @@ end:
     return r;
 }
 
-static UINT msi_get_query_types(MSIQUERY *query, LPWSTR **types, DWORD *numtypes)
+static UINT get_query_types(MSIQUERY *query, WCHAR ***types, DWORD *numtypes)
 {
     UINT r, i, count;
     MSIRECORD *prec = NULL;
@@ -1610,13 +1606,13 @@ end:
     return r;
 }
 
-static void merge_free_rows(MERGETABLE *table)
+static void merge_free_rows(struct merge_table *table)
 {
     struct list *item, *cursor;
 
     LIST_FOR_EACH_SAFE(item, cursor, &table->rows)
     {
-        MERGEROW *row = LIST_ENTRY(item, MERGEROW, entry);
+        struct merge_row *row = LIST_ENTRY(item, struct merge_row, entry);
 
         list_remove(&row->entry);
         msiobj_release(&row->data->hdr);
@@ -1624,7 +1620,7 @@ static void merge_free_rows(MERGETABLE *table)
     }
 }
 
-static void free_merge_table(MERGETABLE *table)
+static void free_merge_table(struct merge_table *table)
 {
     UINT i;
 
@@ -1658,20 +1654,20 @@ static void free_merge_table(MERGETABLE *table)
     free(table);
 }
 
-static UINT msi_get_merge_table (MSIDATABASE *db, LPCWSTR name, MERGETABLE **ptable)
+static UINT get_merge_table(MSIDATABASE *db, const WCHAR *name, struct merge_table **ptable)
 {
     UINT r;
-    MERGETABLE *table;
+    struct merge_table *table;
     MSIQUERY *mergeview = NULL;
 
-    table = calloc(1, sizeof(MERGETABLE));
+    table = calloc(1, sizeof(*table));
     if (!table)
     {
        *ptable = NULL;
        return ERROR_OUTOFMEMORY;
     }
 
-    r = msi_get_table_labels(db, name, &table->labels, &table->numlabels);
+    r = get_table_labels(db, name, &table->labels, &table->numlabels);
     if (r != ERROR_SUCCESS)
         goto err;
 
@@ -1679,11 +1675,11 @@ static UINT msi_get_merge_table (MSIDATABASE *db, LPCWSTR name, MERGETABLE **pta
     if (r != ERROR_SUCCESS)
         goto err;
 
-    r = msi_get_query_columns(mergeview, &table->columns, &table->numcolumns);
+    r = get_query_columns(mergeview, &table->columns, &table->numcolumns);
     if (r != ERROR_SUCCESS)
         goto err;
 
-    r = msi_get_query_types(mergeview, &table->types, &table->numtypes);
+    r = get_query_types(mergeview, &table->types, &table->numtypes);
     if (r != ERROR_SUCCESS)
         goto err;
 
@@ -1705,8 +1701,8 @@ err:
 
 static UINT merge_diff_tables(MSIRECORD *rec, LPVOID param)
 {
-    MERGEDATA *data = param;
-    MERGETABLE *table;
+    struct merge_data *data = param;
+    struct merge_table *table;
     MSIQUERY *dbview = NULL;
     MSIQUERY *mergeview = NULL;
     LPCWSTR name;
@@ -1733,7 +1729,7 @@ static UINT merge_diff_tables(MSIRECORD *rec, LPVOID param)
             goto done;
     }
 
-    r = msi_get_merge_table(data->merge, name, &table);
+    r = get_merge_table(data->merge, name, &table);
     if (r != ERROR_SUCCESS)
         goto done;
 
@@ -1758,7 +1754,7 @@ static UINT gather_merge_data(MSIDATABASE *db, MSIDATABASE *merge,
                               struct list *tabledata)
 {
     MSIQUERY *view;
-    MERGEDATA data;
+    struct merge_data data;
     UINT r;
 
     r = MSI_DatabaseOpenViewW(merge, L"SELECT * FROM `_Tables`", &view);
@@ -1773,21 +1769,20 @@ static UINT gather_merge_data(MSIDATABASE *db, MSIDATABASE *merge,
     return r;
 }
 
-static UINT merge_table(MSIDATABASE *db, MERGETABLE *table)
+static UINT merge_table(MSIDATABASE *db, struct merge_table *table)
 {
     UINT r;
-    MERGEROW *row;
+    struct merge_row *row;
     MSIVIEW *tv;
 
     if (!TABLE_Exists(db, table->name))
     {
-        r = msi_add_table_to_db(db, table->columns, table->types,
-               table->labels, table->numlabels, table->numcolumns);
+        r = add_table_to_db(db, table->columns, table->types, table->labels, table->numlabels, table->numcolumns);
         if (r != ERROR_SUCCESS)
            return ERROR_FUNCTION_FAILED;
     }
 
-    LIST_FOR_EACH_ENTRY(row, &table->rows, MERGEROW, entry)
+    LIST_FOR_EACH_ENTRY(row, &table->rows, struct merge_row, entry)
     {
         r = TABLE_CreateView(db, table->name, &tv);
         if (r != ERROR_SUCCESS)
@@ -1837,7 +1832,7 @@ UINT WINAPI MsiDatabaseMergeW( MSIHANDLE hDatabase, MSIHANDLE hDatabaseMerge, co
     struct list tabledata = LIST_INIT(tabledata);
     struct list *item, *cursor;
     MSIDATABASE *db, *merge;
-    MERGETABLE *table;
+    struct merge_table *table;
     BOOL conflicts;
     UINT r;
 
@@ -1859,7 +1854,7 @@ UINT WINAPI MsiDatabaseMergeW( MSIHANDLE hDatabase, MSIHANDLE hDatabaseMerge, co
         goto done;
 
     conflicts = FALSE;
-    LIST_FOR_EACH_ENTRY(table, &tabledata, MERGETABLE, entry)
+    LIST_FOR_EACH_ENTRY(table, &tabledata, struct merge_table, entry)
     {
         if (table->numconflicts)
         {
@@ -1880,7 +1875,7 @@ UINT WINAPI MsiDatabaseMergeW( MSIHANDLE hDatabase, MSIHANDLE hDatabaseMerge, co
 
     LIST_FOR_EACH_SAFE(item, cursor, &tabledata)
     {
-        MERGETABLE *table = LIST_ENTRY(item, MERGETABLE, entry);
+        struct merge_table *table = LIST_ENTRY(item, struct merge_table, entry);
         list_remove(&table->entry);
         free_merge_table(table);
     }
diff --git a/dlls/msi/delete.c b/dlls/msi/delete.c
index e0dafdd7068..1d80dce8d87 100644
--- a/dlls/msi/delete.c
+++ b/dlls/msi/delete.c
@@ -48,16 +48,16 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
  * that's a bug in the way I'm running the query, or a just a bug.
  */
 
-typedef struct tagMSIDELETEVIEW
+struct delete_view
 {
     MSIVIEW        view;
     MSIDATABASE   *db;
     MSIVIEW       *table;
-} MSIDELETEVIEW;
+};
 
 static UINT DELETE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p %d %d %p\n", dv, row, col, val );
 
@@ -66,7 +66,7 @@ static UINT DELETE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT
 
 static UINT DELETE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm)
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p %d %d %p\n", dv, row, col, stm );
 
@@ -75,7 +75,7 @@ static UINT DELETE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IS
 
 static UINT DELETE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
     UINT r, i, rows = 0, cols = 0;
 
     TRACE("%p %p\n", dv, record);
@@ -102,7 +102,7 @@ static UINT DELETE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 
 static UINT DELETE_close( struct tagMSIVIEW *view )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p\n", dv );
 
@@ -114,7 +114,7 @@ static UINT DELETE_close( struct tagMSIVIEW *view )
 
 static UINT DELETE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p %p %p\n", dv, rows, cols );
 
@@ -129,7 +129,7 @@ static UINT DELETE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *co
 static UINT DELETE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                     UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p %d %p %p %p %p\n", dv, n, name, type, temporary, table_name );
 
@@ -143,7 +143,7 @@ static UINT DELETE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *na
 static UINT DELETE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                            MSIRECORD *rec, UINT row )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p %d %p\n", dv, eModifyMode, rec );
 
@@ -152,7 +152,7 @@ static UINT DELETE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 
 static UINT DELETE_delete( struct tagMSIVIEW *view )
 {
-    MSIDELETEVIEW *dv = (MSIDELETEVIEW*)view;
+    struct delete_view *dv = (struct delete_view *)view;
 
     TRACE("%p\n", dv );
 
@@ -189,7 +189,7 @@ static const MSIVIEWOPS delete_ops =
 
 UINT DELETE_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table )
 {
-    MSIDELETEVIEW *dv = NULL;
+    struct delete_view *dv = NULL;
 
     TRACE("%p\n", dv );
 
diff --git a/dlls/msi/dialog.c b/dlls/msi/dialog.c
index e5a2208cb6f..91e7a567f55 100644
--- a/dlls/msi/dialog.c
+++ b/dlls/msi/dialog.c
@@ -49,19 +49,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
 extern HINSTANCE msi_hInstance;
 
-struct msi_control_tag;
-typedef struct msi_control_tag msi_control;
-typedef UINT (*msi_handler)( msi_dialog *, msi_control *, WPARAM );
-typedef void (*msi_update)( msi_dialog *, msi_control * );
-typedef UINT (*control_event_handler)( msi_dialog *, const WCHAR *, const WCHAR * );
-typedef UINT (*event_handler)( msi_dialog *, const WCHAR * );
-
-struct msi_control_tag
+struct control
 {
     struct list entry;
     HWND hwnd;
-    msi_handler handler;
-    msi_update update;
+    UINT (*handler)( msi_dialog *, struct control *, WPARAM );
+    void (*update)( msi_dialog *, struct control * );
     LPWSTR property;
     LPWSTR value;
     HBITMAP hBitmap;
@@ -77,19 +70,19 @@ struct msi_control_tag
     WCHAR name[1];
 };
 
-typedef struct msi_font_tag
+struct font
 {
     struct list entry;
     HFONT hfont;
     COLORREF color;
     WCHAR name[1];
-} msi_font;
+};
 
 struct msi_dialog_tag
 {
     MSIPACKAGE *package;
     msi_dialog *parent;
-    control_event_handler event_handler;
+    UINT (*event_handler)( msi_dialog *, const WCHAR *, const WCHAR * );
     BOOL finished;
     INT scale;
     DWORD attributes;
@@ -101,7 +94,7 @@ struct msi_dialog_tag
     HWND hWndFocus;
     LPWSTR control_default;
     LPWSTR control_cancel;
-    event_handler pending_event;
+    UINT (*pending_event)( msi_dialog *, const WCHAR * );
     LPWSTR pending_argument;
     INT retval;
     WCHAR name[1];
@@ -116,19 +109,18 @@ struct subscriber
     WCHAR      *attribute;
 };
 
-typedef UINT (*msi_dialog_control_func)( msi_dialog *dialog, MSIRECORD *rec );
 struct control_handler
 {
     LPCWSTR control_type;
-    msi_dialog_control_func func;
+    UINT (*func)( msi_dialog *dialog, MSIRECORD *rec );
 };
 
-typedef struct
+struct radio_button_group_descr
 {
-    msi_dialog* dialog;
-    msi_control *parent;
-    LPWSTR      propval;
-} radio_button_group_descr;
+    msi_dialog *dialog;
+    struct control *parent;
+    WCHAR *propval;
+};
 
 /* dialog sequencing */
 
@@ -140,10 +132,10 @@ typedef struct
 static DWORD uiThreadId;
 static HWND hMsiHiddenWindow;
 
-static LPWSTR msi_get_window_text( HWND hwnd )
+static WCHAR *get_window_text( HWND hwnd )
 {
     UINT sz, r;
-    LPWSTR buf;
+    WCHAR *buf, *new_buf;
 
     sz = 0x20;
     buf = malloc( sz * sizeof(WCHAR) );
@@ -153,58 +145,61 @@ static LPWSTR msi_get_window_text( HWND hwnd )
         if ( r < (sz - 1) )
             break;
         sz *= 2;
-        buf = realloc( buf, sz * sizeof(WCHAR) );
+        new_buf = realloc( buf, sz * sizeof(WCHAR) );
+        if ( !new_buf )
+            free( buf );
+        buf = new_buf;
     }
 
     return buf;
 }
 
-static INT msi_dialog_scale_unit( msi_dialog *dialog, INT val )
+static INT dialog_scale_unit( msi_dialog *dialog, INT val )
 {
     return MulDiv( val, dialog->scale, 12 );
 }
 
-static msi_control *msi_dialog_find_control( msi_dialog *dialog, LPCWSTR name )
+static struct control *dialog_find_control( msi_dialog *dialog, const WCHAR *name )
 {
-    msi_control *control;
+    struct control *control;
 
     if( !name )
         return NULL;
     if( !dialog->hwnd )
         return NULL;
-    LIST_FOR_EACH_ENTRY( control, &dialog->controls, msi_control, entry )
+    LIST_FOR_EACH_ENTRY( control, &dialog->controls, struct control, entry )
         if( !wcscmp( control->name, name ) ) /* FIXME: case sensitive? */
             return control;
     return NULL;
 }
 
-static msi_control *msi_dialog_find_control_by_type( msi_dialog *dialog, LPCWSTR type )
+static struct control *dialog_find_control_by_type( msi_dialog *dialog, const WCHAR *type )
 {
-    msi_control *control;
+    struct control *control;
 
     if( !type )
         return NULL;
     if( !dialog->hwnd )
         return NULL;
-    LIST_FOR_EACH_ENTRY( control, &dialog->controls, msi_control, entry )
+    LIST_FOR_EACH_ENTRY( control, &dialog->controls, struct control, entry )
         if( !wcscmp( control->type, type ) ) /* FIXME: case sensitive? */
             return control;
     return NULL;
 }
 
-static msi_control *msi_dialog_find_control_by_hwnd( msi_dialog *dialog, HWND hwnd )
+static struct control *dialog_find_control_by_hwnd( msi_dialog *dialog, HWND hwnd )
 {
-    msi_control *control;
+    struct control *control;
 
     if( !dialog->hwnd )
         return NULL;
-    LIST_FOR_EACH_ENTRY( control, &dialog->controls, msi_control, entry )
+    LIST_FOR_EACH_ENTRY( control, &dialog->controls, struct control, entry )
         if( hwnd == control->hwnd )
             return control;
     return NULL;
 }
 
-static LPWSTR msi_get_deformatted_field( MSIPACKAGE *package, MSIRECORD *rec, int field )
+static WCHAR *get_deformatted_field( MSIPACKAGE *package, MSIRECORD *rec, int field )
 {
     LPCWSTR str = MSI_RecordGetString( rec, field );
     LPWSTR ret = NULL;
@@ -214,7 +209,7 @@ static LPWSTR msi_get_deformatted_field( MSIPACKAGE *package, MSIRECORD *rec, in
     return ret;
 }
 
-static LPWSTR msi_dialog_dup_property( msi_dialog *dialog, LPCWSTR property, BOOL indirect )
+static WCHAR *dialog_dup_property( msi_dialog *dialog, const WCHAR *property, BOOL indirect )
 {
     LPWSTR prop = NULL;
 
@@ -231,12 +226,12 @@ static LPWSTR msi_dialog_dup_property( msi_dialog *dialog, LPCWSTR property, BOO
 }
 
 /*
- * msi_dialog_get_style
+ * dialog_get_style
  *
  * Extract the {\style} string from the front of the text to display and
  * update the pointer.  Only the last style in a list is applied.
  */
-static LPWSTR msi_dialog_get_style( LPCWSTR p, LPCWSTR *rest )
+static WCHAR *dialog_get_style( const WCHAR *p, const WCHAR **rest )
 {
     LPWSTR ret;
     LPCWSTR q, i, first;
@@ -273,10 +268,10 @@ static LPWSTR msi_dialog_get_style( LPCWSTR p, LPCWSTR *rest )
     return ret;
 }
 
-static UINT msi_dialog_add_font( MSIRECORD *rec, LPVOID param )
+static UINT dialog_add_font( MSIRECORD *rec, void *param )
 {
     msi_dialog *dialog = param;
-    msi_font *font;
+    struct font *font;
     LPCWSTR face, name;
     LOGFONTW lf;
     INT style;
@@ -284,7 +279,7 @@ static UINT msi_dialog_add_font( MSIRECORD *rec, LPVOID param )
 
     /* create a font and add it to the list */
     name = MSI_RecordGetString( rec, 1 );
-    font = malloc( offsetof( msi_font, name[wcslen( name ) + 1] ) );
+    font = malloc( offsetof( struct font, name[wcslen( name ) + 1] ) );
     lstrcpyW( font->name, name );
     list_add_head( &dialog->fonts, &font->entry );
 
@@ -319,22 +314,22 @@ static UINT msi_dialog_add_font( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static msi_font *msi_dialog_find_font( msi_dialog *dialog, LPCWSTR name )
+static struct font *dialog_find_font( msi_dialog *dialog, const WCHAR *name )
 {
-    msi_font *font = NULL;
+    struct font *font = NULL;
 
-    LIST_FOR_EACH_ENTRY( font, &dialog->fonts, msi_font, entry )
+    LIST_FOR_EACH_ENTRY( font, &dialog->fonts, struct font, entry )
         if( !wcscmp( font->name, name ) )  /* FIXME: case sensitive? */
             break;
 
     return font;
 }
 
-static UINT msi_dialog_set_font( msi_dialog *dialog, HWND hwnd, LPCWSTR name )
+static UINT dialog_set_font( msi_dialog *dialog, HWND hwnd, const WCHAR *name )
 {
-    msi_font *font;
+    struct font *font;
 
-    font = msi_dialog_find_font( dialog, name );
+    font = dialog_find_font( dialog, name );
     if( font )
         SendMessageW( hwnd, WM_SETFONT, (WPARAM) font->hfont, TRUE );
     else
@@ -342,7 +337,7 @@ static UINT msi_dialog_set_font( msi_dialog *dialog, HWND hwnd, LPCWSTR name )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_build_font_list( msi_dialog *dialog )
+static UINT dialog_build_font_list( msi_dialog *dialog )
 {
     MSIQUERY *view;
     UINT r;
@@ -353,12 +348,12 @@ static UINT msi_dialog_build_font_list( msi_dialog *dialog )
     if( r != ERROR_SUCCESS )
         return r;
 
-    r = MSI_IterateRecords( view, NULL, msi_dialog_add_font, dialog );
+    r = MSI_IterateRecords( view, NULL, dialog_add_font, dialog );
     msiobj_release( &view->hdr );
     return r;
 }
 
-static void msi_destroy_control( msi_control *t )
+static void destroy_control( struct control *t )
 {
     list_remove( &t->entry );
     /* leave dialog->hwnd - destroying parent destroys child windows */
@@ -377,18 +372,18 @@ static void msi_destroy_control( msi_control *t )
     free( t );
 }
 
-static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DWORD exstyle,
-                                          const WCHAR *szCls, const WCHAR *name, const WCHAR *text,
-                                          DWORD style, HWND parent )
+static struct control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DWORD exstyle,
+                                             const WCHAR *szCls, const WCHAR *name, const WCHAR *text,
+                                             DWORD style, HWND parent )
 {
     DWORD x, y, width, height;
     LPWSTR font = NULL, title_font = NULL;
     LPCWSTR title = NULL;
-    msi_control *control;
+    struct control *control;
 
     style |= WS_CHILD;
 
-    control = malloc( offsetof( msi_control, name[wcslen( name ) + 1] ) );
+    control = malloc( offsetof( struct control, name[wcslen( name ) + 1] ) );
     if (!control)
         return NULL;
 
@@ -413,15 +408,15 @@ static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DW
     width = MSI_RecordGetInteger( rec, 6 );
     height = MSI_RecordGetInteger( rec, 7 );
 
-    x = msi_dialog_scale_unit( dialog, x );
-    y = msi_dialog_scale_unit( dialog, y );
-    width = msi_dialog_scale_unit( dialog, width );
-    height = msi_dialog_scale_unit( dialog, height );
+    x = dialog_scale_unit( dialog, x );
+    y = dialog_scale_unit( dialog, y );
+    width = dialog_scale_unit( dialog, width );
+    height = dialog_scale_unit( dialog, height );
 
     if( text )
     {
         deformat_string( dialog->package, text, &title_font );
-        font = msi_dialog_get_style( title_font, &title );
+        font = dialog_get_style( title_font, &title );
     }
 
     control->hwnd = CreateWindowExW( exstyle, szCls, title, style,
@@ -430,8 +425,7 @@ static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DW
     TRACE("Dialog %s control %s hwnd %p\n",
            debugstr_w(dialog->name), debugstr_w(text), control->hwnd );
 
-    msi_dialog_set_font( dialog, control->hwnd,
-                         font ? font : dialog->default_font );
+    dialog_set_font( dialog, control->hwnd, font ? font : dialog->default_font );
 
     free( title_font );
     free( font );
@@ -439,7 +433,7 @@ static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DW
     return control;
 }
 
-static LPWSTR msi_dialog_get_uitext( msi_dialog *dialog, LPCWSTR key )
+static WCHAR *dialog_get_uitext( msi_dialog *dialog, const WCHAR *key )
 {
     MSIRECORD *rec;
     LPWSTR text;
@@ -451,8 +445,7 @@ static LPWSTR msi_dialog_get_uitext( msi_dialog *dialog, LPCWSTR key )
     return text;
 }
 
-static HANDLE msi_load_image( MSIDATABASE *db, LPCWSTR name, UINT type,
-                              UINT cx, UINT cy, UINT flags )
+static HANDLE load_image( MSIDATABASE *db, const WCHAR *name, UINT type, UINT cx, UINT cy, UINT flags )
 {
     MSIRECORD *rec;
     HANDLE himage = NULL;
@@ -479,7 +472,7 @@ static HANDLE msi_load_image( MSIDATABASE *db, LPCWSTR name, UINT type,
     return himage;
 }
 
-static HICON msi_load_icon( MSIDATABASE *db, LPCWSTR text, UINT attributes )
+static HICON load_icon( MSIDATABASE *db, const WCHAR *text, UINT attributes )
 {
     DWORD cx = 0, cy = 0, flags;
 
@@ -499,39 +492,39 @@ static HICON msi_load_icon( MSIDATABASE *db, LPCWSTR text, UINT attributes )
         }
         /* msidbControlAttributesIconSize48 handled by above logic */
     }
-    return msi_load_image( db, text, IMAGE_ICON, cx, cy, flags );
+    return load_image( db, text, IMAGE_ICON, cx, cy, flags );
 }
 
-static void msi_dialog_update_controls( msi_dialog *dialog, LPCWSTR property )
+static void dialog_update_controls( msi_dialog *dialog, const WCHAR *property )
 {
-    msi_control *control;
+    struct control *control;
 
-    LIST_FOR_EACH_ENTRY( control, &dialog->controls, msi_control, entry )
+    LIST_FOR_EACH_ENTRY( control, &dialog->controls, struct control, entry )
     {
         if ( control->property && !wcscmp( control->property, property ) && control->update )
             control->update( dialog, control );
     }
 }
 
-static void msi_dialog_update_all_controls( msi_dialog *dialog )
+static void dialog_update_all_controls( msi_dialog *dialog )
 {
-    msi_control *control;
+    struct control *control;
 
-    LIST_FOR_EACH_ENTRY( control, &dialog->controls, msi_control, entry )
+    LIST_FOR_EACH_ENTRY( control, &dialog->controls, struct control, entry )
     {
         if ( control->property && control->update )
             control->update( dialog, control );
     }
 }
 
-static void msi_dialog_set_property( MSIPACKAGE *package, LPCWSTR property, LPCWSTR value )
+static void dialog_set_property( MSIPACKAGE *package, const WCHAR *property, const WCHAR *value )
 {
     UINT r = msi_set_property( package->db, property, value, -1 );
     if (r == ERROR_SUCCESS && !wcscmp( property, L"SourceDir" ))
         msi_reset_source_folders( package );
 }
 
-static MSIFEATURE *msi_seltree_feature_from_item( HWND hwnd, HTREEITEM hItem )
+static MSIFEATURE *seltree_feature_from_item( HWND hwnd, HTREEITEM hItem )
 {
     TVITEMW tvi;
 
@@ -551,18 +544,17 @@ struct msi_selection_tree_info
     HTREEITEM selected;
 };
 
-static MSIFEATURE *msi_seltree_get_selected_feature( msi_control *control )
+static MSIFEATURE *seltree_get_selected_feature( struct control *control )
 {
     struct msi_selection_tree_info *info = GetPropW( control->hwnd, L"MSIDATA" );
-    return msi_seltree_feature_from_item( control->hwnd, info->selected );
+    return seltree_feature_from_item( control->hwnd, info->selected );
 }
 
-static void dialog_handle_event( msi_dialog *dialog, const WCHAR *control,
-                                 const WCHAR *attribute, MSIRECORD *rec )
+static void dialog_handle_event( msi_dialog *dialog, const WCHAR *control, const WCHAR *attribute, MSIRECORD *rec )
 {
-    msi_control* ctrl;
+    struct control* ctrl;
 
-    ctrl = msi_dialog_find_control( dialog, control );
+    ctrl = dialog_find_control( dialog, control );
     if (!ctrl)
         return;
     if( !wcscmp( attribute, L"Text" ) )
@@ -571,7 +563,7 @@ static void dialog_handle_event( msi_dialog *dialog, const WCHAR *control,
         WCHAR *font, *text_fmt = NULL;
 
         font_text = MSI_RecordGetString( rec , 1 );
-        font = msi_dialog_get_style( font_text, &text );
+        font = dialog_get_style( font_text, &text );
         deformat_string( dialog->package, text, &text_fmt );
         if (text_fmt) text = text_fmt;
         else text = L"";
@@ -639,13 +631,13 @@ static void dialog_handle_event( msi_dialog *dialog, const WCHAR *control,
     }
     else if ( !wcscmp( attribute, L"Property" ) )
     {
-        MSIFEATURE *feature = msi_seltree_get_selected_feature( ctrl );
-        if (feature) msi_dialog_set_property( dialog->package, ctrl->property, feature->Directory );
+        MSIFEATURE *feature = seltree_get_selected_feature( ctrl );
+        if (feature) dialog_set_property( dialog->package, ctrl->property, feature->Directory );
     }
     else if ( !wcscmp( attribute, L"SelectionPath" ) )
     {
         BOOL indirect = ctrl->attributes & msidbControlAttributesIndirect;
-        LPWSTR path = msi_dialog_dup_property( dialog, ctrl->property, indirect );
+        WCHAR *path = dialog_dup_property( dialog, ctrl->property, indirect );
         if (!path) return;
         SetWindowTextW( ctrl->hwnd, path );
         free( path );
@@ -718,8 +710,7 @@ static void dialog_map_events( msi_dialog *dialog, const WCHAR *control )
 }
 
 /* everything except radio buttons */
-static msi_control *msi_dialog_add_control( msi_dialog *dialog,
-                MSIRECORD *rec, LPCWSTR szCls, DWORD style )
+static struct control *dialog_add_control( msi_dialog *dialog, MSIRECORD *rec, const WCHAR *szCls, DWORD style )
 {
     DWORD attributes;
     const WCHAR *text = NULL, *name, *control_type;
@@ -746,7 +737,7 @@ static msi_control *msi_dialog_add_control( msi_dialog *dialog,
 
 struct msi_text_info
 {
-    msi_font *font;
+    struct font *font;
     WNDPROC oldproc;
     DWORD attributes;
 };
@@ -755,7 +746,7 @@ struct msi_text_info
  * we don't erase our own background,
  * so we have to make sure that the parent window redraws first
  */
-static void msi_text_on_settext( HWND hWnd )
+static void text_on_settext( HWND hWnd )
 {
     HWND hParent;
     RECT rc;
@@ -766,8 +757,7 @@ static void msi_text_on_settext( HWND hWnd )
     InvalidateRect( hParent, &rc, TRUE );
 }
 
-static LRESULT WINAPI
-MSIText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
+static LRESULT WINAPI MSIText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
     struct msi_text_info *info;
     LRESULT r = 0;
@@ -790,7 +780,7 @@ MSIText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     switch( msg )
     {
     case WM_SETTEXT:
-        msi_text_on_settext( hWnd );
+        text_on_settext( hWnd );
         break;
     case WM_NCDESTROY:
         free( info );
@@ -801,16 +791,16 @@ MSIText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     return r;
 }
 
-static UINT msi_dialog_text_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_text_control( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     struct msi_text_info *info;
     LPCWSTR text, ptr, prop, control_name;
     LPWSTR font_name;
 
     TRACE("%p %p\n", dialog, rec);
 
-    control = msi_dialog_add_control( dialog, rec, L"Static", SS_LEFT | WS_GROUP );
+    control = dialog_add_control( dialog, rec, L"Static", SS_LEFT | WS_GROUP );
     if( !control )
         return ERROR_FUNCTION_FAILED;
 
@@ -821,11 +811,11 @@ static UINT msi_dialog_text_control( msi_dialog *dialog, MSIRECORD *rec )
     control_name = MSI_RecordGetString( rec, 2 );
     control->attributes = MSI_RecordGetInteger( rec, 8 );
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
     text = MSI_RecordGetString( rec, 10 );
-    font_name = msi_dialog_get_style( text, &ptr );
-    info->font = ( font_name ) ? msi_dialog_find_font( dialog, font_name ) : NULL;
+    font_name = dialog_get_style( text, &ptr );
+    info->font = ( font_name ) ? dialog_find_font( dialog, font_name ) : NULL;
     free( font_name );
 
     info->attributes = MSI_RecordGetInteger( rec, 8 );
@@ -841,11 +831,11 @@ static UINT msi_dialog_text_control( msi_dialog *dialog, MSIRECORD *rec )
 }
 
 /* strip any leading text style label from text field */
-static WCHAR *msi_get_binary_name( MSIPACKAGE *package, MSIRECORD *rec )
+static WCHAR *get_binary_name( MSIPACKAGE *package, MSIRECORD *rec )
 {
     WCHAR *p, *text;
 
-    text = msi_get_deformatted_field( package, rec, 10 );
+    text = get_deformatted_field( package, rec, 10 );
     if (!text)
         return NULL;
 
@@ -861,7 +851,7 @@ static WCHAR *msi_get_binary_name( MSIPACKAGE *package, MSIRECORD *rec )
     return p;
 }
 
-static UINT msi_dialog_set_property_event( msi_dialog *dialog, LPCWSTR event, LPCWSTR arg )
+static UINT dialog_set_property_event( msi_dialog *dialog, const WCHAR *event, const WCHAR *arg )
 {
     LPWSTR p, prop, arg_fmt = NULL;
     UINT len;
@@ -874,8 +864,8 @@ static UINT msi_dialog_set_property_event( msi_dialog *dialog, LPCWSTR event, LP
     {
         *p = 0;
         if (wcscmp( L"{}", arg )) deformat_string( dialog->package, arg, &arg_fmt );
-        msi_dialog_set_property( dialog->package, prop, arg_fmt );
-        msi_dialog_update_controls( dialog, prop );
+        dialog_set_property( dialog->package, prop, arg_fmt );
+        dialog_update_controls( dialog, prop );
         free( arg_fmt );
     }
     else ERR("Badly formatted property string - what happens?\n");
@@ -883,7 +873,7 @@ static UINT msi_dialog_set_property_event( msi_dialog *dialog, LPCWSTR event, LP
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_send_event( msi_dialog *dialog, LPCWSTR event, LPCWSTR arg )
+static UINT dialog_send_event( msi_dialog *dialog, const WCHAR *event, const WCHAR *arg )
 {
     LPWSTR event_fmt = NULL, arg_fmt = NULL;
 
@@ -900,7 +890,7 @@ static UINT msi_dialog_send_event( msi_dialog *dialog, LPCWSTR event, LPCWSTR ar
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_control_event( MSIRECORD *rec, LPVOID param )
+static UINT dialog_control_event( MSIRECORD *rec, void *param )
 {
     msi_dialog *dialog = param;
     LPCWSTR condition, event, arg;
@@ -913,14 +903,14 @@ static UINT msi_dialog_control_event( MSIRECORD *rec, LPVOID param )
         event = MSI_RecordGetString( rec, 3 );
         arg = MSI_RecordGetString( rec, 4 );
         if (event[0] == '[')
-            msi_dialog_set_property_event( dialog, event, arg );
+            dialog_set_property_event( dialog, event, arg );
         else
-            msi_dialog_send_event( dialog, event, arg );
+            dialog_send_event( dialog, event, arg );
     }
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_button_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_button_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     MSIQUERY *view;
     UINT r;
@@ -936,7 +926,7 @@ static UINT msi_dialog_button_handler( msi_dialog *dialog, msi_control *control,
         ERR("query failed\n");
         return ERROR_SUCCESS;
     }
-    r = MSI_IterateRecords( view, 0, msi_dialog_control_event, dialog );
+    r = MSI_IterateRecords( view, 0, dialog_control_event, dialog );
     msiobj_release( &view->hdr );
 
     /* dialog control events must be processed last regardless of ordering */
@@ -951,7 +941,7 @@ static UINT msi_dialog_button_handler( msi_dialog *dialog, msi_control *control,
     return r;
 }
 
-static HBITMAP msi_load_picture( MSIDATABASE *db, const WCHAR *name, INT cx, INT cy, DWORD flags )
+static HBITMAP load_picture( MSIDATABASE *db, const WCHAR *name, INT cx, INT cy, DWORD flags )
 {
     HBITMAP hOleBitmap = 0, hBitmap = 0, hOldSrcBitmap, hOldDestBitmap;
     MSIRECORD *rec = NULL;
@@ -1015,9 +1005,9 @@ end:
     return hBitmap;
 }
 
-static UINT msi_dialog_button_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_button_control( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     UINT attributes, style, cx = 0, cy = 0, flags = 0;
     WCHAR *name = NULL;
 
@@ -1032,21 +1022,21 @@ static UINT msi_dialog_button_control( msi_dialog *dialog, MSIRECORD *rec )
         if (attributes & msidbControlAttributesFixedSize) flags |= LR_DEFAULTSIZE;
         else
         {
-            cx = msi_dialog_scale_unit( dialog, MSI_RecordGetInteger(rec, 6) );
-            cy = msi_dialog_scale_unit( dialog, MSI_RecordGetInteger(rec, 7) );
+            cx = dialog_scale_unit( dialog, MSI_RecordGetInteger(rec, 6) );
+            cy = dialog_scale_unit( dialog, MSI_RecordGetInteger(rec, 7) );
         }
     }
 
-    control = msi_dialog_add_control( dialog, rec, L"BUTTON", style );
+    control = dialog_add_control( dialog, rec, L"BUTTON", style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
-    control->handler = msi_dialog_button_handler;
+    control->handler = dialog_button_handler;
 
     if (attributes & msidbControlAttributesIcon)
     {
-        name = msi_get_binary_name( dialog->package, rec );
-        control->hIcon = msi_load_icon( dialog->package->db, name, attributes );
+        name = get_binary_name( dialog->package, rec );
+        control->hIcon = load_icon( dialog->package->db, name, attributes );
         if (control->hIcon)
         {
             SendMessageW( control->hwnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM) control->hIcon );
@@ -1055,8 +1045,8 @@ static UINT msi_dialog_button_control( msi_dialog *dialog, MSIRECORD *rec )
     }
     else if (attributes & msidbControlAttributesBitmap)
     {
-        name = msi_get_binary_name( dialog->package, rec );
-        control->hBitmap = msi_load_picture( dialog->package->db, name, cx, cy, flags );
+        name = get_binary_name( dialog->package, rec );
+        control->hBitmap = load_picture( dialog->package->db, name, cx, cy, flags );
         if (control->hBitmap)
         {
             SendMessageW( control->hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM) control->hBitmap );
@@ -1068,7 +1058,7 @@ static UINT msi_dialog_button_control( msi_dialog *dialog, MSIRECORD *rec )
     return ERROR_SUCCESS;
 }
 
-static LPWSTR msi_get_checkbox_value( msi_dialog *dialog, LPCWSTR prop )
+static WCHAR *get_checkbox_value( msi_dialog *dialog, const WCHAR *prop )
 {
     MSIRECORD *rec = NULL;
     LPWSTR ret = NULL;
@@ -1078,7 +1068,7 @@ static LPWSTR msi_get_checkbox_value( msi_dialog *dialog, LPCWSTR prop )
     if (!rec)
         return ret;
 
-    ret = msi_get_deformatted_field( dialog->package, rec, 2 );
+    ret = get_deformatted_field( dialog->package, rec, 2 );
     if( ret && !ret[0] )
     {
         free( ret );
@@ -1098,7 +1088,7 @@ static LPWSTR msi_get_checkbox_value( msi_dialog *dialog, LPCWSTR prop )
     return ret;
 }
 
-static UINT msi_dialog_get_checkbox_state( msi_dialog *dialog, msi_control *control )
+static UINT dialog_get_checkbox_state( msi_dialog *dialog, struct control *control )
 {
     WCHAR state[2] = {0};
     DWORD sz = 2;
@@ -1107,14 +1097,14 @@ static UINT msi_dialog_get_checkbox_state( msi_dialog *dialog, msi_control *cont
     return state[0] ? 1 : 0;
 }
 
-static void msi_dialog_set_checkbox_state( msi_dialog *dialog, msi_control *control, UINT state )
+static void dialog_set_checkbox_state( msi_dialog *dialog, struct control *control, UINT state )
 {
     LPCWSTR val;
 
     /* if uncheck then the property is set to NULL */
     if (!state)
     {
-        msi_dialog_set_property( dialog->package, control->property, NULL );
+        dialog_set_property( dialog->package, control->property, NULL );
         return;
     }
 
@@ -1124,16 +1114,16 @@ static void msi_dialog_set_checkbox_state( msi_dialog *dialog, msi_control *cont
     else
         val = L"1";
 
-    msi_dialog_set_property( dialog->package, control->property, val );
+    dialog_set_property( dialog->package, control->property, val );
 }
 
-static void msi_dialog_checkbox_sync_state( msi_dialog *dialog, msi_control *control )
+static void dialog_checkbox_sync_state( msi_dialog *dialog, struct control *control )
 {
-    UINT state = msi_dialog_get_checkbox_state( dialog, control );
+    UINT state = dialog_get_checkbox_state( dialog, control );
     SendMessageW( control->hwnd, BM_SETCHECK, state ? BST_CHECKED : BST_UNCHECKED, 0 );
 }
 
-static UINT msi_dialog_checkbox_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_checkbox_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     UINT state;
 
@@ -1142,42 +1132,42 @@ static UINT msi_dialog_checkbox_handler( msi_dialog *dialog, msi_control *contro
 
     TRACE("clicked checkbox %s, set %s\n", debugstr_w(control->name), debugstr_w(control->property));
 
-    state = msi_dialog_get_checkbox_state( dialog, control );
+    state = dialog_get_checkbox_state( dialog, control );
     state = state ? 0 : 1;
-    msi_dialog_set_checkbox_state( dialog, control, state );
-    msi_dialog_checkbox_sync_state( dialog, control );
+    dialog_set_checkbox_state( dialog, control, state );
+    dialog_checkbox_sync_state( dialog, control );
 
-    return msi_dialog_button_handler( dialog, control, param );
+    return dialog_button_handler( dialog, control, param );
 }
 
-static UINT msi_dialog_checkbox_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_checkbox_control( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop;
 
     TRACE("%p %p\n", dialog, rec);
 
-    control = msi_dialog_add_control( dialog, rec, L"BUTTON", BS_CHECKBOX | BS_MULTILINE | WS_TABSTOP );
-    control->handler = msi_dialog_checkbox_handler;
-    control->update = msi_dialog_checkbox_sync_state;
+    control = dialog_add_control( dialog, rec, L"BUTTON", BS_CHECKBOX | BS_MULTILINE | WS_TABSTOP );
+    control->handler = dialog_checkbox_handler;
+    control->update = dialog_checkbox_sync_state;
     prop = MSI_RecordGetString( rec, 9 );
     if (prop)
     {
         control->property = wcsdup( prop );
-        control->value = msi_get_checkbox_value( dialog, prop );
+        control->value = get_checkbox_value( dialog, prop );
         TRACE("control %s value %s\n", debugstr_w(control->property), debugstr_w(control->value));
     }
-    msi_dialog_checkbox_sync_state( dialog, control );
+    dialog_checkbox_sync_state( dialog, control );
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     DWORD attributes;
     LPCWSTR name;
     DWORD style, exstyle = 0;
     DWORD x, y, width, height;
-    msi_control *control;
+    struct control *control;
 
     TRACE("%p %p\n", dialog, rec);
 
@@ -1195,7 +1185,7 @@ static UINT msi_dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
 
     dialog_map_events( dialog, name );
 
-    control = malloc( offsetof( msi_control, name[wcslen( name ) + 1] ) );
+    control = malloc( offsetof( struct control, name[wcslen( name ) + 1] ) );
     if (!control)
         return ERROR_OUTOFMEMORY;
 
@@ -1217,9 +1207,9 @@ static UINT msi_dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
     y = MSI_RecordGetInteger( rec, 5 );
     width = MSI_RecordGetInteger( rec, 6 );
 
-    x = msi_dialog_scale_unit( dialog, x );
-    y = msi_dialog_scale_unit( dialog, y );
-    width = msi_dialog_scale_unit( dialog, width );
+    x = dialog_scale_unit( dialog, x );
+    y = dialog_scale_unit( dialog, y );
+    width = dialog_scale_unit( dialog, width );
     height = 2; /* line is exactly 2 units in height */
 
     control->hwnd = CreateWindowExW( exstyle, L"Static", NULL, style,
@@ -1236,12 +1226,11 @@ static UINT msi_dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
 struct msi_scrolltext_info
 {
     msi_dialog *dialog;
-    msi_control *control;
+    struct control *control;
     WNDPROC oldproc;
 };
 
-static LRESULT WINAPI
-MSIScrollText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
+static LRESULT WINAPI MSIScrollText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
     struct msi_scrolltext_info *info;
     HRESULT r;
@@ -1262,7 +1251,7 @@ MSIScrollText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
         break;
     case WM_PAINT:
         /* native MSI sets a wait cursor here */
-        msi_dialog_button_handler( info->dialog, info->control, BN_CLICKED );
+        dialog_button_handler( info->dialog, info->control, BN_CLICKED );
         break;
     }
     return r;
@@ -1275,8 +1264,7 @@ struct msi_streamin_info
     DWORD length;
 };
 
-static DWORD CALLBACK
-msi_richedit_stream_in( DWORD_PTR arg, LPBYTE buffer, LONG count, LONG *pcb )
+static DWORD CALLBACK richedit_stream_in( DWORD_PTR arg, BYTE *buffer, LONG count, LONG *pcb )
 {
     struct msi_streamin_info *info = (struct msi_streamin_info*) arg;
 
@@ -1291,7 +1279,7 @@ msi_richedit_stream_in( DWORD_PTR arg, LPBYTE buffer, LONG count, LONG *pcb )
     return 0;
 }
 
-static void msi_scrolltext_add_text( msi_control *control, LPCWSTR text )
+static void scrolltext_add_text( struct control *control, const WCHAR *text )
 {
     struct msi_streamin_info info;
     EDITSTREAM es;
@@ -1302,17 +1290,17 @@ static void msi_scrolltext_add_text( msi_control *control, LPCWSTR text )
 
     es.dwCookie = (DWORD_PTR) &info;
     es.dwError = 0;
-    es.pfnCallback = msi_richedit_stream_in;
+    es.pfnCallback = richedit_stream_in;
 
     SendMessageW( control->hwnd, EM_STREAMIN, SF_RTF, (LPARAM) &es );
 
     free( info.string );
 }
 
-static UINT msi_dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     struct msi_scrolltext_info *info;
-    msi_control *control;
+    struct control *control;
     HMODULE hRichedit;
     LPCWSTR text;
     DWORD style;
@@ -1325,7 +1313,7 @@ static UINT msi_dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
 
     style = WS_BORDER | ES_MULTILINE | WS_VSCROLL |
             ES_READONLY | ES_AUTOVSCROLL | WS_TABSTOP;
-    control = msi_dialog_add_control( dialog, rec, L"RichEdit20W", style );
+    control = dialog_add_control( dialog, rec, L"RichEdit20W", style );
     if (!control)
     {
         FreeLibrary( hRichedit );
@@ -1346,16 +1334,16 @@ static UINT msi_dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
     /* add the text into the richedit */
     text = MSI_RecordGetString( rec, 10 );
     if (text)
-        msi_scrolltext_add_text( control, text );
+        scrolltext_add_text( control, text );
 
     return ERROR_SUCCESS;
 }
 
 
-static UINT msi_dialog_bitmap_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_bitmap_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     UINT cx, cy, flags, style, attributes;
-    msi_control *control;
+    struct control *control;
     LPWSTR name;
 
     flags = LR_LOADFROMFILE;
@@ -1368,14 +1356,14 @@ static UINT msi_dialog_bitmap_control( msi_dialog *dialog, MSIRECORD *rec )
         style |= SS_CENTERIMAGE;
     }
 
-    control = msi_dialog_add_control( dialog, rec, L"Static", style );
+    control = dialog_add_control( dialog, rec, L"Static", style );
     cx = MSI_RecordGetInteger( rec, 6 );
     cy = MSI_RecordGetInteger( rec, 7 );
-    cx = msi_dialog_scale_unit( dialog, cx );
-    cy = msi_dialog_scale_unit( dialog, cy );
+    cx = dialog_scale_unit( dialog, cx );
+    cy = dialog_scale_unit( dialog, cy );
 
-    name = msi_get_binary_name( dialog->package, rec );
-    control->hBitmap = msi_load_picture( dialog->package->db, name, cx, cy, flags );
+    name = get_binary_name( dialog->package, rec );
+    control->hBitmap = load_picture( dialog->package->db, name, cx, cy, flags );
     if( control->hBitmap )
         SendMessageW( control->hwnd, STM_SETIMAGE,
                       IMAGE_BITMAP, (LPARAM) control->hBitmap );
@@ -1387,20 +1375,19 @@ static UINT msi_dialog_bitmap_control( msi_dialog *dialog, MSIRECORD *rec )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_icon_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_icon_control( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     DWORD attributes;
     LPWSTR name;
 
     TRACE("\n");
 
-    control = msi_dialog_add_control( dialog, rec, L"Static",
-                            SS_ICON | SS_CENTERIMAGE | WS_GROUP );
+    control = dialog_add_control( dialog, rec, L"Static", SS_ICON | SS_CENTERIMAGE | WS_GROUP );
 
     attributes = MSI_RecordGetInteger( rec, 8 );
-    name = msi_get_binary_name( dialog->package, rec );
-    control->hIcon = msi_load_icon( dialog->package->db, name, attributes );
+    name = get_binary_name( dialog->package, rec );
+    control->hIcon = load_icon( dialog->package->db, name, attributes );
     if( control->hIcon )
         SendMessageW( control->hwnd, STM_SETICON, (WPARAM) control->hIcon, 0 );
     else
@@ -1449,7 +1436,7 @@ static LRESULT WINAPI MSIComboBox_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LP
     return r;
 }
 
-static UINT msi_combobox_add_item( MSIRECORD *rec, LPVOID param )
+static UINT combobox_add_item( MSIRECORD *rec, void *param )
 {
     struct msi_combobox_info *info = param;
     LPCWSTR value, text;
@@ -1467,7 +1454,7 @@ static UINT msi_combobox_add_item( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_combobox_add_items( struct msi_combobox_info *info, LPCWSTR property )
+static UINT combobox_add_items( struct msi_combobox_info *info, const WCHAR *property )
 {
     MSIQUERY *view;
     DWORD count;
@@ -1489,15 +1476,15 @@ static UINT msi_combobox_add_items( struct msi_combobox_info *info, LPCWSTR prop
     info->num_items = count;
     info->items = malloc( sizeof(*info->items) * count );
 
-    r = MSI_IterateRecords( view, NULL, msi_combobox_add_item, info );
+    r = MSI_IterateRecords( view, NULL, combobox_add_item, info );
     msiobj_release( &view->hdr );
     return r;
 }
 
-static UINT msi_dialog_set_control_condition( MSIRECORD *rec, LPVOID param )
+static UINT dialog_set_control_condition( MSIRECORD *rec, void *param )
 {
     msi_dialog *dialog = param;
-    msi_control *control;
+    struct control *control;
     LPCWSTR name, action, condition;
     UINT r;
 
@@ -1505,7 +1492,7 @@ static UINT msi_dialog_set_control_condition( MSIRECORD *rec, LPVOID param )
     action = MSI_RecordGetString( rec, 3 );
     condition = MSI_RecordGetString( rec, 4 );
     r = MSI_EvaluateConditionW( dialog->package, condition );
-    control = msi_dialog_find_control( dialog, name );
+    control = dialog_find_control( dialog, name );
     if (r == MSICONDITION_TRUE && control)
     {
         TRACE("%s control %s\n", debugstr_w(action), debugstr_w(name));
@@ -1527,7 +1514,7 @@ static UINT msi_dialog_set_control_condition( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_evaluate_control_conditions( msi_dialog *dialog )
+static UINT dialog_evaluate_control_conditions( msi_dialog *dialog )
 {
     UINT r;
     MSIQUERY *view;
@@ -1540,12 +1527,12 @@ static UINT msi_dialog_evaluate_control_conditions( msi_dialog *dialog )
     if (r != ERROR_SUCCESS)
         return ERROR_SUCCESS;
 
-    r = MSI_IterateRecords( view, 0, msi_dialog_set_control_condition, dialog );
+    r = MSI_IterateRecords( view, 0, dialog_set_control_condition, dialog );
     msiobj_release( &view->hdr );
     return r;
 }
 
-static UINT msi_dialog_combobox_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_combobox_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     struct msi_combobox_info *info;
     int index;
@@ -1557,12 +1544,12 @@ static UINT msi_dialog_combobox_handler( msi_dialog *dialog, msi_control *contro
     info = GetPropW( control->hwnd, L"MSIDATA" );
     index = SendMessageW( control->hwnd, CB_GETCURSEL, 0, 0 );
     if (index == CB_ERR)
-        value = msi_get_window_text( control->hwnd );
+        value = get_window_text( control->hwnd );
     else
         value = (LPWSTR) SendMessageW( control->hwnd, CB_GETITEMDATA, index, 0 );
 
-    msi_dialog_set_property( info->dialog->package, control->property, value );
-    msi_dialog_evaluate_control_conditions( info->dialog );
+    dialog_set_property( info->dialog->package, control->property, value );
+    dialog_evaluate_control_conditions( info->dialog );
 
     if (index == CB_ERR)
         free( value );
@@ -1570,7 +1557,7 @@ static UINT msi_dialog_combobox_handler( msi_dialog *dialog, msi_control *contro
     return ERROR_SUCCESS;
 }
 
-static void msi_dialog_combobox_update( msi_dialog *dialog, msi_control *control )
+static void dialog_combobox_update( msi_dialog *dialog, struct control *control )
 {
     struct msi_combobox_info *info;
     LPWSTR value, tmp;
@@ -1605,10 +1592,10 @@ static void msi_dialog_combobox_update( msi_dialog *dialog, msi_control *control
     free( value );
 }
 
-static UINT msi_dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     struct msi_combobox_info *info;
-    msi_control *control;
+    struct control *control;
     DWORD attributes, style;
     LPCWSTR prop;
 
@@ -1625,18 +1612,18 @@ static UINT msi_dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
     else
         style |= CBS_DROPDOWN;
 
-    control = msi_dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
+    control = dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
     if (!control)
     {
         free( info );
         return ERROR_FUNCTION_FAILED;
     }
 
-    control->handler = msi_dialog_combobox_handler;
-    control->update = msi_dialog_combobox_update;
+    control->handler = dialog_combobox_handler;
+    control->update = dialog_combobox_update;
 
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
     /* subclass */
     info->dialog = dialog;
@@ -1648,14 +1635,14 @@ static UINT msi_dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
     SetPropW( control->hwnd, L"MSIDATA", info );
 
     if (control->property)
-        msi_combobox_add_items( info, control->property );
+        combobox_add_items( info, control->property );
 
-    msi_dialog_combobox_update( dialog, control );
+    dialog_combobox_update( dialog, control );
 
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_edit_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_edit_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     LPWSTR buf;
 
@@ -1664,8 +1651,8 @@ static UINT msi_dialog_edit_handler( msi_dialog *dialog, msi_control *control, W
 
     TRACE("edit %s contents changed, set %s\n", debugstr_w(control->name), debugstr_w(control->property));
 
-    buf = msi_get_window_text( control->hwnd );
-    msi_dialog_set_property( dialog->package, control->property, buf );
+    buf = get_window_text( control->hwnd );
+    dialog_set_property( dialog->package, control->property, buf );
     free( buf );
 
     return ERROR_SUCCESS;
@@ -1674,17 +1661,16 @@ static UINT msi_dialog_edit_handler( msi_dialog *dialog, msi_control *control, W
 /* length of 2^32 + 1 */
 #define MAX_NUM_DIGITS 11
 
-static UINT msi_dialog_edit_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_edit_control( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop, text;
     LPWSTR val, begin, end;
     WCHAR num[MAX_NUM_DIGITS];
     DWORD limit;
 
-    control = msi_dialog_add_control( dialog, rec, L"Edit",
-                                      WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL );
-    control->handler = msi_dialog_edit_handler;
+    control = dialog_add_control( dialog, rec, L"Edit", WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL );
+    control->handler = dialog_edit_handler;
 
     text = MSI_RecordGetString( rec, 10 );
     if ( text )
@@ -1736,7 +1722,7 @@ struct msi_maskedit_info
     struct msi_mask_group group[MASK_MAX_GROUPS];
 };
 
-static BOOL msi_mask_editable( WCHAR type )
+static BOOL mask_editable( WCHAR type )
 {
     switch (type)
     {
@@ -1751,7 +1737,7 @@ static BOOL msi_mask_editable( WCHAR type )
     return FALSE;
 }
 
-static void msi_mask_control_change( struct msi_maskedit_info *info )
+static void mask_control_change( struct msi_maskedit_info *info )
 {
     LPWSTR val;
     UINT i, n, r;
@@ -1772,7 +1758,7 @@ static void msi_mask_control_change( struct msi_maskedit_info *info )
                 ERR("can't fit control %d text into template\n",i);
                 break;
             }
-            if (!msi_mask_editable(info->group[i].type))
+            if (!mask_editable(info->group[i].type))
             {
                 for(r=0; r<info->group[i].len; r++)
                     val[n+r] = info->group[i].type;
@@ -1793,14 +1779,14 @@ static void msi_mask_control_change( struct msi_maskedit_info *info )
     if( i == info->num_groups )
     {
         TRACE("Set property %s to %s\n", debugstr_w(info->prop), debugstr_w(val));
-        msi_dialog_set_property( info->dialog->package, info->prop, val );
-        msi_dialog_evaluate_control_conditions( info->dialog );
+        dialog_set_property( info->dialog->package, info->prop, val );
+        dialog_evaluate_control_conditions( info->dialog );
     }
     free( val );
 }
 
 /* now move to the next control if necessary */
-static VOID msi_mask_next_control( struct msi_maskedit_info *info, HWND hWnd )
+static void mask_next_control( struct msi_maskedit_info *info, HWND hWnd )
 {
     HWND hWndNext;
     UINT len, i;
@@ -1821,8 +1807,7 @@ static VOID msi_mask_next_control( struct msi_maskedit_info *info, HWND hWnd )
     SetFocus( hWndNext );
 }
 
-static LRESULT WINAPI
-MSIMaskedEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
+static LRESULT WINAPI MSIMaskedEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
     struct msi_maskedit_info *info;
     HRESULT r;
@@ -1838,8 +1823,8 @@ MSIMaskedEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     case WM_COMMAND:
         if (HIWORD(wParam) == EN_CHANGE)
         {
-            msi_mask_control_change( info );
-            msi_mask_next_control( info, (HWND) lParam );
+            mask_control_change( info );
+            mask_next_control( info, (HWND) lParam );
         }
         break;
     case WM_NCDESTROY:
@@ -1853,8 +1838,7 @@ MSIMaskedEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 }
 
 /* fish the various bits of the property out and put them in the control */
-static void
-msi_maskedit_set_text( struct msi_maskedit_info *info, LPCWSTR text )
+static void maskedit_set_text( struct msi_maskedit_info *info, const WCHAR *text )
 {
     LPCWSTR p;
     UINT i;
@@ -1878,7 +1862,7 @@ msi_maskedit_set_text( struct msi_maskedit_info *info, LPCWSTR text )
     }
 }
 
-static struct msi_maskedit_info * msi_dialog_parse_groups( LPCWSTR mask )
+static struct msi_maskedit_info *dialog_parse_groups( const WCHAR *mask )
 {
     struct msi_maskedit_info *info;
     int i = 0, n = 0, total = 0;
@@ -1939,8 +1923,7 @@ static struct msi_maskedit_info * msi_dialog_parse_groups( LPCWSTR mask )
     return info;
 }
 
-static void
-msi_maskedit_create_children( struct msi_maskedit_info *info, LPCWSTR font )
+static void maskedit_create_children( struct msi_maskedit_info *info, const WCHAR *font )
 {
     DWORD width, height, style, wx, ww;
     RECT rect;
@@ -1956,7 +1939,7 @@ msi_maskedit_create_children( struct msi_maskedit_info *info, LPCWSTR font )
 
     for( i = 0; i < info->num_groups; i++ )
     {
-        if (!msi_mask_editable( info->group[i].type ))
+        if (!mask_editable( info->group[i].type ))
             continue;
         if (info->num_chars)
         {
@@ -1978,8 +1961,7 @@ msi_maskedit_create_children( struct msi_maskedit_info *info, LPCWSTR font )
 
         SendMessageW( hwnd, EM_LIMITTEXT, info->group[i].len, 0 );
 
-        msi_dialog_set_font( info->dialog, hwnd,
-                             font?font:info->dialog->default_font );
+        dialog_set_font( info->dialog, hwnd, font?font:info->dialog->default_font );
         info->group[i].hwnd = hwnd;
     }
 }
@@ -1989,25 +1971,25 @@ msi_maskedit_create_children( struct msi_maskedit_info *info, LPCWSTR font )
  * delphi 7 uses "<????-??????-??????-????>" and "<???-???>"
  * filemaker pro 7 uses "<^^^^=^^^^=^^^^=^^^^=^^^^=^^^^=^^^^^>"
  */
-static UINT msi_dialog_maskedit_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_maskedit_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     LPWSTR font_mask, val = NULL, font;
     struct msi_maskedit_info *info = NULL;
     UINT ret = ERROR_SUCCESS;
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop, mask;
 
     TRACE("\n");
 
-    font_mask = msi_get_deformatted_field( dialog->package, rec, 10 );
-    font = msi_dialog_get_style( font_mask, &mask );
+    font_mask = get_deformatted_field( dialog->package, rec, 10 );
+    font = dialog_get_style( font_mask, &mask );
     if( !mask )
     {
         WARN("mask template is empty\n");
         goto end;
     }
 
-    info = msi_dialog_parse_groups( mask );
+    info = dialog_parse_groups( mask );
     if( !info )
     {
         ERR("template %s is invalid\n", debugstr_w(mask));
@@ -2016,8 +1998,7 @@ static UINT msi_dialog_maskedit_control( msi_dialog *dialog, MSIRECORD *rec )
 
     info->dialog = dialog;
 
-    control = msi_dialog_add_control( dialog, rec, L"Static",
-                   SS_OWNERDRAW | WS_GROUP | WS_VISIBLE );
+    control = dialog_add_control( dialog, rec, L"Static", SS_OWNERDRAW | WS_GROUP | WS_VISIBLE );
     if( !control )
     {
         ERR("Failed to create maskedit container\n");
@@ -2037,14 +2018,14 @@ static UINT msi_dialog_maskedit_control( msi_dialog *dialog, MSIRECORD *rec )
     if( prop )
         info->prop = wcsdup( prop );
 
-    msi_maskedit_create_children( info, font );
+    maskedit_create_children( info, font );
 
     if( prop )
     {
         val = msi_dup_property( dialog->package->db, prop );
         if( val )
         {
-            msi_maskedit_set_text( info, val );
+            maskedit_set_text( info, val );
             free( val );
         }
     }
@@ -2059,9 +2040,9 @@ end:
 
 /******************** Progress Bar *****************************************/
 
-static UINT msi_dialog_progress_bar( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_progress_bar( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     DWORD attributes, style;
 
     style = WS_VISIBLE;
@@ -2069,7 +2050,7 @@ static UINT msi_dialog_progress_bar( msi_dialog *dialog, MSIRECORD *rec )
     if( !(attributes & msidbControlAttributesProgress95) )
         style |= PBS_SMOOTH;
 
-    control = msi_dialog_add_control( dialog, rec, PROGRESS_CLASSW, style );
+    control = dialog_add_control( dialog, rec, PROGRESS_CLASSW, style );
     if( !control )
         return ERROR_FUNCTION_FAILED;
 
@@ -2082,25 +2063,25 @@ static UINT msi_dialog_progress_bar( msi_dialog *dialog, MSIRECORD *rec )
 struct msi_pathedit_info
 {
     msi_dialog *dialog;
-    msi_control *control;
+    struct control *control;
     WNDPROC oldproc;
 };
 
-static WCHAR *get_path_property( msi_dialog *dialog, msi_control *control )
+static WCHAR *get_path_property( msi_dialog *dialog, struct control *control )
 {
     WCHAR *prop, *path;
     BOOL indirect = control->attributes & msidbControlAttributesIndirect;
-    if (!(prop = msi_dialog_dup_property( dialog, control->property, indirect ))) return NULL;
-    path = msi_dialog_dup_property( dialog, prop, TRUE );
+    if (!(prop = dialog_dup_property( dialog, control->property, indirect ))) return NULL;
+    path = dialog_dup_property( dialog, prop, TRUE );
     free( prop );
     return path;
 }
 
-static void msi_dialog_update_pathedit( msi_dialog *dialog, msi_control *control )
+static void dialog_update_pathedit( msi_dialog *dialog, struct control *control )
 {
     WCHAR *path;
 
-    if (!control && !(control = msi_dialog_find_control_by_type( dialog, L"PathEdit" )))
+    if (!control && !(control = dialog_find_control_by_type( dialog, L"PathEdit" )))
        return;
 
     if (!(path = get_path_property( dialog, control ))) return;
@@ -2110,7 +2091,7 @@ static void msi_dialog_update_pathedit( msi_dialog *dialog, msi_control *control
 }
 
 /* FIXME: test when this should fail */
-static BOOL msi_dialog_verify_path( LPWSTR path )
+static BOOL dialog_verify_path( const WCHAR *path )
 {
     if ( !path[0] )
         return FALSE;
@@ -2122,18 +2103,18 @@ static BOOL msi_dialog_verify_path( LPWSTR path )
 }
 
 /* returns TRUE if the path is valid, FALSE otherwise */
-static BOOL msi_dialog_onkillfocus( msi_dialog *dialog, msi_control *control )
+static BOOL dialog_onkillfocus( msi_dialog *dialog, struct control *control )
 {
     LPWSTR buf, prop;
     BOOL indirect;
     BOOL valid;
 
     indirect = control->attributes & msidbControlAttributesIndirect;
-    prop = msi_dialog_dup_property( dialog, control->property, indirect );
+    prop = dialog_dup_property( dialog, control->property, indirect );
 
-    buf = msi_get_window_text( control->hwnd );
+    buf = get_window_text( control->hwnd );
 
-    if ( !msi_dialog_verify_path( buf ) )
+    if ( !dialog_verify_path( buf ) )
     {
         /* FIXME: display an error message box */
         ERR("Invalid path %s\n", debugstr_w( buf ));
@@ -2143,10 +2124,10 @@ static BOOL msi_dialog_onkillfocus( msi_dialog *dialog, msi_control *control )
     else
     {
         valid = TRUE;
-        msi_dialog_set_property( dialog->package, prop, buf );
+        dialog_set_property( dialog->package, prop, buf );
     }
 
-    msi_dialog_update_pathedit( dialog, control );
+    dialog_update_pathedit( dialog, control );
 
     TRACE("edit %s contents changed, set %s\n", debugstr_w(control->name),
           debugstr_w(prop));
@@ -2167,7 +2148,7 @@ static LRESULT WINAPI MSIPathEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LP
     if ( msg == WM_KILLFOCUS )
     {
         /* if the path is invalid, don't handle this message */
-        if ( !msi_dialog_onkillfocus( info->dialog, info->control ) )
+        if ( !dialog_onkillfocus( info->dialog, info->control ) )
             return 0;
     }
 
@@ -2182,22 +2163,21 @@ static LRESULT WINAPI MSIPathEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LP
     return r;
 }
 
-static UINT msi_dialog_pathedit_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_pathedit_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     struct msi_pathedit_info *info;
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop;
 
     info = malloc( sizeof *info );
     if (!info)
         return ERROR_FUNCTION_FAILED;
 
-    control = msi_dialog_add_control( dialog, rec, L"Edit",
-                                      WS_BORDER | WS_TABSTOP );
+    control = dialog_add_control( dialog, rec, L"Edit", WS_BORDER | WS_TABSTOP );
     control->attributes = MSI_RecordGetInteger( rec, 8 );
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
-    control->update = msi_dialog_update_pathedit;
+    control->property = dialog_dup_property( dialog, prop, FALSE );
+    control->update = dialog_update_pathedit;
 
     info->dialog = dialog;
     info->control = control;
@@ -2205,29 +2185,29 @@ static UINT msi_dialog_pathedit_control( msi_dialog *dialog, MSIRECORD *rec )
                                                  (LONG_PTR)MSIPathEdit_WndProc );
     SetPropW( control->hwnd, L"MSIDATA", info );
 
-    msi_dialog_update_pathedit( dialog, control );
+    dialog_update_pathedit( dialog, control );
 
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_radiogroup_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_radiogroup_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     if (HIWORD(param) != BN_CLICKED)
         return ERROR_SUCCESS;
 
     TRACE("clicked radio button %s, set %s\n", debugstr_w(control->name), debugstr_w(control->property));
 
-    msi_dialog_set_property( dialog->package, control->property, control->name );
+    dialog_set_property( dialog->package, control->property, control->name );
 
-    return msi_dialog_button_handler( dialog, control, param );
+    return dialog_button_handler( dialog, control, param );
 }
 
 /* radio buttons are a bit different from normal controls */
-static UINT msi_dialog_create_radiobutton( MSIRECORD *rec, LPVOID param )
+static UINT dialog_create_radiobutton( MSIRECORD *rec, void *param )
 {
-    radio_button_group_descr *group = param;
+    struct radio_button_group_descr *group = param;
     msi_dialog *dialog = group->dialog;
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop, text, name;
     DWORD style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_AUTORADIOBUTTON | BS_MULTILINE;
 
@@ -2238,7 +2218,7 @@ static UINT msi_dialog_create_radiobutton( MSIRECORD *rec, LPVOID param )
                                     group->parent->hwnd );
     if (!control)
         return ERROR_FUNCTION_FAILED;
-    control->handler = msi_dialog_radiogroup_handler;
+    control->handler = dialog_radiogroup_handler;
 
     if (group->propval && !wcscmp( control->name, group->propval ))
         SendMessageW(control->hwnd, BM_SETCHECK, BST_CHECKED, 0);
@@ -2250,7 +2230,7 @@ static UINT msi_dialog_create_radiobutton( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static BOOL CALLBACK msi_radioground_child_enum( HWND hWnd, LPARAM lParam )
+static BOOL CALLBACK radioground_child_enum( HWND hWnd, LPARAM lParam )
 {
     EnableWindow( hWnd, lParam );
     return TRUE;
@@ -2270,18 +2250,18 @@ static LRESULT WINAPI MSIRadioGroup_WndProc( HWND hWnd, UINT msg, WPARAM wParam,
 
     /* make sure the radio buttons show as disabled if the parent is disabled */
     if (msg == WM_ENABLE)
-        EnumChildWindows( hWnd, msi_radioground_child_enum, wParam );
+        EnumChildWindows( hWnd, radioground_child_enum, wParam );
 
     return r;
 }
 
-static UINT msi_dialog_radiogroup_control( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_radiogroup_control( msi_dialog *dialog, MSIRECORD *rec )
 {
     UINT r;
     LPCWSTR prop;
-    msi_control *control;
+    struct control *control;
     MSIQUERY *view;
-    radio_button_group_descr group;
+    struct radio_button_group_descr group;
     MSIPACKAGE *package = dialog->package;
     WNDPROC oldproc;
     DWORD attr, style = WS_GROUP;
@@ -2301,7 +2281,7 @@ static UINT msi_dialog_radiogroup_control( msi_dialog *dialog, MSIRECORD *rec )
         style |= BS_OWNERDRAW;
 
     /* Create parent group box to hold radio buttons */
-    control = msi_dialog_add_control( dialog, rec, L"BUTTON", style );
+    control = dialog_add_control( dialog, rec, L"BUTTON", style );
     if( !control )
         return ERROR_FUNCTION_FAILED;
 
@@ -2326,14 +2306,13 @@ static UINT msi_dialog_radiogroup_control( msi_dialog *dialog, MSIRECORD *rec )
     group.parent = control;
     group.propval = msi_dup_property( dialog->package->db, control->property );
 
-    r = MSI_IterateRecords( view, 0, msi_dialog_create_radiobutton, &group );
+    r = MSI_IterateRecords( view, 0, dialog_create_radiobutton, &group );
     msiobj_release( &view->hdr );
     free( group.propval );
     return r;
 }
 
-static void
-msi_seltree_sync_item_state( HWND hwnd, MSIFEATURE *feature, HTREEITEM hItem )
+static void seltree_sync_item_state( HWND hwnd, MSIFEATURE *feature, HTREEITEM hItem )
 {
     TVITEMW tvi;
     DWORD index = feature->ActionRequest;
@@ -2352,8 +2331,7 @@ msi_seltree_sync_item_state( HWND hwnd, MSIFEATURE *feature, HTREEITEM hItem )
     SendMessageW( hwnd, TVM_SETITEMW, 0, (LPARAM) &tvi );
 }
 
-static UINT
-msi_seltree_popup_menu( HWND hwnd, INT x, INT y )
+static UINT seltree_popup_menu( HWND hwnd, INT x, INT y )
 {
     HMENU hMenu;
     INT r;
@@ -2372,18 +2350,16 @@ msi_seltree_popup_menu( HWND hwnd, INT x, INT y )
     return r;
 }
 
-static void
-msi_seltree_update_feature_installstate( HWND hwnd, HTREEITEM hItem,
-        MSIPACKAGE *package, MSIFEATURE *feature, INSTALLSTATE state )
+static void seltree_update_feature_installstate( HWND hwnd, HTREEITEM hItem, MSIPACKAGE *package,
+                                                 MSIFEATURE *feature, INSTALLSTATE state )
 {
     feature->ActionRequest = state;
-    msi_seltree_sync_item_state( hwnd, feature, hItem );
+    seltree_sync_item_state( hwnd, feature, hItem );
     ACTION_UpdateComponentStates( package, feature );
 }
 
-static void
-msi_seltree_update_siblings_and_children_installstate( HWND hwnd, HTREEITEM curr,
-        MSIPACKAGE *package, INSTALLSTATE state)
+static void seltree_update_siblings_and_children_installstate( HWND hwnd, HTREEITEM curr, MSIPACKAGE *package,
+                                                               INSTALLSTATE state )
 {
     /* update all siblings */
     do
@@ -2391,20 +2367,18 @@ msi_seltree_update_siblings_and_children_installstate( HWND hwnd, HTREEITEM curr
         MSIFEATURE *feature;
         HTREEITEM child;
 
-        feature = msi_seltree_feature_from_item( hwnd, curr );
-        msi_seltree_update_feature_installstate( hwnd, curr, package, feature, state );
+        feature = seltree_feature_from_item( hwnd, curr );
+        seltree_update_feature_installstate( hwnd, curr, package, feature, state );
 
         /* update this sibling's children */
         child = (HTREEITEM)SendMessageW( hwnd, TVM_GETNEXTITEM, (WPARAM)TVGN_CHILD, (LPARAM)curr );
         if (child)
-            msi_seltree_update_siblings_and_children_installstate( hwnd, child,
-                    package, state );
+            seltree_update_siblings_and_children_installstate( hwnd, child, package, state );
     }
     while ((curr = (HTREEITEM)SendMessageW( hwnd, TVM_GETNEXTITEM, (WPARAM)TVGN_NEXT, (LPARAM)curr )));
 }
 
-static LRESULT
-msi_seltree_menu( HWND hwnd, HTREEITEM hItem )
+static LRESULT seltree_menu( HWND hwnd, HTREEITEM hItem )
 {
     struct msi_selection_tree_info *info;
     MSIFEATURE *feature;
@@ -2419,7 +2393,7 @@ msi_seltree_menu( HWND hwnd, HTREEITEM hItem )
     info = GetPropW(hwnd, L"MSIDATA");
     package = info->dialog->package;
 
-    feature = msi_seltree_feature_from_item( hwnd, hItem );
+    feature = seltree_feature_from_item( hwnd, hItem );
     if (!feature)
     {
         ERR("item %p feature was NULL\n", hItem);
@@ -2431,7 +2405,7 @@ msi_seltree_menu( HWND hwnd, HTREEITEM hItem )
     SendMessageW( hwnd, TVM_GETITEMRECT, 0, (LPARAM) &u.rc );
     MapWindowPoints( hwnd, NULL, u.pt, 2 );
 
-    r = msi_seltree_popup_menu( hwnd, u.rc.left, u.rc.top );
+    r = seltree_popup_menu( hwnd, u.rc.left, u.rc.top );
 
     switch (r)
     {
@@ -2444,19 +2418,18 @@ msi_seltree_menu( HWND hwnd, HTREEITEM hItem )
             HTREEITEM child;
             child = (HTREEITEM)SendMessageW( hwnd, TVM_GETNEXTITEM, (WPARAM)TVGN_CHILD, (LPARAM)hItem );
             if (child)
-                msi_seltree_update_siblings_and_children_installstate( hwnd, child, package, r );
+                seltree_update_siblings_and_children_installstate( hwnd, child, package, r );
         }
         /* fall-through */
     case INSTALLSTATE_LOCAL:
-        msi_seltree_update_feature_installstate( hwnd, hItem, package, feature, r );
+        seltree_update_feature_installstate( hwnd, hItem, package, feature, r );
         break;
     }
 
     return 0;
 }
 
-static LRESULT WINAPI
-MSISelectionTree_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
+static LRESULT WINAPI MSISelectionTree_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
     struct msi_selection_tree_info *info;
     TVHITTESTINFO tvhti;
@@ -2475,7 +2448,7 @@ MSISelectionTree_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
         tvhti.hItem = 0;
         CallWindowProcW(info->oldproc, hWnd, TVM_HITTEST, 0, (LPARAM) &tvhti );
         if (tvhti.flags & TVHT_ONITEMSTATEICON)
-            return msi_seltree_menu( hWnd, tvhti.hItem );
+            return seltree_menu( hWnd, tvhti.hItem );
         break;
     }
     r = CallWindowProcW(info->oldproc, hWnd, msg, wParam, lParam);
@@ -2490,9 +2463,7 @@ MSISelectionTree_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     return r;
 }
 
-static void
-msi_seltree_add_child_features( MSIPACKAGE *package, HWND hwnd,
-                                LPCWSTR parent, HTREEITEM hParent )
+static void seltree_add_child_features( MSIPACKAGE *package, HWND hwnd, const WCHAR *parent, HTREEITEM hParent )
 {
     struct msi_selection_tree_info *info = GetPropW( hwnd, L"MSIDATA" );
     MSIFEATURE *feature;
@@ -2528,8 +2499,8 @@ msi_seltree_add_child_features( MSIPACKAGE *package, HWND hwnd,
         if (!hfirst)
             hfirst = hitem;
 
-        msi_seltree_sync_item_state( hwnd, feature, hitem );
-        msi_seltree_add_child_features( package, hwnd,
+        seltree_sync_item_state( hwnd, feature, hitem );
+        seltree_add_child_features( package, hwnd,
                                         feature->Feature, hitem );
 
         /* the node is expanded if Display is odd */
@@ -2542,7 +2513,7 @@ msi_seltree_add_child_features( MSIPACKAGE *package, HWND hwnd,
     info->selected = hfirst;
 }
 
-static void msi_seltree_create_imagelist( HWND hwnd )
+static void seltree_create_imagelist( HWND hwnd )
 {
     const int bm_width = 32, bm_height = 16, bm_count = 3;
     const int bm_resource = 0x1001;
@@ -2579,8 +2550,7 @@ static void msi_seltree_create_imagelist( HWND hwnd )
     SendMessageW( hwnd, TVM_SETIMAGELIST, TVSIL_STATE, (LPARAM)himl );
 }
 
-static UINT msi_dialog_seltree_handler( msi_dialog *dialog,
-                                        msi_control *control, WPARAM param )
+static UINT dialog_seltree_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     struct msi_selection_tree_info *info = GetPropW( control->hwnd, L"MSIDATA" );
     LPNMTREEVIEWW tv = (LPNMTREEVIEWW)param;
@@ -2597,7 +2567,7 @@ static UINT msi_dialog_seltree_handler( msi_dialog *dialog,
 
     if (!(tv->itemNew.mask & TVIF_TEXT))
     {
-        feature = msi_seltree_feature_from_item( control->hwnd, tv->itemNew.hItem );
+        feature = seltree_feature_from_item( control->hwnd, tv->itemNew.hItem );
         if (feature)
             title = feature->Title;
     }
@@ -2636,9 +2606,9 @@ done:
     return r;
 }
 
-static UINT msi_dialog_selection_tree( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_selection_tree( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop, control_name;
     MSIPACKAGE *package = dialog->package;
     DWORD style;
@@ -2651,18 +2621,18 @@ static UINT msi_dialog_selection_tree( msi_dialog *dialog, MSIRECORD *rec )
     /* create the treeview control */
     style = TVS_HASLINES | TVS_HASBUTTONS | TVS_LINESATROOT;
     style |= WS_GROUP | WS_VSCROLL | WS_TABSTOP;
-    control = msi_dialog_add_control( dialog, rec, WC_TREEVIEWW, style );
+    control = dialog_add_control( dialog, rec, WC_TREEVIEWW, style );
     if (!control)
     {
         free(info);
         return ERROR_FUNCTION_FAILED;
     }
 
-    control->handler = msi_dialog_seltree_handler;
+    control->handler = dialog_seltree_handler;
     control_name = MSI_RecordGetString( rec, 2 );
     control->attributes = MSI_RecordGetInteger( rec, 8 );
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
     /* subclass */
     info->dialog = dialog;
@@ -2674,21 +2644,21 @@ static UINT msi_dialog_selection_tree( msi_dialog *dialog, MSIRECORD *rec )
     event_subscribe( dialog, L"SelectionPath", control_name, L"Property" );
 
     /* initialize it */
-    msi_seltree_create_imagelist( control->hwnd );
-    msi_seltree_add_child_features( package, control->hwnd, NULL, NULL );
+    seltree_create_imagelist( control->hwnd );
+    seltree_add_child_features( package, control->hwnd, NULL, NULL );
 
     return ERROR_SUCCESS;
 }
 
 /******************** Group Box ***************************************/
 
-static UINT msi_dialog_group_box( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_group_box( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     DWORD style;
 
     style = BS_GROUPBOX | WS_CHILD | WS_GROUP;
-    control = msi_dialog_add_control( dialog, rec, WC_BUTTONW, style );
+    control = dialog_add_control( dialog, rec, WC_BUTTONW, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
@@ -2735,7 +2705,7 @@ static LRESULT WINAPI MSIListBox_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPA
     return r;
 }
 
-static UINT msi_listbox_add_item( MSIRECORD *rec, LPVOID param )
+static UINT listbox_add_item( MSIRECORD *rec, void *param )
 {
     struct msi_listbox_info *info = param;
     LPCWSTR value, text;
@@ -2752,7 +2722,7 @@ static UINT msi_listbox_add_item( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_listbox_add_items( struct msi_listbox_info *info, LPCWSTR property )
+static UINT listbox_add_items( struct msi_listbox_info *info, const WCHAR *property )
 {
     MSIQUERY *view;
     DWORD count;
@@ -2774,13 +2744,12 @@ static UINT msi_listbox_add_items( struct msi_listbox_info *info, LPCWSTR proper
     info->num_items = count;
     info->items = malloc( sizeof(*info->items) * count );
 
-    r = MSI_IterateRecords( view, NULL, msi_listbox_add_item, info );
+    r = MSI_IterateRecords( view, NULL, listbox_add_item, info );
     msiobj_release( &view->hdr );
     return r;
 }
 
-static UINT msi_dialog_listbox_handler( msi_dialog *dialog,
-                                        msi_control *control, WPARAM param )
+static UINT dialog_listbox_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     struct msi_listbox_info *info;
     int index;
@@ -2793,16 +2762,16 @@ static UINT msi_dialog_listbox_handler( msi_dialog *dialog,
     index = SendMessageW( control->hwnd, LB_GETCURSEL, 0, 0 );
     value = (LPCWSTR) SendMessageW( control->hwnd, LB_GETITEMDATA, index, 0 );
 
-    msi_dialog_set_property( info->dialog->package, control->property, value );
-    msi_dialog_evaluate_control_conditions( info->dialog );
+    dialog_set_property( info->dialog->package, control->property, value );
+    dialog_evaluate_control_conditions( info->dialog );
 
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_list_box( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_list_box( msi_dialog *dialog, MSIRECORD *rec )
 {
     struct msi_listbox_info *info;
-    msi_control *control;
+    struct control *control;
     DWORD attributes, style;
     LPCWSTR prop;
 
@@ -2815,17 +2784,17 @@ static UINT msi_dialog_list_box( msi_dialog *dialog, MSIRECORD *rec )
     if (~attributes & msidbControlAttributesSorted)
         style |= LBS_SORT;
 
-    control = msi_dialog_add_control( dialog, rec, WC_LISTBOXW, style );
+    control = dialog_add_control( dialog, rec, WC_LISTBOXW, style );
     if (!control)
     {
         free(info);
         return ERROR_FUNCTION_FAILED;
     }
 
-    control->handler = msi_dialog_listbox_handler;
+    control->handler = dialog_listbox_handler;
 
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
     /* subclass */
     info->dialog = dialog;
@@ -2837,18 +2806,18 @@ static UINT msi_dialog_list_box( msi_dialog *dialog, MSIRECORD *rec )
     SetPropW( control->hwnd, L"MSIDATA", info );
 
     if ( control->property )
-        msi_listbox_add_items( info, control->property );
+        listbox_add_items( info, control->property );
 
     return ERROR_SUCCESS;
 }
 
 /******************** Directory Combo ***************************************/
 
-static void msi_dialog_update_directory_combo( msi_dialog *dialog, msi_control *control )
+static void dialog_update_directory_combo( msi_dialog *dialog, struct control *control )
 {
     WCHAR *path;
 
-    if (!control && !(control = msi_dialog_find_control_by_type( dialog, L"DirectoryCombo" )))
+    if (!control && !(control = dialog_find_control_by_type( dialog, L"DirectoryCombo" )))
         return;
 
     if (!(path = get_path_property( dialog, control ))) return;
@@ -2861,38 +2830,38 @@ static void msi_dialog_update_directory_combo( msi_dialog *dialog, msi_control *
     free( path );
 }
 
-static UINT msi_dialog_directory_combo( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_directory_combo( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop;
     DWORD style;
 
     /* FIXME: use CBS_OWNERDRAWFIXED and add owner draw code */
     style = CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD |
             WS_GROUP | WS_TABSTOP | WS_VSCROLL;
-    control = msi_dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
+    control = dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
     control->attributes = MSI_RecordGetInteger( rec, 8 );
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
-    msi_dialog_update_directory_combo( dialog, control );
+    dialog_update_directory_combo( dialog, control );
 
     return ERROR_SUCCESS;
 }
 
 /******************** Directory List ***************************************/
 
-static void msi_dialog_update_directory_list( msi_dialog *dialog, msi_control *control )
+static void dialog_update_directory_list( msi_dialog *dialog, struct control *control )
 {
     WCHAR dir_spec[MAX_PATH], *path;
     WIN32_FIND_DATAW wfd;
     LVITEMW item;
     HANDLE file;
 
-    if (!control && !(control = msi_dialog_find_control_by_type( dialog, L"DirectoryList" )))
+    if (!control && !(control = dialog_find_control_by_type( dialog, L"DirectoryList" )))
         return;
 
     /* clear the list-view */
@@ -2930,27 +2899,27 @@ static void msi_dialog_update_directory_list( msi_dialog *dialog, msi_control *c
     FindClose( file );
 }
 
-static UINT msi_dialog_directorylist_up( msi_dialog *dialog )
+static UINT dialog_directorylist_up( msi_dialog *dialog )
 {
-    msi_control *control;
+    struct control *control;
     LPWSTR prop, path, ptr;
     BOOL indirect;
 
-    control = msi_dialog_find_control_by_type( dialog, L"DirectoryList" );
+    control = dialog_find_control_by_type( dialog, L"DirectoryList" );
     indirect = control->attributes & msidbControlAttributesIndirect;
-    prop = msi_dialog_dup_property( dialog, control->property, indirect );
-    path = msi_dialog_dup_property( dialog, prop, TRUE );
+    prop = dialog_dup_property( dialog, control->property, indirect );
+    path = dialog_dup_property( dialog, prop, TRUE );
 
     /* strip off the last directory */
     ptr = PathFindFileNameW( path );
     if (ptr != path) *(ptr - 1) = '\0';
     PathAddBackslashW( path );
 
-    msi_dialog_set_property( dialog->package, prop, path );
+    dialog_set_property( dialog->package, prop, path );
 
-    msi_dialog_update_directory_list( dialog, NULL );
-    msi_dialog_update_directory_combo( dialog, NULL );
-    msi_dialog_update_pathedit( dialog, NULL );
+    dialog_update_directory_list( dialog, NULL );
+    dialog_update_directory_combo( dialog, NULL );
+    dialog_update_pathedit( dialog, NULL );
 
     free( path );
     free( prop );
@@ -2986,14 +2955,14 @@ static WCHAR *get_unique_folder_name( const WCHAR *root, int *ret_len )
     return path;
 }
 
-static UINT msi_dialog_directorylist_new( msi_dialog *dialog )
+static UINT dialog_directorylist_new( msi_dialog *dialog )
 {
-    msi_control *control;
+    struct control *control;
     WCHAR *path;
     LVITEMW item;
     int index;
 
-    control = msi_dialog_find_control_by_type( dialog, L"DirectoryList" );
+    control = dialog_find_control_by_type( dialog, L"DirectoryList" );
 
     if (!(path = get_path_property( dialog, control ))) return ERROR_OUTOFMEMORY;
 
@@ -3011,7 +2980,7 @@ static UINT msi_dialog_directorylist_new( msi_dialog *dialog )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_dirlist_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_dirlist_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     NMHDR *nmhdr = (NMHDR *)param;
     WCHAR text[MAX_PATH], *new_path, *path, *prop;
@@ -3049,8 +3018,8 @@ static UINT msi_dialog_dirlist_handler( msi_dialog *dialog, msi_control *control
     }
 
     indirect = control->attributes & msidbControlAttributesIndirect;
-    prop = msi_dialog_dup_property( dialog, control->property, indirect );
-    path = msi_dialog_dup_property( dialog, prop, TRUE );
+    prop = dialog_dup_property( dialog, control->property, indirect );
+    path = dialog_dup_property( dialog, prop, TRUE );
 
     if (!(new_path = malloc( (wcslen(path) + wcslen(text) + 2) * sizeof(WCHAR) )))
     {
@@ -3063,11 +3032,11 @@ static UINT msi_dialog_dirlist_handler( msi_dialog *dialog, msi_control *control
     if (nmhdr->code == LVN_ENDLABELEDITW) CreateDirectoryW( new_path, NULL );
     lstrcatW( new_path, L"\\" );
 
-    msi_dialog_set_property( dialog->package, prop, new_path );
+    dialog_set_property( dialog->package, prop, new_path );
 
-    msi_dialog_update_directory_list( dialog, NULL );
-    msi_dialog_update_directory_combo( dialog, NULL );
-    msi_dialog_update_pathedit( dialog, NULL );
+    dialog_update_directory_list( dialog, NULL );
+    dialog_update_directory_combo( dialog, NULL );
+    dialog_update_pathedit( dialog, NULL );
 
     free( prop );
     free( path );
@@ -3076,29 +3045,29 @@ static UINT msi_dialog_dirlist_handler( msi_dialog *dialog, msi_control *control
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_directory_list( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_directory_list( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop;
     DWORD style;
 
     style = LVS_LIST | WS_VSCROLL | LVS_SHAREIMAGELISTS | LVS_EDITLABELS |
             LVS_AUTOARRANGE | LVS_SINGLESEL | WS_BORDER |
             LVS_SORTASCENDING | WS_CHILD | WS_GROUP | WS_TABSTOP;
-    control = msi_dialog_add_control( dialog, rec, WC_LISTVIEWW, style );
+    control = dialog_add_control( dialog, rec, WC_LISTVIEWW, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
     control->attributes = MSI_RecordGetInteger( rec, 8 );
-    control->handler = msi_dialog_dirlist_handler;
+    control->handler = dialog_dirlist_handler;
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
     /* double click to activate an item in the list */
     SendMessageW( control->hwnd, LVM_SETEXTENDEDLISTVIEWSTYLE,
                   0, LVS_EX_TWOCLICKACTIVATE );
 
-    msi_dialog_update_directory_list( dialog, control );
+    dialog_update_directory_list( dialog, control );
 
     return ERROR_SUCCESS;
 }
@@ -3125,7 +3094,7 @@ static const WCHAR column_keys[][80] =
     L"VolumeCostDifference",
 };
 
-static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control, MSIRECORD *rec )
+static void dialog_vcl_add_columns( msi_dialog *dialog, struct control *control, MSIRECORD *rec )
 {
     LPCWSTR text = MSI_RecordGetString( rec, 10 );
     LPCWSTR begin = text, end;
@@ -3166,7 +3135,7 @@ static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control
         ZeroMemory( &lvc, sizeof(lvc) );
         lvc.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
         lvc.cx = wcstol( num, NULL, 10 );
-        lvc.pszText = msi_dialog_get_uitext( dialog, column_keys[count] );
+        lvc.pszText = dialog_get_uitext( dialog, column_keys[count] );
 
         SendMessageW( control->hwnd,  LVM_INSERTCOLUMNW, count++, (LPARAM)&lvc );
         free( lvc.pszText );
@@ -3174,7 +3143,7 @@ static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control
     }
 }
 
-static LONGLONG msi_vcl_get_cost( msi_dialog *dialog )
+static LONGLONG vcl_get_cost( msi_dialog *dialog )
 {
     MSIFEATURE *feature;
     INT each_cost;
@@ -3198,7 +3167,7 @@ static LONGLONG msi_vcl_get_cost( msi_dialog *dialog )
     return total_cost;
 }
 
-static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control )
+static void dialog_vcl_add_drives( msi_dialog *dialog, struct control *control )
 {
     ULARGE_INTEGER total, unused;
     LONGLONG difference, cost;
@@ -3209,7 +3178,7 @@ static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control
     DWORD size, flags;
     int i = 0;
 
-    cost = msi_vcl_get_cost(dialog);
+    cost = vcl_get_cost(dialog);
     StrFormatByteSizeW(cost, cost_text, MAX_PATH);
 
     size = GetLogicalDriveStringsW( 0, NULL );
@@ -3270,28 +3239,27 @@ static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control
     free( drives );
 }
 
-static UINT msi_dialog_volumecost_list( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_volumecost_list( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     DWORD style;
 
     style = LVS_REPORT | WS_VSCROLL | WS_HSCROLL | LVS_SHAREIMAGELISTS |
             LVS_AUTOARRANGE | LVS_SINGLESEL | WS_BORDER |
             WS_CHILD | WS_TABSTOP | WS_GROUP;
-    control = msi_dialog_add_control( dialog, rec, WC_LISTVIEWW, style );
+    control = dialog_add_control( dialog, rec, WC_LISTVIEWW, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
-    msi_dialog_vcl_add_columns( dialog, control, rec );
-    msi_dialog_vcl_add_drives( dialog, control );
+    dialog_vcl_add_columns( dialog, control, rec );
+    dialog_vcl_add_drives( dialog, control );
 
     return ERROR_SUCCESS;
 }
 
 /******************** VolumeSelect Combo ***************************************/
 
-static UINT msi_dialog_volsel_handler( msi_dialog *dialog,
-                                       msi_control *control, WPARAM param )
+static UINT dialog_volsel_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     WCHAR text[MAX_PATH];
     LPWSTR prop;
@@ -3311,15 +3279,15 @@ static UINT msi_dialog_volsel_handler( msi_dialog *dialog,
     SendMessageW( control->hwnd, CB_GETLBTEXT, index, (LPARAM)text );
 
     indirect = control->attributes & msidbControlAttributesIndirect;
-    prop = msi_dialog_dup_property( dialog, control->property, indirect );
+    prop = dialog_dup_property( dialog, control->property, indirect );
 
-    msi_dialog_set_property( dialog->package, prop, text );
+    dialog_set_property( dialog->package, prop, text );
 
     free( prop );
     return ERROR_SUCCESS;
 }
 
-static void msi_dialog_vsc_add_drives( msi_dialog *dialog, msi_control *control )
+static void dialog_vsc_add_drives( msi_dialog *dialog, struct control *control )
 {
     LPWSTR drives, ptr;
     DWORD size;
@@ -3342,9 +3310,9 @@ static void msi_dialog_vsc_add_drives( msi_dialog *dialog, msi_control *control
     free( drives );
 }
 
-static UINT msi_dialog_volumeselect_combo( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_volumeselect_combo( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop;
     DWORD style;
 
@@ -3352,21 +3320,21 @@ static UINT msi_dialog_volumeselect_combo( msi_dialog *dialog, MSIRECORD *rec )
     style = WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP |
             CBS_DROPDOWNLIST | CBS_SORT | CBS_HASSTRINGS |
             WS_EX_LEFT | WS_EX_LTRREADING | WS_EX_RIGHTSCROLLBAR;
-    control = msi_dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
+    control = dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
     control->attributes = MSI_RecordGetInteger( rec, 8 );
-    control->handler = msi_dialog_volsel_handler;
+    control->handler = dialog_volsel_handler;
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
-    msi_dialog_vsc_add_drives( dialog, control );
+    dialog_vsc_add_drives( dialog, control );
 
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_hyperlink_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_hyperlink_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     int len, len_href = ARRAY_SIZE( L"href" ) - 1;
     const WCHAR *p, *q;
@@ -3411,20 +3379,20 @@ static UINT msi_dialog_hyperlink_handler( msi_dialog *dialog, msi_control *contr
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_hyperlink( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_hyperlink( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     DWORD style = WS_CHILD | WS_TABSTOP | WS_GROUP;
     const WCHAR *text = MSI_RecordGetString( rec, 10 );
     int len = lstrlenW( text );
     LITEM item;
 
-    control = msi_dialog_add_control( dialog, rec, WC_LINK, style );
+    control = dialog_add_control( dialog, rec, WC_LINK, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
     control->attributes = MSI_RecordGetInteger( rec, 8 );
-    control->handler    = msi_dialog_hyperlink_handler;
+    control->handler    = dialog_hyperlink_handler;
 
     item.mask      = LIF_ITEMINDEX | LIF_STATE | LIF_URL;
     item.iLink     = 0;
@@ -3443,10 +3411,10 @@ static UINT msi_dialog_hyperlink( msi_dialog *dialog, MSIRECORD *rec )
 struct listview_param
 {
     msi_dialog *dialog;
-    msi_control *control;
+    struct control *control;
 };
 
-static UINT msi_dialog_listview_handler( msi_dialog *dialog, msi_control *control, WPARAM param )
+static UINT dialog_listview_handler( msi_dialog *dialog, struct control *control, WPARAM param )
 {
     NMHDR *nmhdr = (NMHDR *)param;
 
@@ -3455,7 +3423,7 @@ static UINT msi_dialog_listview_handler( msi_dialog *dialog, msi_control *contro
     return ERROR_SUCCESS;
 }
 
-static UINT msi_listview_add_item( MSIRECORD *rec, LPVOID param )
+static UINT listview_add_item( MSIRECORD *rec, void *param )
 {
     struct listview_param *lv_param = (struct listview_param *)param;
     LPCWSTR text, binary;
@@ -3464,7 +3432,7 @@ static UINT msi_listview_add_item( MSIRECORD *rec, LPVOID param )
 
     text = MSI_RecordGetString( rec, 4 );
     binary = MSI_RecordGetString( rec, 5 );
-    hIcon = msi_load_icon( lv_param->dialog->package->db, binary, 0 );
+    hIcon = load_icon( lv_param->dialog->package->db, binary, 0 );
 
     TRACE("Adding: text %s, binary %s, icon %p\n", debugstr_w(text), debugstr_w(binary), hIcon);
 
@@ -3480,7 +3448,7 @@ static UINT msi_listview_add_item( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_listview_add_items( msi_dialog *dialog, msi_control *control )
+static UINT listview_add_items( msi_dialog *dialog, struct control *control )
 {
     MSIQUERY *view;
     struct listview_param lv_param = { dialog, control };
@@ -3488,16 +3456,16 @@ static UINT msi_listview_add_items( msi_dialog *dialog, msi_control *control )
     if (MSI_OpenQuery( dialog->package->db, &view, L"SELECT * FROM `ListView` WHERE `Property` = '%s' ORDER BY `Order`",
                        control->property ) == ERROR_SUCCESS)
     {
-        MSI_IterateRecords( view, NULL, msi_listview_add_item, &lv_param );
+        MSI_IterateRecords( view, NULL, listview_add_item, &lv_param );
         msiobj_release( &view->hdr );
     }
 
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_listview( msi_dialog *dialog, MSIRECORD *rec )
+static UINT dialog_listview( msi_dialog *dialog, MSIRECORD *rec )
 {
-    msi_control *control;
+    struct control *control;
     LPCWSTR prop;
     DWORD style, attributes;
     LVCOLUMNW col;
@@ -3508,12 +3476,12 @@ static UINT msi_dialog_listview( msi_dialog *dialog, MSIRECORD *rec )
     attributes = MSI_RecordGetInteger( rec, 8 );
     if ( ~attributes & msidbControlAttributesSorted )
         style |= LVS_SORTASCENDING;
-    control = msi_dialog_add_control( dialog, rec, WC_LISTVIEWW, style );
+    control = dialog_add_control( dialog, rec, WC_LISTVIEWW, style );
     if (!control)
         return ERROR_FUNCTION_FAILED;
 
     prop = MSI_RecordGetString( rec, 9 );
-    control->property = msi_dialog_dup_property( dialog, prop, FALSE );
+    control->property = dialog_dup_property( dialog, prop, FALSE );
 
     control->hImageList = ImageList_Create( 16, 16, ILC_COLOR32, 0, 1);
     SendMessageW( control->hwnd, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)control->hImageList );
@@ -3528,40 +3496,40 @@ static UINT msi_dialog_listview( msi_dialog *dialog, MSIRECORD *rec )
     SendMessageW( control->hwnd, LVM_INSERTCOLUMNW, 0, (LPARAM)&col );
 
     if (control->property)
-        msi_listview_add_items( dialog, control );
+        listview_add_items( dialog, control );
 
-    control->handler = msi_dialog_listview_handler;
+    control->handler = dialog_listview_handler;
 
     return ERROR_SUCCESS;
 }
 
 static const struct control_handler msi_dialog_handler[] =
 {
-    { L"Text", msi_dialog_text_control },
-    { L"PushButton", msi_dialog_button_control },
-    { L"Line", msi_dialog_line_control },
-    { L"Bitmap", msi_dialog_bitmap_control },
-    { L"CheckBox", msi_dialog_checkbox_control },
-    { L"ScrollableText", msi_dialog_scrolltext_control },
-    { L"ComboBox", msi_dialog_combo_control },
-    { L"Edit", msi_dialog_edit_control },
-    { L"MaskedEdit", msi_dialog_maskedit_control },
-    { L"PathEdit", msi_dialog_pathedit_control },
-    { L"ProgressBar", msi_dialog_progress_bar },
-    { L"RadioButtonGroup", msi_dialog_radiogroup_control },
-    { L"Icon", msi_dialog_icon_control },
-    { L"SelectionTree", msi_dialog_selection_tree },
-    { L"GroupBox", msi_dialog_group_box },
-    { L"ListBox", msi_dialog_list_box },
-    { L"DirectoryCombo", msi_dialog_directory_combo },
-    { L"DirectoryList", msi_dialog_directory_list },
-    { L"VolumeCostList", msi_dialog_volumecost_list },
-    { L"VolumeSelectCombo", msi_dialog_volumeselect_combo },
-    { L"HyperLink", msi_dialog_hyperlink },
-    { L"ListView", msi_dialog_listview }
+    { L"Text", dialog_text_control },
+    { L"PushButton", dialog_button_control },
+    { L"Line", dialog_line_control },
+    { L"Bitmap", dialog_bitmap_control },
+    { L"CheckBox", dialog_checkbox_control },
+    { L"ScrollableText", dialog_scrolltext_control },
+    { L"ComboBox", dialog_combo_control },
+    { L"Edit", dialog_edit_control },
+    { L"MaskedEdit", dialog_maskedit_control },
+    { L"PathEdit", dialog_pathedit_control },
+    { L"ProgressBar", dialog_progress_bar },
+    { L"RadioButtonGroup", dialog_radiogroup_control },
+    { L"Icon", dialog_icon_control },
+    { L"SelectionTree", dialog_selection_tree },
+    { L"GroupBox", dialog_group_box },
+    { L"ListBox", dialog_list_box },
+    { L"DirectoryCombo", dialog_directory_combo },
+    { L"DirectoryList", dialog_directory_list },
+    { L"VolumeCostList", dialog_volumecost_list },
+    { L"VolumeSelectCombo", dialog_volumeselect_combo },
+    { L"HyperLink", dialog_hyperlink },
+    { L"ListView", dialog_listview }
 };
 
-static UINT msi_dialog_create_controls( MSIRECORD *rec, LPVOID param )
+static UINT dialog_create_controls( MSIRECORD *rec, void *param )
 {
     msi_dialog *dialog = param;
     LPCWSTR control_type;
@@ -3580,7 +3548,7 @@ static UINT msi_dialog_create_controls( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dialog_fill_controls( msi_dialog *dialog )
+static UINT dialog_fill_controls( msi_dialog *dialog )
 {
     UINT r;
     MSIQUERY *view;
@@ -3596,19 +3564,19 @@ static UINT msi_dialog_fill_controls( msi_dialog *dialog )
         return ERROR_INVALID_PARAMETER;
     }
 
-    r = MSI_IterateRecords( view, 0, msi_dialog_create_controls, dialog );
+    r = MSI_IterateRecords( view, 0, dialog_create_controls, dialog );
     msiobj_release( &view->hdr );
     return r;
 }
 
-static UINT msi_dialog_reset( msi_dialog *dialog )
+static UINT dialog_reset( msi_dialog *dialog )
 {
     /* FIXME: should restore the original values of any properties we changed */
-    return msi_dialog_evaluate_control_conditions( dialog );
+    return dialog_evaluate_control_conditions( dialog );
 }
 
 /* figure out the height of 10 point MS Sans Serif */
-static INT msi_dialog_get_sans_serif_height( HWND hwnd )
+static INT dialog_get_sans_serif_height( HWND hwnd )
 {
     LOGFONTW lf;
     TEXTMETRICW tm;
@@ -3639,7 +3607,7 @@ static INT msi_dialog_get_sans_serif_height( HWND hwnd )
 }
 
 /* fetch the associated record from the Dialog table */
-static MSIRECORD *msi_get_dialog_record( msi_dialog *dialog )
+static MSIRECORD *get_dialog_record( msi_dialog *dialog )
 {
     MSIPACKAGE *package = dialog->package;
     MSIRECORD *rec = NULL;
@@ -3653,7 +3621,7 @@ static MSIRECORD *msi_get_dialog_record( msi_dialog *dialog )
     return rec;
 }
 
-static void msi_dialog_adjust_dialog_pos( msi_dialog *dialog, MSIRECORD *rec, LPRECT pos )
+static void dialog_adjust_dialog_pos( msi_dialog *dialog, MSIRECORD *rec, RECT *pos )
 {
     UINT xres, yres;
     POINT center;
@@ -3666,8 +3634,8 @@ static void msi_dialog_adjust_dialog_pos( msi_dialog *dialog, MSIRECORD *rec, LP
     sz.cx = MSI_RecordGetInteger( rec, 4 );
     sz.cy = MSI_RecordGetInteger( rec, 5 );
 
-    sz.cx = msi_dialog_scale_unit( dialog, sz.cx );
-    sz.cy = msi_dialog_scale_unit( dialog, sz.cy );
+    sz.cx = dialog_scale_unit( dialog, sz.cx );
+    sz.cy = dialog_scale_unit( dialog, sz.cy );
 
     xres = msi_get_property_int( dialog->package->db, L"ScreenX", 0 );
     yres = msi_get_property_int( dialog->package->db, L"ScreenY", 0 );
@@ -3704,14 +3672,14 @@ static void msi_dialog_adjust_dialog_pos( msi_dialog *dialog, MSIRECORD *rec, LP
     AdjustWindowRect( pos, style, FALSE );
 }
 
-static void msi_dialog_set_tab_order( msi_dialog *dialog, LPCWSTR first )
+static void dialog_set_tab_order( msi_dialog *dialog, const WCHAR *first )
 {
     struct list tab_chain;
-    msi_control *control;
+    struct control *control;
     HWND prev = HWND_TOP;
 
     list_init( &tab_chain );
-    if (!(control = msi_dialog_find_control( dialog, first ))) return;
+    if (!(control = dialog_find_control( dialog, first ))) return;
 
     dialog->hWndFocus = control->hwnd;
     while (control)
@@ -3719,10 +3687,10 @@ static void msi_dialog_set_tab_order( msi_dialog *dialog, LPCWSTR first )
         list_remove( &control->entry );
         list_add_tail( &tab_chain, &control->entry );
         if (!control->tabnext) break;
-        control = msi_dialog_find_control( dialog, control->tabnext );
+        control = dialog_find_control( dialog, control->tabnext );
     }
 
-    LIST_FOR_EACH_ENTRY( control, &tab_chain, msi_control, entry )
+    LIST_FOR_EACH_ENTRY( control, &tab_chain, struct control, entry )
     {
         SetWindowPos( control->hwnd, prev, 0, 0, 0, 0,
                       SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOREDRAW |
@@ -3734,7 +3702,7 @@ static void msi_dialog_set_tab_order( msi_dialog *dialog, LPCWSTR first )
     list_move_head( &dialog->controls, &tab_chain );
 }
 
-static LRESULT msi_dialog_oncreate( HWND hwnd, LPCREATESTRUCTW cs )
+static LRESULT dialog_oncreate( HWND hwnd, CREATESTRUCTW *cs )
 {
     msi_dialog *dialog = cs->lpCreateParams;
     MSIRECORD *rec = NULL;
@@ -3746,16 +3714,16 @@ static LRESULT msi_dialog_oncreate( HWND hwnd, LPCREATESTRUCTW cs )
     dialog->hwnd = hwnd;
     SetWindowLongPtrW( hwnd, GWLP_USERDATA, (LONG_PTR) dialog );
 
-    rec = msi_get_dialog_record( dialog );
+    rec = get_dialog_record( dialog );
     if( !rec )
     {
         TRACE("No record found for dialog %s\n", debugstr_w(dialog->name));
         return -1;
     }
 
-    dialog->scale = msi_dialog_get_sans_serif_height(dialog->hwnd);
+    dialog->scale = dialog_get_sans_serif_height(dialog->hwnd);
 
-    msi_dialog_adjust_dialog_pos( dialog, rec, &pos );
+    dialog_adjust_dialog_pos( dialog, rec, &pos );
 
     dialog->attributes = MSI_RecordGetInteger( rec, 6 );
 
@@ -3770,7 +3738,7 @@ static LRESULT msi_dialog_oncreate( HWND hwnd, LPCREATESTRUCTW cs )
         }
     }
 
-    title = msi_get_deformatted_field( dialog->package, rec, 7 );
+    title = get_deformatted_field( dialog->package, rec, 7 );
     SetWindowTextW( hwnd, title );
     free( title );
 
@@ -3778,31 +3746,31 @@ static LRESULT msi_dialog_oncreate( HWND hwnd, LPCREATESTRUCTW cs )
                   pos.right - pos.left, pos.bottom - pos.top,
                   SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOREDRAW );
 
-    msi_dialog_build_font_list( dialog );
-    msi_dialog_fill_controls( dialog );
-    msi_dialog_evaluate_control_conditions( dialog );
-    msi_dialog_set_tab_order( dialog, MSI_RecordGetString( rec, 8 ) );
+    dialog_build_font_list( dialog );
+    dialog_fill_controls( dialog );
+    dialog_evaluate_control_conditions( dialog );
+    dialog_set_tab_order( dialog, MSI_RecordGetString( rec, 8 ) );
     msiobj_release( &rec->hdr );
 
     return 0;
 }
 
-static LRESULT msi_dialog_oncommand( msi_dialog *dialog, WPARAM param, HWND hwnd )
+static LRESULT dialog_oncommand( msi_dialog *dialog, WPARAM param, HWND hwnd )
 {
-    msi_control *control = NULL;
+    struct control *control = NULL;
 
     TRACE( "%p, %#Ix, %p\n", dialog, param, hwnd );
 
     switch (param)
     {
     case 1: /* enter */
-        control = msi_dialog_find_control( dialog, dialog->control_default );
+        control = dialog_find_control( dialog, dialog->control_default );
         break;
     case 2: /* escape */
-        control = msi_dialog_find_control( dialog, dialog->control_cancel );
+        control = dialog_find_control( dialog, dialog->control_cancel );
         break;
     default:
-        control = msi_dialog_find_control_by_hwnd( dialog, hwnd );
+        control = dialog_find_control_by_hwnd( dialog, hwnd );
     }
 
     if( control )
@@ -3810,17 +3778,17 @@ static LRESULT msi_dialog_oncommand( msi_dialog *dialog, WPARAM param, HWND hwnd
         if( control->handler )
         {
             control->handler( dialog, control, param );
-            msi_dialog_evaluate_control_conditions( dialog );
+            dialog_evaluate_control_conditions( dialog );
         }
     }
 
     return 0;
 }
 
-static LRESULT msi_dialog_onnotify( msi_dialog *dialog, LPARAM param )
+static LRESULT dialog_onnotify( msi_dialog *dialog, LPARAM param )
 {
     LPNMHDR nmhdr = (LPNMHDR) param;
-    msi_control *control = msi_dialog_find_control_by_hwnd( dialog, nmhdr->hwndFrom );
+    struct control *control = dialog_find_control_by_hwnd( dialog, nmhdr->hwndFrom );
 
     TRACE("%p %p\n", dialog, nmhdr->hwndFrom);
 
@@ -3855,14 +3823,14 @@ static LRESULT WINAPI MSIDialog_WndProc( HWND hwnd, UINT msg,
         break;
 
     case WM_CREATE:
-        return msi_dialog_oncreate( hwnd, (LPCREATESTRUCTW)lParam );
+        return dialog_oncreate( hwnd, (LPCREATESTRUCTW)lParam );
 
     case WM_COMMAND:
-        return msi_dialog_oncommand( dialog, wParam, (HWND)lParam );
+        return dialog_oncommand( dialog, wParam, (HWND)lParam );
 
     case WM_CLOSE:
         /* Simulate escape press */
-        return msi_dialog_oncommand(dialog, 2, NULL);
+        return dialog_oncommand(dialog, 2, NULL);
 
     case WM_ACTIVATE:
         if( LOWORD(wParam) == WA_INACTIVE )
@@ -3883,7 +3851,7 @@ static LRESULT WINAPI MSIDialog_WndProc( HWND hwnd, UINT msg,
         dialog->hwnd = NULL;
         return 0;
     case WM_NOTIFY:
-        return msi_dialog_onnotify( dialog, lParam );
+        return dialog_onnotify( dialog, lParam );
     }
     return DefWindowProcW(hwnd, msg, wParam, lParam);
 }
@@ -3944,8 +3912,7 @@ static UINT dialog_run_message_loop( msi_dialog *dialog )
     return ERROR_SUCCESS;
 }
 
-static LRESULT WINAPI MSIHiddenWindowProc( HWND hwnd, UINT msg,
-                WPARAM wParam, LPARAM lParam )
+static LRESULT WINAPI MSIHiddenWindowProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
     msi_dialog *dialog = (msi_dialog*) lParam;
 
@@ -3995,7 +3962,7 @@ static BOOL dialog_register_class( void )
 }
 
 static msi_dialog *dialog_create( MSIPACKAGE *package, const WCHAR *name, msi_dialog *parent,
-                                  control_event_handler event_handler )
+                                  UINT (*event_handler)(msi_dialog *, const WCHAR *, const WCHAR *) )
 {
     MSIRECORD *rec = NULL;
     msi_dialog *dialog;
@@ -4017,7 +3984,7 @@ static msi_dialog *dialog_create( MSIPACKAGE *package, const WCHAR *name, msi_di
     list_init( &dialog->fonts );
 
     /* verify that the dialog exists */
-    rec = msi_get_dialog_record( dialog );
+    rec = get_dialog_record( dialog );
     if( !rec )
     {
         free( dialog );
@@ -4042,7 +4009,7 @@ static msi_dialog *dialog_create( MSIPACKAGE *package, const WCHAR *name, msi_di
     return dialog;
 }
 
-static void msi_dialog_end_dialog( msi_dialog *dialog )
+static void dialog_end_dialog( msi_dialog *dialog )
 {
     TRACE("%p\n", dialog);
     dialog->finished = 1;
@@ -4119,7 +4086,7 @@ static void event_cleanup_subscriptions( MSIPACKAGE *package, const WCHAR *dialo
 
 void msi_dialog_destroy( msi_dialog *dialog )
 {
-    msi_font *font, *next;
+    struct font *font, *next;
 
     if( uiThreadId != GetCurrentThreadId() )
     {
@@ -4139,15 +4106,14 @@ void msi_dialog_destroy( msi_dialog *dialog )
     /* destroy the list of controls */
     while( !list_empty( &dialog->controls ) )
     {
-        msi_control *t;
+        struct control *t;
 
-        t = LIST_ENTRY( list_head( &dialog->controls ),
-                        msi_control, entry );
-        msi_destroy_control( t );
+        t = LIST_ENTRY( list_head( &dialog->controls ), struct control, entry );
+        destroy_control( t );
     }
 
     /* destroy the list of fonts */
-    LIST_FOR_EACH_ENTRY_SAFE( font, next, &dialog->fonts, msi_font, entry )
+    LIST_FOR_EACH_ENTRY_SAFE( font, next, &dialog->fonts, struct font, entry )
     {
         list_remove( &font->entry );
         DeleteObject( font->hfont );
@@ -4307,7 +4273,7 @@ UINT WINAPI MsiPreviewBillboardA( MSIHANDLE hPreview, const char *szControlName,
 struct control_event
 {
     const WCHAR  *event;
-    event_handler handler;
+    UINT (*handler)( msi_dialog *, const WCHAR * );
 };
 
 static UINT dialog_event_handler( msi_dialog *, const WCHAR *, const WCHAR * );
@@ -4364,7 +4330,7 @@ static UINT event_end_dialog( msi_dialog *dialog, const WCHAR *argument )
         dialog->retval = IDABORT;
     }
     event_cleanup_subscriptions( dialog->package, dialog->name );
-    msi_dialog_end_dialog( dialog );
+    dialog_end_dialog( dialog );
     return ERROR_SUCCESS;
 }
 
@@ -4382,7 +4348,7 @@ static UINT event_new_dialog( msi_dialog *dialog, const WCHAR *argument )
     /* store the name of the next dialog, and signal this one to end */
     dialog->package->next_dialog = wcsdup( argument );
     msi_event_cleanup_all_subscriptions( dialog->package );
-    msi_dialog_end_dialog( dialog );
+    dialog_end_dialog( dialog );
     return ERROR_SUCCESS;
 }
 
@@ -4403,10 +4369,10 @@ static UINT event_spawn_dialog( msi_dialog *dialog, const WCHAR *argument )
     if (r != 0)
     {
         dialog->retval = r;
-        msi_dialog_end_dialog( dialog );
+        dialog_end_dialog( dialog );
     }
     else
-        msi_dialog_update_all_controls(dialog);
+        dialog_update_all_controls(dialog);
 
     return ERROR_SUCCESS;
 }
@@ -4513,7 +4479,7 @@ static UINT event_set_target_path( msi_dialog *dialog, const WCHAR *argument )
 
 static UINT event_reset( msi_dialog *dialog, const WCHAR *argument )
 {
-    msi_dialog_reset( dialog );
+    dialog_reset( dialog );
     return ERROR_SUCCESS;
 }
 
@@ -4579,12 +4545,12 @@ static UINT event_set_install_level( msi_dialog *dialog, const WCHAR *argument )
 
 static UINT event_directory_list_up( msi_dialog *dialog, const WCHAR *argument )
 {
-    return msi_dialog_directorylist_up( dialog );
+    return dialog_directorylist_up( dialog );
 }
 
 static UINT event_directory_list_new( msi_dialog *dialog, const WCHAR *argument )
 {
-    return msi_dialog_directorylist_new( dialog );
+    return dialog_directorylist_new( dialog );
 }
 
 static UINT event_reinstall_mode( msi_dialog *dialog, const WCHAR *argument )
diff --git a/dlls/msi/distinct.c b/dlls/msi/distinct.c
index 23e74e17edc..d1b99f9ca64 100644
--- a/dlls/msi/distinct.c
+++ b/dlls/msi/distinct.c
@@ -35,25 +35,25 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
-typedef struct tagDISTINCTSET
+struct distinct_set
 {
     UINT val;
     UINT count;
     UINT row;
-    struct tagDISTINCTSET *nextrow;
-    struct tagDISTINCTSET *nextcol;
-} DISTINCTSET;
+    struct distinct_set *nextrow;
+    struct distinct_set *nextcol;
+};
 
-typedef struct tagMSIDISTINCTVIEW
+struct distinct_view
 {
     MSIVIEW        view;
     MSIDATABASE   *db;
     MSIVIEW       *table;
     UINT           row_count;
     UINT          *translation;
-} MSIDISTINCTVIEW;
+};
 
-static DISTINCTSET ** distinct_insert( DISTINCTSET **x, UINT val, UINT row )
+static struct distinct_set **distinct_insert( struct distinct_set **x, UINT val, UINT row )
 {
     /* horrible O(n) find */
     while( *x )
@@ -67,7 +67,7 @@ static DISTINCTSET ** distinct_insert( DISTINCTSET **x, UINT val, UINT row )
     }
 
     /* nothing found, so add one */
-    *x = malloc( sizeof(DISTINCTSET) );
+    *x = malloc( sizeof(**x) );
     if( *x )
     {
         (*x)->val = val;
@@ -79,11 +79,11 @@ static DISTINCTSET ** distinct_insert( DISTINCTSET **x, UINT val, UINT row )
     return x;
 }
 
-static void distinct_free( DISTINCTSET *x )
+static void distinct_free( struct distinct_set *x )
 {
     while( x )
     {
-        DISTINCTSET *next = x->nextrow;
+        struct distinct_set *next = x->nextrow;
         distinct_free( x->nextcol );
         free( x );
         x = next;
@@ -92,7 +92,7 @@ static void distinct_free( DISTINCTSET *x )
 
 static UINT DISTINCT_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
 
     TRACE("%p %d %d %p\n", dv, row, col, val );
 
@@ -109,9 +109,9 @@ static UINT DISTINCT_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UIN
 
 static UINT DISTINCT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
     UINT r, i, j, r_count, c_count;
-    DISTINCTSET *rowset = NULL;
+    struct distinct_set *rowset = NULL;
 
     TRACE("%p %p\n", dv, record);
 
@@ -133,7 +133,7 @@ static UINT DISTINCT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
     /* build it */
     for( i=0; i<r_count; i++ )
     {
-        DISTINCTSET **x = &rowset;
+        struct distinct_set **x = &rowset;
 
         for( j=1; j<=c_count; j++ )
         {
@@ -171,7 +171,7 @@ static UINT DISTINCT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 
 static UINT DISTINCT_close( struct tagMSIVIEW *view )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
 
     TRACE("%p\n", dv );
 
@@ -187,7 +187,7 @@ static UINT DISTINCT_close( struct tagMSIVIEW *view )
 
 static UINT DISTINCT_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
 
     TRACE("%p %p %p\n", dv, rows, cols );
 
@@ -207,7 +207,7 @@ static UINT DISTINCT_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *
 static UINT DISTINCT_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                       UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
 
     TRACE("%p %d %p %p %p %p\n", dv, n, name, type, temporary, table_name );
 
@@ -221,7 +221,7 @@ static UINT DISTINCT_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *
 static UINT DISTINCT_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                              MSIRECORD *rec, UINT row )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
 
     TRACE("%p %d %p\n", dv, eModifyMode, rec );
 
@@ -233,7 +233,7 @@ static UINT DISTINCT_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 
 static UINT DISTINCT_delete( struct tagMSIVIEW *view )
 {
-    MSIDISTINCTVIEW *dv = (MSIDISTINCTVIEW*)view;
+    struct distinct_view *dv = (struct distinct_view *)view;
 
     TRACE("%p\n", dv );
 
@@ -272,7 +272,7 @@ static const MSIVIEWOPS distinct_ops =
 
 UINT DISTINCT_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table )
 {
-    MSIDISTINCTVIEW *dv = NULL;
+    struct distinct_view *dv = NULL;
     UINT count = 0, r;
 
     TRACE("%p\n", dv );
diff --git a/dlls/msi/drop.c b/dlls/msi/drop.c
index 9c3aebba0eb..9c7fc0ca0ea 100644
--- a/dlls/msi/drop.c
+++ b/dlls/msi/drop.c
@@ -34,18 +34,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
-typedef struct tagMSIDROPVIEW
+struct drop_view
 {
     MSIVIEW view;
     MSIDATABASE *db;
     MSIVIEW *table;
     column_info *colinfo;
     INT hold;
-} MSIDROPVIEW;
+};
 
 static UINT DROP_execute(struct tagMSIVIEW *view, MSIRECORD *record)
 {
-    MSIDROPVIEW *dv = (MSIDROPVIEW*)view;
+    struct drop_view *dv = (struct drop_view *)view;
     UINT r;
 
     TRACE("%p %p\n", dv, record);
@@ -62,7 +62,7 @@ static UINT DROP_execute(struct tagMSIVIEW *view, MSIRECORD *record)
 
 static UINT DROP_close(struct tagMSIVIEW *view)
 {
-    MSIDROPVIEW *dv = (MSIDROPVIEW*)view;
+    struct drop_view *dv = (struct drop_view *)view;
 
     TRACE("%p\n", dv);
 
@@ -71,7 +71,7 @@ static UINT DROP_close(struct tagMSIVIEW *view)
 
 static UINT DROP_get_dimensions(struct tagMSIVIEW *view, UINT *rows, UINT *cols)
 {
-    MSIDROPVIEW *dv = (MSIDROPVIEW*)view;
+    struct drop_view *dv = (struct drop_view *)view;
 
     TRACE("%p %p %p\n", dv, rows, cols);
 
@@ -80,7 +80,7 @@ static UINT DROP_get_dimensions(struct tagMSIVIEW *view, UINT *rows, UINT *cols)
 
 static UINT DROP_delete( struct tagMSIVIEW *view )
 {
-    MSIDROPVIEW *dv = (MSIDROPVIEW*)view;
+    struct drop_view *dv = (struct drop_view *)view;
 
     TRACE("%p\n", dv );
 
@@ -117,7 +117,7 @@ static const MSIVIEWOPS drop_ops =
 
 UINT DROP_CreateView(MSIDATABASE *db, MSIVIEW **view, LPCWSTR name)
 {
-    MSIDROPVIEW *dv;
+    struct drop_view *dv;
     UINT r;
 
     TRACE("%p %s\n", view, debugstr_w(name));
diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 75075a37b5f..96c6c5eaa4b 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -67,7 +67,7 @@ HANDLE msi_create_file( MSIPACKAGE *package, const WCHAR *filename, DWORD access
     return handle;
 }
 
-static BOOL msi_copy_file( MSIPACKAGE *package, const WCHAR *src, const WCHAR *dst, BOOL fail_if_exists )
+static BOOL copy_file( MSIPACKAGE *package, const WCHAR *src, const WCHAR *dst, BOOL fail_if_exists )
 {
     BOOL ret;
     msi_disable_fs_redirection( package );
@@ -85,7 +85,7 @@ BOOL msi_delete_file( MSIPACKAGE *package, const WCHAR *filename )
     return ret;
 }
 
-static BOOL msi_create_directory( MSIPACKAGE *package, const WCHAR *path )
+static BOOL create_directory( MSIPACKAGE *package, const WCHAR *path )
 {
     BOOL ret;
     msi_disable_fs_redirection( package );
@@ -148,7 +148,7 @@ BOOL msi_move_file( MSIPACKAGE *package, const WCHAR *from, const WCHAR *to, DWO
     return ret;
 }
 
-static BOOL msi_apply_filepatch( MSIPACKAGE *package, const WCHAR *patch, const WCHAR *old, const WCHAR *new )
+static BOOL apply_filepatch( MSIPACKAGE *package, const WCHAR *patch, const WCHAR *old, const WCHAR *new )
 {
     BOOL ret;
     msi_disable_fs_redirection( package );
@@ -220,7 +220,7 @@ BOOL msi_create_full_path( MSIPACKAGE *package, const WCHAR *path )
     while ((len = lstrlenW( new_path )) && new_path[len - 1] == '\\')
     new_path[len - 1] = 0;
 
-    while (!msi_create_directory( package, new_path ))
+    while (!create_directory( package, new_path ))
     {
         WCHAR *slash;
         DWORD last_error = GetLastError();
@@ -248,7 +248,7 @@ BOOL msi_create_full_path( MSIPACKAGE *package, const WCHAR *path )
     return ret;
 }
 
-static void msi_file_update_ui( MSIPACKAGE *package, MSIFILE *f, const WCHAR *action )
+static void file_update_ui( MSIPACKAGE *package, MSIFILE *f, const WCHAR *action )
 {
     MSIRECORD *uirow;
 
@@ -305,7 +305,7 @@ static msi_file_state calculate_install_state( MSIPACKAGE *package, MSIFILE *fil
     DWORD size;
 
     comp->Action = msi_get_component_action( package, comp );
-    if (!comp->Enabled || comp->Action != INSTALLSTATE_LOCAL || (comp->assembly && comp->assembly->installed))
+    if (!comp->Enabled || comp->Action != INSTALLSTATE_LOCAL)
     {
         TRACE("skipping %s (not scheduled for install)\n", debugstr_w(file->File));
         return msifs_skipped;
@@ -315,8 +315,7 @@ static msi_file_state calculate_install_state( MSIPACKAGE *package, MSIFILE *fil
         TRACE("skipping %s (obsoleted by patch)\n", debugstr_w(file->File));
         return msifs_skipped;
     }
-    if ((msi_is_global_assembly( comp ) && !comp->assembly->installed) ||
-        msi_get_file_attributes( package, file->TargetPath ) == INVALID_FILE_ATTRIBUTES)
+    if (msi_get_file_attributes( package, file->TargetPath ) == INVALID_FILE_ATTRIBUTES)
     {
         TRACE("installing %s (missing)\n", debugstr_w(file->File));
         return msifs_missing;
@@ -402,11 +401,11 @@ static void schedule_install_files(MSIPACKAGE *package)
     }
 }
 
-static UINT copy_file( MSIPACKAGE *package, MSIFILE *file, WCHAR *source )
+static UINT copy_file_attributes( MSIPACKAGE *package, MSIFILE *file, WCHAR *source )
 {
     BOOL ret;
 
-    ret = msi_copy_file( package, source, file->TargetPath, FALSE );
+    ret = copy_file( package, source, file->TargetPath, FALSE );
     if (!ret)
         return GetLastError();
 
@@ -420,7 +419,7 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
 
     TRACE("Copying %s to %s\n", debugstr_w(source), debugstr_w(file->TargetPath));
 
-    gle = copy_file( package, file, source );
+    gle = copy_file_attributes( package, file, source );
     if (gle == ERROR_SUCCESS)
         return gle;
 
@@ -433,7 +432,7 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
     {
         msi_set_file_attributes( package, file->TargetPath, FILE_ATTRIBUTE_NORMAL );
 
-        gle = copy_file( package, file, source );
+        gle = copy_file_attributes( package, file, source );
         TRACE("Overwriting existing file: %d\n", gle);
     }
     if (gle == ERROR_SHARING_VIOLATION || gle == ERROR_USER_MAPPED_FILE)
@@ -454,7 +453,7 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
         if (!GetTempFileNameW( pathW, L"msi", 0, tmpfileW )) tmpfileW[0] = 0;
         free( pathW );
 
-        if (msi_copy_file( package, source, tmpfileW, FALSE ) &&
+        if (copy_file( package, source, tmpfileW, FALSE ) &&
             msi_move_file( package, file->TargetPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) &&
             msi_move_file( package, tmpfileW, file->TargetPath, MOVEFILE_DELAY_UNTIL_REBOOT ))
         {
@@ -473,7 +472,7 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
     return gle;
 }
 
-static UINT create_directory( MSIPACKAGE *package, const WCHAR *dir )
+static UINT create_folder( MSIPACKAGE *package, const WCHAR *dir )
 {
     MSIFOLDER *folder;
     const WCHAR *install_path;
@@ -520,7 +519,7 @@ static BOOL installfiles_cb(MSIPACKAGE *package, LPCWSTR filename, DWORD action,
 
         if (!msi_is_global_assembly( file->Component ))
         {
-            create_directory( package, file->Component->Directory );
+            create_folder( package, file->Component->Directory );
         }
         *path = wcsdup( file->TargetPath );
         *attrs = file->Attributes;
@@ -580,7 +579,7 @@ UINT ACTION_InstallFiles(MSIPACKAGE *package)
     {
         BOOL is_global_assembly = msi_is_global_assembly( file->Component );
 
-        msi_file_update_ui( package, file, L"InstallFiles" );
+        file_update_ui( package, file, L"InstallFiles" );
 
         rc = msi_load_media_info( package, file->Sequence, mi );
         if (rc != ERROR_SUCCESS)
@@ -629,7 +628,7 @@ UINT ACTION_InstallFiles(MSIPACKAGE *package)
 
             if (!is_global_assembly)
             {
-                create_directory(package, file->Component->Directory);
+                create_folder(package, file->Component->Directory);
             }
             rc = copy_install_file(package, file, source);
             if (rc != ERROR_SUCCESS)
@@ -650,22 +649,6 @@ UINT ACTION_InstallFiles(MSIPACKAGE *package)
             goto done;
         }
     }
-    LIST_FOR_EACH_ENTRY( file, &package->files, MSIFILE, entry )
-    {
-        MSICOMPONENT *comp = file->Component;
-
-        if (!msi_is_global_assembly( comp ) || comp->assembly->installed ||
-            (file->state != msifs_missing && file->state != msifs_overwrite)) continue;
-
-        rc = msi_install_assembly( package, comp );
-        if (rc != ERROR_SUCCESS)
-        {
-            ERR("Failed to install assembly\n");
-            rc = ERROR_INSTALL_FAILURE;
-            break;
-        }
-        file->state = msifs_installed;
-    }
 
 done:
     msi_free_media_info(mi);
@@ -724,7 +707,7 @@ static UINT patch_file( MSIPACKAGE *package, MSIFILEPATCH *patch )
     WCHAR *tmpfile = msi_create_temp_file( package->db );
 
     if (!tmpfile) return ERROR_INSTALL_FAILURE;
-    if (msi_apply_filepatch( package, patch->path, patch->File->TargetPath, tmpfile ))
+    if (apply_filepatch( package, patch->path, patch->File->TargetPath, tmpfile ))
     {
         msi_delete_file( package, patch->File->TargetPath );
         msi_move_file( package, tmpfile, patch->File->TargetPath, 0 );
@@ -740,7 +723,7 @@ static UINT patch_file( MSIPACKAGE *package, MSIFILEPATCH *patch )
     return r;
 }
 
-static UINT patch_assembly( MSIPACKAGE *package, MSIASSEMBLY *assembly, MSIFILEPATCH *patch )
+UINT msi_patch_assembly( MSIPACKAGE *package, MSIASSEMBLY *assembly, MSIFILEPATCH *patch )
 {
     UINT r = ERROR_FUNCTION_FAILED;
     IAssemblyName *name;
@@ -768,7 +751,7 @@ static UINT patch_assembly( MSIPACKAGE *package, MSIASSEMBLY *assembly, MSIFILEP
 
         if ((path = msi_get_assembly_path( package, displayname )))
         {
-            if (!msi_copy_file( package, path, patch->File->TargetPath, FALSE ))
+            if (!copy_file( package, path, patch->File->TargetPath, FALSE ))
             {
                 ERR( "failed to copy file %s -> %s (%lu)\n", debugstr_w(path),
                      debugstr_w(patch->File->TargetPath), GetLastError() );
@@ -851,27 +834,14 @@ UINT ACTION_PatchFiles( MSIPACKAGE *package )
     {
         MSICOMPONENT *comp = patch->File->Component;
 
-        if (!patch->path) continue;
-
-        if (msi_is_global_assembly( comp ))
-            rc = patch_assembly( package, comp->assembly, patch );
-        else
-            rc = patch_file( package, patch );
+        if (msi_is_global_assembly( comp ) || !patch->path) continue;
 
+        rc = patch_file( package, patch );
         if (rc && !(patch->Attributes & msidbPatchAttributesNonVital))
         {
             ERR("Failed to apply patch to file: %s\n", debugstr_w(patch->File->File));
             break;
         }
-
-        if (msi_is_global_assembly( comp ))
-        {
-            if ((rc = msi_install_assembly( package, comp )))
-            {
-                ERR("Failed to install patched assembly\n");
-                break;
-            }
-        }
     }
 
 done:
@@ -881,14 +851,14 @@ done:
 
 #define is_dot_dir(x) ((x[0] == '.') && ((x[1] == 0) || ((x[1] == '.') && (x[2] == 0))))
 
-typedef struct
+struct file_list
 {
     struct list entry;
     LPWSTR sourcename;
     LPWSTR destname;
     LPWSTR source;
     LPWSTR dest;
-} FILE_LIST;
+};
 
 static BOOL move_file( MSIPACKAGE *package, const WCHAR *source, const WCHAR *dest, int options )
 {
@@ -914,10 +884,10 @@ static BOOL move_file( MSIPACKAGE *package, const WCHAR *source, const WCHAR *de
     else
     {
         TRACE("copying %s -> %s\n", debugstr_w(source), debugstr_w(dest));
-        ret = msi_copy_file( package, source, dest, FALSE );
+        ret = copy_file( package, source, dest, FALSE );
         if (!ret)
         {
-            WARN( "msi_copy_file failed: %lu\n", GetLastError() );
+            WARN( "copy_file failed: %lu\n", GetLastError() );
             return FALSE;
         }
     }
@@ -943,31 +913,31 @@ static WCHAR *wildcard_to_file( const WCHAR *wildcard, const WCHAR *filename )
     return path;
 }
 
-static void free_file_entry(FILE_LIST *file)
+static void free_file_entry(struct file_list *file)
 {
     free(file->source);
     free(file->dest);
     free(file);
 }
 
-static void free_list(FILE_LIST *list)
+static void free_list(struct file_list *list)
 {
     while (!list_empty(&list->entry))
     {
-        FILE_LIST *file = LIST_ENTRY(list_head(&list->entry), FILE_LIST, entry);
+        struct file_list *file = LIST_ENTRY(list_head(&list->entry), struct file_list, entry);
 
         list_remove(&file->entry);
         free_file_entry(file);
     }
 }
 
-static BOOL add_wildcard( FILE_LIST *files, const WCHAR *source, WCHAR *dest )
+static BOOL add_wildcard( struct file_list *files, const WCHAR *source, WCHAR *dest )
 {
-    FILE_LIST *new, *file;
+    struct file_list *new, *file;
     WCHAR *ptr, *filename;
     DWORD size;
 
-    new = calloc(1, sizeof(FILE_LIST));
+    new = calloc(1, sizeof(*new));
     if (!new)
         return FALSE;
 
@@ -999,7 +969,7 @@ static BOOL add_wildcard( FILE_LIST *files, const WCHAR *source, WCHAR *dest )
         return TRUE;
     }
 
-    LIST_FOR_EACH_ENTRY(file, &files->entry, FILE_LIST, entry)
+    LIST_FOR_EACH_ENTRY(file, &files->entry, struct file_list, entry)
     {
         if (wcscmp( source, file->source ) < 0)
         {
@@ -1018,7 +988,7 @@ static BOOL move_files_wildcard( MSIPACKAGE *package, const WCHAR *source, WCHAR
     HANDLE hfile;
     LPWSTR path;
     BOOL res;
-    FILE_LIST files, *file;
+    struct file_list files, *file;
     DWORD size;
 
     hfile = msi_find_first_file( package, source, &wfd );
@@ -1046,7 +1016,7 @@ static BOOL move_files_wildcard( MSIPACKAGE *package, const WCHAR *source, WCHAR
         goto done;
 
     /* only the first wildcard match gets renamed to dest */
-    file = LIST_ENTRY(list_head(&files.entry), FILE_LIST, entry);
+    file = LIST_ENTRY(list_head(&files.entry), struct file_list, entry);
     size = (wcsrchr(file->dest, '\\') - file->dest) + lstrlenW(file->destname) + 2;
     file->dest = realloc(file->dest, size * sizeof(WCHAR));
     if (!file->dest)
@@ -1064,7 +1034,7 @@ static BOOL move_files_wildcard( MSIPACKAGE *package, const WCHAR *source, WCHAR
 
     while (!list_empty(&files.entry))
     {
-        file = LIST_ENTRY(list_head(&files.entry), FILE_LIST, entry);
+        file = LIST_ENTRY(list_head(&files.entry), struct file_list, entry);
 
         move_file( package, file->source, file->dest, options );
 
@@ -1324,7 +1294,7 @@ static UINT ITERATE_DuplicateFiles(MSIRECORD *row, LPVOID param)
     }
 
     TRACE("Duplicating file %s to %s\n", debugstr_w(file->TargetPath), debugstr_w(dest));
-    if (!msi_copy_file( package, file->TargetPath, dest, TRUE ))
+    if (!copy_file( package, file->TargetPath, dest, TRUE ))
     {
         WARN( "failed to copy file %s -> %s (%lu)\n",
               debugstr_w(file->TargetPath), debugstr_w(dest), GetLastError() );
@@ -1580,7 +1550,7 @@ UINT ACTION_RemoveFiles( MSIPACKAGE *package )
         VS_FIXEDFILEINFO *ver;
 
         comp = file->Component;
-        msi_file_update_ui( package, file, L"RemoveFiles" );
+        file_update_ui( package, file, L"RemoveFiles" );
 
         comp->Action = msi_get_component_action( package, comp );
         if (comp->Action != INSTALLSTATE_ABSENT || comp->Installed == INSTALLSTATE_SOURCE)
diff --git a/dlls/msi/font.c b/dlls/msi/font.c
index b4eadbc8968..6a4057f6901 100644
--- a/dlls/msi/font.c
+++ b/dlls/msi/font.c
@@ -28,40 +28,43 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
-typedef struct _tagTT_OFFSET_TABLE {
+struct offset_table
+{
     USHORT uMajorVersion;
     USHORT uMinorVersion;
     USHORT uNumOfTables;
     USHORT uSearchRange;
     USHORT uEntrySelector;
     USHORT uRangeShift;
-} TT_OFFSET_TABLE;
+};
 
-typedef struct _tagTT_TABLE_DIRECTORY {
+struct table_directory
+{
     char szTag[4]; /* table name */
     ULONG uCheckSum; /* Check sum */
     ULONG uOffset; /* Offset from beginning of file */
     ULONG uLength; /* length of the table in bytes */
-} TT_TABLE_DIRECTORY;
+};
 
-typedef struct _tagTT_NAME_TABLE_HEADER {
+struct name_table_header
+{
     USHORT uFSelector; /* format selector. Always 0 */
     USHORT uNRCount; /* Name Records count */
-    USHORT uStorageOffset; /* Offset for strings storage,
-                            * from start of the table */
-} TT_NAME_TABLE_HEADER;
+    USHORT uStorageOffset; /* Offset for strings storage from start of the table */
+};
 
 #define NAME_ID_FULL_FONT_NAME  4
 #define NAME_ID_VERSION         5
 
-typedef struct _tagTT_NAME_RECORD {
+struct name_record
+{
     USHORT uPlatformID;
     USHORT uEncodingID;
     USHORT uLanguageID;
     USHORT uNameID;
     USHORT uStringLength;
     USHORT uStringOffset; /* from start of storage area */
-} TT_NAME_RECORD;
+};
 
 #define SWAPWORD(x) MAKEWORD(HIBYTE(x), LOBYTE(x))
 #define SWAPLONG(x) MAKELONG(SWAPWORD(HIWORD(x)), SWAPWORD(LOWORD(x)))
@@ -72,11 +75,11 @@ typedef struct _tagTT_NAME_RECORD {
  */
 static WCHAR *load_ttf_name_id( MSIPACKAGE *package, const WCHAR *filename, DWORD id )
 {
-    TT_TABLE_DIRECTORY tblDir;
+    struct table_directory tblDir;
     BOOL bFound = FALSE;
-    TT_OFFSET_TABLE ttOffsetTable;
-    TT_NAME_TABLE_HEADER ttNTHeader;
-    TT_NAME_RECORD ttRecord;
+    struct offset_table ttOffsetTable;
+    struct name_table_header ttNTHeader;
+    struct name_record ttRecord;
     DWORD dwRead;
     HANDLE handle;
     LPWSTR ret = NULL;
@@ -92,7 +95,7 @@ static WCHAR *load_ttf_name_id( MSIPACKAGE *package, const WCHAR *filename, DWOR
         return NULL;
     }
 
-    if (!ReadFile(handle,&ttOffsetTable, sizeof(TT_OFFSET_TABLE),&dwRead,NULL))
+    if (!ReadFile(handle,&ttOffsetTable, sizeof(struct offset_table),&dwRead,NULL))
         goto end;
 
     ttOffsetTable.uNumOfTables = SWAPWORD(ttOffsetTable.uNumOfTables);
@@ -105,7 +108,7 @@ static WCHAR *load_ttf_name_id( MSIPACKAGE *package, const WCHAR *filename, DWOR
 
     for (i=0; i< ttOffsetTable.uNumOfTables; i++)
     {
-        if (!ReadFile(handle,&tblDir, sizeof(TT_TABLE_DIRECTORY),&dwRead,NULL))
+        if (!ReadFile(handle, &tblDir, sizeof(tblDir), &dwRead, NULL))
             break;
         if (memcmp(tblDir.szTag,"name",4)==0)
         {
@@ -120,14 +123,14 @@ static WCHAR *load_ttf_name_id( MSIPACKAGE *package, const WCHAR *filename, DWOR
         goto end;
 
     SetFilePointer(handle, tblDir.uOffset, NULL, FILE_BEGIN);
-    if (!ReadFile(handle,&ttNTHeader, sizeof(TT_NAME_TABLE_HEADER), &dwRead,NULL))
+    if (!ReadFile(handle, &ttNTHeader, sizeof(ttNTHeader), &dwRead, NULL))
         goto end;
 
     ttNTHeader.uNRCount = SWAPWORD(ttNTHeader.uNRCount);
     ttNTHeader.uStorageOffset = SWAPWORD(ttNTHeader.uStorageOffset);
     for(i=0; i<ttNTHeader.uNRCount; i++)
     {
-        if (!ReadFile(handle,&ttRecord, sizeof(TT_NAME_RECORD),&dwRead,NULL))
+        if (!ReadFile(handle, &ttRecord, sizeof(ttRecord), &dwRead, NULL))
             break;
 
         ttRecord.uNameID = SWAPWORD(ttRecord.uNameID);
diff --git a/dlls/msi/format.c b/dlls/msi/format.c
index 8802756d88c..1d2d61f787d 100644
--- a/dlls/msi/format.c
+++ b/dlls/msi/format.c
@@ -54,7 +54,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
 #define left_type(x) (x & 0xF0)
 
-typedef struct _tagFORMAT
+struct format
 {
     MSIPACKAGE *package;
     MSIRECORD *record;
@@ -64,9 +64,9 @@ typedef struct _tagFORMAT
     BOOL propfailed;
     BOOL groupfailed;
     int groups;
-} FORMAT;
+};
 
-typedef struct _tagFORMSTR
+struct form_str
 {
     struct list entry;
     int n;
@@ -74,25 +74,25 @@ typedef struct _tagFORMSTR
     int type;
     BOOL propfound;
     BOOL nonprop;
-} FORMSTR;
+};
 
-typedef struct _tagSTACK
+struct stack
 {
     struct list items;
-} STACK;
+};
 
-static STACK *create_stack(void)
+static struct stack *create_stack(void)
 {
-    STACK *stack = malloc(sizeof(STACK));
+    struct stack *stack = malloc(sizeof(*stack));
     list_init(&stack->items);
     return stack;
 }
 
-static void free_stack(STACK *stack)
+static void free_stack(struct stack *stack)
 {
     while (!list_empty(&stack->items))
     {
-        FORMSTR *str = LIST_ENTRY(list_head(&stack->items), FORMSTR, entry);
+        struct form_str *str = LIST_ENTRY(list_head(&stack->items), struct form_str, entry);
         list_remove(&str->entry);
         free(str);
     }
@@ -100,28 +100,28 @@ static void free_stack(STACK *stack)
     free(stack);
 }
 
-static void stack_push(STACK *stack, FORMSTR *str)
+static void stack_push(struct stack *stack, struct form_str *str)
 {
     list_add_head(&stack->items, &str->entry);
 }
 
-static FORMSTR *stack_pop(STACK *stack)
+static struct form_str *stack_pop(struct stack *stack)
 {
-    FORMSTR *ret;
+    struct form_str *ret;
 
     if (list_empty(&stack->items))
         return NULL;
 
-    ret = LIST_ENTRY(list_head(&stack->items), FORMSTR, entry);
+    ret = LIST_ENTRY(list_head(&stack->items), struct form_str, entry);
     list_remove(&ret->entry);
     return ret;
 }
 
-static FORMSTR *stack_find(STACK *stack, int type)
+static struct form_str *stack_find(struct stack *stack, int type)
 {
-    FORMSTR *str;
+    struct form_str *str;
 
-    LIST_FOR_EACH_ENTRY(str, &stack->items, FORMSTR, entry)
+    LIST_FOR_EACH_ENTRY(str, &stack->items, struct form_str, entry)
     {
         if (str->type == type)
             return str;
@@ -130,17 +130,17 @@ static FORMSTR *stack_find(STACK *stack, int type)
     return NULL;
 }
 
-static FORMSTR *stack_peek(STACK *stack)
+static struct form_str *stack_peek(struct stack *stack)
 {
-    return LIST_ENTRY(list_head(&stack->items), FORMSTR, entry);
+    return LIST_ENTRY(list_head(&stack->items), struct form_str, entry);
 }
 
-static LPCWSTR get_formstr_data(FORMAT *format, FORMSTR *str)
+static const WCHAR *get_formstr_data(struct format *format, struct form_str *str)
 {
     return &format->deformatted[str->n];
 }
 
-static WCHAR *dup_formstr( FORMAT *format, FORMSTR *str, int *ret_len )
+static WCHAR *dup_formstr( struct format *format, struct form_str *str, int *ret_len )
 {
     WCHAR *val;
 
@@ -154,7 +154,7 @@ static WCHAR *dup_formstr( FORMAT *format, FORMSTR *str, int *ret_len )
     return val;
 }
 
-static WCHAR *deformat_index( FORMAT *format, FORMSTR *str, int *ret_len )
+static WCHAR *deformat_index( struct format *format, struct form_str *str, int *ret_len )
 {
     WCHAR *val, *ret;
     DWORD len;
@@ -180,7 +180,7 @@ static WCHAR *deformat_index( FORMAT *format, FORMSTR *str, int *ret_len )
     return ret;
 }
 
-static WCHAR *deformat_property( FORMAT *format, FORMSTR *str, int *ret_len )
+static WCHAR *deformat_property( struct format *format, struct form_str *str, int *ret_len )
 {
     WCHAR *prop, *ret;
     DWORD len = 0;
@@ -203,7 +203,7 @@ static WCHAR *deformat_property( FORMAT *format, FORMSTR *str, int *ret_len )
     return ret;
 }
 
-static WCHAR *deformat_component( FORMAT *format, FORMSTR *str, int *ret_len )
+static WCHAR *deformat_component( struct format *format, struct form_str *str, int *ret_len )
 {
     WCHAR *key, *ret;
     MSICOMPONENT *comp;
@@ -227,7 +227,7 @@ static WCHAR *deformat_component( FORMAT *format, FORMSTR *str, int *ret_len )
     return ret;
 }
 
-static WCHAR *deformat_file( FORMAT *format, FORMSTR *str, BOOL shortname, int *ret_len )
+static WCHAR *deformat_file( struct format *format, struct form_str *str, BOOL shortname, int *ret_len )
 {
     WCHAR *key, *ret = NULL;
     const MSIFILE *file;
@@ -257,7 +257,7 @@ done:
     return ret;
 }
 
-static WCHAR *deformat_environment( FORMAT *format, FORMSTR *str, int *ret_len )
+static WCHAR *deformat_environment( struct format *format, struct form_str *str, int *ret_len )
 {
     WCHAR *key, *ret = NULL;
     DWORD len;
@@ -275,7 +275,7 @@ static WCHAR *deformat_environment( FORMAT *format, FORMSTR *str, int *ret_len )
     return ret;
 }
 
-static WCHAR *deformat_literal( FORMAT *format, FORMSTR *str, BOOL *propfound,
+static WCHAR *deformat_literal( struct format *format, struct form_str *str, BOOL *propfound,
                                 int *type, int *len )
 {
     LPCWSTR data = get_formstr_data(format, str);
@@ -389,10 +389,10 @@ static BOOL format_is_literal(WCHAR x)
     return (format_is_alpha(x) || format_is_number(x));
 }
 
-static int format_lex(FORMAT *format, FORMSTR **out)
+static int format_lex(struct format *format, struct form_str **out)
 {
     int type, len = 1;
-    FORMSTR *str;
+    struct form_str *str;
     LPCWSTR data;
     WCHAR ch;
 
@@ -401,7 +401,7 @@ static int format_lex(FORMAT *format, FORMSTR **out)
     if (!format->deformatted)
         return FORMAT_NULL;
 
-    *out = calloc(1, sizeof(FORMSTR));
+    *out = calloc(1, sizeof(**out));
     if (!*out)
         return FORMAT_FAIL;
 
@@ -473,10 +473,10 @@ static int format_lex(FORMAT *format, FORMSTR **out)
     return type;
 }
 
-static FORMSTR *format_replace( FORMAT *format, BOOL propfound, BOOL nonprop,
-                                int oldsize, int type, WCHAR *replace, int len )
+static struct form_str *format_replace( struct format *format, BOOL propfound, BOOL nonprop,
+                                        int oldsize, int type, WCHAR *replace, int len )
 {
-    FORMSTR *ret;
+    struct form_str *ret;
     LPWSTR str, ptr;
     DWORD size = 0;
     int n;
@@ -533,7 +533,7 @@ static FORMSTR *format_replace( FORMAT *format, BOOL propfound, BOOL nonprop,
     if (!replace)
         return NULL;
 
-    ret = calloc(1, sizeof(FORMSTR));
+    ret = calloc(1, sizeof(*ret));
     if (!ret)
         return NULL;
 
@@ -546,12 +546,12 @@ static FORMSTR *format_replace( FORMAT *format, BOOL propfound, BOOL nonprop,
     return ret;
 }
 
-static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
+static WCHAR *replace_stack_group( struct format *format, struct stack *values,
                                    BOOL *propfound, BOOL *nonprop,
                                    int *oldsize, int *type, int *len )
 {
     WCHAR *replaced;
-    FORMSTR *content, *node;
+    struct form_str *content, *node;
     int n;
 
     *nonprop = FALSE;
@@ -575,7 +575,7 @@ static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
         free(node);
     }
 
-    content = calloc(1, sizeof(FORMSTR));
+    content = calloc(1, sizeof(*content));
     content->n = n;
     content->len = *oldsize;
     content->type = FORMAT_LITERAL;
@@ -616,12 +616,12 @@ static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
     return replaced;
 }
 
-static WCHAR *replace_stack_prop( FORMAT *format, STACK *values,
+static WCHAR *replace_stack_prop( struct format *format, struct stack *values,
                                   BOOL *propfound, BOOL *nonprop,
                                   int *oldsize, int *type, int *len )
 {
     WCHAR *replaced;
-    FORMSTR *content, *node;
+    struct form_str *content, *node;
     int n;
 
     *propfound = FALSE;
@@ -644,7 +644,7 @@ static WCHAR *replace_stack_prop( FORMAT *format, STACK *values,
         free(node);
     }
 
-    content = calloc(1, sizeof(FORMSTR));
+    content = calloc(1, sizeof(*content));
     content->n = n + 1;
     content->len = *oldsize - 2;
     content->type = *type;
@@ -676,10 +676,10 @@ static WCHAR *replace_stack_prop( FORMAT *format, STACK *values,
     return replaced;
 }
 
-static UINT replace_stack(FORMAT *format, STACK *stack, STACK *values)
+static UINT replace_stack(struct format *format, struct stack *stack, struct stack *values)
 {
     WCHAR *replaced = NULL;
-    FORMSTR *beg, *top, *node;
+    struct form_str *beg, *top, *node;
     BOOL propfound = FALSE, nonprop = FALSE, group = FALSE;
     int type, n, len = 0, oldsize = 0;
 
@@ -757,10 +757,10 @@ static DWORD deformat_string_internal(MSIPACKAGE *package, LPCWSTR ptr,
                                       WCHAR** data, DWORD *len,
                                       MSIRECORD* record)
 {
-    FORMAT format;
-    FORMSTR *str = NULL;
-    STACK *stack, *temp;
-    FORMSTR *node;
+    struct format format;
+    struct form_str *str = NULL;
+    struct stack *stack, *temp;
+    struct form_str *node;
     int type;
 
     if (!ptr)
@@ -773,7 +773,7 @@ static DWORD deformat_string_internal(MSIPACKAGE *package, LPCWSTR ptr,
     *data = wcsdup(ptr);
     *len = lstrlenW(ptr);
 
-    ZeroMemory(&format, sizeof(FORMAT));
+    ZeroMemory(&format, sizeof(format));
     format.package = package;
     format.record = record;
     format.deformatted = *data;
diff --git a/dlls/msi/handle.c b/dlls/msi/handle.c
index 6ebe1796d3a..4093878431c 100644
--- a/dlls/msi/handle.c
+++ b/dlls/msi/handle.c
@@ -35,27 +35,27 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
-static CRITICAL_SECTION MSI_handle_cs;
-static CRITICAL_SECTION_DEBUG MSI_handle_cs_debug =
+static CRITICAL_SECTION handle_cs;
+static CRITICAL_SECTION_DEBUG handle_cs_debug =
 {
-    0, 0, &MSI_handle_cs,
-    { &MSI_handle_cs_debug.ProcessLocksList, 
-      &MSI_handle_cs_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": MSI_handle_cs") }
+    0, 0, &handle_cs,
+    { &handle_cs_debug.ProcessLocksList,
+      &handle_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": handle_cs") }
 };
-static CRITICAL_SECTION MSI_handle_cs = { &MSI_handle_cs_debug, -1, 0, 0, 0, 0 };
+static CRITICAL_SECTION handle_cs = { &handle_cs_debug, -1, 0, 0, 0, 0 };
 
-static CRITICAL_SECTION MSI_object_cs;
-static CRITICAL_SECTION_DEBUG MSI_object_cs_debug =
+static CRITICAL_SECTION object_cs;
+static CRITICAL_SECTION_DEBUG object_cs_debug =
 {
-    0, 0, &MSI_object_cs,
-    { &MSI_object_cs_debug.ProcessLocksList, 
-      &MSI_object_cs_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": MSI_object_cs") }
+    0, 0, &object_cs,
+    { &object_cs_debug.ProcessLocksList,
+      &object_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": object_cs") }
 };
-static CRITICAL_SECTION MSI_object_cs = { &MSI_object_cs_debug, -1, 0, 0, 0, 0 };
+static CRITICAL_SECTION object_cs = { &object_cs_debug, -1, 0, 0, 0, 0 };
 
-typedef struct msi_handle_info_t
+struct handle_info
 {
     BOOL remote;
     union {
@@ -63,18 +63,18 @@ typedef struct msi_handle_info_t
         MSIHANDLE rem;
     } u;
     DWORD dwThreadId;
-} msi_handle_info;
+};
 
-static msi_handle_info *msihandletable = NULL;
-static unsigned int msihandletable_size = 0;
+static struct handle_info *handle_table = NULL;
+static unsigned int handle_table_size = 0;
 
 void msi_free_handle_table(void)
 {
-    free( msihandletable );
-    msihandletable = NULL;
-    msihandletable_size = 0;
-    DeleteCriticalSection(&MSI_handle_cs);
-    DeleteCriticalSection(&MSI_object_cs);
+    free( handle_table );
+    handle_table = NULL;
+    handle_table_size = 0;
+    DeleteCriticalSection(&handle_cs);
+    DeleteCriticalSection(&object_cs);
 }
 
 static MSIHANDLE alloc_handle_table_entry(void)
@@ -82,50 +82,50 @@ static MSIHANDLE alloc_handle_table_entry(void)
     UINT i;
 
     /* find a slot */
-    for(i=0; i<msihandletable_size; i++)
-        if( !msihandletable[i].u.obj && !msihandletable[i].u.rem )
+    for(i = 0; i < handle_table_size; i++)
+        if (!handle_table[i].u.obj && !handle_table[i].u.rem)
             break;
-    if( i==msihandletable_size )
+    if (i == handle_table_size)
     {
-        msi_handle_info *p;
+        struct handle_info *p;
         int newsize;
-        if (msihandletable_size == 0)
+        if (!handle_table_size)
         {
             newsize = 256;
             p = calloc(newsize, sizeof(*p));
         }
         else
         {
-            newsize = msihandletable_size * 2;
-            p = realloc(msihandletable, newsize * sizeof(*p));
-            if (p) memset(p + msihandletable_size, 0, (newsize - msihandletable_size) * sizeof(*p));
+            newsize = handle_table_size * 2;
+            p = realloc(handle_table, newsize * sizeof(*p));
+            if (p) memset(p + handle_table_size, 0, (newsize - handle_table_size) * sizeof(*p));
         }
         if (!p)
             return 0;
-        msihandletable = p;
-        msihandletable_size = newsize;
+        handle_table = p;
+        handle_table_size = newsize;
     }
     return i + 1;
 }
 
 MSIHANDLE alloc_msihandle( MSIOBJECTHDR *obj )
 {
-    msi_handle_info *entry;
+    struct handle_info *entry;
     MSIHANDLE ret;
 
-    EnterCriticalSection( &MSI_handle_cs );
+    EnterCriticalSection( &handle_cs );
 
     ret = alloc_handle_table_entry();
     if (ret)
     {
-        entry = &msihandletable[ ret - 1 ];
+        entry = &handle_table[ ret - 1 ];
         msiobj_addref( obj );
         entry->u.obj = obj;
         entry->dwThreadId = GetCurrentThreadId();
         entry->remote = FALSE;
     }
 
-    LeaveCriticalSection( &MSI_handle_cs );
+    LeaveCriticalSection( &handle_cs );
 
     TRACE( "%p -> %lu\n", obj, ret );
 
@@ -134,21 +134,21 @@ MSIHANDLE alloc_msihandle( MSIOBJECTHDR *obj )
 
 MSIHANDLE alloc_msi_remote_handle(MSIHANDLE remote)
 {
-    msi_handle_info *entry;
+    struct handle_info *entry;
     MSIHANDLE ret;
 
-    EnterCriticalSection( &MSI_handle_cs );
+    EnterCriticalSection( &handle_cs );
 
     ret = alloc_handle_table_entry();
     if (ret)
     {
-        entry = &msihandletable[ ret - 1 ];
+        entry = &handle_table[ ret - 1 ];
         entry->u.rem = remote;
         entry->dwThreadId = GetCurrentThreadId();
         entry->remote = TRUE;
     }
 
-    LeaveCriticalSection( &MSI_handle_cs );
+    LeaveCriticalSection( &handle_cs );
 
     TRACE( "%lu -> %lu\n", remote, ret );
 
@@ -159,23 +159,23 @@ void *msihandle2msiinfo(MSIHANDLE handle, UINT type)
 {
     MSIOBJECTHDR *ret = NULL;
 
-    EnterCriticalSection( &MSI_handle_cs );
+    EnterCriticalSection( &handle_cs );
     handle--;
-    if( handle >= msihandletable_size )
+    if (handle >= handle_table_size)
         goto out;
-    if( msihandletable[handle].remote)
+    if (handle_table[handle].remote)
         goto out;
-    if( !msihandletable[handle].u.obj )
+    if (!handle_table[handle].u.obj)
         goto out;
-    if( msihandletable[handle].u.obj->magic != MSIHANDLE_MAGIC )
+    if (handle_table[handle].u.obj->magic != MSIHANDLE_MAGIC)
         goto out;
-    if( type && (msihandletable[handle].u.obj->type != type) )
+    if (type && (handle_table[handle].u.obj->type != type))
         goto out;
-    ret = msihandletable[handle].u.obj;
+    ret = handle_table[handle].u.obj;
     msiobj_addref( ret );
 
 out:
-    LeaveCriticalSection( &MSI_handle_cs );
+    LeaveCriticalSection( &handle_cs );
 
     return ret;
 }
@@ -184,16 +184,16 @@ MSIHANDLE msi_get_remote( MSIHANDLE handle )
 {
     MSIHANDLE ret = 0;
 
-    EnterCriticalSection( &MSI_handle_cs );
+    EnterCriticalSection( &handle_cs );
     handle--;
-    if( handle>=msihandletable_size )
+    if (handle >= handle_table_size)
         goto out;
-    if( !msihandletable[handle].remote)
+    if (!handle_table[handle].remote)
         goto out;
-    ret = msihandletable[handle].u.rem;
+    ret = handle_table[handle].u.rem;
 
 out:
-    LeaveCriticalSection( &MSI_handle_cs );
+    LeaveCriticalSection( &handle_cs );
 
     return ret;
 }
@@ -230,12 +230,12 @@ void msiobj_addref( MSIOBJECTHDR *info )
 
 void msiobj_lock( MSIOBJECTHDR *info )
 {
-    EnterCriticalSection( &MSI_object_cs );
+    EnterCriticalSection( &object_cs );
 }
 
 void msiobj_unlock( MSIOBJECTHDR *info )
 {
-    LeaveCriticalSection( &MSI_object_cs );
+    LeaveCriticalSection( &object_cs );
 }
 
 int msiobj_release( MSIOBJECTHDR *info )
@@ -276,19 +276,19 @@ UINT WINAPI MsiCloseHandle(MSIHANDLE handle)
     if (!handle)
         return ERROR_SUCCESS;
 
-    EnterCriticalSection( &MSI_handle_cs );
+    EnterCriticalSection( &handle_cs );
 
     handle--;
-    if (handle >= msihandletable_size)
+    if (handle >= handle_table_size)
         goto out;
 
-    if (msihandletable[handle].remote)
+    if (handle_table[handle].remote)
     {
-        remote_CloseHandle( msihandletable[handle].u.rem );
+        remote_CloseHandle( handle_table[handle].u.rem );
     }
     else
     {
-        info = msihandletable[handle].u.obj;
+        info = handle_table[handle].u.obj;
         if( !info )
             goto out;
 
@@ -299,15 +299,15 @@ UINT WINAPI MsiCloseHandle(MSIHANDLE handle)
         }
     }
 
-    msihandletable[handle].u.obj = NULL;
-    msihandletable[handle].remote = 0;
-    msihandletable[handle].dwThreadId = 0;
+    handle_table[handle].u.obj = NULL;
+    handle_table[handle].remote = 0;
+    handle_table[handle].dwThreadId = 0;
 
     ret = ERROR_SUCCESS;
 
     TRACE( "handle %lu destroyed\n", handle + 1 );
 out:
-    LeaveCriticalSection( &MSI_handle_cs );
+    LeaveCriticalSection( &handle_cs );
     if( info )
         msiobj_release( info );
 
@@ -328,18 +328,18 @@ UINT WINAPI MsiCloseAllHandles(void)
 
     TRACE("\n");
 
-    EnterCriticalSection( &MSI_handle_cs );
-    for(i=0; i<msihandletable_size; i++)
+    EnterCriticalSection( &handle_cs );
+    for (i = 0; i < handle_table_size; i++)
     {
-        if(msihandletable[i].dwThreadId == GetCurrentThreadId())
+        if (handle_table[i].dwThreadId == GetCurrentThreadId())
         {
-            LeaveCriticalSection( &MSI_handle_cs );
-            MsiCloseHandle( i+1 );
-            EnterCriticalSection( &MSI_handle_cs );
+            LeaveCriticalSection( &handle_cs );
+            MsiCloseHandle( i + 1 );
+            EnterCriticalSection( &handle_cs );
             n++;
         }
     }
-    LeaveCriticalSection( &MSI_handle_cs );
+    LeaveCriticalSection( &handle_cs );
 
     return n;
 }
diff --git a/dlls/msi/insert.c b/dlls/msi/insert.c
index 1859b31438f..ffa870e08ac 100644
--- a/dlls/msi/insert.c
+++ b/dlls/msi/insert.c
@@ -38,7 +38,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 /* below is the query interface to a table */
 
-typedef struct tagMSIINSERTVIEW
+struct insert_view
 {
     MSIVIEW          view;
     MSIVIEW         *table;
@@ -46,11 +46,11 @@ typedef struct tagMSIINSERTVIEW
     BOOL             bIsTemp;
     MSIVIEW         *sv;
     column_info     *vals;
-} MSIINSERTVIEW;
+};
 
 static UINT INSERT_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
 
     TRACE("%p %d %d %p\n", iv, row, col, val );
 
@@ -106,7 +106,7 @@ err:
 /* checks to see if the column order specified in the INSERT query
  * matches the column order of the table
  */
-static BOOL msi_columns_in_order(MSIINSERTVIEW *iv, UINT col_count)
+static BOOL columns_in_order(struct insert_view *iv, UINT col_count)
 {
     LPCWSTR a, b;
     UINT i;
@@ -124,7 +124,7 @@ static BOOL msi_columns_in_order(MSIINSERTVIEW *iv, UINT col_count)
 /* rearranges the data in the record to be inserted based on column order,
  * and pads the record for any missing columns in the INSERT query
  */
-static UINT msi_arrange_record(MSIINSERTVIEW *iv, MSIRECORD **values)
+static UINT arrange_record(struct insert_view *iv, MSIRECORD **values)
 {
     MSIRECORD *padded;
     UINT col_count, val_count;
@@ -140,7 +140,7 @@ static UINT msi_arrange_record(MSIINSERTVIEW *iv, MSIRECORD **values)
     /* check to see if the columns are arranged already
      * to avoid unnecessary copying
      */
-    if (col_count == val_count && msi_columns_in_order(iv, col_count))
+    if (col_count == val_count && columns_in_order(iv, col_count))
         return ERROR_SUCCESS;
 
     padded = MSI_CreateRecord(col_count);
@@ -176,7 +176,7 @@ err:
     return r;
 }
 
-static BOOL row_has_null_primary_keys(MSIINSERTVIEW *iv, MSIRECORD *row)
+static BOOL row_has_null_primary_keys(struct insert_view *iv, MSIRECORD *row)
 {
     UINT r, i, col_count, type;
 
@@ -203,7 +203,7 @@ static BOOL row_has_null_primary_keys(MSIINSERTVIEW *iv, MSIRECORD *row)
 
 static UINT INSERT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
     UINT r, row = -1, col_count = 0;
     MSIVIEW *sv;
     MSIRECORD *values = NULL;
@@ -231,7 +231,7 @@ static UINT INSERT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
     if( !values )
         goto err;
 
-    r = msi_arrange_record( iv, &values );
+    r = arrange_record( iv, &values );
     if( r != ERROR_SUCCESS )
         goto err;
 
@@ -251,7 +251,7 @@ err:
 
 static UINT INSERT_close( struct tagMSIVIEW *view )
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
     MSIVIEW *sv;
 
     TRACE("%p\n", iv);
@@ -265,7 +265,7 @@ static UINT INSERT_close( struct tagMSIVIEW *view )
 
 static UINT INSERT_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
     MSIVIEW *sv;
 
     TRACE("%p %p %p\n", iv, rows, cols );
@@ -280,7 +280,7 @@ static UINT INSERT_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *co
 static UINT INSERT_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                     UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
     MSIVIEW *sv;
 
     TRACE("%p %d %p %p %p %p\n", iv, n, name, type, temporary, table_name );
@@ -294,7 +294,7 @@ static UINT INSERT_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *na
 
 static UINT INSERT_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode, MSIRECORD *rec, UINT row)
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
 
     TRACE("%p %d %p\n", iv, eModifyMode, rec );
 
@@ -303,7 +303,7 @@ static UINT INSERT_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode, MSIRE
 
 static UINT INSERT_delete( struct tagMSIVIEW *view )
 {
-    MSIINSERTVIEW *iv = (MSIINSERTVIEW*)view;
+    struct insert_view *iv = (struct insert_view *)view;
     MSIVIEW *sv;
 
     TRACE("%p\n", iv );
@@ -351,7 +351,7 @@ static UINT count_column_info( const column_info *ci )
 UINT INSERT_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR table,
                         column_info *columns, column_info *values, BOOL temp )
 {
-    MSIINSERTVIEW *iv = NULL;
+    struct insert_view *iv = NULL;
     UINT r;
     MSIVIEW *tv = NULL, *sv = NULL;
 
diff --git a/dlls/msi/media.c b/dlls/msi/media.c
index 97c59b4e543..513e04b1b7e 100644
--- a/dlls/msi/media.c
+++ b/dlls/msi/media.c
@@ -60,7 +60,7 @@ static BOOL source_matches_volume(MSIMEDIAINFO *mi, LPCWSTR source_root)
     return !wcsicmp( mi->volume_label, p );
 }
 
-static UINT msi_change_media(MSIPACKAGE *package, MSIMEDIAINFO *mi)
+static UINT change_media(MSIPACKAGE *package, MSIMEDIAINFO *mi)
 {
     MSIRECORD *record;
     LPWSTR source_dir;
@@ -83,7 +83,7 @@ static UINT msi_change_media(MSIPACKAGE *package, MSIMEDIAINFO *mi)
     return r == IDRETRY ? ERROR_SUCCESS : ERROR_INSTALL_SOURCE_ABSENT;
 }
 
-static MSICABINETSTREAM *msi_get_cabinet_stream( MSIPACKAGE *package, UINT disk_id )
+static MSICABINETSTREAM *get_cabinet_stream( MSIPACKAGE *package, UINT disk_id )
 {
     MSICABINETSTREAM *cab;
 
@@ -183,7 +183,7 @@ static INT_PTR CDECL cabinet_open_stream( char *pszFile, int oflag, int pmode )
     MSICABINETSTREAM *cab;
     IStream *stream;
 
-    if (!(cab = msi_get_cabinet_stream( package_disk.package, package_disk.id )))
+    if (!(cab = get_cabinet_stream( package_disk.package, package_disk.id )))
     {
         WARN("failed to get cabinet stream\n");
         return -1;
@@ -255,7 +255,7 @@ static LONG CDECL cabinet_seek_stream( INT_PTR hf, LONG dist, int seektype )
     return -1;
 }
 
-static UINT msi_media_get_disk_info(MSIPACKAGE *package, MSIMEDIAINFO *mi)
+static UINT media_get_disk_info(MSIPACKAGE *package, MSIMEDIAINFO *mi)
 {
     MSIRECORD *row;
 
@@ -313,7 +313,7 @@ static INT_PTR cabinet_next_cabinet(FDINOTIFICATIONTYPE fdint,
     mi->disk_id++;
     mi->is_continuous = TRUE;
 
-    rc = msi_media_get_disk_info(data->package, mi);
+    rc = media_get_disk_info(data->package, mi);
     if (rc != ERROR_SUCCESS)
     {
         ERR("Failed to get next cabinet information: %d\n", rc);
@@ -355,7 +355,7 @@ static INT_PTR cabinet_next_cabinet(FDINOTIFICATIONTYPE fdint,
     res = 0;
     if (GetFileAttributesW(cabinet_file) == INVALID_FILE_ATTRIBUTES)
     {
-        if (msi_change_media(data->package, mi) != ERROR_SUCCESS)
+        if (change_media(data->package, mi) != ERROR_SUCCESS)
             res = -1;
     }
 
@@ -382,7 +382,7 @@ static INT_PTR cabinet_next_cabinet_stream( FDINOTIFICATIONTYPE fdint,
     mi->disk_id++;
     mi->is_continuous = TRUE;
 
-    rc = msi_media_get_disk_info( data->package, mi );
+    rc = media_get_disk_info( data->package, mi );
     if (rc != ERROR_SUCCESS)
     {
         ERR("Failed to get next cabinet information: %u\n", rc);
@@ -889,7 +889,7 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
 
             if (!match && (mi->type == DRIVE_CDROM || mi->type == DRIVE_REMOVABLE))
             {
-                if ((rc = msi_change_media( package, mi )) != ERROR_SUCCESS)
+                if ((rc = change_media( package, mi )) != ERROR_SUCCESS)
                 {
                     free( cabinet_file );
                     return rc;
diff --git a/dlls/msi/msi.c b/dlls/msi/msi.c
index 3ebfd94a9f0..42f2122bed8 100644
--- a/dlls/msi/msi.c
+++ b/dlls/msi/msi.c
@@ -1365,7 +1365,7 @@ done:
     return r;
 }
 
-static UINT msi_copy_outval(LPWSTR val, LPWSTR out, LPDWORD size)
+static UINT copy_outval(const WCHAR *val, WCHAR *out, DWORD *size)
 {
     UINT r = ERROR_SUCCESS;
 
@@ -1490,7 +1490,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
         if (!val)
             val = wcsdup(L"");
 
-        r = msi_copy_outval(val, szValue, pcchValue);
+        r = copy_outval(val, szValue, pcchValue);
     }
     else if (!wcscmp( szProperty, INSTALLPROPERTY_TRANSFORMSW ) ||
              !wcscmp( szProperty, INSTALLPROPERTY_LANGUAGEW ) ||
@@ -1515,7 +1515,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
         if (!val)
             val = wcsdup(L"");
 
-        r = msi_copy_outval(val, szValue, pcchValue);
+        r = copy_outval(val, szValue, pcchValue);
     }
     else if (!wcscmp( szProperty, INSTALLPROPERTY_PRODUCTSTATEW ))
     {
@@ -1533,14 +1533,14 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
             else
                 val = wcsdup(L"1");
 
-            r = msi_copy_outval(val, szValue, pcchValue);
+            r = copy_outval(val, szValue, pcchValue);
             goto done;
         }
         else if (props && (val = reg_get_value(props, package, &type)))
         {
             free(val);
             val = wcsdup(L"5");
-            r = msi_copy_outval(val, szValue, pcchValue);
+            r = copy_outval(val, szValue, pcchValue);
             goto done;
         }
 
@@ -1549,7 +1549,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
         else
             goto done;
 
-        r = msi_copy_outval(val, szValue, pcchValue);
+        r = copy_outval(val, szValue, pcchValue);
     }
     else if (!wcscmp( szProperty, INSTALLPROPERTY_ASSIGNMENTTYPEW ))
     {
@@ -1558,7 +1558,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
 
         /* FIXME */
         val = wcsdup(L"");
-        r = msi_copy_outval(val, szValue, pcchValue);
+        r = copy_outval(val, szValue, pcchValue);
     }
     else
         r = ERROR_UNKNOWN_PROPERTY;
@@ -2082,7 +2082,7 @@ UINT WINAPI MsiQueryComponentStateA(LPCSTR szProductCode,
     return r;
 }
 
-static BOOL msi_comp_find_prod_key(LPCWSTR prodcode, MSIINSTALLCONTEXT context)
+static BOOL comp_find_prod_key(const WCHAR *prodcode, MSIINSTALLCONTEXT context)
 {
     UINT r;
     HKEY hkey = NULL;
@@ -2092,7 +2092,7 @@ static BOOL msi_comp_find_prod_key(LPCWSTR prodcode, MSIINSTALLCONTEXT context)
     return (r == ERROR_SUCCESS);
 }
 
-static BOOL msi_comp_find_package(LPCWSTR prodcode, MSIINSTALLCONTEXT context)
+static BOOL comp_find_package(const WCHAR *prodcode, MSIINSTALLCONTEXT context)
 {
     LPCWSTR package;
     HKEY hkey;
@@ -2116,9 +2116,8 @@ static BOOL msi_comp_find_package(LPCWSTR prodcode, MSIINSTALLCONTEXT context)
     return (res == ERROR_SUCCESS);
 }
 
-static UINT msi_comp_find_prodcode(WCHAR *squashed_pc,
-                                   MSIINSTALLCONTEXT context,
-                                   LPCWSTR comp, LPWSTR val, DWORD *sz)
+static UINT comp_find_prodcode(const WCHAR *squashed_pc, MSIINSTALLCONTEXT context, const WCHAR *comp, WCHAR *val,
+                               DWORD *sz)
 {
     HKEY hkey;
     LONG res;
@@ -2160,9 +2159,9 @@ UINT WINAPI MsiQueryComponentStateW(LPCWSTR szProductCode,
     if (!squash_guid( szProductCode, squashed_pc ))
         return ERROR_INVALID_PARAMETER;
 
-    found = msi_comp_find_prod_key(szProductCode, dwContext);
+    found = comp_find_prod_key(szProductCode, dwContext);
 
-    if (!msi_comp_find_package(szProductCode, dwContext))
+    if (!comp_find_package(szProductCode, dwContext))
     {
         if (found)
         {
@@ -2176,7 +2175,7 @@ UINT WINAPI MsiQueryComponentStateW(LPCWSTR szProductCode,
     *pdwState = INSTALLSTATE_UNKNOWN;
 
     sz = 0;
-    if (msi_comp_find_prodcode( squashed_pc, dwContext, szComponent, NULL, &sz ))
+    if (comp_find_prodcode( squashed_pc, dwContext, szComponent, NULL, &sz ))
         return ERROR_UNKNOWN_COMPONENT;
 
     if (sz == 0)
@@ -2187,7 +2186,7 @@ UINT WINAPI MsiQueryComponentStateW(LPCWSTR szProductCode,
         UINT r;
 
         if (!(val = malloc( sz ))) return ERROR_OUTOFMEMORY;
-        if ((r = msi_comp_find_prodcode( squashed_pc, dwContext, szComponent, val, &sz )))
+        if ((r = comp_find_prodcode( squashed_pc, dwContext, szComponent, val, &sz )))
         {
             free(val);
             return r;
@@ -4006,17 +4005,17 @@ UINT WINAPI MsiReinstallFeatureA( const char *szProduct, const char *szFeature,
     return rc;
 }
 
-typedef struct
+struct md5_ctx
 {
     unsigned int i[2];
     unsigned int buf[4];
     unsigned char in[64];
     unsigned char digest[16];
-} MD5_CTX;
+};
 
-extern VOID WINAPI MD5Init( MD5_CTX *);
-extern VOID WINAPI MD5Update( MD5_CTX *, const unsigned char *, unsigned int );
-extern VOID WINAPI MD5Final( MD5_CTX *);
+extern void WINAPI MD5Init( struct md5_ctx * );
+extern void WINAPI MD5Update( struct md5_ctx *, const unsigned char *, unsigned int );
+extern void WINAPI MD5Final( struct md5_ctx * );
 
 UINT msi_get_filehash( MSIPACKAGE *package, const WCHAR *path, MSIFILEHASHINFO *hash )
 {
@@ -4040,7 +4039,7 @@ UINT msi_get_filehash( MSIPACKAGE *package, const WCHAR *path, MSIFILEHASHINFO *
         {
             if ((p = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, length )))
             {
-                MD5_CTX ctx;
+                struct md5_ctx ctx;
 
                 MD5Init( &ctx );
                 MD5Update( &ctx, p, length );
diff --git a/dlls/msi/msi_main.c b/dlls/msi/msi_main.c
index 258489c4ef1..a2b6b6a0503 100644
--- a/dlls/msi/msi_main.c
+++ b/dlls/msi/msi_main.c
@@ -87,20 +87,21 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
     return TRUE;
 }
 
-typedef struct tagIClassFactoryImpl {
+struct class_factory
+{
     IClassFactory IClassFactory_iface;
-    HRESULT (*create_object)( IUnknown*, LPVOID* );
-} IClassFactoryImpl;
+    HRESULT (*create_object)( IUnknown *, void ** );
+};
 
-static inline IClassFactoryImpl *impl_from_IClassFactory(IClassFactory *iface)
+static inline struct class_factory *impl_from_IClassFactory(IClassFactory *iface)
 {
-    return CONTAINING_RECORD(iface, IClassFactoryImpl, IClassFactory_iface);
+    return CONTAINING_RECORD(iface, struct class_factory, IClassFactory_iface);
 }
 
 static HRESULT WINAPI MsiCF_QueryInterface(LPCLASSFACTORY iface,
                 REFIID riid,LPVOID *ppobj)
 {
-    IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+    struct class_factory *This = impl_from_IClassFactory(iface);
 
     TRACE("%p %s %p\n",This,debugstr_guid(riid),ppobj);
 
@@ -129,7 +130,7 @@ static ULONG WINAPI MsiCF_Release(LPCLASSFACTORY iface)
 static HRESULT WINAPI MsiCF_CreateInstance(LPCLASSFACTORY iface,
     LPUNKNOWN pOuter, REFIID riid, LPVOID *ppobj)
 {
-    IClassFactoryImpl *This = impl_from_IClassFactory(iface);
+    struct class_factory *This = impl_from_IClassFactory(iface);
     IUnknown *unk = NULL;
     HRESULT r;
 
@@ -165,7 +166,7 @@ static const IClassFactoryVtbl MsiCF_Vtbl =
     MsiCF_LockServer
 };
 
-static IClassFactoryImpl MsiServer_CF = { { &MsiCF_Vtbl }, create_msiserver };
+static struct class_factory MsiServer_CF = { { &MsiCF_Vtbl }, create_msiserver };
 
 /******************************************************************
  * DllGetClassObject          [MSI.@]
diff --git a/dlls/msi/msipriv.h b/dlls/msi/msipriv.h
index 1db770481ef..3a67fddc9c7 100644
--- a/dlls/msi/msipriv.h
+++ b/dlls/msi/msipriv.h
@@ -515,7 +515,6 @@ typedef struct tagMSIASSEMBLY
     DWORD attributes;
     LPWSTR display_name;
     LPWSTR tempdir;
-    BOOL installed;
     BOOL clr_version[CLR_VERSION_MAX];
 } MSIASSEMBLY;
 
@@ -784,7 +783,7 @@ extern string_table *msi_load_string_table( IStorage *stg, UINT *bytes_per_strre
 extern UINT msi_save_string_table( const string_table *st, IStorage *storage, UINT *bytes_per_strref ) DECLSPEC_HIDDEN;
 extern UINT msi_get_string_table_codepage( const string_table *st ) DECLSPEC_HIDDEN;
 extern UINT msi_set_string_table_codepage( string_table *st, UINT codepage ) DECLSPEC_HIDDEN;
-extern WCHAR *msi_strdupW( const WCHAR *value, int len ) DECLSPEC_HIDDEN;
+extern WCHAR *msi_strdupW( const WCHAR *value, int len ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 
 extern BOOL TABLE_Exists( MSIDATABASE *db, LPCWSTR name ) DECLSPEC_HIDDEN;
 extern MSICONDITION MSI_DatabaseIsTablePersistent( MSIDATABASE *db, LPCWSTR table ) DECLSPEC_HIDDEN;
@@ -806,6 +805,7 @@ extern UINT msi_check_patch_applicable( MSIPACKAGE *package, MSISUMMARYINFO *si
 extern UINT msi_apply_patches( MSIPACKAGE *package ) DECLSPEC_HIDDEN;
 extern UINT msi_apply_registered_patch( MSIPACKAGE *package, LPCWSTR patch_code ) DECLSPEC_HIDDEN;
 extern void msi_free_patchinfo( MSIPATCHINFO *patch ) DECLSPEC_HIDDEN;
+extern UINT msi_patch_assembly( MSIPACKAGE *, MSIASSEMBLY *, MSIFILEPATCH * ) DECLSPEC_HIDDEN;
 
 /* action internals */
 extern UINT MSI_InstallPackage( MSIPACKAGE *, LPCWSTR, LPCWSTR ) DECLSPEC_HIDDEN;
@@ -854,7 +854,7 @@ extern UINT copy_remote_record(const struct wire_record *rec, MSIHANDLE handle)
 
 /* stream internals */
 extern void enum_stream_names( IStorage *stg ) DECLSPEC_HIDDEN;
-extern LPWSTR encode_streamname(BOOL bTable, LPCWSTR in) DECLSPEC_HIDDEN;
+extern WCHAR *encode_streamname(BOOL is_table, const WCHAR *in) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern BOOL decode_streamname(LPCWSTR in, LPWSTR out) DECLSPEC_HIDDEN;
 
 /* database internals */
@@ -942,7 +942,7 @@ extern UINT MSIREG_OpenClassesUpgradeCodesKey(LPCWSTR szUpgradeCode, HKEY* key,
 extern UINT MSIREG_DeleteLocalClassesProductKey(LPCWSTR szProductCode) DECLSPEC_HIDDEN;
 extern UINT MSIREG_DeleteLocalClassesFeaturesKey(LPCWSTR szProductCode) DECLSPEC_HIDDEN;
 extern UINT msi_locate_product(LPCWSTR szProduct, MSIINSTALLCONTEXT *context) DECLSPEC_HIDDEN;
-extern LPWSTR msi_reg_get_val_str( HKEY hkey, LPCWSTR name ) DECLSPEC_HIDDEN;
+extern WCHAR *msi_reg_get_val_str( HKEY hkey, const WCHAR *name ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern BOOL msi_reg_get_val_dword( HKEY hkey, LPCWSTR name, DWORD *val) DECLSPEC_HIDDEN;
 
 extern DWORD msi_version_str_to_dword(LPCWSTR p) DECLSPEC_HIDDEN;
@@ -963,9 +963,10 @@ extern void msi_dialog_unregister_class( void ) DECLSPEC_HIDDEN;
 /* summary information */
 extern UINT msi_get_suminfo( IStorage *stg, UINT uiUpdateCount, MSISUMMARYINFO **si ) DECLSPEC_HIDDEN;
 extern UINT msi_get_db_suminfo( MSIDATABASE *db, UINT uiUpdateCount, MSISUMMARYINFO **si ) DECLSPEC_HIDDEN;
-extern LPWSTR msi_suminfo_dup_string( MSISUMMARYINFO *si, UINT uiProperty ) DECLSPEC_HIDDEN;
+extern WCHAR *msi_suminfo_dup_string( MSISUMMARYINFO *si,
+                                      UINT property ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern INT msi_suminfo_get_int32( MSISUMMARYINFO *si, UINT uiProperty ) DECLSPEC_HIDDEN;
-extern LPWSTR msi_get_suminfo_product( IStorage *stg ) DECLSPEC_HIDDEN;
+extern WCHAR *msi_get_suminfo_product( IStorage *stg ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern UINT msi_add_suminfo( MSIDATABASE *db, LPWSTR **records, int num_records, int num_columns ) DECLSPEC_HIDDEN;
 extern UINT msi_export_suminfo( MSIDATABASE *db, HANDLE handle ) DECLSPEC_HIDDEN;
 extern UINT msi_load_suminfo_properties( MSIPACKAGE *package ) DECLSPEC_HIDDEN;
@@ -1021,27 +1022,30 @@ extern UINT ACTION_MsiUnpublishAssemblies(MSIPACKAGE *package) DECLSPEC_HIDDEN;
 
 /* Helpers */
 extern DWORD deformat_string(MSIPACKAGE *package, LPCWSTR ptr, WCHAR** data ) DECLSPEC_HIDDEN;
-extern WCHAR *msi_dup_record_field(MSIRECORD *row, INT index) DECLSPEC_HIDDEN;
-extern LPWSTR msi_dup_property( MSIDATABASE *db, LPCWSTR prop ) DECLSPEC_HIDDEN;
+extern WCHAR *msi_dup_record_field( MSIRECORD *row, INT index ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
+extern WCHAR *msi_dup_property( MSIDATABASE *db, const WCHAR *prop ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern UINT msi_set_property( MSIDATABASE *, const WCHAR *, const WCHAR *, int ) DECLSPEC_HIDDEN;
 extern UINT msi_get_property( MSIDATABASE *, LPCWSTR, LPWSTR, LPDWORD ) DECLSPEC_HIDDEN;
 extern int msi_get_property_int( MSIDATABASE *package, LPCWSTR prop, int def ) DECLSPEC_HIDDEN;
-extern WCHAR *msi_resolve_source_folder(MSIPACKAGE *package, const WCHAR *name, MSIFOLDER **folder) DECLSPEC_HIDDEN;
+extern WCHAR *msi_resolve_source_folder(MSIPACKAGE *package, const WCHAR *name,
+                                        MSIFOLDER **folder) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern void msi_resolve_target_folder(MSIPACKAGE *package, const WCHAR *name, BOOL load_prop) DECLSPEC_HIDDEN;
-extern WCHAR *msi_normalize_path(const WCHAR *) DECLSPEC_HIDDEN;
-extern WCHAR *msi_resolve_file_source(MSIPACKAGE *package, MSIFILE *file) DECLSPEC_HIDDEN;
+extern WCHAR *msi_normalize_path(const WCHAR *) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
+extern WCHAR *msi_resolve_file_source(MSIPACKAGE *package,
+                                      MSIFILE *file) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern const WCHAR *msi_get_target_folder(MSIPACKAGE *package, const WCHAR *name) DECLSPEC_HIDDEN;
 extern void msi_reset_source_folders( MSIPACKAGE *package ) DECLSPEC_HIDDEN;
 extern MSICOMPONENT *msi_get_loaded_component(MSIPACKAGE *package, const WCHAR *Component) DECLSPEC_HIDDEN;
 extern MSIFEATURE *msi_get_loaded_feature(MSIPACKAGE *package, const WCHAR *Feature) DECLSPEC_HIDDEN;
 extern MSIFILE *msi_get_loaded_file(MSIPACKAGE *package, const WCHAR *file) DECLSPEC_HIDDEN;
 extern MSIFOLDER *msi_get_loaded_folder(MSIPACKAGE *package, const WCHAR *dir) DECLSPEC_HIDDEN;
-extern WCHAR *msi_create_temp_file(MSIDATABASE *db) DECLSPEC_HIDDEN;
+extern WCHAR *msi_create_temp_file(MSIDATABASE *db) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern void msi_free_action_script(MSIPACKAGE *package, UINT script) DECLSPEC_HIDDEN;
-extern WCHAR *msi_build_icon_path(MSIPACKAGE *, const WCHAR *) DECLSPEC_HIDDEN;
-extern WCHAR * WINAPIV msi_build_directory_name(DWORD , ...) DECLSPEC_HIDDEN;
+extern WCHAR *msi_build_icon_path(MSIPACKAGE *, const WCHAR *) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
+extern WCHAR * WINAPIV msi_build_directory_name(DWORD , ...) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern void msi_reduce_to_long_filename(WCHAR *) DECLSPEC_HIDDEN;
-extern WCHAR *msi_create_component_advertise_string(MSIPACKAGE *, MSICOMPONENT *, const WCHAR *) DECLSPEC_HIDDEN;
+extern WCHAR *msi_create_component_advertise_string(MSIPACKAGE *, MSICOMPONENT *,
+                                                    const WCHAR *) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern void ACTION_UpdateComponentStates(MSIPACKAGE *package, MSIFEATURE *feature) DECLSPEC_HIDDEN;
 extern UINT msi_register_unique_action(MSIPACKAGE *, const WCHAR *) DECLSPEC_HIDDEN;
 extern BOOL msi_action_is_unique(const MSIPACKAGE *, const WCHAR *) DECLSPEC_HIDDEN;
@@ -1052,17 +1056,16 @@ extern UINT msi_set_sourcedir_props(MSIPACKAGE *package, BOOL replace) DECLSPEC_
 extern MSIASSEMBLY *msi_load_assembly(MSIPACKAGE *, MSICOMPONENT *) DECLSPEC_HIDDEN;
 extern UINT msi_install_assembly(MSIPACKAGE *, MSICOMPONENT *) DECLSPEC_HIDDEN;
 extern UINT msi_uninstall_assembly(MSIPACKAGE *, MSICOMPONENT *) DECLSPEC_HIDDEN;
-extern BOOL msi_init_assembly_caches(MSIPACKAGE *) DECLSPEC_HIDDEN;
 extern void msi_destroy_assembly_caches(MSIPACKAGE *) DECLSPEC_HIDDEN;
 extern BOOL msi_is_global_assembly(MSICOMPONENT *) DECLSPEC_HIDDEN;
 extern IAssemblyEnum *msi_create_assembly_enum(MSIPACKAGE *, const WCHAR *) DECLSPEC_HIDDEN;
-extern WCHAR *msi_get_assembly_path(MSIPACKAGE *, const WCHAR *) DECLSPEC_HIDDEN;
+extern WCHAR *msi_get_assembly_path(MSIPACKAGE *, const WCHAR *) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern WCHAR **msi_split_string(const WCHAR *, WCHAR) DECLSPEC_HIDDEN;
 extern UINT msi_set_original_database_property(MSIDATABASE *, const WCHAR *) DECLSPEC_HIDDEN;
-extern WCHAR *msi_get_error_message(MSIDATABASE *, int) DECLSPEC_HIDDEN;
+extern WCHAR *msi_get_error_message(MSIDATABASE *, int) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 extern UINT msi_strncpyWtoA(const WCHAR *str, int len, char *buf, DWORD *sz, BOOL remote) DECLSPEC_HIDDEN;
 extern UINT msi_strncpyW(const WCHAR *str, int len, WCHAR *buf, DWORD *sz) DECLSPEC_HIDDEN;
-extern WCHAR *msi_get_package_code(MSIDATABASE *db) DECLSPEC_HIDDEN;
+extern WCHAR *msi_get_package_code(MSIDATABASE *db) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 
 /* wrappers for filesystem functions */
 static inline void msi_disable_fs_redirection( MSIPACKAGE *package )
@@ -1087,7 +1090,8 @@ extern BOOL msi_create_full_path( MSIPACKAGE *, const WCHAR * ) DECLSPEC_HIDDEN;
 extern DWORD msi_get_disk_file_size( MSIPACKAGE *, const WCHAR * ) DECLSPEC_HIDDEN;
 extern VS_FIXEDFILEINFO *msi_get_disk_file_version( MSIPACKAGE *, const WCHAR * ) DECLSPEC_HIDDEN;
 extern UINT msi_get_filehash( MSIPACKAGE *, const WCHAR *, MSIFILEHASHINFO * ) DECLSPEC_HIDDEN;
-extern WCHAR *msi_get_font_file_version( MSIPACKAGE *, const WCHAR * ) DECLSPEC_HIDDEN;
+extern WCHAR *msi_get_font_file_version( MSIPACKAGE *,
+                                         const WCHAR * ) __WINE_DEALLOC(free) __WINE_MALLOC DECLSPEC_HIDDEN;
 
 /* media */
 
diff --git a/dlls/msi/msiquery.c b/dlls/msi/msiquery.c
index b4fbf279700..e16719f53d9 100644
--- a/dlls/msi/msiquery.c
+++ b/dlls/msi/msiquery.c
@@ -564,8 +564,7 @@ UINT WINAPI MsiViewExecute( MSIHANDLE hView, MSIHANDLE hRec )
     return ret;
 }
 
-static UINT msi_set_record_type_string( MSIRECORD *rec, UINT field,
-                                        UINT type, BOOL temporary )
+static UINT set_record_type_string( MSIRECORD *rec, UINT field, UINT type, BOOL temporary )
 {
     WCHAR szType[0x10];
 
@@ -633,7 +632,7 @@ UINT MSI_ViewGetColumnInfo( MSIQUERY *query, MSICOLINFO info, MSIRECORD **prec )
         if (info == MSICOLINFO_NAMES)
             MSI_RecordSetStringW( rec, i+1, name );
         else
-            msi_set_record_type_string( rec, i+1, type, temporary );
+            set_record_type_string( rec, i+1, type, temporary );
     }
     *prec = rec;
     return ERROR_SUCCESS;
@@ -1009,15 +1008,15 @@ UINT WINAPI MsiDatabaseCommit( MSIHANDLE hdb )
     return r;
 }
 
-struct msi_primary_key_record_info
+struct primary_key_record_info
 {
     DWORD n;
     MSIRECORD *rec;
 };
 
-static UINT msi_primary_key_iterator( MSIRECORD *rec, LPVOID param )
+static UINT primary_key_iterator( MSIRECORD *rec, void *param )
 {
-    struct msi_primary_key_record_info *info = param;
+    struct primary_key_record_info *info = param;
     LPCWSTR name, table;
     DWORD type;
 
@@ -1041,10 +1040,9 @@ static UINT msi_primary_key_iterator( MSIRECORD *rec, LPVOID param )
     return ERROR_SUCCESS;
 }
 
-UINT MSI_DatabaseGetPrimaryKeys( MSIDATABASE *db,
-                LPCWSTR table, MSIRECORD **prec )
+UINT MSI_DatabaseGetPrimaryKeys( MSIDATABASE *db, const WCHAR *table, MSIRECORD **prec )
 {
-    struct msi_primary_key_record_info info;
+    struct primary_key_record_info info;
     MSIQUERY *query = NULL;
     UINT r;
 
@@ -1058,7 +1056,7 @@ UINT MSI_DatabaseGetPrimaryKeys( MSIDATABASE *db,
     /* count the number of primary key records */
     info.n = 0;
     info.rec = 0;
-    r = MSI_IterateRecords( query, 0, msi_primary_key_iterator, &info );
+    r = MSI_IterateRecords( query, 0, primary_key_iterator, &info );
     if( r == ERROR_SUCCESS )
     {
         TRACE( "found %lu primary keys\n", info.n );
@@ -1066,7 +1064,7 @@ UINT MSI_DatabaseGetPrimaryKeys( MSIDATABASE *db,
         /* allocate a record and fill in the names of the tables */
         info.rec = MSI_CreateRecord( info.n );
         info.n = 0;
-        r = MSI_IterateRecords( query, 0, msi_primary_key_iterator, &info );
+        r = MSI_IterateRecords( query, 0, primary_key_iterator, &info );
         if( r == ERROR_SUCCESS )
             *prec = info.rec;
         else
diff --git a/dlls/msi/package.c b/dlls/msi/package.c
index bfbbaadae1b..9e34b7e6351 100644
--- a/dlls/msi/package.c
+++ b/dlls/msi/package.c
@@ -573,11 +573,11 @@ static LPWSTR get_fusion_filename(MSIPACKAGE *package)
     return filename;
 }
 
-typedef struct tagLANGANDCODEPAGE
+struct lang_codepage
 {
   WORD wLanguage;
   WORD wCodePage;
-} LANGANDCODEPAGE;
+};
 
 static void set_msi_assembly_prop(MSIPACKAGE *package)
 {
@@ -586,7 +586,7 @@ static void set_msi_assembly_prop(MSIPACKAGE *package)
     LPVOID version = NULL;
     WCHAR buf[MAX_PATH];
     LPWSTR fusion, verstr;
-    LANGANDCODEPAGE *translate;
+    struct lang_codepage *translate;
 
     fusion = get_fusion_filename(package);
     if (!fusion)
@@ -940,7 +940,7 @@ static MSIPACKAGE *alloc_package( void )
     return package;
 }
 
-static UINT msi_load_admin_properties(MSIPACKAGE *package)
+static UINT load_admin_properties(MSIPACKAGE *package)
 {
     BYTE *data;
     UINT r, sz;
@@ -1009,7 +1009,7 @@ MSIPACKAGE *MSI_CreatePackage( MSIDATABASE *db )
         }
 
         if (package->WordCount & msidbSumInfoSourceTypeAdminImage)
-            msi_load_admin_properties( package );
+            load_admin_properties( package );
 
         package->log_file = INVALID_HANDLE_VALUE;
         package->script = SCRIPT_NONE;
@@ -1502,13 +1502,6 @@ UINT MSI_OpenPackageW(LPCWSTR szPackage, DWORD dwOptions, MSIPACKAGE **pPackage)
         package->log_file = CreateFileW( gszLogFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
                                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
 
-    if (!msi_init_assembly_caches( package ))
-    {
-        ERR("can't initialize assembly caches\n");
-        msiobj_release( &package->hdr );
-        return ERROR_FUNCTION_FAILED;
-    }
-
     /* FIXME: when should these messages be sent? */
     data_row = MSI_CreateRecord(3);
     if (!data_row)
@@ -2117,7 +2110,7 @@ UINT WINAPI MsiSetPropertyW( MSIHANDLE hInstall, LPCWSTR szName, LPCWSTR szValue
     return ret;
 }
 
-static MSIRECORD *msi_get_property_row( MSIDATABASE *db, LPCWSTR name )
+static MSIRECORD *get_property_row( MSIDATABASE *db, const WCHAR *name )
 {
     MSIRECORD *rec, *row = NULL;
     MSIQUERY *view;
@@ -2192,7 +2185,7 @@ UINT msi_get_property( MSIDATABASE *db, LPCWSTR szName,
 
     TRACE("%p %s %p %p\n", db, debugstr_w(szName), szValueBuf, pchValueBuf);
 
-    row = msi_get_property_row( db, szName );
+    row = get_property_row( db, szName );
 
     if (*pchValueBuf > 0)
         szValueBuf[0] = 0;
@@ -2307,7 +2300,7 @@ UINT WINAPI MsiGetPropertyA(MSIHANDLE hinst, const char *name, char *buf, DWORD
         return r;
     }
 
-    row = msi_get_property_row(package->db, nameW);
+    row = get_property_row(package->db, nameW);
     if (row)
         value = msi_record_get_string(row, 1, &len);
 
@@ -2370,7 +2363,7 @@ UINT WINAPI MsiGetPropertyW(MSIHANDLE hinst, const WCHAR *name, WCHAR *buf, DWOR
         return r;
     }
 
-    row = msi_get_property_row(package->db, name);
+    row = get_property_row(package->db, name);
     if (row)
         value = msi_record_get_string(row, 1, &len);
 
diff --git a/dlls/msi/patch.c b/dlls/msi/patch.c
index 8acc741e0c7..3b8a4eef033 100644
--- a/dlls/msi/patch.c
+++ b/dlls/msi/patch.c
@@ -315,7 +315,7 @@ UINT msi_check_patch_applicable( MSIPACKAGE *package, MSISUMMARYINFO *si )
     return ret;
 }
 
-static UINT msi_parse_patch_summary( MSISUMMARYINFO *si, MSIPATCHINFO **patch )
+static UINT parse_patch_summary( MSISUMMARYINFO *si, MSIPATCHINFO **patch )
 {
     MSIPATCHINFO *pi;
     UINT r = ERROR_SUCCESS;
@@ -831,7 +831,7 @@ static DWORD is_uninstallable( MSIDATABASE *db )
     return ret;
 }
 
-static UINT msi_apply_patch_db( MSIPACKAGE *package, MSIDATABASE *patch_db, MSIPATCHINFO *patch )
+static UINT apply_patch_db( MSIPACKAGE *package, MSIDATABASE *patch_db, MSIPATCHINFO *patch )
 {
     UINT i, r = ERROR_SUCCESS;
     WCHAR **substorage;
@@ -872,7 +872,7 @@ void msi_free_patchinfo( MSIPATCHINFO *patch )
     free( patch );
 }
 
-static UINT msi_apply_patch_package( MSIPACKAGE *package, const WCHAR *file )
+static UINT apply_patch_package( MSIPACKAGE *package, const WCHAR *file )
 {
     MSIDATABASE *patch_db = NULL;
     WCHAR localfile[MAX_PATH];
@@ -901,7 +901,7 @@ static UINT msi_apply_patch_package( MSIPACKAGE *package, const WCHAR *file )
         r = ERROR_SUCCESS;
         goto done;
     }
-    r = msi_parse_patch_summary( si, &patch );
+    r = parse_patch_summary( si, &patch );
     if ( r != ERROR_SUCCESS )
         goto done;
 
@@ -914,7 +914,7 @@ static UINT msi_apply_patch_package( MSIPACKAGE *package, const WCHAR *file )
     if (!(patch->filename = wcsdup( file ))) goto done;
     if (!(patch->localfile = wcsdup( localfile ))) goto done;
 
-    r = msi_apply_patch_db( package, patch_db, patch );
+    r = apply_patch_db( package, patch_db, patch );
     if (r != ERROR_SUCCESS) WARN("patch failed to apply %u\n", r);
 
 done:
@@ -940,7 +940,7 @@ UINT msi_apply_patches( MSIPACKAGE *package )
 
     patches = msi_split_string( patch_list, ';' );
     for (i = 0; patches && patches[i] && r == ERROR_SUCCESS; i++)
-        r = msi_apply_patch_package( package, patches[i] );
+        r = apply_patch_package( package, patches[i] );
 
     free( patches );
     free( patch_list );
@@ -1018,7 +1018,7 @@ UINT msi_apply_registered_patch( MSIPACKAGE *package, LPCWSTR patch_code )
         msiobj_release( &patch_db->hdr );
         return r;
     }
-    r = msi_parse_patch_summary( si, &patch_info );
+    r = parse_patch_summary( si, &patch_info );
     msiobj_release( &si->hdr );
     if (r != ERROR_SUCCESS)
     {
@@ -1034,7 +1034,7 @@ UINT msi_apply_registered_patch( MSIPACKAGE *package, LPCWSTR patch_code )
         msi_free_patchinfo( patch_info );
         return ERROR_OUTOFMEMORY;
     }
-    r = msi_apply_patch_db( package, patch_db, patch_info );
+    r = apply_patch_db( package, patch_db, patch_info );
     msiobj_release( &patch_db->hdr );
     if (r != ERROR_SUCCESS)
     {
diff --git a/dlls/msi/query.h b/dlls/msi/query.h
index 5e5f3906f4f..2323a8481d4 100644
--- a/dlls/msi/query.h
+++ b/dlls/msi/query.h
@@ -68,7 +68,6 @@ struct complex_expr
     struct expr *right;
 };
 
-struct tagJOINTABLE;
 union ext_column
 {
     struct
@@ -79,7 +78,7 @@ union ext_column
     struct
     {
         UINT column;
-        struct tagJOINTABLE *table;
+        struct join_table *table;
     } parsed;
 };
 
diff --git a/dlls/msi/record.c b/dlls/msi/record.c
index 4e7430774d6..3671133ac4c 100644
--- a/dlls/msi/record.c
+++ b/dlls/msi/record.c
@@ -497,7 +497,7 @@ UINT WINAPI MsiRecordGetStringW( MSIHANDLE handle, UINT iField, WCHAR *szValue,
     return ret;
 }
 
-static UINT msi_get_stream_size( IStream *stm )
+static UINT get_stream_size( IStream *stm )
 {
     STATSTG stat;
     HRESULT r;
@@ -524,7 +524,7 @@ static UINT MSI_RecordDataSize(MSIRECORD *rec, UINT iField)
     case MSIFIELD_NULL:
         break;
     case MSIFIELD_STREAM:
-        return msi_get_stream_size( rec->fields[iField].u.stream );
+        return get_stream_size( rec->fields[iField].u.stream );
     }
     return 0;
 }
@@ -865,7 +865,7 @@ UINT MSI_RecordGetIStream( MSIRECORD *rec, UINT iField, IStream **pstm)
     return ERROR_SUCCESS;
 }
 
-static UINT msi_dump_stream_to_file( IStream *stm, LPCWSTR name )
+static UINT dump_stream_to_file( IStream *stm, const WCHAR *name )
 {
     ULARGE_INTEGER size;
     LARGE_INTEGER pos;
@@ -909,7 +909,7 @@ UINT MSI_RecordStreamToFile( MSIRECORD *rec, UINT iField, LPCWSTR name )
     r = MSI_RecordGetIStream( rec, iField, &stm );
     if( r == ERROR_SUCCESS )
     {
-        r = msi_dump_stream_to_file( stm, name );
+        r = dump_stream_to_file( stm, name );
         IStream_Release( stm );
     }
 
diff --git a/dlls/msi/registry.c b/dlls/msi/registry.c
index 4120800db1e..149f9cf9945 100644
--- a/dlls/msi/registry.c
+++ b/dlls/msi/registry.c
@@ -1687,9 +1687,8 @@ done:
     return r;
 }
 
-static UINT msi_get_patch_state(LPCWSTR prodcode, LPCWSTR usersid,
-                                MSIINSTALLCONTEXT context,
-                                LPWSTR patch, MSIPATCHSTATE *state)
+static UINT get_patch_state(const WCHAR *prodcode, const WCHAR *usersid, MSIINSTALLCONTEXT context,
+                            WCHAR *patch, MSIPATCHSTATE *state)
 {
     DWORD type, val, size;
     HKEY prod, hkey = 0;
@@ -1732,10 +1731,9 @@ done:
     return r;
 }
 
-static UINT msi_check_product_patches(LPCWSTR prodcode, LPCWSTR usersid,
-        MSIINSTALLCONTEXT context, DWORD filter, DWORD index, DWORD *idx,
-        LPWSTR patch, LPWSTR targetprod, MSIINSTALLCONTEXT *targetctx,
-        LPWSTR targetsid, DWORD *sidsize, LPWSTR *transforms)
+static UINT check_product_patches(const WCHAR *prodcode, const WCHAR *usersid, MSIINSTALLCONTEXT context,
+                                  DWORD filter, DWORD index, DWORD *idx, WCHAR *patch, WCHAR *targetprod,
+                                  MSIINSTALLCONTEXT *targetctx, WCHAR *targetsid, DWORD *sidsize, WCHAR **transforms)
 {
     MSIPATCHSTATE state = MSIPATCHSTATE_INVALID;
     LPWSTR ptr, patches = NULL;
@@ -1806,8 +1804,7 @@ static UINT msi_check_product_patches(LPCWSTR prodcode, LPCWSTR usersid,
         {
             if (!(filter & MSIPATCHSTATE_APPLIED))
             {
-                temp = msi_get_patch_state(prodcode, usersid, context,
-                                           ptr, &state);
+                temp = get_patch_state(prodcode, usersid, context, ptr, &state);
                 if (temp == ERROR_BAD_CONFIGURATION)
                 {
                     r = ERROR_BAD_CONFIGURATION;
@@ -1822,8 +1819,7 @@ static UINT msi_check_product_patches(LPCWSTR prodcode, LPCWSTR usersid,
         {
             if (!(filter & MSIPATCHSTATE_APPLIED))
             {
-                temp = msi_get_patch_state(prodcode, usersid, context,
-                                           ptr, &state);
+                temp = get_patch_state(prodcode, usersid, context, ptr, &state);
                 if (temp == ERROR_BAD_CONFIGURATION)
                 {
                     r = ERROR_BAD_CONFIGURATION;
@@ -1901,11 +1897,10 @@ done:
     return r;
 }
 
-static UINT msi_enum_patches(LPCWSTR szProductCode, LPCWSTR szUserSid,
-        DWORD dwContext, DWORD dwFilter, DWORD dwIndex, DWORD *idx,
-        LPWSTR szPatchCode, LPWSTR szTargetProductCode,
-        MSIINSTALLCONTEXT *pdwTargetProductContext, LPWSTR szTargetUserSid,
-        LPDWORD pcchTargetUserSid, LPWSTR *szTransforms)
+static UINT enum_patches(const WCHAR *szProductCode, const WCHAR *szUserSid, DWORD dwContext, DWORD dwFilter,
+                         DWORD dwIndex, DWORD *idx, WCHAR *szPatchCode, WCHAR *szTargetProductCode,
+                         MSIINSTALLCONTEXT *pdwTargetProductContext, WCHAR *szTargetUserSid, DWORD *pcchTargetUserSid,
+                         WCHAR **szTransforms)
 {
     LPWSTR usersid = NULL;
     UINT r = ERROR_INVALID_PARAMETER;
@@ -1918,36 +1913,27 @@ static UINT msi_enum_patches(LPCWSTR szProductCode, LPCWSTR szUserSid,
 
     if (dwContext & MSIINSTALLCONTEXT_USERMANAGED)
     {
-        r = msi_check_product_patches(szProductCode, szUserSid,
-                                      MSIINSTALLCONTEXT_USERMANAGED, dwFilter,
-                                      dwIndex, idx, szPatchCode,
-                                      szTargetProductCode,
-                                      pdwTargetProductContext, szTargetUserSid,
-                                      pcchTargetUserSid, szTransforms);
+        r = check_product_patches(szProductCode, szUserSid, MSIINSTALLCONTEXT_USERMANAGED, dwFilter, dwIndex, idx,
+                                  szPatchCode, szTargetProductCode, pdwTargetProductContext, szTargetUserSid,
+                                  pcchTargetUserSid, szTransforms);
         if (r != ERROR_NO_MORE_ITEMS)
             goto done;
     }
 
     if (dwContext & MSIINSTALLCONTEXT_USERUNMANAGED)
     {
-        r = msi_check_product_patches(szProductCode, szUserSid,
-                                      MSIINSTALLCONTEXT_USERUNMANAGED, dwFilter,
-                                      dwIndex, idx, szPatchCode,
-                                      szTargetProductCode,
-                                      pdwTargetProductContext, szTargetUserSid,
-                                      pcchTargetUserSid, szTransforms);
+        r = check_product_patches(szProductCode, szUserSid, MSIINSTALLCONTEXT_USERUNMANAGED, dwFilter, dwIndex, idx,
+                                  szPatchCode, szTargetProductCode, pdwTargetProductContext, szTargetUserSid,
+                                  pcchTargetUserSid, szTransforms);
         if (r != ERROR_NO_MORE_ITEMS)
             goto done;
     }
 
     if (dwContext & MSIINSTALLCONTEXT_MACHINE)
     {
-        r = msi_check_product_patches(szProductCode, szUserSid,
-                                      MSIINSTALLCONTEXT_MACHINE, dwFilter,
-                                      dwIndex, idx, szPatchCode,
-                                      szTargetProductCode,
-                                      pdwTargetProductContext, szTargetUserSid,
-                                      pcchTargetUserSid, szTransforms);
+        r = check_product_patches(szProductCode, szUserSid, MSIINSTALLCONTEXT_MACHINE, dwFilter, dwIndex, idx,
+                                  szPatchCode, szTargetProductCode, pdwTargetProductContext, szTargetUserSid,
+                                  pcchTargetUserSid, szTransforms);
         if (r != ERROR_NO_MORE_ITEMS)
             goto done;
     }
@@ -1997,10 +1983,8 @@ UINT WINAPI MsiEnumPatchesExW( const WCHAR *szProductCode, const WCHAR *szUserSi
     if (dwIndex == 0)
         last_index = 0;
 
-    r = msi_enum_patches(szProductCode, szUserSid, dwContext, dwFilter,
-                         dwIndex, &idx, szPatchCode, szTargetProductCode,
-                         pdwTargetProductContext, szTargetUserSid,
-                         pcchTargetUserSid, NULL);
+    r = enum_patches(szProductCode, szUserSid, dwContext, dwFilter, dwIndex, &idx, szPatchCode, szTargetProductCode,
+                     pdwTargetProductContext, szTargetUserSid, pcchTargetUserSid, NULL);
 
     if (r == ERROR_SUCCESS)
         last_index = dwIndex;
@@ -2094,9 +2078,8 @@ UINT WINAPI MsiEnumPatchesW( const WCHAR *szProduct, DWORD iPatchIndex, WCHAR *l
 
     RegCloseKey(prod);
 
-    r = msi_enum_patches(szProduct, NULL, MSIINSTALLCONTEXT_ALL,
-                         MSIPATCHSTATE_ALL, iPatchIndex, &idx, lpPatchBuf,
-                         NULL, NULL, NULL, NULL, &transforms);
+    r = enum_patches(szProduct, NULL, MSIINSTALLCONTEXT_ALL, MSIPATCHSTATE_ALL, iPatchIndex, &idx, lpPatchBuf, NULL,
+                     NULL, NULL, NULL, &transforms);
     if (r != ERROR_SUCCESS)
         goto done;
 
diff --git a/dlls/msi/script.c b/dlls/msi/script.c
index 519beb86a63..f355918b07d 100644
--- a/dlls/msi/script.c
+++ b/dlls/msi/script.c
@@ -50,18 +50,19 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
 #endif
 
 /*
- * MsiActiveScriptSite - Our IActiveScriptSite implementation.
+ * struct script_site - Our IActiveScriptSite implementation.
  */
-typedef struct {
+struct script_site
+{
     IActiveScriptSite IActiveScriptSite_iface;
     IDispatch *installer;
     IDispatch *session;
     LONG ref;
-} MsiActiveScriptSite;
+};
 
-static inline MsiActiveScriptSite *impl_from_IActiveScriptSite( IActiveScriptSite *iface )
+static inline struct script_site *impl_from_IActiveScriptSite( IActiveScriptSite *iface )
 {
-    return CONTAINING_RECORD(iface, MsiActiveScriptSite, IActiveScriptSite_iface);
+    return CONTAINING_RECORD(iface, struct script_site, IActiveScriptSite_iface);
 }
 
 /*
@@ -69,7 +70,7 @@ static inline MsiActiveScriptSite *impl_from_IActiveScriptSite( IActiveScriptSit
  */
 static HRESULT WINAPI MsiActiveScriptSite_QueryInterface(IActiveScriptSite* iface, REFIID riid, void** obj)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
 
     TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), obj);
 
@@ -88,7 +89,7 @@ static HRESULT WINAPI MsiActiveScriptSite_QueryInterface(IActiveScriptSite* ifac
 
 static ULONG WINAPI MsiActiveScriptSite_AddRef(IActiveScriptSite* iface)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
     TRACE( "(%p)->(%lu)\n", This, ref );
     return ref;
@@ -96,7 +97,7 @@ static ULONG WINAPI MsiActiveScriptSite_AddRef(IActiveScriptSite* iface)
 
 static ULONG WINAPI MsiActiveScriptSite_Release(IActiveScriptSite* iface)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
     TRACE( "(%p)->(%lu)\n", This, ref );
@@ -109,14 +110,14 @@ static ULONG WINAPI MsiActiveScriptSite_Release(IActiveScriptSite* iface)
 
 static HRESULT WINAPI MsiActiveScriptSite_GetLCID(IActiveScriptSite* iface, LCID* plcid)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     TRACE("(%p)->(%p)\n", This, plcid);
     return E_NOTIMPL;  /* Script will use system-defined locale */
 }
 
 static HRESULT WINAPI MsiActiveScriptSite_GetItemInfo(IActiveScriptSite* iface, LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppiunkItem, ITypeInfo** ppti)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
 
     TRACE( "(%p)->(%p, %lu, %p, %p)\n", This, pstrName, dwReturnMask, ppiunkItem, ppti );
 
@@ -149,14 +150,14 @@ static HRESULT WINAPI MsiActiveScriptSite_GetItemInfo(IActiveScriptSite* iface,
 
 static HRESULT WINAPI MsiActiveScriptSite_GetDocVersionString(IActiveScriptSite* iface, BSTR* pbstrVersion)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     TRACE("(%p)->(%p)\n", This, pbstrVersion);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI MsiActiveScriptSite_OnScriptTerminate(IActiveScriptSite* iface, const VARIANT* pvarResult, const EXCEPINFO* pexcepinfo)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     TRACE("(%p)->(%p, %p)\n", This, pvarResult, pexcepinfo);
     return S_OK;
 }
@@ -198,7 +199,7 @@ static HRESULT WINAPI MsiActiveScriptSite_OnStateChange(IActiveScriptSite* iface
 
 static HRESULT WINAPI MsiActiveScriptSite_OnScriptError(IActiveScriptSite* iface, IActiveScriptError* pscripterror)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     EXCEPINFO exception;
     HRESULT hr;
 
@@ -219,14 +220,14 @@ static HRESULT WINAPI MsiActiveScriptSite_OnScriptError(IActiveScriptSite* iface
 
 static HRESULT WINAPI MsiActiveScriptSite_OnEnterScript(IActiveScriptSite* iface)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     TRACE("(%p)\n", This);
     return S_OK;
 }
 
 static HRESULT WINAPI MsiActiveScriptSite_OnLeaveScript(IActiveScriptSite* iface)
 {
-    MsiActiveScriptSite *This = impl_from_IActiveScriptSite(iface);
+    struct script_site *This = impl_from_IActiveScriptSite(iface);
     TRACE("(%p)\n", This);
     return S_OK;
 }
@@ -246,15 +247,15 @@ static const struct IActiveScriptSiteVtbl activescriptsitevtbl =
     MsiActiveScriptSite_OnLeaveScript
 };
 
-static HRESULT create_activescriptsite(MsiActiveScriptSite **obj)
+static HRESULT create_activescriptsite(struct script_site **obj)
 {
-    MsiActiveScriptSite* object;
+    struct script_site *object;
 
     TRACE("(%p)\n", obj);
 
     *obj = NULL;
 
-    object = malloc(sizeof(MsiActiveScriptSite));
+    object = malloc(sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
 
@@ -290,7 +291,7 @@ DWORD call_script(MSIHANDLE hPackage, INT type, LPCWSTR script, LPCWSTR function
     HRESULT hr;
     IActiveScript *pActiveScript = NULL;
     IActiveScriptParse *pActiveScriptParse = NULL;
-    MsiActiveScriptSite *scriptsite;
+    struct script_site *scriptsite;
     IDispatch *pDispatch = NULL;
     DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
     DISPID dispid;
diff --git a/dlls/msi/select.c b/dlls/msi/select.c
index 1b77d1095d3..cfb17f60b62 100644
--- a/dlls/msi/select.c
+++ b/dlls/msi/select.c
@@ -38,7 +38,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 /* below is the query interface to a table */
 
-typedef struct tagMSISELECTVIEW
+struct select_view
 {
     MSIVIEW        view;
     MSIDATABASE   *db;
@@ -46,9 +46,9 @@ typedef struct tagMSISELECTVIEW
     UINT           num_cols;
     UINT           max_cols;
     UINT           cols[1];
-} MSISELECTVIEW;
+};
 
-static UINT translate_record( MSISELECTVIEW *sv, MSIRECORD *in, MSIRECORD **out )
+static UINT translate_record( struct select_view *sv, MSIRECORD *in, MSIRECORD **out )
 {
     UINT r, col_count, i;
     MSIRECORD *object;
@@ -74,7 +74,7 @@ static UINT translate_record( MSISELECTVIEW *sv, MSIRECORD *in, MSIRECORD **out
 
 static UINT SELECT_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p %d %d %p\n", sv, row, col, val );
 
@@ -95,7 +95,7 @@ static UINT SELECT_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT
 
 static UINT SELECT_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm)
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p %d %d %p\n", sv, row, col, stm );
 
@@ -116,7 +116,7 @@ static UINT SELECT_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IS
 
 static UINT SELECT_set_row( struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UINT mask )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
     UINT i, expanded_mask = 0, r = ERROR_SUCCESS, col_count = 0;
     MSIRECORD *expanded;
 
@@ -158,7 +158,7 @@ static UINT SELECT_set_row( struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, U
 
 static UINT SELECT_insert_row( struct tagMSIVIEW *view, MSIRECORD *record, UINT row, BOOL temporary )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
     UINT table_cols, r;
     MSIRECORD *outrec;
 
@@ -183,7 +183,7 @@ static UINT SELECT_insert_row( struct tagMSIVIEW *view, MSIRECORD *record, UINT
 
 static UINT SELECT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p %p\n", sv, record);
 
@@ -195,7 +195,7 @@ static UINT SELECT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 
 static UINT SELECT_close( struct tagMSIVIEW *view )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p\n", sv );
 
@@ -207,7 +207,7 @@ static UINT SELECT_close( struct tagMSIVIEW *view )
 
 static UINT SELECT_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p %p %p\n", sv, rows, cols );
 
@@ -223,7 +223,7 @@ static UINT SELECT_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *co
 static UINT SELECT_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                     UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p %d %p %p %p %p\n", sv, n, name, type, temporary, table_name );
 
@@ -248,7 +248,7 @@ static UINT SELECT_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *na
 
 UINT msi_select_update(MSIVIEW *view, MSIRECORD *rec, UINT row)
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
     UINT r, i, col, type, val;
     IStream *stream;
     LPCWSTR str;
@@ -295,7 +295,7 @@ UINT msi_select_update(MSIVIEW *view, MSIRECORD *rec, UINT row)
 static UINT SELECT_modify( struct tagMSIVIEW *view, MSIMODIFY mode,
                            MSIRECORD *rec, UINT row )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
     MSIRECORD *table_rec;
     UINT r;
 
@@ -336,7 +336,7 @@ static UINT SELECT_modify( struct tagMSIVIEW *view, MSIMODIFY mode,
 
 static UINT SELECT_delete( struct tagMSIVIEW *view )
 {
-    MSISELECTVIEW *sv = (MSISELECTVIEW*)view;
+    struct select_view *sv = (struct select_view *)view;
 
     TRACE("%p\n", sv );
 
@@ -372,8 +372,7 @@ static const MSIVIEWOPS select_ops =
     NULL,
 };
 
-static UINT SELECT_AddColumn( MSISELECTVIEW *sv, LPCWSTR name,
-                              LPCWSTR table_name )
+static UINT SELECT_AddColumn( struct select_view *sv, const WCHAR *name, const WCHAR *table_name )
 {
     UINT r, n;
     MSIVIEW *table;
@@ -423,14 +422,14 @@ static int select_count_columns( const column_info *col )
 UINT SELECT_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table,
                         const column_info *columns )
 {
-    MSISELECTVIEW *sv = NULL;
+    struct select_view *sv = NULL;
     UINT count = 0, r = ERROR_SUCCESS;
 
     TRACE("%p\n", sv );
 
     count = select_count_columns( columns );
 
-    sv = calloc( 1, offsetof( MSISELECTVIEW, cols[count] ) );
+    sv = calloc( 1, offsetof( struct select_view, cols[count] ) );
     if( !sv )
         return ERROR_FUNCTION_FAILED;
 
diff --git a/dlls/msi/source.c b/dlls/msi/source.c
index 6545f5dc63c..d67a16ab4a3 100644
--- a/dlls/msi/source.c
+++ b/dlls/msi/source.c
@@ -42,13 +42,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
  * These apis are defined in MSI 3.0
  */
 
-typedef struct tagMediaInfo
+struct media_info
 {
     struct list entry;
     LPWSTR  path;
     WCHAR   szIndex[10];
     DWORD   index;
-} media_info;
+};
 
 static UINT OpenSourceKey(LPCWSTR szProduct, HKEY* key, DWORD dwOptions,
                           MSIINSTALLCONTEXT context, BOOL create)
@@ -937,17 +937,16 @@ static void free_source_list(struct list *sourcelist)
 {
     while (!list_empty(sourcelist))
     {
-        media_info *info = LIST_ENTRY(list_head(sourcelist), media_info, entry);
+        struct media_info *info = LIST_ENTRY(list_head(sourcelist), struct media_info, entry);
         list_remove(&info->entry);
         free(info->path);
         free(info);
     }
 }
 
-static void add_source_to_list(struct list *sourcelist, media_info *info,
-                               DWORD *index)
+static void add_source_to_list(struct list *sourcelist, struct media_info *info, DWORD *index)
 {
-    media_info *iter;
+    struct media_info *iter;
     BOOL found = FALSE;
 
     if (index) *index = 0;
@@ -958,7 +957,7 @@ static void add_source_to_list(struct list *sourcelist, media_info *info,
         return;
     }
 
-    LIST_FOR_EACH_ENTRY(iter, sourcelist, media_info, entry)
+    LIST_FOR_EACH_ENTRY(iter, sourcelist, struct media_info, entry)
     {
         if (!found && info->index < iter->index)
         {
@@ -983,7 +982,7 @@ static UINT fill_source_list(struct list *sourcelist, HKEY sourcekey, DWORD *cou
     DWORD index = 0;
     WCHAR name[10];
     DWORD size, val_size;
-    media_info *entry;
+    struct media_info *entry;
 
     *count = 0;
 
@@ -994,7 +993,7 @@ static UINT fill_source_list(struct list *sourcelist, HKEY sourcekey, DWORD *cou
         if (r != ERROR_SUCCESS)
             return r;
 
-        entry = malloc(sizeof(media_info));
+        entry = malloc(sizeof(*entry));
         if (!entry)
             goto error;
 
@@ -1037,7 +1036,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
     HKEY sourcekey, typekey;
     UINT rc;
     struct list sourcelist;
-    media_info *info;
+    struct media_info *info;
     WCHAR *source, squashed_pc[SQUASHED_GUID_SIZE], name[10];
     LPCWSTR postfix;
     DWORD size, count, index;
@@ -1118,7 +1117,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
     else
     {
         swprintf(name, ARRAY_SIZE(name), L"%d", dwIndex);
-        info = malloc(sizeof(media_info));
+        info = malloc(sizeof(*info));
         if (!info)
         {
             rc = ERROR_OUTOFMEMORY;
@@ -1130,7 +1129,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
         info->index = dwIndex;
         add_source_to_list(&sourcelist, info, &index);
 
-        LIST_FOR_EACH_ENTRY(info, &sourcelist, media_info, entry)
+        LIST_FOR_EACH_ENTRY(info, &sourcelist, struct media_info, entry)
         {
             if (info->index < index)
                 continue;
diff --git a/dlls/msi/storages.c b/dlls/msi/storages.c
index df17aa036a5..94415035842 100644
--- a/dlls/msi/storages.c
+++ b/dlls/msi/storages.c
@@ -40,23 +40,23 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 #define NUM_STORAGES_COLS    2
 #define MAX_STORAGES_NAME_LEN 62
 
-typedef struct tabSTORAGE
+struct storage
 {
     UINT str_index;
     IStorage *storage;
 } STORAGE;
 
-typedef struct tagMSISTORAGESVIEW
+struct storages_view
 {
     MSIVIEW view;
     MSIDATABASE *db;
-    STORAGE *storages;
+    struct storage *storages;
     UINT max_storages;
     UINT num_rows;
     UINT row_size;
-} MSISTORAGESVIEW;
+};
 
-static BOOL storages_set_table_size(MSISTORAGESVIEW *sv, UINT size)
+static BOOL storages_set_table_size(struct storages_view *sv, UINT size)
 {
     if (size >= sv->max_storages)
     {
@@ -71,7 +71,7 @@ static BOOL storages_set_table_size(MSISTORAGESVIEW *sv, UINT size)
 
 static UINT STORAGES_fetch_int(struct tagMSIVIEW *view, UINT row, UINT col, UINT *val)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
 
     TRACE("(%p, %d, %d, %p)\n", view, row, col, val);
 
@@ -88,7 +88,7 @@ static UINT STORAGES_fetch_int(struct tagMSIVIEW *view, UINT row, UINT col, UINT
 
 static UINT STORAGES_fetch_stream(struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
 
     TRACE("(%p, %d, %d, %p)\n", view, row, col, stm);
 
@@ -155,7 +155,7 @@ done:
 
 static UINT STORAGES_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *stream )
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
     IStorage *stg, *substg, *prev;
     const WCHAR *name;
     HRESULT hr;
@@ -195,7 +195,7 @@ static UINT STORAGES_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *str
 
 static UINT STORAGES_set_row(struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UINT mask)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
     IStorage *stg, *substg = NULL, *prev;
     IStream *stm;
     LPWSTR name = NULL;
@@ -259,7 +259,7 @@ done:
 
 static UINT STORAGES_insert_row(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row, BOOL temporary)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
 
     if (!storages_set_table_size(sv, ++sv->num_rows))
         return ERROR_FUNCTION_FAILED;
@@ -294,7 +294,7 @@ static UINT STORAGES_close(struct tagMSIVIEW *view)
 
 static UINT STORAGES_get_dimensions(struct tagMSIVIEW *view, UINT *rows, UINT *cols)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
 
     TRACE("(%p, %p, %p)\n", view, rows, cols);
 
@@ -330,7 +330,7 @@ static UINT STORAGES_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *
     return ERROR_SUCCESS;
 }
 
-static UINT storages_find_row(MSISTORAGESVIEW *sv, MSIRECORD *rec, UINT *row)
+static UINT storages_find_row(struct storages_view *sv, MSIRECORD *rec, UINT *row)
 {
     LPCWSTR str;
     UINT r, i, id, data;
@@ -356,7 +356,7 @@ static UINT storages_find_row(MSISTORAGESVIEW *sv, MSIRECORD *rec, UINT *row)
 
 static UINT storages_modify_update(struct tagMSIVIEW *view, MSIRECORD *rec)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
     UINT r, row;
 
     r = storages_find_row(sv, rec, &row);
@@ -368,7 +368,7 @@ static UINT storages_modify_update(struct tagMSIVIEW *view, MSIRECORD *rec)
 
 static UINT storages_modify_assign(struct tagMSIVIEW *view, MSIRECORD *rec)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
     UINT r, row;
 
     r = storages_find_row(sv, rec, &row);
@@ -420,7 +420,7 @@ static UINT STORAGES_modify(struct tagMSIVIEW *view, MSIMODIFY eModifyMode, MSIR
 
 static UINT STORAGES_delete(struct tagMSIVIEW *view)
 {
-    MSISTORAGESVIEW *sv = (MSISTORAGESVIEW *)view;
+    struct storages_view *sv = (struct storages_view *)view;
     UINT i;
 
     TRACE("(%p)\n", view);
@@ -461,7 +461,7 @@ static const MSIVIEWOPS storages_ops =
     NULL,
 };
 
-static INT add_storages_to_table(MSISTORAGESVIEW *sv)
+static INT add_storages_to_table(struct storages_view *sv)
 {
     IEnumSTATSTG *stgenum = NULL;
     STATSTG stat;
@@ -514,12 +514,12 @@ static INT add_storages_to_table(MSISTORAGESVIEW *sv)
 
 UINT STORAGES_CreateView(MSIDATABASE *db, MSIVIEW **view)
 {
-    MSISTORAGESVIEW *sv;
+    struct storages_view *sv;
     INT rows;
 
     TRACE("(%p, %p)\n", db, view);
 
-    sv = calloc(1, sizeof(MSISTORAGESVIEW));
+    sv = calloc(1, sizeof(*sv));
     if (!sv)
         return ERROR_FUNCTION_FAILED;
 
diff --git a/dlls/msi/streams.c b/dlls/msi/streams.c
index fb83e49db8b..4c23a97d10f 100644
--- a/dlls/msi/streams.c
+++ b/dlls/msi/streams.c
@@ -38,12 +38,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 #define NUM_STREAMS_COLS    2
 
-typedef struct tagMSISTREAMSVIEW
+struct streams_view
 {
     MSIVIEW view;
     MSIDATABASE *db;
     UINT num_cols;
-} MSISTREAMSVIEW;
+};
 
 static BOOL streams_resize_table( MSIDATABASE *db, UINT size )
 {
@@ -67,7 +67,7 @@ static BOOL streams_resize_table( MSIDATABASE *db, UINT size )
 
 static UINT STREAMS_fetch_int(struct tagMSIVIEW *view, UINT row, UINT col, UINT *val)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
 
     TRACE("(%p, %d, %d, %p)\n", view, row, col, val);
 
@@ -84,7 +84,7 @@ static UINT STREAMS_fetch_int(struct tagMSIVIEW *view, UINT row, UINT col, UINT
 
 static UINT STREAMS_fetch_stream(struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
     LARGE_INTEGER pos;
     HRESULT hr;
 
@@ -112,7 +112,7 @@ static UINT STREAMS_set_string( struct tagMSIVIEW *view, UINT row, UINT col, con
 
 static UINT STREAMS_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *stream )
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
     IStream *prev;
 
     TRACE("view %p, row %u, col %u, stream %p.\n", view, row, col, stream);
@@ -125,7 +125,7 @@ static UINT STREAMS_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *stre
 
 static UINT STREAMS_set_row(struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UINT mask)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
 
     TRACE("(%p, %d, %p, %08x)\n", view, row, rec, mask);
 
@@ -162,7 +162,7 @@ static UINT STREAMS_set_row(struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, U
     return ERROR_SUCCESS;
 }
 
-static UINT streams_find_row( MSISTREAMSVIEW *sv, MSIRECORD *rec, UINT *row )
+static UINT streams_find_row( struct streams_view *sv, MSIRECORD *rec, UINT *row )
 {
     const WCHAR *str;
     UINT r, i, id, val;
@@ -188,7 +188,7 @@ static UINT streams_find_row( MSISTREAMSVIEW *sv, MSIRECORD *rec, UINT *row )
 
 static UINT STREAMS_insert_row(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row, BOOL temporary)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
     UINT i, r, num_rows = sv->db->num_streams + 1;
 
     TRACE("(%p, %p, %d, %d)\n", view, rec, row, temporary);
@@ -218,7 +218,7 @@ static UINT STREAMS_insert_row(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row
 
 static UINT STREAMS_delete_row(struct tagMSIVIEW *view, UINT row)
 {
-    MSIDATABASE *db = ((MSISTREAMSVIEW *)view)->db;
+    MSIDATABASE *db = ((struct streams_view *)view)->db;
     UINT i, num_rows = db->num_streams - 1;
     const WCHAR *name;
     WCHAR *encname;
@@ -256,7 +256,7 @@ static UINT STREAMS_close(struct tagMSIVIEW *view)
 
 static UINT STREAMS_get_dimensions(struct tagMSIVIEW *view, UINT *rows, UINT *cols)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
 
     TRACE("(%p, %p, %p)\n", view, rows, cols);
 
@@ -269,7 +269,7 @@ static UINT STREAMS_get_dimensions(struct tagMSIVIEW *view, UINT *rows, UINT *co
 static UINT STREAMS_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                      UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
 
     TRACE("(%p, %d, %p, %p, %p, %p)\n", view, n, name, type, temporary, table_name);
 
@@ -295,7 +295,7 @@ static UINT STREAMS_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *n
 
 static UINT streams_modify_update(struct tagMSIVIEW *view, MSIRECORD *rec)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
     UINT r, row;
 
     r = streams_find_row(sv, rec, &row);
@@ -307,7 +307,7 @@ static UINT streams_modify_update(struct tagMSIVIEW *view, MSIRECORD *rec)
 
 static UINT streams_modify_assign(struct tagMSIVIEW *view, MSIRECORD *rec)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
     UINT r;
 
     r = streams_find_row( sv, rec, NULL );
@@ -362,7 +362,7 @@ static UINT STREAMS_modify(struct tagMSIVIEW *view, MSIMODIFY eModifyMode, MSIRE
 
 static UINT STREAMS_delete(struct tagMSIVIEW *view)
 {
-    MSISTREAMSVIEW *sv = (MSISTREAMSVIEW *)view;
+    struct streams_view *sv = (struct streams_view *)view;
 
     TRACE("(%p)\n", view);
 
@@ -538,7 +538,7 @@ UINT msi_get_stream( MSIDATABASE *db, const WCHAR *name, IStream **ret )
 
 UINT STREAMS_CreateView(MSIDATABASE *db, MSIVIEW **view)
 {
-    MSISTREAMSVIEW *sv;
+    struct streams_view *sv;
     UINT r;
 
     TRACE("(%p, %p)\n", db, view);
@@ -547,7 +547,7 @@ UINT STREAMS_CreateView(MSIDATABASE *db, MSIVIEW **view)
     if (r != ERROR_SUCCESS)
         return r;
 
-    if (!(sv = calloc( 1, sizeof(MSISTREAMSVIEW) )))
+    if (!(sv = calloc( 1, sizeof(*sv) )))
         return ERROR_OUTOFMEMORY;
 
     sv->view.ops = &streams_ops;
diff --git a/dlls/msi/suminfo.c b/dlls/msi/suminfo.c
index de2dda8bf2b..26da79ce8e1 100644
--- a/dlls/msi/suminfo.c
+++ b/dlls/msi/suminfo.c
@@ -44,30 +44,35 @@ WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
 #include "pshpack1.h"
 
-typedef struct {
+struct property_set_header
+{
     WORD wByteOrder;
     WORD wFormat;
     DWORD dwOSVer;
     CLSID clsID;
     DWORD reserved;
-} PROPERTYSETHEADER;
+};
 
-typedef struct {
+struct format_id_offset
+{
     FMTID fmtid;
     DWORD dwOffset;
-} FORMATIDOFFSET;
+};
 
-typedef struct {
+struct property_section_header
+{
     DWORD cbSection;
     DWORD cProperties;
-} PROPERTYSECTIONHEADER;
+};
 
-typedef struct {
+struct property_id_offset
+{
     DWORD propid;
     DWORD dwOffset;
-} PROPERTYIDOFFSET;
+};
 
-typedef struct {
+struct property_data
+{
     DWORD type;
     union {
         INT i4;
@@ -78,7 +83,7 @@ typedef struct {
             BYTE str[1];
         } str;
     } u;
-} PROPERTY_DATA;
+};
 
 #include "poppack.h"
 
@@ -86,7 +91,7 @@ static HRESULT (WINAPI *pPropVariantChangeType)
     (PROPVARIANT *ppropvarDest, REFPROPVARIANT propvarSrc,
      PROPVAR_CHANGE_FLAGS flags, VARTYPE vt);
 
-#define SECT_HDR_SIZE (sizeof(PROPERTYSECTIONHEADER))
+#define SECT_HDR_SIZE (sizeof(struct property_section_header))
 
 static void free_prop( PROPVARIANT *prop )
 {
@@ -170,14 +175,14 @@ static void read_properties_from_data( PROPVARIANT *prop, LPBYTE data, DWORD sz
 {
     UINT type;
     DWORD i, size;
-    PROPERTY_DATA *propdata;
+    struct property_data *propdata;
     PROPVARIANT property, *ptr;
     PROPVARIANT changed;
-    PROPERTYIDOFFSET *idofs;
-    PROPERTYSECTIONHEADER *section_hdr;
+    struct property_id_offset *idofs;
+    struct property_section_header *section_hdr;
 
-    section_hdr = (PROPERTYSECTIONHEADER*) &data[0];
-    idofs = (PROPERTYIDOFFSET*) &data[SECT_HDR_SIZE];
+    section_hdr = (struct property_section_header *) &data[0];
+    idofs = (struct property_id_offset *)&data[SECT_HDR_SIZE];
 
     /* now set all the properties */
     for( i = 0; i < section_hdr->cProperties; i++ )
@@ -195,7 +200,7 @@ static void read_properties_from_data( PROPVARIANT *prop, LPBYTE data, DWORD sz
             break;
         }
 
-        propdata = (PROPERTY_DATA*) &data[ idofs[i].dwOffset ];
+        propdata = (struct property_data *)&data[ idofs[i].dwOffset ];
 
         /* check we don't run off the end of the data */
         size = sz - idofs[i].dwOffset - sizeof(DWORD);
@@ -237,9 +242,9 @@ static void read_properties_from_data( PROPVARIANT *prop, LPBYTE data, DWORD sz
 
 static UINT load_summary_info( MSISUMMARYINFO *si, IStream *stm )
 {
-    PROPERTYSETHEADER set_hdr;
-    FORMATIDOFFSET format_hdr;
-    PROPERTYSECTIONHEADER section_hdr;
+    struct property_set_header set_hdr;
+    struct format_id_offset format_hdr;
+    struct property_section_header section_hdr;
     LPBYTE data = NULL;
     LARGE_INTEGER ofs;
     ULONG count, sz;
@@ -362,10 +367,10 @@ static UINT write_property_to_data( const PROPVARIANT *prop, LPBYTE data )
 static UINT save_summary_info( const MSISUMMARYINFO * si, IStream *stm )
 {
     UINT ret = ERROR_FUNCTION_FAILED;
-    PROPERTYSETHEADER set_hdr;
-    FORMATIDOFFSET format_hdr;
-    PROPERTYSECTIONHEADER section_hdr;
-    PROPERTYIDOFFSET idofs[MSI_MAX_PROPS];
+    struct property_set_header set_hdr;
+    struct format_id_offset format_hdr;
+    struct property_section_header section_hdr;
+    struct property_id_offset idofs[MSI_MAX_PROPS];
     LPBYTE data = NULL;
     ULONG count, sz;
     HRESULT r;
@@ -875,8 +880,8 @@ static UINT set_prop( MSISUMMARYINFO *si, UINT uiProperty, UINT type,
     return ERROR_SUCCESS;
 }
 
-static UINT msi_set_prop( MSISUMMARYINFO *si, UINT uiProperty, UINT uiDataType,
-                          INT iValue, FILETIME *pftValue, awcstring *str )
+static UINT suminfo_set_prop( MSISUMMARYINFO *si, UINT uiProperty, UINT uiDataType, INT iValue, FILETIME *pftValue,
+                              awcstring *str )
 {
     UINT type = get_type( uiProperty );
     if( type == VT_EMPTY || type != uiDataType )
@@ -916,7 +921,7 @@ UINT WINAPI MsiSummaryInfoSetPropertyW( MSIHANDLE handle, UINT uiProperty, UINT
     str.unicode = TRUE;
     str.str.w = szValue;
 
-    ret = msi_set_prop( si, uiProperty, uiDataType, iValue, pftValue, &str );
+    ret = suminfo_set_prop( si, uiProperty, uiDataType, iValue, pftValue, &str );
     msiobj_release( &si->hdr );
     return ret;
 }
@@ -946,7 +951,7 @@ UINT WINAPI MsiSummaryInfoSetPropertyA( MSIHANDLE handle, UINT uiProperty, UINT
     str.unicode = FALSE;
     str.str.a = szValue;
 
-    ret = msi_set_prop( si, uiProperty, uiDataType, iValue, pftValue, &str );
+    ret = suminfo_set_prop( si, uiProperty, uiDataType, iValue, pftValue, &str );
     msiobj_release( &si->hdr );
     return ret;
 }
diff --git a/dlls/msi/table.c b/dlls/msi/table.c
index 5fe803cee3c..f65250766a4 100644
--- a/dlls/msi/table.c
+++ b/dlls/msi/table.c
@@ -40,22 +40,22 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 #define MSITABLE_HASH_TABLE_SIZE 37
 
-typedef struct tagMSICOLUMNHASHENTRY
+struct column_hash_entry
 {
-    struct tagMSICOLUMNHASHENTRY *next;
+    struct column_hash_entry *next;
     UINT value;
     UINT row;
-} MSICOLUMNHASHENTRY;
+};
 
-typedef struct tagMSICOLUMNINFO
+struct column_info
 {
     LPCWSTR tablename;
     UINT    number;
     LPCWSTR colname;
     UINT    type;
     UINT    offset;
-    MSICOLUMNHASHENTRY **hash_table;
-} MSICOLUMNINFO;
+    struct column_hash_entry **hash_table;
+};
 
 struct tagMSITABLE
 {
@@ -63,7 +63,7 @@ struct tagMSITABLE
     BOOL *data_persistent;
     UINT row_count;
     struct list entry;
-    MSICOLUMNINFO *colinfo;
+    struct column_info *colinfo;
     UINT col_count;
     MSICONDITION persistent;
     LONG ref_count;
@@ -71,20 +71,22 @@ struct tagMSITABLE
 };
 
 /* information for default tables */
-static const MSICOLUMNINFO _Columns_cols[4] = {
+static const struct column_info _Columns_cols[4] =
+{
     { L"_Columns", 1, L"Table",  MSITYPE_VALID | MSITYPE_STRING | MSITYPE_KEY | 64, 0, NULL },
     { L"_Columns", 2, L"Number", MSITYPE_VALID | MSITYPE_KEY | 2,     2, NULL },
     { L"_Columns", 3, L"Name",   MSITYPE_VALID | MSITYPE_STRING | 64, 4, NULL },
     { L"_Columns", 4, L"Type",   MSITYPE_VALID | 2,                   6, NULL },
 };
 
-static const MSICOLUMNINFO _Tables_cols[1] = {
+static const struct column_info _Tables_cols[1] =
+{
     { L"_Tables",  1, L"Name",   MSITYPE_VALID | MSITYPE_STRING | MSITYPE_KEY | 64, 0, NULL },
 };
 
 #define MAX_STREAM_NAME 0x1f
 
-static inline UINT bytes_per_column( MSIDATABASE *db, const MSICOLUMNINFO *col, UINT bytes_per_strref )
+static inline UINT bytes_per_column( MSIDATABASE *db, const struct column_info *col, UINT bytes_per_strref )
 {
     if( MSITYPE_IS_BINARY(col->type) )
         return 2;
@@ -353,7 +355,7 @@ end:
     return ret;
 }
 
-static void free_colinfo( MSICOLUMNINFO *colinfo, UINT count )
+static void free_colinfo( struct column_info *colinfo, UINT count )
 {
     UINT i;
     for (i = 0; i < count; i++) free( colinfo[i].hash_table );
@@ -371,9 +373,9 @@ static void free_table( MSITABLE *table )
     free( table );
 }
 
-static UINT msi_table_get_row_size( MSIDATABASE *db, const MSICOLUMNINFO *cols, UINT count, UINT bytes_per_strref )
+static UINT table_get_row_size( MSIDATABASE *db, const struct column_info *cols, UINT count, UINT bytes_per_strref )
 {
-    const MSICOLUMNINFO *last_col;
+    const struct column_info *last_col;
 
     if (!count)
         return 0;
@@ -396,8 +398,8 @@ static UINT read_table_from_storage( MSIDATABASE *db, MSITABLE *t, IStorage *stg
 
     TRACE("%s\n",debugstr_w(t->name));
 
-    row_size = msi_table_get_row_size( db, t->colinfo, t->col_count, db->bytes_per_strref );
-    row_size_mem = msi_table_get_row_size( db, t->colinfo, t->col_count, LONG_STR_BYTES );
+    row_size = table_get_row_size( db, t->colinfo, t->col_count, db->bytes_per_strref );
+    row_size_mem = table_get_row_size( db, t->colinfo, t->col_count, LONG_STR_BYTES );
 
     /* if we can't read the table, just assume that it's empty */
     read_stream_data( stg, t->name, TRUE, &rawdata, &rawsize );
@@ -489,7 +491,7 @@ static MSITABLE *find_cached_table( MSIDATABASE *db, LPCWSTR name )
     return NULL;
 }
 
-static void table_calc_column_offsets( MSIDATABASE *db, MSICOLUMNINFO *colinfo, DWORD count )
+static void table_calc_column_offsets( MSIDATABASE *db, struct column_info *colinfo, DWORD count )
 {
     DWORD i;
 
@@ -506,9 +508,9 @@ static void table_calc_column_offsets( MSIDATABASE *db, MSICOLUMNINFO *colinfo,
     }
 }
 
-static UINT get_defaulttablecolumns( MSIDATABASE *db, LPCWSTR name, MSICOLUMNINFO *colinfo, UINT *sz )
+static UINT get_defaulttablecolumns( MSIDATABASE *db, const WCHAR *name, struct column_info *colinfo, UINT *sz )
 {
-    const MSICOLUMNINFO *p;
+    const struct column_info *p;
     DWORD i, n;
 
     TRACE("%s\n", debugstr_w(name));
@@ -535,12 +537,12 @@ static UINT get_defaulttablecolumns( MSIDATABASE *db, LPCWSTR name, MSICOLUMNINF
     return ERROR_SUCCESS;
 }
 
-static UINT get_tablecolumns( MSIDATABASE *db, LPCWSTR szTableName, MSICOLUMNINFO *colinfo, UINT *sz );
+static UINT get_tablecolumns( MSIDATABASE *, const WCHAR *, struct column_info *, UINT * );
 
-static UINT table_get_column_info( MSIDATABASE *db, LPCWSTR name, MSICOLUMNINFO **pcols, UINT *pcount )
+static UINT table_get_column_info( MSIDATABASE *db, const WCHAR *name, struct column_info **pcols, UINT *pcount )
 {
     UINT r, column_count = 0;
-    MSICOLUMNINFO *columns;
+    struct column_info *columns;
 
     /* get the number of columns in this table */
     column_count = 0;
@@ -556,7 +558,7 @@ static UINT table_get_column_info( MSIDATABASE *db, LPCWSTR name, MSICOLUMNINFO
 
     TRACE("table %s found\n", debugstr_w(name));
 
-    columns = malloc( column_count * sizeof(MSICOLUMNINFO) );
+    columns = malloc( column_count * sizeof(*columns) );
     if (!columns)
         return ERROR_FUNCTION_FAILED;
 
@@ -626,7 +628,7 @@ static UINT read_table_int( BYTE *const *data, UINT row, UINT col, UINT bytes )
     return ret;
 }
 
-static UINT get_tablecolumns( MSIDATABASE *db, LPCWSTR szTableName, MSICOLUMNINFO *colinfo, UINT *sz )
+static UINT get_tablecolumns( MSIDATABASE *db, const WCHAR *szTableName, struct column_info *colinfo, UINT *sz )
 {
     UINT r, i, n = 0, table_id, count, maxcount = *sz;
     MSITABLE *table = NULL;
@@ -738,7 +740,7 @@ UINT msi_create_table( MSIDATABASE *db, LPCWSTR name, column_info *col_info,
     for( col = col_info; col; col = col->next )
         table->col_count++;
 
-    table->colinfo = malloc( table->col_count * sizeof(MSICOLUMNINFO) );
+    table->colinfo = malloc( table->col_count * sizeof(*table->colinfo) );
     if (!table->colinfo)
     {
         free_table( table );
@@ -867,7 +869,7 @@ static UINT save_table( MSIDATABASE *db, const MSITABLE *t, UINT bytes_per_strre
 
     TRACE("Saving %s\n", debugstr_w( t->name ) );
 
-    row_size = msi_table_get_row_size( db, t->colinfo, t->col_count, bytes_per_strref );
+    row_size = table_get_row_size( db, t->colinfo, t->col_count, bytes_per_strref );
     row_count = t->row_count;
     for (i = 0; i < t->row_count; i++)
     {
@@ -930,7 +932,7 @@ err:
     return r;
 }
 
-static void msi_update_table_columns( MSIDATABASE *db, LPCWSTR name )
+static void update_table_columns( MSIDATABASE *db, const WCHAR *name )
 {
     MSITABLE *table;
     UINT size, offset, old_count;
@@ -945,7 +947,7 @@ static void msi_update_table_columns( MSIDATABASE *db, LPCWSTR name )
     table_get_column_info( db, name, &table->colinfo, &table->col_count );
     if (!table->col_count) return;
 
-    size = msi_table_get_row_size( db, table->colinfo, table->col_count, LONG_STR_BYTES );
+    size = table_get_row_size( db, table->colinfo, table->col_count, LONG_STR_BYTES );
     offset = table->colinfo[table->col_count - 1].offset;
 
     for ( n = 0; n < table->row_count; n++ )
@@ -991,20 +993,20 @@ BOOL TABLE_Exists( MSIDATABASE *db, LPCWSTR name )
 
 /* below is the query interface to a table */
 
-typedef struct tagMSITABLEVIEW
+struct table_view
 {
     MSIVIEW        view;
     MSIDATABASE   *db;
     MSITABLE      *table;
-    MSICOLUMNINFO *columns;
+    struct column_info *columns;
     UINT           num_cols;
     UINT           row_size;
     WCHAR          name[1];
-} MSITABLEVIEW;
+};
 
 static UINT TABLE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT offset, n;
 
     if( !tv->table )
@@ -1039,7 +1041,7 @@ static UINT TABLE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *
     return ERROR_SUCCESS;
 }
 
-static UINT get_stream_name( const MSITABLEVIEW *tv, UINT row, WCHAR **pstname )
+static UINT get_stream_name( const struct table_view *tv, UINT row, WCHAR **pstname )
 {
     LPWSTR p, stname = NULL;
     UINT i, r, type, ival;
@@ -1131,7 +1133,7 @@ err:
  */
 static UINT TABLE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT r;
     WCHAR *name;
 
@@ -1154,7 +1156,7 @@ static UINT TABLE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, ISt
 }
 
 /* Set a table value, i.e. preadjusted integer or string ID. */
-static UINT table_set_bytes( MSITABLEVIEW *tv, UINT row, UINT col, UINT val )
+static UINT table_set_bytes( struct table_view *tv, UINT row, UINT col, UINT val )
 {
     UINT offset, n, i;
 
@@ -1191,7 +1193,7 @@ static UINT table_set_bytes( MSITABLEVIEW *tv, UINT row, UINT col, UINT val )
     return ERROR_SUCCESS;
 }
 
-static UINT int_to_table_storage( const MSITABLEVIEW *tv, UINT col, int val, UINT *ret )
+static UINT int_to_table_storage( const struct table_view *tv, UINT col, int val, UINT *ret )
 {
     if ((tv->columns[col-1].type & MSI_DATASIZEMASK) == 2)
     {
@@ -1213,7 +1215,7 @@ static UINT int_to_table_storage( const MSITABLEVIEW *tv, UINT col, int val, UIN
 
 static UINT TABLE_set_int( MSIVIEW *view, UINT row, UINT col, int val )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW *)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT r, table_int;
 
     TRACE("row %u, col %u, val %d.\n", row, col, val);
@@ -1240,7 +1242,7 @@ static UINT TABLE_set_int( MSIVIEW *view, UINT row, UINT col, int val )
 
 static UINT TABLE_set_string( MSIVIEW *view, UINT row, UINT col, const WCHAR *val, int len )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW *)view;
+    struct table_view *tv = (struct table_view *)view;
     BOOL persistent;
     UINT id, r;
 
@@ -1277,7 +1279,7 @@ static UINT TABLE_set_string( MSIVIEW *view, UINT row, UINT col, const WCHAR *va
 
 static UINT TABLE_get_row( struct tagMSIVIEW *view, UINT row, MSIRECORD **rec )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW *)view;
+    struct table_view *tv = (struct table_view *)view;
 
     if (!tv->table)
         return ERROR_INVALID_PARAMETER;
@@ -1339,7 +1341,7 @@ done:
 
 static UINT TABLE_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *stream )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW *)view;
+    struct table_view *tv = (struct table_view *)view;
     WCHAR *name;
     UINT r;
 
@@ -1353,9 +1355,9 @@ static UINT TABLE_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *stream
     return r;
 }
 
-static UINT get_table_value_from_record( MSITABLEVIEW *tv, MSIRECORD *rec, UINT iField, UINT *pvalue )
+static UINT get_table_value_from_record( struct table_view *tv, MSIRECORD *rec, UINT iField, UINT *pvalue )
 {
-    MSICOLUMNINFO columninfo;
+    struct column_info columninfo;
     UINT r;
 
     if (!iField || iField > tv->num_cols || MSI_RecordIsNull( rec, iField ))
@@ -1387,7 +1389,7 @@ static UINT get_table_value_from_record( MSITABLEVIEW *tv, MSIRECORD *rec, UINT
 
 static UINT TABLE_set_row( struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UINT mask )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT i, val, r = ERROR_SUCCESS;
 
     if ( !tv->table )
@@ -1472,7 +1474,7 @@ static UINT TABLE_set_row( struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UI
 
 static UINT table_create_new_row( struct tagMSIVIEW *view, UINT *num, BOOL temporary )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     BYTE **p, *row;
     BOOL *b;
     UINT sz;
@@ -1531,7 +1533,7 @@ static UINT table_create_new_row( struct tagMSIVIEW *view, UINT *num, BOOL tempo
 
 static UINT TABLE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     TRACE("%p %p\n", tv, record);
 
@@ -1549,7 +1551,7 @@ static UINT TABLE_close( struct tagMSIVIEW *view )
 
 static UINT TABLE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     TRACE("%p %p %p\n", view, rows, cols );
 
@@ -1569,7 +1571,7 @@ static UINT TABLE_get_column_info( struct tagMSIVIEW *view,
                 UINT n, LPCWSTR *name, UINT *type, BOOL *temporary,
                 LPCWSTR *table_name )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     TRACE("%p %d %p %p\n", tv, n, name, type );
 
@@ -1599,9 +1601,9 @@ static UINT TABLE_get_column_info( struct tagMSIVIEW *view,
     return ERROR_SUCCESS;
 }
 
-static UINT msi_table_find_row( MSITABLEVIEW *tv, MSIRECORD *rec, UINT *row, UINT *column );
+static UINT table_find_row( struct table_view *, MSIRECORD *, UINT *, UINT * );
 
-static UINT table_validate_new( MSITABLEVIEW *tv, MSIRECORD *rec, UINT *column )
+static UINT table_validate_new( struct table_view *tv, MSIRECORD *rec, UINT *column )
 {
     UINT r, row, i;
 
@@ -1638,14 +1640,14 @@ static UINT table_validate_new( MSITABLEVIEW *tv, MSIRECORD *rec, UINT *column )
     }
 
     /* check there are no duplicate keys */
-    r = msi_table_find_row( tv, rec, &row, column );
+    r = table_find_row( tv, rec, &row, column );
     if (r == ERROR_SUCCESS)
         return ERROR_FUNCTION_FAILED;
 
     return ERROR_SUCCESS;
 }
 
-static int compare_record( MSITABLEVIEW *tv, UINT row, MSIRECORD *rec )
+static int compare_record( struct table_view *tv, UINT row, MSIRECORD *rec )
 {
     UINT r, i, ivalue, x;
 
@@ -1678,7 +1680,7 @@ static int compare_record( MSITABLEVIEW *tv, UINT row, MSIRECORD *rec )
     return 1;
 }
 
-static int find_insert_index( MSITABLEVIEW *tv, MSIRECORD *rec )
+static int find_insert_index( struct table_view *tv, MSIRECORD *rec )
 {
     int idx, c, low = 0, high = tv->table->row_count - 1;
 
@@ -1705,7 +1707,7 @@ static int find_insert_index( MSITABLEVIEW *tv, MSIRECORD *rec )
 
 static UINT TABLE_insert_row( struct tagMSIVIEW *view, MSIRECORD *rec, UINT row, BOOL temporary )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT i, r;
 
     TRACE("%p %p %s\n", tv, rec, temporary ? "TRUE" : "FALSE" );
@@ -1738,7 +1740,7 @@ static UINT TABLE_insert_row( struct tagMSIVIEW *view, MSIRECORD *rec, UINT row,
 
 static UINT TABLE_delete_row( struct tagMSIVIEW *view, UINT row )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT r, num_rows, num_cols, i;
 
     TRACE("%p %d\n", tv, row);
@@ -1774,9 +1776,9 @@ static UINT TABLE_delete_row( struct tagMSIVIEW *view, UINT row )
     return ERROR_SUCCESS;
 }
 
-static UINT msi_table_update(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row)
+static UINT table_update(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW *)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT r, new_row;
 
     /* FIXME: MsiViewFetch should set rec index 0 to some ID that
@@ -1786,7 +1788,7 @@ static UINT msi_table_update(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row)
     if (!tv->table)
         return ERROR_INVALID_PARAMETER;
 
-    r = msi_table_find_row(tv, rec, &new_row, NULL);
+    r = table_find_row(tv, rec, &new_row, NULL);
     if (r != ERROR_SUCCESS)
     {
         ERR("can't find row to modify\n");
@@ -1800,22 +1802,22 @@ static UINT msi_table_update(struct tagMSIVIEW *view, MSIRECORD *rec, UINT row)
     return TABLE_set_row(view, new_row, rec, (1 << tv->num_cols) - 1);
 }
 
-static UINT msi_table_assign(struct tagMSIVIEW *view, MSIRECORD *rec)
+static UINT table_assign(struct tagMSIVIEW *view, MSIRECORD *rec)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW *)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT r, row;
 
     if (!tv->table)
         return ERROR_INVALID_PARAMETER;
 
-    r = msi_table_find_row(tv, rec, &row, NULL);
+    r = table_find_row(tv, rec, &row, NULL);
     if (r == ERROR_SUCCESS)
         return TABLE_set_row(view, row, rec, (1 << tv->num_cols) - 1);
     else
         return TABLE_insert_row( view, rec, -1, FALSE );
 }
 
-static UINT msi_refresh_record( struct tagMSIVIEW *view, MSIRECORD *rec, UINT row )
+static UINT refresh_record( struct tagMSIVIEW *view, MSIRECORD *rec, UINT row )
 {
     MSIRECORD *curr;
     UINT r, i, count;
@@ -1838,7 +1840,7 @@ static UINT msi_refresh_record( struct tagMSIVIEW *view, MSIRECORD *rec, UINT ro
 static UINT TABLE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                           MSIRECORD *rec, UINT row)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     UINT r, frow, column;
 
     TRACE("%p %d %p\n", view, eModifyMode, rec );
@@ -1873,20 +1875,20 @@ static UINT TABLE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
         break;
 
     case MSIMODIFY_REFRESH:
-        r = msi_refresh_record( view, rec, row );
+        r = refresh_record( view, rec, row );
         break;
 
     case MSIMODIFY_UPDATE:
-        r = msi_table_update( view, rec, row );
+        r = table_update( view, rec, row );
         break;
 
     case MSIMODIFY_ASSIGN:
-        r = msi_table_assign( view, rec );
+        r = table_assign( view, rec );
         break;
 
     case MSIMODIFY_MERGE:
         /* check row that matches this record */
-        r = msi_table_find_row( tv, rec, &frow, &column );
+        r = table_find_row( tv, rec, &frow, &column );
         if (r != ERROR_SUCCESS)
         {
             r = table_validate_new( tv, rec, NULL );
@@ -1912,7 +1914,7 @@ static UINT TABLE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 
 static UINT TABLE_delete( struct tagMSIVIEW *view )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     TRACE("%p\n", view );
 
@@ -1926,7 +1928,7 @@ static UINT TABLE_delete( struct tagMSIVIEW *view )
 
 static UINT TABLE_add_ref(struct tagMSIVIEW *view)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     TRACE( "%p, %ld\n", view, tv->table->ref_count );
     return InterlockedIncrement(&tv->table->ref_count);
@@ -1934,7 +1936,7 @@ static UINT TABLE_add_ref(struct tagMSIVIEW *view)
 
 static UINT TABLE_remove_column(struct tagMSIVIEW *view, UINT number)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     MSIRECORD *rec = NULL;
     MSIVIEW *columns = NULL;
     UINT row, r;
@@ -1967,7 +1969,7 @@ static UINT TABLE_remove_column(struct tagMSIVIEW *view, UINT number)
         return r;
     }
 
-    r = msi_table_find_row((MSITABLEVIEW *)columns, rec, &row, NULL);
+    r = table_find_row((struct table_view *)columns, rec, &row, NULL);
     if (r != ERROR_SUCCESS)
         goto done;
 
@@ -1975,7 +1977,7 @@ static UINT TABLE_remove_column(struct tagMSIVIEW *view, UINT number)
     if (r != ERROR_SUCCESS)
         goto done;
 
-    msi_update_table_columns(tv->db, tv->name);
+    update_table_columns(tv->db, tv->name);
 
 done:
     msiobj_release(&rec->hdr);
@@ -1985,7 +1987,7 @@ done:
 
 static UINT TABLE_release(struct tagMSIVIEW *view)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     INT ref = tv->table->ref_count;
     UINT r;
     INT i;
@@ -2025,8 +2027,8 @@ static UINT TABLE_add_column(struct tagMSIVIEW *view, LPCWSTR column,
 {
     UINT i, r, table_id, col_id, size, offset;
     BOOL temporary = type & MSITYPE_TEMPORARY;
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
-    MSICOLUMNINFO *colinfo;
+    struct table_view *tv = (struct table_view *)view;
+    struct column_info *colinfo;
 
     if (temporary && !hold && !tv->table->ref_count)
         return ERROR_SUCCESS;
@@ -2061,7 +2063,7 @@ static UINT TABLE_add_column(struct tagMSIVIEW *view, LPCWSTR column,
 
     table_calc_column_offsets( tv->db, tv->table->colinfo, tv->table->col_count);
 
-    size = msi_table_get_row_size( tv->db, tv->table->colinfo, tv->table->col_count, LONG_STR_BYTES );
+    size = table_get_row_size( tv->db, tv->table->colinfo, tv->table->col_count, LONG_STR_BYTES );
     offset = tv->table->colinfo[tv->table->col_count - 1].offset;
     for (i = 0; i < tv->table->row_count; i++)
     {
@@ -2117,7 +2119,7 @@ static UINT TABLE_add_column(struct tagMSIVIEW *view, LPCWSTR column,
 
 static UINT TABLE_drop(struct tagMSIVIEW *view)
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     MSIVIEW *tables = NULL;
     MSIRECORD *rec = NULL;
     UINT r, row;
@@ -2145,7 +2147,7 @@ static UINT TABLE_drop(struct tagMSIVIEW *view)
         return r;
     }
 
-    r = msi_table_find_row((MSITABLEVIEW *)tables, rec, &row, NULL);
+    r = table_find_row((struct table_view *)tables, rec, &row, NULL);
     if (r != ERROR_SUCCESS)
         goto done;
 
@@ -2188,7 +2190,7 @@ static const MSIVIEWOPS table_ops =
 
 UINT TABLE_CreateView( MSIDATABASE *db, LPCWSTR name, MSIVIEW **view )
 {
-    MSITABLEVIEW *tv ;
+    struct table_view *tv ;
     UINT r, sz;
 
     TRACE("%p %s %p\n", db, debugstr_w(name), view );
@@ -2198,7 +2200,7 @@ UINT TABLE_CreateView( MSIDATABASE *db, LPCWSTR name, MSIVIEW **view )
     else if ( !wcscmp( name, L"_Storages" ) )
         return STORAGES_CreateView( db, view );
 
-    sz = FIELD_OFFSET( MSITABLEVIEW, name[lstrlenW( name ) + 1] );
+    sz = FIELD_OFFSET( struct table_view, name[lstrlenW( name ) + 1] );
     tv = calloc( 1, sz );
     if( !tv )
         return ERROR_FUNCTION_FAILED;
@@ -2218,7 +2220,7 @@ UINT TABLE_CreateView( MSIDATABASE *db, LPCWSTR name, MSIVIEW **view )
     tv->db = db;
     tv->columns = tv->table->colinfo;
     tv->num_cols = tv->table->col_count;
-    tv->row_size = msi_table_get_row_size( db, tv->table->colinfo, tv->table->col_count, LONG_STR_BYTES );
+    tv->row_size = table_get_row_size( db, tv->table->colinfo, tv->table->col_count, LONG_STR_BYTES );
 
     TRACE("%s one row is %d bytes\n", debugstr_w(name), tv->row_size );
 
@@ -2228,7 +2230,7 @@ UINT TABLE_CreateView( MSIDATABASE *db, LPCWSTR name, MSIVIEW **view )
     return ERROR_SUCCESS;
 }
 
-static WCHAR* create_key_string(MSITABLEVIEW *tv, MSIRECORD *rec)
+static WCHAR *create_key_string(struct table_view *tv, MSIRECORD *rec)
 {
     DWORD i, p, len, key_len = 0;
     WCHAR *key;
@@ -2260,7 +2262,7 @@ static WCHAR* create_key_string(MSITABLEVIEW *tv, MSIRECORD *rec)
     return key;
 }
 
-static UINT msi_record_stream_name( const MSITABLEVIEW *tv, MSIRECORD *rec, LPWSTR name, DWORD *len )
+static UINT record_stream_name( const struct table_view *tv, MSIRECORD *rec, WCHAR *name, DWORD *len )
 {
     UINT p = 0, i, r;
     DWORD l;
@@ -2295,7 +2297,7 @@ static UINT msi_record_stream_name( const MSITABLEVIEW *tv, MSIRECORD *rec, LPWS
 
 static UINT TransformView_fetch_int( MSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     if (!tv->table || col > tv->table->col_count)
     {
@@ -2307,7 +2309,7 @@ static UINT TransformView_fetch_int( MSIVIEW *view, UINT row, UINT col, UINT *va
 
 static UINT TransformView_fetch_stream( MSIVIEW *view, UINT row, UINT col, IStream **stm )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
 
     if (!tv->table || col > tv->table->col_count)
     {
@@ -2322,7 +2324,7 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
     static const WCHAR query_pfx[] =
         L"INSERT INTO `_TransformView` (`new`, `Table`, `Column`, `Row`, `Data`, `Current`) VALUES (1, '";
 
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     WCHAR buf[256], *query;
     MSIRECORD *old_rec;
     MSIQUERY *q;
@@ -2362,7 +2364,7 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
         qlen += wcslen( tv->columns[i].colname ) + 3;
         qlen += wcslen( key ) + 3;
         if (MSITYPE_IS_BINARY( tv->columns[i].type ))
-            r = msi_record_stream_name( tv, rec, NULL, &len );
+            r = record_stream_name( tv, rec, NULL, &len );
         else
             r = MSI_RecordGetStringW( rec, i + 1, NULL, &len );
         if (r != ERROR_SUCCESS)
@@ -2418,7 +2420,7 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
         query[p++] = '\'';
         len = qlen - p;
         if (MSITYPE_IS_BINARY( tv->columns[i].type ))
-            msi_record_stream_name( tv, rec, query + p, &len );
+            record_stream_name( tv, rec, query + p, &len );
         else
             MSI_RecordGetStringW( rec, i + 1, query + p, &len );
         p += len;
@@ -2463,7 +2465,7 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
     return ERROR_SUCCESS;
 }
 
-static UINT TransformView_create_table( MSITABLEVIEW *tv, MSIRECORD *rec )
+static UINT TransformView_create_table( struct table_view *tv, MSIRECORD *rec )
 {
     static const WCHAR query_fmt[] =
         L"INSERT INTO `_TransformView` (`Table`, `Column`, `new`) VALUES ('%s', 'CREATE', 1)";
@@ -2498,7 +2500,7 @@ static UINT TransformView_create_table( MSITABLEVIEW *tv, MSIRECORD *rec )
     return r;
 }
 
-static UINT TransformView_add_column( MSITABLEVIEW *tv, MSIRECORD *rec )
+static UINT TransformView_add_column( struct table_view *tv, MSIRECORD *rec )
 {
     static const WCHAR query_pfx[] =
         L"INSERT INTO `_TransformView` (`new`, `Table`, `Current`, `Column`, `Data`) VALUES (1, '";
@@ -2557,7 +2559,7 @@ static UINT TransformView_insert_row( MSIVIEW *view, MSIRECORD *rec, UINT row, B
     static const WCHAR query_fmt[] =
         L"INSERT INTO `_TransformView` (`new`, `Table`, `Column`, `Row`) VALUES (1, '%s', 'INSERT', '%s')";
 
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     WCHAR buf[256], *query = buf;
     MSIQUERY *q;
     WCHAR *key;
@@ -2601,7 +2603,7 @@ static UINT TransformView_insert_row( MSIVIEW *view, MSIRECORD *rec, UINT row, B
     return TransformView_set_row( view, row, rec, ~0 );
 }
 
-static UINT TransformView_drop_table( MSITABLEVIEW *tv, UINT row )
+static UINT TransformView_drop_table( struct table_view *tv, UINT row )
 {
     static const WCHAR query_pfx[] = L"INSERT INTO `_TransformView` ( `new`, `Table`, `Column` ) VALUES ( 1, '";
     static const WCHAR query_sfx[] = L"', 'DROP' )";
@@ -2651,7 +2653,7 @@ static UINT TransformView_delete_row( MSIVIEW *view, UINT row )
     static const WCHAR query_column[] = L"', 'DELETE', '";
     static const WCHAR query_sfx[] = L"')";
 
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     WCHAR *key, buf[256], *query = buf;
     UINT r, len, name_len, key_len;
     MSIRECORD *rec;
@@ -2734,7 +2736,7 @@ static UINT TransformView_get_column_info( MSIVIEW *view, UINT n, LPCWSTR *name,
 
 static UINT TransformView_delete( MSIVIEW *view )
 {
-    MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
+    struct table_view *tv = (struct table_view *)view;
     if (!tv->table || tv->columns != tv->table->colinfo)
         free( tv->columns );
     return TABLE_delete( view );
@@ -2770,8 +2772,8 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
 
     WCHAR buf[256], *query = buf;
     UINT r, len, name_len, size, add_col;
-    MSICOLUMNINFO *colinfo;
-    MSITABLEVIEW *tv;
+    struct column_info *colinfo;
+    struct table_view *tv;
     MSIRECORD *rec;
     MSIQUERY *q;
 
@@ -2781,7 +2783,7 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
     if (r == ERROR_INVALID_PARAMETER)
     {
         /* table does not exist */
-        size = FIELD_OFFSET( MSITABLEVIEW, name[name_len + 1] );
+        size = FIELD_OFFSET( struct table_view, name[name_len + 1] );
         tv = calloc( 1, size );
         if (!tv)
             return ERROR_OUTOFMEMORY;
@@ -2796,7 +2798,7 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
     }
     else
     {
-        tv = (MSITABLEVIEW*)*view;
+        tv = (struct table_view *)*view;
     }
 
     tv->view.ops = &transform_view_ops;
@@ -2946,7 +2948,7 @@ static UINT read_raw_int(const BYTE *data, UINT col, UINT bytes)
     return ret;
 }
 
-static UINT msi_record_encoded_stream_name( const MSITABLEVIEW *tv, MSIRECORD *rec, LPWSTR *pstname )
+static UINT record_encoded_stream_name( const struct table_view *tv, MSIRECORD *rec, WCHAR **pstname )
 {
     UINT r;
     DWORD len;
@@ -2954,7 +2956,7 @@ static UINT msi_record_encoded_stream_name( const MSITABLEVIEW *tv, MSIRECORD *r
 
     TRACE("%p %p\n", tv, rec);
 
-    r = msi_record_stream_name( tv, rec, NULL, &len );
+    r = record_stream_name( tv, rec, NULL, &len );
     if (r != ERROR_SUCCESS)
         return r;
     len++;
@@ -2963,7 +2965,7 @@ static UINT msi_record_encoded_stream_name( const MSITABLEVIEW *tv, MSIRECORD *r
     if (!name)
         return ERROR_OUTOFMEMORY;
 
-    r = msi_record_stream_name( tv, rec, name, &len );
+    r = record_stream_name( tv, rec, name, &len );
     if (r != ERROR_SUCCESS)
     {
         free( name );
@@ -2975,12 +2977,12 @@ static UINT msi_record_encoded_stream_name( const MSITABLEVIEW *tv, MSIRECORD *r
     return ERROR_SUCCESS;
 }
 
-static MSIRECORD *msi_get_transform_record( const MSITABLEVIEW *tv, const string_table *st,
-                                            IStorage *stg, const BYTE *rawdata, UINT bytes_per_strref )
+static MSIRECORD *get_transform_record( const struct table_view *tv, const string_table *st, IStorage *stg,
+                                        const BYTE *rawdata, UINT bytes_per_strref )
 {
     UINT i, val, ofs = 0;
     USHORT mask;
-    MSICOLUMNINFO *columns = tv->columns;
+    struct column_info *columns = tv->columns;
     MSIRECORD *rec;
 
     mask = rawdata[0] | (rawdata[1] << 8);
@@ -3007,7 +3009,7 @@ static MSIRECORD *msi_get_transform_record( const MSITABLEVIEW *tv, const string
 
             ofs += bytes_per_column( tv->db, &columns[i], bytes_per_strref );
 
-            r = msi_record_encoded_stream_name( tv, rec, &encname );
+            r = record_encoded_stream_name( tv, rec, &encname );
             if ( r != ERROR_SUCCESS )
             {
                 msiobj_release( &rec->hdr );
@@ -3074,7 +3076,7 @@ static void dump_table( const string_table *st, const USHORT *rawdata, UINT raws
     }
 }
 
-static UINT* msi_record_to_row( const MSITABLEVIEW *tv, MSIRECORD *rec )
+static UINT *record_to_row( const struct table_view *tv, MSIRECORD *rec )
 {
     UINT i, r, *data;
 
@@ -3118,7 +3120,7 @@ static UINT* msi_record_to_row( const MSITABLEVIEW *tv, MSIRECORD *rec )
     return data;
 }
 
-static UINT msi_row_matches( MSITABLEVIEW *tv, UINT row, const UINT *data, UINT *column )
+static UINT row_matches( struct table_view *tv, UINT row, const UINT *data, UINT *column )
 {
     UINT i, r, x, ret = ERROR_FUNCTION_FAILED;
 
@@ -3147,16 +3149,16 @@ static UINT msi_row_matches( MSITABLEVIEW *tv, UINT row, const UINT *data, UINT
     return ret;
 }
 
-static UINT msi_table_find_row( MSITABLEVIEW *tv, MSIRECORD *rec, UINT *row, UINT *column )
+static UINT table_find_row( struct table_view *tv, MSIRECORD *rec, UINT *row, UINT *column )
 {
     UINT i, r = ERROR_FUNCTION_FAILED, *data;
 
-    data = msi_record_to_row( tv, rec );
+    data = record_to_row( tv, rec );
     if( !data )
         return r;
     for( i = 0; i < tv->table->row_count; i++ )
     {
-        r = msi_row_matches( tv, i, data, column );
+        r = row_matches( tv, i, data, column );
         if( r == ERROR_SUCCESS )
         {
             *row = i;
@@ -3167,18 +3169,17 @@ static UINT msi_table_find_row( MSITABLEVIEW *tv, MSIRECORD *rec, UINT *row, UIN
     return r;
 }
 
-typedef struct
+struct transform_data
 {
     struct list entry;
     LPWSTR name;
-} TRANSFORMDATA;
+};
 
-static UINT msi_table_load_transform( MSIDATABASE *db, IStorage *stg,
-                                      string_table *st, TRANSFORMDATA *transform,
-                                      UINT bytes_per_strref, int err_cond )
+static UINT table_load_transform( MSIDATABASE *db, IStorage *stg, string_table *st, struct transform_data *transform,
+                                  UINT bytes_per_strref, int err_cond )
 {
     BYTE *rawdata = NULL;
-    MSITABLEVIEW *tv = NULL;
+    struct table_view *tv = NULL;
     UINT r, n, sz, i, mask, num_cols, colcol = 0, rawsize = 0;
     MSIRECORD *rec = NULL;
     WCHAR coltable[32];
@@ -3275,7 +3276,7 @@ static UINT msi_table_load_transform( MSIDATABASE *db, IStorage *stg,
             break;
         }
 
-        rec = msi_get_transform_record( tv, st, stg, &rawdata[n], bytes_per_strref );
+        rec = get_transform_record( tv, st, stg, &rawdata[n], bytes_per_strref );
         if (rec)
         {
             WCHAR table[32];
@@ -3309,7 +3310,7 @@ static UINT msi_table_load_transform( MSIDATABASE *db, IStorage *stg,
             if (TRACE_ON(msidb)) dump_record( rec );
 
             if (tv->table)
-                r = msi_table_find_row( tv, rec, &row, NULL );
+                r = table_find_row( tv, rec, &row, NULL );
             else
                 r = ERROR_FUNCTION_FAILED;
             if (r == ERROR_SUCCESS)
@@ -3344,9 +3345,8 @@ static UINT msi_table_load_transform( MSIDATABASE *db, IStorage *stg,
                     WARN("failed to insert row %u\n", r);
             }
 
-            if (!(err_cond & MSITRANSFORM_ERROR_VIEWTRANSFORM) &&
-                    !wcscmp( name, L"_Columns" ))
-                msi_update_table_columns( db, table );
+            if (!(err_cond & MSITRANSFORM_ERROR_VIEWTRANSFORM) && !wcscmp( name, L"_Columns" ))
+                update_table_columns( db, table );
 
             msiobj_release( &rec->hdr );
         }
@@ -3372,8 +3372,8 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
 {
     struct list transforms;
     IEnumSTATSTG *stgenum = NULL;
-    TRANSFORMDATA *transform;
-    TRANSFORMDATA *tables = NULL, *columns = NULL;
+    struct transform_data *transform;
+    struct transform_data *tables = NULL, *columns = NULL;
     HRESULT hr;
     STATSTG stat;
     string_table *strings;
@@ -3396,7 +3396,7 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
 
     while ( TRUE )
     {
-        MSITABLEVIEW *tv = NULL;
+        struct table_view *tv = NULL;
         WCHAR name[0x40];
         ULONG count = 0;
 
@@ -3413,7 +3413,7 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
              !wcscmp( name+1, L"_StringData" ) )
             continue;
 
-        transform = calloc( 1, sizeof(TRANSFORMDATA) );
+        transform = calloc( 1, sizeof(*transform) );
         if ( !transform )
             break;
 
@@ -3480,11 +3480,11 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
      * Apply _Tables and _Columns transforms first so that
      * the table metadata is correct, and empty tables exist.
      */
-    ret = msi_table_load_transform( db, stg, strings, tables, bytes_per_strref, err_cond );
+    ret = table_load_transform( db, stg, strings, tables, bytes_per_strref, err_cond );
     if (ret != ERROR_SUCCESS && ret != ERROR_INVALID_TABLE)
         goto end;
 
-    ret = msi_table_load_transform( db, stg, strings, columns, bytes_per_strref, err_cond );
+    ret = table_load_transform( db, stg, strings, columns, bytes_per_strref, err_cond );
     if (ret != ERROR_SUCCESS && ret != ERROR_INVALID_TABLE)
         goto end;
 
@@ -3492,13 +3492,13 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
 
     while ( !list_empty( &transforms ) )
     {
-        transform = LIST_ENTRY( list_head( &transforms ), TRANSFORMDATA, entry );
+        transform = LIST_ENTRY( list_head( &transforms ), struct transform_data, entry );
 
         if ( wcscmp( transform->name, L"_Columns" ) &&
              wcscmp( transform->name, L"_Tables" ) &&
              ret == ERROR_SUCCESS )
         {
-            ret = msi_table_load_transform( db, stg, strings, transform, bytes_per_strref, err_cond );
+            ret = table_load_transform( db, stg, strings, transform, bytes_per_strref, err_cond );
         }
 
         list_remove( &transform->entry );
@@ -3519,7 +3519,7 @@ end:
         msi_destroy_stringtable( strings );
     if (transform_view)
     {
-        struct tagMSITABLE *table = ((MSITABLEVIEW*)transform_view)->table;
+        struct tagMSITABLE *table = ((struct table_view *)transform_view)->table;
 
         if (ret != ERROR_SUCCESS)
             transform_view->ops->release( transform_view );
diff --git a/dlls/msi/tests/package.c b/dlls/msi/tests/package.c
index 05633c4b6df..43ee28fdc21 100644
--- a/dlls/msi/tests/package.c
+++ b/dlls/msi/tests/package.c
@@ -2137,7 +2137,7 @@ static void test_condition(void)
     DeleteFileA(msifile);
 }
 
-static void check_prop(MSIHANDLE hpkg, const char *prop, const char *expect, int match_case)
+static void check_prop(MSIHANDLE hpkg, const char *prop, const char *expect, int match_case, int todo_value)
 {
     char buffer[MAX_PATH] = "x";
     DWORD sz = sizeof(buffer);
@@ -2145,9 +2145,9 @@ static void check_prop(MSIHANDLE hpkg, const char *prop, const char *expect, int
     ok(!r, "'%s': got %u\n", prop, r);
     ok(sz == lstrlenA(buffer), "'%s': expected %u, got %lu\n", prop, lstrlenA(buffer), sz);
     if (match_case)
-        ok(!strcmp(buffer, expect), "'%s': expected '%s', got '%s'\n", prop, expect, buffer);
+        todo_wine_if (todo_value) ok(!strcmp(buffer, expect), "'%s': expected '%s', got '%s'\n", prop, expect, buffer);
     else
-        ok(!_stricmp(buffer, expect), "'%s': expected '%s', got '%s'\n", prop, expect, buffer);
+        todo_wine_if (todo_value) ok(!_stricmp(buffer, expect), "'%s': expected '%s', got '%s'\n", prop, expect, buffer);
 }
 
 static void test_props(void)
@@ -2220,29 +2220,29 @@ static void test_props(void)
 
     r = MsiSetPropertyA( hpkg, "=", "asdf" );
     ok(!r, "got %u\n", r);
-    check_prop(hpkg, "=", "asdf", 1);
+    check_prop(hpkg, "=", "asdf", 1, 0);
 
     r = MsiSetPropertyA( hpkg, " ", "asdf" );
     ok(!r, "got %u\n", r);
-    check_prop(hpkg, " ", "asdf", 1);
+    check_prop(hpkg, " ", "asdf", 1, 0);
 
     r = MsiSetPropertyA( hpkg, "'", "asdf" );
     ok(!r, "got %u\n", r);
-    check_prop(hpkg, "'", "asdf", 1);
+    check_prop(hpkg, "'", "asdf", 1, 0);
 
     /* set empty values */
     r = MsiSetPropertyA( hpkg, "boo", NULL );
     ok(!r, "got %u\n", r);
-    check_prop(hpkg, "boo", "", 1);
+    check_prop(hpkg, "boo", "", 1, 0);
 
     r = MsiSetPropertyA( hpkg, "boo", "" );
     ok(!r, "got %u\n", r);
-    check_prop(hpkg, "boo", "", 1);
+    check_prop(hpkg, "boo", "", 1, 0);
 
     /* set a non-empty value */
     r = MsiSetPropertyA( hpkg, "boo", "xyz" );
     ok(!r, "got %u\n", r);
-    check_prop(hpkg, "boo", "xyz", 1);
+    check_prop(hpkg, "boo", "xyz", 1, 0);
 
     r = MsiGetPropertyA(hpkg, "boo", NULL, NULL);
     ok(!r, "got %u\n", r);
@@ -2317,10 +2317,10 @@ static void test_props(void)
     ok(sz == 3, "got size %lu\n", sz);
 
     /* properties are case-sensitive */
-    check_prop(hpkg, "BOO", "", 1);
+    check_prop(hpkg, "BOO", "", 1, 0);
 
     /* properties set in Property table should work */
-    check_prop(hpkg, "MetadataCompName", "Photoshop.dll", 1);
+    check_prop(hpkg, "MetadataCompName", "Photoshop.dll", 1, 0);
 
     MsiCloseHandle( hpkg );
     DeleteFileA(msifile);
@@ -5066,6 +5066,7 @@ static void test_appsearch_inilocator(void)
     }
     ok(r == ERROR_SUCCESS, "Expected a valid package handle %u\n", r);
 
+    MsiCloseHandle( hdb );
     MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
 
     r = MsiDoActionA(hpkg, "AppSearch");
@@ -5074,6 +5075,12 @@ static void test_appsearch_inilocator(void)
     size = MAX_PATH;
     r = MsiGetPropertyA(hpkg, "SIGPROP1", prop, &size);
     ok(r == ERROR_SUCCESS, "Expected ERROR_SUCCESS, got %d\n", r);
+    if (!prop[0])
+    {
+        win_skip("broken result\n");
+        MsiCloseHandle(hpkg);
+        goto error;
+    }
     ok(!lstrcmpA(prop, "keydata"), "Expected \"keydata\", got \"%s\"\n", prop);
 
     size = MAX_PATH;
@@ -5628,7 +5635,12 @@ static void test_installprops(void)
     ok( !lstrcmpA(buf, path), "Expected %s, got %s\n", path, buf);
 
     RegOpenKeyA(HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\MS Setup (ACME)\\User Info", &hkey1);
-    RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", 0, access, &hkey2);
+    res = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", 0, access, &hkey2);
+    if (res == ERROR_ACCESS_DENIED)
+    {
+        win_skip("no access\n");
+        goto done;
+    }
     RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion",
         0, KEY_QUERY_VALUE | KEY_WOW64_64KEY, &pathkey);
 
@@ -5734,72 +5746,73 @@ static void test_installprops(void)
     GetNativeSystemInfo(&si);
 
     sprintf(buf, "%d", LOBYTE(LOWORD(GetVersion())) * 100 + HIBYTE(LOWORD(GetVersion())));
-    check_prop(hpkg, "VersionNT", buf, 1);
+    check_prop(hpkg, "VersionNT", buf, 1, 1);
 
     if (S(U(si)).wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
     {
         sprintf(buf, "%d", si.wProcessorLevel);
-        check_prop(hpkg, "Intel", buf, 1);
-        check_prop(hpkg, "MsiAMD64", buf, 1);
-        check_prop(hpkg, "Msix64", buf, 1);
+        check_prop(hpkg, "Intel", buf, 1, 0);
+        check_prop(hpkg, "MsiAMD64", buf, 1, 0);
+        check_prop(hpkg, "Msix64", buf, 1, 0);
         sprintf(buf, "%d", LOBYTE(LOWORD(GetVersion())) * 100 + HIBYTE(LOWORD(GetVersion())));
-        check_prop(hpkg, "VersionNT64", buf, 1);
+        check_prop(hpkg, "VersionNT64", buf, 1, 1);
 
         GetSystemDirectoryA(path, MAX_PATH);
         strcat(path, "\\");
-        check_prop(hpkg, "System64Folder", path, 0);
+        check_prop(hpkg, "System64Folder", path, 0, 0);
 
         GetSystemWow64DirectoryA(path, MAX_PATH);
         strcat(path, "\\");
-        check_prop(hpkg, "SystemFolder", path, 0);
+        check_prop(hpkg, "SystemFolder", path, 0, 0);
 
         size = MAX_PATH;
         r = RegQueryValueExA(pathkey, "ProgramFilesDir (x86)", 0, &type, (BYTE *)path, &size);
         strcat(path, "\\");
-        check_prop(hpkg, "ProgramFilesFolder", path, 0);
+        check_prop(hpkg, "ProgramFilesFolder", path, 0, 0);
 
         size = MAX_PATH;
         RegQueryValueExA(pathkey, "ProgramFilesDir", 0, &type, (BYTE *)path, &size);
         strcat(path, "\\");
-        check_prop(hpkg, "ProgramFiles64Folder", path, 0);
+        check_prop(hpkg, "ProgramFiles64Folder", path, 0, 0);
 
         size = MAX_PATH;
         RegQueryValueExA(pathkey, "CommonFilesDir (x86)", 0, &type, (BYTE *)path, &size);
         strcat(path, "\\");
-        check_prop(hpkg, "CommonFilesFolder", path, 0);
+        check_prop(hpkg, "CommonFilesFolder", path, 0, 0);
 
         size = MAX_PATH;
         RegQueryValueExA(pathkey, "CommonFilesDir", 0, &type, (BYTE *)path, &size);
         strcat(path, "\\");
-        check_prop(hpkg, "CommonFiles64Folder", path, 0);
+        check_prop(hpkg, "CommonFiles64Folder", path, 0, 0);
     }
     else if (S(U(si)).wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
     {
         sprintf(buf, "%d", si.wProcessorLevel);
-        check_prop(hpkg, "Intel", buf, 1);
+        check_prop(hpkg, "Intel", buf, 1, 0);
 
         GetSystemDirectoryA(path, MAX_PATH);
         strcat(path, "\\");
-        check_prop(hpkg, "SystemFolder", path, 0);
+        check_prop(hpkg, "SystemFolder", path, 0, 0);
 
         size = MAX_PATH;
         RegQueryValueExA(pathkey, "ProgramFilesDir", 0, &type, (BYTE *)path, &size);
         strcat(path, "\\");
-        check_prop(hpkg, "ProgramFilesFolder", path, 0);
+        check_prop(hpkg, "ProgramFilesFolder", path, 0, 0);
 
         size = MAX_PATH;
         RegQueryValueExA(pathkey, "CommonFilesDir", 0, &type, (BYTE *)path, &size);
         strcat(path, "\\");
-        check_prop(hpkg, "CommonFilesFolder", path, 0);
-
-        check_prop(hpkg, "MsiAMD64", "", 1);
-        check_prop(hpkg, "Msix64", "", 1);
-        check_prop(hpkg, "VersionNT64", "", 1);
-        check_prop(hpkg, "System64Folder", "", 0);
-        check_prop(hpkg, "ProgramFiles64Dir", "", 0);
-        check_prop(hpkg, "CommonFiles64Dir", "", 0);
+        check_prop(hpkg, "CommonFilesFolder", path, 0, 0);
+
+        check_prop(hpkg, "MsiAMD64", "", 1, 0);
+        check_prop(hpkg, "Msix64", "", 1, 0);
+        check_prop(hpkg, "VersionNT64", "", 1, 0);
+        check_prop(hpkg, "System64Folder", "", 0, 0);
+        check_prop(hpkg, "ProgramFiles64Dir", "", 0, 0);
+        check_prop(hpkg, "CommonFiles64Dir", "", 0, 0);
     }
 
+done:
     CloseHandle(hkey1);
     CloseHandle(hkey2);
     RegCloseKey(pathkey);
diff --git a/dlls/msi/tokenize.c b/dlls/msi/tokenize.c
index 3b9f98c6f17..22a905d0544 100644
--- a/dlls/msi/tokenize.c
+++ b/dlls/msi/tokenize.c
@@ -29,8 +29,8 @@
 ** All the keywords of the SQL language are stored as in a hash
 ** table composed of instances of the following structure.
 */
-typedef struct Keyword Keyword;
-struct Keyword {
+struct keyword
+{
   const WCHAR *name;             /* The keyword name */
   unsigned int len;
   int tokenType;           /* The token value for this keyword */
@@ -43,7 +43,7 @@ struct Keyword {
 ** They MUST be in alphabetical order
 */
 #define X(str)  str, ARRAY_SIZE(str) - 1
-static const Keyword aKeywordTable[] = {
+static const struct keyword aKeywordTable[] = {
   { X(L"ADD"),         TK_ADD },
   { X(L"ALTER"),       TK_ALTER },
   { X(L"AND"),         TK_AND },
@@ -88,7 +88,7 @@ static const Keyword aKeywordTable[] = {
 ** Comparison function for binary search.
 */
 static int __cdecl compKeyword(const void *m1, const void *m2){
-  const Keyword *k1 = m1, *k2 = m2;
+  const struct keyword *k1 = m1, *k2 = m2;
   int ret, len = min( k1->len, k2->len );
 
   if ((ret = wcsnicmp( k1->name, k2->name, len ))) return ret;
@@ -103,7 +103,7 @@ static int __cdecl compKeyword(const void *m1, const void *m2){
 ** returned.  If the input is not a keyword, TK_ID is returned.
 */
 static int sqliteKeywordCode(const WCHAR *z, int n){
-  Keyword key, *r;
+  struct keyword key, *r;
 
   if( n>MAX_TOKEN_LEN )
     return TK_ID;
@@ -111,7 +111,7 @@ static int sqliteKeywordCode(const WCHAR *z, int n){
   key.tokenType = 0;
   key.name = z;
   key.len = n;
-  r = bsearch( &key, aKeywordTable, ARRAY_SIZE(aKeywordTable), sizeof(Keyword), compKeyword );
+  r = bsearch( &key, aKeywordTable, ARRAY_SIZE(aKeywordTable), sizeof(struct keyword), compKeyword );
   if( r )
     return r->tokenType;
   return TK_ID;
diff --git a/dlls/msi/update.c b/dlls/msi/update.c
index 3fc5b2583bb..865455b1546 100644
--- a/dlls/msi/update.c
+++ b/dlls/msi/update.c
@@ -38,17 +38,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 /* below is the query interface to a table */
 
-typedef struct tagMSIUPDATEVIEW
+struct update_view
 {
     MSIVIEW          view;
     MSIDATABASE     *db;
     MSIVIEW         *wv;
     column_info     *vals;
-} MSIUPDATEVIEW;
+};
 
 static UINT UPDATE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
 
     TRACE("%p %d %d %p\n", uv, row, col, val );
 
@@ -57,7 +57,7 @@ static UINT UPDATE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT
 
 static UINT UPDATE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
     UINT i, r, col_count = 0, row_count = 0;
     MSIRECORD *values = NULL;
     MSIRECORD *where = NULL;
@@ -128,7 +128,7 @@ done:
 
 static UINT UPDATE_close( struct tagMSIVIEW *view )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
     MSIVIEW *wv;
 
     TRACE("%p\n", uv);
@@ -142,7 +142,7 @@ static UINT UPDATE_close( struct tagMSIVIEW *view )
 
 static UINT UPDATE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *cols )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
     MSIVIEW *wv;
 
     TRACE("%p %p %p\n", uv, rows, cols );
@@ -157,7 +157,7 @@ static UINT UPDATE_get_dimensions( struct tagMSIVIEW *view, UINT *rows, UINT *co
 static UINT UPDATE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *name,
                                     UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
     MSIVIEW *wv;
 
     TRACE("%p %d %p %p %p %p\n", uv, n, name, type, temporary, table_name );
@@ -172,7 +172,7 @@ static UINT UPDATE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *na
 static UINT UPDATE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                            MSIRECORD *rec, UINT row )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
 
     TRACE("%p %d %p\n", uv, eModifyMode, rec );
 
@@ -181,7 +181,7 @@ static UINT UPDATE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 
 static UINT UPDATE_delete( struct tagMSIVIEW *view )
 {
-    MSIUPDATEVIEW *uv = (MSIUPDATEVIEW*)view;
+    struct update_view *uv = (struct update_view *)view;
     MSIVIEW *wv;
 
     TRACE("%p\n", uv );
@@ -220,7 +220,7 @@ static const MSIVIEWOPS update_ops =
 UINT UPDATE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR table,
                         column_info *columns, struct expr *expr )
 {
-    MSIUPDATEVIEW *uv = NULL;
+    struct update_view *uv = NULL;
     UINT r;
     MSIVIEW *sv = NULL, *wv = NULL;
 
diff --git a/dlls/msi/where.c b/dlls/msi/where.c
index 05be5338ac6..d2183d348d4 100644
--- a/dlls/msi/where.c
+++ b/dlls/msi/where.c
@@ -38,20 +38,20 @@
 WINE_DEFAULT_DEBUG_CHANNEL(msidb);
 
 /* below is the query interface to a table */
-typedef struct tagMSIROWENTRY
+struct row_entry
 {
     struct tagMSIWHEREVIEW *wv; /* used during sorting */
     UINT values[1];
-} MSIROWENTRY;
+};
 
-typedef struct tagJOINTABLE
+struct join_table
 {
-    struct tagJOINTABLE *next;
+    struct join_table *next;
     MSIVIEW *view;
     UINT col_count;
     UINT row_count;
     UINT table_index;
-} JOINTABLE;
+};
 
 typedef struct tagMSIORDERINFO
 {
@@ -64,11 +64,11 @@ typedef struct tagMSIWHEREVIEW
 {
     MSIVIEW        view;
     MSIDATABASE   *db;
-    JOINTABLE     *tables;
+    struct join_table *tables;
     UINT           row_count;
     UINT           col_count;
     UINT           table_count;
-    MSIROWENTRY  **reorder;
+    struct row_entry **reorder;
     UINT           reorder_size; /* number of entries available in reorder */
     struct expr   *cond;
     UINT           rec_index;
@@ -100,7 +100,7 @@ static void free_reorder(MSIWHEREVIEW *wv)
 
 static UINT init_reorder(MSIWHEREVIEW *wv)
 {
-    MSIROWENTRY **new = calloc(INITIAL_REORDER_SIZE, sizeof(MSIROWENTRY *));
+    struct row_entry **new = calloc(INITIAL_REORDER_SIZE, sizeof(*new));
     if (!new)
         return ERROR_OUTOFMEMORY;
 
@@ -124,11 +124,11 @@ static inline UINT find_row(MSIWHEREVIEW *wv, UINT row, UINT *(values[]))
 
 static UINT add_row(MSIWHEREVIEW *wv, UINT vals[])
 {
-    MSIROWENTRY *new;
+    struct row_entry *new;
 
     if (wv->reorder_size <= wv->row_count)
     {
-        MSIROWENTRY **new_reorder;
+        struct row_entry **new_reorder;
         UINT newsize = wv->reorder_size * 2;
 
         new_reorder = realloc(wv->reorder, newsize * sizeof(*new_reorder));
@@ -140,7 +140,7 @@ static UINT add_row(MSIWHEREVIEW *wv, UINT vals[])
         wv->reorder_size = newsize;
     }
 
-    new = malloc(offsetof(MSIROWENTRY, values[wv->table_count]));
+    new = malloc(offsetof(struct row_entry, values[wv->table_count]));
 
     if (!new)
         return ERROR_OUTOFMEMORY;
@@ -153,9 +153,9 @@ static UINT add_row(MSIWHEREVIEW *wv, UINT vals[])
     return ERROR_SUCCESS;
 }
 
-static JOINTABLE *find_table(MSIWHEREVIEW *wv, UINT col, UINT *table_col)
+static struct join_table *find_table(MSIWHEREVIEW *wv, UINT col, UINT *table_col)
 {
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
 
     if(col == 0 || col > wv->col_count)
          return NULL;
@@ -174,7 +174,7 @@ static JOINTABLE *find_table(MSIWHEREVIEW *wv, UINT col, UINT *table_col)
 static UINT parse_column(MSIWHEREVIEW *wv, union ext_column *column,
                          UINT *column_type)
 {
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
     UINT i, r;
 
     do
@@ -216,7 +216,7 @@ static UINT parse_column(MSIWHEREVIEW *wv, union ext_column *column,
 static UINT WHERE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *val )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table;
+    struct join_table *table;
     UINT *rows;
     UINT r;
 
@@ -239,7 +239,7 @@ static UINT WHERE_fetch_int( struct tagMSIVIEW *view, UINT row, UINT col, UINT *
 static UINT WHERE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, IStream **stm )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table;
+    struct join_table *table;
     UINT *rows;
     UINT r;
 
@@ -262,7 +262,7 @@ static UINT WHERE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, ISt
 static UINT WHERE_set_int(struct tagMSIVIEW *view, UINT row, UINT col, int val)
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table;
+    struct join_table *table;
     UINT *rows;
     UINT r;
 
@@ -282,7 +282,7 @@ static UINT WHERE_set_int(struct tagMSIVIEW *view, UINT row, UINT col, int val)
 static UINT WHERE_set_string(struct tagMSIVIEW *view, UINT row, UINT col, const WCHAR *val, int len)
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table;
+    struct join_table *table;
     UINT *rows;
     UINT r;
 
@@ -302,7 +302,7 @@ static UINT WHERE_set_string(struct tagMSIVIEW *view, UINT row, UINT col, const
 static UINT WHERE_set_stream(MSIVIEW *view, UINT row, UINT col, IStream *stream)
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table;
+    struct join_table *table;
     UINT *rows;
     UINT r;
 
@@ -323,7 +323,7 @@ static UINT WHERE_set_row( struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UI
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
     UINT i, r, offset = 0;
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
     UINT *rows;
     UINT mask_copy = mask;
 
@@ -493,7 +493,7 @@ static INT INT_evaluate_binary( MSIWHEREVIEW *wv, const UINT rows[],
 
 static inline UINT expr_fetch_value(const union ext_column *expr, const UINT rows[], UINT *val)
 {
-    JOINTABLE *table = expr->parsed.table;
+    struct join_table *table = expr->parsed.table;
 
     if( rows[table->table_index] == INVALID_ROW_INDEX )
     {
@@ -647,7 +647,7 @@ static UINT WHERE_evaluate( MSIWHEREVIEW *wv, const UINT rows[],
     return ERROR_SUCCESS;
 }
 
-static UINT check_condition( MSIWHEREVIEW *wv, MSIRECORD *record, JOINTABLE **tables,
+static UINT check_condition( MSIWHEREVIEW *wv, MSIRECORD *record, struct join_table **tables,
                              UINT table_rows[] )
 {
     UINT r = ERROR_FUNCTION_FAILED;
@@ -684,8 +684,8 @@ static UINT check_condition( MSIWHEREVIEW *wv, MSIRECORD *record, JOINTABLE **ta
 
 static int __cdecl compare_entry( const void *left, const void *right )
 {
-    const MSIROWENTRY *le = *(const MSIROWENTRY**)left;
-    const MSIROWENTRY *re = *(const MSIROWENTRY**)right;
+    const struct row_entry *le = *(const struct row_entry **)left;
+    const struct row_entry *re = *(const struct row_entry **)right;
     const MSIWHEREVIEW *wv = le->wv;
     MSIORDERINFO *order = wv->order_info;
     UINT i, j, r, l_val, r_val;
@@ -729,7 +729,7 @@ static int __cdecl compare_entry( const void *left, const void *right )
     return 0;
 }
 
-static void add_to_array( JOINTABLE **array, JOINTABLE *elem )
+static void add_to_array( struct join_table **array, struct join_table *elem )
 {
     while (*array && *array != elem)
         array++;
@@ -737,7 +737,7 @@ static void add_to_array( JOINTABLE **array, JOINTABLE *elem )
         *array = elem;
 }
 
-static BOOL in_array( JOINTABLE **array, JOINTABLE *elem )
+static BOOL in_array( struct join_table **array, struct join_table *elem )
 {
     while (*array && *array != elem)
         array++;
@@ -748,8 +748,8 @@ static BOOL in_array( JOINTABLE **array, JOINTABLE *elem )
 #define JOIN_TO_CONST_EXPR 0x10000 /* comparison to a table involved with
                                       a CONST_EXPR comaprison */
 
-static UINT reorder_check( const struct expr *expr, JOINTABLE **ordered_tables,
-                           BOOL process_joins, JOINTABLE **lastused )
+static UINT reorder_check( const struct expr *expr, struct join_table **ordered_tables,
+                           BOOL process_joins, struct join_table **lastused )
 {
     UINT res = 0;
 
@@ -787,10 +787,9 @@ static UINT reorder_check( const struct expr *expr, JOINTABLE **ordered_tables,
 }
 
 /* reorders the tablelist in a way to evaluate the condition as fast as possible */
-static JOINTABLE **ordertables( MSIWHEREVIEW *wv )
+static struct join_table **ordertables( MSIWHEREVIEW *wv )
 {
-    JOINTABLE *table;
-    JOINTABLE **tables;
+    struct join_table *table, **tables;
 
     tables = calloc(wv->table_count + 1, sizeof(*tables));
 
@@ -815,9 +814,9 @@ static UINT WHERE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
     UINT r;
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
     UINT *rows;
-    JOINTABLE **ordered_tables;
+    struct join_table **ordered_tables;
     UINT i = 0;
 
     TRACE("%p %p\n", wv, record);
@@ -857,7 +856,7 @@ static UINT WHERE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
     if (wv->order_info)
         wv->order_info->error = ERROR_SUCCESS;
 
-    qsort(wv->reorder, wv->row_count, sizeof(MSIROWENTRY *), compare_entry);
+    qsort(wv->reorder, wv->row_count, sizeof(struct row_entry *), compare_entry);
 
     if (wv->order_info)
         r = wv->order_info->error;
@@ -870,7 +869,7 @@ static UINT WHERE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 static UINT WHERE_close( struct tagMSIVIEW *view )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
 
     TRACE("%p\n", wv );
 
@@ -910,7 +909,7 @@ static UINT WHERE_get_column_info( struct tagMSIVIEW *view, UINT n, LPCWSTR *nam
                                    UINT *type, BOOL *temporary, LPCWSTR *table_name )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table;
+    struct join_table *table;
 
     TRACE("%p %d %p %p %p %p\n", wv, n, name, type, temporary, table_name );
 
@@ -980,7 +979,7 @@ static UINT WHERE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
                           MSIRECORD *rec, UINT row )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
     UINT r;
 
     TRACE("%p %d %p\n", wv, eModifyMode, rec);
@@ -1035,13 +1034,13 @@ static UINT WHERE_modify( struct tagMSIVIEW *view, MSIMODIFY eModifyMode,
 static UINT WHERE_delete( struct tagMSIVIEW *view )
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW*)view;
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
 
     TRACE("%p\n", wv );
 
     while(table)
     {
-        JOINTABLE *next;
+        struct join_table *next;
 
         table->view->ops->delete(table->view);
         table->view = NULL;
@@ -1066,7 +1065,7 @@ static UINT WHERE_delete( struct tagMSIVIEW *view )
 static UINT WHERE_sort(struct tagMSIVIEW *view, column_info *columns)
 {
     MSIWHEREVIEW *wv = (MSIWHEREVIEW *)view;
-    JOINTABLE *table = wv->tables;
+    struct join_table *table = wv->tables;
     column_info *column = columns;
     MSIORDERINFO *orderinfo;
     UINT r, count = 0;
@@ -1245,12 +1244,12 @@ UINT WHERE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR tables,
 
     while (*tables)
     {
-        JOINTABLE *table;
+        struct join_table *table;
 
         if ((ptr = wcschr(tables, ' ')))
             *ptr = '\0';
 
-        table = malloc(sizeof(JOINTABLE));
+        table = malloc(sizeof(*table));
         if (!table)
         {
             r = ERROR_OUTOFMEMORY;
diff --git a/dlls/msmpeg2vdec/Makefile.in b/dlls/msmpeg2vdec/Makefile.in
new file mode 100644
index 00000000000..d2dbf5adda0
--- /dev/null
+++ b/dlls/msmpeg2vdec/Makefile.in
@@ -0,0 +1 @@
+MODULE    = msmpeg2vdec.dll
diff --git a/dlls/msmpeg2vdec/msmpeg2vdec.spec b/dlls/msmpeg2vdec/msmpeg2vdec.spec
new file mode 100644
index 00000000000..2ba3ab602f1
--- /dev/null
+++ b/dlls/msmpeg2vdec/msmpeg2vdec.spec
@@ -0,0 +1,8 @@
+@ stub GetH264DecoderFunctionTable
+@ stub ?GetSurface@CVIDEOfilter@@QEAAJHPEAEJ@Z
+@ stub ?GetSurfaceSize@CVIDEOfilter@@QEAAJHPEAJ@Z
+@ stub ?LoadSurface@CVIDEOfilter@@QEAAJHPEAEK@Z
+@ stdcall -private DllCanUnloadNow()
+@ stub DllGetClassObject
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
diff --git a/dlls/msvcr80/tests/msvcr80.c b/dlls/msvcr80/tests/msvcr80.c
index a2a3734f6c0..fa04b024031 100644
--- a/dlls/msvcr80/tests/msvcr80.c
+++ b/dlls/msvcr80/tests/msvcr80.c
@@ -62,6 +62,8 @@ static int (__cdecl *p__close)(int);
 static intptr_t (__cdecl *p__get_osfhandle)(int);
 static int (__cdecl *p_strcmp)(const char *, const char *);
 static int (__cdecl *p_strncmp)(const char *, const char *, size_t);
+static int (__cdecl *p_dupenv_s)(char **, size_t *, const char *);
+static int (__cdecl *p_wdupenv_s)(wchar_t **, size_t *, const wchar_t *);
 
 #define SETNOFAIL(x,y) x = (void*)GetProcAddress(hcrt,y)
 #define SET(x,y) do { SETNOFAIL(x,y); ok(x != NULL, "Export '%s' not found\n", y); } while(0)
@@ -83,6 +85,8 @@ static BOOL init(void)
 
     SET(p_strcmp, "strcmp");
     SET(p_strncmp, "strncmp");
+    SET(p_dupenv_s, "_dupenv_s");
+    SET(p_wdupenv_s, "_wdupenv_s");
 
     return TRUE;
 }
@@ -184,6 +188,34 @@ static void test_strcmp(void)
     ok( ret == 0, "wrong ret %d\n", ret );
 }
 
+static void test_dupenv_s(void)
+{
+    size_t len;
+    char *tmp;
+    int ret;
+
+    len = 0xdeadbeef;
+    tmp = (void *)0xdeadbeef;
+    ret = p_dupenv_s( &tmp, &len, "nonexistent" );
+    ok( !ret, "_dupenv_s returned %d\n", ret );
+    ok( !len, "_dupenv_s returned length is %Id\n", len );
+    ok( !tmp, "_dupenv_s returned pointer is %p\n", tmp );
+}
+
+static void test_wdupenv_s(void)
+{
+    wchar_t *tmp;
+    size_t len;
+    int ret;
+
+    len = 0xdeadbeef;
+    tmp = (void *)0xdeadbeef;
+    ret = p_wdupenv_s( &tmp, &len, L"nonexistent" );
+    ok( !ret, "_wdupenv_s returned %d\n", ret );
+    ok( !len, "_wdupenv_s returned length is %Id\n", len );
+    ok( !tmp, "_wdupenv_s returned pointer is %p\n", tmp );
+}
+
 START_TEST(msvcr80)
 {
     if(!init())
@@ -191,4 +223,6 @@ START_TEST(msvcr80)
 
     test_ioinfo_flags();
     test_strcmp();
+    test_dupenv_s();
+    test_wdupenv_s();
 }
diff --git a/dlls/msvcrt/environ.c b/dlls/msvcrt/environ.c
index e541bd5bff0..2c2a3353582 100644
--- a/dlls/msvcrt/environ.c
+++ b/dlls/msvcrt/environ.c
@@ -25,19 +25,19 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msvcrt);
 
-/*********************************************************************
- *		getenv (MSVCRT.@)
- */
-char * CDECL getenv(const char *name)
+static char * getenv_helper(const char *name)
 {
     char **env;
-    unsigned int length=strlen(name);
+    size_t len;
+
+    if (!name) return NULL;
+    len = strlen(name);
 
     for (env = MSVCRT__environ; *env; env++)
     {
         char *str = *env;
         char *pos = strchr(str,'=');
-        if (pos && ((pos - str) == length) && !_strnicmp(str,name,length))
+        if (pos && ((pos - str) == len) && !_strnicmp(str, name, len))
         {
             TRACE("(%s): got %s\n", debugstr_a(name), debugstr_a(pos + 1));
             return pos + 1;
@@ -47,12 +47,22 @@ char * CDECL getenv(const char *name)
 }
 
 /*********************************************************************
- *		_wgetenv (MSVCRT.@)
+ *              getenv (MSVCRT.@)
  */
-wchar_t * CDECL _wgetenv(const wchar_t *name)
+char * CDECL getenv(const char *name)
+{
+    if (!MSVCRT_CHECK_PMT(name != NULL)) return NULL;
+
+    return getenv_helper(name);
+}
+
+static wchar_t * wgetenv_helper(const wchar_t *name)
 {
     wchar_t **env;
-    unsigned int length=wcslen(name);
+    size_t len;
+
+    if (!name) return NULL;
+    len = wcslen(name);
 
     /* Initialize the _wenviron array if it's not already created. */
     if (!MSVCRT__wenviron)
@@ -62,7 +72,7 @@ wchar_t * CDECL _wgetenv(const wchar_t *name)
     {
         wchar_t *str = *env;
         wchar_t *pos = wcschr(str,'=');
-        if (pos && ((pos - str) == length) && !_wcsnicmp(str,name,length))
+        if (pos && ((pos - str) == len) && !_wcsnicmp(str, name, len))
         {
             TRACE("(%s): got %s\n", debugstr_w(name), debugstr_w(pos + 1));
             return pos + 1;
@@ -71,6 +81,16 @@ wchar_t * CDECL _wgetenv(const wchar_t *name)
     return NULL;
 }
 
+/*********************************************************************
+ *              _wgetenv (MSVCRT.@)
+ */
+wchar_t * CDECL _wgetenv(const wchar_t *name)
+{
+    if (!MSVCRT_CHECK_PMT(name != NULL)) return NULL;
+
+    return wgetenv_helper(name);
+}
+
 /*********************************************************************
  *		_putenv (MSVCRT.@)
  */
@@ -229,7 +249,12 @@ int CDECL _dupenv_s(char **buffer, size_t *numberOfElements, const char *varname
     if (!MSVCRT_CHECK_PMT(buffer != NULL)) return EINVAL;
     if (!MSVCRT_CHECK_PMT(varname != NULL)) return EINVAL;
 
-    if (!(e = getenv(varname))) return *_errno() = EINVAL;
+    if (!(e = getenv(varname)))
+    {
+        *buffer = NULL;
+        if (numberOfElements) *numberOfElements = 0;
+        return 0;
+    }
 
     sz = strlen(e) + 1;
     if (!(*buffer = malloc(sz)))
@@ -254,7 +279,12 @@ int CDECL _wdupenv_s(wchar_t **buffer, size_t *numberOfElements,
     if (!MSVCRT_CHECK_PMT(buffer != NULL)) return EINVAL;
     if (!MSVCRT_CHECK_PMT(varname != NULL)) return EINVAL;
 
-    if (!(e = _wgetenv(varname))) return *_errno() = EINVAL;
+    if (!(e = _wgetenv(varname)))
+    {
+        *buffer = NULL;
+        if (numberOfElements) *numberOfElements = 0;
+        return 0;
+    }
 
     sz = wcslen(e) + 1;
     if (!(*buffer = malloc(sz * sizeof(wchar_t))))
@@ -272,24 +302,20 @@ int CDECL _wdupenv_s(wchar_t **buffer, size_t *numberOfElements,
 /******************************************************************
  *		getenv_s (MSVCRT.@)
  */
-int CDECL getenv_s(size_t *pReturnValue, char* buffer, size_t numberOfElements, const char *varname)
+int CDECL getenv_s(size_t *ret_len, char* buffer, size_t len, const char *varname)
 {
     char *e;
 
-    if (!MSVCRT_CHECK_PMT(pReturnValue != NULL)) return EINVAL;
-    if (!MSVCRT_CHECK_PMT(!(buffer == NULL && numberOfElements > 0))) return EINVAL;
-    if (!MSVCRT_CHECK_PMT(varname != NULL)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(ret_len != NULL)) return EINVAL;
+    *ret_len = 0;
+    if (!MSVCRT_CHECK_PMT((buffer && len > 0) || (!buffer && !len))) return EINVAL;
+    if (buffer) buffer[0] = 0;
+
+    if (!(e = getenv_helper(varname))) return 0;
+    *ret_len = strlen(e) + 1;
+    if (!len) return 0;
+    if (len < *ret_len) return ERANGE;
 
-    if (!(e = getenv(varname)))
-    {
-        *pReturnValue = 0;
-        return *_errno() = EINVAL;
-    }
-    *pReturnValue = strlen(e) + 1;
-    if (numberOfElements < *pReturnValue)
-    {
-        return *_errno() = ERANGE;
-    }
     strcpy(buffer, e);
     return 0;
 }
@@ -297,25 +323,21 @@ int CDECL getenv_s(size_t *pReturnValue, char* buffer, size_t numberOfElements,
 /******************************************************************
  *		_wgetenv_s (MSVCRT.@)
  */
-int CDECL _wgetenv_s(size_t *pReturnValue, wchar_t *buffer, size_t numberOfElements,
+int CDECL _wgetenv_s(size_t *ret_len, wchar_t *buffer, size_t len,
                      const wchar_t *varname)
 {
     wchar_t *e;
 
-    if (!MSVCRT_CHECK_PMT(pReturnValue != NULL)) return EINVAL;
-    if (!MSVCRT_CHECK_PMT(!(buffer == NULL && numberOfElements > 0))) return EINVAL;
-    if (!MSVCRT_CHECK_PMT(varname != NULL)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(ret_len != NULL)) return EINVAL;
+    *ret_len = 0;
+    if (!MSVCRT_CHECK_PMT((buffer && len > 0) || (!buffer && !len))) return EINVAL;
+    if (buffer) buffer[0] = 0;
+
+    if (!(e = wgetenv_helper(varname))) return 0;
+    *ret_len = wcslen(e) + 1;
+    if (!len) return 0;
+    if (len < *ret_len) return ERANGE;
 
-    if (!(e = _wgetenv(varname)))
-    {
-        *pReturnValue = 0;
-        return *_errno() = EINVAL;
-    }
-    *pReturnValue = wcslen(e) + 1;
-    if (numberOfElements < *pReturnValue)
-    {
-        return *_errno() = ERANGE;
-    }
     wcscpy(buffer, e);
     return 0;
 }
diff --git a/dlls/msvcrt/exit.c b/dlls/msvcrt/exit.c
index 6427b15bece..3a7b5ae0330 100644
--- a/dlls/msvcrt/exit.c
+++ b/dlls/msvcrt/exit.c
@@ -290,7 +290,7 @@ unsigned int CDECL _set_abort_behavior(unsigned int flags, unsigned int mask)
 /*********************************************************************
  *              _wassert (MSVCRT.@)
  */
-void CDECL _wassert(const wchar_t* str, const wchar_t* file, unsigned int line)
+void DECLSPEC_NORETURN CDECL _wassert(const wchar_t* str, const wchar_t* file, unsigned int line)
 {
   TRACE("(%s,%s,%d)\n", debugstr_w(str), debugstr_w(file), line);
 
@@ -311,7 +311,7 @@ void CDECL _wassert(const wchar_t* str, const wchar_t* file, unsigned int line)
 /*********************************************************************
  *		_assert (MSVCRT.@)
  */
-void CDECL _assert(const char* str, const char* file, unsigned int line)
+void DECLSPEC_NORETURN CDECL _assert(const char* str, const char* file, unsigned int line)
 {
     wchar_t strW[1024], fileW[1024];
 
diff --git a/dlls/msvcrt/tests/environ.c b/dlls/msvcrt/tests/environ.c
index 03129dcbf14..3d6b55dffa8 100644
--- a/dlls/msvcrt/tests/environ.c
+++ b/dlls/msvcrt/tests/environ.c
@@ -50,6 +50,7 @@ static void (__cdecl *p_get_environ)(char ***);
 static void (__cdecl *p_get_wenviron)(WCHAR ***);
 static errno_t (__cdecl *p_putenv_s)(const char*, const char*);
 static errno_t (__cdecl *p_wputenv_s)(const wchar_t*, const wchar_t*);
+static errno_t (__cdecl *p_getenv_s)(size_t*, char*, size_t, const char*);
 
 static char ***p_environ;
 static WCHAR ***p_wenviron;
@@ -66,6 +67,7 @@ static void init(void)
     p_get_wenviron = (void *)GetProcAddress(hmod, "_get_wenviron");
     p_putenv_s = (void *)GetProcAddress(hmod, "_putenv_s");
     p_wputenv_s = (void *)GetProcAddress(hmod, "_wputenv_s");
+    p_getenv_s = (void *)GetProcAddress(hmod, "getenv_s");
 }
 
 static void test_system(void)
@@ -242,11 +244,20 @@ static void test__wenviron(void)
 
 static void test_environment_manipulation(void)
 {
+    char buf[256];
     errno_t ret;
+    size_t len;
 
     ok( _putenv("cat=") == 0, "_putenv failed on deletion of nonexistent environment variable\n" );
     ok( _putenv("cat=dog") == 0, "failed setting cat=dog\n" );
     ok( strcmp(getenv("cat"), "dog") == 0, "getenv did not return 'dog'\n" );
+    if (p_getenv_s)
+    {
+        ret = p_getenv_s(&len, buf, sizeof(buf), "cat");
+        ok( !ret, "getenv_s returned %d\n", ret );
+        ok( len == 4, "getenv_s returned length is %Id\n", len);
+        ok( !strcmp(buf, "dog"), "getenv_s did not return 'dog'\n");
+    }
     ok( _putenv("cat=") == 0, "failed deleting cat\n" );
 
     ok( _putenv("=") == -1, "should not accept '=' as input\n" );
@@ -282,6 +293,27 @@ static void test_environment_manipulation(void)
         ret = p_wputenv_s(L"cat", L"");
         ok( !ret, "_wputenv_s returned %d\n", ret);
     }
+
+    if (p_getenv_s)
+    {
+        buf[0] = 'x';
+        len = 1;
+        errno = 0xdeadbeef;
+        ret = p_getenv_s(&len, buf, sizeof(buf), "nonexistent");
+        ok( !ret, "_getenv_s returned %d\n", ret);
+        ok( !len, "getenv_s returned length is %Id\n", len);
+        ok( !buf[0], "buf = %s\n", buf);
+        ok( errno == 0xdeadbeef, "errno = %d\n", errno);
+
+        buf[0] = 'x';
+        len = 1;
+        errno = 0xdeadbeef;
+        ret = p_getenv_s(&len, buf, sizeof(buf), NULL);
+        ok( !ret, "_getenv_s returned %d\n", ret);
+        ok( !len, "getenv_s returned length is %Id\n", len);
+        ok( !buf[0], "buf = %s\n", buf);
+        ok( errno == 0xdeadbeef, "errno = %d\n", errno);
+    }
 }
 
 START_TEST(environ)
diff --git a/dlls/msvcrt/time.c b/dlls/msvcrt/time.c
index fb91aa2b1ec..56b80e84105 100644
--- a/dlls/msvcrt/time.c
+++ b/dlls/msvcrt/time.c
@@ -1715,7 +1715,7 @@ char * CDECL _ctime64(const __time64_t *time)
 /*********************************************************************
  *		_ctime64_s (MSVCRT.@)
  */
-int CDECL _ctime64_s(char *res, size_t len, const __time64_t *time)
+errno_t CDECL _ctime64_s(char *res, size_t len, const __time64_t *time)
 {
     struct tm *t;
 
@@ -1744,7 +1744,7 @@ char * CDECL _ctime32(const __time32_t *time)
 /*********************************************************************
  *		_ctime32_s (MSVCRT.@)
  */
-int CDECL _ctime32_s(char *res, size_t len, const __time32_t *time)
+errno_t CDECL _ctime32_s(char *res, size_t len, const __time32_t *time)
 {
     struct tm *t;
 
diff --git a/dlls/nsi/nsi.c b/dlls/nsi/nsi.c
index 345dce6dfe6..3f324ef555b 100644
--- a/dlls/nsi/nsi.c
+++ b/dlls/nsi/nsi.c
@@ -70,6 +70,8 @@ DWORD WINAPI NsiAllocateAndGetTable( DWORD unk, const NPI_MODULEID *module, DWOR
         memset( data, 0, sizeof(data) );
         err = NsiEnumerateObjectsAllParameters( unk, 0, module, table, NULL, 0, NULL, 0, NULL, 0, NULL, 0, &num );
         if (err) return err;
+        err = ERROR_OUTOFMEMORY; /* fail if this is the last attempt */
+        num += num >> 4; /* the tables may grow before the next iteration; get ahead */
     }
 
     if (!err)
diff --git a/dlls/nsiproxy.sys/device.c b/dlls/nsiproxy.sys/device.c
index 4528e934991..87d634ff5c0 100644
--- a/dlls/nsiproxy.sys/device.c
+++ b/dlls/nsiproxy.sys/device.c
@@ -305,13 +305,11 @@ static NTSTATUS WINAPI nsi_ioctl( DEVICE_OBJECT *device, IRP *irp )
 
 static int add_device( DRIVER_OBJECT *driver )
 {
-    UNICODE_STRING name, link;
+    UNICODE_STRING name = RTL_CONSTANT_STRING( L"\\Device\\Nsi" );
+    UNICODE_STRING link = RTL_CONSTANT_STRING( L"\\??\\Nsi" );
     DEVICE_OBJECT *device;
     NTSTATUS status;
 
-    RtlInitUnicodeString( &name, L"\\Device\\Nsi" );
-    RtlInitUnicodeString( &link, L"\\??\\Nsi" );
-
     if (!(status = IoCreateDevice( driver, 0, &name, FILE_DEVICE_NETWORK, FILE_DEVICE_SECURE_OPEN, FALSE, &device )))
         status = IoCreateSymbolicLink( &link, &name );
     if (status)
diff --git a/dlls/ntdll/env.c b/dlls/ntdll/env.c
index 6db6cee17cd..ab54a9ec563 100644
--- a/dlls/ntdll/env.c
+++ b/dlls/ntdll/env.c
@@ -54,12 +54,9 @@ static inline SIZE_T get_env_length( const WCHAR *env )
  */
 static void set_wow64_environment( WCHAR **env )
 {
-    static WCHAR archW[]    = L"PROCESSOR_ARCHITECTURE";
-    static WCHAR arch6432W[] = L"PROCESSOR_ARCHITEW6432";
-
     WCHAR buf[256];
-    UNICODE_STRING arch_strW = { sizeof(archW) - sizeof(WCHAR), sizeof(archW), archW };
-    UNICODE_STRING arch6432_strW = { sizeof(arch6432W) - sizeof(WCHAR), sizeof(arch6432W), arch6432W };
+    UNICODE_STRING arch_strW = RTL_CONSTANT_STRING( L"PROCESSOR_ARCHITECTURE" );
+    UNICODE_STRING arch6432_strW = RTL_CONSTANT_STRING( L"PROCESSOR_ARCHITEW6432" );
     UNICODE_STRING valW = { 0, sizeof(buf), buf };
     UNICODE_STRING nameW;
 
diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index 22c9c829a4d..fc3e8982a98 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -191,7 +191,7 @@ LONG call_vectored_handlers( EXCEPTION_RECORD *rec, CONTEXT *context )
  *
  * Implementation of RtlRaiseStatus with a specific exception record.
  */
-void raise_status( NTSTATUS status, EXCEPTION_RECORD *rec )
+void DECLSPEC_NORETURN raise_status( NTSTATUS status, EXCEPTION_RECORD *rec )
 {
     EXCEPTION_RECORD ExceptionRec;
 
@@ -208,7 +208,7 @@ void raise_status( NTSTATUS status, EXCEPTION_RECORD *rec )
  *
  * Raise an exception with ExceptionCode = status
  */
-void WINAPI RtlRaiseStatus( NTSTATUS status )
+void DECLSPEC_NORETURN WINAPI RtlRaiseStatus( NTSTATUS status )
 {
     raise_status( status, NULL );
 }
@@ -623,7 +623,7 @@ PRUNTIME_FUNCTION WINAPI RtlLookupFunctionEntry( ULONG_PTR pc, ULONG_PTR *base,
 /*************************************************************
  *            _assert
  */
-void __cdecl _assert( const char *str, const char *file, unsigned int line )
+void DECLSPEC_NORETURN __cdecl _assert( const char *str, const char *file, unsigned int line )
 {
     ERR( "%s:%u: Assertion failed %s\n", file, line, debugstr_a(str) );
     RtlRaiseStatus( EXCEPTION_WINE_ASSERTION );
@@ -961,6 +961,32 @@ ULONG64 WINAPI RtlGetExtendedFeaturesMask( CONTEXT_EX *context_ex )
 }
 
 
+static void context_copy_ranges( BYTE *d, DWORD context_flags, BYTE *s, const struct context_parameters *p )
+{
+    const struct context_copy_range *range;
+    unsigned int start;
+
+    *((ULONG *)(d + p->flags_offset)) |= context_flags;
+
+    start = 0;
+    range = p->copy_ranges;
+    do
+    {
+        if (range->flag & context_flags)
+        {
+            if (!start)
+                start = range->start;
+        }
+        else if (start)
+        {
+            memcpy( d + start, s + start, range->start - start );
+            start = 0;
+        }
+    }
+    while (range++->start != p->context_size);
+}
+
+
 /***********************************************************************
  *              RtlCopyContext  (NTDLL.@)
  */
@@ -968,6 +994,7 @@ NTSTATUS WINAPI RtlCopyContext( CONTEXT *dst, DWORD context_flags, CONTEXT *src
 {
     DWORD context_size, arch_flag, flags_offset, dst_flags, src_flags;
     static const DWORD arch_mask = CONTEXT_i386 | CONTEXT_AMD64;
+    const struct context_parameters *p;
     BYTE *d, *s;
 
     TRACE("dst %p, context_flags %#lx, src %p.\n", dst, context_flags, src);
@@ -1000,8 +1027,15 @@ NTSTATUS WINAPI RtlCopyContext( CONTEXT *dst, DWORD context_flags, CONTEXT *src
     context_flags &= src_flags;
     if (context_flags & ~dst_flags & 0x40) return STATUS_BUFFER_OVERFLOW;
 
-    return RtlCopyExtendedContext( (CONTEXT_EX *)(d + context_size), context_flags,
-                                   (CONTEXT_EX *)(s + context_size) );
+    if (context_flags & 0x40)
+        return RtlCopyExtendedContext( (CONTEXT_EX *)(d + context_size), context_flags,
+                                       (CONTEXT_EX *)(s + context_size) );
+
+    if (!(p = context_get_parameters( context_flags )))
+        return STATUS_INVALID_PARAMETER;
+
+    context_copy_ranges( d, context_flags, s, p );
+    return STATUS_SUCCESS;
 }
 
 
@@ -1010,12 +1044,9 @@ NTSTATUS WINAPI RtlCopyContext( CONTEXT *dst, DWORD context_flags, CONTEXT *src
  */
 NTSTATUS WINAPI RtlCopyExtendedContext( CONTEXT_EX *dst, ULONG context_flags, CONTEXT_EX *src )
 {
-    const struct context_copy_range *range;
     const struct context_parameters *p;
     XSTATE *dst_xs, *src_xs;
     ULONG64 feature_mask;
-    unsigned int start;
-    BYTE *d, *s;
 
     TRACE( "dst %p, context_flags %#lx, src %p.\n", dst, context_flags, src );
 
@@ -1025,27 +1056,7 @@ NTSTATUS WINAPI RtlCopyExtendedContext( CONTEXT_EX *dst, ULONG context_flags, CO
     if (!(feature_mask = RtlGetEnabledExtendedFeatures( ~(ULONG64)0 )) && context_flags & 0x40)
         return STATUS_NOT_SUPPORTED;
 
-    d = RtlLocateLegacyContext( dst, NULL );
-    s = RtlLocateLegacyContext( src, NULL );
-
-    *((ULONG *)(d + p->flags_offset)) |= context_flags;
-
-    start = 0;
-    range = p->copy_ranges;
-    do
-    {
-        if (range->flag & context_flags)
-        {
-            if (!start)
-                start = range->start;
-        }
-        else if (start)
-        {
-            memcpy( d + start, s + start, range->start - start );
-            start = 0;
-        }
-    }
-    while (range++->start != p->context_size);
+    context_copy_ranges( RtlLocateLegacyContext( dst, NULL ), context_flags, RtlLocateLegacyContext( src, NULL ), p );
 
     if (!(context_flags & 0x40))
         return STATUS_SUCCESS;
diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index aafbbd0f523..6688fab9690 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -39,6 +39,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(heap);
 
+/* HeapCompatibilityInformation values */
+
+#define HEAP_STD 0
+#define HEAP_LAL 1
+#define HEAP_LFH 2
+
+
 /* undocumented RtlWalkHeap structure */
 
 struct rtl_heap_entry
@@ -77,13 +84,16 @@ struct rtl_heap_entry
 #define REGION_ALIGN  0x10000
 #define BLOCK_ALIGN   (2 * sizeof(void *))
 
-struct block
+struct DECLSPEC_ALIGN(8) block
 {
-    WORD block_size;   /* block size in multiple of BLOCK_ALIGN */
+    /* block size in multiple of BLOCK_ALIGN */
+    WORD block_size;
+    /* unused size (used block) / high size bits (free block) */
+    WORD tail_size;
+    /* offset to region base / first group block (LFH block) */
+    WORD base_offset;
+    BYTE block_type;
     BYTE block_flags;
-    BYTE tail_size;    /* unused size (used block) / high size bits (free block) */
-    WORD base_offset;  /* offset to the region base in multiple of REGION_ALIGN */
-    WORD block_type;
 };
 
 C_ASSERT( sizeof(struct block) == 8 );
@@ -94,6 +104,7 @@ C_ASSERT( sizeof(struct block) == 8 );
 #define BLOCK_FLAG_PREV_FREE   0x02
 #define BLOCK_FLAG_FREE_LINK   0x03
 #define BLOCK_FLAG_LARGE       0x04
+#define BLOCK_FLAG_LFH         0x08 /* block is handled by the LFH frontend */
 #define BLOCK_FLAG_USER_INFO   0x10 /* user flags up to 0xf0 */
 #define BLOCK_FLAG_USER_MASK   0xf0
 
@@ -124,10 +135,10 @@ typedef struct
 C_ASSERT( sizeof(ARENA_LARGE) == offsetof(ARENA_LARGE, block) + sizeof(struct block) );
 C_ASSERT( sizeof(ARENA_LARGE) == 4 * BLOCK_ALIGN );
 
-#define BLOCK_TYPE_USED        0x5355
-#define BLOCK_TYPE_DEAD        0xdead
-#define BLOCK_TYPE_FREE        0x5246
-#define BLOCK_TYPE_LARGE       0x614c
+#define BLOCK_TYPE_USED        'u'
+#define BLOCK_TYPE_DEAD        'D'
+#define BLOCK_TYPE_FREE        'F'
+#define BLOCK_TYPE_LARGE       'L'
 
 #define BLOCK_FILL_USED        0x55
 #define BLOCK_FILL_TAIL        0xab
@@ -150,8 +161,9 @@ C_ASSERT( sizeof(struct entry) <= HEAP_MIN_BLOCK_SIZE );
 #define HEAP_MAX_BLOCK_REGION_SIZE  (FIELD_MAX( struct block, base_offset ) * REGION_ALIGN)
 
 C_ASSERT( HEAP_MAX_USED_BLOCK_SIZE == 512 * 1024 * (sizeof(void *) / 4) - BLOCK_ALIGN );
-C_ASSERT( HEAP_MAX_FREE_BLOCK_SIZE == 128 * 1024 * 1024 * (sizeof(void *) / 4) - BLOCK_ALIGN );
-C_ASSERT( HEAP_MAX_BLOCK_REGION_SIZE >= HEAP_MAX_FREE_BLOCK_SIZE );
+C_ASSERT( HEAP_MAX_FREE_BLOCK_SIZE >= 128 * 1024 * 1024 * (sizeof(void *) / 4) - BLOCK_ALIGN );
+C_ASSERT( HEAP_MAX_BLOCK_REGION_SIZE >= 128 * 1024 * 1024 * (sizeof(void *) / 4) - BLOCK_ALIGN );
+C_ASSERT( HEAP_MAX_FREE_BLOCK_SIZE >= HEAP_MAX_BLOCK_REGION_SIZE );
 
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  (HEAP_MAX_USED_BLOCK_SIZE - 0x1000)
@@ -182,6 +194,94 @@ typedef struct DECLSPEC_ALIGN(BLOCK_ALIGN) tagSUBHEAP
 C_ASSERT( sizeof(SUBHEAP) == offsetof(SUBHEAP, block) + sizeof(struct block) );
 C_ASSERT( sizeof(SUBHEAP) == 4 * BLOCK_ALIGN );
 
+
+/* LFH block size bins */
+
+#define BIN_SIZE_MIN_0        0
+#define BIN_SIZE_MIN_1    0x100
+#define BIN_SIZE_MIN_2    0x200
+#define BIN_SIZE_MIN_3    0x400
+#define BIN_SIZE_MIN_4    0x800
+#define BIN_SIZE_MIN_5   0x1000
+#define BIN_SIZE_MIN_6   0x2000
+#define BIN_SIZE_MIN_7   0x4000
+#define BIN_SIZE_MAX     0x8000
+
+#define BIN_SIZE_STEP_0                   (16)
+#define BIN_SIZE_STEP_1  (BIN_SIZE_MIN_1 >> 4)
+#define BIN_SIZE_STEP_2  (BIN_SIZE_MIN_2 >> 4)
+#define BIN_SIZE_STEP_3  (BIN_SIZE_MIN_3 >> 4)
+#define BIN_SIZE_STEP_4  (BIN_SIZE_MIN_4 >> 4)
+#define BIN_SIZE_STEP_5  (BIN_SIZE_MIN_5 >> 4)
+#define BIN_SIZE_STEP_6  (BIN_SIZE_MIN_6 >> 4)
+#define BIN_SIZE_STEP_7  (BIN_SIZE_MIN_7 >> 4)
+
+#define BLOCK_BIN_SIZE_N( n, bin )   (BIN_SIZE_MIN_##n + (bin + 1) * BIN_SIZE_STEP_##n)
+#define BLOCK_SIZE_BIN_N( n, size )  (((size) - 1 - BIN_SIZE_MIN_##n) / BIN_SIZE_STEP_##n)
+
+#define BLOCK_BIN_SIZE( bin )   ((bin) >= 0x80 ? ~(SIZE_T)0 : \
+                                 (bin) >= 0x70 ? BLOCK_BIN_SIZE_N( 7, bin - 0x70 ) : \
+                                 (bin) >= 0x60 ? BLOCK_BIN_SIZE_N( 6, bin - 0x60 ) : \
+                                 (bin) >= 0x50 ? BLOCK_BIN_SIZE_N( 5, bin - 0x50 ) : \
+                                 (bin) >= 0x40 ? BLOCK_BIN_SIZE_N( 4, bin - 0x40 ) : \
+                                 (bin) >= 0x30 ? BLOCK_BIN_SIZE_N( 3, bin - 0x30 ) : \
+                                 (bin) >= 0x20 ? BLOCK_BIN_SIZE_N( 2, bin - 0x20 ) : \
+                                 (bin) >= 0x10 ? BLOCK_BIN_SIZE_N( 1, bin - 0x10 ) : \
+                                 BLOCK_BIN_SIZE_N( 0, bin ))
+
+#define BLOCK_SIZE_BIN( size )  ((size) > BIN_SIZE_MAX   ? 0x80 : \
+                                 (size) > BIN_SIZE_MIN_7 ? 0x70 + BLOCK_SIZE_BIN_N( 7, size ) : \
+                                 (size) > BIN_SIZE_MIN_6 ? 0x60 + BLOCK_SIZE_BIN_N( 6, size ) : \
+                                 (size) > BIN_SIZE_MIN_5 ? 0x50 + BLOCK_SIZE_BIN_N( 5, size ) : \
+                                 (size) > BIN_SIZE_MIN_4 ? 0x40 + BLOCK_SIZE_BIN_N( 4, size ) : \
+                                 (size) > BIN_SIZE_MIN_3 ? 0x30 + BLOCK_SIZE_BIN_N( 3, size ) : \
+                                 (size) > BIN_SIZE_MIN_2 ? 0x20 + BLOCK_SIZE_BIN_N( 2, size ) : \
+                                 (size) > BIN_SIZE_MIN_1 ? 0x10 + BLOCK_SIZE_BIN_N( 1, size ) : \
+                                 (size) <= BIN_SIZE_MIN_0 ?   0 : BLOCK_SIZE_BIN_N( 0, size ))
+
+#define BLOCK_SIZE_BIN_COUNT    (BLOCK_SIZE_BIN( BIN_SIZE_MAX + 1 ) + 1)
+
+/* macros sanity checks */
+C_ASSERT( BLOCK_SIZE_BIN( 0 ) == 0 );
+C_ASSERT( BLOCK_SIZE_BIN( 0x10 ) == 0 );
+C_ASSERT( BLOCK_BIN_SIZE( 0 ) == BIN_SIZE_MIN_0 + 1 * BIN_SIZE_STEP_0 );
+C_ASSERT( BLOCK_SIZE_BIN( 0x11 ) == 1 );
+C_ASSERT( BLOCK_BIN_SIZE( 1 ) == BIN_SIZE_MIN_0 + 2 * BIN_SIZE_STEP_0 );
+C_ASSERT( BLOCK_SIZE_BIN( BIN_SIZE_MAX ) == 0x7f );
+C_ASSERT( BLOCK_BIN_SIZE( 0x7f ) == BIN_SIZE_MAX );
+C_ASSERT( BLOCK_SIZE_BIN( BIN_SIZE_MAX + 1 ) == 0x80 );
+C_ASSERT( BLOCK_BIN_SIZE( 0x80 ) == ~(SIZE_T)0 );
+
+/* difference between block classes and all possible validation overhead must fit into block tail_size */
+C_ASSERT( BIN_SIZE_STEP_7 + 3 * BLOCK_ALIGN <= FIELD_MAX( struct block, tail_size ) );
+
+static BYTE affinity_mapping[] = {20,6,31,15,14,29,27,4,18,24,26,13,0,9,2,30,17,7,23,25,10,19,12,3,22,21,5,16,1,28,11,8};
+static LONG next_thread_affinity;
+
+/* a bin, tracking heap blocks of a certain size */
+struct bin
+{
+    /* counters for LFH activation */
+    LONG count_alloc;
+    LONG count_freed;
+    LONG enabled;
+
+    /* list of groups with free blocks */
+    SLIST_HEADER groups;
+
+    /* array of affinity reserved groups, interleaved with other bins to keep
+     * all pointers of the same affinity and different bin grouped together,
+     * and pointers of the same bin and different affinity away from each other,
+     * hopefully in separate cache lines.
+     */
+    struct group **affinity_group_base;
+};
+
+static inline struct group **bin_get_affinity_group( struct bin *bin, BYTE affinity )
+{
+    return bin->affinity_group_base + affinity * BLOCK_SIZE_BIN_COUNT;
+}
+
 struct heap
 {                                  /* win32/win64 */
     DWORD_PTR        unknown1[2];   /* 0000/0000 */
@@ -194,6 +294,7 @@ struct heap
     DWORD            force_flags;   /* 0044/0074 */
     /* end of the Windows 10 compatible struct layout */
 
+    LONG             compat_info;   /* HeapCompatibilityInformation / heap frontend type */
     struct list      entry;         /* Entry in process heap list */
     struct list      subheap_list;  /* Sub-heap list */
     struct list      large_list;    /* Large blocks list */
@@ -204,6 +305,7 @@ struct heap
     struct block   **pending_free;  /* Ring buffer for pending free requests */
     RTL_CRITICAL_SECTION cs;
     struct entry     free_lists[HEAP_NB_FREE_LISTS];
+    struct bin      *bins;
     SUBHEAP          subheap;
 };
 
@@ -338,8 +440,10 @@ static inline struct block *next_block( const SUBHEAP *subheap, const struct blo
     return (struct block *)next;
 }
 
-static inline BOOL check_subheap( const SUBHEAP *subheap )
+static inline BOOL check_subheap( const SUBHEAP *subheap, const struct heap *heap )
 {
+    if (subheap->user_value != heap) return FALSE;
+
     return contains( &subheap->block, subheap->block_size, subheap + 1, subheap->data_size );
 }
 
@@ -447,13 +551,13 @@ static inline void valgrind_notify_resize( void const *ptr, SIZE_T size_old, SIZ
 #endif
 }
 
-static void valgrind_notify_free_all( SUBHEAP *subheap )
+static void valgrind_notify_free_all( SUBHEAP *subheap, const struct heap *heap )
 {
 #ifdef VALGRIND_FREELIKE_BLOCK
     struct block *block;
 
     if (!RUNNING_ON_VALGRIND) return;
-    if (!check_subheap( subheap )) return;
+    if (!check_subheap( subheap, heap )) return;
 
     for (block = first_block( subheap ); block; block = next_block( subheap, block ))
     {
@@ -534,6 +638,16 @@ static void heap_dump( const struct heap *heap )
     TRACE( "heap: %p\n", heap );
     TRACE( "  next %p\n", LIST_ENTRY( heap->entry.next, struct heap, entry ) );
 
+    TRACE( "  bins:\n" );
+    for (i = 0; heap->bins && i < BLOCK_SIZE_BIN_COUNT; i++)
+    {
+        const struct bin *bin = heap->bins + i;
+        ULONG alloc = ReadNoFence( &bin->count_alloc ), freed = ReadNoFence( &bin->count_freed );
+        if (!alloc && !freed) continue;
+        TRACE( "    %3u: size %#4Ix, alloc %ld, freed %ld, enabled %lu\n", i, BLOCK_BIN_SIZE( i ),
+               alloc, freed, ReadNoFence( &bin->enabled ) );
+    }
+
     TRACE( "  free_lists: %p\n", heap->free_lists );
     for (i = 0; i < HEAP_NB_FREE_LISTS; i++)
         TRACE( "    %p: size %#8Ix, prev %p, next %p\n", heap->free_lists + i, get_free_list_block_size( i ),
@@ -549,7 +663,7 @@ static void heap_dump( const struct heap *heap )
         TRACE( "    %p: base %p first %p last %p end %p\n", subheap, base, first_block( subheap ),
                last_block( subheap ), base + subheap_size( subheap ) );
 
-        if (!check_subheap( subheap )) return;
+        if (!check_subheap( subheap, heap )) return;
 
         overhead += subheap_overhead( subheap );
         for (block = first_block( subheap ); block; block = next_block( subheap, block ))
@@ -648,10 +762,10 @@ static SUBHEAP *find_subheap( const struct heap *heap, const struct block *block
     LIST_FOR_EACH_ENTRY( subheap, &heap->subheap_list, SUBHEAP, entry )
     {
         SIZE_T blocks_size = (char *)last_block( subheap ) - (char *)first_block( subheap );
-        if (!check_subheap( subheap )) return NULL;
+        if (!check_subheap( subheap, heap )) return NULL;
         if (contains( first_block( subheap ), blocks_size, block, sizeof(*block) )) return subheap;
         /* outside of blocks region, possible corruption or heap_walk */
-        if (contains( subheap_base( subheap ), subheap_size( subheap ), block, 0 )) return heap_walk ? subheap : NULL;
+        if (contains( subheap_base( subheap ), subheap_size( subheap ), block, 1 )) return heap_walk ? subheap : NULL;
     }
 
     return NULL;
@@ -1067,7 +1181,8 @@ static BOOL validate_free_block( const struct heap *heap, const SUBHEAP *subheap
 }
 
 
-static BOOL validate_used_block( const struct heap *heap, const SUBHEAP *subheap, const struct block *block )
+static BOOL validate_used_block( const struct heap *heap, const SUBHEAP *subheap, const struct block *block,
+                                 unsigned int expected_block_type )
 {
     const char *err = NULL, *base = subheap_base( subheap ), *commit_end = subheap_commit_end( subheap );
     DWORD flags = heap->flags;
@@ -1078,13 +1193,17 @@ static BOOL validate_used_block( const struct heap *heap, const SUBHEAP *subheap
         err = "invalid block BLOCK_ALIGN";
     else if (block_get_type( block ) != BLOCK_TYPE_USED && block_get_type( block ) != BLOCK_TYPE_DEAD)
         err = "invalid block header";
+    else if (expected_block_type && block_get_type( block ) != expected_block_type)
+        err = "invalid block type";
     else if (block_get_flags( block ) & BLOCK_FLAG_FREE)
         err = "invalid block flags";
     else if (!contains( base, commit_end - base, block, block_get_size( block ) ))
         err = "invalid block size";
     else if (block->tail_size > block_get_size( block ) - sizeof(*block))
         err = "invalid block unused size";
-    else if ((next = next_block( subheap, block )) && (block_get_flags( next ) & BLOCK_FLAG_PREV_FREE))
+    else if ((next = next_block( subheap, block )) && (block_get_flags( next ) & BLOCK_FLAG_PREV_FREE) &&
+             /* LFH blocks do not use BLOCK_FLAG_PREV_FREE or back pointer */
+             !(block_get_flags( block ) & BLOCK_FLAG_LFH))
         err = "invalid next block flags";
     else if (block_get_flags( block ) & BLOCK_FLAG_PREV_FREE)
     {
@@ -1131,14 +1250,14 @@ static BOOL heap_validate_ptr( const struct heap *heap, const void *ptr )
     {
         if (!find_large_block( heap, block ))
         {
-            if (WARN_ON(heap)) WARN("heap %p, ptr %p: block region not found\n", heap, ptr );
+            WARN("heap %p, ptr %p: block region not found\n", heap, ptr );
             return FALSE;
         }
 
         return validate_large_block( heap, block );
     }
 
-    return validate_used_block( heap, subheap, block );
+    return validate_used_block( heap, subheap, block, BLOCK_TYPE_USED );
 }
 
 static BOOL heap_validate( const struct heap *heap )
@@ -1149,9 +1268,9 @@ static BOOL heap_validate( const struct heap *heap )
 
     LIST_FOR_EACH_ENTRY( subheap, &heap->subheap_list, SUBHEAP, entry )
     {
-        if (!check_subheap( subheap ))
+        if (!check_subheap( subheap, heap ))
         {
-            ERR( "heap %p, subheap %p corrupted sizes\n", heap, subheap );
+            ERR( "heap %p, subheap %p corrupted sizes or user_value\n", heap, subheap );
             if (TRACE_ON(heap)) heap_dump( heap );
             return FALSE;
         }
@@ -1164,7 +1283,37 @@ static BOOL heap_validate( const struct heap *heap )
             }
             else
             {
-                if (!validate_used_block( heap, subheap, block )) return FALSE;
+                if (!validate_used_block( heap, subheap, block, 0 )) return FALSE;
+            }
+        }
+    }
+
+    if (heap->pending_free)
+    {
+        unsigned int i;
+
+        for (i = 0; i < MAX_FREE_PENDING; i++)
+        {
+            if (!(block = heap->pending_free[i])) break;
+
+            subheap = find_subheap( heap, block, FALSE );
+            if (!subheap)
+            {
+                ERR( "heap %p: cannot find valid subheap for delayed freed block %p\n", heap, block );
+                if (TRACE_ON(heap)) heap_dump( heap );
+                return FALSE;
+            }
+
+            if (!validate_used_block( heap, subheap, block, BLOCK_TYPE_DEAD )) return FALSE;
+        }
+
+        for (; i < MAX_FREE_PENDING; i++)
+        {
+            if ((block = heap->pending_free[i]))
+            {
+                ERR( "heap %p: unexpected delayed freed block %p at slot %u\n", heap, block, i );
+                if (TRACE_ON(heap)) heap_dump( heap );
+                return FALSE;
             }
         }
     }
@@ -1191,6 +1340,16 @@ static inline struct block *unsafe_block_from_ptr( struct heap *heap, ULONG flag
 
     if ((ULONG_PTR)ptr % BLOCK_ALIGN)
         err = "invalid ptr alignment";
+    else if (block_get_type( block ) == BLOCK_TYPE_DEAD)
+        err = "delayed freed block";
+    else if (block_get_type( block ) == BLOCK_TYPE_FREE)
+        err = "already freed block";
+    else if (block_get_flags( block ) & BLOCK_FLAG_LFH)
+    {
+        /* LFH block base_offset points to the group, not the subheap */
+        if (block_get_type( block ) != BLOCK_TYPE_USED)
+            err = "invalid block type";
+    }
     else if ((subheap = block_get_subheap( heap, block )) >= (SUBHEAP *)block)
         err = "invalid base offset";
     else if (block_get_type( block ) == BLOCK_TYPE_USED)
@@ -1204,12 +1363,10 @@ static inline struct block *unsafe_block_from_ptr( struct heap *heap, ULONG flag
         ARENA_LARGE *large = subheap_base( subheap );
         if (block != &large->block) err = "invalid large block";
     }
-    else if (block_get_type( block ) == BLOCK_TYPE_DEAD)
-        err = "delayed freed block";
-    else if (block_get_type( block ) == BLOCK_TYPE_FREE)
-        err = "already freed block";
     else
+    {
         err = "invalid block type";
+    }
 
     if (err) WARN( "heap %p, block %p: %s\n", heap, block, err );
     return err ? NULL : block;
@@ -1268,7 +1425,7 @@ static void heap_set_debug_flags( HANDLE handle )
         {
             const char *commit_end = subheap_commit_end( subheap );
 
-            if (!check_subheap( subheap )) break;
+            if (!check_subheap( subheap, heap )) break;
 
             for (block = first_block( subheap ); block; block = next_block( subheap, block ))
             {
@@ -1343,6 +1500,7 @@ HANDLE WINAPI RtlCreateHeap( ULONG flags, void *addr, SIZE_T total_size, SIZE_T
     heap->ffeeffee      = 0xffeeffee;
     heap->auto_flags    = (flags & HEAP_GROWABLE);
     heap->flags         = (flags & ~HEAP_SHARED);
+    heap->compat_info   = HEAP_STD;
     heap->magic         = HEAP_MAGIC;
     heap->grow_size     = max( HEAP_DEF_SIZE, total_size );
     heap->min_size      = commit_size;
@@ -1386,6 +1544,20 @@ HANDLE WINAPI RtlCreateHeap( ULONG flags, void *addr, SIZE_T total_size, SIZE_T
 
     heap_set_debug_flags( heap );
 
+    if (heap->flags & HEAP_GROWABLE)
+    {
+        SIZE_T size = (sizeof(struct bin) + sizeof(struct group *) * ARRAY_SIZE(affinity_mapping)) * BLOCK_SIZE_BIN_COUNT;
+        NtAllocateVirtualMemory( NtCurrentProcess(), (void *)&heap->bins,
+                                 0, &size, MEM_COMMIT, PAGE_READWRITE );
+
+        for (i = 0; heap->bins && i < BLOCK_SIZE_BIN_COUNT; ++i)
+        {
+            RtlInitializeSListHead( &heap->bins[i].groups );
+            /* offset affinity_group_base to interleave the bin affinity group pointers */
+            heap->bins[i].affinity_group_base = (struct group **)(heap->bins + BLOCK_SIZE_BIN_COUNT) + i;
+        }
+    }
+
     /* link it into the per-process heap list */
     if (process_heap)
     {
@@ -1464,13 +1636,18 @@ HANDLE WINAPI RtlDestroyHeap( HANDLE handle )
     LIST_FOR_EACH_ENTRY_SAFE( subheap, next, &heap->subheap_list, SUBHEAP, entry )
     {
         if (subheap == &heap->subheap) continue;  /* do this one last */
-        valgrind_notify_free_all( subheap );
+        valgrind_notify_free_all( subheap, heap );
         list_remove( &subheap->entry );
         size = 0;
         addr = ROUND_ADDR( subheap, REGION_ALIGN - 1 );
         NtFreeVirtualMemory( NtCurrentProcess(), &addr, &size, MEM_RELEASE );
     }
-    valgrind_notify_free_all( &heap->subheap );
+    valgrind_notify_free_all( &heap->subheap, heap );
+    if ((addr = heap->bins))
+    {
+        size = 0;
+        NtFreeVirtualMemory( NtCurrentProcess(), &addr, &size, MEM_RELEASE );
+    }
     size = 0;
     addr = heap;
     NtFreeVirtualMemory( NtCurrentProcess(), &addr, &size, MEM_RELEASE );
@@ -1528,6 +1705,305 @@ static NTSTATUS heap_allocate_block( struct heap *heap, ULONG flags, SIZE_T bloc
     return STATUS_SUCCESS;
 }
 
+/* Low Fragmentation Heap frontend */
+
+/* header for every LFH block group */
+struct DECLSPEC_ALIGN(BLOCK_ALIGN) group
+{
+    SLIST_ENTRY entry;
+    /* one bit for each free block and the highest bit for GROUP_FLAG_FREE */
+    LONG free_bits;
+    /* affinity of the thread which last allocated from this group */
+    LONG affinity;
+    /* first block of a group, required for alignment */
+    struct block first_block;
+};
+
+#define GROUP_BLOCK_COUNT     (sizeof(((struct group *)0)->free_bits) * 8 - 1)
+#define GROUP_FLAG_FREE       (1u << GROUP_BLOCK_COUNT)
+
+static inline UINT block_get_group_index( const struct block *block )
+{
+    return block->base_offset;
+}
+
+static inline struct group *block_get_group( const struct block *block )
+{
+    SIZE_T block_size = block_get_size( block );
+    void *first_block = (char *)block - block_get_group_index( block ) * block_size;
+    return CONTAINING_RECORD( first_block, struct group, first_block );
+}
+
+static inline void block_set_group( struct block *block, SIZE_T block_size, const struct group *group )
+{
+    SIZE_T offset = (char *)block - (char *)&group->first_block;
+    block->base_offset = offset / block_size;
+}
+
+static inline struct block *group_get_block( struct group *group, SIZE_T block_size, UINT index )
+{
+    char *first_block = (char *)&group->first_block;
+    return (struct block *)(first_block + index * block_size);
+}
+
+/* lookup a free block using the group free_bits, the current thread must own the group */
+static inline struct block *group_find_free_block( struct group *group, SIZE_T block_size )
+{
+    ULONG i, free_bits = ReadNoFence( &group->free_bits );
+    /* free_bits will never be 0 as the group is unlinked when it's fully used */
+    BitScanForward( &i, free_bits );
+    InterlockedAnd( &group->free_bits, ~(1 << i) );
+    return group_get_block( group, block_size, i );
+}
+
+/* allocate a new group block using non-LFH allocation, returns a group owned by current thread */
+static struct group *group_allocate( struct heap *heap, ULONG flags, SIZE_T block_size )
+{
+    SIZE_T i, group_size, group_block_size;
+    struct group *group;
+    NTSTATUS status;
+
+    group_size = offsetof( struct group, first_block ) + GROUP_BLOCK_COUNT * block_size;
+    group_block_size = heap_get_block_size( heap, flags, group_size );
+
+    heap_lock( heap, flags );
+
+    if (group_block_size >= HEAP_MIN_LARGE_BLOCK_SIZE)
+        status = heap_allocate_large( heap, flags & ~HEAP_ZERO_MEMORY, group_block_size, group_size, (void **)&group );
+    else
+        status = heap_allocate_block( heap, flags & ~HEAP_ZERO_MEMORY, group_block_size, group_size, (void **)&group );
+
+    heap_unlock( heap, flags );
+
+    if (status) return NULL;
+
+    block_set_flags( (struct block *)group - 1, 0, BLOCK_FLAG_LFH );
+    group->free_bits = ~GROUP_FLAG_FREE;
+
+    for (i = 0; i < GROUP_BLOCK_COUNT; ++i)
+    {
+        struct block *block = group_get_block( group, block_size, i );
+        valgrind_make_writable( block, sizeof(*block) );
+        block_set_type( block, BLOCK_TYPE_FREE );
+        block_set_flags( block, ~0, BLOCK_FLAG_FREE | BLOCK_FLAG_LFH );
+        block_set_group( block, block_size, group );
+        block_set_size( block, block_size );
+        mark_block_free( block + 1, (char *)block + block_size - (char *)(block + 1), flags );
+    }
+
+    return group;
+}
+
+/* release a fully freed group to the non-LFH subheap, group must be owned by current thread */
+static NTSTATUS group_release( struct heap *heap, ULONG flags, struct bin *bin, struct group *group )
+{
+    struct block *block = (struct block *)group - 1;
+    NTSTATUS status;
+
+    heap_lock( heap, flags );
+
+    block_set_flags( block, BLOCK_FLAG_LFH, 0 );
+
+    if (block_get_flags( block ) & BLOCK_FLAG_LARGE)
+        status = heap_free_large( heap, flags, block );
+    else
+        status = heap_free_block( heap, flags, block );
+
+    heap_unlock( heap, flags );
+
+    return status;
+}
+
+static inline ULONG heap_current_thread_affinity(void)
+{
+    ULONG affinity;
+
+    if (!(affinity = NtCurrentTeb()->HeapVirtualAffinity))
+    {
+        affinity = InterlockedIncrement( &next_thread_affinity );
+        affinity = affinity_mapping[affinity % ARRAY_SIZE(affinity_mapping)];
+        NtCurrentTeb()->HeapVirtualAffinity = affinity;
+    }
+
+    return affinity;
+}
+
+/* acquire a group from the bin, thread takes ownership of a shared group or allocates a new one */
+static struct group *heap_acquire_bin_group( struct heap *heap, ULONG flags, SIZE_T block_size, struct bin *bin )
+{
+    ULONG affinity = NtCurrentTeb()->HeapVirtualAffinity;
+    struct group *group;
+    SLIST_ENTRY *entry;
+
+    if ((group = InterlockedExchangePointer( (void *)bin_get_affinity_group( bin, affinity ), NULL )))
+        return group;
+
+    if ((entry = RtlInterlockedPopEntrySList( &bin->groups )))
+        return CONTAINING_RECORD( entry, struct group, entry );
+
+    return group_allocate( heap, flags, block_size );
+}
+
+/* release a thread owned and fully freed group to the bin shared group, or free its memory */
+static NTSTATUS heap_release_bin_group( struct heap *heap, ULONG flags, struct bin *bin, struct group *group )
+{
+    ULONG affinity = group->affinity;
+
+    /* using InterlockedExchangePointer here would possibly return a group that has used blocks,
+     * we prefer keeping our fully freed group instead for reduced memory consumption.
+     */
+    if (!InterlockedCompareExchangePointer( (void *)bin_get_affinity_group( bin, affinity ), group, NULL ))
+        return STATUS_SUCCESS;
+
+    /* try re-using the block group instead of releasing it */
+    if (RtlQueryDepthSList( &bin->groups ) <= ARRAY_SIZE(affinity_mapping))
+    {
+        RtlInterlockedPushEntrySList( &bin->groups, &group->entry );
+        return STATUS_SUCCESS;
+    }
+
+    return group_release( heap, flags, bin, group );
+}
+
+static struct block *find_free_bin_block( struct heap *heap, ULONG flags, SIZE_T block_size, struct bin *bin )
+{
+    ULONG affinity = heap_current_thread_affinity();
+    struct block *block;
+    struct group *group;
+
+    /* acquire a group, the thread will own it and no other thread can clear free bits.
+     * some other thread might still set the free bits if they are freeing blocks.
+     */
+    if (!(group = heap_acquire_bin_group( heap, flags, block_size, bin ))) return NULL;
+    group->affinity = affinity;
+
+    block = group_find_free_block( group, block_size );
+
+    /* serialize with heap_free_block_lfh: atomically set GROUP_FLAG_FREE when the free bits are all 0. */
+    if (ReadNoFence( &group->free_bits ) || InterlockedCompareExchange( &group->free_bits, GROUP_FLAG_FREE, 0 ))
+    {
+        /* if GROUP_FLAG_FREE isn't set, thread is responsible for putting it back into group list. */
+        if ((group = InterlockedExchangePointer( (void *)bin_get_affinity_group( bin, affinity ), group )))
+            RtlInterlockedPushEntrySList( &bin->groups, &group->entry );
+    }
+
+    return block;
+}
+
+static NTSTATUS heap_allocate_block_lfh( struct heap *heap, ULONG flags, SIZE_T block_size,
+                                         SIZE_T size, void **ret )
+{
+    struct bin *bin, *last = heap->bins + BLOCK_SIZE_BIN_COUNT - 1;
+    struct block *block;
+
+    bin = heap->bins + BLOCK_SIZE_BIN( block_size );
+    if (bin == last) return STATUS_UNSUCCESSFUL;
+
+    /* paired with WriteRelease in bin_try_enable. */
+    if (!ReadAcquire( &bin->enabled )) return STATUS_UNSUCCESSFUL;
+
+    block_size = BLOCK_BIN_SIZE( BLOCK_SIZE_BIN( block_size ) );
+
+    if ((block = find_free_bin_block( heap, flags, block_size, bin )))
+    {
+        block_set_type( block, BLOCK_TYPE_USED );
+        block_set_flags( block, ~BLOCK_FLAG_LFH, BLOCK_USER_FLAGS( flags ) );
+        block->tail_size = block_size - sizeof(*block) - size;
+        initialize_block( block, 0, size, flags );
+        mark_block_tail( block, flags );
+        *ret = block + 1;
+    }
+
+    return block ? STATUS_SUCCESS : STATUS_NO_MEMORY;
+}
+
+static NTSTATUS heap_free_block_lfh( struct heap *heap, ULONG flags, struct block *block )
+{
+    struct bin *bin, *last = heap->bins + BLOCK_SIZE_BIN_COUNT - 1;
+    SIZE_T i, block_size = block_get_size( block );
+    struct group *group = block_get_group( block );
+    NTSTATUS status = STATUS_SUCCESS;
+
+    if (!(block_get_flags( block ) & BLOCK_FLAG_LFH)) return STATUS_UNSUCCESSFUL;
+
+    bin = heap->bins + BLOCK_SIZE_BIN( block_size );
+    if (bin == last) return STATUS_UNSUCCESSFUL;
+
+    i = block_get_group_index( block );
+    valgrind_make_writable( block, sizeof(*block) );
+    block_set_type( block, BLOCK_TYPE_FREE );
+    block_set_flags( block, ~BLOCK_FLAG_LFH, BLOCK_FLAG_FREE );
+    mark_block_free( block + 1, (char *)block + block_size - (char *)(block + 1), flags );
+
+    /* if this was the last used block in a group and GROUP_FLAG_FREE was set */
+    if (InterlockedOr( &group->free_bits, 1 << i ) == ~(1 << i))
+    {
+        /* thread now owns the group, and can release it to its bin */
+        group->free_bits = ~GROUP_FLAG_FREE;
+        status = heap_release_bin_group( heap, flags, bin, group );
+    }
+
+    return status;
+}
+
+static void bin_try_enable( struct heap *heap, struct bin *bin )
+{
+    ULONG alloc = ReadNoFence( &bin->count_alloc ), freed = ReadNoFence( &bin->count_freed );
+    SIZE_T block_size = BLOCK_BIN_SIZE( bin - heap->bins );
+    BOOL enable = FALSE;
+
+    if (bin == heap->bins && alloc > 0x10) enable = TRUE;
+    else if (bin - heap->bins < 0x30 && alloc > 0x800) enable = TRUE;
+    else if (bin - heap->bins < 0x30 && alloc - freed > 0x10) enable = TRUE;
+    else if (alloc - freed > 0x400000 / block_size) enable = TRUE;
+    if (!enable) return;
+
+    if (ReadNoFence( &heap->compat_info ) != HEAP_LFH)
+    {
+        ULONG info = HEAP_LFH;
+        RtlSetHeapInformation( heap, HeapCompatibilityInformation, &info, sizeof(info) );
+    }
+
+    /* paired with ReadAcquire in heap_allocate_block_lfh.
+     *
+     * The acq/rel barrier on the enabled flag is protecting compat_info
+     * (i.e. compat_info := LFH happens-before enabled := TRUE), so that
+     * a caller that observes LFH block allocation (alloc request
+     * succeeds without heap lock) will never observe HEAP_STD when it
+     * queries the heap.
+     */
+    WriteRelease( &bin->enabled, TRUE );
+}
+
+static void heap_thread_detach_bin_groups( struct heap *heap )
+{
+    ULONG i, affinity = NtCurrentTeb()->HeapVirtualAffinity;
+
+    if (!heap->bins) return;
+
+    for (i = 0; i < BLOCK_SIZE_BIN_COUNT; ++i)
+    {
+        struct bin *bin = heap->bins + i;
+        struct group *group;
+        if (!(group = InterlockedExchangePointer( (void *)bin_get_affinity_group( bin, affinity ), NULL ))) continue;
+        RtlInterlockedPushEntrySList( &bin->groups, &group->entry );
+    }
+}
+
+void heap_thread_detach(void)
+{
+    struct heap *heap;
+
+    RtlEnterCriticalSection( &process_heap->cs );
+
+    LIST_FOR_EACH_ENTRY( heap, &process_heap->entry, struct heap, entry )
+        heap_thread_detach_bin_groups( heap );
+
+    heap_thread_detach_bin_groups( process_heap );
+
+    RtlLeaveCriticalSection( &process_heap->cs );
+}
+
 /***********************************************************************
  *           RtlAllocateHeap   (NTDLL.@)
  */
@@ -1545,11 +2021,20 @@ void *WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE handle, ULONG flags, SIZE
         status = STATUS_NO_MEMORY;
     else if (block_size >= HEAP_MIN_LARGE_BLOCK_SIZE)
         status = heap_allocate_large( heap, heap_flags, block_size, size, &ptr );
+    else if (heap->bins && !heap_allocate_block_lfh( heap, heap_flags, block_size, size, &ptr ))
+        status = STATUS_SUCCESS;
     else
     {
         heap_lock( heap, heap_flags );
         status = heap_allocate_block( heap, heap_flags, block_size, size, &ptr );
         heap_unlock( heap, heap_flags );
+
+        if (!status && heap->bins)
+        {
+            SIZE_T bin = BLOCK_SIZE_BIN( block_get_size( (struct block *)ptr - 1 ) );
+            InterlockedIncrement( &heap->bins[bin].count_alloc );
+            if (!ReadNoFence( &heap->bins[bin].enabled )) bin_try_enable( heap, &heap->bins[bin] );
+        }
     }
 
     if (!status) valgrind_notify_alloc( ptr, size, flags & HEAP_ZERO_MEMORY );
@@ -1582,11 +2067,17 @@ BOOLEAN WINAPI DECLSPEC_HOTPATCH RtlFreeHeap( HANDLE handle, ULONG flags, void *
         status = heap_free_large( heap, heap_flags, block );
     else if (!(block = heap_delay_free( heap, heap_flags, block )))
         status = STATUS_SUCCESS;
+    else if (!heap_free_block_lfh( heap, heap_flags, block ))
+        status = STATUS_SUCCESS;
     else
     {
+        SIZE_T block_size = block_get_size( block ), bin = BLOCK_SIZE_BIN( block_size );
+
         heap_lock( heap, heap_flags );
         status = heap_free_block( heap, heap_flags, block );
         heap_unlock( heap, heap_flags );
+
+        if (!status && heap->bins) InterlockedIncrement( &heap->bins[bin].count_freed );
     }
 
     TRACE( "handle %p, flags %#lx, ptr %p, return %u, status %#lx.\n", handle, flags, ptr, !status, status );
@@ -1594,56 +2085,46 @@ BOOLEAN WINAPI DECLSPEC_HOTPATCH RtlFreeHeap( HANDLE handle, ULONG flags, void *
     return !status;
 }
 
-static NTSTATUS heap_resize_block( struct heap *heap, ULONG flags, struct block *block, SIZE_T block_size,
+static NTSTATUS heap_resize_large( struct heap *heap, ULONG flags, struct block *block, SIZE_T block_size,
                                    SIZE_T size, SIZE_T *old_size, void **ret )
 {
-    SUBHEAP *subheap = block_get_subheap( heap, block );
-    SIZE_T old_block_size;
-    struct entry *entry;
-    struct block *next;
+    ARENA_LARGE *large = CONTAINING_RECORD( block, ARENA_LARGE, block );
+    SIZE_T old_block_size = large->block_size;
+    *old_size = large->data_size;
 
-    if (block_get_flags( block ) & BLOCK_FLAG_LARGE)
-    {
-        ARENA_LARGE *large = CONTAINING_RECORD( block, ARENA_LARGE, block );
-        old_block_size = large->block_size;
-        *old_size = large->data_size;
-
-        if (block_size < HEAP_MIN_LARGE_BLOCK_SIZE / 4) return STATUS_NO_MEMORY;  /* shrinking large block to small block */
-        if (old_block_size < block_size) return STATUS_NO_MEMORY;
-
-        /* FIXME: we could remap zero-pages instead */
-        valgrind_notify_resize( block + 1, *old_size, size );
-        initialize_block( block, *old_size, size, flags );
+    if (old_block_size < block_size) return STATUS_NO_MEMORY;
 
-        large->data_size = size;
-        valgrind_make_noaccess( (char *)block + sizeof(*block) + large->data_size,
-                                old_block_size - sizeof(*block) - large->data_size );
-
-        *ret = block + 1;
-        return STATUS_SUCCESS;
-    }
+    /* FIXME: we could remap zero-pages instead */
+    valgrind_notify_resize( block + 1, *old_size, size );
+    initialize_block( block, *old_size, size, flags );
 
-    old_block_size = block_get_size( block );
-    *old_size = old_block_size - block_get_overhead( block );
+    large->data_size = size;
+    valgrind_make_noaccess( (char *)block + sizeof(*block) + large->data_size,
+                            old_block_size - sizeof(*block) - large->data_size );
 
-    if (block_size >= HEAP_MIN_LARGE_BLOCK_SIZE) return STATUS_NO_MEMORY;  /* growing small block to large block */
+    *ret = block + 1;
+    return STATUS_SUCCESS;
+}
 
-    heap_lock( heap, flags );
+static NTSTATUS heap_resize_block( struct heap *heap, ULONG flags, struct block *block, SIZE_T block_size,
+                                   SIZE_T size, SIZE_T old_block_size, SIZE_T *old_size, void **ret )
+{
+    SUBHEAP *subheap = block_get_subheap( heap, block );
+    struct block *next;
 
     if (block_size > old_block_size)
     {
-        if (!(next = next_block( subheap, block )) || !(block_get_flags( next ) & BLOCK_FLAG_FREE) ||
-            block_size > old_block_size + block_get_size( next ) || !subheap_commit( heap, subheap, block, block_size ))
-        {
-            heap_unlock( heap, flags );
-            return STATUS_NO_MEMORY;
-        }
+        /* need to grow block, make sure it's followed by large enough free block */
+        if (!(next = next_block( subheap, block ))) return STATUS_NO_MEMORY;
+        if (!(block_get_flags( next ) & BLOCK_FLAG_FREE)) return STATUS_NO_MEMORY;
+        if (block_size > old_block_size + block_get_size( next )) return STATUS_NO_MEMORY;
+        if (!subheap_commit( heap, subheap, block, block_size )) return STATUS_NO_MEMORY;
     }
 
     if ((next = next_block( subheap, block )) && (block_get_flags( next ) & BLOCK_FLAG_FREE))
     {
         /* merge with next block if it is free */
-        entry = (struct entry *)next;
+        struct entry *entry = (struct entry *)next;
         list_remove( &entry->entry );
         old_block_size += block_get_size( next );
     }
@@ -1662,12 +2143,58 @@ static NTSTATUS heap_resize_block( struct heap *heap, ULONG flags, struct block
 
     if ((next = next_block( subheap, block ))) block_set_flags( next, BLOCK_FLAG_PREV_FREE, 0 );
 
-    heap_unlock( heap, flags );
+    *ret = block + 1;
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS heap_resize_block_lfh( struct block *block, ULONG flags, SIZE_T block_size, SIZE_T size, SIZE_T *old_size, void **ret )
+{
+    /* as native LFH does it with different block size: refuse to resize even though we could */
+    if (ROUND_SIZE( *old_size, BLOCK_ALIGN - 1) != ROUND_SIZE( size, BLOCK_ALIGN - 1)) return STATUS_NO_MEMORY;
+    if (size >= *old_size) return STATUS_NO_MEMORY;
+
+    block_set_flags( block, BLOCK_FLAG_USER_MASK & ~BLOCK_FLAG_USER_INFO, BLOCK_USER_FLAGS( flags ) );
+    block->tail_size = block_size - sizeof(*block) - size;
+    initialize_block( block, *old_size, size, flags );
+    mark_block_tail( block, flags );
 
     *ret = block + 1;
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS heap_resize_in_place( struct heap *heap, ULONG flags, struct block *block, SIZE_T block_size,
+                                      SIZE_T size, SIZE_T *old_size, void **ret )
+{
+    SIZE_T old_bin, old_block_size;
+    NTSTATUS status;
+
+    if (block_get_flags( block ) & BLOCK_FLAG_LARGE)
+        return heap_resize_large( heap, flags, block, block_size, size, old_size, ret );
+
+    old_block_size = block_get_size( block );
+    *old_size = old_block_size - block_get_overhead( block );
+    old_bin = BLOCK_SIZE_BIN( old_block_size );
+
+    if (block_size >= HEAP_MIN_LARGE_BLOCK_SIZE) return STATUS_NO_MEMORY;  /* growing small block to large block */
+
+    if (block_get_flags( block ) & BLOCK_FLAG_LFH)
+        return heap_resize_block_lfh( block, flags, block_size, size, old_size, ret );
+
+    heap_lock( heap, flags );
+    status = heap_resize_block( heap, flags, block, block_size, size, old_block_size, old_size, ret );
+    heap_unlock( heap, flags );
+
+    if (!status && heap->bins)
+    {
+        SIZE_T new_bin = BLOCK_SIZE_BIN( block_size );
+        InterlockedIncrement( &heap->bins[old_bin].count_freed );
+        InterlockedIncrement( &heap->bins[new_bin].count_alloc );
+        if (!ReadNoFence( &heap->bins[new_bin].enabled )) bin_try_enable( heap, &heap->bins[new_bin] );
+    }
+
+    return status;
+}
+
 /***********************************************************************
  *           RtlReAllocateHeap   (NTDLL.@)
  */
@@ -1688,8 +2215,8 @@ void *WINAPI RtlReAllocateHeap( HANDLE handle, ULONG flags, void *ptr, SIZE_T si
         status = STATUS_NO_MEMORY;
     else if (!(block = unsafe_block_from_ptr( heap, heap_flags, ptr )))
         status = STATUS_INVALID_PARAMETER;
-    else if ((status = heap_resize_block( heap, heap_flags, block, block_size, size,
-                                          &old_size, &ret )))
+    else if ((status = heap_resize_in_place( heap, heap_flags, block, block_size, size,
+                                        &old_size, &ret )))
     {
         if (flags & HEAP_REALLOC_IN_PLACE_ONLY)
             status = STATUS_NO_MEMORY;
@@ -2004,21 +2531,24 @@ ULONG WINAPI RtlGetProcessHeaps( ULONG count, HANDLE *heaps )
  *           RtlQueryHeapInformation    (NTDLL.@)
  */
 NTSTATUS WINAPI RtlQueryHeapInformation( HANDLE handle, HEAP_INFORMATION_CLASS info_class,
-                                         void *info, SIZE_T size_in, PSIZE_T size_out )
+                                         void *info, SIZE_T size_in, SIZE_T *size_out )
 {
+    struct heap *heap;
+    ULONG flags;
+
+    TRACE( "handle %p, info_class %u, info %p, size_in %Iu, size_out %p.\n", handle, info_class, info, size_in, size_out );
+
     switch (info_class)
     {
     case HeapCompatibilityInformation:
+        if (!(heap = unsafe_heap_from_handle( handle, 0, &flags ))) return STATUS_ACCESS_VIOLATION;
         if (size_out) *size_out = sizeof(ULONG);
-
-        if (size_in < sizeof(ULONG))
-            return STATUS_BUFFER_TOO_SMALL;
-
-        *(ULONG *)info = 0; /* standard heap */
+        if (size_in < sizeof(ULONG)) return STATUS_BUFFER_TOO_SMALL;
+        *(ULONG *)info = ReadNoFence( &heap->compat_info );
         return STATUS_SUCCESS;
 
     default:
-        FIXME("Unknown heap information class %u\n", info_class);
+        FIXME( "HEAP_INFORMATION_CLASS %u not implemented!\n", info_class );
         return STATUS_INVALID_INFO_CLASS;
     }
 }
@@ -2028,8 +2558,36 @@ NTSTATUS WINAPI RtlQueryHeapInformation( HANDLE handle, HEAP_INFORMATION_CLASS i
  */
 NTSTATUS WINAPI RtlSetHeapInformation( HANDLE handle, HEAP_INFORMATION_CLASS info_class, void *info, SIZE_T size )
 {
-    FIXME( "handle %p, info_class %d, info %p, size %Id stub!\n", handle, info_class, info, size );
-    return STATUS_SUCCESS;
+    struct heap *heap;
+    ULONG flags;
+
+    TRACE( "handle %p, info_class %u, info %p, size %Iu.\n", handle, info_class, info, size );
+
+    switch (info_class)
+    {
+    case HeapCompatibilityInformation:
+    {
+        ULONG compat_info;
+
+        if (size < sizeof(ULONG)) return STATUS_BUFFER_TOO_SMALL;
+        if (!(heap = unsafe_heap_from_handle( handle, 0, &flags ))) return STATUS_INVALID_HANDLE;
+        if (heap->flags & HEAP_NO_SERIALIZE) return STATUS_INVALID_PARAMETER;
+
+        compat_info = *(ULONG *)info;
+        if (compat_info != HEAP_STD && compat_info != HEAP_LFH)
+        {
+            FIXME( "HeapCompatibilityInformation %lu not implemented!\n", compat_info );
+            return STATUS_UNSUCCESSFUL;
+        }
+        if (InterlockedCompareExchange( &heap->compat_info, compat_info, HEAP_STD ) != HEAP_STD)
+            return STATUS_UNSUCCESSFUL;
+        return STATUS_SUCCESS;
+    }
+
+    default:
+        FIXME( "HEAP_INFORMATION_CLASS %u not implemented!\n", info_class );
+        return STATUS_SUCCESS;
+    }
 }
 
 /***********************************************************************
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 61aeb25898b..f533db060d0 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -77,7 +77,7 @@ static DWORD (WINAPI *pCtrlRoutine)(void *);
 
 SYSTEM_DLL_INIT_BLOCK LdrSystemDllInitBlock = { 0xf0 };
 
-unixlib_handle_t ntdll_unix_handle = 0;
+unixlib_handle_t __wine_unixlib_handle = 0;
 
 /* windows directory */
 const WCHAR windows_dir[] = L"C:\\windows";
@@ -1222,7 +1222,7 @@ static BOOL is_dll_native_subsystem( LDR_DATA_TABLE_ENTRY *mod, const IMAGE_NT_H
  * Allocate a TLS slot for a newly-loaded module.
  * The loader_section must be locked while calling this function.
  */
-static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
+static BOOL alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
 {
     const IMAGE_TLS_DIRECTORY *dir;
     ULONG i, size;
@@ -1230,10 +1230,10 @@ static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
     LIST_ENTRY *entry;
 
     if (!(dir = RtlImageDirectoryEntryToData( mod->DllBase, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &size )))
-        return -1;
+        return FALSE;
 
     size = dir->EndAddressOfRawData - dir->StartAddressOfRawData;
-    if (!size && !dir->SizeOfZeroFill && !dir->AddressOfCallBacks) return -1;
+    if (!size && !dir->SizeOfZeroFill && !dir->AddressOfCallBacks) return FALSE;
 
     for (i = 0; i < tls_module_count; i++)
     {
@@ -1255,7 +1255,7 @@ static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
         else
             new_ptr = RtlReAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, tls_dirs,
                                          new_count * sizeof(*tls_dirs) );
-        if (!new_ptr) return -1;
+        if (!new_ptr) return FALSE;
 
         /* resize the pointer block in all running threads */
         for (entry = tls_links.Flink; entry != &tls_links; entry = entry->Flink)
@@ -1264,7 +1264,7 @@ static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
             void **old = teb->ThreadLocalStoragePointer;
             void **new = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, new_count * sizeof(*new));
 
-            if (!new) return -1;
+            if (!new) return FALSE;
             if (old) memcpy( new, old, tls_module_count * sizeof(*new) );
             teb->ThreadLocalStoragePointer = new;
 #ifdef __x86_64__  /* macOS-specific hack */
@@ -1296,7 +1296,7 @@ static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
 
     *(DWORD *)dir->AddressOfIndex = i;
     tls_dirs[i] = *dir;
-    return i;
+    return TRUE;
 }
 
 
@@ -1308,9 +1308,15 @@ static SHORT alloc_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
  */
 static void free_tls_slot( LDR_DATA_TABLE_ENTRY *mod )
 {
-    ULONG i = (USHORT)mod->TlsIndex;
+    const IMAGE_TLS_DIRECTORY *dir;
+    ULONG i, size;
 
-    if (mod->TlsIndex == -1) return;
+    if (mod->TlsIndex != -1)
+        return;
+    if (!(dir = RtlImageDirectoryEntryToData( mod->DllBase, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &size )))
+        return;
+
+    i = *(ULONG*)dir->AddressOfIndex;
     assert( i < tls_module_count );
     memset( &tls_dirs[i], 0, sizeof(tls_dirs[i]) );
 }
@@ -1374,7 +1380,7 @@ static NTSTATUS fixup_imports( WINE_MODREF *wm, LPCWSTR load_path )
     if (!(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS)) return STATUS_SUCCESS;  /* already done */
     wm->ldr.Flags &= ~LDR_DONT_RESOLVE_REFS;
 
-    wm->ldr.TlsIndex = alloc_tls_slot( &wm->ldr );
+    if (alloc_tls_slot( &wm->ldr )) wm->ldr.TlsIndex = -1;
 
     if (!(imports = RtlImageDirectoryEntryToData( wm->ldr.DllBase, TRUE,
                                                   IMAGE_DIRECTORY_ENTRY_IMPORT, &size )))
@@ -1431,7 +1437,7 @@ static WINE_MODREF *alloc_module( HMODULE hModule, const UNICODE_STRING *nt_name
     wm->ldr.DllBase       = hModule;
     wm->ldr.SizeOfImage   = nt->OptionalHeader.SizeOfImage;
     wm->ldr.Flags         = LDR_DONT_RESOLVE_REFS | (builtin ? LDR_WINE_INTERNAL : 0);
-    wm->ldr.TlsIndex      = -1;
+    wm->ldr.TlsIndex      = 0;
     wm->ldr.LoadCount     = 1;
     wm->CheckSum          = nt->OptionalHeader.CheckSum;
     wm->ldr.TimeDateStamp = nt->FileHeader.TimeDateStamp;
@@ -1783,7 +1789,7 @@ NTSTATUS WINAPI LdrDisableThreadCalloutsForDll(HMODULE hModule)
     RtlEnterCriticalSection( &loader_section );
 
     wm = get_modref( hModule );
-    if (!wm || wm->ldr.TlsIndex != -1)
+    if (!wm || wm->ldr.TlsIndex == -1)
         ret = STATUS_DLL_NOT_FOUND;
     else
         wm->ldr.Flags |= LDR_NO_DLL_CALLS;
@@ -2189,10 +2195,9 @@ static NTSTATUS build_module( LPCWSTR load_path, const UNICODE_STRING *nt_name,
  */
 static void build_ntdll_module( HMODULE module )
 {
-    UNICODE_STRING nt_name;
+    UNICODE_STRING nt_name = RTL_CONSTANT_STRING( L"\\??\\C:\\windows\\system32\\ntdll.dll" );
     WINE_MODREF *wm;
 
-    RtlInitUnicodeString( &nt_name, L"\\??\\C:\\windows\\system32\\ntdll.dll" );
     wm = alloc_module( module, &nt_name, TRUE );
     assert( wm );
     wm->ldr.Flags &= ~LDR_DONT_RESOLVE_REFS;
@@ -2364,7 +2369,7 @@ static inline WCHAR *append_path( WCHAR *p, const WCHAR *str, int len )
 static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_mode, WCHAR **path )
 {
     const WCHAR *mod_end = module;
-    UNICODE_STRING name, value;
+    UNICODE_STRING name = RTL_CONSTANT_STRING( L"PATH" ), value;
     WCHAR *p, *ret;
     int len = ARRAY_SIZE(system_path) + 1, path_len = 0;
 
@@ -2374,7 +2379,6 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
         len += (mod_end - module) + 1;
     }
 
-    RtlInitUnicodeString( &name, L"PATH" );
     value.Length = 0;
     value.MaximumLength = 0;
     value.Buffer = NULL;
@@ -2623,7 +2627,7 @@ static NTSTATUS load_so_dll( LPCWSTR load_path, const UNICODE_STRING *nt_name,
     struct load_so_dll_params params = { *nt_name, &module };
 
     TRACE( "trying %s as so lib\n", debugstr_us(nt_name) );
-    if ((status = NTDLL_UNIX_CALL( load_so_dll, &params )))
+    if ((status = WINE_UNIX_CALL( unix_load_so_dll, &params )))
     {
         WARN( "failed to load .so lib %s\n", debugstr_us(nt_name) );
         if (status == STATUS_INVALID_IMAGE_FORMAT) status = STATUS_INVALID_IMAGE_NOT_MZ;
@@ -3149,7 +3153,7 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, DWORD fl
     switch (nts)
     {
     case STATUS_INVALID_IMAGE_NOT_MZ:  /* not in PE format, maybe it's a .so file */
-        if (ntdll_unix_handle) nts = load_so_dll( load_path, &nt_name, flags, pwm );
+        if (__wine_unixlib_handle) nts = load_so_dll( load_path, &nt_name, flags, pwm );
         break;
 
     case STATUS_SUCCESS:  /* valid PE file */
@@ -3195,6 +3199,49 @@ NTSTATUS WINAPI __wine_unix_call( unixlib_handle_t handle, unsigned int code, vo
 }
 
 
+/***********************************************************************
+ *           __wine_unix_spawnvp
+ */
+NTSTATUS WINAPI __wine_unix_spawnvp( char * const argv[], int wait )
+{
+    struct wine_spawnvp_params params = { (char **)argv, wait };
+
+    return WINE_UNIX_CALL( unix_wine_spawnvp, &params );
+}
+
+
+/***********************************************************************
+ *           wine_server_call
+ */
+unsigned int CDECL wine_server_call( void *req_ptr )
+{
+    return WINE_UNIX_CALL( unix_wine_server_call, req_ptr );
+}
+
+
+/***********************************************************************
+ *           wine_server_fd_to_handle
+ */
+NTSTATUS CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int attributes,
+                                         HANDLE *handle )
+{
+    struct wine_server_fd_to_handle_params params = { fd, access, attributes, handle };
+
+    return WINE_UNIX_CALL( unix_wine_server_fd_to_handle, &params );
+}
+
+
+/***********************************************************************
+ *           wine_server_handle_to_fd (NTDLL.@)
+ */
+NTSTATUS CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd,
+                                         unsigned int *options )
+{
+    struct wine_server_handle_to_fd_params params = { handle, access, unix_fd, options };
+
+    return WINE_UNIX_CALL( unix_wine_server_handle_to_fd, &params );
+}
+
 /******************************************************************
  *		LdrLoadDll (NTDLL.@)
  */
@@ -3712,7 +3759,7 @@ void WINAPI LdrShutdownThread(void)
                         DLL_THREAD_DETACH, NULL );
     }
 
-    if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.DllBase, DLL_THREAD_DETACH );
+    if (wm->ldr.TlsIndex == -1) call_tls_callbacks( wm->ldr.DllBase, DLL_THREAD_DETACH );
 
     RtlAcquirePebLock();
     if (NtCurrentTeb()->TlsLinks.Flink) RemoveEntryList( &NtCurrentTeb()->TlsLinks );
@@ -3731,6 +3778,8 @@ void WINAPI LdrShutdownThread(void)
     /* don't call DbgUiGetThreadDebugObject as some apps hook it and terminate if called */
     if (NtCurrentTeb()->DbgSsReserved[1]) NtClose( NtCurrentTeb()->DbgSsReserved[1] );
     RtlFreeThreadActivationContextStack();
+
+    heap_thread_detach();
 }
 
 
@@ -3945,20 +3994,22 @@ static void process_breakpoint(void)
 static void load_global_options(void)
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING name_str, val_str;
+    UNICODE_STRING bootstrap_mode_str = RTL_CONSTANT_STRING( L"WINEBOOTSTRAPMODE" );
+    UNICODE_STRING session_manager_str =
+        RTL_CONSTANT_STRING( L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );
+    UNICODE_STRING val_str;
     HANDLE hkey;
 
-    RtlInitUnicodeString( &name_str, L"WINEBOOTSTRAPMODE" );
     val_str.MaximumLength = 0;
-    is_prefix_bootstrap = RtlQueryEnvironmentVariable_U( NULL, &name_str, &val_str ) != STATUS_VARIABLE_NOT_FOUND;
+    is_prefix_bootstrap =
+        RtlQueryEnvironmentVariable_U( NULL, &bootstrap_mode_str, &val_str ) != STATUS_VARIABLE_NOT_FOUND;
 
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
-    attr.ObjectName = &name_str;
+    attr.ObjectName = &session_manager_str;
     attr.Attributes = OBJ_CASE_INSENSITIVE;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &name_str, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );
 
     if (!NtOpenKey( &hkey, KEY_QUERY_VALUE, &attr ))
     {
@@ -4013,12 +4064,11 @@ static void map_wow64cpu(void)
 {
     SIZE_T size = 0;
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING string;
+    UNICODE_STRING string = RTL_CONSTANT_STRING( L"\\??\\C:\\windows\\sysnative\\wow64cpu.dll" );
     HANDLE file, section;
     IO_STATUS_BLOCK io;
     NTSTATUS status;
 
-    RtlInitUnicodeString( &string, L"\\??\\C:\\windows\\sysnative\\wow64cpu.dll" );
     InitializeObjectAttributes( &attr, &string, 0, NULL, NULL );
     if ((status = NtOpenFile( &file, GENERIC_READ | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ,
                               FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE )))
@@ -4108,14 +4158,13 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
     if (!imports_fixup_done)
     {
         MEMORY_BASIC_INFORMATION meminfo;
-        ANSI_STRING func_name;
+        ANSI_STRING base_thread_init_thunk = RTL_CONSTANT_STRING( "BaseThreadInitThunk" );
+        ANSI_STRING ctrl_routine = RTL_CONSTANT_STRING( "CtrlRoutine" );
         WINE_MODREF *kernel32;
         PEB *peb = NtCurrentTeb()->Peb;
 
         NtQueryVirtualMemory( GetCurrentProcess(), LdrInitializeThunk, MemoryBasicInformation,
                               &meminfo, sizeof(meminfo), NULL );
-        NtQueryVirtualMemory( GetCurrentProcess(), meminfo.AllocationBase, MemoryWineUnixFuncs,
-                              &ntdll_unix_handle, sizeof(ntdll_unix_handle), NULL );
 
         peb->LdrData            = &ldr;
         peb->FastPebLock        = &peb_lock;
@@ -4148,15 +4197,13 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
             NtTerminateProcess( GetCurrentProcess(), status );
         }
         node_kernel32 = kernel32->ldr.DdagNode;
-        RtlInitAnsiString( &func_name, "BaseThreadInitThunk" );
-        if ((status = LdrGetProcedureAddress( kernel32->ldr.DllBase, &func_name,
+        if ((status = LdrGetProcedureAddress( kernel32->ldr.DllBase, &base_thread_init_thunk,
                                               0, (void **)&pBaseThreadInitThunk )) != STATUS_SUCCESS)
         {
             MESSAGE( "wine: could not find BaseThreadInitThunk in kernel32.dll, status %lx\n", status );
             NtTerminateProcess( GetCurrentProcess(), status );
         }
-        RtlInitAnsiString( &func_name, "CtrlRoutine" );
-        LdrGetProcedureAddress( kernel32->ldr.DllBase, &func_name, 0, (void **)&pCtrlRoutine );
+        LdrGetProcedureAddress( kernel32->ldr.DllBase, &ctrl_routine, 0, (void **)&pCtrlRoutine );
 
         actctx_init();
         locale_init();
@@ -4216,7 +4263,7 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
             NtTerminateProcess( GetCurrentProcess(), status );
         }
         release_address_space();
-        if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.DllBase, DLL_PROCESS_ATTACH );
+        if (wm->ldr.TlsIndex == -1) call_tls_callbacks( wm->ldr.DllBase, DLL_PROCESS_ATTACH );
         if (wm->ldr.ActivationContext) RtlDeactivateActivationContext( 0, cookie );
         process_breakpoint();
     }
@@ -4225,7 +4272,7 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
         if ((status = alloc_thread_tls()) != STATUS_SUCCESS)
             NtTerminateThread( GetCurrentThread(), status );
         thread_attach();
-        if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.DllBase, DLL_THREAD_ATTACH );
+        if (wm->ldr.TlsIndex == -1) call_tls_callbacks( wm->ldr.DllBase, DLL_THREAD_ATTACH );
     }
 
     RtlLeaveCriticalSection( &loader_section );
@@ -4310,6 +4357,15 @@ PVOID WINAPI RtlImageRvaToVa( const IMAGE_NT_HEADERS *nt, HMODULE module,
 }
 
 
+/***********************************************************************
+ *           RtlAddressInSectionTable   (NTDLL.@)
+ */
+PVOID WINAPI RtlAddressInSectionTable( const IMAGE_NT_HEADERS *nt, HMODULE module,
+                                       DWORD rva )
+{
+    return RtlImageRvaToVa( nt, module, rva, NULL );
+}
+
 /***********************************************************************
  *           RtlPcToFileHeader   (NTDLL.@)
  */
@@ -4526,9 +4582,8 @@ NTSTATUS WINAPI RtlGetExePath( PCWSTR name, PWSTR *path )
     /* same check as NeedCurrentDirectoryForExePathW */
     if (!wcschr( name, '\\' ))
     {
-        UNICODE_STRING name, value = { 0 };
+        UNICODE_STRING name = RTL_CONSTANT_STRING( L"NoDefaultCurrentDirectoryInExePath" ), value = { 0 };
 
-        RtlInitUnicodeString( &name, L"NoDefaultCurrentDirectoryInExePath" );
         if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) != STATUS_VARIABLE_NOT_FOUND)
             dlldir = L"";
     }
diff --git a/dlls/ntdll/locale.c b/dlls/ntdll/locale.c
index 26302cfb376..f18181210aa 100644
--- a/dlls/ntdll/locale.c
+++ b/dlls/ntdll/locale.c
@@ -1329,7 +1329,7 @@ NTSTATUS WINAPI RtlIdnToUnicode( DWORD flags, const WCHAR *src, INT srclen, WCHA
     int i, buflen, start, end, out_label, out = 0;
     NTSTATUS status;
     UINT buffer[64];
-    WCHAR ch;
+    WCHAR ch = 0;
 
     if (!src || srclen < -1) return STATUS_INVALID_PARAMETER;
     if (srclen == -1) srclen = wcslen( src ) + 1;
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index b41e29c0ff5..3117e4c9b72 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -158,6 +158,7 @@
 @ stdcall -syscall NtClearEvent(long)
 @ stdcall -syscall NtClose(long)
 # @ stub NtCloseObjectAuditAlarm
+@ stdcall -syscall NtCommitTransaction(long long)
 # @ stub NtCompactKeys
 @ stdcall -syscall NtCompareObjects(ptr ptr)
 # @ stub NtCompareTokens
@@ -192,6 +193,7 @@
 @ stdcall -syscall NtCreateThreadEx(ptr long ptr long ptr ptr long long long long ptr)
 @ stdcall -syscall NtCreateTimer(ptr long ptr long)
 # @ stub NtCreateToken
+@ stdcall -syscall NtCreateTransaction(ptr long ptr ptr long long long long ptr ptr)
 @ stdcall -syscall NtCreateUserProcess(ptr ptr long long ptr ptr long long ptr ptr ptr)
 # @ stub NtCreateWaitablePort
 @ stdcall -arch=i386,arm64 NtCurrentTeb()
@@ -365,6 +367,7 @@
 @ stdcall -syscall NtRestoreKey(long long long)
 @ stdcall -syscall NtResumeProcess(long)
 @ stdcall -syscall NtResumeThread(long ptr)
+@ stdcall -syscall NtRollbackTransaction(long long)
 @ stdcall -syscall NtSaveKey(long long)
 # @ stub NtSaveKeyEx
 # @ stub NtSaveMergedKeys
@@ -487,7 +490,7 @@
 # @ stub RtlAddRefMemoryStream
 @ stdcall RtlAddVectoredContinueHandler(long ptr)
 @ stdcall RtlAddVectoredExceptionHandler(long ptr)
-# @ stub RtlAddressInSectionTable
+@ stdcall RtlAddressInSectionTable(ptr long long)
 @ stdcall RtlAdjustPrivilege(long long long ptr)
 @ stdcall RtlAllocateAndInitializeSid (ptr long long long long long long long long long ptr)
 @ stdcall RtlAllocateHandle(ptr ptr)
@@ -1685,20 +1688,21 @@
 # or 'wine_' (for user-visible functions) to avoid namespace conflicts.
 
 # Server interface
-@ cdecl -syscall -norelay wine_server_call(ptr)
-@ cdecl -syscall wine_server_fd_to_handle(long long long ptr)
-@ cdecl -syscall wine_server_handle_to_fd(long long ptr ptr)
+@ cdecl -norelay wine_server_call(ptr)
+@ cdecl wine_server_fd_to_handle(long long long ptr)
+@ cdecl wine_server_handle_to_fd(long long ptr ptr)
 
 # Unix interface
 @ stdcall __wine_unix_call(int64 long ptr)
-@ stdcall -syscall __wine_unix_spawnvp(long ptr)
+@ stdcall __wine_unix_spawnvp(long ptr)
 @ stdcall __wine_ctrl_routine(ptr)
 @ extern -private __wine_syscall_dispatcher
 @ extern -private __wine_unix_call_dispatcher
+@ extern -private __wine_unixlib_handle
 @ extern -arch=arm64 __wine_current_teb
 
 # Debugging
-@ stdcall -syscall -norelay __wine_dbg_write(ptr long)
+@ stdcall -norelay __wine_dbg_write(ptr long)
 @ cdecl -norelay __wine_dbg_get_channel_flags(ptr)
 @ cdecl -norelay __wine_dbg_header(long long str)
 @ cdecl -norelay __wine_dbg_output(str)
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index d1a7790991b..f6b77b79cde 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -127,5 +127,6 @@ static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
 
 /* FLS data */
 extern TEB_FLS_DATA *fls_alloc_data(void) DECLSPEC_HIDDEN;
+extern void heap_thread_detach(void) DECLSPEC_HIDDEN;
 
 #endif
diff --git a/dlls/ntdll/relay.c b/dlls/ntdll/relay.c
index 7dbff3c0727..afa4085fb33 100644
--- a/dlls/ntdll/relay.c
+++ b/dlls/ntdll/relay.c
@@ -165,7 +165,7 @@ static const WCHAR **load_list( HKEY hkey, const WCHAR *value )
 static DWORD WINAPI init_debug_lists( RTL_RUN_ONCE *once, void *param, void **context )
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING name;
+    UNICODE_STRING name = RTL_CONSTANT_STRING( L"Software\\Wine\\Debug" );
     HANDLE root, hkey;
 
     RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
@@ -175,7 +175,6 @@ static DWORD WINAPI init_debug_lists( RTL_RUN_ONCE *once, void *param, void **co
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &name, L"Software\\Wine\\Debug" );
 
     /* @@ Wine registry key: HKCU\Software\Wine\Debug */
     if (NtOpenKey( &hkey, KEY_ALL_ACCESS, &attr )) hkey = 0;
diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 84488ea1d81..25927afce54 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -684,7 +684,7 @@ __ASM_FASTCALL_FUNC(RtlUshortByteSwap, 4,
 /*************************************************************************
  * RtlUniform   [NTDLL.@]
  *
- * Generates an uniform random number
+ * Generates a uniform random number
  *
  * PARAMS
  *  seed [O] The seed of the Random function
@@ -693,12 +693,7 @@ __ASM_FASTCALL_FUNC(RtlUshortByteSwap, 4,
  *  It returns a random number uniformly distributed over [0..MAXLONG-1].
  *
  * NOTES
- *  Generates an uniform random number using D.H. Lehmer's 1948 algorithm.
- *  In our case the algorithm is:
- *
- *|  result = (*seed * 0x7fffffed + 0x7fffffc3) % MAXLONG;
- *|
- *|  *seed = result;
+ *  Generates a uniform random number using a linear congruential generator.
  *
  * DIFFERENCES
  *  The native documentation states that the random number is
@@ -706,27 +701,10 @@ __ASM_FASTCALL_FUNC(RtlUshortByteSwap, 4,
  *  function and our function return a random number uniformly
  *  distributed over [0..MAXLONG-1].
  */
-ULONG WINAPI RtlUniform (PULONG seed)
+ULONG WINAPI RtlUniform( ULONG *seed )
 {
-    ULONG result;
-
-   /*
-    * Instead of the algorithm stated above, we use the algorithm
-    * below, which is totally equivalent (see the tests), but does
-    * not use a division and therefore is faster.
-    */
-    result = *seed * 0xffffffed + 0x7fffffc3;
-    if (result == 0xffffffff || result == 0x7ffffffe) {
-	result = (result + 2) & MAXLONG;
-    } else if (result == 0x7fffffff) {
-	result = 0;
-    } else if ((result & 0x80000000) == 0) {
-	result = result + (~result & 1);
-    } else {
-	result = (result + (result & 1)) & MAXLONG;
-    } /* if */
-    *seed = result;
-    return result;
+    /* See the tests for details. */
+    return (*seed = ((ULONGLONG)*seed * 0x7fffffed + 0x7fffffc3) % 0x7fffffff);
 }
 
 
diff --git a/dlls/ntdll/signal_arm.c b/dlls/ntdll/signal_arm.c
index b426e03ff0e..47b535b69c5 100644
--- a/dlls/ntdll/signal_arm.c
+++ b/dlls/ntdll/signal_arm.c
@@ -165,7 +165,7 @@ static NTSTATUS virtual_unwind( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEX
     {
         struct unwind_builtin_dll_params params = { type, dispatch, context };
 
-        status = NTDLL_UNIX_CALL( unwind_builtin_dll, &params );
+        status = WINE_UNIX_CALL( unix_unwind_builtin_dll, &params );
         if (status != STATUS_SUCCESS) return status;
 
         if (dispatch->EstablisherFrame)
diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
index bdf58dfba01..cadf774be67 100644
--- a/dlls/ntdll/signal_arm64.c
+++ b/dlls/ntdll/signal_arm64.c
@@ -199,7 +199,7 @@ static NTSTATUS virtual_unwind( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEX
     {
         struct unwind_builtin_dll_params params = { type, dispatch, context };
 
-        status = NTDLL_UNIX_CALL( unwind_builtin_dll, &params );
+        status = WINE_UNIX_CALL( unix_unwind_builtin_dll, &params );
         if (status != STATUS_SUCCESS) return status;
 
         if (dispatch->EstablisherFrame)
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index ac543338893..81479f1fd91 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -282,7 +282,7 @@ static NTSTATUS virtual_unwind( ULONG type, DISPATCHER_CONTEXT *dispatch, CONTEX
     {
         struct unwind_builtin_dll_params params = { type, dispatch, context };
 
-        status = NTDLL_UNIX_CALL( unwind_builtin_dll, &params );
+        status = WINE_UNIX_CALL( unix_unwind_builtin_dll, &params );
         if (!status && dispatch->LanguageHandler && !module)
         {
             FIXME( "calling personality routine in system library not supported yet\n" );
diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 4bf2e4ec78e..94b2ccf61a6 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -198,7 +198,7 @@ static int test_stage;
 #if defined(__i386__) || defined(__x86_64__)
 static void test_debugger_xstate(HANDLE thread, CONTEXT *ctx, int stage)
 {
-    char context_buffer[sizeof(CONTEXT) + sizeof(CONTEXT_EX) + sizeof(XSTATE) + 63];
+    char context_buffer[sizeof(CONTEXT) + sizeof(CONTEXT_EX) + sizeof(XSTATE) + 1024];
     CONTEXT_EX *c_ex;
     NTSTATUS status;
     YMMCONTEXT *ymm;
@@ -2465,7 +2465,6 @@ static void test_restore_context(void)
         rec.NumberParameters = 1;
         rec.ExceptionInformation[0] = (DWORD64)&buf;
 
-        ok(buf.MxCsr == 0x1f80, "Got unexpected MxCsr %#lx.\n", buf.MxCsr);
         ok(buf.FpCsr == 0x27f, "Got unexpected FpCsr %#x.\n", buf.FpCsr);
         buf.FpCsr = 0x7f;
         buf.MxCsr = 0x3f80;
@@ -9487,6 +9486,7 @@ static void test_extended_context(void)
             8,
         },
     };
+    const ULONG64 supported_features = 7, supported_compaction_mask = supported_features | ((ULONG64)1 << 63);
     ULONG expected_length, expected_length_xstate, context_flags, expected_offset;
     ULONG64 enabled_features, expected_compaction;
     DECLSPEC_ALIGN(64) BYTE context_buffer2[2048];
@@ -9999,7 +9999,7 @@ static void test_extended_context(void)
         mask = 0xdeadbeef;
         bret = pGetXStateFeaturesMask(context, &mask);
         if (flags & CONTEXT_NATIVE)
-            ok(bret && mask == enabled_features,
+            ok(bret && mask == (enabled_features & supported_features),
                     "Got unexpected bret %#x, mask %s, flags %#lx.\n", bret, wine_dbgstr_longlong(mask), flags);
         else
             ok(!bret && mask == 0xdeadbeef,
@@ -10243,9 +10243,9 @@ static void test_extended_context(void)
     expected_compaction = compaction_enabled ? ((ULONG64)1 << 63) | 4 : 0;
 
     xs = (XSTATE *)((BYTE *)context_ex + context_ex->XState.Offset);
-    ok(xs->Mask == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
-            wine_dbgstr_longlong(xs->CompactionMask));
+    ok((xs->Mask & supported_features) == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
+    ok((xs->CompactionMask & (supported_features | ((ULONG64)1 << 63))) == expected_compaction,
+            "Got unexpected CompactionMask %s.\n", wine_dbgstr_longlong(xs->CompactionMask));
 
     for (i = 4; i < 8; ++i)
         ok(!data[i], "Got unexpected data %#x, i %u.\n", data[i], i);
@@ -10291,9 +10291,10 @@ static void test_extended_context(void)
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
     todo_wine_if (!xsaveopt_enabled)
-        ok(xs->Mask == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
-            wine_dbgstr_longlong(xs->CompactionMask));
+        ok((xs->Mask & supported_features) == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
+    ok((xs->CompactionMask & supported_compaction_mask) == expected_compaction,
+            "Got unexpected CompactionMask %s.\n", wine_dbgstr_longlong(xs->CompactionMask));
+
     for (i = 0; i < 16 * 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == ((xs->Mask & 4) ? 0 : 0xcccccccc),
                 "Got unexpected value %#lx, i %u.\n", ((ULONG *)&xs->YmmContext)[i], i);
@@ -10306,8 +10307,9 @@ static void test_extended_context(void)
     memset(&xs->YmmContext, 0xcc, sizeof(xs->YmmContext));
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
-    ok(!xs->Mask || broken(xs->Mask == 4), "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
+    ok(!(xs->Mask & supported_features) || broken((xs->Mask & supported_features) == 4), "Got unexpected Mask %s.\n",
+            wine_dbgstr_longlong(xs->Mask));
+    ok((xs->CompactionMask & supported_compaction_mask) == expected_compaction, "Got unexpected CompactionMask %s.\n",
             wine_dbgstr_longlong(xs->CompactionMask));
     for (i = 0; i < 16 * 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == 0xcccccccc || broken(xs->Mask == 4 && !((ULONG *)&xs->YmmContext)[i]),
@@ -10320,8 +10322,8 @@ static void test_extended_context(void)
     memset(&xs->YmmContext, 0xcc, sizeof(xs->YmmContext));
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
-    ok(xs->Mask == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
+    ok((xs->Mask & supported_features) == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
+    ok((xs->CompactionMask & supported_compaction_mask) == expected_compaction, "Got unexpected CompactionMask %s.\n",
             wine_dbgstr_longlong(xs->CompactionMask));
     for (i = 0; i < 16 * 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == 0x28282828, "Got unexpected value %#lx, i %u.\n",
@@ -10341,7 +10343,7 @@ static void test_extended_context(void)
     memset(&xs->YmmContext, 0xcc, sizeof(xs->YmmContext));
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
-    ok(xs->Mask == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
+    ok((xs->Mask & supported_features) == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
 
     for (i = 0; i < 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == 0x68686868, "Got unexpected value %#lx, i %u.\n",
@@ -10353,9 +10355,10 @@ static void test_extended_context(void)
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
     todo_wine_if (!xsaveopt_enabled && sizeof(void *) != 4)
-        ok(xs->Mask == (xsaveopt_enabled ? 0 : 4) || (sizeof(void *) == 4 && xs->Mask == 4),
-                "Got unexpected Mask %#I64x.\n", xs->Mask);
-    if (xs->Mask == 4)
+        ok((xs->Mask & supported_features) == (xsaveopt_enabled ? 0 : 4)
+                || (sizeof(void *) == 4 && (xs->Mask & supported_features) == 4),
+                "Got unexpected Mask %#I64x, supported_features.\n", xs->Mask);
+    if ((xs->Mask & supported_features) == 4)
     {
         for (i = 0; i < 8 * sizeof(void *); ++i)
             ok(((ULONG *)&xs->YmmContext)[i] == 0,
@@ -10431,13 +10434,13 @@ static void check_changes_in_range_(const char *file, unsigned int line, const B
 
 static void test_copy_context(void)
 {
-    static const struct modified_range ranges_amd64[] =
+    static struct modified_range ranges_amd64[] =
     {
         {0x30, ~0}, {0x38, 0x1}, {0x3a, 0x4}, {0x42, 0x1}, {0x48, 0x10}, {0x78, 0x2}, {0x98, 0x1},
         {0xa0, 0x2}, {0xf8, 0x1}, {0x100, 0x8}, {0x2a0, 0x80000008}, {0x4b0, 0x10}, {0x4d0, ~0},
         {0x4e8, 0}, {0x500, ~0}, {0x640, 0}, {0x1000, 0},
     };
-    static const struct modified_range ranges_x86[] =
+    static struct modified_range ranges_x86[] =
     {
         {0x0, ~0}, {0x4, 0x10}, {0x1c, 0x8}, {0x8c, 0x4}, {0x9c, 0x2}, {0xb4, 0x1}, {0xcc, 0x20}, {0x1ec, 0x80000020},
         {0x2cc, ~0}, {0x294, 0}, {0x1000, 0},
@@ -10496,6 +10499,26 @@ static void test_copy_context(void)
 
     enabled_features = pRtlGetEnabledExtendedFeatures(~(ULONG64)0);
 
+    memset(dst_context_buffer, 0xdd, sizeof(dst_context_buffer));
+    memset(src_context_buffer, 0xcc, sizeof(src_context_buffer));
+
+    status = pRtlInitializeExtendedContext(src_context_buffer, CONTEXT_ALL | CONTEXT_XSTATE, &src_ex);
+    if (!status)
+    {
+        src = pRtlLocateLegacyContext(src_ex, NULL);
+        dst = (CONTEXT *)dst_context_buffer;
+        dst->ContextFlags = CONTEXT_ALL;
+        status = pRtlCopyContext(dst, dst->ContextFlags, src);
+        ok(!status, "Got status %#lx.\n", status);
+        check_changes_in_range((BYTE *)dst, CONTEXT_ALL & CONTEXT_AMD64 ? &ranges_amd64[0] : &ranges_x86[0],
+                CONTEXT_ALL, sizeof(CONTEXT));
+    }
+    else
+    {
+        ok(status == STATUS_NOT_SUPPORTED, "Got status %#lx.\n", status);
+        skip("Extended context is not supported.\n");
+    }
+
     for (i = 0; i < ARRAY_SIZE(tests); ++i)
     {
         flags = tests[i];
@@ -10524,15 +10547,23 @@ static void test_copy_context(void)
         *(DWORD *)((BYTE *)dst + flags_offset) = 0;
         *(DWORD *)((BYTE *)src + flags_offset) = 0;
 
-        src_xs = (XSTATE *)((BYTE *)src_ex + src_ex->XState.Offset);
-        memset(src_xs, 0xcc, sizeof(XSTATE));
-        src_xs->Mask = 3;
-        src_xs->CompactionMask = ~(ULONG64)0;
+        context_length = (BYTE *)dst_ex - (BYTE *)dst + dst_ex->All.Length;
+
+        if (flags & 0x40)
+        {
+            src_xs = (XSTATE *)((BYTE *)src_ex + src_ex->XState.Offset);
+            memset(src_xs, 0xcc, src_ex->XState.Length);
+            src_xs->Mask = enabled_features & ~(ULONG64)4;
+            src_xs->CompactionMask = ~(ULONG64)0;
+            if (flags & CONTEXT_AMD64)
+                ranges_amd64[ARRAY_SIZE(ranges_amd64) - 2].start = 0x640 + src_ex->XState.Length - sizeof(XSTATE);
+            else
+                ranges_x86[ARRAY_SIZE(ranges_x86) - 2].start = 0x294 + src_ex->XState.Length - sizeof(XSTATE);
+        }
 
         status = pRtlCopyExtendedContext(dst_ex, flags, src_ex);
         ok(!status, "Got unexpected status %#lx, flags %#lx.\n", status, flags);
 
-        context_length = (BYTE *)dst_ex - (BYTE *)dst + dst_ex->All.Length;
         check_changes_in_range((BYTE *)dst, flags & CONTEXT_AMD64 ? &ranges_amd64[0] : &ranges_x86[0],
                 flags, context_length);
 
diff --git a/dlls/ntdll/tests/generated.c b/dlls/ntdll/tests/generated.c
index 995ffb90b57..8314697b7fd 100644
--- a/dlls/ntdll/tests/generated.c
+++ b/dlls/ntdll/tests/generated.c
@@ -839,15 +839,17 @@ static void test_pack_IMAGE_LINENUMBER(void)
 static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY(void)
 {
     /* IMAGE_LOAD_CONFIG_DIRECTORY */
-    TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY, 112)
+    /* size varies depending on Windows version */
+    /* TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY, 112) */
     TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY, 8)
 }
 
 static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY32(void)
 {
     /* IMAGE_LOAD_CONFIG_DIRECTORY32 */
-    TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY32, 88)
-    TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY32, 8)
+    /* size varies depending on Windows version */
+    /* TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY32, 72) */
+    TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY32, 4)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, Size, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, Size, 4)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, Size, 0)
@@ -875,45 +877,46 @@ static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY32(void)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, DeCommitTotalFreeThreshold, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, DeCommitTotalFreeThreshold, 4)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, DeCommitTotalFreeThreshold, 28)
-    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, LockPrefixTable, 8)
-    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, LockPrefixTable, 8)
+    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, LockPrefixTable, 4)
+    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, LockPrefixTable, 4)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, LockPrefixTable, 32)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, MaximumAllocationSize, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, MaximumAllocationSize, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, MaximumAllocationSize, 40)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, MaximumAllocationSize, 36)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, VirtualMemoryThreshold, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, VirtualMemoryThreshold, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, VirtualMemoryThreshold, 44)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, VirtualMemoryThreshold, 40)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessHeapFlags, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessHeapFlags, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessHeapFlags, 48)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessHeapFlags, 44)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessAffinityMask, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessAffinityMask, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessAffinityMask, 52)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, ProcessAffinityMask, 48)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 2)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 2)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 56)
-    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, Reserved1, 2)
-    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, Reserved1, 2)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, Reserved1, 58)
-    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 8)
-    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 8)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 64)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 52)
+    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, DependentLoadFlags, 2)
+    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, DependentLoadFlags, 2)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, DependentLoadFlags, 54)
+    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 4)
+    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 4)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 56)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, SecurityCookie, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, SecurityCookie, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SecurityCookie, 72)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SecurityCookie, 60)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerTable, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerTable, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerTable, 76)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerTable, 64)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount, 4)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount, 80)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerCount, 68)
 }
 
 static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY64(void)
 {
     /* IMAGE_LOAD_CONFIG_DIRECTORY64 */
-    TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY64, 112)
+    /* size varies depending on Windows version */
+    /* TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY64, 112) */
     TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY64, 8)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, Size, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, Size, 4)
@@ -960,9 +963,9 @@ static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY64(void)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, CSDVersion, 2)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, CSDVersion, 2)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, CSDVersion, 76)
-    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, Reserved1, 2)
-    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, Reserved1, 2)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, Reserved1, 78)
+    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, DependentLoadFlags, 2)
+    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, DependentLoadFlags, 2)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, DependentLoadFlags, 78)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, EditList, 8)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, EditList, 8)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, EditList, 80)
@@ -4264,14 +4267,16 @@ static void test_pack_IMAGE_LINENUMBER(void)
 static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY(void)
 {
     /* IMAGE_LOAD_CONFIG_DIRECTORY */
-    TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY, 72)
+    /* size varies depending on Windows version */
+    /* TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY, 72) */
     TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY, 4)
 }
 
 static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY32(void)
 {
     /* IMAGE_LOAD_CONFIG_DIRECTORY32 */
-    TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY32, 72)
+    /* size varies depending on Windows version */
+    /* TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY32, 72) */
     TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY32, 4)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, Size, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, Size, 4)
@@ -4318,9 +4323,9 @@ static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY32(void)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 2)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 2)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, CSDVersion, 52)
-    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, Reserved1, 2)
-    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, Reserved1, 2)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, Reserved1, 54)
+    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, DependentLoadFlags, 2)
+    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, DependentLoadFlags, 2)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, DependentLoadFlags, 54)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 4)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY32, EditList, 56)
@@ -4338,7 +4343,8 @@ static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY32(void)
 static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY64(void)
 {
     /* IMAGE_LOAD_CONFIG_DIRECTORY64 */
-    TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY64, 112)
+    /* size varies depending on Windows version */
+    /* TEST_TYPE_SIZE   (IMAGE_LOAD_CONFIG_DIRECTORY64, 112) */
     TEST_TYPE_ALIGN  (IMAGE_LOAD_CONFIG_DIRECTORY64, 8)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, Size, 4)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, Size, 4)
@@ -4385,9 +4391,9 @@ static void test_pack_IMAGE_LOAD_CONFIG_DIRECTORY64(void)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, CSDVersion, 2)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, CSDVersion, 2)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, CSDVersion, 76)
-    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, Reserved1, 2)
-    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, Reserved1, 2)
-    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, Reserved1, 78)
+    TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, DependentLoadFlags, 2)
+    TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, DependentLoadFlags, 2)
+    TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, DependentLoadFlags, 78)
     TEST_FIELD_SIZE  (IMAGE_LOAD_CONFIG_DIRECTORY64, EditList, 8)
     TEST_FIELD_ALIGN (IMAGE_LOAD_CONFIG_DIRECTORY64, EditList, 8)
     TEST_FIELD_OFFSET(IMAGE_LOAD_CONFIG_DIRECTORY64, EditList, 80)
diff --git a/dlls/ntdll/tests/info.c b/dlls/ntdll/tests/info.c
index 192f6be7ce9..cf074076c96 100644
--- a/dlls/ntdll/tests/info.c
+++ b/dlls/ntdll/tests/info.c
@@ -199,7 +199,7 @@ static void test_query_basic(void)
             "info is different\n" );
     }
 #else
-    ok( status == STATUS_INVALID_INFO_CLASS || broken(STATUS_NOT_IMPLEMENTED), /* vista */
+    ok( status == STATUS_INVALID_INFO_CLASS || broken(status == STATUS_SUCCESS), /* some Win8 */
         "got %08lx\n", status);
     status = pRtlGetNativeSystemInformation( SystemNativeBasicInformation, &sbi3, sizeof(sbi3), &ReturnLength );
     ok( !status || status == STATUS_INFO_LENGTH_MISMATCH ||
@@ -3219,9 +3219,9 @@ static void test_ThreadEnableAlignmentFaultFixup(void)
 
     dummy = 0;
     status = NtQueryInformationThread( GetCurrentThread(), ThreadEnableAlignmentFaultFixup, &dummy, sizeof(ULONG), NULL );
-    ok( status == STATUS_INVALID_INFO_CLASS || broken(STATUS_NOT_IMPLEMENTED), "Expected STATUS_INVALID_INFO_CLASS, got %08lx\n", status );
+    ok( status == STATUS_INVALID_INFO_CLASS, "Expected STATUS_INVALID_INFO_CLASS, got %08lx\n", status );
     status = NtQueryInformationThread( GetCurrentThread(), ThreadEnableAlignmentFaultFixup, &dummy, 1, NULL );
-    ok( status == STATUS_INVALID_INFO_CLASS || broken(STATUS_NOT_IMPLEMENTED), "Expected STATUS_INVALID_INFO_CLASS, got %08lx\n", status );
+    ok( status == STATUS_INVALID_INFO_CLASS, "Expected STATUS_INVALID_INFO_CLASS, got %08lx\n", status );
 
     dummy = 1;
     status = pNtSetInformationThread( GetCurrentThread(), ThreadEnableAlignmentFaultFixup, &dummy, sizeof(ULONG) );
diff --git a/dlls/ntdll/tests/om.c b/dlls/ntdll/tests/om.c
index e96cf128153..fb6deb19fa9 100644
--- a/dlls/ntdll/tests/om.c
+++ b/dlls/ntdll/tests/om.c
@@ -272,7 +272,8 @@ static void test_name_collisions(void)
     OBJECT_ATTRIBUTES attr;
     HANDLE dir, h, h1, h2;
     DWORD winerr;
-    LARGE_INTEGER size;
+    LARGE_INTEGER size, timeout;
+    IO_STATUS_BLOCK iosb;
 
     InitializeObjectAttributes(&attr, &str, 0, 0, NULL);
     RtlInitUnicodeString(&str, L"\\");
@@ -332,7 +333,7 @@ static void test_name_collisions(void)
     pNtClose(h);
     pNtClose(h1);
     pNtClose(h2);
-    
+
     h = CreateWaitableTimerA(NULL, TRUE, "om.c-test");
     ok(h != 0, "CreateWaitableTimerA failed got ret=%p (%ld)\n", h, GetLastError());
     status = pNtCreateTimer(&h1, GENERIC_ALL, &attr, NotificationTimer);
@@ -362,6 +363,57 @@ static void test_name_collisions(void)
     pNtClose(h2);
 
     pNtClose(dir);
+
+    RtlInitUnicodeString(&str, L"\\??\\PIPE\\named_pipe");
+    attr.RootDirectory = 0;
+    timeout.QuadPart = -10000;
+    status = pNtCreateNamedPipeFile( &h, GENERIC_READ|GENERIC_WRITE, &attr, &iosb,
+                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
+                                     FILE_OPEN, FILE_PIPE_FULL_DUPLEX,
+                                     FALSE, FALSE, FALSE, 10, 256, 256, &timeout );
+    ok(status == STATUS_OBJECT_NAME_NOT_FOUND, "failed to create pipe %08lx\n", status);
+
+    memset( &iosb, 0xcc, sizeof(iosb) );
+    status = pNtCreateNamedPipeFile( &h, GENERIC_READ|GENERIC_WRITE, &attr, &iosb,
+                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
+                                     FILE_OPEN_IF, FILE_PIPE_FULL_DUPLEX,
+                                     FALSE, FALSE, FALSE, 10, 256, 256, &timeout );
+    ok(status == STATUS_SUCCESS, "failed to create pipe %08lx\n", status);
+    ok( iosb.Information == FILE_CREATED, "wrong info %Ix\n", iosb.Information );
+    pNtClose( h );
+
+    memset( &iosb, 0xcc, sizeof(iosb) );
+    status = pNtCreateNamedPipeFile( &h, GENERIC_READ|GENERIC_WRITE, &attr, &iosb,
+                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
+                                     FILE_CREATE, FILE_PIPE_FULL_DUPLEX,
+                                     FALSE, FALSE, FALSE, 10, 256, 256, &timeout );
+    ok(status == STATUS_SUCCESS, "failed to create pipe %08lx\n", status);
+    ok( iosb.Information == FILE_CREATED, "wrong info %Ix\n", iosb.Information );
+
+    memset( &iosb, 0xcc, sizeof(iosb) );
+    status = pNtCreateNamedPipeFile( &h1, GENERIC_READ|GENERIC_WRITE, &attr, &iosb,
+                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
+                                     FILE_OPEN, FILE_PIPE_FULL_DUPLEX,
+                                     FALSE, FALSE, FALSE, 10, 256, 256, &timeout );
+    ok(status == STATUS_SUCCESS, "failed to create pipe %08lx\n", status);
+    ok( iosb.Information == FILE_OPENED, "wrong info %Ix\n", iosb.Information );
+    pNtClose(h1);
+
+    memset( &iosb, 0xcc, sizeof(iosb) );
+    status = pNtCreateNamedPipeFile( &h1, GENERIC_READ|GENERIC_WRITE, &attr, &iosb,
+                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
+                                     FILE_OPEN_IF, FILE_PIPE_FULL_DUPLEX,
+                                     FALSE, FALSE, FALSE, 10, 256, 256, &timeout );
+    ok(status == STATUS_SUCCESS, "failed to create pipe %08lx\n", status);
+    ok( iosb.Information == FILE_OPENED, "wrong info %Ix\n", iosb.Information );
+    pNtClose(h1);
+
+    h1 = CreateNamedPipeA( "\\\\.\\pipe\\named_pipe", PIPE_ACCESS_DUPLEX,
+                          PIPE_READMODE_BYTE, 10, 256, 256, 1000, NULL );
+    winerr = GetLastError();
+    ok(h1 != 0 && winerr == ERROR_ALREADY_EXISTS, "CreateNamedPipeA got ret=%p (%ld)\n", h1, winerr);
+    pNtClose(h1);
+    pNtClose(h);
 }
 
 static void test_all_kernel_objects( UINT line, OBJECT_ATTRIBUTES *attr,
diff --git a/dlls/ntdll/tests/path.c b/dlls/ntdll/tests/path.c
index 4732f6a6aa8..9210cfb8843 100644
--- a/dlls/ntdll/tests/path.c
+++ b/dlls/ntdll/tests/path.c
@@ -128,10 +128,10 @@ static void test_RtlIsDosDeviceName_U(void)
         { "c:\\nul\\",     0, 0 },
         { "c:\\nul\\foo",  0, 0 },
         { "c:\\nul::",     6, 6 },
-        { "c:\\nul::::::", 6, 6 },
-        { "c:prn     ",    4, 6 },
-        { "c:prn.......",  4, 6 },
-        { "c:prn... ...",  4, 6 },
+        { "c:\\nul::::::", 6, 6, TRUE }, /* fails on win11 */
+        { "c:prn     ",    4, 6, TRUE }, /* fails on win11 */
+        { "c:prn.......",  4, 6, TRUE }, /* fails on win11 */
+        { "c:prn... ...",  4, 6, TRUE }, /* fails on win11 */
         { "c:NUL  ....  ", 4, 6 },
         { "c: . . .",      0, 0 },
         { "c:",            0, 0 },
@@ -140,14 +140,14 @@ static void test_RtlIsDosDeviceName_U(void)
         { "c:nul. . . :",  4, 6 },
         { "c:nul . . :",   4, 6 },
         { "c:nul0",        0, 0 },
-        { "c:prn:aaa",     4, 6 },
-        { "c:PRN:.txt",    4, 6 },
-        { "c:aux:.txt...", 4, 6 },
-        { "c:prn:.txt:",   4, 6 },
-        { "c:nul:aaa",     4, 6 },
+        { "c:prn:aaa",     4, 6, TRUE }, /* fails on win11 */
+        { "c:PRN:.txt",    4, 6, TRUE }, /* fails on win11 */
+        { "c:aux:.txt...", 4, 6, TRUE }, /* fails on win11 */
+        { "c:prn:.txt:",   4, 6, TRUE }, /* fails on win11 */
+        { "c:nul:aaa",     4, 6, TRUE }, /* fails on win11 */
         { "con:",          0, 6 },
         { "lpt1:",         0, 8 },
-        { "c:com5:",       4, 8 },
+        { "c:com5:",       4, 8, TRUE }, /* fails on win11 */
         { "CoM4:",         0, 8 },
         { "lpt9:",         0, 8 },
         { "c:\\lpt0.txt",  0, 0 },
@@ -159,14 +159,14 @@ static void test_RtlIsDosDeviceName_U(void)
         { "\\??\\CONIN$",  8, 12, TRUE }, /* fails on win7 */
         { "\\??\\CONOUT$", 8, 14, TRUE }, /* fails on win7 */
         { "\\??\\CONERR$", 0, 0 },
-        { "\\??\\CON",     8, 6 },
+        { "\\??\\CON",     8, 6, TRUE }, /* fails on win11 */
         { "c:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
           "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
           "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
           "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
           "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
           "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
-          "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\nul.txt", 1000, 6 },
+          "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\nul.txt", 1000, 6, TRUE }, /* fails on win11 */
         { NULL, 0 }
     };
 
@@ -321,7 +321,8 @@ static void test_RtlGetFullPathName_U(void)
             { "foo/..",                      "C:\\windows",      "windows"},
             { "\\windows\\nul",              "\\\\.\\nul",       NULL},
             { "C:\\nonexistent\\nul",        "\\\\.\\nul",       NULL},
-            { "C:\\con\\con",                "\\\\.\\con",       NULL},
+            { "C:\\con\\con",                "\\\\.\\con",       NULL,
+                                             "C:\\con\\con",     "con"}, /* win11 */
             { "C:NUL.",                      "\\\\.\\NUL",       NULL},
             { "C:NUL",                       "\\\\.\\NUL",       NULL},
             { "AUX",                         "\\\\.\\AUX",       NULL},
@@ -564,7 +565,7 @@ static void test_RtlDosPathNameToNtPathName_U(void)
         {L"CONERR$",        L"\\??\\C:\\windows\\CONERR$",  15},
     };
     static const WCHAR *error_paths[] = {
-        NULL, L"", L" ", L"C:\\nonexistent\\nul", L"C:\\con\\con"
+        NULL, L"", L" ", L"C:\\nonexistent\\nul"
     };
 
     GetCurrentDirectoryA(sizeof(curdir), curdir);
diff --git a/dlls/ntdll/tests/pipe.c b/dlls/ntdll/tests/pipe.c
index 11192d6e471..243b2794888 100644
--- a/dlls/ntdll/tests/pipe.c
+++ b/dlls/ntdll/tests/pipe.c
@@ -260,14 +260,14 @@ static void test_create_invalid(void)
 /* create a pipe with FILE_OVERWRITE */
     res = pNtCreateNamedPipeFile(&handle, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &attr, &iosb, FILE_SHARE_READ, 4 /*FILE_OVERWRITE*/,
                                  0, 1, 0, 0, 0xFFFFFFFF, 500, 500, &timeout);
-    todo_wine ok(res == STATUS_INVALID_PARAMETER, "NtCreateNamedPipeFile returned %lx\n", res);
+    ok(res == STATUS_INVALID_PARAMETER, "NtCreateNamedPipeFile returned %lx\n", res);
     if (!res)
         CloseHandle(handle);
 
 /* create a pipe with FILE_OVERWRITE_IF */
     res = pNtCreateNamedPipeFile(&handle, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &attr, &iosb, FILE_SHARE_READ, 5 /*FILE_OVERWRITE_IF*/,
                                  0, 1, 0, 0, 0xFFFFFFFF, 500, 500, &timeout);
-    todo_wine ok(res == STATUS_INVALID_PARAMETER, "NtCreateNamedPipeFile returned %lx\n", res);
+    ok(res == STATUS_INVALID_PARAMETER, "NtCreateNamedPipeFile returned %lx\n", res);
     if (!res)
         CloseHandle(handle);
 
@@ -289,7 +289,7 @@ static void test_create_invalid(void)
 /* test FILE_CREATE creation disposition */
     res = pNtCreateNamedPipeFile(&handle2, SYNCHRONIZE, &attr, &iosb, FILE_SHARE_READ | FILE_SHARE_WRITE, 2 /*FILE_CREATE*/,
                                  0, 1, 0, 0, 0xFFFFFFFF, 500, 500, &timeout);
-    todo_wine ok(res == STATUS_ACCESS_DENIED, "NtCreateNamedPipeFile returned %lx\n", res);
+    ok(res == STATUS_ACCESS_DENIED, "NtCreateNamedPipeFile returned %lx\n", res);
     if (!res)
         CloseHandle(handle2);
 
diff --git a/dlls/ntdll/tests/rtl.c b/dlls/ntdll/tests/rtl.c
index c2ca8ea11a7..493cdc92cac 100644
--- a/dlls/ntdll/tests/rtl.c
+++ b/dlls/ntdll/tests/rtl.c
@@ -381,293 +381,113 @@ static void test_RtlByteSwap(void)
 
 static void test_RtlUniform(void)
 {
-    ULONGLONG num;
+    const ULONG step = 0x7fff;
+    ULONG num;
     ULONG seed;
     ULONG seed_bak;
     ULONG expected;
     ULONG result;
 
-/*
- * According to the documentation RtlUniform is using D.H. Lehmer's 1948
- * algorithm. This algorithm is:
- *
- * seed = (seed * const_1 + const_2) % const_3;
- *
- * According to the documentation the random number is distributed over
- * [0..MAXLONG]. Therefore const_3 is MAXLONG + 1:
- *
- * seed = (seed * const_1 + const_2) % (MAXLONG + 1);
- *
- * Because MAXLONG is 0x7fffffff (and MAXLONG + 1 is 0x80000000) the
- * algorithm can be expressed without division as:
- *
- * seed = (seed * const_1 + const_2) & MAXLONG;
- *
- * To find out const_2 we just call RtlUniform with seed set to 0:
- */
+    /*
+     * According to the documentation RtlUniform is using D.H. Lehmer's 1948
+     * algorithm.  We assume a more generic version of this algorithm,
+     * which is the linear congruential generator (LCG).  Its formula is:
+     *
+     *   X_(n+1) = (a * X_n + c) % m
+     *
+     * where a is the multiplier, c is the increment, and m is the modulus.
+     *
+     * According to the documentation, the random numbers are distributed over
+     * [0..MAXLONG].  Therefore, the modulus is MAXLONG + 1:
+     *
+     *   X_(n+1) = (a * X_n + c) % (MAXLONG + 1)
+     *
+     * To find out the increment, we just call RtlUniform with seed set to 0.
+     * This reveals c = 0x7fffffc3.
+     */
     seed = 0;
     expected = 0x7fffffc3;
     result = RtlUniform(&seed);
     ok(result == expected,
         "RtlUniform(&seed (seed == 0)) returns %lx, expected %lx\n",
         result, expected);
-/*
- * The algorithm is now:
- *
- * seed = (seed * const_1 + 0x7fffffc3) & MAXLONG;
- *
- * To find out const_1 we can use:
- *
- * const_1 = RtlUniform(1) - 0x7fffffc3;
- *
- * If that does not work a search loop can try all possible values of
- * const_1 and compare to the result to RtlUniform(1).
- * This way we find out that const_1 is 0xffffffed.
- *
- * For seed = 1 the const_2 is 0x7fffffc4:
- */
-    seed = 1;
-    expected = seed * 0xffffffed + 0x7fffffc3 + 1;
-    result = RtlUniform(&seed);
-    ok(result == expected,
-        "RtlUniform(&seed (seed == 1)) returns %lx, expected %lx\n",
-        result, expected);
-/*
- * For seed = 2 the const_2 is 0x7fffffc3:
- */
-    seed = 2;
-    expected = seed * 0xffffffed + 0x7fffffc3;
-    result = RtlUniform(&seed);
-
-/*
- * Windows Vista uses different algorithms, so skip the rest of the tests
- * until that is figured out. Trace output for the failures is about 10.5 MB!
- */
-
-    if (result == 0x7fffff9f) {
-        skip("Most likely running on Windows Vista which uses a different algorithm\n");
-        return;
-    }
-
-    ok(result == expected,
-        "RtlUniform(&seed (seed == 2)) returns %lx, expected %lx\n",
-        result, expected);
 
-/*
- * More tests show that if seed is odd the result must be incremented by 1:
- */
-    seed = 3;
-    expected = seed * 0xffffffed + 0x7fffffc3 + (seed & 1);
+    /*
+     * The formula is now:
+     *
+     *   X_(n+1) = (a * X_n + 0x7fffffc3) % (MAXLONG + 1)
+     *
+     * If the modulus is correct, RtlUniform(0) shall equal RtlUniform(MAXLONG + 1).
+     * However, testing reveals that this is not the case.
+     * That is, the modulus in the documentation is incorrect.
+     */
+    seed = 0x80000000U;
+    expected = 0x7fffffb1;
     result = RtlUniform(&seed);
-    ok(result == expected,
-        "RtlUniform(&seed (seed == 3)) returns %lx, expected %lx\n",
-        result, expected);
 
-    seed = 0x6bca1aa;
-    expected = seed * 0xffffffed + 0x7fffffc3;
-    result = RtlUniform(&seed);
     ok(result == expected,
-        "RtlUniform(&seed (seed == 0x6bca1aa)) returns %lx, expected %lx\n",
+        "RtlUniform(&seed (seed == 0x80000000)) returns %lx, expected %lx\n",
         result, expected);
 
-    seed = 0x6bca1ab;
-    expected = seed * 0xffffffed + 0x7fffffc3 + 1;
-    result = RtlUniform(&seed);
-    ok(result == expected,
-        "RtlUniform(&seed (seed == 0x6bca1ab)) returns %lx, expected %lx\n",
-        result, expected);
-/*
- * When seed is 0x6bca1ac there is an exception:
- */
-    seed = 0x6bca1ac;
-    expected = seed * 0xffffffed + 0x7fffffc3 + 2;
-    result = RtlUniform(&seed);
-    ok(result == expected,
-        "RtlUniform(&seed (seed == 0x6bca1ac)) returns %lx, expected %lx\n",
-        result, expected);
-/*
- * Note that up to here const_3 is not used
- * (the highest bit of the result is not set).
- *
- * Starting with 0x6bca1ad: If seed is even the result must be incremented by 1:
- */
-    seed = 0x6bca1ad;
-    expected = (seed * 0xffffffed + 0x7fffffc3) & MAXLONG;
+    /*
+     * We try another value for modulus, say MAXLONG.
+     * We discover that RtlUniform(0) equals RtlUniform(MAXLONG), which means
+     * the correct value for the modulus is actually MAXLONG.
+     */
+    seed = 0x7fffffff;
+    expected = 0x7fffffc3;
     result = RtlUniform(&seed);
     ok(result == expected,
-        "RtlUniform(&seed (seed == 0x6bca1ad)) returns %lx, expected %lx\n",
+        "RtlUniform(&seed (seed == 0x7fffffff)) returns %lx, expected %lx\n",
         result, expected);
 
-    seed = 0x6bca1ae;
-    expected = (seed * 0xffffffed + 0x7fffffc3 + 1) & MAXLONG;
+    /*
+     * The formula is now:
+     *
+     *   X_(n+1) = (a * X_n + 0x7fffffc3) % MAXLONG
+     *
+     * To find out the multiplier we can use:
+     *
+     *   a = RtlUniform(1) - 0x7fffffc3 (mod MAXLONG)
+     *
+     * This way, we find out that a = -18 (mod MAXLONG),
+     * which is congruent to 0x7fffffed (MAXLONG - 18).
+     */
+    seed = 1;
+    expected = ((ULONGLONG)seed * 0x7fffffed + 0x7fffffc3) % MAXLONG;
     result = RtlUniform(&seed);
     ok(result == expected,
-        "RtlUniform(&seed (seed == 0x6bca1ae)) returns %lx, expected %lx\n",
+        "RtlUniform(&seed (seed == 1)) returns %lx, expected %lx\n",
         result, expected);
-/*
- * There are several ranges where for odd or even seed the result must be
- * incremented by 1. You can see this ranges in the following test.
- *
- * For a full test use one of the following loop heads:
- *
- *  for (num = 0; num <= 0xffffffff; num++) {
- *      seed = num;
- *      ...
- *
- *  seed = 0;
- *  for (num = 0; num <= 0xffffffff; num++) {
- *      ...
- */
-    seed = 0;
-    for (num = 0; num <= 100000; num++) {
 
-	expected = seed * 0xffffffed + 0x7fffffc3;
-	if (seed < 0x6bca1ac) {
-	    expected = expected + (seed & 1);
-	} else if (seed == 0x6bca1ac) {
-	    expected = (expected + 2) & MAXLONG;
-	} else if (seed < 0xd79435c) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x1435e50b) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x1af286ba) { 
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x21af2869) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x286bca18) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x2f286bc7) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x35e50d77) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x3ca1af26) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x435e50d5) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x4a1af284) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x50d79433) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x579435e2) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x5e50d792) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x650d7941) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x6bca1af0) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x7286bc9f) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x79435e4e) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x7ffffffd) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x86bca1ac) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed == 0x86bca1ac) {
-	    expected = (expected + 1) & MAXLONG;
-	} else if (seed < 0x8d79435c) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0x9435e50b) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0x9af286ba) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xa1af2869) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0xa86bca18) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xaf286bc7) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed == 0xaf286bc7) {
-	    expected = (expected + 2) & MAXLONG;
-	} else if (seed < 0xb5e50d77) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xbca1af26) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0xc35e50d5) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xca1af284) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0xd0d79433) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xd79435e2) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0xde50d792) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xe50d7941) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0xebca1af0) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xf286bc9f) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else if (seed < 0xf9435e4e) {
-	    expected = expected + (seed & 1);
-	} else if (seed < 0xfffffffd) {
-	    expected = (expected + (~seed & 1)) & MAXLONG;
-	} else {
-	    expected = expected + (seed & 1);
-	} /* if */
-        seed_bak = seed;
+    num = 2;
+    do
+    {
+        seed = num;
+        expected = ((ULONGLONG)seed * 0x7fffffed + 0x7fffffc3) % 0x7fffffff;
         result = RtlUniform(&seed);
         ok(result == expected,
-                "test: 0x%s RtlUniform(&seed (seed == %lx)) returns %lx, expected %lx\n",
-                wine_dbgstr_longlong(num), seed_bak, result, expected);
+                "test: RtlUniform(&seed (seed == %lx)) returns %lx, expected %lx\n",
+                num, result, expected);
         ok(seed == expected,
-                "test: 0x%s RtlUniform(&seed (seed == %lx)) sets seed to %lx, expected %lx\n",
-                wine_dbgstr_longlong(num), seed_bak, result, expected);
-    } /* for */
-/*
- * Further investigation shows: In the different regions the highest bit
- * is set or cleared when even or odd seeds need an increment by 1.
- * This leads to a simplified algorithm:
- *
- * seed = seed * 0xffffffed + 0x7fffffc3;
- * if (seed == 0xffffffff || seed == 0x7ffffffe) {
- *     seed = (seed + 2) & MAXLONG;
- * } else if (seed == 0x7fffffff) {
- *     seed = 0;
- * } else if ((seed & 0x80000000) == 0) {
- *     seed = seed + (~seed & 1);
- * } else {
- *     seed = (seed + (seed & 1)) & MAXLONG;
- * }
- *
- * This is also the algorithm used for RtlUniform of wine (see dlls/ntdll/rtl.c).
- *
- * Now comes the funny part:
- * It took me one weekend, to find the complicated algorithm and one day more,
- * to find the simplified algorithm. Several weeks later I found out: The value
- * MAXLONG (=0x7fffffff) is never returned, neither with the native function
- * nor with the simplified algorithm. In reality the native function and our
- * function return a random number distributed over [0..MAXLONG-1]. Note
- * that this is different from what native documentation states [0..MAXLONG].
- * Expressed with D.H. Lehmer's 1948 algorithm it looks like:
- *
- * seed = (seed * const_1 + const_2) % MAXLONG;
- *
- * Further investigations show that the real algorithm is:
- *
- * seed = (seed * 0x7fffffed + 0x7fffffc3) % MAXLONG;
- *
- * This is checked with the test below:
- */
+                "test: RtlUniform(&seed (seed == %lx)) sets seed to %lx, expected %lx\n",
+                num, result, expected);
+
+        num += step;
+    } while (num >= 2 + step);
+
     seed = 0;
     for (num = 0; num <= 100000; num++) {
-	expected = (seed * 0x7fffffed + 0x7fffffc3) % 0x7fffffff;
+        expected = ((ULONGLONG)seed * 0x7fffffed + 0x7fffffc3) % 0x7fffffff;
         seed_bak = seed;
         result = RtlUniform(&seed);
         ok(result == expected,
-                "test: 0x%s RtlUniform(&seed (seed == %lx)) returns %lx, expected %lx\n",
-                wine_dbgstr_longlong(num), seed_bak, result, expected);
+                "test: %ld RtlUniform(&seed (seed == %lx)) returns %lx, expected %lx\n",
+                num, seed_bak, result, expected);
         ok(seed == expected,
-                "test: 0x%s RtlUniform(&seed (seed == %lx)) sets seed to %lx, expected %lx\n",
-                wine_dbgstr_longlong(num), seed_bak, result, expected);
+                "test: %ld RtlUniform(&seed (seed == %lx)) sets seed to %lx, expected %lx\n",
+                num, seed_bak, result, expected);
     } /* for */
-/*
- * More tests show that RtlUniform does not return 0x7ffffffd for seed values
- * in the range [0..MAXLONG-1]. Additionally 2 is returned twice. This shows
- * that there is more than one cycle of generated randon numbers ...
- */
 }
 
 
@@ -3788,6 +3608,31 @@ static void test_RtlFirstFreeAce(void)
     HeapFree(GetProcessHeap(), 0, acl);
 }
 
+static void test_TlsIndex(void)
+{
+    LIST_ENTRY *root = &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList;
+    for (LIST_ENTRY *entry = root->Flink; entry != root; entry = entry->Flink)
+    {
+        LDR_DATA_TABLE_ENTRY *mod = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+        if (lstrcmpiW(L"ntdll.dll", mod->BaseDllName.Buffer) == 0)
+        {
+            /* Pick ntdll as a dll that definitely won't have TLS */
+            ok(mod->TlsIndex == 0, "ntdll.dll TlsIndex: %d instead of 0\n", mod->TlsIndex);
+        }
+        else if (mod->DllBase == GetModuleHandleA(NULL))
+        {
+            /* mingw gcc doesn't support MSVC-style TLS */
+            /* If we do get a way to add tls to this exe, uncomment the following test: */
+            /* ok(mod->TlsIndex == -1, "Test exe TlsIndex: %d instead of -1\n", mod->TlsIndex); */
+        }
+        else
+        {
+            ok(mod->TlsIndex == 0 || mod->TlsIndex == -1, "%s TlsIndex: %d\n",
+               debugstr_w(mod->BaseDllName.Buffer), mod->TlsIndex);
+        }
+    }
+}
+
 START_TEST(rtl)
 {
     InitFunctionPtrs();
@@ -3832,4 +3677,5 @@ START_TEST(rtl)
     test_DbgPrint();
     test_RtlDestroyHeap();
     test_RtlFirstFreeAce();
+    test_TlsIndex();
 }
diff --git a/dlls/ntdll/tests/rtlstr.c b/dlls/ntdll/tests/rtlstr.c
index 2aebe1deda1..8988aadeac4 100644
--- a/dlls/ntdll/tests/rtlstr.c
+++ b/dlls/ntdll/tests/rtlstr.c
@@ -792,6 +792,7 @@ typedef struct {
     int res_buf_size;
     const char *res_buf;
     NTSTATUS result;
+    int broken_len;
 } ustr2astr_t;
 
 static const ustr2astr_t ustr2astr[] = {
@@ -799,7 +800,7 @@ static const ustr2astr_t ustr2astr[] = {
     { 10, 12, 12, "------------", 12, 12, 12, "abcdef", TRUE,  6, 7, 7, "abcdef", STATUS_SUCCESS},
     {  0,  2, 12, "------------", 12, 12, 12, "abcdef", TRUE,  6, 7, 7, "abcdef", STATUS_SUCCESS},
     { 10, 12, 12, NULL,           12, 12, 12, "abcdef", TRUE,  6, 7, 7, "abcdef", STATUS_SUCCESS},
-    {  0,  0, 12, "------------", 12, 12, 12, "abcdef", FALSE, 6, 0, 0, "",       STATUS_BUFFER_OVERFLOW},
+    {  0,  0, 12, "------------", 12, 12, 12, "abcdef", FALSE, 6, 0, 0, "",       STATUS_BUFFER_OVERFLOW, 1},
     {  0,  1, 12, "------------", 12, 12, 12, "abcdef", FALSE, 0, 1, 1, "",       STATUS_BUFFER_OVERFLOW},
     {  0,  2, 12, "------------", 12, 12, 12, "abcdef", FALSE, 1, 2, 2, "a",      STATUS_BUFFER_OVERFLOW},
     {  0,  3, 12, "------------", 12, 12, 12, "abcdef", FALSE, 2, 3, 3, "ab",     STATUS_BUFFER_OVERFLOW},
@@ -849,7 +850,8 @@ static void test_RtlUnicodeStringToAnsiString(void)
 	ok(result == ustr2astr[test_num].result,
            "(test %d): RtlUnicodeStringToAnsiString(ansi, uni, %d) has result %lx, expected %lx\n",
 	   test_num, ustr2astr[test_num].doalloc, result, ustr2astr[test_num].result);
-	ok(ansi_str.Length == ustr2astr[test_num].res_Length,
+	ok(ansi_str.Length == ustr2astr[test_num].res_Length ||
+       broken(ustr2astr[test_num].broken_len && !ansi_str.Length) /* win11 */,
 	   "(test %d): RtlUnicodeStringToAnsiString(ansi, uni, %d) ansi has Length %d, expected %d\n",
 	   test_num, ustr2astr[test_num].doalloc, ansi_str.Length, ustr2astr[test_num].res_Length);
 	ok(ansi_str.MaximumLength == ustr2astr[test_num].res_MaximumLength,
@@ -1523,6 +1525,7 @@ typedef struct {
     USHORT MaximumLength;
     const char *Buffer;
     NTSTATUS result;
+    int broken_len;
 } int2str_t;
 
 static const int2str_t int2str[] = {
@@ -1622,11 +1625,11 @@ static const int2str_t int2str[] = {
     { 2,       131072, 18, 19, "100000000000000000\0----------------", STATUS_SUCCESS},
     { 2,       131072, 18, 18, "100000000000000000-----------------",  STATUS_SUCCESS},
     {16,   0xffffffff,  8,  9, "FFFFFFFF\0--------------------------", STATUS_SUCCESS},
-    {16,   0xffffffff,  8,  8, "FFFFFFFF---------------------------",  STATUS_SUCCESS}, /* No \0 term */
-    {16,   0xffffffff,  8,  7, "-----------------------------------",  STATUS_BUFFER_OVERFLOW}, /* Too short */
+    {16,   0xffffffff,  8,  8, "FFFFFFFF---------------------------",  STATUS_SUCCESS, 1}, /* No \0 term */
+    {16,   0xffffffff,  8,  7, "-----------------------------------",  STATUS_BUFFER_OVERFLOW, 1}, /* Too short */
     {16,          0xa,  1,  2, "A\0---------------------------------", STATUS_SUCCESS},
-    {16,          0xa,  1,  1, "A----------------------------------",  STATUS_SUCCESS}, /* No \0 term */
-    {16,            0,  1,  0, "-----------------------------------",  STATUS_BUFFER_OVERFLOW},
+    {16,          0xa,  1,  1, "A----------------------------------",  STATUS_SUCCESS, 1}, /* No \0 term */
+    {16,            0,  1,  0, "-----------------------------------",  STATUS_BUFFER_OVERFLOW, 1},
     {20,   0xdeadbeef,  0,  9, "-----------------------------------",  STATUS_INVALID_PARAMETER}, /* ill. base */
     {-8,     07654321,  0, 12, "-----------------------------------",  STATUS_INVALID_PARAMETER}, /* neg. base */
 };
@@ -1687,7 +1690,8 @@ static void one_RtlIntegerToUnicodeString_test(int test_num, const int2str_t *in
     ok(memcmp(unicode_string.Buffer, expected_unicode_string.Buffer, STRI_BUFFER_LENGTH * sizeof(WCHAR)) == 0,
        "(test %d): RtlIntegerToUnicodeString(%lu, %d, [out]) assigns string \"%s\", expected: \"%s\"\n",
        test_num, int2str->value, int2str->base, ansi_str.Buffer, expected_ansi_str.Buffer);
-    ok(unicode_string.Length == expected_unicode_string.Length,
+    ok(unicode_string.Length == expected_unicode_string.Length ||
+       broken(int2str->broken_len && !unicode_string.Length) /* win11 */,
        "(test %d): RtlIntegerToUnicodeString(%lu, %d, [out]) string has Length %d, expected: %d\n",
        test_num, int2str->value, int2str->base, unicode_string.Length, expected_unicode_string.Length);
     ok(unicode_string.MaximumLength == expected_unicode_string.MaximumLength,
diff --git a/dlls/ntdll/tests/threadpool.c b/dlls/ntdll/tests/threadpool.c
index 008755e6e5d..a7457e0a315 100644
--- a/dlls/ntdll/tests/threadpool.c
+++ b/dlls/ntdll/tests/threadpool.c
@@ -33,15 +33,17 @@ static VOID     (WINAPI *pTpCallbackReleaseSemaphoreOnCompletion)(TP_CALLBACK_IN
 static void     (WINAPI *pTpCancelAsyncIoOperation)(TP_IO *);
 static VOID     (WINAPI *pTpDisassociateCallback)(TP_CALLBACK_INSTANCE *);
 static BOOL     (WINAPI *pTpIsTimerSet)(TP_TIMER *);
-static VOID     (WINAPI *pTpReleaseWait)(TP_WAIT *);
 static VOID     (WINAPI *pTpPostWork)(TP_WORK *);
+static NTSTATUS (WINAPI *pTpQueryPoolStackInformation)(TP_POOL *,TP_POOL_STACK_INFORMATION *);
 static VOID     (WINAPI *pTpReleaseCleanupGroup)(TP_CLEANUP_GROUP *);
 static VOID     (WINAPI *pTpReleaseCleanupGroupMembers)(TP_CLEANUP_GROUP *,BOOL,PVOID);
 static void     (WINAPI *pTpReleaseIoCompletion)(TP_IO *);
 static VOID     (WINAPI *pTpReleasePool)(TP_POOL *);
 static VOID     (WINAPI *pTpReleaseTimer)(TP_TIMER *);
+static VOID     (WINAPI *pTpReleaseWait)(TP_WAIT *);
 static VOID     (WINAPI *pTpReleaseWork)(TP_WORK *);
 static VOID     (WINAPI *pTpSetPoolMaxThreads)(TP_POOL *,DWORD);
+static NTSTATUS (WINAPI *pTpSetPoolStackInformation)(TP_POOL *,TP_POOL_STACK_INFORMATION *);
 static VOID     (WINAPI *pTpSetTimer)(TP_TIMER *,LARGE_INTEGER *,LONG,LONG);
 static VOID     (WINAPI *pTpSetWait)(TP_WAIT *,HANDLE,LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pTpSimpleTryPost)(PTP_SIMPLE_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
@@ -80,6 +82,7 @@ static BOOL init_threadpool(void)
     GET_PROC(TpDisassociateCallback);
     GET_PROC(TpIsTimerSet);
     GET_PROC(TpPostWork);
+    GET_PROC(TpQueryPoolStackInformation);
     GET_PROC(TpReleaseCleanupGroup);
     GET_PROC(TpReleaseCleanupGroupMembers);
     GET_PROC(TpReleaseIoCompletion);
@@ -88,6 +91,7 @@ static BOOL init_threadpool(void)
     GET_PROC(TpReleaseWait);
     GET_PROC(TpReleaseWork);
     GET_PROC(TpSetPoolMaxThreads);
+    GET_PROC(TpSetPoolStackInformation);
     GET_PROC(TpSetTimer);
     GET_PROC(TpSetWait);
     GET_PROC(TpSimpleTryPost);
@@ -575,6 +579,7 @@ static void CALLBACK simple2_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
 
 static void test_tp_simple(void)
 {
+    TP_POOL_STACK_INFORMATION stack_info;
     TP_CALLBACK_ENVIRON environment;
     TP_CALLBACK_ENVIRON_V3 environment3;
     TP_CLEANUP_GROUP *group;
@@ -678,6 +683,22 @@ static void test_tp_simple(void)
     pTpReleaseCleanupGroupMembers(group, TRUE, NULL);
     ok(userdata < 100, "expected userdata < 100, got %lu\n", userdata);
 
+    /* test querying and setting the stack size */
+    status = pTpQueryPoolStackInformation(pool, &stack_info);
+    ok(!status, "TpQueryPoolStackInformation failed: %lx\n", status);
+    ok(stack_info.StackReserve == 2 * 1024 * 1024, "expected default StackReserve, got %ld\n", (ULONG)stack_info.StackReserve);
+    ok(stack_info.StackCommit == 4 * 1024, "expected default StackCommit, got %ld\n", (ULONG)stack_info.StackCommit);
+
+    /* threadpool does not validate the stack size values */
+    stack_info.StackReserve = stack_info.StackCommit = 1;
+    status = pTpSetPoolStackInformation(pool, &stack_info);
+    ok(!status, "TpSetPoolStackInformation failed: %lx\n", status);
+
+    status = pTpQueryPoolStackInformation(pool, &stack_info);
+    ok(!status, "TpQueryPoolStackInformation failed: %lx\n", status);
+    ok(stack_info.StackReserve == 1, "expected 1 byte StackReserve, got %ld\n", (ULONG)stack_info.StackReserve);
+    ok(stack_info.StackCommit == 1, "expected 1 byte StackCommit, got %ld\n", (ULONG)stack_info.StackCommit);
+
     /* cleanup */
     pTpReleaseCleanupGroup(group);
     pTpReleasePool(pool);
diff --git a/dlls/ntdll/tests/virtual.c b/dlls/ntdll/tests/virtual.c
index 6831fe3c522..a239a75ad47 100644
--- a/dlls/ntdll/tests/virtual.c
+++ b/dlls/ntdll/tests/virtual.c
@@ -1265,6 +1265,32 @@ static void test_NtMapViewOfSection(void)
     CloseHandle(file);
     DeleteFileA(testfile);
 
+    /* test zero_bits > 31 with a 64-bit DLL file image mapping */
+    if (is_win64)
+    {
+        file = CreateFileA("c:\\windows\\system32\\version.dll", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
+        ok(file != INVALID_HANDLE_VALUE, "Failed to open version.dll\n");
+
+        mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_IMAGE, 0, 0, NULL);
+        ok(mapping != 0, "CreateFileMapping failed\n");
+
+        ptr = NULL;
+        size = 0;
+        offset.QuadPart = 0;
+        zero_bits = 0x7fffffff;
+        status = NtMapViewOfSection(mapping, process, &ptr, zero_bits, 0, &offset, &size, 1, 0, PAGE_READONLY);
+
+        ok(status == STATUS_SUCCESS || status == STATUS_IMAGE_NOT_AT_BASE, "NtMapViewOfSection returned %08lx\n", status);
+        ok(!((ULONG_PTR)ptr & 0xffff), "returned memory %p is not aligned to 64k\n", ptr);
+        ok(((UINT_PTR)ptr & ~get_zero_bits_mask(zero_bits)) == 0, "NtMapViewOfSection returned address %p\n", ptr);
+
+        status = NtUnmapViewOfSection(process, ptr);
+        ok(status == STATUS_SUCCESS, "NtUnmapViewOfSection returned %08lx\n", status);
+
+        NtClose(mapping);
+        CloseHandle(file);
+    }
+
     TerminateProcess(process, 0);
     CloseHandle(process);
 }
diff --git a/dlls/ntdll/tests/wow64.c b/dlls/ntdll/tests/wow64.c
index b0f5dda5804..b8f28f6215c 100644
--- a/dlls/ntdll/tests/wow64.c
+++ b/dlls/ntdll/tests/wow64.c
@@ -662,7 +662,8 @@ static NTSTATUS call_func64( ULONG64 func64, int nb_args, ULONG64 *args )
     return func( func64, nb_args, args );
 }
 
-static ULONG64 main_module, ntdll_module, wow64_module, wow64cpu_module, wow64win_module;
+static ULONG64 main_module, ntdll_module, wow64_module, wow64base_module, wow64con_module,
+               wow64cpu_module, wow64win_module;
 
 static void enum_modules64( void (*func)(ULONG64,const WCHAR *) )
 {
@@ -776,6 +777,8 @@ static void check_module( ULONG64 base, const WCHAR *name )
 #define CHECK_MODULE(mod) if (!wcsicmp( name, L"" #mod ".dll" )) { mod ## _module = base; return; }
     CHECK_MODULE(ntdll);
     CHECK_MODULE(wow64);
+    CHECK_MODULE(wow64base);
+    CHECK_MODULE(wow64con);
     CHECK_MODULE(wow64cpu);
     CHECK_MODULE(wow64win);
 #undef CHECK_MODULE
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index 1bd8f900d22..b0b61419e37 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -157,6 +157,16 @@ int __cdecl __wine_dbg_header( enum __wine_debug_class cls, struct __wine_debug_
     return info->out_pos;
 }
 
+/***********************************************************************
+ *		__wine_dbg_write  (NTDLL.@)
+ */
+int WINAPI __wine_dbg_write( const char *str, unsigned int len )
+{
+    struct wine_dbg_write_params params = { str, len };
+
+    return WINE_UNIX_CALL( unix_wine_dbg_write, &params );
+}
+
 /***********************************************************************
  *		__wine_dbg_output  (NTDLL.@)
  */
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 99525f831e1..c50983e83d4 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -1152,7 +1152,8 @@ static NTSTATUS tp_new_worker_thread( struct threadpool *pool )
     HANDLE thread;
     NTSTATUS status;
 
-    status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, 0, 0, 0,
+    status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, 0,
+                                  pool->stack_info.StackReserve, pool->stack_info.StackCommit,
                                   threadpool_worker_proc, pool, &thread, NULL );
     if (status == STATUS_SUCCESS)
     {
diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index 0a4ff0f64d3..1c7f20c434e 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -374,7 +374,7 @@ LONGLONG WINAPI RtlGetSystemTimePrecise( void )
 {
     LONGLONG ret;
 
-    NTDLL_UNIX_CALL( system_time_precise, &ret );
+    WINE_UNIX_CALL( unix_system_time_precise, &ret );
     return ret;
 }
 
diff --git a/dlls/ntdll/unix/debug.c b/dlls/ntdll/unix/debug.c
index aa2d87c304f..bc0e3c1c694 100644
--- a/dlls/ntdll/unix/debug.c
+++ b/dlls/ntdll/unix/debug.c
@@ -253,12 +253,30 @@ const char * __cdecl __wine_dbg_strdup( const char *str )
 }
 
 /***********************************************************************
- *		__wine_dbg_write  (NTDLL.@)
+ *		unixcall_wine_dbg_write
  */
-int WINAPI __wine_dbg_write( const char *str, unsigned int len )
+NTSTATUS unixcall_wine_dbg_write( void *args )
 {
-    return write( 2, str, len );
+    struct wine_dbg_write_params *params = args;
+
+    return write( 2, params->str, params->len );
+}
+
+#ifdef _WIN64
+/***********************************************************************
+ *		wow64_wine_dbg_write
+ */
+NTSTATUS wow64_wine_dbg_write( void *args )
+{
+    struct
+    {
+        ULONG        str;
+        unsigned int len;
+    } const *params32 = args;
+
+    return write( 2, ULongToPtr(params32->str), params32->len );
 }
+#endif
 
 /***********************************************************************
  *		__wine_dbg_output  (NTDLL.@)
@@ -272,7 +290,7 @@ int __cdecl __wine_dbg_output( const char *str )
     if (end)
     {
         ret += append_output( info, str, end + 1 - str );
-        __wine_dbg_write( info->output, info->out_pos );
+        write( 2, info->output, info->out_pos );
         info->out_pos = 0;
         str = end + 1;
     }
diff --git a/dlls/ntdll/unix/dwarf.h b/dlls/ntdll/unix/dwarf.h
index 9acda7ca985..906366cf894 100644
--- a/dlls/ntdll/unix/dwarf.h
+++ b/dlls/ntdll/unix/dwarf.h
@@ -934,7 +934,7 @@ static ULONG_PTR eval_expression( const unsigned char *p, CONTEXT *context,
         case DW_OP_eq:          stack[sp-1] = (stack[sp-1] == stack[sp]); sp--; break;
         case DW_OP_ne:          stack[sp-1] = (stack[sp-1] != stack[sp]); sp--; break;
         case DW_OP_skip:        tmp = (short)dwarf_get_u2(&p); p += tmp; break;
-        case DW_OP_bra:         tmp = (short)dwarf_get_u2(&p); if (!stack[sp--]) p += tmp; break;
+        case DW_OP_bra:         tmp = (short)dwarf_get_u2(&p); if (!stack[sp--]) { p += tmp; } break;
         case DW_OP_GNU_encoded_addr: tmp = *p++; stack[++sp] = dwarf_get_ptr( &p, tmp, bases ); break;
         case DW_OP_regx:        stack[++sp] = *(ULONG_PTR *)get_context_reg( context, dwarf_get_uleb128(&p) ); break;
         case DW_OP_bregx:
diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 6f1709f4713..79dc7ffc5c3 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -1848,9 +1848,9 @@ static void init_peb( RTL_USER_PROCESS_PARAMETERS *params, void *module )
 {
     peb->ImageBaseAddress           = module;
     peb->ProcessParameters          = params;
-    peb->OSMajorVersion             = 6;
-    peb->OSMinorVersion             = 1;
-    peb->OSBuildNumber              = 0x1db1;
+    peb->OSMajorVersion             = 10;
+    peb->OSMinorVersion             = 0;
+    peb->OSBuildNumber              = 18362;
     peb->OSPlatformId               = VER_PLATFORM_WIN32_NT;
     peb->ImageSubSystem             = main_image_info.SubSystemType;
     peb->ImageSubSystemMajorVersion = main_image_info.MajorSubsystemVersion;
diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 957d9f3b801..4daf1a5335c 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -1618,7 +1618,7 @@ static int fd_set_dos_attrib( int fd, UINT attr )
 
 
 /* set the stat info and file attributes for a file (by file descriptor) */
-NTSTATUS fd_set_file_info( int fd, UINT attr )
+static NTSTATUS fd_set_file_info( int fd, UINT attr )
 {
     struct stat st;
 
@@ -4138,12 +4138,17 @@ NTSTATUS WINAPI NtCreateNamedPipeFile( HANDLE *handle, ULONG access, OBJECT_ATTR
             (pipe_type ? NAMED_PIPE_MESSAGE_STREAM_WRITE   : 0) |
             (read_mode ? NAMED_PIPE_MESSAGE_STREAM_READ    : 0) |
             (completion_mode ? NAMED_PIPE_NONBLOCKING_MODE : 0);
+        req->disposition  = dispo;
         req->maxinstances = max_inst;
         req->outsize = outbound_quota;
         req->insize  = inbound_quota;
         req->timeout = timeout->QuadPart;
         wine_server_add_data( req, objattr, len );
-        if (!(status = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
+        if (!(status = wine_server_call( req )))
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            io->Information = reply->created ? FILE_CREATED : FILE_OPENED;
+        }
     }
     SERVER_END_REQ;
 
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index a1525cf7f93..5cbe57c020a 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -117,7 +117,6 @@ void     (WINAPI *p__wine_ctrl_routine)(void*);
 SYSTEM_DLL_INIT_BLOCK *pLdrSystemDllInitBlock = NULL;
 
 static void *p__wine_syscall_dispatcher;
-static void **p__wine_unix_call_dispatcher;
 
 static void * const syscalls[] =
 {
@@ -143,6 +142,7 @@ static void * const syscalls[] =
     NtCancelTimer,
     NtClearEvent,
     NtClose,
+    NtCommitTransaction,
     NtCompareObjects,
     NtCompleteConnectPort,
     NtConnectPort,
@@ -168,6 +168,7 @@ static void * const syscalls[] =
     NtCreateThread,
     NtCreateThreadEx,
     NtCreateTimer,
+    NtCreateTransaction,
     NtCreateUserProcess,
     NtDebugActiveProcess,
     NtDebugContinue,
@@ -296,6 +297,7 @@ static void * const syscalls[] =
     NtRestoreKey,
     NtResumeProcess,
     NtResumeThread,
+    NtRollbackTransaction,
     NtSaveKey,
     NtSecureConnectPort,
     NtSetContextThread,
@@ -355,12 +357,7 @@ static void * const syscalls[] =
     NtWriteFileGather,
     NtWriteVirtualMemory,
     NtYieldExecution,
-    __wine_dbg_write,
-    __wine_unix_spawnvp,
     wine_nt_to_unix_file_name,
-    wine_server_call,
-    wine_server_fd_to_handle,
-    wine_server_handle_to_fd,
     wine_unix_to_nt_file_name,
 };
 
@@ -395,7 +392,6 @@ const char **dll_paths = NULL;
 const char **system_dll_paths = NULL;
 const char *user_name = NULL;
 SECTION_IMAGE_INFORMATION main_image_info = { NULL };
-HMODULE ntdll_module = 0;
 static const IMAGE_EXPORT_DIRECTORY *ntdll_exports;
 
 /* adjust an array of pointers to make them into RVAs */
@@ -640,8 +636,6 @@ static void init_paths( char *argv[] )
                 bin_dir = realpath_dirname( path );
             free( path );
         }
-#else
-        bin_dir = realpath_dirname( argv[0] );
 #endif
         if (!bin_dir) bin_dir = build_path( dll_dir, DLL_TO_BINDIR );
         data_dir = build_path( bin_dir, BIN_TO_DATADIR );
@@ -1036,6 +1030,9 @@ static const void *get_module_data_dir( HMODULE module, ULONG dir, ULONG *size )
 
 static void load_ntdll_functions( HMODULE module )
 {
+    void **p__wine_unix_call_dispatcher;
+    unixlib_handle_t *p__wine_unixlib_handle;
+
     ntdll_exports = get_module_data_dir( module, IMAGE_FILE_EXPORT_DIRECTORY, NULL );
     assert( ntdll_exports );
 
@@ -1054,6 +1051,9 @@ static void load_ntdll_functions( HMODULE module )
     GET_FUNC( __wine_ctrl_routine );
     GET_FUNC( __wine_syscall_dispatcher );
     GET_FUNC( __wine_unix_call_dispatcher );
+    GET_FUNC( __wine_unixlib_handle );
+    *p__wine_unix_call_dispatcher = __wine_unix_call_dispatcher;
+    *p__wine_unixlib_handle = (UINT_PTR)__wine_unix_call_funcs;
 #ifdef __aarch64__
     {
         void **p__wine_current_teb;
@@ -1086,6 +1086,14 @@ static void load_ntdll_wow64_functions( HMODULE module )
 
     p__wine_ctrl_routine = (void *)find_named_export( module, exports, "__wine_ctrl_routine" );
 
+#ifdef _WIN64
+    {
+        unixlib_handle_t *p__wine_unixlib_handle = (void *)find_named_export( module, exports,
+                                                                              "__wine_unixlib_handle" );
+        *p__wine_unixlib_handle = (UINT_PTR)__wine_unix_call_wow64_funcs;
+    }
+#endif
+
     /* also set the 32-bit LdrSystemDllInitBlock */
     memcpy( (void *)(ULONG_PTR)pLdrSystemDllInitBlock->pLdrSystemDllInitBlock,
             pLdrSystemDllInitBlock, sizeof(*pLdrSystemDllInitBlock) );
@@ -1904,7 +1912,6 @@ static void load_ntdll(void)
     else if (status) fatal_error( "failed to load %s error %x\n", name, status );
     free( name );
     load_ntdll_functions( module );
-    ntdll_module = module;
 }
 
 
@@ -2049,6 +2056,11 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     load_so_dll,
     unwind_builtin_dll,
+    unixcall_wine_dbg_write,
+    unixcall_wine_server_call,
+    unixcall_wine_server_fd_to_handle,
+    unixcall_wine_server_handle_to_fd,
+    unixcall_wine_spawnvp,
     system_time_precise,
 };
 
@@ -2065,6 +2077,11 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
     wow64_load_so_dll,
     wow64_unwind_builtin_dll,
+    wow64_wine_dbg_write,
+    wow64_wine_server_call,
+    wow64_wine_server_fd_to_handle,
+    wow64_wine_server_handle_to_fd,
+    wow64_wine_spawnvp,
     system_time_precise,
 };
 
@@ -2098,7 +2115,6 @@ static void start_main_thread(void)
     if (main_image_info.Machine != current_machine) load_wow64_ntdll( main_image_info.Machine );
     load_apiset_dll();
     ntdll_init_syscalls( 0, &syscall_table, p__wine_syscall_dispatcher );
-    *p__wine_unix_call_dispatcher = __wine_unix_call_dispatcher;
     server_init_process_done();
 }
 
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index ca153a30bf2..79e5d4bab87 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -538,6 +538,44 @@ NTSTATUS WINAPI __wine_unix_spawnvp( char * const argv[], int wait )
 }
 
 
+/***********************************************************************
+ *           unixcall_wine_spawnvp
+ */
+NTSTATUS unixcall_wine_spawnvp( void *args )
+{
+    struct wine_spawnvp_params *params = args;
+
+    return __wine_unix_spawnvp( params->argv, params->wait );
+}
+
+
+#ifdef _WIN64
+/***********************************************************************
+ *		wow64_wine_spawnvp
+ */
+NTSTATUS wow64_wine_spawnvp( void *args )
+{
+    struct
+    {
+        ULONG argv;
+        int   wait;
+    } const *params32 = args;
+
+    ULONG *argv32 = ULongToPtr( params32->argv );
+    unsigned int i, count = 0;
+    char **argv;
+    NTSTATUS ret;
+
+    while (argv32[count]) count++;
+    argv = malloc( (count + 1) * sizeof(*argv) );
+    for (i = 0; i < count; i++) argv[i] = ULongToPtr( argv32[i] );
+    argv[count] = NULL;
+    ret = __wine_unix_spawnvp( argv, params32->wait );
+    free( argv );
+    return ret;
+}
+#endif
+
 /***********************************************************************
  *           fork_and_exec
  *
@@ -1343,6 +1381,7 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
             else if (!handle) ret = STATUS_INVALID_HANDLE;
             else
             {
+                FIXME( "ProcessHandleCount (%p,%p,0x%08x,%p) stub\n", handle, info, (int)size, ret_len );
                 memset(info, 0, 4);
                 len = 4;
             }
@@ -1355,6 +1394,11 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
         }
         break;
 
+    case ProcessHandleTable:
+        FIXME( "ProcessHandleTable (%p,%p,0x%08x,%p) stub\n", handle, info, (int)size, ret_len );
+        len = 0;
+        break;
+
     case ProcessAffinityMask:
         len = sizeof(ULONG_PTR);
         if (size == len)
@@ -1500,6 +1544,25 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
         else ret = STATUS_INFO_LENGTH_MISMATCH;
         break;
 
+    case ProcessCycleTime:
+        len = sizeof(PROCESS_CYCLE_TIME_INFORMATION);
+        if (size == len)
+        {
+            if (!info) ret = STATUS_ACCESS_VIOLATION;
+            else
+            {
+                PROCESS_CYCLE_TIME_INFORMATION cycles;
+
+                FIXME( "ProcessCycleTime (%p,%p,0x%08x,%p) stub\n", handle, info, (int)size, ret_len );
+                cycles.AccumulatedCycles = 0;
+                cycles.CurrentCycleCount = 0;
+
+                memcpy(info, &cycles, sizeof(PROCESS_CYCLE_TIME_INFORMATION));
+            }
+        }
+        else ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
     case ProcessWineLdtCopy:
         if (handle == NtCurrentProcess())
         {
diff --git a/dlls/ntdll/unix/registry.c b/dlls/ntdll/unix/registry.c
index d183474b53f..a24d6e7c267 100644
--- a/dlls/ntdll/unix/registry.c
+++ b/dlls/ntdll/unix/registry.c
@@ -826,7 +826,7 @@ NTSTATUS WINAPI NtQueryLicenseValue( const UNICODE_STRING *name, ULONG *type,
                                   'S','o','f','t','w','a','r','e','\\',
                                   'W','i','n','e','\\','L','i','c','e','n','s','e',
                                   'I','n','f','o','r','m','a','t','i','o','n',0};
-    UNICODE_STRING keyW = { sizeof(nameW) - sizeof(WCHAR), sizeof(nameW), (WCHAR *)nameW };
+    UNICODE_STRING keyW = RTL_CONSTANT_STRING( nameW );
     KEY_VALUE_PARTIAL_INFORMATION *info;
     NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
     DWORD info_length, count;
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 75a766078cd..1ce174d421e 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -286,6 +286,17 @@ unsigned int CDECL wine_server_call( void *req_ptr )
 }
 
 
+/***********************************************************************
+ *           unixcall_wine_server_call
+ *
+ * Perform a server call.
+ */
+NTSTATUS unixcall_wine_server_call( void *args )
+{
+    return wine_server_call( args );
+}
+
+
 /***********************************************************************
  *           server_enter_uninterrupted_section
  */
@@ -1091,6 +1102,17 @@ NTSTATUS CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned i
 }
 
 
+/***********************************************************************
+ *           unixcall_wine_server_fd_to_handle
+ */
+NTSTATUS unixcall_wine_server_fd_to_handle( void *args )
+{
+    struct wine_server_fd_to_handle_params *params = args;
+
+    return wine_server_fd_to_handle( params->fd, params->access, params->attributes, params->handle );
+}
+
+
 /***********************************************************************
  *           wine_server_handle_to_fd
  *
@@ -1110,6 +1132,17 @@ NTSTATUS CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int
 }
 
 
+/***********************************************************************
+ *           unixcall_wine_server_handle_to_fd
+ */
+NTSTATUS unixcall_wine_server_handle_to_fd( void *args )
+{
+    struct wine_server_handle_to_fd_params *params = args;
+
+    return wine_server_handle_to_fd( params->handle, params->access, params->unix_fd, params->options );
+}
+
+
 /***********************************************************************
  *           server_pipe
  *
@@ -1764,3 +1797,81 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     }
     return ret;
 }
+
+#ifdef _WIN64
+
+struct __server_request_info32
+{
+    union
+    {
+        union generic_request req;
+        union generic_reply   reply;
+    } u;
+    unsigned int            data_count;
+    ULONG                   reply_data;
+    struct { ULONG ptr; data_size_t size; } data[__SERVER_MAX_DATA];
+};
+
+/**********************************************************************
+ *		wow64_wine_server_call
+ */
+NTSTATUS wow64_wine_server_call( void *args )
+{
+    struct __server_request_info32 *req32 = args;
+    unsigned int i;
+    NTSTATUS status;
+    struct __server_request_info req;
+
+    req.u.req = req32->u.req;
+    req.data_count = req32->data_count;
+    for (i = 0; i < req.data_count; i++)
+    {
+        req.data[i].ptr = ULongToPtr( req32->data[i].ptr );
+        req.data[i].size = req32->data[i].size;
+    }
+    req.reply_data = ULongToPtr( req32->reply_data );
+    status = wine_server_call( &req );
+    req32->u.reply = req.u.reply;
+    return status;
+}
+
+/***********************************************************************
+ *		wow64_wine_server_fd_to_handle
+ */
+NTSTATUS wow64_wine_server_fd_to_handle( void *args )
+{
+    struct
+    {
+        int          fd;
+        unsigned int access;
+        unsigned int attributes;
+        ULONG        handle;
+    } const *params32 = args;
+
+    ULONG *handle32 = ULongToPtr( params32->handle );
+    HANDLE handle;
+    NTSTATUS ret;
+
+    ret = wine_server_fd_to_handle( params32->fd, params32->access, params32->attributes, &handle );
+    *handle32 = HandleToULong( handle );
+    return ret;
+}
+
+/**********************************************************************
+ *           wow64_wine_server_handle_to_fd
+ */
+NTSTATUS wow64_wine_server_handle_to_fd( void *args )
+{
+    struct
+    {
+        ULONG        handle;
+        unsigned int access;
+        ULONG        unix_fd;
+        ULONG        options;
+    } const *params32 = args;
+
+    return wine_server_handle_to_fd( ULongToHandle( params32->handle ), params32->access,
+                                     ULongToPtr( params32->unix_fd ), ULongToPtr( params32->options ));
+}
+
+#endif /* _WIN64 */
diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 9bdb2f6d6fb..681c2e3c0c1 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -1155,7 +1155,7 @@ NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context
  *           call_user_mode_callback
  */
 extern NTSTATUS CDECL call_user_mode_callback( void *func, void *stack, void **ret_ptr,
-                                               ULONG *ret_len, TEB *teb );
+                                               ULONG *ret_len, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( call_user_mode_callback,
                    "push {r2-r12,lr}\n\t"
                    "ldr r4, [sp, #0x30]\n\t"  /* teb */
@@ -1184,7 +1184,7 @@ __ASM_GLOBAL_FUNC( call_user_mode_callback,
  *           user_mode_callback_return
  */
 extern void CDECL DECLSPEC_NORETURN user_mode_callback_return( void *ret_ptr, ULONG ret_len,
-                                                               NTSTATUS status, TEB *teb );
+                                                               NTSTATUS status, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( user_mode_callback_return,
                    "ldr r4, [r3, #0x1d8]\n\t" /* arm_thread_data()->syscall_frame */
                    "ldr r5, [r4, #0x4c]\n\t"  /* frame->prev_frame */
@@ -1701,7 +1701,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "ldr r5, [r4]\n\t"               /* table->ServiceTable */
                    "ldr ip, [r5, ip, lsl #2]\n\t"
                    "blx ip\n"
-                   ".L__wine_syscall_dispatcher_return:\n\t"
+                   __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") ":\n\t"
                    "ldr ip, [r8, #0x44]\n\t"    /* frame->restore_flags */
 #ifndef __SOFTFP__
                    "tst ip, #4\n\t"                 /* CONTEXT_FLOATING_POINT */
@@ -1722,12 +1722,12 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "5:\tmovw r0, #0x000d\n\t" /* STATUS_INVALID_PARAMETER */
                    "movt r0, #0xc000\n\t"
                    "add sp, sp, #0x10\n\t"
-                   "b .L__wine_syscall_dispatcher_return\n\t"
+                   "b " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") "\n\t"
                    ".globl " __ASM_NAME("__wine_syscall_dispatcher_return") "\n"
                    __ASM_NAME("__wine_syscall_dispatcher_return") ":\n\t"
                    "mov r8, r0\n\t"
                    "mov r0, r1\n\t"
-                   "b .L__wine_syscall_dispatcher_return" )
+                   "b " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 
 /***********************************************************************
@@ -1762,7 +1762,7 @@ __ASM_GLOBAL_FUNC( __wine_unix_call_dispatcher,
                    "ldr sp, [r8, #0x38]\n\t"
                    "add r8, r8, #0x10\n\t"
                    "ldm r8, {r4-r12,pc}\n\t"
-                   "1:\tb .L__wine_syscall_dispatcher_return" )
+                   "1:\tb " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 
 /***********************************************************************
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 4483303decc..d94b335bc8d 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -881,7 +881,7 @@ NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context
  *           call_user_mode_callback
  */
 extern NTSTATUS CDECL call_user_mode_callback( void *func, void *stack, void **ret_ptr,
-                                               ULONG *ret_len, TEB *teb );
+                                               ULONG *ret_len, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( call_user_mode_callback,
                    "stp x29, x30, [sp,#-0xc0]!\n\t"
                    "mov x29, sp\n\t"
@@ -919,7 +919,7 @@ __ASM_GLOBAL_FUNC( call_user_mode_callback,
  *           user_mode_callback_return
  */
 extern void CDECL DECLSPEC_NORETURN user_mode_callback_return( void *ret_ptr, ULONG ret_len,
-                                                               NTSTATUS status, TEB *teb );
+                                                               NTSTATUS status, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( user_mode_callback_return,
                    "ldr x4, [x3, #0x2f8]\n\t"     /* arm64_thread_data()->syscall_frame */
                    "ldr x5, [x4, #0x110]\n\t"     /* prev_frame */
@@ -1522,7 +1522,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "ldr x16, [x16, x20, lsl 3]\n\t"
                    "blr x16\n\t"
                    "mov sp, x22\n"
-                   ".L__wine_syscall_dispatcher_return:\n\t"
+                   __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") ":\n\t"
                    "ldp x18, x19, [sp, #0x90]\n\t"
                    "ldp x20, x21, [sp, #0xa0]\n\t"
                    "ldp x22, x23, [sp, #0xb0]\n\t"
@@ -1567,12 +1567,12 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "ret x16\n"
                    "4:\tmov x0, #0xc0000000\n\t" /* STATUS_INVALID_PARAMETER */
                    "movk x0, #0x000d\n\t"
-                   "b .L__wine_syscall_dispatcher_return\n\t"
+                   "b " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") "\n\t"
                    ".globl " __ASM_NAME("__wine_syscall_dispatcher_return") "\n"
                    __ASM_NAME("__wine_syscall_dispatcher_return") ":\n\t"
                    "mov sp, x0\n\t"
                    "mov x0, x1\n\t"
-                   "b .L__wine_syscall_dispatcher_return" )
+                   "b " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 
 /***********************************************************************
@@ -1607,7 +1607,7 @@ __ASM_GLOBAL_FUNC( __wine_unix_call_dispatcher,
                    "mov x0, x2\n\t"             /* args */
                    "blr x16\n\t"
                    "ldr w16, [sp, #0x10c]\n\t"  /* frame->restore_flags */
-                   "cbnz w16, .L__wine_syscall_dispatcher_return\n\t"
+                   "cbnz w16, " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") "\n\t"
                    "ldr x18, [sp, #0x90]\n\t"
                    "ldp x16, x17, [sp, #0xf8]\n\t"
                    "mov sp, x16\n\t"
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index d800885748f..a567aa31b2a 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1575,7 +1575,7 @@ NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context
  *           call_user_mode_callback
  */
 extern NTSTATUS CDECL call_user_mode_callback( void *func, void *stack, void **ret_ptr,
-                                               ULONG *ret_len, TEB *teb );
+                                               ULONG *ret_len, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( call_user_mode_callback,
                    "pushl %ebp\n\t"
                    __ASM_CFI(".cfi_adjust_cfa_offset 4\n\t")
@@ -1610,7 +1610,7 @@ __ASM_GLOBAL_FUNC( call_user_mode_callback,
  *           user_mode_callback_return
  */
 extern void CDECL DECLSPEC_NORETURN user_mode_callback_return( void *ret_ptr, ULONG ret_len,
-                                                               NTSTATUS status, TEB *teb );
+                                                               NTSTATUS status, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( user_mode_callback_return,
                    "movl 16(%esp),%edx\n"      /* teb */
                    "movl 0x1f8(%edx),%eax\n\t" /* x86_thread_data()->syscall_frame */
@@ -2630,7 +2630,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "call *(%eax,%edx,4)\n\t"
                    "leal -0x34(%ebp),%esp\n"
 
-                   ".L__wine_syscall_dispatcher_return:\t"
+                   __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") ":\t"
                    __ASM_CFI_CFA_IS_AT1(esp, 0x0c)
                    __ASM_CFI_REG_IS_AT1(esp, esp, 0x0c)
                    __ASM_CFI_REG_IS_AT1(eip, esp, 0x08)
@@ -2707,7 +2707,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "iret\n"
                    __ASM_CFI("\t.cfi_restore_state\n")
                    "6:\tmovl $0xc000000d,%eax\n\t" /* STATUS_INVALID_PARAMETER */
-                   "jmp .L__wine_syscall_dispatcher_return\n\t"
+                   "jmp " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") "\n\t"
 
                    ".globl " __ASM_NAME("__wine_syscall_dispatcher_return") "\n"
                    __ASM_NAME("__wine_syscall_dispatcher_return") ":\n\t"
@@ -2722,7 +2722,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "movl 8(%esp),%eax\n\t"
                    "movl 4(%esp),%esp\n\t"
                    __ASM_CFI(".cfi_restore_state\n\t")
-                   "jmp .L__wine_syscall_dispatcher_return" )
+                   "jmp " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 
 /***********************************************************************
@@ -2769,7 +2769,7 @@ __ASM_GLOBAL_FUNC( __wine_unix_call_dispatcher,
                    __ASM_CFI_REG_IS_AT1(esi, esp, 0x30)
                    __ASM_CFI_REG_IS_AT1(ebp, esp, 0x34)
                    "testw $0xffff,2(%esp)\n\t" /* frame->restore_flags */
-                   "jnz .L__wine_syscall_dispatcher_return\n\t"
+                   "jnz " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") "\n\t"
                    "movl 0x08(%esp),%ecx\n\t"  /* frame->eip */
                    __ASM_CFI(".cfi_register %eip, %ecx\n\t")
                    "movl 0x0c(%esp),%esp\n\t"  /* frame->esp */
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 94d79b9cdd1..9cb5d8199d7 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -812,7 +812,7 @@ static inline void set_sigcontext( const CONTEXT *context, ucontext_t *sigcontex
 /***********************************************************************
  *           init_handler
  */
-static inline void init_handler( const ucontext_t *sigcontext )
+static inline ucontext_t *init_handler( void *sigcontext )
 {
 #ifdef __linux__
     if (fs32_sel)
@@ -821,6 +821,7 @@ static inline void init_handler( const ucontext_t *sigcontext )
         arch_prctl( ARCH_SET_FS, ((struct amd64_thread_data *)thread_data->cpu_data)->pthread_teb );
     }
 #endif
+    return sigcontext;
 }
 
 
@@ -845,8 +846,6 @@ static void save_context( struct xcontext *xcontext, const ucontext_t *sigcontex
 {
     CONTEXT *context = &xcontext->c;
 
-    init_handler( sigcontext );
-
     context->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_DEBUG_REGISTERS;
     context->Rax    = RAX_sig(sigcontext);
     context->Rcx    = RCX_sig(sigcontext);
@@ -1001,6 +1000,10 @@ NTSTATUS WINAPI NtSetContextThread( HANDLE handle, const CONTEXT *context )
     if (!self)
     {
         ret = set_thread_context( handle, context, &self, IMAGE_FILE_MACHINE_AMD64 );
+#ifdef __APPLE__
+        if ((flags & CONTEXT_DEBUG_REGISTERS) && (ret == STATUS_UNSUCCESSFUL))
+            WARN_(seh)( "Setting debug registers is not supported under Rosetta\n" );
+#endif
         if (ret || !self) return ret;
         if (flags & CONTEXT_DEBUG_REGISTERS)
         {
@@ -1573,7 +1576,7 @@ NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context
  *           call_user_mode_callback
  */
 extern NTSTATUS CDECL call_user_mode_callback( void *func, void *stack, void **ret_ptr,
-                                               ULONG *ret_len, TEB *teb );
+                                               ULONG *ret_len, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( call_user_mode_callback,
                    "subq $0xe8,%rsp\n\t"
                    __ASM_SEH(".seh_stackalloc 0xf0\n\t")
@@ -1644,7 +1647,7 @@ __ASM_GLOBAL_FUNC( call_user_mode_callback,
  *           user_mode_callback_return
  */
 extern void CDECL DECLSPEC_NORETURN user_mode_callback_return( void *ret_ptr, ULONG ret_len,
-                                                               NTSTATUS status, TEB *teb );
+                                                               NTSTATUS status, TEB *teb ) DECLSPEC_HIDDEN;
 __ASM_GLOBAL_FUNC( user_mode_callback_return,
                    "movq 0x328(%r9),%r10\n\t"  /* amd64_thread_data()->syscall_frame */
                    "movq 0xa0(%r10),%r11\n\t"  /* frame->prev_frame */
@@ -1929,13 +1932,13 @@ static BOOL handle_syscall_trap( ucontext_t *sigcontext )
 
     if ((void *)RIP_sig( sigcontext ) == __wine_syscall_dispatcher)
     {
-        extern void __wine_syscall_dispatcher_prolog_end(void);
+        extern void __wine_syscall_dispatcher_prolog_end(void) DECLSPEC_HIDDEN;
 
         RIP_sig( sigcontext ) = (ULONG64)__wine_syscall_dispatcher_prolog_end;
     }
     else if ((void *)RIP_sig( sigcontext ) == __wine_unix_call_dispatcher)
     {
-        extern void __wine_unix_call_dispatcher_prolog_end(void);
+        extern void __wine_unix_call_dispatcher_prolog_end(void) DECLSPEC_HIDDEN;
 
         RIP_sig( sigcontext ) = (ULONG64)__wine_unix_call_dispatcher_prolog_end;
         R10_sig( sigcontext ) = RCX_sig( sigcontext );
@@ -1965,10 +1968,10 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
     EXCEPTION_RECORD rec = { 0 };
     struct xcontext context;
-    ucontext_t *ucontext = sigcontext;
+    ucontext_t *ucontext = init_handler( sigcontext );
 
     rec.ExceptionAddress = (void *)RIP_sig(ucontext);
-    save_context( &context, sigcontext );
+    save_context( &context, ucontext );
 
     switch(TRAP_sig(ucontext))
     {
@@ -2004,7 +2007,7 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
                                                   (void *)RSP_sig(ucontext) );
         if (!rec.ExceptionCode)
         {
-            leave_handler( sigcontext );
+            leave_handler( ucontext );
             return;
         }
         break;
@@ -2012,7 +2015,7 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
         if (EFL_sig(ucontext) & 0x00040000)
         {
             EFL_sig(ucontext) &= ~0x00040000;  /* reset AC flag */
-            leave_handler( sigcontext );
+            leave_handler( ucontext );
             return;
         }
         rec.ExceptionCode = EXCEPTION_DATATYPE_MISALIGNMENT;
@@ -2029,8 +2032,8 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
         rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
         break;
     }
-    if (handle_syscall_fault( sigcontext, &rec, &context.c )) return;
-    setup_raise_exception( sigcontext, &rec, &context );
+    if (handle_syscall_fault( ucontext, &rec, &context.c )) return;
+    setup_raise_exception( ucontext, &rec, &context );
 }
 
 
@@ -2043,12 +2046,12 @@ static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
     EXCEPTION_RECORD rec = { 0 };
     struct xcontext context;
-    ucontext_t *ucontext = sigcontext;
+    ucontext_t *ucontext = init_handler( sigcontext );
 
-    if (handle_syscall_trap( sigcontext )) return;
+    if (handle_syscall_trap( ucontext )) return;
 
     rec.ExceptionAddress = (void *)RIP_sig(ucontext);
-    save_context( &context, sigcontext );
+    save_context( &context, ucontext );
 
     switch (TRAP_sig(ucontext))
     {
@@ -2064,7 +2067,7 @@ static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
         rec.ExceptionInformation[0] = 0;
         break;
     }
-    setup_raise_exception( sigcontext, &rec, &context );
+    setup_raise_exception( ucontext, &rec, &context );
 }
 
 
@@ -2076,7 +2079,7 @@ static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
     EXCEPTION_RECORD rec = { 0 };
-    ucontext_t *ucontext = sigcontext;
+    ucontext_t *ucontext = init_handler( sigcontext );
 
     switch (siginfo->si_code)
     {
@@ -2117,7 +2120,7 @@ static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
         rec.ExceptionInformation[1] = FPU_sig(ucontext) ? FPU_sig(ucontext)->MxCsr : 0;
         if (CS_sig(ucontext) != cs64_sel) rec.ExceptionCode = STATUS_FLOAT_MULTIPLE_TRAPS;
     }
-    setup_exception( sigcontext, &rec );
+    setup_exception( ucontext, &rec );
 }
 
 
@@ -2128,12 +2131,16 @@ static void fpe_handler( int signal, siginfo_t *siginfo, void *sigcontext )
  */
 static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
+    ucontext_t *ucontext = init_handler( sigcontext );
     HANDLE handle;
 
-    if (!p__wine_ctrl_routine) return;
-    if (!NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, NULL, NtCurrentProcess(),
-                           p__wine_ctrl_routine, 0 /* CTRL_C_EVENT */, 0, 0, 0, 0, NULL ))
-        NtClose( handle );
+    if (p__wine_ctrl_routine)
+    {
+        if (!NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, NULL, NtCurrentProcess(),
+                               p__wine_ctrl_routine, 0 /* CTRL_C_EVENT */, 0, 0, 0, 0, NULL ))
+            NtClose( handle );
+    }
+    leave_handler( ucontext );
 }
 
 
@@ -2144,9 +2151,10 @@ static void int_handler( int signal, siginfo_t *siginfo, void *sigcontext )
  */
 static void abrt_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
+    ucontext_t *ucontext = init_handler( sigcontext );
     EXCEPTION_RECORD rec = { EXCEPTION_WINE_ASSERTION, EH_NONCONTINUABLE };
 
-    setup_exception( sigcontext, &rec );
+    setup_exception( ucontext, &rec );
 }
 
 
@@ -2167,11 +2175,11 @@ static void quit_handler( int signal, siginfo_t *siginfo, void *ucontext )
  *
  * Handler for SIGUSR1, used to signal a thread that it got suspended.
  */
-static void usr1_handler( int signal, siginfo_t *siginfo, void *ucontext )
+static void usr1_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
+    ucontext_t *ucontext = init_handler( sigcontext );
     struct xcontext context;
 
-    init_handler( ucontext );
     if (is_inside_syscall( ucontext ))
     {
         DECLSPEC_ALIGN(64) XSTATE xs;
@@ -2757,7 +2765,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "leaq -0x98(%rbp),%rcx\n\t"
                    /* $rcx is now pointing to "frame" again */
                    __ASM_CFI(".cfi_restore_state\n")
-                   ".L__wine_syscall_dispatcher_return:\n\t"
+                   __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") ":\n\t"
                    "movl 0x94(%rcx),%edx\n\t"  /* frame->restore_flags */
 #ifdef __linux__
                    "testl $12,%r14d\n\t"           /* SYSCALL_HAVE_PTHREAD_TEB | SYSCALL_HAVE_WRFSGSBASE */
@@ -2849,7 +2857,7 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    __ASM_NAME("__wine_syscall_dispatcher_return") ":\n\t"
                    "movl 0xb0(%rcx),%r14d\n\t"     /* frame->syscall_flags */
                    "movq %rdx,%rax\n\t"
-                   "jmp .L__wine_syscall_dispatcher_return" )
+                   "jmp " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 
 /***********************************************************************
@@ -2930,7 +2938,7 @@ __ASM_GLOBAL_FUNC( __wine_unix_call_dispatcher,
                    "movdqa 0x240(%rcx),%xmm14\n\t"
                    "movdqa 0x250(%rcx),%xmm15\n\t"
                    "testl $0xffff,0x94(%rcx)\n\t"  /* frame->restore_flags */
-                   "jnz .L__wine_syscall_dispatcher_return\n\t"
+                   "jnz " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") "\n\t"
 #ifdef __linux__
                    "testl $12,%r14d\n\t"           /* SYSCALL_HAVE_PTHREAD_TEB | SYSCALL_HAVE_WRFSGSBASE */
                    "jz 1f\n\t"
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index a0905963562..22a3555ba3f 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2561,3 +2561,37 @@ void set_async_direct_result( HANDLE *async_handle, NTSTATUS status, ULONG_PTR i
 
     return;
 }
+
+/***********************************************************************
+ *           NtCreateTransaction (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateTransaction( HANDLE *handle, ACCESS_MASK mask, OBJECT_ATTRIBUTES *obj_attr, GUID *guid, HANDLE tm,
+        ULONG options, ULONG isol_level, ULONG isol_flags, PLARGE_INTEGER timeout, UNICODE_STRING *description )
+{
+    FIXME( "%p, %#x, %p, %s, %p, 0x%08x, 0x%08x, 0x%08x, %p, %p stub.\n", handle, (int)mask, obj_attr, debugstr_guid(guid), tm,
+            (int)options, (int)isol_level, (int)isol_flags, timeout, description );
+
+    *handle = ULongToHandle(1);
+
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           NtCommitTransaction (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCommitTransaction( HANDLE transaction, BOOLEAN wait )
+{
+    FIXME( "%p, %d stub.\n", transaction, wait );
+
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           NtRollbackTransaction (NTDLL.@)
+ */
+NTSTATUS WINAPI NtRollbackTransaction( HANDLE transaction, BOOLEAN wait )
+{
+    FIXME( "%p, %d stub.\n", transaction, wait );
+
+    return STATUS_ACCESS_VIOLATION;
+}
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index b9762fd278f..33e93bbdf32 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -1885,7 +1885,7 @@ static void get_performance_info( SYSTEM_PERFORMANCE_INFORMATION *info )
 
         if ((fp = fopen("/proc/meminfo", "r")))
         {
-            unsigned long long value;
+            unsigned long long value, mem_available = 0;
             char line[64];
 
             while (fgets(line, sizeof(line), fp))
@@ -1902,8 +1902,11 @@ static void get_performance_info( SYSTEM_PERFORMANCE_INFORMATION *info )
                     freeram += value * 1024;
                 else if (sscanf(line, "Cached: %llu", &value))
                     freeram += value * 1024;
+                else if (sscanf(line, "MemAvailable: %llu", &value))
+                    mem_available = value * 1024;
             }
             fclose(fp);
+            if (mem_available) freeram = mem_available;
         }
     }
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || \
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 8821cd78491..d7d1d0d2ac0 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -41,7 +41,6 @@ static const WORD current_machine = IMAGE_FILE_MACHINE_ARMNT;
 static const WORD current_machine = IMAGE_FILE_MACHINE_ARM64;
 #endif
 extern WORD native_machine DECLSPEC_HIDDEN;
-extern HMODULE ntdll_module DECLSPEC_HIDDEN;
 
 extern const unixlib_entry_t __wine_unix_call_funcs[] DECLSPEC_HIDDEN;
 extern const unixlib_entry_t __wine_unix_call_wow64_funcs[] DECLSPEC_HIDDEN;
@@ -284,6 +283,19 @@ extern void init_cpu_info(void) DECLSPEC_HIDDEN;
 extern void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info, BOOL async ) DECLSPEC_HIDDEN;
 extern void set_async_direct_result( HANDLE *async_handle, NTSTATUS status, ULONG_PTR information, BOOL mark_pending ) DECLSPEC_HIDDEN;
 
+extern NTSTATUS unixcall_wine_dbg_write( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS unixcall_wine_server_call( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS unixcall_wine_server_fd_to_handle( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS unixcall_wine_server_handle_to_fd( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS unixcall_wine_spawnvp( void *args ) DECLSPEC_HIDDEN;
+#ifdef _WIN64
+extern NTSTATUS wow64_wine_dbg_write( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS wow64_wine_server_call( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS wow64_wine_server_fd_to_handle( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS wow64_wine_server_handle_to_fd( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS wow64_wine_spawnvp( void *args ) DECLSPEC_HIDDEN;
+#endif
+
 extern void dbg_init(void) DECLSPEC_HIDDEN;
 
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 0f66429fc9d..b1267ff0db5 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -640,35 +640,15 @@ void *get_builtin_so_handle( void *module )
  */
 static NTSTATUS get_builtin_unix_funcs( void *module, BOOL wow, const void **funcs )
 {
-    const char *p, *ptr_name = wow ? "__wine_unix_call_wow64_funcs" : "__wine_unix_call_funcs";
+    const char *ptr_name = wow ? "__wine_unix_call_wow64_funcs" : "__wine_unix_call_funcs";
     sigset_t sigset;
     NTSTATUS status = STATUS_DLL_NOT_FOUND;
     struct builtin_module *builtin;
 
-    if (module == ntdll_module)
-    {
-#ifdef _WIN64
-        *funcs = wow ? __wine_unix_call_wow64_funcs : __wine_unix_call_funcs;
-#else
-        *funcs = __wine_unix_call_funcs;
-#endif
-        return STATUS_SUCCESS;
-    }
-
     server_enter_uninterrupted_section( &virtual_mutex, &sigset );
     LIST_FOR_EACH_ENTRY( builtin, &builtin_modules, struct builtin_module, entry )
     {
         if (builtin->module != module) continue;
-        if (builtin->unix_path && (p = strrchr( builtin->unix_path, '/' )) && !strcmp( p, "/ntdll.so" ))
-        {
-#ifdef _WIN64
-            *funcs = wow ? __wine_unix_call_wow64_funcs : __wine_unix_call_funcs;
-#else
-            *funcs = __wine_unix_call_funcs;
-#endif
-            status = STATUS_SUCCESS;
-            break;
-        }
         if (builtin->unix_path && !builtin->unix_handle)
             builtin->unix_handle = dlopen( builtin->unix_path, RTLD_NOW );
         if (builtin->unix_handle)
@@ -1923,6 +1903,8 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
     {
         if (is_beyond_limit( base, size, address_space_limit ))
             return STATUS_WORKING_SET_LIMIT_RANGE;
+        if (limit && is_beyond_limit( base, size, (void *)limit ))
+            return STATUS_CONFLICTING_ADDRESSES;
         status = map_fixed_area( base, size, vprot );
         if (status != STATUS_SUCCESS) return status;
         ptr = base;
@@ -3192,7 +3174,7 @@ void virtual_map_user_shared_data(void)
 {
     static const WCHAR nameW[] = {'\\','K','e','r','n','e','l','O','b','j','e','c','t','s',
                                   '\\','_','_','w','i','n','e','_','u','s','e','r','_','s','h','a','r','e','d','_','d','a','t','a',0};
-    UNICODE_STRING name_str = { sizeof(nameW) - sizeof(WCHAR), sizeof(nameW), (WCHAR *)nameW };
+    UNICODE_STRING name_str = RTL_CONSTANT_STRING( nameW );
     OBJECT_ATTRIBUTES attr = { sizeof(attr), 0, &name_str };
     unsigned int status;
     HANDLE section;
diff --git a/dlls/ntdll/unixlib.h b/dlls/ntdll/unixlib.h
index 0b4c2a984bb..22e5663990d 100644
--- a/dlls/ntdll/unixlib.h
+++ b/dlls/ntdll/unixlib.h
@@ -25,6 +25,34 @@
 
 struct _DISPATCHER_CONTEXT;
 
+struct wine_dbg_write_params
+{
+    const char  *str;
+    unsigned int len;
+};
+
+struct wine_server_fd_to_handle_params
+{
+    int          fd;
+    unsigned int access;
+    unsigned int attributes;
+    HANDLE      *handle;
+};
+
+struct wine_server_handle_to_fd_params
+{
+    HANDLE        handle;
+    unsigned int  access;
+    int          *unix_fd;
+    unsigned int *options;
+};
+
+struct wine_spawnvp_params
+{
+    char       **argv;
+    int          wait;
+};
+
 struct load_so_dll_params
 {
     UNICODE_STRING              nt_name;
@@ -42,11 +70,14 @@ enum ntdll_unix_funcs
 {
     unix_load_so_dll,
     unix_unwind_builtin_dll,
+    unix_wine_dbg_write,
+    unix_wine_server_call,
+    unix_wine_server_fd_to_handle,
+    unix_wine_server_handle_to_fd,
+    unix_wine_spawnvp,
     unix_system_time_precise,
 };
 
-extern unixlib_handle_t ntdll_unix_handle;
-
-#define NTDLL_UNIX_CALL( func, params ) __wine_unix_call_dispatcher( ntdll_unix_handle, unix_ ## func, params )
+extern unixlib_handle_t __wine_unixlib_handle DECLSPEC_HIDDEN;
 
 #endif /* __NTDLL_UNIXLIB_H */
diff --git a/dlls/ntdll/version.c b/dlls/ntdll/version.c
index 02544173096..9c396598d4e 100644
--- a/dlls/ntdll/version.c
+++ b/dlls/ntdll/version.c
@@ -55,6 +55,7 @@ typedef enum
     WIN8,    /* Windows 8 */
     WIN81,   /* Windows 8.1 */
     WIN10,   /* Windows 10 */
+    WIN11,   /* Windows 11 */
     NB_WINDOWS_VERSIONS
 } WINDOWS_VERSION;
 
@@ -170,7 +171,11 @@ static const RTL_OSVERSIONINFOEXW VersionData[NB_WINDOWS_VERSIONS] =
         sizeof(RTL_OSVERSIONINFOEXW), 10, 0, 18362, VER_PLATFORM_WIN32_NT,
         L"", 0, 0, VER_SUITE_SINGLEUSERTS, VER_NT_WORKSTATION, 0
     },
-
+    /* WIN11 */
+    {
+        sizeof(RTL_OSVERSIONINFOEXW), 10, 0, 22000, VER_PLATFORM_WIN32_NT,
+        L"", 0, 0, VER_SUITE_SINGLEUSERTS, VER_NT_WORKSTATION, 0
+    },
 };
 
 static const struct { WCHAR name[12]; WINDOWS_VERSION ver; } version_names[] =
@@ -201,6 +206,7 @@ static const struct { WCHAR name[12]; WINDOWS_VERSION ver; } version_names[] =
     { L"win8", WIN8 },
     { L"win81", WIN81 },
     { L"win10", WIN10 },
+    { L"win11", WIN11 },
 };
 
 
@@ -270,18 +276,36 @@ static BOOL get_nt_registry_version( RTL_OSVERSIONINFOEXW *version )
 
     memset( version, 0, sizeof(*version) );
 
-    RtlInitUnicodeString( &valueW, L"CurrentVersion" );
-    if (!NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation, tmp, sizeof(tmp)-1, &count ))
+    RtlInitUnicodeString( &valueW, L"CurrentMajorVersionNumber" );
+    if (!NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation, tmp, sizeof(tmp)-1, &count ) &&
+        info->Type == REG_DWORD)
     {
-        WCHAR *p, *str = (WCHAR *)info->Data;
-        str[info->DataLength / sizeof(WCHAR)] = 0;
-        p = wcschr( str, '.' );
-        if (p)
+        version->dwMajorVersion = *(DWORD *)info->Data;
+
+        RtlInitUnicodeString( &valueW, L"CurrentMinorVersionNumber" );
+        if (!NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation, tmp, sizeof(tmp)-1, &count ) &&
+            info->Type == REG_DWORD)
         {
-            *p++ = 0;
-            version->dwMinorVersion = wcstoul( p, NULL, 10 );
+            version->dwMinorVersion = *(DWORD *)info->Data;
+        }
+        else version->dwMajorVersion = 0;
+    }
+
+    if (!version->dwMajorVersion)
+    {
+        RtlInitUnicodeString( &valueW, L"CurrentVersion" );
+        if (!NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation, tmp, sizeof(tmp)-1, &count ))
+        {
+            WCHAR *p, *str = (WCHAR *)info->Data;
+            str[info->DataLength / sizeof(WCHAR)] = 0;
+            p = wcschr( str, '.' );
+            if (p)
+            {
+                *p++ = 0;
+                version->dwMinorVersion = wcstoul( p, NULL, 10 );
+            }
+            version->dwMajorVersion = wcstoul( str, NULL, 10 );
         }
-        version->dwMajorVersion = wcstoul( str, NULL, 10 );
     }
 
     if (version->dwMajorVersion)   /* we got the main version, now fetch the other fields */
@@ -467,7 +491,7 @@ void version_init(void)
 
     NtQuerySystemInformation( SystemWineVersionInformation, wine_version, sizeof(wine_version), NULL );
 
-    current_version = &VersionData[WIN7];
+    current_version = &VersionData[WIN10];
 
     RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
     attr.Length = sizeof(attr);
diff --git a/dlls/ntoskrnl.exe/pnp.c b/dlls/ntoskrnl.exe/pnp.c
index 7c77a9a7145..59655a24777 100644
--- a/dlls/ntoskrnl.exe/pnp.c
+++ b/dlls/ntoskrnl.exe/pnp.c
@@ -720,18 +720,18 @@ NTSTATUS WINAPI IoSetDeviceInterfaceState( UNICODE_STRING *name, BOOLEAN enable
         'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
         'C','o','n','t','r','o','l','\\',
         'D','e','v','i','c','e','C','l','a','s','s','e','s','\\',0};
-    static const WCHAR controlW[] = {'C','o','n','t','r','o','l',0};
-    static const WCHAR linkedW[] = {'L','i','n','k','e','d',0};
     static const WCHAR slashW[] = {'\\',0};
     static const WCHAR hashW[] = {'#',0};
 
     size_t namelen = name->Length / sizeof(WCHAR);
     DEV_BROADCAST_DEVICEINTERFACE_W *broadcast;
-    WCHAR *path, *refstr, *p, *upper_end;
     struct device_interface *iface;
     HANDLE iface_key, control_key;
     OBJECT_ATTRIBUTES attr = {0};
     struct wine_rb_entry *entry;
+    UNICODE_STRING control = RTL_CONSTANT_STRING( L"Control" );
+    UNICODE_STRING linked = RTL_CONSTANT_STRING( L"Linked" );
+    WCHAR *path, *refstr, *p;
     UNICODE_STRING string;
     DWORD data = enable;
     NTSTATUS ret;
@@ -780,14 +780,14 @@ NTSTATUS WINAPI IoSetDeviceInterfaceState( UNICODE_STRING *name, BOOLEAN enable
         return ret;
 
     attr.RootDirectory = iface_key;
-    RtlInitUnicodeString( &string, controlW );
+    attr.ObjectName = &control;
     ret = NtCreateKey( &control_key, KEY_SET_VALUE, &attr, 0, NULL, REG_OPTION_VOLATILE, NULL );
     NtClose( iface_key );
     if (ret)
         return ret;
 
-    RtlInitUnicodeString( &string, linkedW );
-    ret = NtSetValueKey( control_key, &string, 0, REG_DWORD, &data, sizeof(data) );
+    attr.ObjectName = &linked;
+    ret = NtSetValueKey( control_key, &linked, 0, REG_DWORD, &data, sizeof(data) );
     if (ret)
     {
         NtClose( control_key );
@@ -800,7 +800,7 @@ NTSTATUS WINAPI IoSetDeviceInterfaceState( UNICODE_STRING *name, BOOLEAN enable
         ret = IoDeleteSymbolicLink( name );
     if (ret)
     {
-        NtDeleteValueKey( control_key, &string );
+        NtDeleteValueKey( control_key, &linked );
         NtClose( control_key );
         return ret;
     }
@@ -817,12 +817,6 @@ NTSTATUS WINAPI IoSetDeviceInterfaceState( UNICODE_STRING *name, BOOLEAN enable
         broadcast->dbcc_classguid  = iface->interface_class;
         lstrcpynW( broadcast->dbcc_name, name->Buffer, namelen + 1 );
         if (namelen > 1) broadcast->dbcc_name[1] = '\\';
-
-        upper_end = wcschr( broadcast->dbcc_name, '#' );
-        if (upper_end) upper_end = wcschr( upper_end + 1, '#' );
-        while (upper_end && upper_end-- != broadcast->dbcc_name)
-            *upper_end = towupper( *upper_end );
-
         send_devicechange( enable ? DBT_DEVICEARRIVAL : DBT_DEVICEREMOVECOMPLETE, broadcast, len );
         heap_free( broadcast );
     }
@@ -883,13 +877,12 @@ NTSTATUS WINAPI IoRegisterDeviceInterface(DEVICE_OBJECT *device, const GUID *cla
     SP_DEVICE_INTERFACE_DATA sp_iface = {sizeof(sp_iface)};
     SP_DEVINFO_DATA sp_device = {sizeof(sp_device)};
     WCHAR device_instance_id[MAX_DEVICE_ID_LEN];
-    SP_DEVICE_INTERFACE_DETAIL_DATA_W *data;
     NTSTATUS status = STATUS_SUCCESS;
     UNICODE_STRING device_path;
     struct device_interface *iface;
     struct wine_rb_entry *entry;
-    DWORD required;
     HDEVINFO set;
+    WCHAR *p;
 
     TRACE("device %p, class_guid %s, refstr %s, symbolic_link %p.\n",
             device, debugstr_guid(class_guid), debugstr_us(refstr), symbolic_link);
@@ -910,22 +903,31 @@ NTSTATUS WINAPI IoRegisterDeviceInterface(DEVICE_OBJECT *device, const GUID *cla
     if (!SetupDiCreateDeviceInterfaceW( set, &sp_device, class_guid, refstr ? refstr->Buffer : NULL, 0, &sp_iface ))
         return STATUS_UNSUCCESSFUL;
 
-    required = 0;
-    SetupDiGetDeviceInterfaceDetailW( set, &sp_iface, NULL, 0, &required, NULL );
-    if (required == 0) return STATUS_UNSUCCESSFUL;
+    /* setupapi mangles the case; construct the interface path manually. */
 
-    data = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, required );
-    data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
+    device_path.Length = (4 + wcslen( device_instance_id ) + 1 + 38) * sizeof(WCHAR);
+    if (refstr)
+        device_path.Length += sizeof(WCHAR) + refstr->Length;
+    device_path.MaximumLength = device_path.Length + sizeof(WCHAR);
 
-    if (!SetupDiGetDeviceInterfaceDetailW( set, &sp_iface, data, required, NULL, NULL ))
+    device_path.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, device_path.MaximumLength );
+    swprintf( device_path.Buffer, device_path.MaximumLength / sizeof(WCHAR),
+            L"\\??\\%s#{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
+            device_instance_id, class_guid->Data1, class_guid->Data2, class_guid->Data3,
+            class_guid->Data4[0], class_guid->Data4[1], class_guid->Data4[2], class_guid->Data4[3],
+            class_guid->Data4[4], class_guid->Data4[5], class_guid->Data4[6], class_guid->Data4[7] );
+    for (p = device_path.Buffer + 4; *p; p++)
     {
-        HeapFree( GetProcessHeap(), 0, data );
-        return STATUS_UNSUCCESSFUL;
+        if (*p == '\\')
+            *p = '#';
+    }
+    if (refstr)
+    {
+        *p++ = '\\';
+        wcscpy( p, refstr->Buffer );
     }
 
-    data->DevicePath[1] = '?';
-    TRACE("Returning path %s.\n", debugstr_w(data->DevicePath));
-    RtlCreateUnicodeString( &device_path, data->DevicePath);
+    TRACE("Returning path %s.\n", debugstr_us(&device_path));
 
     entry = wine_rb_get( &device_interfaces, &device_path );
     if (entry)
@@ -937,7 +939,7 @@ NTSTATUS WINAPI IoRegisterDeviceInterface(DEVICE_OBJECT *device, const GUID *cla
     else
     {
         iface = heap_alloc_zero( sizeof(struct device_interface) );
-        RtlCreateUnicodeString(&iface->symbolic_link, data->DevicePath);
+        RtlDuplicateUnicodeString( 1, &device_path, &iface->symbolic_link );
         if (wine_rb_put( &device_interfaces, &iface->symbolic_link, &iface->entry ))
             ERR("Failed to insert interface %s into tree.\n", debugstr_us(&iface->symbolic_link));
     }
@@ -945,9 +947,7 @@ NTSTATUS WINAPI IoRegisterDeviceInterface(DEVICE_OBJECT *device, const GUID *cla
     iface->device = device;
     iface->interface_class = *class_guid;
     if (symbolic_link)
-        RtlCreateUnicodeString( symbolic_link, data->DevicePath);
-
-    HeapFree( GetProcessHeap(), 0, data );
+        RtlDuplicateUnicodeString( 1, &device_path, symbolic_link );
 
     RtlFreeUnicodeString( &device_path );
 
@@ -1141,15 +1141,13 @@ static DWORD CALLBACK device_enum_thread_proc(void *arg)
 
 void pnp_manager_start(void)
 {
-    static const WCHAR driver_nameW[] = {'\\','D','r','i','v','e','r','\\','P','n','p','M','a','n','a','g','e','r',0};
     WCHAR endpoint[] = L"\\pipe\\wine_plugplay";
     WCHAR protseq[] = L"ncacn_np";
-    UNICODE_STRING driver_nameU;
+    UNICODE_STRING driver_nameU = RTL_CONSTANT_STRING( L"\\Driver\\PnpManager" );
     RPC_WSTR binding_str;
     NTSTATUS status;
     RPC_STATUS err;
 
-    RtlInitUnicodeString( &driver_nameU, driver_nameW );
     if ((status = IoCreateDriver( &driver_nameU, pnp_manager_driver_entry )))
         ERR("Failed to create PnP manager driver, status %#lx.\n", status);
 
diff --git a/dlls/ntoskrnl.exe/tests/driver_netio.c b/dlls/ntoskrnl.exe/tests/driver_netio.c
index e406f49eacb..9f9478d75b0 100644
--- a/dlls/ntoskrnl.exe/tests/driver_netio.c
+++ b/dlls/ntoskrnl.exe/tests/driver_netio.c
@@ -235,6 +235,7 @@ static void test_wsk_listen_socket(void)
     memset(&addr, 0, sizeof(addr));
     addr.sin_family = AF_INET;
     addr.sin_port = htons(SERVER_LISTEN_PORT);
+    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 
     IoReuseIrp(wsk_irp, STATUS_UNSUCCESSFUL);
     IoSetCompletionRoutine(wsk_irp, irp_completion_routine, &irp_complete_event, TRUE, TRUE, TRUE);
diff --git a/dlls/ntoskrnl.exe/tests/driver_pnp.c b/dlls/ntoskrnl.exe/tests/driver_pnp.c
index 9a965f584cd..77332708fd3 100644
--- a/dlls/ntoskrnl.exe/tests/driver_pnp.c
+++ b/dlls/ntoskrnl.exe/tests/driver_pnp.c
@@ -34,6 +34,19 @@
 #include "driver.h"
 #include "utils.h"
 
+/* memcmp() isn't exported from ntoskrnl on i386 */
+static int kmemcmp( const void *ptr1, const void *ptr2, size_t n )
+{
+    const unsigned char *p1, *p2;
+
+    for (p1 = ptr1, p2 = ptr2; n; n--, p1++, p2++)
+    {
+        if (*p1 < *p2) return -1;
+        if (*p1 > *p2) return 1;
+    }
+    return 0;
+}
+
 static const GUID bus_class     = {0xdeadbeef, 0x29ef, 0x4538, {0xa5, 0xfd, 0xb6, 0x95, 0x73, 0xa3, 0x62, 0xc1}};
 static const GUID child_class   = {0xdeadbeef, 0x29ef, 0x4538, {0xa5, 0xfd, 0xb6, 0x95, 0x73, 0xa3, 0x62, 0xc2}};
 static UNICODE_STRING control_symlink, bus_symlink;
@@ -178,7 +191,7 @@ static NTSTATUS fdo_pnp(IRP *irp)
 
 static NTSTATUS query_id(struct device *device, IRP *irp, BUS_QUERY_ID_TYPE type)
 {
-    static const WCHAR device_id[] = L"wine\\test";
+    static const WCHAR device_id[] = L"Wine\\Test";
     WCHAR *id = NULL;
 
     irp->IoStatus.Information = 0;
@@ -256,6 +269,7 @@ static NTSTATUS pdo_pnp(DEVICE_OBJECT *device_obj, IRP *irp)
 
         case IRP_MN_START_DEVICE:
         {
+            static const WCHAR expect_symlink[] = L"\\??\\Wine#Test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}";
             static const LARGE_INTEGER wait_time = {.QuadPart = -500 * 10000};
             POWER_STATE state = {.DeviceState = PowerDeviceD0};
             NTSTATUS status;
@@ -267,6 +281,12 @@ static NTSTATUS pdo_pnp(DEVICE_OBJECT *device_obj, IRP *irp)
 
             status = IoRegisterDeviceInterface(device_obj, &child_class, NULL, &device->child_symlink);
             ok(!status, "Failed to register interface, status %#lx.\n", status);
+            ok(device->child_symlink.Length == sizeof(expect_symlink) - sizeof(WCHAR),
+                    "Got length %u.\n", device->child_symlink.Length);
+            ok(device->child_symlink.MaximumLength == sizeof(expect_symlink),
+                    "Got maximum length %u.\n", device->child_symlink.MaximumLength);
+            ok(!kmemcmp(device->child_symlink.Buffer, expect_symlink, device->child_symlink.MaximumLength),
+                    "Got symlink \"%ls\".\n", device->child_symlink.Buffer);
 
             IoSetDeviceInterfaceState(&device->child_symlink, TRUE);
 
diff --git a/dlls/ntoskrnl.exe/tests/ntoskrnl.c b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
index ff93cfc98ec..859dab4b3a9 100644
--- a/dlls/ntoskrnl.exe/tests/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
@@ -1400,13 +1400,13 @@ static LRESULT WINAPI device_notify_proc(HWND window, UINT message, WPARAM wpara
             if (IsEqualGUID(&iface->dbcc_classguid, &bus_class))
             {
                 ++got_bus_arrival;
-                todo_wine ok(!strcmp(iface->dbcc_name, "\\\\?\\ROOT#WINETEST#0#{deadbeef-29ef-4538-a5fd-b69573a362c1}"),
+                ok(!strcmp(iface->dbcc_name, "\\\\?\\ROOT#WINETEST#0#{deadbeef-29ef-4538-a5fd-b69573a362c1}"),
                         "got name %s\n", debugstr_a(iface->dbcc_name));
             }
             else if (IsEqualGUID(&iface->dbcc_classguid, &child_class))
             {
                 ++got_child_arrival;
-                todo_wine ok(!strcmp(iface->dbcc_name, "\\\\?\\wine#test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
+                ok(!strcmp(iface->dbcc_name, "\\\\?\\Wine#Test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
                         "got name %s\n", debugstr_a(iface->dbcc_name));
             }
             break;
@@ -1428,13 +1428,13 @@ static LRESULT WINAPI device_notify_proc(HWND window, UINT message, WPARAM wpara
             if (IsEqualGUID(&iface->dbcc_classguid, &bus_class))
             {
                 ++got_bus_removal;
-                todo_wine ok(!strcmp(iface->dbcc_name, "\\\\?\\ROOT#WINETEST#0#{deadbeef-29ef-4538-a5fd-b69573a362c1}"),
+                ok(!strcmp(iface->dbcc_name, "\\\\?\\ROOT#WINETEST#0#{deadbeef-29ef-4538-a5fd-b69573a362c1}"),
                         "got name %s\n", debugstr_a(iface->dbcc_name));
             }
             else if (IsEqualGUID(&iface->dbcc_classguid, &child_class))
             {
                 ++got_child_removal;
-                todo_wine ok(!strcmp(iface->dbcc_name, "\\\\?\\wine#test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
+                ok(!strcmp(iface->dbcc_name, "\\\\?\\Wine#Test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
                         "got name %s\n", debugstr_a(iface->dbcc_name));
             }
             break;
@@ -1506,7 +1506,7 @@ static void test_pnp_devices(void)
 
     ret = SetupDiGetDeviceInstanceIdA(set, &device, buffer, sizeof(buffer), NULL);
     ok(ret, "failed to get device ID, error %#lx\n", GetLastError());
-    ok(!strcasecmp(buffer, "root\\winetest\\0"), "got ID %s\n", debugstr_a(buffer));
+    ok(!strcmp(buffer, "ROOT\\WINETEST\\0"), "got ID %s\n", debugstr_a(buffer));
 
     ret = SetupDiEnumDeviceInterfaces(set, NULL, &control_class, 0, &iface);
     ok(ret, "failed to get interface, error %#lx\n", GetLastError());
@@ -1517,7 +1517,7 @@ static void test_pnp_devices(void)
     iface_detail->cbSize = sizeof(*iface_detail);
     ret = SetupDiGetDeviceInterfaceDetailA(set, &iface, iface_detail, sizeof(buffer), NULL, NULL);
     ok(ret, "failed to get interface path, error %#lx\n", GetLastError());
-    ok(!strcasecmp(iface_detail->DevicePath, "\\\\?\\root#winetest#0#{deadbeef-29ef-4538-a5fd-b69573a362c0}"),
+    ok(!strcmp(iface_detail->DevicePath, "\\\\?\\root#winetest#0#{deadbeef-29ef-4538-a5fd-b69573a362c0}"),
             "wrong path %s\n", debugstr_a(iface_detail->DevicePath));
 
     SetupDiDestroyDeviceInfoList(set);
@@ -1614,7 +1614,7 @@ static void test_pnp_devices(void)
 
     ret = SetupDiGetDeviceInstanceIdA(set, &device, buffer, sizeof(buffer), NULL);
     ok(ret, "failed to get device ID, error %#lx\n", GetLastError());
-    ok(!strcasecmp(buffer, "wine\\test\\1"), "got ID %s\n", debugstr_a(buffer));
+    ok(!strcmp(buffer, "WINE\\TEST\\1"), "got ID %s\n", debugstr_a(buffer));
 
     ret = SetupDiGetDeviceRegistryPropertyA(set, &device, SPDRP_CAPABILITIES,
             &type, (BYTE *)&dword, sizeof(dword), NULL);
@@ -1680,6 +1680,18 @@ static void test_pnp_devices(void)
         ok(!strcmp(buffer, "\\Device\\winetest_pnp_1"), "got PDO name %s\n", debugstr_a(buffer));
     }
 
+    ret = SetupDiEnumDeviceInterfaces(set, NULL, &child_class, 0, &iface);
+    ok(ret, "failed to get interface, error %#lx\n", GetLastError());
+    ok(IsEqualGUID(&iface.InterfaceClassGuid, &child_class),
+            "wrong class %s\n", debugstr_guid(&iface.InterfaceClassGuid));
+    ok(iface.Flags == SPINT_ACTIVE, "got flags %#lx\n", iface.Flags);
+
+    iface_detail->cbSize = sizeof(*iface_detail);
+    ret = SetupDiGetDeviceInterfaceDetailA(set, &iface, iface_detail, sizeof(buffer), NULL, NULL);
+    ok(ret, "failed to get interface path, error %#lx\n", GetLastError());
+    ok(!strcmp(iface_detail->DevicePath, "\\\\?\\wine#test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
+            "wrong path %s\n", debugstr_a(iface_detail->DevicePath));
+
     SetupDiDestroyDeviceInfoList(set);
 
     RtlInitUnicodeString(&string, L"\\Device\\winetest_pnp_1");
diff --git a/dlls/odbccp32/odbccp32.c b/dlls/odbccp32/odbccp32.c
index 131cb158ed6..0025fad7c4b 100644
--- a/dlls/odbccp32/odbccp32.c
+++ b/dlls/odbccp32/odbccp32.c
@@ -271,7 +271,7 @@ static HMODULE load_config_driver(const WCHAR *driver)
         return NULL;
     }
 
-    hmod = LoadLibraryW(filename);
+    hmod = LoadLibraryExW(filename, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
     HeapFree(GetProcessHeap(), 0, filename);
 
     if(!hmod)
diff --git a/dlls/ole32/compobj.c b/dlls/ole32/compobj.c
index 8d2591c1211..1eb5dc6e8f5 100644
--- a/dlls/ole32/compobj.c
+++ b/dlls/ole32/compobj.c
@@ -252,7 +252,7 @@ static HKEY create_classes_root_hkey(DWORD access)
 {
     HKEY hkey, ret = 0;
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING name;
+    UNICODE_STRING name = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Classes");
 
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
@@ -260,7 +260,6 @@ static HKEY create_classes_root_hkey(DWORD access)
     attr.Attributes = 0;
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &name, L"\\Registry\\Machine\\Software\\Classes" );
     if (create_key( &hkey, access, &attr )) return 0;
     TRACE( "%s -> %p\n", debugstr_w(attr.ObjectName->Buffer), hkey );
 
diff --git a/dlls/ole32/tests/marshal.c b/dlls/ole32/tests/marshal.c
index 7a69ad9ed15..18f47a5c64c 100644
--- a/dlls/ole32/tests/marshal.c
+++ b/dlls/ole32/tests/marshal.c
@@ -269,7 +269,7 @@ static ULONG WINAPI TestCrash_IUnknown_Release(LPUNKNOWN iface)
     UnlockModule();
     if(!cLocks) {
         trace("crashing...\n");
-        *(int**)0xc = 0;
+        RaiseException( EXCEPTION_ACCESS_VIOLATION, EXCEPTION_NONCONTINUABLE, 0, NULL );
     }
     return 1; /* non-heap-based object */
 }
diff --git a/dlls/oleaut32/oleaut.c b/dlls/oleaut32/oleaut.c
index 858622c833c..92a9f12661b 100644
--- a/dlls/oleaut32/oleaut.c
+++ b/dlls/oleaut32/oleaut.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
@@ -34,6 +35,7 @@
 #include "ole2.h"
 #include "olectl.h"
 #include "oleauto.h"
+#include "rpcproxy.h"
 #include "initguid.h"
 #include "typelib.h"
 #include "oleaut32_oaidl.h"
@@ -999,6 +1001,114 @@ static HRESULT dispatch_create_stub(IUnknown *server, IRpcStubBuffer **stub)
     return hr;
 }
 
+struct dispinterface_stub
+{
+    CInterfaceStubVtbl stub_vtbl;
+    CStdStubBuffer stub_buffer;
+};
+
+static struct dispinterface_stub *impl_from_IRpcStubBuffer(IRpcStubBuffer *iface)
+{
+    return CONTAINING_RECORD(&iface->lpVtbl, struct dispinterface_stub, stub_buffer.lpVtbl);
+}
+
+static ULONG WINAPI dispinterface_stub_Release(IRpcStubBuffer *iface)
+{
+    struct dispinterface_stub *stub = impl_from_IRpcStubBuffer(iface);
+    unsigned int refcount = InterlockedDecrement(&stub->stub_buffer.RefCount);
+
+    TRACE("%p decreasing refcount to %u.\n", stub, refcount);
+
+    if (!refcount)
+    {
+        /* Copied from NdrCStdStubBuffer_Release(), but supposedly incorrect
+         * according to the comment there. */
+        IRpcStubBuffer_Disconnect(iface);
+
+        free(stub);
+    }
+    return refcount;
+}
+
+extern const ExtendedProxyFileInfo oleaut32_oaidl_ProxyFileInfo;
+
+static const CInterfaceStubVtbl *find_idispatch_stub_vtbl(void)
+{
+    CInterfaceStubVtbl *const *vtbl;
+
+    for (vtbl = oleaut32_oaidl_ProxyFileInfo.pStubVtblList; *vtbl; ++vtbl)
+    {
+        if (IsEqualGUID((*vtbl)->header.piid, &IID_IDispatch))
+            return *vtbl;
+    }
+
+    assert(0);
+    return NULL;
+}
+
+/* Normal dispinterfaces have an IID specified by the IDL compiler as DIID_*,
+ * but are otherwise identical to IDispatch. Unfortunately, such interfaces may
+ * not actually support IDispatch in QueryInterface.
+ *
+ * This becomes a problem, since CreateStub() was designed such that, for some
+ * reason, the caller need not actually pass the interface matching "iid". As
+ * such the standard rpcrt4 implementation will query the server for the
+ * relevant IID.
+ *
+ * This means that we cannot just pass IID_IDispatch with the object, even
+ * though it is in theory an IDispatch. However, while the standard stub
+ * constructor is not exported from rpcrt4, all of the vtbl methods are, and
+ * the type is public, so we *can* manually create it ourselves, bypassing the
+ * QueryInterface check.
+ *
+ * This relies on some rpcrt4 implementation details.
+ */
+static HRESULT dispinterface_create_stub(IUnknown *server, const GUID *iid, IRpcStubBuffer **stub)
+{
+    const CInterfaceStubVtbl *stub_vtbl = find_idispatch_stub_vtbl();
+    struct dispinterface_stub *object;
+    void *dispatch;
+    HRESULT hr;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    /* It's possible we can just assume that "server" is already the
+     * dispinterface type—we don't have tests for this—but since rpcrt4 queries
+     * (which we do have tests for) it makes sense for us to match that
+     * behaviour. */
+    if (FAILED(hr = IUnknown_QueryInterface(server, iid, &dispatch)))
+    {
+        ERR("Object does not support interface %s.\n", debugstr_guid(iid));
+        free(object);
+        return hr;
+    }
+
+    object->stub_vtbl.header = stub_vtbl->header;
+    object->stub_vtbl.Vtbl.QueryInterface             = CStdStubBuffer_QueryInterface;
+    object->stub_vtbl.Vtbl.AddRef                     = CStdStubBuffer_AddRef;
+    object->stub_vtbl.Vtbl.Release                    = dispinterface_stub_Release;
+    object->stub_vtbl.Vtbl.Connect                    = CStdStubBuffer_Connect;
+    object->stub_vtbl.Vtbl.Disconnect                 = CStdStubBuffer_Disconnect;
+    object->stub_vtbl.Vtbl.Invoke                     = CStdStubBuffer_Invoke;
+    object->stub_vtbl.Vtbl.IsIIDSupported             = CStdStubBuffer_IsIIDSupported;
+    object->stub_vtbl.Vtbl.CountRefs                  = CStdStubBuffer_CountRefs;
+    object->stub_vtbl.Vtbl.DebugServerQueryInterface  = CStdStubBuffer_DebugServerQueryInterface;
+    object->stub_vtbl.Vtbl.DebugServerRelease         = CStdStubBuffer_DebugServerRelease;
+    object->stub_buffer.lpVtbl = &object->stub_vtbl.Vtbl;
+    object->stub_buffer.RefCount = 1;
+    object->stub_buffer.pvServerObject = dispatch;
+    /* rpcrt4 will also fill pPSFactory, but it never uses it except in the
+     * Release method (which we reimplement). It's only to keep a reference to
+     * the module to implement NdrDllCanUnloadNow(). We use the default
+     * DllCanUnloadNow() from winecrt0, which always returns S_FALSE, so don't
+     * bother filling pPSFactory. */
+
+    TRACE("Created stub %p.\n", object);
+    *stub = (IRpcStubBuffer *)&object->stub_buffer.lpVtbl;
+    return S_OK;
+}
+
 static HRESULT WINAPI dispatch_typelib_ps_CreateStub(IPSFactoryBuffer *iface,
     REFIID iid, IUnknown *server, IRpcStubBuffer **stub)
 {
@@ -1022,10 +1132,10 @@ static HRESULT WINAPI dispatch_typelib_ps_CreateStub(IPSFactoryBuffer *iface,
     if (attr->typekind == TKIND_INTERFACE || (attr->wTypeFlags & TYPEFLAG_FDUAL))
         hr = CreateStubFromTypeInfo(typeinfo, iid, server, stub);
     else
-        hr = dispatch_create_stub(server, stub);
+        hr = dispinterface_create_stub(server, iid, stub);
 
     if (FAILED(hr))
-        ERR("Failed to create proxy, hr %#lx.\n", hr);
+        ERR("Failed to create stub, hr %#lx.\n", hr);
 
     ITypeInfo_ReleaseTypeAttr(typeinfo, attr);
     ITypeInfo_Release(typeinfo);
diff --git a/dlls/oleaut32/tests/tmarshal.c b/dlls/oleaut32/tests/tmarshal.c
index 53861870e78..5ffc103c7eb 100644
--- a/dlls/oleaut32/tests/tmarshal.c
+++ b/dlls/oleaut32/tests/tmarshal.c
@@ -17,6 +17,7 @@
  *
  */
 
+#include <stdbool.h>
 #include <math.h>
 
 #define COBJMACROS
@@ -394,6 +395,7 @@ struct disp_obj
 {
     ISomethingFromDispatch ISomethingFromDispatch_iface;
     LONG ref;
+    bool support_idispatch;
 };
 
 static inline struct disp_obj *impl_from_ISomethingFromDispatch(ISomethingFromDispatch *iface)
@@ -403,6 +405,11 @@ static inline struct disp_obj *impl_from_ISomethingFromDispatch(ISomethingFromDi
 
 static HRESULT WINAPI disp_obj_QueryInterface(ISomethingFromDispatch *iface, REFIID iid, void **out)
 {
+    struct disp_obj *obj = impl_from_ISomethingFromDispatch(iface);
+
+    if (!obj->support_idispatch)
+        ok(!IsEqualGUID(iid, &IID_IDispatch), "Expected no query for IDispatch.\n");
+
     if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IDispatch)
             || IsEqualGUID(iid, &IID_ISomethingFromDispatch)
             || IsEqualGUID(iid, &DIID_ItestIF4))
@@ -475,14 +482,20 @@ static const ISomethingFromDispatchVtbl disp_obj_vtbl =
     disp_obj_anotherfn,
 };
 
-static ISomethingFromDispatch *create_disp_obj(void)
+static ISomethingFromDispatch *create_disp_obj2(bool support_idispatch)
 {
     struct disp_obj *obj = CoTaskMemAlloc(sizeof(*obj));
     obj->ISomethingFromDispatch_iface.lpVtbl = &disp_obj_vtbl;
     obj->ref = 1;
+    obj->support_idispatch = support_idispatch;
     return &obj->ISomethingFromDispatch_iface;
 }
 
+static ISomethingFromDispatch *create_disp_obj(void)
+{
+    return create_disp_obj2(true);
+}
+
 struct coclass_obj
 {
     ICoclass1 ICoclass1_iface;
@@ -3710,7 +3723,7 @@ static void test_marshal_dispinterface(void)
 {
     static const LARGE_INTEGER zero;
 
-    ISomethingFromDispatch *disp_obj = create_disp_obj();
+    ISomethingFromDispatch *disp_obj = create_disp_obj2(false);
     ITypeInfo *typeinfo = NULL;
     IDispatch *proxy_disp;
     IStream *stream;
diff --git a/dlls/oleaut32/tests/vartest.c b/dlls/oleaut32/tests/vartest.c
index cdbb836b041..d31df67d084 100644
--- a/dlls/oleaut32/tests/vartest.c
+++ b/dlls/oleaut32/tests/vartest.c
@@ -3121,6 +3121,8 @@ static void test_VarAbs(void)
     VARABS(R4,-1,R4,1);
     VARABS(R8,1,R8,1);
     VARABS(R8,-1,R8,1);
+    VARABS(R4,1.40129846432481707e-45,R4,1.40129846432481707e-45);
+    VARABS(R8,4.94065645841246544e-324,R8,4.94065645841246544e-324);
     VARABS(DATE,1,DATE,1);
     VARABS(DATE,-1,DATE,1);
     V_VT(&v) = VT_CY;
@@ -3143,6 +3145,14 @@ static void test_VarAbs(void)
     hres = pVarAbs(&v,&vDst);
     ok(hres == S_OK && V_VT(&vDst) == VT_R8 && V_R8(&vDst) == 1.1,
        "VarAbs: expected 0x0,%d,%g, got 0x%lX,%d,%g\n", VT_R8, 1.1, hres, V_VT(&vDst), V_R8(&vDst));
+
+    V_VT(&v) = VT_BSTR;
+    V_BSTR(&v) = SysAllocString(L"30000");
+    memset(&vDst,0,sizeof(vDst));
+    hres = pVarAbs(&v,&vDst);
+    ok(hres == S_OK && V_VT(&vDst) == VT_R8 && V_R8(&vDst) == 30000.0,
+       "VarAbs: expected 0x0,%d,%g, got 0x%lX,%d,%g\n", VT_R8, 30000.0, hres, V_VT(&vDst), V_R8(&vDst));
+    SysFreeString(V_BSTR(&v));
 }
 
 static HRESULT (WINAPI *pVarNot)(LPVARIANT,LPVARIANT);
diff --git a/dlls/oleaut32/variant.c b/dlls/oleaut32/variant.c
index 885082cc659..8c2aa3b729d 100644
--- a/dlls/oleaut32/variant.c
+++ b/dlls/oleaut32/variant.c
@@ -4329,7 +4329,6 @@ VarOr_Exit:
  */
 HRESULT WINAPI VarAbs(LPVARIANT pVarIn, LPVARIANT pVarOut)
 {
-    VARIANT varIn;
     HRESULT hRet = S_OK;
     VARIANT temp;
 
@@ -4369,16 +4368,19 @@ HRESULT WINAPI VarAbs(LPVARIANT pVarIn, LPVARIANT pVarOut)
     case VT_INT:
     ABS_CASE(I4,I4_MIN);
     ABS_CASE(I8,I8_MIN);
-    ABS_CASE(R4,R4_MIN);
+    case VT_R4:
+        if (V_R4(pVarOut) < 0.0) V_R4(pVarOut) = -V_R4(pVarOut);
+        break;
     case VT_BSTR:
-        hRet = VarR8FromStr(V_BSTR(pVarIn), LOCALE_USER_DEFAULT, 0, &V_R8(&varIn));
+        hRet = VarR8FromStr(V_BSTR(pVarIn), LOCALE_USER_DEFAULT, 0, &V_R8(pVarOut));
         if (FAILED(hRet))
             break;
         V_VT(pVarOut) = VT_R8;
-        pVarIn = &varIn;
         /* Fall through ... */
     case VT_DATE:
-    ABS_CASE(R8,R8_MIN);
+    case VT_R8:
+        if (V_R8(pVarOut) < 0.0) V_R8(pVarOut) = -V_R8(pVarOut);
+        break;
     case VT_CY:
         hRet = VarCyAbs(V_CY(pVarIn), & V_CY(pVarOut));
         break;
diff --git a/dlls/oledb32/errorinfo.c b/dlls/oledb32/errorinfo.c
index b6e0d10e8e0..6857caeb368 100644
--- a/dlls/oledb32/errorinfo.c
+++ b/dlls/oledb32/errorinfo.c
@@ -120,7 +120,7 @@ static ULONG WINAPI errorrecords_Release(IErrorInfo* iface)
                 IUnknown_Release(This->records[i].custom_error);
 
             for (j = 0; j < dispparams->cArgs && dispparams->rgvarg; j++)
-                VariantClear(&dispparams->rgvarg[i]);
+                VariantClear(&dispparams->rgvarg[j]);
             CoTaskMemFree(dispparams->rgvarg);
             CoTaskMemFree(dispparams->rgdispidNamedArgs);
         }
diff --git a/dlls/oledb32/tests/database.c b/dlls/oledb32/tests/database.c
index 5d99aef7a89..26e3ebf2186 100644
--- a/dlls/oledb32/tests/database.c
+++ b/dlls/oledb32/tests/database.c
@@ -1043,13 +1043,9 @@ static void test_odbc_provider(void)
         ok(propidlist.cPropertyIDs == 14, "got %ld\n", propinfoset->cPropertyInfos);
 
         for (i = 0; i < propidlist.cPropertyIDs; i++)
-        {
             ok(properties[i] == propidlist.rgPropertyIDs[i], "%ld, got %ld\n", i,
                     propidlist.rgPropertyIDs[i]);
 
-            propidlist.rgPropertyIDs[i] = propinfoset->rgPropertyInfos[i].dwPropertyID;
-        }
-
         CoTaskMemFree(propidlist.rgPropertyIDs);
         CoTaskMemFree(propset);
     }
diff --git a/dlls/oledlg/oledlg_main.c b/dlls/oledlg/oledlg_main.c
index 33e62f64935..c568610b0c9 100644
--- a/dlls/oledlg/oledlg_main.c
+++ b/dlls/oledlg/oledlg_main.c
@@ -207,7 +207,7 @@ BOOL WINAPI OleUIAddVerbMenuW(IOleObject *object, LPCWSTR shorttype,
         args[1] = (DWORD_PTR)objecttype;
 
         FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-            resstrW, 0, 0, (WCHAR*)&str, 0, (__ms_va_list*)args);
+            resstrW, 0, 0, (WCHAR*)&str, 0, (va_list *)args);
 
         RemoveMenu(hMenu, uPos, MF_BYPOSITION);
         InsertMenuW(hMenu, uPos, MF_BYPOSITION|MF_STRING, idmin, str);
@@ -247,7 +247,7 @@ BOOL WINAPI OleUIAddVerbMenuW(IOleObject *object, LPCWSTR shorttype,
 
     args[0] = (DWORD_PTR)objecttype;
     FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-        resstrW, 0, 0, (WCHAR*)&str, 0, (__ms_va_list*)args);
+        resstrW, 0, 0, (WCHAR*)&str, 0, (va_list *)args);
 
     InsertMenuW(hMenu, uPos, MF_BYPOSITION|MF_POPUP|MF_STRING, (UINT_PTR)submenu, str);
     HeapFree(GetProcessHeap(), 0, str);
diff --git a/dlls/opengl32/tests/opengl.c b/dlls/opengl32/tests/opengl.c
index 42c2626a2c2..6979e00792e 100644
--- a/dlls/opengl32/tests/opengl.c
+++ b/dlls/opengl32/tests/opengl.c
@@ -1899,11 +1899,16 @@ static void test_wglChoosePixelFormatARB(HDC hdc)
 
 static void test_copy_context(HDC hdc)
 {
-    HGLRC ctx, ctx2;
+    HGLRC ctx, ctx2, old_ctx;
     BOOL ret;
 
+    old_ctx = wglGetCurrentContext();
+    ok(!!old_ctx, "wglGetCurrentContext failed, last error %#lx.\n", GetLastError());
+
     ctx = wglCreateContext(hdc);
     ok(!!ctx, "Failed to create GL context, last error %#lx.\n", GetLastError());
+    ret = wglMakeCurrent(hdc, ctx);
+    ok(ret, "wglMakeCurrent failed, last error %#lx.\n", GetLastError());
     ctx2 = wglCreateContext(hdc);
     ok(!!ctx2, "Failed to create GL context, last error %#lx.\n", GetLastError());
 
@@ -1911,10 +1916,15 @@ static void test_copy_context(HDC hdc)
     todo_wine
     ok(ret, "Failed to copy GL context, last error %#lx.\n", GetLastError());
 
+    ret = wglMakeCurrent(NULL, NULL);
+    ok(ret, "wglMakeCurrent failed, last error %#lx.\n", GetLastError());
     ret = wglDeleteContext(ctx2);
     ok(ret, "Failed to delete GL context, last error %#lx.\n", GetLastError());
     ret = wglDeleteContext(ctx);
     ok(ret, "Failed to delete GL context, last error %#lx.\n", GetLastError());
+
+    ret = wglMakeCurrent(hdc, old_ctx);
+    ok(ret, "wglMakeCurrent failed, last error %#lx.\n", GetLastError());
 }
 
 START_TEST(opengl)
diff --git a/dlls/propsys/propsys.spec b/dlls/propsys/propsys.spec
index 7391cf4aaa2..cf7a4c299f4 100644
--- a/dlls/propsys/propsys.spec
+++ b/dlls/propsys/propsys.spec
@@ -41,7 +41,7 @@
 @ stub InitPropVariantFromResource
 @ stub InitPropVariantFromStrRet
 @ stub InitPropVariantFromStringAsVector
-@ stub InitPropVariantFromStringVector
+@ stdcall InitPropVariantFromStringVector(ptr long ptr)
 @ stub InitPropVariantFromUInt16Vector
 @ stub InitPropVariantFromUInt32Vector
 @ stub InitPropVariantFromUInt64Vector
diff --git a/dlls/propsys/propvar.c b/dlls/propsys/propvar.c
index cd92912fde5..86670a51adf 100644
--- a/dlls/propsys/propvar.c
+++ b/dlls/propsys/propvar.c
@@ -657,6 +657,38 @@ HRESULT WINAPI InitPropVariantFromCLSID(REFCLSID clsid, PROPVARIANT *ppropvar)
     return S_OK;
 }
 
+HRESULT WINAPI InitPropVariantFromStringVector(PCWSTR *strs, ULONG count, PROPVARIANT *ppropvar)
+{
+    unsigned int i;
+
+    TRACE("(%p %lu %p)\n", strs, count, ppropvar);
+
+    ppropvar->calpwstr.pElems = CoTaskMemAlloc(count * sizeof(*ppropvar->calpwstr.pElems));
+    if(!ppropvar->calpwstr.pElems)
+        return E_OUTOFMEMORY;
+
+    ppropvar->vt = VT_LPWSTR | VT_VECTOR;
+    ppropvar->calpwstr.cElems = 0;
+    if (count)
+        memset(ppropvar->calpwstr.pElems, 0, count * sizeof(*ppropvar->calpwstr.pElems));
+
+    for (i = 0; i < count; ++i)
+    {
+        if (strs[i])
+        {
+            if (!(ppropvar->calpwstr.pElems[i] = CoTaskMemAlloc((wcslen(strs[i]) + 1)*sizeof(**strs))))
+            {
+                PropVariantClear(ppropvar);
+                return E_OUTOFMEMORY;
+            }
+        }
+        wcscpy(ppropvar->calpwstr.pElems[i], strs[i]);
+        ppropvar->calpwstr.cElems++;
+    }
+
+    return S_OK;
+}
+
 HRESULT WINAPI InitVariantFromBuffer(const VOID *pv, UINT cb, VARIANT *pvar)
 {
     SAFEARRAY *arr;
diff --git a/dlls/propsys/tests/propsys.c b/dlls/propsys/tests/propsys.c
index 47a7930a18b..fb9decd7ab0 100644
--- a/dlls/propsys/tests/propsys.c
+++ b/dlls/propsys/tests/propsys.c
@@ -1419,6 +1419,35 @@ static void test_InitPropVariantFromCLSID(void)
     PropVariantClear(&propvar);
 }
 
+static void test_InitPropVariantFromStringVector(void)
+{
+    static const WCHAR *strs[2] = { L"abc", L"def" };
+    PROPVARIANT propvar;
+    HRESULT hr;
+
+    memset(&propvar, 0, sizeof(propvar));
+    propvar.vt = VT_I4;
+    propvar.lVal = 15;
+
+    hr = InitPropVariantFromStringVector(NULL, 0, &propvar);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(propvar.vt == (VT_LPWSTR|VT_VECTOR), "Unexpected type %#x.\n", propvar.vt);
+    ok(!propvar.calpwstr.cElems, "Unexpected number of elements.\n");
+    ok(!!propvar.calpwstr.pElems, "Unexpected vector pointer.\n");
+    PropVariantClear(&propvar);
+
+    hr = InitPropVariantFromStringVector(strs, 2, &propvar);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(propvar.vt == (VT_LPWSTR|VT_VECTOR), "Unexpected type %#x.\n", propvar.vt);
+    ok(propvar.calpwstr.cElems == 2, "Unexpected number of elements.\n");
+    ok(!!propvar.calpwstr.pElems, "Unexpected vector pointer.\n");
+    ok(propvar.calpwstr.pElems[0] != strs[0], "Unexpected string pointer.\n");
+    ok(!wcscmp(propvar.calpwstr.pElems[0], strs[0]), "Unexpected string %s.\n", debugstr_w(propvar.calpwstr.pElems[0]));
+    ok(propvar.calpwstr.pElems[1] != strs[1], "Unexpected string pointer.\n");
+    ok(!wcscmp(propvar.calpwstr.pElems[1], strs[1]), "Unexpected string %s.\n", debugstr_w(propvar.calpwstr.pElems[1]));
+    PropVariantClear(&propvar);
+}
+
 static void test_PropVariantToDouble(void)
 {
     PROPVARIANT propvar;
@@ -2252,11 +2281,15 @@ static void test_VariantToStringWithDefault(void)
 
 START_TEST(propsys)
 {
+    test_InitPropVariantFromGUIDAsString();
+    test_InitPropVariantFromBuffer();
+    test_InitPropVariantFromCLSID();
+    test_InitPropVariantFromStringVector();
+    test_InitVariantFromFileTime();
+
     test_PSStringFromPropertyKey();
     test_PSPropertyKeyFromString();
     test_PSRefreshPropertySchema();
-    test_InitPropVariantFromGUIDAsString();
-    test_InitPropVariantFromBuffer();
     test_PropVariantToGUID();
     test_PropVariantToStringAlloc();
     test_PropVariantCompareEx();
@@ -2264,7 +2297,6 @@ START_TEST(propsys)
     test_PropVariantChangeType_LPWSTR();
     test_PropVariantToBoolean();
     test_PropVariantToStringWithDefault();
-    test_InitPropVariantFromCLSID();
     test_PropVariantToDouble();
     test_PropVariantToString();
     test_PropVariantToBuffer();
@@ -2273,6 +2305,5 @@ START_TEST(propsys)
     test_PSCreateMemoryPropertyStore();
     test_propertystore();
     test_PSCreatePropertyStoreFromObject();
-    test_InitVariantFromFileTime();
     test_VariantToStringWithDefault();
 }
diff --git a/dlls/psapi/tests/psapi_main.c b/dlls/psapi/tests/psapi_main.c
index 185a4062092..227fc52c2ad 100644
--- a/dlls/psapi/tests/psapi_main.c
+++ b/dlls/psapi/tests/psapi_main.c
@@ -43,6 +43,7 @@ static BOOL  (WINAPI *pWow64RevertWow64FsRedirection)(void *);
 static BOOL  (WINAPI *pQueryWorkingSetEx)(HANDLE, PVOID, DWORD);
 
 static BOOL wow64;
+static char** main_argv;
 
 static BOOL init_func_ptrs(void)
 {
@@ -140,36 +141,384 @@ static void test_EnumProcessModules(void)
     {
         MODULEINFO info;
         char name[40];
+        HMODULE hmods[3];
 
         strcpy(buffer, "C:\\windows\\syswow64\\notepad.exe");
         ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        if (ret)
+        {
+            ret = WaitForInputIdle(pi.hProcess, 5000);
+            ok(!ret, "wait timed out\n");
+
+            SetLastError(0xdeadbeef);
+            hmods[0] = NULL;
+            ret = EnumProcessModules(pi.hProcess, hmods, sizeof(hmods), &cbNeeded);
+            ok(ret == 1, "got %ld, error %lu\n", ret, GetLastError());
+            ok(cbNeeded >= sizeof(HMODULE), "expected at least one module\n");
+            ok(!!hmods[0], "expected non-NULL module\n");
+            ok(cbNeeded % sizeof(hmods[0]) == 0, "got %lu\n", cbNeeded);
+
+            ret = GetModuleBaseNameA(pi.hProcess, hmods[0], name, sizeof(name));
+            ok(ret, "got error %lu\n", GetLastError());
+            ok(!strcmp(name, "notepad.exe"), "got %s\n", name);
+
+            ret = GetModuleFileNameExA(pi.hProcess, hmods[0], name, sizeof(name));
+            ok(ret, "got error %lu\n", GetLastError());
+            ok(!strcmp(name, buffer), "got %s\n", name);
+
+            ret = GetModuleInformation(pi.hProcess, hmods[0], &info, sizeof(info));
+            ok(ret, "got error %lu\n", GetLastError());
+            ok(info.lpBaseOfDll == hmods[0], "expected %p, got %p\n", hmods[0], info.lpBaseOfDll);
+            ok(info.SizeOfImage, "image size was 0\n");
+            ok(info.EntryPoint >= info.lpBaseOfDll, "got entry point %p\n", info.EntryPoint);
+
+            /* "old" Wine wow64 will only return main DLL; while windows & multi-arch Wine Wow64 setup
+             * will return main module, ntdll.dll and one of the wow64*.dll.
+             */
+            todo_wine_if(cbNeeded == sizeof(HMODULE))
+            ok(cbNeeded >= 3 * sizeof(HMODULE), "Wrong count of DLLs\n");
+            if (cbNeeded >= 3 * sizeof(HMODULE))
+            {
+                ret = GetModuleBaseNameA(pi.hProcess, hmods[2], name, sizeof(name));
+                ok(ret, "got error %lu\n", GetLastError());
+                ok(strstr(CharLowerA(name), "wow64") != NULL, "third DLL in wow64 should be one of wow*.dll (%s)\n", name);
+            }
+            TerminateProcess(pi.hProcess, 0);
+        }
+        else
+        {
+            if (GetLastError() == ERROR_FILE_NOT_FOUND)
+                skip("Skip wow64 test on non compatible platform\n");
+            else
+                ok(ret, "CreateProcess failed: %lu\n", GetLastError());
+        }
+    }
+    else if (wow64)
+    {
+        pWow64DisableWow64FsRedirection(&cookie);
+        ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        pWow64RevertWow64FsRedirection(cookie);
         ok(ret, "CreateProcess failed: %lu\n", GetLastError());
 
         ret = WaitForInputIdle(pi.hProcess, 5000);
         ok(!ret, "wait timed out\n");
 
         SetLastError(0xdeadbeef);
-        hMod = NULL;
         ret = EnumProcessModules(pi.hProcess, &hMod, sizeof(HMODULE), &cbNeeded);
-        ok(ret == 1, "got %ld, error %lu\n", ret, GetLastError());
-        ok(!!hMod, "expected non-NULL module\n");
-        ok(cbNeeded % sizeof(hMod) == 0, "got %lu\n", cbNeeded);
+        ok(!ret, "got %ld\n", ret);
+        ok(GetLastError() == ERROR_PARTIAL_COPY, "got error %lu\n", GetLastError());
 
-        ret = GetModuleBaseNameA(pi.hProcess, hMod, name, sizeof(name));
-        ok(ret, "got error %lu\n", GetLastError());
-        ok(!strcmp(name, "notepad.exe"), "got %s\n", name);
+        TerminateProcess(pi.hProcess, 0);
+    }
+}
 
-        ret = GetModuleFileNameExA(pi.hProcess, hMod, name, sizeof(name));
-        ok(ret, "got error %lu\n", GetLastError());
-        ok(!strcmp(name, buffer), "got %s\n", name);
+struct moduleex_snapshot
+{
+    unsigned list;
+    DWORD num_modules;
+    HMODULE modules[128];
+};
+
+static BOOL test_EnumProcessModulesEx_snapshot(HANDLE proc, struct moduleex_snapshot* mxsnap,
+                                               unsigned numsnap)
+{
+    DWORD needed;
+    char buffer[80];
+    MODULEINFO info;
+    int i, j;
+    BOOL ret;
+
+    for (i = 0; i < numsnap; i++)
+    {
+        winetest_push_context("%d", mxsnap[i].list);
+        SetLastError(0xdeadbeef);
+        mxsnap[i].modules[0] = (void *)0xdeadbeef;
+        ret = EnumProcessModulesEx(proc, mxsnap[i].modules, sizeof(mxsnap[i].modules), &needed, mxsnap[i].list);
+        ok(ret, "didn't succeed %lu\n", GetLastError());
+        ok(needed % sizeof(HMODULE) == 0, "not a multiple of sizeof(HMODULE) cbNeeded=%ld\n", needed);
+        mxsnap[i].num_modules = min(needed, sizeof(mxsnap[i].modules)) / sizeof(HMODULE);
+        for (j = 0; j < mxsnap[i].num_modules; j++)
+        {
+            ret = GetModuleBaseNameA(proc, mxsnap[i].modules[j], buffer, sizeof(buffer));
+            ok(ret, "GetModuleBaseName failed: %lu (%u/%lu=%p)\n", GetLastError(), j, mxsnap[i].num_modules, mxsnap[i].modules[j]);
+            ret = GetModuleFileNameExA(proc, mxsnap[i].modules[j], buffer, sizeof(buffer));
+            ok(ret, "GetModuleFileNameEx failed: %lu (%u/%lu=%p)\n", GetLastError(), j, mxsnap[i].num_modules, mxsnap[i].modules[j]);
+            memset(&info, 0, sizeof(info));
+            ret = GetModuleInformation(proc, mxsnap[i].modules[j], &info, sizeof(info));
+            ok(ret, "GetModuleInformation failed: %lu\n", GetLastError());
+            ok(info.lpBaseOfDll == mxsnap[i].modules[j], "expected %p, got %p\n", mxsnap[i].modules[j], info.lpBaseOfDll);
+            ok(info.SizeOfImage, "image size was 0\n");
+            /* info.EntryPoint to be checked */
+        }
+        winetest_pop_context();
+    }
+    return ret;
+}
+
+static BOOL snapshot_is_empty(const struct moduleex_snapshot* snap)
+{
+    return snap->num_modules == 0;
+}
+
+static BOOL snapshot_contains(const struct moduleex_snapshot* snap, HMODULE mod)
+{
+    int i;
 
-        ret = GetModuleInformation(pi.hProcess, hMod, &info, sizeof(info));
+    for (i = 0; i < snap->num_modules; i++)
+        if (snap->modules[i] == mod) return TRUE;
+    return FALSE;
+}
+
+/* It happens (experienced on Windows) that the considered process still loads modules,
+ * meaning that the number of loaded modules can increase between consecutive calls to EnumProcessModulesEx.
+ * In order to cope with this, we're testing for modules list being included into the next one (instead of
+ * equality)
+ */
+static BOOL snapshot_is_subset(const struct moduleex_snapshot* subset, const struct moduleex_snapshot* superset)
+{
+    int i;
+
+    for (i = 0; i < subset->num_modules; i++)
+        if (!snapshot_contains(superset, subset->modules[i])) return FALSE;
+    return TRUE;
+}
+
+static BOOL snapshot_is_equal(const struct moduleex_snapshot* seta, const struct moduleex_snapshot* setb)
+{
+    return snapshot_is_subset(seta, setb) && seta->num_modules == setb->num_modules;
+}
+
+static BOOL snapshot_are_disjoint(const struct moduleex_snapshot* seta, const struct moduleex_snapshot* setb, unsigned start)
+{
+    int i, j;
+    for (i = start; i < seta->num_modules; i++)
+        for (j = start; j < setb->num_modules; j++)
+            if (seta->modules[i] == setb->modules[j]) return FALSE;
+    return TRUE;
+}
+
+static void snapshot_check_first_main_module(const struct moduleex_snapshot* snap, HANDLE proc,
+                                             const char* filename)
+{
+    char buffer[80];
+    MODULEINFO info;
+    const char* modname;
+    BOOL ret;
+
+    if (!(modname = strrchr(filename, '\\'))) modname = filename; else modname++;
+    winetest_push_context("%d", snap->list);
+    ret = GetModuleBaseNameA(proc, snap->modules[0], buffer, sizeof(buffer));
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(!strcasecmp(buffer, modname), "expecting %s but got %s\n", modname, buffer);
+    ret = GetModuleFileNameExA(proc, snap->modules[0], buffer, sizeof(buffer));
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(!strcasecmp(filename, buffer), "expecting %s but got %s\n", filename, buffer);
+
+    ret = GetModuleInformation(proc, snap->modules[0], &info, sizeof(info));
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(info.lpBaseOfDll == snap->modules[0], "expected %p, got %p\n", snap->modules[0], info.lpBaseOfDll);
+    ok(info.SizeOfImage, "image size was 0\n");
+    ok(info.EntryPoint >= info.lpBaseOfDll, "got entry point %p\n", info.EntryPoint);
+    winetest_pop_context();
+}
+
+static unsigned int snapshot_count_in_dir(const struct moduleex_snapshot* snap, HANDLE proc, const char* dirname)
+{
+    unsigned int count = 0;
+    char buffer[128];
+    size_t dirname_len = strlen(dirname);
+    BOOL ret;
+    int i;
+
+    for (i = 0; i < snap->num_modules; i++)
+    {
+        ret = GetModuleFileNameExA(proc, snap->modules[i], buffer, sizeof(buffer));
         ok(ret, "got error %lu\n", GetLastError());
-        ok(info.lpBaseOfDll == hMod, "expected %p, got %p\n", hMod, info.lpBaseOfDll);
-        ok(info.SizeOfImage, "image size was 0\n");
-        ok(info.EntryPoint >= info.lpBaseOfDll, "got entry point %p\n", info.EntryPoint);
+        if (!strncasecmp(buffer, dirname, dirname_len)) count++;
+    }
+    return count;
+}
+
+static void test_EnumProcessModulesEx(void)
+{
+    char buffer[200] = "C:\\windows\\system32\\notepad.exe";
+    PROCESS_INFORMATION pi = {0};
+    STARTUPINFOA si = {0};
+    void *cookie;
+    HMODULE hMod;
+    DWORD ret, cbNeeded = 0xdeadbeef;
+    struct moduleex_snapshot snap[4] = {{LIST_MODULES_32BIT}, {LIST_MODULES_64BIT}, {LIST_MODULES_DEFAULT}, {LIST_MODULES_ALL}};
+    int i;
+
+    SetLastError(0xdeadbeef);
+    EnumProcessModulesEx(NULL, NULL, 0, &cbNeeded, LIST_MODULES_ALL);
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "expected error=ERROR_INVALID_HANDLE but got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    EnumProcessModulesEx(hpQI, NULL, 0, &cbNeeded, LIST_MODULES_ALL);
+    ok(GetLastError() == ERROR_ACCESS_DENIED, "expected error=ERROR_ACCESS_DENIED but got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hMod = (void *)0xdeadbeef;
+    ret = EnumProcessModulesEx(hpQI, &hMod, sizeof(HMODULE), NULL, LIST_MODULES_ALL);
+    ok(!ret, "succeeded\n");
+    ok(GetLastError() == ERROR_ACCESS_DENIED, "expected error=ERROR_ACCESS_DENIED but got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hMod = (void *)0xdeadbeef;
+    ret = EnumProcessModulesEx(hpQV, &hMod, sizeof(HMODULE), NULL, LIST_MODULES_ALL);
+    ok(!ret, "succeeded\n");
+    ok(GetLastError() == ERROR_NOACCESS, "expected error=ERROR_NOACCESS but got %ld\n", GetLastError());
+    ok(hMod == GetModuleHandleA(NULL),
+       "hMod=%p GetModuleHandleA(NULL)=%p\n", hMod, GetModuleHandleA(NULL));
+
+    SetLastError(0xdeadbeef);
+    ret = EnumProcessModulesEx(hpQV, NULL, 0, &cbNeeded, LIST_MODULES_ALL);
+    ok(ret == 1, "failed with %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = EnumProcessModulesEx(hpQV, NULL, sizeof(HMODULE), &cbNeeded, LIST_MODULES_ALL);
+    ok(!ret, "succeeded\n");
+    ok(GetLastError() == ERROR_NOACCESS, "expected error=ERROR_NOACCESS but got %ld\n", GetLastError());
+
+    winetest_push_context("self");
+    if (sizeof(void *) == 8)
+    {
+        test_EnumProcessModulesEx_snapshot(hpQV, snap, ARRAY_SIZE(snap));
+        ok(snapshot_is_empty(&snap[0]), "didn't expect 32bit module\n");
+        ok(snapshot_is_equal(&snap[1], &snap[2]), "mismatch in modules count\n");
+        ok(snapshot_is_equal(&snap[2], &snap[3]), "mismatch in modules count\n");
+        snapshot_check_first_main_module(&snap[1], hpQV, main_argv[0]);
+        snapshot_check_first_main_module(&snap[2], hpQV, main_argv[0]);
+        snapshot_check_first_main_module(&snap[3], hpQV, main_argv[0]);
+
+        /* in fact, this error is only returned when (list & 3 == 0), otherwise the corresponding
+         * list is returned without errors
+         */
+        SetLastError(0xdeadbeef);
+        ret = EnumProcessModulesEx(hpQV, &hMod, sizeof(HMODULE), &cbNeeded, 0x400);
+        ok(!ret, "succeeded\n");
+        ok(GetLastError() == ERROR_INVALID_PARAMETER, "expected error=ERROR_INVALID_PARAMETER but got %ld\n", GetLastError());
+    }
+    else if (wow64)
+    {
+        test_EnumProcessModulesEx_snapshot(hpQV, snap, ARRAY_SIZE(snap));
+        ok(snapshot_is_equal(&snap[0], &snap[1]), "mismatch in modules count\n");
+        ok(snapshot_is_equal(&snap[1], &snap[2]), "mismatch in modules count\n");
+        ok(snapshot_is_equal(&snap[2], &snap[3]), "mismatch in modules count\n");
+        snapshot_check_first_main_module(&snap[0], hpQV, main_argv[0]);
+        snapshot_check_first_main_module(&snap[1], hpQV, main_argv[0]);
+        snapshot_check_first_main_module(&snap[2], hpQV, main_argv[0]);
+        snapshot_check_first_main_module(&snap[3], hpQV, main_argv[0]);
+    }
+    winetest_pop_context();
+
+    ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+    ok(ret, "CreateProcess failed: %lu\n", GetLastError());
+
+    ret = WaitForInputIdle(pi.hProcess, 5000);
+    ok(!ret, "wait timed out\n");
+
+    if (sizeof(void *) == 8)
+    {
+        winetest_push_context("pcs-6464");
+        test_EnumProcessModulesEx_snapshot(pi.hProcess, snap, ARRAY_SIZE(snap));
+        ok(snapshot_is_empty(&snap[0]), "didn't expect 32bit module\n");
+        ok(snapshot_is_subset(&snap[1], &snap[2]), "64bit and default module lists should match\n");
+        ok(snapshot_is_subset(&snap[2], &snap[3]), "default and all module lists should match\n");
+        snapshot_check_first_main_module(&snap[1], pi.hProcess, buffer);
+        snapshot_check_first_main_module(&snap[2], pi.hProcess, buffer);
+        snapshot_check_first_main_module(&snap[3], pi.hProcess, buffer);
+        winetest_pop_context();
+
+        /* in fact, this error is only returned when (list & 3 == 0), otherwise the corresponding
+         * list is returned without errors
+         */
+        SetLastError(0xdeadbeef);
+        ret = EnumProcessModulesEx(hpQV, &hMod, sizeof(HMODULE), &cbNeeded, 0x400);
+        ok(!ret, "succeeded\n");
+        ok(GetLastError() == ERROR_INVALID_PARAMETER, "expected error=ERROR_INVALID_PARAMETER but got %ld\n", GetLastError());
+    }
+    else if (wow64)
+    {
+        winetest_push_context("pcs-3232");
+        test_EnumProcessModulesEx_snapshot(pi.hProcess, snap, ARRAY_SIZE(snap));
+        /* some windows version return 64bit modules, others don't... */
+        /* ok(snapshot_is_empty(&snap[1]), "didn't expect 64bit module\n"); */
+        ok(snapshot_is_subset(&snap[1], &snap[3]), "64 and all module lists should match\n");
+
+        ok(snapshot_is_subset(&snap[0], &snap[2]), "32bit and default module lists should match\n");
+        ok(snapshot_is_subset(&snap[2], &snap[3]), "default and all module lists should match\n");
+        snapshot_check_first_main_module(&snap[0], pi.hProcess, "c:\\windows\\syswow64\\notepad.exe");
+        snapshot_check_first_main_module(&snap[2], pi.hProcess, "c:\\windows\\syswow64\\notepad.exe");
+        snapshot_check_first_main_module(&snap[3], pi.hProcess, "c:\\windows\\syswow64\\notepad.exe");
+        winetest_pop_context();
+    }
+
+    TerminateProcess(pi.hProcess, 0);
+
+    if (sizeof(void *) == 8)
+    {
+        unsigned int count;
+
+        strcpy(buffer, "C:\\windows\\syswow64\\notepad.exe");
+        ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        if (ret)
+        {
+            ret = WaitForInputIdle(pi.hProcess, 5000);
+            ok(!ret, "wait timed out\n");
+
+            winetest_push_context("pcs-6432");
+            test_EnumProcessModulesEx_snapshot(pi.hProcess, snap, ARRAY_SIZE(snap));
+            ok(!snapshot_is_empty(&snap[0]), "expecting 32bit modules\n");
+            /* FIXME: this tests fails on Wine "old" wow configuration, but succceeds in "multi-arch" and Windows */
+            todo_wine_if(snapshot_is_empty(&snap[1]))
+            ok(!snapshot_is_empty(&snap[1]), "expecting 64bit modules\n");
+            ok(snapshot_is_subset(&snap[1], &snap[2]), "64bit and default module lists should match\n");
+            ok(snapshot_are_disjoint(&snap[0], &snap[1], 0), "32bit and 64bit list should be disjoint\n");
+            /* Main module (even 32bit) is present in both 32bit (makes sense) but also default
+             * (even if all the other modules are 64bit)
+             */
+            ok(snapshot_are_disjoint(&snap[0], &snap[2], 1), "32bit and default list should be disjoint\n");
+            ok(snapshot_is_subset(&snap[0], &snap[3]), "32bit and all module lists should match\n");
+            ok(snapshot_is_subset(&snap[1], &snap[3]), "64bit and all module lists should match\n");
+            ok(snapshot_is_subset(&snap[2], &snap[3]), "default and all module list should match\n");
+            snapshot_check_first_main_module(&snap[0], pi.hProcess, buffer);
+            ok(!snapshot_contains(&snap[1], snap[0].modules[0]), "main module shouldn't be present in 64bit list\n");
+            snapshot_check_first_main_module(&snap[2], pi.hProcess, buffer);
+            snapshot_check_first_main_module(&snap[3], pi.hProcess, buffer);
+
+            ret = GetSystemWow64DirectoryA(buffer, sizeof(buffer));
+            ok(ret, "GetSystemWow64DirectoryA failed: %lu\n", GetLastError());
+            count = snapshot_count_in_dir(snap, pi.hProcess, buffer);
+            todo_wine
+            ok(count <= 1, "Wrong count %u in %s\n", count, buffer); /* notepad can be from system wow64 */
+            ret = GetSystemDirectoryA(buffer, sizeof(buffer));
+            ok(ret, "GetSystemDirectoryA failed: %lu\n", GetLastError());
+            count = snapshot_count_in_dir(snap, pi.hProcess, buffer);
+            todo_wine
+            ok(count > 2, "Wrong count %u in %s\n", count, buffer);
+
+            /* in fact, this error is only returned when (list & 3 == 0), otherwise the corresponding
+             * list is returned without errors.
+             */
+            SetLastError(0xdeadbeef);
+            ret = EnumProcessModulesEx(hpQV, &hMod, sizeof(HMODULE), &cbNeeded, 0x400);
+            ok(!ret, "succeeded\n");
+            ok(GetLastError() == ERROR_INVALID_PARAMETER, "expected error=ERROR_INVALID_PARAMETER but got %ld\n", GetLastError());
+
+            winetest_pop_context();
+
+            TerminateProcess(pi.hProcess, 0);
+        }
+        else
+        {
+            if (GetLastError() == ERROR_FILE_NOT_FOUND)
+                skip("Skip wow64 test on non compatible platform\n");
+            else
+                ok(ret, "CreateProcess failed: %lu\n", GetLastError());
+        }
 
-        TerminateProcess(pi.hProcess, 0);
     }
     else if (wow64)
     {
@@ -181,11 +530,15 @@ static void test_EnumProcessModules(void)
         ret = WaitForInputIdle(pi.hProcess, 5000);
         ok(!ret, "wait timed out\n");
 
-        SetLastError(0xdeadbeef);
-        ret = EnumProcessModules(pi.hProcess, &hMod, sizeof(HMODULE), &cbNeeded);
-        ok(!ret, "got %ld\n", ret);
-        todo_wine
-        ok(GetLastError() == ERROR_PARTIAL_COPY, "got error %lu\n", GetLastError());
+        winetest_push_context("pcs-3264");
+        for (i = 0; i < ARRAY_SIZE(snap); i++)
+        {
+            SetLastError(0xdeadbeef);
+            ret = EnumProcessModulesEx(pi.hProcess, &hMod, sizeof(HMODULE), &cbNeeded, snap[i].list);
+            ok(!ret, "succeeded\n");
+            ok(GetLastError() == ERROR_PARTIAL_COPY, "expected error=ERROR_PARTIAL_COPY but got %ld\n", GetLastError());
+        }
+        winetest_pop_context();
 
         TerminateProcess(pi.hProcess, 0);
     }
@@ -854,6 +1207,7 @@ START_TEST(psapi_main)
 {
     DWORD pid = GetCurrentProcessId();
 
+    winetest_get_mainargs(&main_argv);
     init_func_ptrs();
 
     if (pIsWow64Process)
@@ -870,6 +1224,7 @@ START_TEST(psapi_main)
 
     test_EnumProcesses();
     test_EnumProcessModules();
+    test_EnumProcessModulesEx();
     test_GetModuleInformation();
     test_GetPerformanceInfo();
     test_GetProcessMemoryInfo();
diff --git a/dlls/riched20/editor.c b/dlls/riched20/editor.c
index 57601745ab2..704546f1e95 100644
--- a/dlls/riched20/editor.c
+++ b/dlls/riched20/editor.c
@@ -1609,9 +1609,17 @@ static LRESULT ME_StreamIn(ME_TextEditor *editor, DWORD format, EDITSTREAM *stre
   {
     style = editor->pBuffer->pDefaultStyle;
     ME_AddRefStyle(style);
-    set_selection_cursors(editor, 0, 0);
-    ME_InternalDeleteText(editor, &editor->pCursors[1],
-                          ME_GetTextLength(editor), FALSE);
+    if (format & SFF_SELECTION)
+    {
+      ME_GetSelection(editor, &selStart, &selEnd);
+      ME_InternalDeleteText(editor, selStart, to - from, FALSE);
+    }
+    else
+    {
+      set_selection_cursors(editor, 0, 0);
+      ME_InternalDeleteText(editor, &editor->pCursors[1],
+                            ME_GetTextLength(editor), FALSE);
+    }
     from = to = 0;
     ME_ClearTempStyle(editor);
     editor_set_default_para_fmt( editor, &editor->pCursors[0].para->fmt );
@@ -4099,8 +4107,8 @@ LRESULT editor_handle_message( ME_TextEditor *editor, UINT msg, WPARAM wParam,
     return 0;
   case WM_IME_STARTCOMPOSITION:
   {
-    editor->imeStartIndex=ME_GetCursorOfs(&editor->pCursors[0]);
     ME_DeleteSelection(editor);
+    editor->imeStartIndex = ME_GetCursorOfs(&editor->pCursors[0]);
     ME_CommitUndo(editor);
     ME_UpdateRepaint(editor, FALSE);
     return 0;
diff --git a/dlls/riched20/tests/editor.c b/dlls/riched20/tests/editor.c
index 07af9ab5dbd..7c959680e84 100644
--- a/dlls/riched20/tests/editor.c
+++ b/dlls/riched20/tests/editor.c
@@ -1405,10 +1405,48 @@ static void test_EM_SETCHARFORMAT(void)
   DestroyWindow(hwndRichEdit);
 }
 
+/* As the clipboard is a shared resource, it happens (on Windows) that the WM_PASTE
+ * is a no-op; likely because another app has opened the clipboard for inspection.
+ * In this case, WM_PASTE does nothing, and doesn't return an error code.
+ * So retry pasting a couple of times.
+ * Don't use this function if the paste operation shouldn't change the content of the
+ * editor (clipboard is empty without selection, edit control is read only...).
+ * Also impact on undo stack is not managed.
+ */
+#define send_paste(a) _send_paste(__LINE__, (a))
+static void _send_paste(unsigned int line, HWND wnd)
+{
+    int retries;
+
+    SendMessageA(wnd, EM_SETMODIFY, FALSE, 0);
+
+    for (retries = 0; retries < 7; retries++)
+    {
+        if (retries) Sleep(15);
+        SendMessageA(wnd, WM_PASTE, 0, 0);
+        if (SendMessageA(wnd, EM_GETMODIFY, 0, 0)) return;
+    }
+    ok_(__FILE__, line)(0, "Failed to paste clipboard content\n");
+    {
+        char classname[256];
+        HWND clipwnd = GetOpenClipboardWindow();
+        /* Provide a hint as to the source of interference:
+         * - The class name would typically be CLIPBRDWNDCLASS if the
+         *   clipboard was opened by a Windows application using the
+         *   ole32 API.
+         * - And it would be __wine_clipboard_manager if it was opened in
+         *   response to a native application.
+         */
+        GetClassNameA(clipwnd, classname, ARRAY_SIZE(classname));
+        trace("%p (%s) opened the clipboard\n", clipwnd, classname);
+    }
+}
+
 static void test_EM_SETTEXTMODE(void)
 {
   HWND hwndRichEdit = new_richedit(NULL);
   CHARFORMAT2A cf2, cf2test;
+  unsigned int len;
   CHARRANGE cr;
   int rc = 0;
 
@@ -1478,7 +1516,10 @@ static void test_EM_SETTEXTMODE(void)
   SendMessageA(hwndRichEdit, WM_SETTEXT, 0, (LPARAM)"wine");
 
   /*Paste the italicized "wine" into the control*/
-  SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+  send_paste(hwndRichEdit);
+
+  len = SendMessageA(hwndRichEdit, WM_GETTEXTLENGTH, 0, 0);
+  ok(len == 8 /*winewine*/, "Unexpected text length %u\n", len);
 
   /*Select a character from the first "wine" string*/
   cr.cpMin = 2;
@@ -1521,7 +1562,7 @@ static void test_EM_SETTEXTMODE(void)
   SendMessageA(hwndRichEdit, WM_SETTEXT, 0, (LPARAM)"wine");
 
   /*Paste italicized "wine" into the control*/
-  SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+  send_paste(hwndRichEdit);
 
   /*Select text from the first "wine" string*/
   cr.cpMin = 1;
@@ -1667,7 +1708,7 @@ static void test_TM_PLAINTEXT(void)
   /*Paste the plain text "wine" string, which should take the insert
    formatting, which at the moment is bold italics*/
 
-  SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+  send_paste(hwndRichEdit);
 
   /*Select the first "wine" string and retrieve its formatting*/
 
@@ -4750,6 +4791,36 @@ static DWORD CALLBACK test_EM_GETMODIFY_esCallback(DWORD_PTR dwCookie,
   return 0;
 }
 
+#define open_clipboard(hwnd) open_clipboard_(__LINE__, hwnd)
+static BOOL open_clipboard_(int line, HWND hwnd)
+{
+    DWORD start = GetTickCount();
+    while (1)
+    {
+        BOOL ret = OpenClipboard(hwnd);
+        if (ret || GetLastError() != ERROR_ACCESS_DENIED)
+            return ret;
+        if (GetTickCount() - start > 100)
+        {
+            char classname[256];
+            DWORD le = GetLastError();
+            HWND clipwnd = GetOpenClipboardWindow();
+            /* Provide a hint as to the source of interference:
+             * - The class name would typically be CLIPBRDWNDCLASS if the
+             *   clipboard was opened by a Windows application using the
+             *   ole32 API.
+             * - And it would be __wine_clipboard_manager if it was opened in
+             *   response to a native application.
+             */
+            GetClassNameA(clipwnd, classname, ARRAY_SIZE(classname));
+            trace_(__FILE__, line)("%p (%s) opened the clipboard\n", clipwnd, classname);
+            SetLastError(le);
+            return ret;
+        }
+        Sleep(15);
+    }
+}
+
 static void test_EM_GETMODIFY(void)
 {
   HWND hwndRichEdit = new_richedit(NULL);
@@ -4766,6 +4837,8 @@ static void test_EM_GETMODIFY(void)
   CHARFORMAT2A cf2;
   PARAFORMAT2 pf2;
   EDITSTREAM es;
+  BOOL r;
+  HANDLE hclip;
   
   HFONT testFont = CreateFontA (0,0,0,0,FW_LIGHT, 0, 0, 0, ANSI_CHARSET, 
     OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | 
@@ -4847,7 +4920,7 @@ static void test_EM_GETMODIFY(void)
   SendMessageA(hwndRichEdit, EM_SETMODIFY, FALSE, 0);
   SendMessageA(hwndRichEdit, EM_SETSEL, 0, 2);
   SendMessageA(hwndRichEdit, WM_COPY, 0, 0);
-  SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+  send_paste(hwndRichEdit);
   result = SendMessageA(hwndRichEdit, EM_GETMODIFY, 0, 0);
   ok (result != 0,
       "EM_GETMODIFY returned zero, instead of non-zero when pasting identical text\n");
@@ -4857,7 +4930,7 @@ static void test_EM_GETMODIFY(void)
   SendMessageA(hwndRichEdit, EM_SETSEL, 0, 2);
   SendMessageA(hwndRichEdit, WM_COPY, 0, 0);
   SendMessageA(hwndRichEdit, EM_SETSEL, 0, 3);
-  SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+  send_paste(hwndRichEdit);
   result = SendMessageA(hwndRichEdit, EM_GETMODIFY, 0, 0);
   ok (result != 0,
       "EM_GETMODIFY returned zero, instead of non-zero when pasting different text\n");
@@ -4912,7 +4985,28 @@ static void test_EM_GETMODIFY(void)
   ok (result != 0,
       "EM_GETMODIFY returned zero, instead of non-zero for EM_STREAM\n");
 
+  /* Check that the clipboard data is still available after destroying the
+   * editor window.
+   */
+  SendMessageA(hwndRichEdit, WM_SETTEXT, 0, (LPARAM)"Stayin' alive");
+  SendMessageA(hwndRichEdit, EM_SETSEL, 8, -1);
+  SendMessageA(hwndRichEdit, WM_COPY, 0, 0);
+
   DestroyWindow(hwndRichEdit);
+
+  r = open_clipboard(NULL);
+  ok(r, "OpenClipboard failed le=%lu\n", GetLastError());
+
+  hclip = GetClipboardData(CF_TEXT);
+  todo_wine ok(hclip != NULL, "GetClipboardData() failed le=%lu\n", GetLastError());
+  if (hclip)
+  {
+      const char* str = GlobalLock(hclip);
+      ok(strcmp(str, "alive") == 0, "unexpected clipboard content: %s\n", str);
+      GlobalUnlock(hclip);
+  }
+
+  CloseClipboard();
 }
 
 struct exsetsel_s {
@@ -5557,7 +5651,7 @@ static void test_WM_PASTE(void)
                 (MapVirtualKeyA('C', MAPVK_VK_TO_VSC) << 16) | 1);
     release_key(VK_CONTROL);
     SendMessageA(hwndRichEdit, WM_SETTEXT, 0, 0);
-    SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+    send_paste(hwndRichEdit);
     SendMessageA(hwndRichEdit, WM_GETTEXT, 1024, (LPARAM)buffer);
     result = strcmp(buffer,"testing");
     ok(result == 0,
@@ -5578,7 +5672,7 @@ static void test_WM_PASTE(void)
     ok(result == 0,
         "test paste: strcmp = %i, actual = '%s'\n", result, buffer);
     SendMessageA(hwndRichEdit, WM_SETTEXT, 0, 0);
-    SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+    send_paste(hwndRichEdit);
     SendMessageA(hwndRichEdit, WM_GETTEXT, 1024, (LPARAM)buffer);
     result = strcmp(buffer,"cut\r\n");
     ok(result == 0,
@@ -5628,7 +5722,7 @@ static void test_WM_PASTE(void)
 
     /* Paste multi-line text into single-line control */
     hwndRichEdit = new_richedit_with_style(NULL, 0);
-    SendMessageA(hwndRichEdit, WM_PASTE, 0, 0);
+    send_paste(hwndRichEdit);
     SendMessageA(hwndRichEdit, WM_GETTEXT, 1024, (LPARAM)buffer);
     result = strcmp(buffer, "testing paste");
     ok(result == 0,
@@ -5690,6 +5784,7 @@ static void test_EM_FORMATRANGE(void)
     SIZE stringsize;
     int len;
 
+    winetest_push_context("%d", i);
     SendMessageA(hwndRichEdit, WM_SETTEXT, 0, (LPARAM)fmtstrings[i].string);
 
     gtl.flags = GTL_NUMCHARS | GTL_PRECISE;
@@ -5746,6 +5841,7 @@ static void test_EM_FORMATRANGE(void)
     todo_wine {
     ok(r == len, "Expected %d, got %d\n", len, r);
     }
+    winetest_pop_context();
   }
 
   ReleaseDC(NULL, hdc);
diff --git a/dlls/riched20/tests/richole.c b/dlls/riched20/tests/richole.c
index d648354729e..1c19d36dc0d 100644
--- a/dlls/riched20/tests/richole.c
+++ b/dlls/riched20/tests/richole.c
@@ -4907,6 +4907,35 @@ static void test_character_movement(void)
   ITextRange_Release(range);
 }
 
+static BOOL open_clipboard(HWND hwnd)
+{
+    DWORD start = GetTickCount();
+    while (1)
+    {
+        BOOL ret = OpenClipboard(hwnd);
+        if (ret || GetLastError() != ERROR_ACCESS_DENIED)
+            return ret;
+        if (GetTickCount() - start > 100)
+        {
+            char classname[256];
+            DWORD le = GetLastError();
+            HWND clipwnd = GetOpenClipboardWindow();
+            /* Provide a hint as to the source of interference:
+             * - The class name would typically be CLIPBRDWNDCLASS if the
+             *   clipboard was opened by a Windows application using the
+             *   ole32 API.
+             * - And it would be __wine_clipboard_manager if it was opened in
+             *   response to a native application.
+             */
+            GetClassNameA(clipwnd, classname, ARRAY_SIZE(classname));
+            trace("%p (%s) opened the clipboard\n", clipwnd, classname);
+            SetLastError(le);
+            return ret;
+        }
+        Sleep(15);
+    }
+}
+
 #define CLIPBOARD_RANGE_CONTAINS(range, start, end, expected) _clipboard_range_contains(range, start, end, expected, __LINE__, 0);
 #define TODO_CLIPBOARD_RANGE_CONTAINS(range, start, end, expected) _clipboard_range_contains(range, start, end, expected, __LINE__, 1);
 static void _clipboard_range_contains(ITextRange *range, LONG start, LONG end, const char *expected, int line, int todo)
@@ -4921,7 +4950,7 @@ static void _clipboard_range_contains(ITextRange *range, LONG start, LONG end, c
   hr = ITextRange_Copy(range, NULL);
   ok_(__FILE__,line)(hr == S_OK, "Copy failed: 0x%08lx\n", hr);
 
-  clipboard_open = OpenClipboard(NULL);
+  clipboard_open = open_clipboard(NULL);
   ok_(__FILE__,line)(clipboard_open, "OpenClipboard failed: %ld\n", GetLastError());
   global = GetClipboardData(CF_TEXT);
   ok_(__FILE__,line)(global != NULL, "GetClipboardData failed: %p\n", global);
diff --git a/dlls/rpcrt4/cproxy.c b/dlls/rpcrt4/cproxy.c
index b2c86d54422..80400422e41 100644
--- a/dlls/rpcrt4/cproxy.c
+++ b/dlls/rpcrt4/cproxy.c
@@ -332,7 +332,7 @@ HRESULT StdProxy_Construct(REFIID riid,
   This = calloc(1, sizeof(StdProxyImpl));
   if (!This) return E_OUTOFMEMORY;
 
-  if (!pUnkOuter) pUnkOuter = (IUnknown *)This;
+  if (!pUnkOuter) pUnkOuter = (IUnknown *)&This->IRpcProxyBuffer_iface;
   This->IRpcProxyBuffer_iface.lpVtbl = &StdProxy_Vtbl;
   This->PVtbl = vtbl->Vtbl;
   /* one reference for the proxy */
@@ -586,7 +586,7 @@ void WINAPI NdrProxyFreeBuffer(void *This,
   {
     IRpcChannelBuffer_FreeBuffer(pStubMsg->pRpcChannelBuffer,
                                  (RPCOLEMESSAGE*)pStubMsg->RpcMsg);
-    pStubMsg->fBufferValid = TRUE;
+    pStubMsg->fBufferValid = FALSE;
   }
   IRpcChannelBuffer_Release(pStubMsg->pRpcChannelBuffer);
   pStubMsg->pRpcChannelBuffer = NULL;
diff --git a/dlls/rpcrt4/cstub.c b/dlls/rpcrt4/cstub.c
index 47d5e301c0f..0f5bd0eda9f 100644
--- a/dlls/rpcrt4/cstub.c
+++ b/dlls/rpcrt4/cstub.c
@@ -38,8 +38,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ole);
 
-#define STUB_HEADER(This) (((const CInterfaceStubHeader*)((This)->lpVtbl))[-1])
-
 static LONG WINAPI stub_filter(EXCEPTION_POINTERS *eptr)
 {
     if (eptr->ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE)
@@ -47,9 +45,21 @@ static LONG WINAPI stub_filter(EXCEPTION_POINTERS *eptr)
     return EXCEPTION_EXECUTE_HANDLER;
 }
 
+static CStdStubBuffer *impl_from_IRpcStubBuffer(IRpcStubBuffer *iface)
+{
+    return CONTAINING_RECORD(&iface->lpVtbl, CStdStubBuffer, lpVtbl);
+}
+
 static inline cstdstubbuffer_delegating_t *impl_from_delegating( IRpcStubBuffer *iface )
 {
-    return CONTAINING_RECORD(iface, cstdstubbuffer_delegating_t, stub_buffer);
+    return CONTAINING_RECORD(impl_from_IRpcStubBuffer(iface), cstdstubbuffer_delegating_t, stub_buffer);
+}
+
+static const CInterfaceStubHeader *get_stub_header(const CStdStubBuffer *stub)
+{
+    const CInterfaceStubVtbl *vtbl = CONTAINING_RECORD(stub->lpVtbl, CInterfaceStubVtbl, Vtbl);
+
+    return &vtbl->header;
 }
 
 HRESULT CStdStubBuffer_Construct(REFIID riid,
@@ -100,15 +110,15 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION delegating_vtbl_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
-typedef struct
+struct delegating_vtbl
 {
     DWORD ref;
     DWORD size;
     IUnknownVtbl vtbl;
-    /* remaining entries in vtbl */
-} ref_counted_vtbl;
+    const void *methods[];
+};
 
-static ref_counted_vtbl *current_vtbl;
+static struct delegating_vtbl *current_vtbl;
 
 
 static HRESULT WINAPI delegating_QueryInterface(IUnknown *pUnk, REFIID iid, void **ppv)
@@ -241,24 +251,27 @@ static const vtbl_method_t *allocate_block( unsigned int num )
     return block;
 }
 
-static BOOL fill_delegated_stub_table(IUnknownVtbl *vtbl, DWORD num)
+static BOOL init_delegating_vtbl(struct delegating_vtbl *table, DWORD num)
 {
-    const void **entry = (const void **)(vtbl + 1);
     DWORD i, j;
 
+    table->ref = 0;
+    table->size = num;
+
     if (num - 3 > BLOCK_SIZE * MAX_BLOCKS)
     {
         FIXME( "%lu methods not supported\n", num );
         return FALSE;
     }
-    vtbl->QueryInterface = delegating_QueryInterface;
-    vtbl->AddRef = delegating_AddRef;
-    vtbl->Release = delegating_Release;
+    table->vtbl.QueryInterface = delegating_QueryInterface;
+    table->vtbl.AddRef = delegating_AddRef;
+    table->vtbl.Release = delegating_Release;
     for (i = 0; i < (num - 3 + BLOCK_SIZE - 1) / BLOCK_SIZE; i++)
     {
         const vtbl_method_t *block = method_blocks[i];
         if (!block && !(block = allocate_block( i ))) return FALSE;
-        for (j = 0; j < BLOCK_SIZE && j < num - 3 - i * BLOCK_SIZE; j++) *entry++ = &block[j];
+        for (j = 0; j < BLOCK_SIZE && j < num - 3 - i * BLOCK_SIZE; j++)
+            table->methods[j] = &block[j];
     }
     return TRUE;
 }
@@ -296,16 +309,14 @@ IUnknownVtbl *get_delegating_vtbl(DWORD num_methods)
 
     if(!current_vtbl || num_methods > current_vtbl->size)
     {
-        ref_counted_vtbl *table = malloc(FIELD_OFFSET(ref_counted_vtbl, vtbl) + num_methods * sizeof(void *));
+        struct delegating_vtbl *table = malloc(FIELD_OFFSET(struct delegating_vtbl, methods[num_methods]));
         if (!table)
         {
             LeaveCriticalSection(&delegating_vtbl_section);
             return NULL;
         }
 
-        table->ref = 0;
-        table->size = num_methods;
-        fill_delegated_stub_table(&table->vtbl, num_methods);
+        init_delegating_vtbl(table, num_methods);
 
         if (current_vtbl && current_vtbl->ref == 0)
         {
@@ -323,7 +334,7 @@ IUnknownVtbl *get_delegating_vtbl(DWORD num_methods)
 
 void release_delegating_vtbl(IUnknownVtbl *vtbl)
 {
-    ref_counted_vtbl *table = (ref_counted_vtbl*)((DWORD *)vtbl - 1);
+    struct delegating_vtbl *table = CONTAINING_RECORD(vtbl, struct delegating_vtbl, vtbl);
 
     EnterCriticalSection(&delegating_vtbl_section);
     table->ref--;
@@ -392,7 +403,7 @@ HRESULT WINAPI CStdStubBuffer_QueryInterface(LPRPCSTUBBUFFER iface,
                                             REFIID riid,
                                             LPVOID *obj)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   TRACE("(%p)->QueryInterface(%s,%p)\n",This,debugstr_guid(riid),obj);
 
   if (IsEqualIID(&IID_IUnknown, riid) ||
@@ -408,7 +419,7 @@ HRESULT WINAPI CStdStubBuffer_QueryInterface(LPRPCSTUBBUFFER iface,
 
 ULONG WINAPI CStdStubBuffer_AddRef(LPRPCSTUBBUFFER iface)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   TRACE("(%p)->AddRef()\n",This);
   return InterlockedIncrement(&This->RefCount);
 }
@@ -416,7 +427,7 @@ ULONG WINAPI CStdStubBuffer_AddRef(LPRPCSTUBBUFFER iface)
 ULONG WINAPI NdrCStdStubBuffer_Release(LPRPCSTUBBUFFER iface,
                                       LPPSFACTORYBUFFER pPSF)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   ULONG refs;
 
   TRACE("(%p)->Release()\n",This);
@@ -462,13 +473,13 @@ ULONG WINAPI NdrCStdStubBuffer2_Release(LPRPCSTUBBUFFER iface,
 HRESULT WINAPI CStdStubBuffer_Connect(LPRPCSTUBBUFFER iface,
                                      LPUNKNOWN lpUnkServer)
 {
-    CStdStubBuffer *This = (CStdStubBuffer *)iface;
+    CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
     HRESULT r;
     IUnknown *new = NULL;
 
     TRACE("(%p)->Connect(%p)\n",This,lpUnkServer);
 
-    r = IUnknown_QueryInterface(lpUnkServer, STUB_HEADER(This).piid, (void**)&new);
+    r = IUnknown_QueryInterface(lpUnkServer, get_stub_header(This)->piid, (void**)&new);
     new = InterlockedExchangePointer((void**)&This->pvServerObject, new);
     if(new)
         IUnknown_Release(new);
@@ -477,7 +488,7 @@ HRESULT WINAPI CStdStubBuffer_Connect(LPRPCSTUBBUFFER iface,
 
 void WINAPI CStdStubBuffer_Disconnect(LPRPCSTUBBUFFER iface)
 {
-    CStdStubBuffer *This = (CStdStubBuffer *)iface;
+    CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
     IUnknown *old;
     TRACE("(%p)->Disconnect()\n",This);
 
@@ -491,7 +502,8 @@ HRESULT WINAPI CStdStubBuffer_Invoke(LPRPCSTUBBUFFER iface,
                                     PRPCOLEMESSAGE pMsg,
                                     LPRPCCHANNELBUFFER pChannel)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
+  const CInterfaceStubHeader *header = get_stub_header(This);
   DWORD dwPhase = STUB_UNMARSHAL;
   HRESULT hr = S_OK;
 
@@ -499,8 +511,8 @@ HRESULT WINAPI CStdStubBuffer_Invoke(LPRPCSTUBBUFFER iface,
 
   __TRY
   {
-    if (STUB_HEADER(This).pDispatchTable)
-      STUB_HEADER(This).pDispatchTable[pMsg->iMethod](iface, pChannel, (PRPC_MESSAGE)pMsg, &dwPhase);
+    if (header->pDispatchTable)
+      header->pDispatchTable[pMsg->iMethod](iface, pChannel, (PRPC_MESSAGE)pMsg, &dwPhase);
     else /* pure interpreted */
       NdrStubCall2(iface, pChannel, (PRPC_MESSAGE)pMsg, &dwPhase);
   }
@@ -521,14 +533,18 @@ HRESULT WINAPI CStdStubBuffer_Invoke(LPRPCSTUBBUFFER iface,
 LPRPCSTUBBUFFER WINAPI CStdStubBuffer_IsIIDSupported(LPRPCSTUBBUFFER iface,
                                                     REFIID riid)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
-  TRACE("(%p)->IsIIDSupported(%s)\n",This,debugstr_guid(riid));
-  return IsEqualGUID(STUB_HEADER(This).piid, riid) ? iface : NULL;
+    CStdStubBuffer *stub = impl_from_IRpcStubBuffer(iface);
+
+    TRACE("(%p)->IsIIDSupported(%s)\n", stub, debugstr_guid(riid));
+
+    if (IsEqualGUID(get_stub_header(stub)->piid, riid))
+        return iface;
+    return NULL;
 }
 
 ULONG WINAPI CStdStubBuffer_CountRefs(LPRPCSTUBBUFFER iface)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   TRACE("(%p)->CountRefs()\n",This);
   return This->RefCount;
 }
@@ -536,7 +552,7 @@ ULONG WINAPI CStdStubBuffer_CountRefs(LPRPCSTUBBUFFER iface)
 HRESULT WINAPI CStdStubBuffer_DebugServerQueryInterface(LPRPCSTUBBUFFER iface,
                                                        LPVOID *ppv)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   TRACE("(%p)->DebugServerQueryInterface(%p)\n",This,ppv);
   return S_OK;
 }
@@ -544,7 +560,7 @@ HRESULT WINAPI CStdStubBuffer_DebugServerQueryInterface(LPRPCSTUBBUFFER iface,
 void WINAPI CStdStubBuffer_DebugServerRelease(LPRPCSTUBBUFFER iface,
                                              LPVOID pv)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   TRACE("(%p)->DebugServerRelease(%p)\n",This,pv);
 }
 
@@ -613,8 +629,9 @@ const IRpcStubBufferVtbl CStdStubBuffer_Delegating_Vtbl =
 
 const MIDL_SERVER_INFO *CStdStubBuffer_GetServerInfo(IRpcStubBuffer *iface)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
-  return STUB_HEADER(This).pServerInfo;
+    CStdStubBuffer *stub = impl_from_IRpcStubBuffer(iface);
+
+    return get_stub_header(stub)->pServerInfo;
 }
 
 /************************************************************************
@@ -654,14 +671,14 @@ void WINAPI NdrStubGetBuffer(LPRPCSTUBBUFFER iface,
                             LPRPCCHANNELBUFFER pRpcChannelBuffer,
                             PMIDL_STUB_MESSAGE pStubMsg)
 {
-  CStdStubBuffer *This = (CStdStubBuffer *)iface;
+  CStdStubBuffer *This = impl_from_IRpcStubBuffer(iface);
   HRESULT hr;
 
   TRACE("(%p, %p, %p)\n", This, pRpcChannelBuffer, pStubMsg);
 
   pStubMsg->RpcMsg->BufferLength = pStubMsg->BufferLength;
   hr = IRpcChannelBuffer_GetBuffer(pRpcChannelBuffer,
-    (RPCOLEMESSAGE *)pStubMsg->RpcMsg, STUB_HEADER(This).piid);
+    (RPCOLEMESSAGE *)pStubMsg->RpcMsg, get_stub_header(This)->piid);
   if (FAILED(hr))
   {
     RpcRaiseException(hr);
diff --git a/dlls/rpcrt4/tests/rpc.c b/dlls/rpcrt4/tests/rpc.c
index a4653fd603f..2a3d43cfc2d 100644
--- a/dlls/rpcrt4/tests/rpc.c
+++ b/dlls/rpcrt4/tests/rpc.c
@@ -158,41 +158,27 @@ static void test_UuidFromString(void)
 static void test_DceErrorInqTextA(void)
 {
     char bufferInvalid [1024];
-    char buffer [1024]; /* The required size is not documented but would
-                         * appear to be 256.
-                         */
+    char buffer [1024];
     DWORD dwCount;
+    RPC_STATUS status;
 
     dwCount = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL,
             RPC_S_NOT_RPC_ERROR, 0, bufferInvalid, ARRAY_SIZE(bufferInvalid), NULL);
+    ok(dwCount, "Cannot set up for DceErrorInqText\n");
 
-    /* A random sample of DceErrorInqText */
     /* 0 is success */
-    ok ((DceErrorInqTextA (0, (unsigned char*)buffer) == RPC_S_OK),
-            "DceErrorInqTextA(0...)\n");
-    /* A real RPC_S error */
-    ok ((DceErrorInqTextA (RPC_S_INVALID_STRING_UUID, (unsigned char*)buffer) == RPC_S_OK),
-            "DceErrorInqTextA(valid...)\n");
+    status = DceErrorInqTextA(0, (unsigned char*)buffer);
+    ok(status == RPC_S_OK, "got %lx\n", status);
 
-    if (dwCount)
-    {
-        /* A message for which FormatMessage should fail
-         * which should return RPC_S_OK and the 
-         * fixed "not valid" message
-         */
-        ok ((DceErrorInqTextA (35, (unsigned char*)buffer) == RPC_S_OK &&
-                    strcmp (buffer, bufferInvalid) == 0),
-                "DceErrorInqTextA(unformattable...)\n");
-        /* One for which FormatMessage should succeed but 
-         * DceErrorInqText should "fail"
-         * 3814 is generally quite a long message
-         */
-        ok ((DceErrorInqTextA (3814, (unsigned char*)buffer) == RPC_S_OK &&
-                    strcmp (buffer, bufferInvalid) == 0),
-                "DceErrorInqTextA(deviation...)\n");
-    }
-    else
-        ok (0, "Cannot set up for DceErrorInqText\n");
+    /* A real RPC_S error */
+    status = DceErrorInqTextA(RPC_S_INVALID_STRING_UUID, (unsigned char*)buffer);
+    ok(status == RPC_S_OK, "got %lx\n", status);
+
+    /* A message for which FormatMessage should fail which should return RPC_S_OK and the
+     * fixed "not valid" message  */
+    status = DceErrorInqTextA(35, (unsigned char*)buffer);
+    ok(status == RPC_S_OK, "got %lx\n", status);
+    ok(!strcmp(buffer, bufferInvalid), "got %s vs %s\n", wine_dbgstr_a(buffer), wine_dbgstr_a(bufferInvalid));
 }
 
 static RPC_DISPATCH_FUNCTION IFoo_table[] =
diff --git a/dlls/scardsvr/Makefile.in b/dlls/scardsvr/Makefile.in
new file mode 100644
index 00000000000..c89e86c17d8
--- /dev/null
+++ b/dlls/scardsvr/Makefile.in
@@ -0,0 +1,5 @@
+MODULE    = scardsvr.dll
+IMPORTS   = advapi32
+
+C_SRCS = \
+	scardsvr.c
diff --git a/dlls/scardsvr/scardsvr.c b/dlls/scardsvr/scardsvr.c
new file mode 100644
index 00000000000..5c4e26f5362
--- /dev/null
+++ b/dlls/scardsvr/scardsvr.c
@@ -0,0 +1,88 @@
+/*
+ * Smart card service
+ *
+ * Copyright 2014 Nikolay Sivov for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+#include "winsvc.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(winscard);
+
+static SERVICE_STATUS_HANDLE service_handle;
+static HANDLE stop_event;
+
+static DWORD WINAPI service_handler(DWORD ctrl, DWORD event_type, void *event_data, void *context)
+{
+    SERVICE_STATUS status;
+
+    status.dwServiceType = SERVICE_WIN32;
+    status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+    status.dwWin32ExitCode = 0;
+    status.dwServiceSpecificExitCode = 0;
+    status.dwCheckPoint = 0;
+    status.dwWaitHint = 0;
+
+    switch(ctrl)
+    {
+        case SERVICE_CONTROL_STOP:
+        case SERVICE_CONTROL_SHUTDOWN:
+            TRACE("Shutting down.\n");
+            status.dwCurrentState = SERVICE_STOP_PENDING;
+            status.dwControlsAccepted = 0;
+            SetServiceStatus(service_handle, &status);
+            SetEvent(stop_event);
+            return ERROR_SUCCESS;
+
+        default:
+            FIXME("Got unknown control %#lx.\n", ctrl);
+            status.dwCurrentState = SERVICE_RUNNING;
+            SetServiceStatus(service_handle, &status);
+            return ERROR_SUCCESS;
+    }
+}
+
+void WINAPI CalaisMain(DWORD argc, WCHAR **argv)
+{
+    SERVICE_STATUS status;
+
+    TRACE("Starting service.\n");
+
+    stop_event = CreateEventW(NULL, TRUE, FALSE, NULL);
+
+    if (!(service_handle = RegisterServiceCtrlHandlerExW(L"scardsvr", service_handler, NULL)))
+        return;
+
+    status.dwServiceType = SERVICE_WIN32;
+    status.dwCurrentState = SERVICE_RUNNING;
+    status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
+    status.dwWin32ExitCode = 0;
+    status.dwServiceSpecificExitCode = 0;
+    status.dwCheckPoint = 0;
+    status.dwWaitHint = 10000;
+    SetServiceStatus(service_handle, &status);
+
+    WaitForSingleObject(stop_event, INFINITE);
+
+    status.dwCurrentState = SERVICE_STOPPED;
+    status.dwControlsAccepted = 0;
+    SetServiceStatus(service_handle, &status);
+    TRACE("Service stopped.\n");
+}
diff --git a/dlls/scardsvr/scardsvr.spec b/dlls/scardsvr/scardsvr.spec
new file mode 100644
index 00000000000..c33a1aa6569
--- /dev/null
+++ b/dlls/scardsvr/scardsvr.spec
@@ -0,0 +1,3 @@
+@ stdcall -private CalaisMain(long ptr)
+@ stub InitSmartCardService
+# @ stub SvchostPushServiceGlobals
diff --git a/dlls/schedsvc/schedsvc.c b/dlls/schedsvc/schedsvc.c
index c670c8b1cbb..784fc5d944d 100644
--- a/dlls/schedsvc/schedsvc.c
+++ b/dlls/schedsvc/schedsvc.c
@@ -660,7 +660,7 @@ HRESULT __cdecl SchRpcEnumFolders(const WCHAR *path, DWORD flags, DWORD *start_i
             {
                 TASK_NAMES new_list;
                 allocated *= 2;
-                new_list = heap_realloc(list, allocated * sizeof(list[0]));
+                new_list = realloc(list, allocated * sizeof(list[0]));
                 if (!new_list)
                 {
                     hr = E_OUTOFMEMORY;
@@ -768,7 +768,7 @@ HRESULT __cdecl SchRpcEnumTasks(const WCHAR *path, DWORD flags, DWORD *start_ind
             {
                 TASK_NAMES new_list;
                 allocated *= 2;
-                new_list = heap_realloc(list, allocated * sizeof(list[0]));
+                new_list = realloc(list, allocated * sizeof(list[0]));
                 if (!new_list)
                 {
                     hr = E_OUTOFMEMORY;
diff --git a/dlls/schedsvc/schedsvc_private.h b/dlls/schedsvc/schedsvc_private.h
index 62b25f97794..224b4c1b398 100644
--- a/dlls/schedsvc/schedsvc_private.h
+++ b/dlls/schedsvc/schedsvc_private.h
@@ -19,8 +19,6 @@
 #ifndef __WINE_SCHEDSVC_PRIVATE_H__
 #define __WINE_SCHEDSVC_PRIVATE_H__
 
-#include "wine/heap.h"
-
 void schedsvc_auto_start(void) DECLSPEC_HIDDEN;
 void add_job(const WCHAR *name) DECLSPEC_HIDDEN;
 void remove_job(const WCHAR *name) DECLSPEC_HIDDEN;
diff --git a/dlls/schedsvc/svc_main.c b/dlls/schedsvc/svc_main.c
index 7681a220592..349dae756fc 100644
--- a/dlls/schedsvc/svc_main.c
+++ b/dlls/schedsvc/svc_main.c
@@ -244,7 +244,7 @@ void schedsvc_auto_start(void)
     {
         if (!QueryServiceConfigW(service, NULL, 0, &cfg_size) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
         {
-            cfg = HeapAlloc(GetProcessHeap(), 0, cfg_size);
+            cfg = malloc(cfg_size);
             if (cfg)
             {
                 if (QueryServiceConfigW(service, cfg, cfg_size, &cfg_size))
@@ -257,7 +257,7 @@ void schedsvc_auto_start(void)
                             start_type = SERVICE_AUTO_START;
                     }
                 }
-                HeapFree(GetProcessHeap(), 0, cfg);
+                free(cfg);
             }
         }
         else
@@ -418,10 +418,10 @@ void WINAPI ServiceMain(DWORD argc, LPWSTR *argv)
 
 void  __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
 {
-    return heap_alloc(len);
+    return malloc(len);
 }
 
 void __RPC_USER MIDL_user_free(void __RPC_FAR * ptr)
 {
-    heap_free(ptr);
+    free(ptr);
 }
diff --git a/dlls/scrobj/scrobj.c b/dlls/scrobj/scrobj.c
index 90cf2024537..5056977624a 100644
--- a/dlls/scrobj/scrobj.c
+++ b/dlls/scrobj/scrobj.c
@@ -1188,7 +1188,7 @@ static HRESULT create_scriptlet_instance(struct scriptlet_factory *factory, IDis
     struct script_host *factory_host, *host;
     struct scriptlet_instance *obj;
     IDispatch *script_dispatch;
-    HRESULT hres;
+    HRESULT hres = S_OK;
 
     if (!(obj = calloc(1, sizeof(*obj))))
         return E_OUTOFMEMORY;
diff --git a/dlls/sechost/service.c b/dlls/sechost/service.c
index 011533b883e..b00e5536eda 100644
--- a/dlls/sechost/service.c
+++ b/dlls/sechost/service.c
@@ -356,7 +356,7 @@ SC_HANDLE WINAPI DECLSPEC_HOTPATCH CreateServiceA( SC_HANDLE manager, const char
     display_nameW = heap_strdupAtoW( display_name );
     pathW = heap_strdupAtoW( path );
     groupW = heap_strdupAtoW( group );
-    dependenciesW = heap_strdupAtoW( dependencies );
+    dependenciesW = heap_strdup_multi_AtoW( dependencies );
     usernameW = heap_strdupAtoW( username );
     passwordW = heap_strdupAtoW( password );
 
diff --git a/dlls/secur32/schannel.c b/dlls/secur32/schannel.c
index 23917626497..05994ed0753 100644
--- a/dlls/secur32/schannel.c
+++ b/dlls/secur32/schannel.c
@@ -161,23 +161,24 @@ static void read_config(void)
     DWORD enabled = 0, default_disabled = 0;
     HKEY protocols_key, key;
     WCHAR subkey_name[64];
-    unsigned i;
+    unsigned i, server;
     DWORD res;
 
     static BOOL config_read = FALSE;
     static const struct {
         WCHAR key_name[20];
         DWORD prot_client_flag;
+        DWORD prot_server_flag;
         BOOL enabled; /* If no config is present, enable the protocol */
         BOOL disabled_by_default; /* Disable if caller asks for default protocol set */
     } protocol_config_keys[] = {
-        { L"SSL 2.0", SP_PROT_SSL2_CLIENT, FALSE, TRUE }, /* NOTE: TRUE, TRUE on Windows */
-        { L"SSL 3.0", SP_PROT_SSL3_CLIENT, TRUE, FALSE },
-        { L"TLS 1.0", SP_PROT_TLS1_0_CLIENT, TRUE, FALSE },
-        { L"TLS 1.1", SP_PROT_TLS1_1_CLIENT, TRUE, FALSE /* NOTE: not enabled by default on Windows */ },
-        { L"TLS 1.2", SP_PROT_TLS1_2_CLIENT, TRUE, FALSE /* NOTE: not enabled by default on Windows */ },
-        { L"DTLS 1.0", SP_PROT_DTLS1_0_CLIENT, TRUE, TRUE },
-        { L"DTLS 1.2", SP_PROT_DTLS1_2_CLIENT, TRUE, TRUE },
+        { L"SSL 2.0",  SP_PROT_SSL2_CLIENT,    SP_PROT_SSL2_SERVER,    FALSE, TRUE }, /* NOTE: TRUE, TRUE on Windows */
+        { L"SSL 3.0",  SP_PROT_SSL3_CLIENT,    SP_PROT_SSL3_SERVER,    TRUE, FALSE },
+        { L"TLS 1.0",  SP_PROT_TLS1_0_CLIENT,  SP_PROT_TLS1_0_SERVER,  TRUE, FALSE },
+        { L"TLS 1.1",  SP_PROT_TLS1_1_CLIENT,  SP_PROT_TLS1_1_SERVER,  TRUE, FALSE /* NOTE: not enabled by default on Windows */ },
+        { L"TLS 1.2",  SP_PROT_TLS1_2_CLIENT,  SP_PROT_TLS1_2_SERVER,  TRUE, FALSE /* NOTE: not enabled by default on Windows */ },
+        { L"DTLS 1.0", SP_PROT_DTLS1_0_CLIENT, SP_PROT_DTLS1_0_SERVER, TRUE, TRUE },
+        { L"DTLS 1.2", SP_PROT_DTLS1_2_CLIENT, SP_PROT_DTLS1_2_SERVER, TRUE, TRUE },
     };
 
     /* No need for thread safety */
@@ -191,44 +192,49 @@ static void read_config(void)
         DWORD type, size, value;
 
         for(i = 0; i < ARRAY_SIZE(protocol_config_keys); i++) {
-            wcscpy(subkey_name, protocol_config_keys[i].key_name);
-            wcscat(subkey_name, L"\\Client");
-            res = RegOpenKeyExW(protocols_key, subkey_name, 0, KEY_READ, &key);
-            if(res != ERROR_SUCCESS) {
-                if(protocol_config_keys[i].enabled)
-                    enabled |= protocol_config_keys[i].prot_client_flag;
-                if(protocol_config_keys[i].disabled_by_default)
-                    default_disabled |= protocol_config_keys[i].prot_client_flag;
-                continue;
-            }
-
-            size = sizeof(value);
-            res = RegQueryValueExW(key, L"enabled", NULL, &type, (BYTE *)&value, &size);
-            if(res == ERROR_SUCCESS) {
-                if(type == REG_DWORD && value)
-                    enabled |= protocol_config_keys[i].prot_client_flag;
-            }else if(protocol_config_keys[i].enabled) {
-                enabled |= protocol_config_keys[i].prot_client_flag;
+            for (server = 0; server < 2; server++) {
+                DWORD flag = server ? protocol_config_keys[i].prot_server_flag
+                                    : protocol_config_keys[i].prot_client_flag;
+                wcscpy(subkey_name, protocol_config_keys[i].key_name);
+                wcscat(subkey_name, server ? L"\\Server" : L"\\Client");
+                res = RegOpenKeyExW(protocols_key, subkey_name, 0, KEY_READ, &key);
+                if(res != ERROR_SUCCESS) {
+                    if(protocol_config_keys[i].enabled)
+                        enabled |= flag;
+                    if(protocol_config_keys[i].disabled_by_default)
+                        default_disabled |= flag;
+                    continue;
+                }
+
+                size = sizeof(value);
+                res = RegQueryValueExW(key, L"enabled", NULL, &type, (BYTE *)&value, &size);
+                if(res == ERROR_SUCCESS) {
+                    if(type == REG_DWORD && value)
+                        enabled |= flag;
+                }else if(protocol_config_keys[i].enabled) {
+                    enabled |= flag;
+                }
+
+                size = sizeof(value);
+                res = RegQueryValueExW(key, L"DisabledByDefault", NULL, &type, (BYTE *)&value, &size);
+                if(res == ERROR_SUCCESS) {
+                    if(type != REG_DWORD || value)
+                        default_disabled |= flag;
+                }else if(protocol_config_keys[i].disabled_by_default) {
+                    default_disabled |= flag;
+                }
+
+                RegCloseKey(key);
             }
-
-            size = sizeof(value);
-            res = RegQueryValueExW(key, L"DisabledByDefault", NULL, &type, (BYTE *)&value, &size);
-            if(res == ERROR_SUCCESS) {
-                if(type != REG_DWORD || value)
-                    default_disabled |= protocol_config_keys[i].prot_client_flag;
-            }else if(protocol_config_keys[i].disabled_by_default) {
-                default_disabled |= protocol_config_keys[i].prot_client_flag;
-            }
-
-            RegCloseKey(key);
         }
     }else {
         /* No config, enable all known protocols. */
         for(i = 0; i < ARRAY_SIZE(protocol_config_keys); i++) {
+            DWORD flag = protocol_config_keys[i].prot_client_flag | protocol_config_keys[i].prot_server_flag;
             if(protocol_config_keys[i].enabled)
-                enabled |= protocol_config_keys[i].prot_client_flag;
+                enabled |= flag;
             if(protocol_config_keys[i].disabled_by_default)
-                default_disabled |= protocol_config_keys[i].prot_client_flag;
+                default_disabled |= flag;
         }
     }
 
@@ -533,8 +539,8 @@ static BYTE *get_key_blob(const CERT_CONTEXT *ctx, DWORD *size)
     return ret;
 }
 
-static SECURITY_STATUS schan_AcquireClientCredentials(const void *schanCred,
- PCredHandle phCredential, PTimeStamp ptsExpiry)
+static SECURITY_STATUS acquire_credentials_handle(ULONG fCredentialUse,
+ const SCHANNEL_CRED *schanCred, PCredHandle phCredential, PTimeStamp ptsExpiry)
 {
     struct schan_credentials *creds;
     DWORD enabled_protocols, cred_enabled_protocols;
@@ -545,37 +551,44 @@ static SECURITY_STATUS schan_AcquireClientCredentials(const void *schanCred,
     BYTE *key_blob = NULL;
     ULONG key_size = 0;
 
-    TRACE("schanCred %p, phCredential %p, ptsExpiry %p\n", schanCred, phCredential, ptsExpiry);
+    TRACE("fCredentialUse %#lx, schanCred %p, phCredential %p, ptsExpiry %p\n", fCredentialUse, schanCred, phCredential, ptsExpiry);
 
     if (schanCred)
     {
-        const unsigned dtls_protocols = SP_PROT_DTLS_CLIENT | SP_PROT_DTLS1_2_CLIENT;
-        const unsigned tls_protocols = SP_PROT_TLS1_CLIENT | SP_PROT_TLS1_0_CLIENT | SP_PROT_TLS1_1_CLIENT |
-                                       SP_PROT_TLS1_2_CLIENT | SP_PROT_TLS1_3_CLIENT;
+        const unsigned dtls_protocols = SP_PROT_DTLS1_X;
+        const unsigned non_dtls_protocols = (SP_PROT_X_CLIENTS | SP_PROT_X_SERVERS) & ~SP_PROT_DTLS1_X;
 
         status = get_cert(schanCred, &cert);
         if (status != SEC_E_OK && status != SEC_E_NO_CREDENTIALS)
             return status;
 
         cred_enabled_protocols = get_enabled_protocols(schanCred);
-        if ((cred_enabled_protocols & tls_protocols) &&
+        if ((cred_enabled_protocols & non_dtls_protocols) &&
             (cred_enabled_protocols & dtls_protocols)) return SEC_E_ALGORITHM_MISMATCH;
 
         status = SEC_E_OK;
     }
+    else if (fCredentialUse & SECPKG_CRED_INBOUND)
+    {
+        return SEC_E_NO_CREDENTIALS;
+    }
 
     read_config();
     if(schanCred && cred_enabled_protocols)
         enabled_protocols = cred_enabled_protocols & config_enabled_protocols;
     else
         enabled_protocols = config_enabled_protocols & ~config_default_disabled_protocols;
+    if (!(fCredentialUse & SECPKG_CRED_OUTBOUND))
+        enabled_protocols &= ~SP_PROT_X_CLIENTS;
+    if (!(fCredentialUse & SECPKG_CRED_INBOUND))
+        enabled_protocols &= ~SP_PROT_X_SERVERS;
     if(!enabled_protocols) {
         ERR("Could not find matching protocol\n");
-        return SEC_E_NO_AUTHENTICATING_AUTHORITY;
+        return SEC_E_ALGORITHM_MISMATCH;
     }
 
     if (!(creds = malloc(sizeof(*creds)))) return SEC_E_INSUFFICIENT_MEMORY;
-    creds->credential_use = SECPKG_CRED_OUTBOUND;
+    creds->credential_use = fCredentialUse;
     creds->enabled_protocols = enabled_protocols;
 
     if (cert && !(key_blob = get_key_blob(cert, &key_size))) goto fail;
@@ -598,11 +611,18 @@ static SECURITY_STATUS schan_AcquireClientCredentials(const void *schanCred,
     phCredential->dwLower = handle;
     phCredential->dwUpper = 0;
 
-    /* Outbound credentials have no expiry */
     if (ptsExpiry)
     {
-        ptsExpiry->LowPart = 0;
-        ptsExpiry->HighPart = 0;
+        if (fCredentialUse & SECPKG_CRED_INBOUND)
+        {
+            /* FIXME: get expiry from cert */
+        }
+        else
+        {
+            /* Outbound credentials have no expiry */
+            ptsExpiry->LowPart = 0;
+            ptsExpiry->HighPart = 0;
+        }
     }
 
     return status;
@@ -612,54 +632,6 @@ fail:
     return SEC_E_INTERNAL_ERROR;
 }
 
-static SECURITY_STATUS schan_AcquireServerCredentials(const SCHANNEL_CRED *schanCred,
- PCredHandle phCredential, PTimeStamp ptsExpiry)
-{
-    SECURITY_STATUS status;
-    const CERT_CONTEXT *cert = NULL;
-
-    TRACE("schanCred %p, phCredential %p, ptsExpiry %p\n", schanCred, phCredential, ptsExpiry);
-
-    if (!schanCred) return SEC_E_NO_CREDENTIALS;
-
-    status = get_cert(schanCred, &cert);
-    if (status == SEC_E_OK)
-    {
-        ULONG_PTR handle;
-        struct schan_credentials *creds;
-
-        if (!(creds = calloc(1, sizeof(*creds)))) return SEC_E_INSUFFICIENT_MEMORY;
-        creds->credential_use = SECPKG_CRED_INBOUND;
-
-        handle = schan_alloc_handle(creds, SCHAN_HANDLE_CRED);
-        if (handle == SCHAN_INVALID_HANDLE)
-        {
-            free(creds);
-            return SEC_E_INTERNAL_ERROR;
-        }
-
-        phCredential->dwLower = handle;
-        phCredential->dwUpper = 0;
-
-        /* FIXME: get expiry from cert */
-    }
-    return status;
-}
-
-static SECURITY_STATUS schan_AcquireCredentialsHandle(ULONG fCredentialUse,
- const SCHANNEL_CRED *schanCred, PCredHandle phCredential, PTimeStamp ptsExpiry)
-{
-    SECURITY_STATUS ret;
-
-    if (fCredentialUse == SECPKG_CRED_OUTBOUND)
-        ret = schan_AcquireClientCredentials(schanCred, phCredential,
-         ptsExpiry);
-    else
-        ret = schan_AcquireServerCredentials(schanCred, phCredential,
-         ptsExpiry);
-    return ret;
-}
-
 static SECURITY_STATUS SEC_ENTRY schan_AcquireCredentialsHandleA(
  SEC_CHAR *pszPrincipal, SEC_CHAR *pszPackage, ULONG fCredentialUse,
  PLUID pLogonID, PVOID pAuthData, SEC_GET_KEY_FN pGetKeyFn,
@@ -668,7 +640,7 @@ static SECURITY_STATUS SEC_ENTRY schan_AcquireCredentialsHandleA(
     TRACE("(%s, %s, 0x%08lx, %p, %p, %p, %p, %p, %p)\n",
      debugstr_a(pszPrincipal), debugstr_a(pszPackage), fCredentialUse,
      pLogonID, pAuthData, pGetKeyFn, pGetKeyArgument, phCredential, ptsExpiry);
-    return schan_AcquireCredentialsHandle(fCredentialUse,
+    return acquire_credentials_handle(fCredentialUse,
      pAuthData, phCredential, ptsExpiry);
 }
 
@@ -680,7 +652,7 @@ static SECURITY_STATUS SEC_ENTRY schan_AcquireCredentialsHandleW(
     TRACE("(%s, %s, 0x%08lx, %p, %p, %p, %p, %p, %p)\n",
      debugstr_w(pszPrincipal), debugstr_w(pszPackage), fCredentialUse,
      pLogonID, pAuthData, pGetKeyFn, pGetKeyArgument, phCredential, ptsExpiry);
-    return schan_AcquireCredentialsHandle(fCredentialUse,
+    return acquire_credentials_handle(fCredentialUse,
      pAuthData, phCredential, ptsExpiry);
 }
 
@@ -769,14 +741,11 @@ static BOOL validate_input_buffers(SecBufferDesc *desc)
     return TRUE;
 }
 
-/***********************************************************************
- *              InitializeSecurityContextW
- */
-static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
+static SECURITY_STATUS establish_context(
  PCredHandle phCredential, PCtxtHandle phContext, SEC_WCHAR *pszTargetName,
- ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,
- PSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,
- PSecBufferDesc pOutput, ULONG *pfContextAttr, PTimeStamp ptsExpiry)
+ PSecBufferDesc pInput, ULONG fContextReq, ULONG TargetDataRep,
+ PCtxtHandle phNewContext, PSecBufferDesc pOutput, ULONG *pfContextAttr,
+ PTimeStamp ptsTimeStamp, BOOL bIsServer)
 {
     const ULONG extra_size = 0x10000;
     struct schan_context *ctx;
@@ -791,26 +760,20 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
     ULONG input_offset = 0, output_offset = 0;
     SecBufferDesc input_desc, output_desc;
 
-    TRACE("%p %p %s 0x%08lx %ld %ld %p %ld %p %p %p %p\n", phCredential, phContext,
-     debugstr_w(pszTargetName), fContextReq, Reserved1, TargetDataRep, pInput,
-     Reserved1, phNewContext, pOutput, pfContextAttr, ptsExpiry);
-
-    dump_buffer_desc(pInput);
-    dump_buffer_desc(pOutput);
-
-    if (ptsExpiry)
+    if (ptsTimeStamp)
     {
-        ptsExpiry->LowPart = 0;
-        ptsExpiry->HighPart = 0;
+        ptsTimeStamp->LowPart = 0;
+        ptsTimeStamp->HighPart = 0;
     }
 
     if (!pOutput || !pOutput->cBuffers) return SEC_E_INVALID_TOKEN;
     for (i = 0; i < pOutput->cBuffers; i++)
     {
         ULONG type = pOutput->pBuffers[i].BufferType;
+        ULONG allocate_memory_flag = bIsServer ? ASC_REQ_ALLOCATE_MEMORY : ISC_REQ_ALLOCATE_MEMORY;
 
         if (type != SECBUFFER_TOKEN && type != SECBUFFER_ALERT) continue;
-        if (!pOutput->pBuffers[i].cbBuffer && !(fContextReq & ISC_REQ_ALLOCATE_MEMORY))
+        if (!pOutput->pBuffers[i].cbBuffer && !(fContextReq & allocate_memory_flag))
             return SEC_E_INSUFFICIENT_MEMORY;
     }
 
@@ -818,15 +781,16 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
     {
         ULONG_PTR handle;
         struct create_session_params create_params;
+        ULONG credential_use = bIsServer ? SECPKG_CRED_INBOUND : SECPKG_CRED_OUTBOUND;
 
         if (!phCredential) return SEC_E_INVALID_HANDLE;
 
         cred = schan_get_object(phCredential->dwLower, SCHAN_HANDLE_CRED);
         if (!cred) return SEC_E_INVALID_HANDLE;
 
-        if (!(cred->credential_use & SECPKG_CRED_OUTBOUND))
+        if (!(cred->credential_use & credential_use))
         {
-            WARN("Invalid credential use %#lx\n", cred->credential_use);
+            WARN("Invalid credential use %#lx, expected %#lx\n", cred->credential_use, credential_use);
             return SEC_E_INVALID_HANDLE;
         }
 
@@ -848,7 +812,7 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
             return SEC_E_INTERNAL_ERROR;
         }
 
-        if (cred->enabled_protocols & (SP_PROT_DTLS1_0_CLIENT | SP_PROT_DTLS1_2_CLIENT))
+        if (cred->enabled_protocols & SP_PROT_DTLS1_X)
             ctx->header_size = HEADER_SIZE_DTLS;
         else
             ctx->header_size = HEADER_SIZE_TLS;
@@ -894,12 +858,13 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
         phNewContext->dwLower = handle;
         phNewContext->dwUpper = 0;
     }
-    else
+
+    if (bIsServer || phContext)
     {
         SIZE_T record_size = 0;
         unsigned char *ptr;
 
-        if (!(ctx = schan_get_object(phContext->dwLower, SCHAN_HANDLE_CTX))) return SEC_E_INVALID_HANDLE;
+        if (phContext && !(ctx = schan_get_object(phContext->dwLower, SCHAN_HANDLE_CTX))) return SEC_E_INVALID_HANDLE;
         if (!pInput && !ctx->shutdown_requested && !is_dtls_context(ctx)) return SEC_E_INCOMPLETE_MESSAGE;
 
         if (!ctx->shutdown_requested && pInput)
@@ -938,7 +903,7 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
             TRACE("Using expected_size %Iu.\n", expected_size);
         }
 
-        if (phNewContext) *phNewContext = *phContext;
+        if (phNewContext && phContext) *phNewContext = *phContext;
     }
 
     ctx->req_ctx_attr = fContextReq;
@@ -1014,16 +979,45 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
         if (buffer->BufferType == SECBUFFER_ALERT) buffer->cbBuffer = 0;
     }
 
-    *pfContextAttr = ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT | ISC_RET_CONFIDENTIALITY | ISC_RET_STREAM;
-    if (ctx->req_ctx_attr & ISC_REQ_EXTENDED_ERROR) *pfContextAttr |= ISC_RET_EXTENDED_ERROR;
-    if (ctx->req_ctx_attr & ISC_REQ_DATAGRAM) *pfContextAttr |= ISC_RET_DATAGRAM;
-    if (ctx->req_ctx_attr & ISC_REQ_ALLOCATE_MEMORY) *pfContextAttr |= ISC_RET_ALLOCATED_MEMORY;
-    if (ctx->req_ctx_attr & ISC_REQ_USE_SUPPLIED_CREDS) *pfContextAttr |= ISC_RET_USED_SUPPLIED_CREDS;
-    if (ctx->req_ctx_attr & ISC_REQ_MANUAL_CRED_VALIDATION) *pfContextAttr |= ISC_RET_MANUAL_CRED_VALIDATION;
+    if (bIsServer)
+    {
+        *pfContextAttr = ASC_RET_REPLAY_DETECT | ASC_RET_SEQUENCE_DETECT | ASC_RET_CONFIDENTIALITY | ASC_RET_STREAM;
+        if (ctx->req_ctx_attr & ASC_REQ_EXTENDED_ERROR) *pfContextAttr |= ASC_RET_EXTENDED_ERROR;
+        if (ctx->req_ctx_attr & ASC_REQ_DATAGRAM) *pfContextAttr |= ASC_RET_DATAGRAM;
+        if (ctx->req_ctx_attr & ASC_REQ_ALLOCATE_MEMORY) *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY;
+    }
+    else
+    {
+        *pfContextAttr = ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT | ISC_RET_CONFIDENTIALITY | ISC_RET_STREAM;
+        if (ctx->req_ctx_attr & ISC_REQ_EXTENDED_ERROR) *pfContextAttr |= ISC_RET_EXTENDED_ERROR;
+        if (ctx->req_ctx_attr & ISC_REQ_DATAGRAM) *pfContextAttr |= ISC_RET_DATAGRAM;
+        if (ctx->req_ctx_attr & ISC_REQ_ALLOCATE_MEMORY) *pfContextAttr |= ISC_RET_ALLOCATED_MEMORY;
+        if (ctx->req_ctx_attr & ISC_REQ_USE_SUPPLIED_CREDS) *pfContextAttr |= ISC_RET_USED_SUPPLIED_CREDS;
+        if (ctx->req_ctx_attr & ISC_REQ_MANUAL_CRED_VALIDATION) *pfContextAttr |= ISC_RET_MANUAL_CRED_VALIDATION;
+    }
 
     return ret;
 }
 
+/***********************************************************************
+ *              InitializeSecurityContextW
+ */
+static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
+ PCredHandle phCredential, PCtxtHandle phContext, SEC_WCHAR *pszTargetName,
+ ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,
+ PSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,
+ PSecBufferDesc pOutput, ULONG *pfContextAttr, PTimeStamp ptsExpiry)
+{
+    TRACE("%p %p %s 0x%08lx %ld %ld %p %ld %p %p %p %p\n", phCredential, phContext,
+     debugstr_w(pszTargetName), fContextReq, Reserved1, TargetDataRep, pInput,
+     Reserved1, phNewContext, pOutput, pfContextAttr, ptsExpiry);
+
+    dump_buffer_desc(pInput);
+    dump_buffer_desc(pOutput);
+
+    return establish_context(phCredential, phContext, pszTargetName, pInput, fContextReq, TargetDataRep, phNewContext, pOutput, pfContextAttr, ptsExpiry, FALSE);
+}
+
 /***********************************************************************
  *              InitializeSecurityContextA
  */
@@ -1036,7 +1030,7 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextA(
     SECURITY_STATUS ret;
     SEC_WCHAR *target_name = NULL;
 
-    TRACE("%p %p %s %ld %ld %ld %p %ld %p %p %p %p\n", phCredential, phContext,
+    TRACE("%p %p %s 0x%08lx %ld %ld %p %ld %p %p %p %p\n", phCredential, phContext,
      debugstr_a(pszTargetName), fContextReq, Reserved1, TargetDataRep, pInput,
      Reserved1, phNewContext, pOutput, pfContextAttr, ptsExpiry);
 
@@ -1055,6 +1049,23 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextA(
     return ret;
 }
 
+/***********************************************************************
+ *              AcceptSecurityContext
+ */
+static SECURITY_STATUS SEC_ENTRY schan_AcceptSecurityContext(
+ PCredHandle phCredential, PCtxtHandle phContext, PSecBufferDesc pInput,
+ ULONG fContextReq, ULONG TargetDataRep, PCtxtHandle phNewContext,
+ PSecBufferDesc pOutput, ULONG *pfContextAttr, PTimeStamp ptsTimeStamp)
+{
+    TRACE("%p %p %p 0x%08lx %ld %p %p %p %p\n", phCredential, phContext, pInput,
+     fContextReq, TargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp);
+
+    dump_buffer_desc(pInput);
+    dump_buffer_desc(pOutput);
+
+    return establish_context(phCredential, phContext, NULL, pInput, fContextReq, TargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp, TRUE);
+}
+
 static void *get_alg_name(ALG_ID id, BOOL wide)
 {
     static const struct {
@@ -1138,8 +1149,8 @@ static SECURITY_STATUS SEC_ENTRY schan_QueryContextAttributesW(
     TRACE("context_handle %p, attribute %#lx, buffer %p\n",
             context_handle, attribute, buffer);
 
-    if (!context_handle) return SEC_E_INVALID_HANDLE;
-    ctx = schan_get_object(context_handle->dwLower, SCHAN_HANDLE_CTX);
+    if (!context_handle || !(ctx = schan_get_object(context_handle->dwLower, SCHAN_HANDLE_CTX)))
+        return SEC_E_INVALID_HANDLE;
 
     switch(attribute)
     {
@@ -1604,7 +1615,7 @@ static const SecurityFunctionTableA schanTableA = {
     schan_FreeCredentialsHandle,
     NULL, /* Reserved2 */
     schan_InitializeSecurityContextA,
-    NULL, /* AcceptSecurityContext */
+    schan_AcceptSecurityContext,
     NULL, /* CompleteAuthToken */
     schan_DeleteSecurityContext,
     schan_ApplyControlToken, /* ApplyControlToken */
@@ -1635,7 +1646,7 @@ static const SecurityFunctionTableW schanTableW = {
     schan_FreeCredentialsHandle,
     NULL, /* Reserved2 */
     schan_InitializeSecurityContextW,
-    NULL, /* AcceptSecurityContext */
+    schan_AcceptSecurityContext,
     NULL, /* CompleteAuthToken */
     schan_DeleteSecurityContext,
     schan_ApplyControlToken, /* ApplyControlToken */
diff --git a/dlls/secur32/schannel_gnutls.c b/dlls/secur32/schannel_gnutls.c
index b26344aa85e..06d56fccee1 100644
--- a/dlls/secur32/schannel_gnutls.c
+++ b/dlls/secur32/schannel_gnutls.c
@@ -354,10 +354,12 @@ static ssize_t push_adapter(gnutls_transport_ptr_t transport, const void *buff,
     return len;
 }
 
-static const struct {
+struct protocol_priority_flag {
     DWORD enable_flag;
     const char *gnutls_flag;
-} protocol_priority_flags[] = {
+};
+
+static const struct protocol_priority_flag client_protocol_priority_flags[] = {
     {SP_PROT_DTLS1_2_CLIENT, "VERS-DTLS1.2"},
     {SP_PROT_DTLS1_0_CLIENT, "VERS-DTLS1.0"},
     {SP_PROT_TLS1_3_CLIENT, "VERS-TLS1.3"},
@@ -368,33 +370,46 @@ static const struct {
     /* {SP_PROT_SSL2_CLIENT} is not supported by GnuTLS */
 };
 
+static const struct protocol_priority_flag server_protocol_priority_flags[] = {
+    {SP_PROT_DTLS1_2_SERVER, "VERS-DTLS1.2"},
+    {SP_PROT_DTLS1_0_SERVER, "VERS-DTLS1.0"},
+    {SP_PROT_TLS1_3_SERVER, "VERS-TLS1.3"},
+    {SP_PROT_TLS1_2_SERVER, "VERS-TLS1.2"},
+    {SP_PROT_TLS1_1_SERVER, "VERS-TLS1.1"},
+    {SP_PROT_TLS1_0_SERVER, "VERS-TLS1.0"},
+    {SP_PROT_SSL3_SERVER,   "VERS-SSL3.0"}
+    /* {SP_PROT_SSL2_SERVER} is not supported by GnuTLS */
+};
+
 static DWORD supported_protocols;
 
-static void check_supported_protocols(void)
+static void check_supported_protocols(
+ const struct protocol_priority_flag *flags, int num_flags, BOOLEAN server)
 {
+    const char *type_desc = server ? "server" : "client";
     gnutls_session_t session;
     char priority[64];
     unsigned i;
     int err;
 
-    err = pgnutls_init(&session, GNUTLS_CLIENT);
+    err = pgnutls_init(&session, server ? GNUTLS_SERVER : GNUTLS_CLIENT);
     if (err != GNUTLS_E_SUCCESS)
     {
         pgnutls_perror(err);
         return;
     }
 
-    for(i = 0; i < ARRAY_SIZE(protocol_priority_flags); i++)
+    for(i = 0; i < num_flags; i++)
     {
-        sprintf(priority, "NORMAL:-%s", protocol_priority_flags[i].gnutls_flag);
+        sprintf(priority, "NORMAL:-%s", flags[i].gnutls_flag);
         err = pgnutls_priority_set_direct(session, priority, NULL);
         if (err == GNUTLS_E_SUCCESS)
         {
-            TRACE("%s is supported\n", protocol_priority_flags[i].gnutls_flag);
-            supported_protocols |= protocol_priority_flags[i].enable_flag;
+            TRACE("%s %s is supported\n", type_desc, flags[i].gnutls_flag);
+            supported_protocols |= flags[i].enable_flag;
         }
         else
-            TRACE("%s is not supported\n", protocol_priority_flags[i].gnutls_flag);
+            TRACE("%s %s is not supported\n", type_desc, flags[i].gnutls_flag);
     }
 
     pgnutls_deinit(session);
@@ -420,6 +435,11 @@ static int pull_timeout(gnutls_transport_ptr_t transport, unsigned int timeout)
 static NTSTATUS set_priority(schan_credentials *cred, gnutls_session_t session)
 {
     char priority[128] = "NORMAL:%LATEST_RECORD_VERSION", *p;
+    BOOL server = !!(cred->credential_use & SECPKG_CRED_INBOUND);
+    const struct protocol_priority_flag *protocols =
+        server ? server_protocol_priority_flags : client_protocol_priority_flags;
+    int num_protocols = server ? ARRAYSIZE(server_protocol_priority_flags)
+                               : ARRAYSIZE(client_protocol_priority_flags);
     BOOL using_vers_all = FALSE, disabled;
     int i, err;
 
@@ -447,16 +467,16 @@ static NTSTATUS set_priority(schan_credentials *cred, gnutls_session_t session)
         using_vers_all = TRUE;
     }
 
-    for (i = 0; i < ARRAY_SIZE(protocol_priority_flags); i++)
+    for (i = 0; i < num_protocols; i++)
     {
-        if (!(supported_protocols & protocol_priority_flags[i].enable_flag)) continue;
+        if (!(supported_protocols & protocols[i].enable_flag)) continue;
 
-        disabled = !(cred->enabled_protocols & protocol_priority_flags[i].enable_flag);
+        disabled = !(cred->enabled_protocols & protocols[i].enable_flag);
         if (using_vers_all && disabled) continue;
 
         *p++ = ':';
         *p++ = disabled ? '-' : '+';
-        strcpy(p, protocol_priority_flags[i].gnutls_flag);
+        strcpy(p, protocols[i].gnutls_flag);
         p += strlen(p);
     }
 
@@ -483,7 +503,7 @@ static NTSTATUS schan_create_session( void *args )
 
     *params->session = 0;
 
-    if (cred->enabled_protocols & (SP_PROT_DTLS1_0_CLIENT | SP_PROT_DTLS1_2_CLIENT))
+    if (cred->enabled_protocols & SP_PROT_DTLS1_X)
     {
         flags |= GNUTLS_DATAGRAM | GNUTLS_NONBLOCK;
     }
@@ -1505,7 +1525,8 @@ static NTSTATUS process_attach( void *args )
         pgnutls_global_set_log_function(gnutls_log);
     }
 
-    check_supported_protocols();
+    check_supported_protocols(client_protocol_priority_flags, ARRAYSIZE(client_protocol_priority_flags), FALSE);
+    check_supported_protocols(server_protocol_priority_flags, ARRAYSIZE(server_protocol_priority_flags), TRUE);
     return STATUS_SUCCESS;
 
 fail:
diff --git a/dlls/secur32/tests/schannel.c b/dlls/secur32/tests/schannel.c
index 33915351cb3..5153c9b4a1e 100644
--- a/dlls/secur32/tests/schannel.c
+++ b/dlls/secur32/tests/schannel.c
@@ -351,6 +351,8 @@ static void testAcquireSecurityContext(void)
     ok(st == SEC_E_OK, "AcquireCredentialsHandleA failed: %08lx\n", st);
     if(st == SEC_E_OK)
         FreeCredentialsHandle(&cred);
+    st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &cred, NULL);
+    ok(st == SEC_E_NO_CREDENTIALS, "st = %08lx\n", st);
     memset(&cred, 0, sizeof(cred));
     st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND,
      NULL, NULL, NULL, NULL, &cred, &exp);
@@ -363,6 +365,22 @@ static void testAcquireSecurityContext(void)
 
     FreeCredentialsHandle(&cred);
 
+    /* Should fail if no enabled protocols are available */
+    init_cred(&schanCred);
+    schanCred.grbitEnabledProtocols = SP_PROT_TLS1_X_SERVER;
+    st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND, NULL, &schanCred, NULL, NULL, &cred, &exp);
+    ok(st == SEC_E_ALGORITHM_MISMATCH, "st = %08lx\n", st);
+    st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_INBOUND, NULL, &schanCred, NULL, NULL, &cred, &exp);
+    ok(st == SEC_E_OK, "AcquireCredentialsHandleA failed: %08lx\n", st);
+    FreeCredentialsHandle(&cred);
+
+    schanCred.grbitEnabledProtocols = SP_PROT_TLS1_X_CLIENT;
+    st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND, NULL, &schanCred, NULL, NULL, &cred, &exp);
+    ok(st == SEC_E_OK, "AcquireCredentialsHandleA failed: %08lx\n", st);
+    FreeCredentialsHandle(&cred);
+    st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_INBOUND, NULL, &schanCred, NULL, NULL, &cred, &exp);
+    ok(st == SEC_E_ALGORITHM_MISMATCH, "st = %08lx\n", st);
+
     /* Bad version in SCHANNEL_CRED */
     memset(&schanCred, 0, sizeof(schanCred));
     st = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND,
@@ -1511,6 +1529,10 @@ static void test_communication(void)
 
 done:
     DeleteSecurityContext(&context);
+
+    status = QueryContextAttributesW(&context, SECPKG_ATTR_REMOTE_CERT_CONTEXT, (void*)&cert);
+    ok(status == SEC_E_INVALID_HANDLE, "QueryContextAttributesW(SECPKG_ATTR_REMOTE_CERT_CONTEXT) got %08lx\n", status);
+
     FreeCredentialsHandle(&cred_handle);
 
     CertFreeCertificateContext(cert);
@@ -1653,6 +1675,146 @@ static void test_application_protocol_negotiation(void)
     closesocket(sock);
 }
 
+static void test_server_protocol_negotiation(void) {
+    BOOL ret;
+    SECURITY_STATUS status;
+    ULONG attrs;
+    SCHANNEL_CRED client_cred, server_cred;
+    CredHandle client_cred_handle, server_cred_handle;
+    CtxtHandle client_context, server_context, client_context2, server_context2;
+    SecPkgContext_ApplicationProtocol protocol;
+    SecBufferDesc buffers[3];
+    PCCERT_CONTEXT cert;
+    HCRYPTPROV csp;
+    HCRYPTKEY key;
+    CRYPT_KEY_PROV_INFO keyProvInfo;
+    WCHAR ms_def_prov_w[MAX_PATH];
+    unsigned buf_size = 8192;
+    unsigned char *alpn_buffer;
+    unsigned int *extension_len;
+    unsigned short *list_len;
+    int list_start_index, offset = 0;
+
+    if (!pQueryContextAttributesA)
+    {
+        win_skip("Required secur32 functions not available\n");
+        return;
+    }
+
+    lstrcpyW(ms_def_prov_w, MS_DEF_PROV_W);
+    keyProvInfo.pwszContainerName = cspNameW;
+    keyProvInfo.pwszProvName = ms_def_prov_w;
+    keyProvInfo.dwProvType = PROV_RSA_FULL;
+    keyProvInfo.dwFlags = 0;
+    keyProvInfo.cProvParam = 0;
+    keyProvInfo.rgProvParam = NULL;
+    keyProvInfo.dwKeySpec = AT_SIGNATURE;
+
+    cert = CertCreateCertificateContext(X509_ASN_ENCODING, selfSignedCert, sizeof(selfSignedCert));
+    ret = CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0, &keyProvInfo);
+    ok(ret, "CertSetCertificateContextProperty failed: %08lx", GetLastError());
+    ret = CryptAcquireContextW(&csp, cspNameW, MS_DEF_PROV_W, PROV_RSA_FULL, CRYPT_NEWKEYSET);
+    ok(ret, "CryptAcquireContextW failed: %08lx\n", GetLastError());
+    ret = CryptImportKey(csp, privKey, sizeof(privKey), 0, 0, &key);
+    ok(ret, "CryptImportKey failed: %08lx\n", GetLastError());
+    if (!ret) return;
+
+    init_cred(&client_cred);
+    init_cred(&server_cred);
+    client_cred.grbitEnabledProtocols = SP_PROT_TLS1_CLIENT;
+    client_cred.dwFlags = SCH_CRED_NO_DEFAULT_CREDS|SCH_CRED_MANUAL_CRED_VALIDATION;
+    server_cred.grbitEnabledProtocols = SP_PROT_TLS1_SERVER;
+    server_cred.dwFlags = SCH_CRED_NO_DEFAULT_CREDS|SCH_CRED_MANUAL_CRED_VALIDATION;
+    server_cred.cCreds = 1;
+    server_cred.paCred = &cert;
+
+    status = AcquireCredentialsHandleA(NULL, (SEC_CHAR *)UNISP_NAME_A, SECPKG_CRED_OUTBOUND, NULL, &client_cred, NULL, NULL, &client_cred_handle, NULL);
+    ok(status == SEC_E_OK, "got %08lx\n", status);
+    if (status != SEC_E_OK) return;
+    status = AcquireCredentialsHandleA(NULL, (SEC_CHAR *)UNISP_NAME_A, SECPKG_CRED_INBOUND,  NULL, &server_cred, NULL, NULL, &server_cred_handle, NULL);
+    ok(status == SEC_E_OK, "got %08lx\n", status);
+    if (status != SEC_E_OK) return;
+
+    init_buffers(&buffers[0], 4, buf_size);
+    init_buffers(&buffers[1], 4, buf_size);
+    init_buffers(&buffers[2], 1, 128);
+
+    alpn_buffer = buffers[2].pBuffers[0].pvBuffer;
+    extension_len = (unsigned int *)&alpn_buffer[offset];
+    offset += sizeof(*extension_len);
+    *(unsigned int *)&alpn_buffer[offset] = SecApplicationProtocolNegotiationExt_ALPN;
+    offset += sizeof(unsigned int);
+    list_len = (unsigned short *)&alpn_buffer[offset];
+    offset += sizeof(*list_len);
+    list_start_index = offset;
+
+    alpn_buffer[offset++] = sizeof("http/1.1") - 1;
+    memcpy(&alpn_buffer[offset], "http/1.1", sizeof("http/1.1") - 1);
+    offset += sizeof("http/1.1") - 1;
+    alpn_buffer[offset++] = sizeof("h2") - 1;
+    memcpy(&alpn_buffer[offset], "h2", sizeof("h2") - 1);
+    offset += sizeof("h2") - 1;
+
+    *list_len = offset - list_start_index;
+    *extension_len = *list_len + sizeof(*extension_len) + sizeof(*list_len);
+
+    buffers[2].pBuffers[0].BufferType = SECBUFFER_APPLICATION_PROTOCOLS;
+    buffers[2].pBuffers[0].cbBuffer = offset;
+    buffers[0].pBuffers[0].BufferType = SECBUFFER_TOKEN;
+    status = InitializeSecurityContextA(&client_cred_handle, NULL, (SEC_CHAR *)"localhost", ISC_REQ_CONFIDENTIALITY|ISC_REQ_STREAM, 0, 0, &buffers[2], 0, &client_context, &buffers[0], &attrs, NULL);
+    ok(status == SEC_I_CONTINUE_NEEDED, "got %08lx\n", status);
+
+    buffers[1].pBuffers[0].cbBuffer = buf_size;
+    buffers[1].pBuffers[0].BufferType = SECBUFFER_TOKEN;
+    buffers[0].pBuffers[1] = buffers[2].pBuffers[0];
+    status = AcceptSecurityContext(&server_cred_handle, NULL, &buffers[0], ASC_REQ_CONFIDENTIALITY|ASC_REQ_STREAM, 0, &server_context, &buffers[1], &attrs, NULL);
+    ok(status == SEC_I_CONTINUE_NEEDED, "got %08lx\n", status);
+    memset(&buffers[0].pBuffers[1], 0, sizeof(buffers[0].pBuffers[1]));
+
+    client_context2.dwLower = client_context2.dwUpper = 0xdeadbeef;
+    buffers[0].pBuffers[0].cbBuffer = buf_size;
+    status = InitializeSecurityContextA(&client_cred_handle, &client_context, (SEC_CHAR *)"localhost", ISC_REQ_CONFIDENTIALITY|ISC_REQ_STREAM|ISC_REQ_USE_SUPPLIED_CREDS, 0, 0, &buffers[1], 0, &client_context2, &buffers[0], &attrs, NULL);
+    ok(client_context.dwLower == client_context2.dwLower, "dwLower mismatch, expected %#Ix, got %#Ix\n", client_context.dwLower, client_context2.dwLower);
+    ok(client_context.dwUpper == client_context2.dwUpper, "dwUpper mismatch, expected %#Ix, got %#Ix\n", client_context.dwUpper, client_context2.dwUpper);
+    ok(status == SEC_I_CONTINUE_NEEDED, "got %08lx\n", status);
+
+    server_context2.dwLower = server_context2.dwUpper = 0xdeadbeef;
+    buffers[1].pBuffers[0].cbBuffer = buf_size;
+    status = AcceptSecurityContext(&server_cred_handle, &server_context, &buffers[0], ASC_REQ_CONFIDENTIALITY|ASC_REQ_STREAM, 0, &server_context2, &buffers[1], &attrs, NULL);
+    ok(server_context.dwLower == server_context2.dwLower, "dwLower mismatch, expected %#Ix, got %#Ix\n", server_context.dwLower, server_context2.dwLower);
+    ok(server_context.dwUpper == server_context2.dwUpper, "dwUpper mismatch, expected %#Ix, got %#Ix\n", server_context.dwUpper, server_context2.dwUpper);
+    ok(status == SEC_E_OK, "got %08lx\n", status);
+
+    buffers[0].pBuffers[0].cbBuffer = buf_size;
+    status = InitializeSecurityContextA(&client_cred_handle, &client_context, (SEC_CHAR *)"localhost", ISC_REQ_USE_SUPPLIED_CREDS, 0, 0, &buffers[1], 0, NULL, &buffers[0], &attrs, NULL);
+    ok(status == SEC_E_OK, "got %08lx\n", status);
+
+    memset(&protocol, 0, sizeof(protocol));
+    status = pQueryContextAttributesA(&client_context, SECPKG_ATTR_APPLICATION_PROTOCOL, &protocol);
+    ok(status == SEC_E_OK || broken(status == SEC_E_UNSUPPORTED_FUNCTION) /* win2k8 */, "got %08lx\n", status);
+    if (status == SEC_E_OK)
+    {
+        ok(protocol.ProtoNegoStatus == SecApplicationProtocolNegotiationStatus_Success, "got %u\n", protocol.ProtoNegoStatus);
+        ok(protocol.ProtoNegoExt == SecApplicationProtocolNegotiationExt_ALPN, "got %u\n", protocol.ProtoNegoExt);
+        ok(protocol.ProtocolIdSize == 8, "got %u\n", protocol.ProtocolIdSize);
+        ok(!memcmp(protocol.ProtocolId, "http/1.1", 8), "wrong protocol id\n");
+    }
+
+    DeleteSecurityContext(&client_context);
+    DeleteSecurityContext(&server_context);
+    FreeCredentialsHandle(&client_cred_handle);
+    FreeCredentialsHandle(&server_cred_handle);
+
+    free_buffers(&buffers[0]);
+    free_buffers(&buffers[1]);
+    free_buffers(&buffers[2]);
+
+    CryptDestroyKey(key);
+    CryptReleaseContext(csp, 0);
+    CryptAcquireContextW(&csp, cspNameW, MS_DEF_PROV_W, PROV_RSA_FULL, CRYPT_DELETEKEYSET);
+    CertFreeCertificateContext(cert);
+}
+
 static void init_dtls_output_buffer(SecBufferDesc *buffer)
 {
     buffer->pBuffers[0].BufferType = SECBUFFER_TOKEN;
@@ -1668,7 +1830,7 @@ static void test_dtls(void)
     SECURITY_STATUS status;
     TimeStamp exp;
     SCHANNEL_CRED cred;
-    CredHandle cred_handle;
+    CredHandle cred_handle, cred_handle2;
     CtxtHandle ctx_handle, ctx_handle2;
     SecBufferDesc buffers[3];
     ULONG flags_req, flags_ret, attr, prev_buf_len;
@@ -1687,6 +1849,19 @@ static void test_dtls(void)
     }
     ok( status == SEC_E_OK, "got %08lx\n", status );
 
+    /* Should fail if both DTLS and TLS protocols are requested */
+    cred.grbitEnabledProtocols |= SP_PROT_TLS1_CLIENT;
+    status = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND, NULL, &cred, NULL, NULL, &cred_handle2, &exp);
+    ok(status == SEC_E_ALGORITHM_MISMATCH, "status = %08lx\n", status);
+
+    cred.grbitEnabledProtocols = SP_PROT_DTLS1_X_CLIENT | SP_PROT_TLS1_SERVER;
+    status = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND, NULL, &cred, NULL, NULL, &cred_handle2, &exp);
+    ok(status == SEC_E_ALGORITHM_MISMATCH, "status = got %08lx\n", status);
+
+    cred.grbitEnabledProtocols = SP_PROT_DTLS1_X_CLIENT | SP_PROT_SSL3_SERVER;
+    status = AcquireCredentialsHandleA(NULL, unisp_name_a, SECPKG_CRED_OUTBOUND, NULL, &cred, NULL, NULL, &cred_handle2, &exp);
+    ok(status == SEC_E_ALGORITHM_MISMATCH, "status = got %08lx\n", status);
+
     flags_req = ISC_REQ_MANUAL_CRED_VALIDATION | ISC_REQ_EXTENDED_ERROR | ISC_REQ_DATAGRAM | ISC_REQ_USE_SUPPLIED_CREDS |
                 ISC_REQ_CONFIDENTIALITY | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT;
     test_context_output_buffer_size(SP_PROT_DTLS_CLIENT | SP_PROT_DTLS1_2_CLIENT, SCH_CRED_NO_DEFAULT_CREDS, flags_req);
@@ -1918,6 +2093,7 @@ START_TEST(schannel)
     test_InitializeSecurityContext();
     test_communication();
     test_application_protocol_negotiation();
+    test_server_protocol_negotiation();
     test_dtls();
     test_connection_shutdown();
 }
diff --git a/dlls/setupapi/dialog.c b/dlls/setupapi/dialog.c
index 5a0eadcb760..6515027484a 100644
--- a/dlls/setupapi/dialog.c
+++ b/dlls/setupapi/dialog.c
@@ -73,7 +73,7 @@ static void promptdisk_init(HWND hwnd, struct promptdisk_params *params)
             args[1] = (DWORD_PTR)unknown;
         }
         FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                       format, 0, 0, message, ARRAY_SIZE(message), (__ms_va_list*)args);
+                       format, 0, 0, message, ARRAY_SIZE(message), (va_list *)args);
         SetDlgItemTextW(hwnd, IDC_FILENEEDED, message);
 
         LoadStringW(SETUPAPI_hInstance, IDS_INFO, message, ARRAY_SIZE(message));
diff --git a/dlls/setupapi/install.c b/dlls/setupapi/install.c
index 532ac6c36a6..8a28bfcc4e1 100644
--- a/dlls/setupapi/install.c
+++ b/dlls/setupapi/install.c
@@ -19,6 +19,7 @@
  */
 
 #include <stdarg.h>
+#include <stdbool.h>
 
 #define COBJMACROS
 
@@ -227,17 +228,45 @@ static HKEY get_root_key( const WCHAR *name, HKEY def_root )
  *
  * Append a multisz string to a multisz registry value.
  */
-static void append_multi_sz_value( HKEY hkey, const WCHAR *value, const WCHAR *strings,
+static bool append_multi_sz_value( HKEY hkey, const WCHAR *value, const WCHAR *strings,
                                    DWORD str_size )
 {
     DWORD size, type, total;
     WCHAR *buffer, *p;
+    LONG ret;
 
-    if (RegQueryValueExW( hkey, value, NULL, &type, NULL, &size )) return;
-    if (type != REG_MULTI_SZ) return;
+    if ((ret = RegQueryValueExW( hkey, value, NULL, &type, NULL, &size )))
+    {
+        if (ret != ERROR_FILE_NOT_FOUND)
+        {
+            ERR( "failed to query value %s, error %lu\n", debugstr_w(value), ret );
+            SetLastError( ret );
+            return false;
+        }
 
-    if (!(buffer = HeapAlloc( GetProcessHeap(), 0, (size + str_size) * sizeof(WCHAR) ))) return;
-    if (RegQueryValueExW( hkey, value, NULL, NULL, (BYTE *)buffer, &size )) goto done;
+        if ((ret = RegSetValueExW( hkey, value, 0, REG_MULTI_SZ, (BYTE *)strings, str_size * sizeof(WCHAR) )))
+        {
+            ERR( "failed to set value %s, error %lu\n", debugstr_w(value), ret );
+            SetLastError( ret );
+            return false;
+        }
+
+        return true;
+    }
+
+    if (type != REG_MULTI_SZ)
+    {
+        WARN( "value %s exists but has wrong type %#lx\n", debugstr_w(value), type );
+        SetLastError( ERROR_INVALID_DATA );
+        return false;
+    }
+
+    if (!(buffer = HeapAlloc( GetProcessHeap(), 0, (size + str_size) * sizeof(WCHAR) ))) return false;
+    if (RegQueryValueExW( hkey, value, NULL, NULL, (BYTE *)buffer, &size ))
+    {
+        HeapFree( GetProcessHeap(), 0, buffer );
+        return false;
+    }
 
     /* compare each string against all the existing ones */
     total = size;
@@ -261,8 +290,9 @@ static void append_multi_sz_value( HKEY hkey, const WCHAR *value, const WCHAR *s
         TRACE( "setting value %s to %s\n", debugstr_w(value), debugstr_w(buffer) );
         RegSetValueExW( hkey, value, 0, REG_MULTI_SZ, (BYTE *)buffer, total );
     }
- done:
+
     HeapFree( GetProcessHeap(), 0, buffer );
+    return true;
 }
 
 
@@ -374,7 +404,11 @@ static BOOL do_reg_operation( HKEY hkey, const WCHAR *value, INFCONTEXT *context
             if (flags & FLG_ADDREG_APPEND)
             {
                 if (!str) return TRUE;
-                append_multi_sz_value( hkey, value, str, size );
+                if (!append_multi_sz_value( hkey, value, str, size ))
+                {
+                    HeapFree( GetProcessHeap(), 0, str );
+                    return FALSE;
+                }
                 HeapFree( GetProcessHeap(), 0, str );
                 return TRUE;
             }
diff --git a/dlls/setupapi/misc.c b/dlls/setupapi/misc.c
index f9d34b5353d..5a4b899dc9d 100644
--- a/dlls/setupapi/misc.c
+++ b/dlls/setupapi/misc.c
@@ -740,7 +740,7 @@ fail:;
 DWORD WINAPI RetreiveFileSecurity(LPCWSTR lpFileName,
                                   PSECURITY_DESCRIPTOR *pSecurityDescriptor)
 {
-    PSECURITY_DESCRIPTOR SecDesc;
+    SECURITY_DESCRIPTOR *SecDesc, *NewSecDesc;
     DWORD dwSize = 0x100;
     DWORD dwError;
 
@@ -763,9 +763,13 @@ DWORD WINAPI RetreiveFileSecurity(LPCWSTR lpFileName,
         return dwError;
     }
 
-    SecDesc = MyRealloc(SecDesc, dwSize);
-    if (SecDesc == NULL)
+    NewSecDesc = MyRealloc(SecDesc, dwSize);
+    if (NewSecDesc == NULL)
+    {
+        MyFree(SecDesc);
         return ERROR_NOT_ENOUGH_MEMORY;
+    }
+    SecDesc = NewSecDesc;
 
     if (GetFileSecurityW(lpFileName, OWNER_SECURITY_INFORMATION |
                          GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
diff --git a/dlls/setupapi/tests/install.c b/dlls/setupapi/tests/install.c
index 2bbcbec88dc..318f1294210 100644
--- a/dlls/setupapi/tests/install.c
+++ b/dlls/setupapi/tests/install.c
@@ -2297,6 +2297,102 @@ static void test_rename(void)
     ok(ret, "Failed to delete directory, error %lu.\n", GetLastError());
 }
 
+static void test_append_reg(void)
+{
+    static const char inf_data[] = "[Version]\n"
+            "Signature=\"$Chicago$\"\n"
+            "[DefaultInstall]\n"
+            "AddReg=reg_section\n"
+            "[reg_section]\n"
+            "HKCU,Software\\winetest_setupapi,value,0x10008,\"data\"\n";
+
+    void *context = SetupInitDefaultQueueCallbackEx(NULL, INVALID_HANDLE_VALUE, 0, 0, 0);
+    char path[MAX_PATH];
+    DWORD type, size;
+    char value[20];
+    HINF hinf;
+    BOOL ret;
+    HKEY key;
+    LONG l;
+
+    create_inf_file("test.inf", inf_data);
+    sprintf(path, "%s\\test.inf", CURR_DIR);
+    hinf = SetupOpenInfFileA(path, NULL, INF_STYLE_WIN4, NULL);
+    ok(hinf != INVALID_HANDLE_VALUE, "Failed to open INF file, error %#lx.\n", GetLastError());
+
+    /* Key doesn't exist yet. */
+
+    RegDeleteKeyA(HKEY_CURRENT_USER, "winetest_setupapi");
+
+    ret = SetupInstallFromInfSectionA(NULL, hinf, "DefaultInstall", SPINST_REGISTRY,
+            NULL, "C:\\", 0, SetupDefaultQueueCallbackA, context, NULL, NULL);
+    ok(ret, "Failed to install, error %#lx.\n", GetLastError());
+
+    l = RegOpenKeyA(HKEY_CURRENT_USER, "Software\\winetest_setupapi", &key);
+    ok(!l, "Got error %lu.\n", l);
+    size = sizeof(value);
+    l = RegQueryValueExA(key, "value", NULL, &type, (BYTE *)value, &size);
+    ok(!l, "Got error %lu.\n", l);
+    ok(type == REG_MULTI_SZ, "Got type %#lx.\n", type);
+    ok(size == sizeof("data\0"), "Got size %lu.\n", size);
+    ok(!memcmp(value, "data\0", size), "Got data %s.\n", debugstr_an(value, size));
+
+    /* Key exists and already has a value. */
+
+    l = RegSetValueExA(key, "value", 0, REG_MULTI_SZ, (const BYTE *)"foo\0bar\0", sizeof("foo\0bar\0"));
+    ok(!l, "Got error %lu.\n", l);
+
+    ret = SetupInstallFromInfSectionA(NULL, hinf, "DefaultInstall", SPINST_REGISTRY,
+            NULL, "C:\\", 0, SetupDefaultQueueCallbackA, context, NULL, NULL);
+    ok(ret, "Failed to install, error %#lx.\n", GetLastError());
+
+    size = sizeof(value);
+    l = RegQueryValueExA(key, "value", NULL, &type, (BYTE *)value, &size);
+    ok(!l, "Got error %lu.\n", l);
+    ok(type == REG_MULTI_SZ, "Got type %#lx.\n", type);
+    ok(size == sizeof("foo\0bar\0data\0"), "Got size %lu.\n", size);
+    ok(!memcmp(value, "foo\0bar\0data\0", size), "Got data %s.\n", debugstr_an(value, size));
+
+    /* Key exists and already has the value to be added. */
+
+    ret = SetupInstallFromInfSectionA(NULL, hinf, "DefaultInstall", SPINST_REGISTRY,
+            NULL, "C:\\", 0, SetupDefaultQueueCallbackA, context, NULL, NULL);
+    ok(ret, "Failed to install, error %#lx.\n", GetLastError());
+
+    size = sizeof(value);
+    l = RegQueryValueExA(key, "value", NULL, &type, (BYTE *)value, &size);
+    ok(!l, "Got error %lu.\n", l);
+    ok(type == REG_MULTI_SZ, "Got type %#lx.\n", type);
+    ok(size == sizeof("foo\0bar\0data\0"), "Got size %lu.\n", size);
+    ok(!memcmp(value, "foo\0bar\0data\0", size), "Got data %s.\n", debugstr_an(value, size));
+
+    /* Key exists and already has a value of the wrong type. */
+
+    l = RegSetValueExA(key, "value", 0, REG_SZ, (const BYTE *)"string", sizeof("string"));
+    ok(!l, "Got error %lu.\n", l);
+
+    ret = SetupInstallFromInfSectionA(NULL, hinf, "DefaultInstall", SPINST_REGISTRY,
+            NULL, "C:\\", 0, SetupDefaultQueueCallbackA, context, NULL, NULL);
+    ok(!ret, "Expected failure.\n");
+    ok(GetLastError() == ERROR_INVALID_DATA, "Got error %#lx.\n", GetLastError());
+
+    size = sizeof(value);
+    l = RegQueryValueExA(key, "value", NULL, &type, (BYTE *)value, &size);
+    ok(!l, "Got error %lu.\n", l);
+    ok(type == REG_SZ, "Got type %#lx.\n", type);
+    ok(size == sizeof("string"), "Got size %lu.\n", size);
+    ok(!memcmp(value, "string", size), "Got data %s.\n", debugstr_an(value, size));
+
+    RegCloseKey(key);
+
+    l = RegDeleteKeyA(HKEY_CURRENT_USER, "Software\\winetest_setupapi");
+    ok(!l, "Got error %lu.\n", l);
+
+    SetupCloseInfFile(hinf);
+    ret = DeleteFileA("test.inf");
+    ok(ret, "Failed to delete INF file, error %lu.\n", GetLastError());
+}
+
 static WCHAR service_name[] = L"Wine Test Service";
 static SERVICE_STATUS_HANDLE service_handle;
 static HANDLE stop_event;
@@ -2406,6 +2502,7 @@ START_TEST(install)
     test_start_copy();
     test_register_dlls();
     test_rename();
+    test_append_reg();
 
     UnhookWindowsHookEx(hhook);
 
diff --git a/dlls/shell.dll16/shell.c b/dlls/shell.dll16/shell.c
index bc3cfdfc97d..342adeb9a4a 100644
--- a/dlls/shell.dll16/shell.c
+++ b/dlls/shell.dll16/shell.c
@@ -670,7 +670,7 @@ HINSTANCE16 WINAPI ShellExecute16( HWND16 hWnd, LPCSTR lpOperation,
  * Only exported from shell32 on Windows, probably imported
  * from shell through the 16/32 thunks.
  */
-void WINAPI RunDLL_CallEntry16( DWORD proc, HWND hwnd, HINSTANCE inst, LPCSTR cmdline, INT cmdshow )
+void WINAPI RunDLL_CallEntry16( DWORD proc, HWND hwnd, HINSTANCE inst, LPSTR cmdline, INT cmdshow )
 {
     WORD args[5];
     SEGPTR cmdline_seg;
diff --git a/dlls/shell32/dde.c b/dlls/shell32/dde.c
index 96b5a243f93..24294d69fe2 100644
--- a/dlls/shell32/dde.c
+++ b/dlls/shell32/dde.c
@@ -145,9 +145,9 @@ static inline HDDEDATA Dde_OnRequest(UINT uFmt, HCONV hconv, HSZ hszTopic,
         WIN32_FIND_DATAW finddata;
         HANDLE hfind;
         int len = 1;
-        WCHAR *groups_data = malloc(sizeof(WCHAR));
+        WCHAR *groups_data = malloc(sizeof(WCHAR)), *new_groups_data;
         char *groups_dataA;
-        HDDEDATA ret;
+        HDDEDATA ret = NULL;
 
         groups_data[0] = 0;
         programs = get_programs_path(L"*", FALSE);
@@ -160,7 +160,14 @@ static inline HDDEDATA Dde_OnRequest(UINT uFmt, HCONV hconv, HSZ hszTopic,
                     wcscmp(finddata.cFileName, L".") && wcscmp(finddata.cFileName, L".."))
                 {
                     len += lstrlenW(finddata.cFileName) + 2;
-                    groups_data = realloc(groups_data, len * sizeof(WCHAR));
+                    new_groups_data = realloc(groups_data, len * sizeof(WCHAR));
+                    if (!new_groups_data)
+                    {
+                        free(groups_data);
+                        free(programs);
+                        return NULL;
+                    }
+                    groups_data = new_groups_data;
                     lstrcatW(groups_data, finddata.cFileName);
                     lstrcatW(groups_data, L"\r\n");
                 }
@@ -170,8 +177,11 @@ static inline HDDEDATA Dde_OnRequest(UINT uFmt, HCONV hconv, HSZ hszTopic,
 
         len = WideCharToMultiByte(CP_ACP, 0, groups_data, -1, NULL, 0, NULL, NULL);
         groups_dataA = malloc(len * sizeof(WCHAR));
-        WideCharToMultiByte(CP_ACP, 0, groups_data, -1, groups_dataA, len, NULL, NULL);
-        ret = DdeCreateDataHandle(dwDDEInst, (BYTE *)groups_dataA, len, 0, hszGroups, uFmt, 0);
+        if (groups_dataA)
+        {
+            WideCharToMultiByte(CP_ACP, 0, groups_data, -1, groups_dataA, len, NULL, NULL);
+            ret = DdeCreateDataHandle(dwDDEInst, (BYTE *)groups_dataA, len, 0, hszGroups, uFmt, 0);
+        }
 
         free(groups_dataA);
         free(groups_data);
@@ -337,7 +347,7 @@ static DWORD PROGMAN_OnExecute(WCHAR *command, int argc, WCHAR **argv)
 static DWORD parse_dde_command(HSZ hszTopic, WCHAR *command)
 {
     WCHAR *original = command;
-    WCHAR *opcode = NULL, **argv = NULL, *p;
+    WCHAR *opcode = NULL, **argv = NULL, **new_argv, *p;
     int argc = 0, i;
     DWORD ret = DDE_FACK;
 
@@ -347,7 +357,7 @@ static DWORD parse_dde_command(HSZ hszTopic, WCHAR *command)
     while (*command == '[')
     {
         argc = 0;
-        argv = malloc(sizeof(*argv));
+        argv = NULL;
 
         command++;
         while (*command == ' ') command++;
@@ -375,9 +385,11 @@ static DWORD parse_dde_command(HSZ hszTopic, WCHAR *command)
                     while (p[-1] == ' ') p--;
                 }
 
+                new_argv = realloc(argv, (argc + 1) * sizeof(*argv));
+                if (!new_argv) goto error;
+                argv = new_argv;
+                argv[argc] = strndupW(command, p - command);
                 argc++;
-                argv = realloc(argv, argc * sizeof(*argv));
-                argv[argc-1] = strndupW(command, p - command);
 
                 command = p;
                 if (*command == '"') command++;
diff --git a/dlls/shell32/shfldr_fs.c b/dlls/shell32/shfldr_fs.c
index 662d8b52d5b..609a5c5ee6e 100644
--- a/dlls/shell32/shfldr_fs.c
+++ b/dlls/shell32/shfldr_fs.c
@@ -347,7 +347,7 @@ IShellFolder_fnParseDisplayName (IShellFolder2 * iface,
         /* Special case for the root folder. */
         if (!wcsicmp( szPath, L"\\\\?\\unix\\" ))
         {
-            *ppidl = SHAlloc(sizeof(USHORT));
+            *ppidl = SHAlloc(sizeof(**ppidl));
             if (!*ppidl) return E_FAIL;
             (*ppidl)->mkid.cb = 0; /* Terminate the ITEMIDLIST */
             return S_OK;
diff --git a/dlls/shlwapi/tests/clist.c b/dlls/shlwapi/tests/clist.c
index 5f88e92a5a6..54bff21ae8d 100644
--- a/dlls/shlwapi/tests/clist.c
+++ b/dlls/shlwapi/tests/clist.c
@@ -567,7 +567,7 @@ static void test_IStream_Read(void)
 static void test_IStream_Write(void)
 {
   struct dummystream streamobj;
-  char buff[256];
+  char buff[256] = {0};
   HRESULT hRet;
 
   if (!pIStream_Write)
diff --git a/dlls/spoolss/tests/spoolss.c b/dlls/spoolss/tests/spoolss.c
index ce55cf50220..07af82e56ac 100644
--- a/dlls/spoolss/tests/spoolss.c
+++ b/dlls/spoolss/tests/spoolss.c
@@ -208,7 +208,7 @@ START_TEST(spoolss)
 {
     LPCSTR ptr;
 
-    /* The tests fail on Win7 (see comments in load_function() */
+    /* The tests fail on Win7 (see comments in load_functions() */
     ptr = load_functions();
     if (ptr) {
         win_skip("%s not found\n", ptr);
diff --git a/dlls/twain_32/dsm_ctrl.c b/dlls/twain_32/dsm_ctrl.c
index 6854093017a..13503e6772c 100644
--- a/dlls/twain_32/dsm_ctrl.c
+++ b/dlls/twain_32/dsm_ctrl.c
@@ -53,6 +53,7 @@ twain_add_onedriver(const WCHAR *dsname) {
 	DSENTRYPROC	dsEntry;
 	TW_IDENTITY	fakeOrigin;
 	TW_IDENTITY	sourceId;
+	struct all_devices *new_devices;
 	TW_UINT16	ret;
         WCHAR path[MAX_PATH];
 
@@ -89,7 +90,10 @@ twain_add_onedriver(const WCHAR *dsname) {
 		}
 		if (i < nrdevices)
 			break;
-                devices = realloc( devices, sizeof(devices[0])*(nrdevices+1) );
+		new_devices = realloc( devices, sizeof(devices[0]) * (nrdevices + 1) );
+		if (!new_devices)
+			break;
+		devices = new_devices;
 		devices[nrdevices].modname = wcsdup( path );
 		devices[nrdevices].identity = sourceId;
 		nrdevices++;
diff --git a/dlls/uiautomationcore/Makefile.in b/dlls/uiautomationcore/Makefile.in
index 9910e8e336e..28d814e6ee6 100644
--- a/dlls/uiautomationcore/Makefile.in
+++ b/dlls/uiautomationcore/Makefile.in
@@ -6,9 +6,12 @@ EXTRADLLFLAGS = -Wb,--prefer-native
 
 C_SRCS = \
 	uia_client.c \
+	uia_com_client.c \
 	uia_ids.c \
 	uia_main.c \
 	uia_provider.c
 
 IDL_SRCS = \
-	uia_classes.idl
+	uia_classes.idl \
+	uia_classes_client.idl \
+	uia_classes_core.idl
diff --git a/dlls/uiautomationcore/tests/uiautomation.c b/dlls/uiautomationcore/tests/uiautomation.c
index 3756b5cbf1a..73b0db3073c 100644
--- a/dlls/uiautomationcore/tests/uiautomation.c
+++ b/dlls/uiautomationcore/tests/uiautomation.c
@@ -1103,12 +1103,19 @@ struct Provider_prop_override
     VARIANT val;
 };
 
+struct Provider_value_pattern_data
+{
+    BOOL is_supported;
+    BOOL is_read_only;
+};
+
 static struct Provider
 {
     IRawElementProviderSimple IRawElementProviderSimple_iface;
     IRawElementProviderFragment IRawElementProviderFragment_iface;
     IRawElementProviderFragmentRoot IRawElementProviderFragmentRoot_iface;
     IRawElementProviderHwndOverride IRawElementProviderHwndOverride_iface;
+    IValueProvider IValueProvider_iface;
     LONG ref;
 
     const char *prov_name;
@@ -1128,8 +1135,11 @@ static struct Provider
     HWND override_hwnd;
     struct Provider_prop_override *prop_override;
     int prop_override_count;
+    struct UiaRect bounds_rect;
+    struct Provider_value_pattern_data value_pattern_data;
 } Provider, Provider2, Provider_child, Provider_child2;
 static struct Provider Provider_hwnd, Provider_nc, Provider_proxy, Provider_proxy2, Provider_override;
+static void initialize_provider(struct Provider *prov, int prov_opts, HWND hwnd, BOOL initialize_nav_links);
 
 static const WCHAR *uia_bstr_prop_str = L"uia-string";
 static const ULONG uia_i4_prop_val = 0xdeadbeef;
@@ -1182,21 +1192,25 @@ static SAFEARRAY *create_unk_safearray(void)
 
 enum {
     PROV_GET_PROVIDER_OPTIONS,
+    PROV_GET_PATTERN_PROV,
     PROV_GET_PROPERTY_VALUE,
     PROV_GET_HOST_RAW_ELEMENT_PROVIDER,
     FRAG_NAVIGATE,
     FRAG_GET_RUNTIME_ID,
     FRAG_GET_FRAGMENT_ROOT,
+    FRAG_GET_BOUNDING_RECT,
     HWND_OVERRIDE_GET_OVERRIDE_PROVIDER,
 };
 
 static const char *prov_method_str[] = {
     "get_ProviderOptions",
+    "GetPatternProvider",
     "GetPropertyValue",
     "get_HostRawElementProvider",
     "Navigate",
     "GetRuntimeId",
     "get_FragmentRoot",
+    "get_BoundingRectangle",
     "GetOverrideProviderForHwnd",
 };
 
@@ -1222,6 +1236,31 @@ struct prov_method_sequence {
 static int sequence_cnt, sequence_size;
 static struct prov_method_sequence *sequence;
 
+/*
+ * This sequence of method calls is always used when creating an HUIANODE from
+ * an IRawElementProviderSimple.
+ */
+#define NODE_CREATE_SEQ(prov) \
+    { prov , PROV_GET_PROVIDER_OPTIONS }, \
+    /* Win10v1507 and below call this. */ \
+    { prov , PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */ \
+    { prov , PROV_GET_HOST_RAW_ELEMENT_PROVIDER }, \
+    { prov , PROV_GET_PROPERTY_VALUE }, \
+    { prov , FRAG_NAVIGATE }, /* NavigateDirection_Parent */ \
+    { prov , PROV_GET_PROVIDER_OPTIONS, METHOD_OPTIONAL } \
+
+/*
+ * This sequence of method calls is always used when creating an HUIANODE from
+ * an IRawElementProviderSimple that returns an HWND from get_HostRawElementProvider.
+ */
+#define NODE_CREATE_SEQ2(prov) \
+    { prov , PROV_GET_PROVIDER_OPTIONS }, \
+    /* Win10v1507 and below call this. */ \
+    { prov , PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */ \
+    { prov , PROV_GET_HOST_RAW_ELEMENT_PROVIDER }, \
+    { prov , FRAG_NAVIGATE }, /* NavigateDirection_Parent */ \
+    { prov , PROV_GET_PROVIDER_OPTIONS, METHOD_OPTIONAL } \
+
 static void flush_method_sequence(void)
 {
     HeapFree(GetProcessHeap(), 0, sequence);
@@ -1515,6 +1554,8 @@ HRESULT WINAPI ProviderSimple_QueryInterface(IRawElementProviderSimple *iface, R
         *ppv = &This->IRawElementProviderFragmentRoot_iface;
     else if (IsEqualIID(riid, &IID_IRawElementProviderHwndOverride))
         *ppv = &This->IRawElementProviderHwndOverride_iface;
+    else if (IsEqualIID(riid, &IID_IValueProvider))
+        *ppv = &This->IValueProvider_iface;
     else
         return E_NOINTERFACE;
 
@@ -1557,8 +1598,29 @@ HRESULT WINAPI ProviderSimple_get_ProviderOptions(IRawElementProviderSimple *ifa
 HRESULT WINAPI ProviderSimple_GetPatternProvider(IRawElementProviderSimple *iface,
         PATTERNID pattern_id, IUnknown **ret_val)
 {
-    ok(0, "unexpected call\n");
-    return E_NOTIMPL;
+    struct Provider *This = impl_from_ProviderSimple(iface);
+
+    add_method_call(This, PROV_GET_PATTERN_PROV);
+    if (This->expected_tid)
+        ok(This->expected_tid == GetCurrentThreadId(), "Unexpected tid %ld\n", GetCurrentThreadId());
+    This->last_call_tid = GetCurrentThreadId();
+
+    *ret_val = NULL;
+    switch (pattern_id)
+    {
+    case UIA_ValuePatternId:
+        if (This->value_pattern_data.is_supported)
+            *ret_val = (IUnknown *)iface;
+        break;
+
+    default:
+        break;
+    }
+
+    if (*ret_val)
+        IUnknown_AddRef(*ret_val);
+
+    return S_OK;
 }
 
 HRESULT WINAPI ProviderSimple_GetPropertyValue(IRawElementProviderSimple *iface,
@@ -1891,8 +1953,15 @@ static HRESULT WINAPI ProviderFragment_GetRuntimeId(IRawElementProviderFragment
 static HRESULT WINAPI ProviderFragment_get_BoundingRectangle(IRawElementProviderFragment *iface,
         struct UiaRect *ret_val)
 {
-    ok(0, "unexpected call\n");
-    return E_NOTIMPL;
+    struct Provider *This = impl_from_ProviderFragment(iface);
+
+    add_method_call(This, FRAG_GET_BOUNDING_RECT);
+    if (This->expected_tid)
+        ok(This->expected_tid == GetCurrentThreadId(), "Unexpected tid %ld\n", GetCurrentThreadId());
+    This->last_call_tid = GetCurrentThreadId();
+
+    *ret_val = This->bounds_rect;
+    return S_OK;
 }
 
 static HRESULT WINAPI ProviderFragment_GetEmbeddedFragmentRoots(IRawElementProviderFragment *iface,
@@ -2035,12 +2104,67 @@ static const IRawElementProviderHwndOverrideVtbl ProviderHwndOverrideVtbl = {
     ProviderHwndOverride_GetOverrideProviderForHwnd,
 };
 
+static inline struct Provider *impl_from_ProviderValuePattern(IValueProvider *iface)
+{
+    return CONTAINING_RECORD(iface, struct Provider, IValueProvider_iface);
+}
+
+static HRESULT WINAPI ProviderValuePattern_QueryInterface(IValueProvider *iface, REFIID riid,
+        void **ppv)
+{
+    struct Provider *Provider = impl_from_ProviderValuePattern(iface);
+    return IRawElementProviderSimple_QueryInterface(&Provider->IRawElementProviderSimple_iface, riid, ppv);
+}
+
+static ULONG WINAPI ProviderValuePattern_AddRef(IValueProvider *iface)
+{
+    struct Provider *Provider = impl_from_ProviderValuePattern(iface);
+    return IRawElementProviderSimple_AddRef(&Provider->IRawElementProviderSimple_iface);
+}
+
+static ULONG WINAPI ProviderValuePattern_Release(IValueProvider *iface)
+{
+    struct Provider *Provider = impl_from_ProviderValuePattern(iface);
+    return IRawElementProviderSimple_Release(&Provider->IRawElementProviderSimple_iface);
+}
+
+static HRESULT WINAPI ProviderValuePattern_SetValue(IValueProvider *iface, LPCWSTR val)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ProviderValuePattern_get_Value(IValueProvider *iface, BSTR *ret_val)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ProviderValuePattern_get_IsReadOnly(IValueProvider *iface, BOOL *ret_val)
+{
+    struct Provider *Provider = impl_from_ProviderValuePattern(iface);
+
+    *ret_val = Provider->value_pattern_data.is_read_only;
+
+    return S_OK;
+}
+
+static const IValueProviderVtbl ProviderValuePatternVtbl = {
+    ProviderValuePattern_QueryInterface,
+    ProviderValuePattern_AddRef,
+    ProviderValuePattern_Release,
+    ProviderValuePattern_SetValue,
+    ProviderValuePattern_get_Value,
+    ProviderValuePattern_get_IsReadOnly,
+};
+
 static struct Provider Provider =
 {
     { &ProviderSimpleVtbl },
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider",
     NULL, NULL,
@@ -2055,6 +2179,7 @@ static struct Provider Provider2 =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider2",
     NULL, NULL,
@@ -2069,6 +2194,7 @@ static struct Provider Provider_child =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_child",
     &Provider.IRawElementProviderFragment_iface, &Provider.IRawElementProviderFragmentRoot_iface,
@@ -2083,6 +2209,7 @@ static struct Provider Provider_child2 =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_child2",
     &Provider.IRawElementProviderFragment_iface, &Provider.IRawElementProviderFragmentRoot_iface,
@@ -2097,6 +2224,7 @@ static struct Provider Provider_hwnd =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_hwnd",
     NULL, NULL,
@@ -2111,6 +2239,7 @@ static struct Provider Provider_nc =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_nc",
     NULL, NULL,
@@ -2126,6 +2255,7 @@ static struct Provider Provider_proxy =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_proxy",
     NULL, NULL,
@@ -2141,6 +2271,7 @@ static struct Provider Provider_proxy2 =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_proxy2",
     NULL, NULL,
@@ -2156,6 +2287,7 @@ static struct Provider Provider_override =
     { &ProviderFragmentVtbl },
     { &ProviderFragmentRootVtbl },
     { &ProviderHwndOverrideVtbl },
+    { &ProviderValuePatternVtbl },
     1,
     "Provider_override",
     NULL, NULL,
@@ -2172,6 +2304,7 @@ static struct Provider Provider_override =
         { &ProviderFragmentVtbl }, \
         { &ProviderFragmentRootVtbl }, \
         { &ProviderHwndOverrideVtbl }, \
+        { &ProviderValuePatternVtbl }, \
         1, \
         "Provider_" # name "", \
         NULL, NULL, \
@@ -3301,13 +3434,43 @@ static void test_uia_prov_from_acc_properties(void)
 
     IRawElementProviderSimple_Release(elprov);
     ok(Accessible.ref == 1, "Unexpected refcnt %ld\n", Accessible.ref);
+
+    /* UIA_NamePropertyId tests. */
+    set_accessible_props(&Accessible, 0, 0, 0, L"Accessible", 0, 0, 0, 0);
+    hr = pUiaProviderFromIAccessible(&Accessible.IAccessible_iface, CHILDID_SELF, UIA_PFIA_DEFAULT, &elprov);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(Accessible.ref == 2, "Unexpected refcnt %ld\n", Accessible.ref);
+
+    SET_EXPECT(Accessible_get_accName);
+    VariantInit(&v);
+    hr = IRawElementProviderSimple_GetPropertyValue(elprov, UIA_NamePropertyId, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(V_VT(&v) == VT_BSTR, "Unexpected VT %d\n", V_VT(&v));
+    ok(!lstrcmpW(V_BSTR(&v), Accessible.name), "Unexpected BSTR %s\n", wine_dbgstr_w(V_BSTR(&v)));
+    VariantClear(&v);
+    CHECK_CALLED(Accessible_get_accName);
+
+    /* Name is not cached. */
+    set_accessible_props(&Accessible, 0, 0, 0, L"Accessible2", 0, 0, 0, 0);
+    SET_EXPECT(Accessible_get_accName);
+    hr = IRawElementProviderSimple_GetPropertyValue(elprov, UIA_NamePropertyId, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(V_VT(&v) == VT_BSTR, "Unexpected VT %d\n", V_VT(&v));
+    ok(!lstrcmpW(V_BSTR(&v), Accessible.name), "Unexpected BSTR %s\n", wine_dbgstr_w(V_BSTR(&v)));
+    VariantClear(&v);
+    CHECK_CALLED(Accessible_get_accName);
+
+    IRawElementProviderSimple_Release(elprov);
+    ok(Accessible.ref == 1, "Unexpected refcnt %ld\n", Accessible.ref);
 }
 
 static void test_UiaProviderFromIAccessible(void)
 {
     ILegacyIAccessibleProvider *accprov;
     IRawElementProviderSimple *elprov, *elprov2;
+    IRawElementProviderFragment *elfrag;
     enum ProviderOptions prov_opt;
+    struct UiaRect rect;
     IAccessible *acc;
     IUnknown *unk;
     WNDCLASSA cls;
@@ -3825,6 +3988,83 @@ static void test_UiaProviderFromIAccessible(void)
     IRawElementProviderSimple_Release(elprov);
     ok(Accessible.ref == 1, "Unexpected refcnt %ld\n", Accessible.ref);
 
+    /*
+     * Test IRawElementProviderFragment_get_BoundingRectangle.
+     */
+    set_accessible_props(&Accessible, ROLE_SYSTEM_DOCUMENT, STATE_SYSTEM_FOCUSABLE, 0, L"acc_name", 25, 25, 50, 50);
+    /* Test the case where Accessible is not the root for its HWND. */
+    acc_client = NULL;
+    hr = pUiaProviderFromIAccessible(&Accessible.IAccessible_iface, CHILDID_SELF, UIA_PFIA_DEFAULT, &elprov);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(Accessible.ref == 2, "Unexpected refcnt %ld\n", Accessible.ref);
+
+    hr = IRawElementProviderSimple_QueryInterface(elprov, &IID_IRawElementProviderFragment, (void **)&elfrag);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(!!elfrag, "elfrag == NULL\n");
+
+    SET_EXPECT(winproc_GETOBJECT_CLIENT);
+    SET_EXPECT(Accessible_get_accRole);
+    SET_EXPECT(Accessible_get_accState);
+    SET_EXPECT(Accessible_accLocation);
+    hr = IRawElementProviderFragment_get_BoundingRectangle(elfrag, &rect);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(rect.left == (double)Accessible.left, "Unexpected left value %f\n", rect.left);
+    ok(rect.top == (double)Accessible.top, "Unexpected top value %f\n", rect.top);
+    ok(rect.width == (double)Accessible.width, "Unexpected width value %f\n", rect.width);
+    ok(rect.height == (double)Accessible.height, "Unexpected height value %f\n", rect.height);
+    CHECK_CALLED(winproc_GETOBJECT_CLIENT);
+    CHECK_CALLED(Accessible_get_accRole);
+    CHECK_CALLED(Accessible_get_accState);
+    CHECK_CALLED(Accessible_accLocation);
+
+    /* If Accessible has STATE_SYSTEM_OFFSCREEN, it will return an empty rect. */
+    set_accessible_props(&Accessible, ROLE_SYSTEM_DOCUMENT, STATE_SYSTEM_OFFSCREEN, 0, L"acc_name", 0, 0, 50, 50);
+    SET_EXPECT(Accessible_get_accState);
+    hr = IRawElementProviderFragment_get_BoundingRectangle(elfrag, &rect);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(rect.left == 0.0, "Unexpected left value %f\n", rect.left);
+    ok(rect.top == 0.0, "Unexpected top value %f\n", rect.top);
+    ok(rect.width == 0.0, "Unexpected width value %f\n", rect.width);
+    ok(rect.height == 0.0, "Unexpected height value %f\n", rect.height);
+    CHECK_CALLED(Accessible_get_accState);
+
+    IRawElementProviderFragment_Release(elfrag);
+    IRawElementProviderSimple_Release(elprov);
+    ok(Accessible.ref == 1, "Unexpected refcnt %ld\n", Accessible.ref);
+
+    /* Test case where accessible is the root accessible. */
+    set_accessible_props(&Accessible, ROLE_SYSTEM_DOCUMENT, 0, 0, L"acc_name", 0, 0, 0, 0);
+    acc_client = &Accessible.IAccessible_iface;
+    hr = pUiaProviderFromIAccessible(&Accessible.IAccessible_iface, CHILDID_SELF, UIA_PFIA_DEFAULT, &elprov);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(Accessible.ref == 2, "Unexpected refcnt %ld\n", Accessible.ref);
+
+    hr = IRawElementProviderSimple_QueryInterface(elprov, &IID_IRawElementProviderFragment, (void **)&elfrag);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(!!elfrag, "elfrag == NULL\n");
+
+    SET_EXPECT(winproc_GETOBJECT_CLIENT);
+    hr = IRawElementProviderFragment_get_BoundingRectangle(elfrag, &rect);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(rect.left == 0.0, "Unexpected left value %f\n", rect.left);
+    ok(rect.top == 0.0, "Unexpected top value %f\n", rect.top);
+    ok(rect.width == 0.0, "Unexpected width value %f\n", rect.width);
+    ok(rect.height == 0.0, "Unexpected height value %f\n", rect.height);
+    CHECK_CALLED(winproc_GETOBJECT_CLIENT);
+
+    /* Second call does nothing. */
+    hr = IRawElementProviderFragment_get_BoundingRectangle(elfrag, &rect);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(rect.left == 0.0, "Unexpected left value %f\n", rect.left);
+    ok(rect.top == 0.0, "Unexpected top value %f\n", rect.top);
+    ok(rect.width == 0.0, "Unexpected width value %f\n", rect.width);
+    ok(rect.height == 0.0, "Unexpected height value %f\n", rect.height);
+
+    IRawElementProviderFragment_Release(elfrag);
+    IRawElementProviderSimple_Release(elprov);
+    ok(Accessible.ref == 1, "Unexpected refcnt %ld\n", Accessible.ref);
+    acc_client = NULL;
+
     test_uia_prov_from_acc_properties();
     test_uia_prov_from_acc_navigation();
     test_uia_prov_from_acc_ia2();
@@ -4022,22 +4262,161 @@ static const struct uia_lookup_id uia_property_lookup_ids[] = {
     { &IsDialog_Property_GUID,                            UIA_IsDialogPropertyId },
 };
 
+static const struct uia_lookup_id uia_event_lookup_ids[] = {
+    { &ToolTipOpened_Event_GUID,                                  UIA_ToolTipOpenedEventId },
+    { &ToolTipClosed_Event_GUID,                                  UIA_ToolTipClosedEventId },
+    { &StructureChanged_Event_GUID,                               UIA_StructureChangedEventId },
+    { &MenuOpened_Event_GUID,                                     UIA_MenuOpenedEventId },
+    { &AutomationPropertyChanged_Event_GUID,                      UIA_AutomationPropertyChangedEventId },
+    { &AutomationFocusChanged_Event_GUID,                         UIA_AutomationFocusChangedEventId },
+    { &AsyncContentLoaded_Event_GUID,                             UIA_AsyncContentLoadedEventId },
+    { &MenuClosed_Event_GUID,                                     UIA_MenuClosedEventId },
+    { &LayoutInvalidated_Event_GUID,                              UIA_LayoutInvalidatedEventId },
+    { &Invoke_Invoked_Event_GUID,                                 UIA_Invoke_InvokedEventId },
+    { &SelectionItem_ElementAddedToSelectionEvent_Event_GUID,     UIA_SelectionItem_ElementAddedToSelectionEventId },
+    { &SelectionItem_ElementRemovedFromSelectionEvent_Event_GUID, UIA_SelectionItem_ElementRemovedFromSelectionEventId },
+    { &SelectionItem_ElementSelectedEvent_Event_GUID,             UIA_SelectionItem_ElementSelectedEventId },
+    { &Selection_InvalidatedEvent_Event_GUID,                     UIA_Selection_InvalidatedEventId },
+    { &Text_TextSelectionChangedEvent_Event_GUID,                 UIA_Text_TextSelectionChangedEventId },
+    { &Text_TextChangedEvent_Event_GUID,                          UIA_Text_TextChangedEventId },
+    { &Window_WindowOpened_Event_GUID,                            UIA_Window_WindowOpenedEventId },
+    { &Window_WindowClosed_Event_GUID,                            UIA_Window_WindowClosedEventId },
+    { &MenuModeStart_Event_GUID,                                  UIA_MenuModeStartEventId },
+    { &MenuModeEnd_Event_GUID,                                    UIA_MenuModeEndEventId },
+    { &InputReachedTarget_Event_GUID,                             UIA_InputReachedTargetEventId },
+    { &InputReachedOtherElement_Event_GUID,                       UIA_InputReachedOtherElementEventId },
+    { &InputDiscarded_Event_GUID,                                 UIA_InputDiscardedEventId },
+    /* Implemented on Win8+ */
+    { &SystemAlert_Event_GUID,                                    UIA_SystemAlertEventId },
+    { &LiveRegionChanged_Event_GUID,                              UIA_LiveRegionChangedEventId },
+    { &HostedFragmentRootsInvalidated_Event_GUID,                 UIA_HostedFragmentRootsInvalidatedEventId },
+    { &Drag_DragStart_Event_GUID,                                 UIA_Drag_DragStartEventId },
+    { &Drag_DragCancel_Event_GUID,                                UIA_Drag_DragCancelEventId },
+    { &Drag_DragComplete_Event_GUID,                              UIA_Drag_DragCompleteEventId },
+    { &DropTarget_DragEnter_Event_GUID,                           UIA_DropTarget_DragEnterEventId },
+    { &DropTarget_DragLeave_Event_GUID,                           UIA_DropTarget_DragLeaveEventId },
+    { &DropTarget_Dropped_Event_GUID,                             UIA_DropTarget_DroppedEventId },
+    { &TextEdit_TextChanged_Event_GUID,                           UIA_TextEdit_TextChangedEventId },
+    { &TextEdit_ConversionTargetChanged_Event_GUID,               UIA_TextEdit_ConversionTargetChangedEventId },
+    /* Implemented on Win10v1809+. */
+    { &Changes_Event_GUID,                                        UIA_ChangesEventId },
+    { &Notification_Event_GUID,                                   UIA_NotificationEventId },
+};
+
+static const struct uia_lookup_id uia_pattern_lookup_ids[] = {
+    { &Invoke_Pattern_GUID,            UIA_InvokePatternId },
+    { &Selection_Pattern_GUID,         UIA_SelectionPatternId },
+    { &Value_Pattern_GUID,             UIA_ValuePatternId },
+    { &RangeValue_Pattern_GUID,        UIA_RangeValuePatternId },
+    { &Scroll_Pattern_GUID,            UIA_ScrollPatternId },
+    { &ExpandCollapse_Pattern_GUID,    UIA_ExpandCollapsePatternId },
+    { &Grid_Pattern_GUID,              UIA_GridPatternId },
+    { &GridItem_Pattern_GUID,          UIA_GridItemPatternId },
+    { &MultipleView_Pattern_GUID,      UIA_MultipleViewPatternId },
+    { &Window_Pattern_GUID,            UIA_WindowPatternId },
+    { &SelectionItem_Pattern_GUID,     UIA_SelectionItemPatternId },
+    { &Dock_Pattern_GUID,              UIA_DockPatternId },
+    { &Table_Pattern_GUID,             UIA_TablePatternId },
+    { &TableItem_Pattern_GUID,         UIA_TableItemPatternId },
+    { &Text_Pattern_GUID,              UIA_TextPatternId },
+    { &Toggle_Pattern_GUID,            UIA_TogglePatternId },
+    { &Transform_Pattern_GUID,         UIA_TransformPatternId },
+    { &ScrollItem_Pattern_GUID,        UIA_ScrollItemPatternId },
+    { &LegacyIAccessible_Pattern_GUID, UIA_LegacyIAccessiblePatternId },
+    { &ItemContainer_Pattern_GUID,     UIA_ItemContainerPatternId },
+    { &VirtualizedItem_Pattern_GUID,   UIA_VirtualizedItemPatternId },
+    { &SynchronizedInput_Pattern_GUID, UIA_SynchronizedInputPatternId },
+    /* Implemented on Win8+ */
+    { &ObjectModel_Pattern_GUID,       UIA_ObjectModelPatternId },
+    { &Annotation_Pattern_GUID,        UIA_AnnotationPatternId },
+    { &Text_Pattern2_GUID,             UIA_TextPattern2Id },
+    { &Styles_Pattern_GUID,            UIA_StylesPatternId },
+    { &Spreadsheet_Pattern_GUID,       UIA_SpreadsheetPatternId },
+    { &SpreadsheetItem_Pattern_GUID,   UIA_SpreadsheetItemPatternId },
+    { &Tranform_Pattern2_GUID,         UIA_TransformPattern2Id },
+    { &TextChild_Pattern_GUID,         UIA_TextChildPatternId },
+    { &Drag_Pattern_GUID,              UIA_DragPatternId },
+    { &DropTarget_Pattern_GUID,        UIA_DropTargetPatternId },
+    { &TextEdit_Pattern_GUID,          UIA_TextEditPatternId },
+    /* Implemented on Win10+. */
+    { &CustomNavigation_Pattern_GUID,  UIA_CustomNavigationPatternId },
+};
+
+static const struct uia_lookup_id uia_control_type_lookup_ids[] = {
+    { &Button_Control_GUID,       UIA_ButtonControlTypeId },
+    { &Calendar_Control_GUID,     UIA_CalendarControlTypeId },
+    { &CheckBox_Control_GUID,     UIA_CheckBoxControlTypeId },
+    { &ComboBox_Control_GUID,     UIA_ComboBoxControlTypeId },
+    { &Edit_Control_GUID,         UIA_EditControlTypeId },
+    { &Hyperlink_Control_GUID,    UIA_HyperlinkControlTypeId },
+    { &Image_Control_GUID,        UIA_ImageControlTypeId },
+    { &ListItem_Control_GUID,     UIA_ListItemControlTypeId },
+    { &List_Control_GUID,         UIA_ListControlTypeId },
+    { &Menu_Control_GUID,         UIA_MenuControlTypeId },
+    { &MenuBar_Control_GUID,      UIA_MenuBarControlTypeId },
+    { &MenuItem_Control_GUID,     UIA_MenuItemControlTypeId },
+    { &ProgressBar_Control_GUID,  UIA_ProgressBarControlTypeId },
+    { &RadioButton_Control_GUID,  UIA_RadioButtonControlTypeId },
+    { &ScrollBar_Control_GUID,    UIA_ScrollBarControlTypeId },
+    { &Slider_Control_GUID,       UIA_SliderControlTypeId },
+    { &Spinner_Control_GUID,      UIA_SpinnerControlTypeId },
+    { &StatusBar_Control_GUID,    UIA_StatusBarControlTypeId },
+    { &Tab_Control_GUID,          UIA_TabControlTypeId },
+    { &TabItem_Control_GUID,      UIA_TabItemControlTypeId },
+    { &Text_Control_GUID,         UIA_TextControlTypeId },
+    { &ToolBar_Control_GUID,      UIA_ToolBarControlTypeId },
+    { &ToolTip_Control_GUID,      UIA_ToolTipControlTypeId },
+    { &Tree_Control_GUID,         UIA_TreeControlTypeId },
+    { &TreeItem_Control_GUID,     UIA_TreeItemControlTypeId },
+    { &Custom_Control_GUID,       UIA_CustomControlTypeId },
+    { &Group_Control_GUID,        UIA_GroupControlTypeId },
+    { &Thumb_Control_GUID,        UIA_ThumbControlTypeId },
+    { &DataGrid_Control_GUID,     UIA_DataGridControlTypeId },
+    { &DataItem_Control_GUID,     UIA_DataItemControlTypeId },
+    { &Document_Control_GUID,     UIA_DocumentControlTypeId },
+    { &SplitButton_Control_GUID,  UIA_SplitButtonControlTypeId },
+    { &Window_Control_GUID,       UIA_WindowControlTypeId },
+    { &Pane_Control_GUID,         UIA_PaneControlTypeId },
+    { &Header_Control_GUID,       UIA_HeaderControlTypeId },
+    { &HeaderItem_Control_GUID,   UIA_HeaderItemControlTypeId },
+    { &Table_Control_GUID,        UIA_TableControlTypeId },
+    { &TitleBar_Control_GUID,     UIA_TitleBarControlTypeId },
+    { &Separator_Control_GUID,    UIA_SeparatorControlTypeId },
+    /* Implemented on Win8+ */
+    { &SemanticZoom_Control_GUID, UIA_SemanticZoomControlTypeId },
+    { &AppBar_Control_GUID,       UIA_AppBarControlTypeId },
+};
+
 static void test_UiaLookupId(void)
 {
-    unsigned int i;
-
-    for (i = 0; i < ARRAY_SIZE(uia_property_lookup_ids); i++)
+    static const struct {
+        const char *id_type_name;
+        int id_type;
+        const struct uia_lookup_id *ids;
+        int ids_count;
+    } tests[] =
     {
-        int prop_id = UiaLookupId(AutomationIdentifierType_Property, uia_property_lookup_ids[i].guid);
-
-        if (!prop_id)
+        { "property", AutomationIdentifierType_Property, uia_property_lookup_ids, ARRAY_SIZE(uia_property_lookup_ids) },
+        { "event",    AutomationIdentifierType_Event,    uia_event_lookup_ids,    ARRAY_SIZE(uia_event_lookup_ids) },
+        { "pattern",  AutomationIdentifierType_Pattern,  uia_pattern_lookup_ids,  ARRAY_SIZE(uia_pattern_lookup_ids) },
+        { "control_type", AutomationIdentifierType_ControlType, uia_control_type_lookup_ids, ARRAY_SIZE(uia_control_type_lookup_ids) },
+    };
+    unsigned int i, y;
+
+    for (i = 0; i < ARRAY_SIZE(tests); i++)
+    {
+        for (y = 0; y < tests[i].ids_count; y++)
         {
-            win_skip("No propertyId for GUID %s, skipping further tests.\n", debugstr_guid(uia_property_lookup_ids[i].guid));
-            break;
-        }
+            int id = UiaLookupId(tests[i].id_type, tests[i].ids[y].guid);
+
+            if (!id)
+            {
+                win_skip("No %s id for GUID %s, skipping further tests.\n", tests[i].id_type_name, debugstr_guid(tests[i].ids[y].guid));
+                break;
+            }
 
-        ok(prop_id == uia_property_lookup_ids[i].id, "Unexpected Property id, expected %d, got %d\n",
-                uia_property_lookup_ids[i].id, prop_id);
+            ok(id == tests[i].ids[y].id, "Unexpected %s id, expected %d, got %d\n", tests[i].id_type_name, tests[i].ids[y].id, id);
+        }
     }
 }
 
@@ -4171,7 +4550,7 @@ static const struct prov_method_sequence node_from_prov8[] = {
     { 0 }
 };
 
-static void check_uia_prop_val(PROPERTYID prop_id, enum UIAutomationType type, VARIANT *v);
+static void check_uia_prop_val(PROPERTYID prop_id, enum UIAutomationType type, VARIANT *v, BOOL from_com);
 static DWORD WINAPI uia_node_from_provider_test_com_thread(LPVOID param)
 {
     HUIANODE node = param;
@@ -4190,7 +4569,7 @@ static DWORD WINAPI uia_node_from_provider_test_com_thread(LPVOID param)
 
     hr = UiaGetPropertyValue(node, UIA_ProcessIdPropertyId, &v);
     ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
-    check_uia_prop_val(UIA_ProcessIdPropertyId, UIAutomationType_Int, &v);
+    check_uia_prop_val(UIA_ProcessIdPropertyId, UIAutomationType_Int, &v, FALSE);
 
     /*
      * When retrieving a UIAutomationType_Element property, if UseComThreading
@@ -4204,7 +4583,7 @@ static DWORD WINAPI uia_node_from_provider_test_com_thread(LPVOID param)
     Provider_child.expected_tid = Provider.expected_tid;
     hr = UiaGetPropertyValue(node, UIA_LabeledByPropertyId, &v);
     ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
-    check_uia_prop_val(UIA_LabeledByPropertyId, UIAutomationType_Element, &v);
+    check_uia_prop_val(UIA_LabeledByPropertyId, UIAutomationType_Element, &v, FALSE);
 
     /* Unset ProviderOptions_UseComThreading. */
     Provider_child.prov_opts = ProviderOptions_ServerSideProvider;
@@ -4216,7 +4595,7 @@ static DWORD WINAPI uia_node_from_provider_test_com_thread(LPVOID param)
      * called on the current thread.
      */
     Provider_child.expected_tid = GetCurrentThreadId();
-    check_uia_prop_val(UIA_LabeledByPropertyId, UIAutomationType_Element, &v);
+    check_uia_prop_val(UIA_LabeledByPropertyId, UIAutomationType_Element, &v, FALSE);
 
     CoUninitialize();
 
@@ -4570,7 +4949,126 @@ static const struct prov_method_sequence get_elem_arr_prop_seq[] = {
     { 0 }
 };
 
-static void check_uia_prop_val(PROPERTYID prop_id, enum UIAutomationType type, VARIANT *v)
+static const struct prov_method_sequence get_pattern_prop_seq[] = {
+    { &Provider, PROV_GET_PATTERN_PROV },
+    { 0 }
+};
+
+static const struct prov_method_sequence get_bounding_rect_seq[] = {
+    NODE_CREATE_SEQ(&Provider_child),
+    { &Provider_child, FRAG_GET_BOUNDING_RECT },
+    /*
+     * Win10v21H2+ and above call these, attempting to get the fragment root's
+     * HWND. I'm guessing this is an attempt to get the HWND's DPI for DPI scaling.
+     */
+    { &Provider_child, FRAG_GET_FRAGMENT_ROOT, METHOD_OPTIONAL },
+    { &Provider, PROV_GET_HOST_RAW_ELEMENT_PROVIDER, METHOD_OPTIONAL },
+    { &Provider, PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */
+    { &Provider, FRAG_GET_FRAGMENT_ROOT, METHOD_OPTIONAL },
+    { 0 }
+};
+
+static const struct prov_method_sequence get_bounding_rect_seq2[] = {
+    { &Provider, PROV_GET_PROPERTY_VALUE },
+    NODE_CREATE_SEQ(&Provider_child),
+    { &Provider_child, FRAG_GET_BOUNDING_RECT },
+    /*
+     * Win10v21H2+ and above call these, attempting to get the fragment root's
+     * HWND. I'm guessing this is an attempt to get the HWND's DPI for DPI scaling.
+     */
+    { &Provider_child, FRAG_GET_FRAGMENT_ROOT, METHOD_OPTIONAL },
+    { &Provider, PROV_GET_HOST_RAW_ELEMENT_PROVIDER, METHOD_OPTIONAL },
+    { &Provider, PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */
+    { &Provider, FRAG_GET_FRAGMENT_ROOT, METHOD_OPTIONAL },
+    { 0 }
+};
+
+static const struct prov_method_sequence get_bounding_rect_seq3[] = {
+    { &Provider_child, FRAG_GET_BOUNDING_RECT },
+    /*
+     * Win10v21H2+ and above call these, attempting to get the fragment root's
+     * HWND. I'm guessing this is an attempt to get the HWND's DPI for DPI scaling.
+     */
+    { &Provider_child, FRAG_GET_FRAGMENT_ROOT, METHOD_OPTIONAL },
+    { &Provider, PROV_GET_HOST_RAW_ELEMENT_PROVIDER, METHOD_OPTIONAL },
+    { &Provider, PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */
+    { &Provider, FRAG_GET_FRAGMENT_ROOT, METHOD_OPTIONAL },
+    { 0 }
+};
+
+static const struct prov_method_sequence get_empty_bounding_rect_seq[] = {
+    { &Provider_child, FRAG_GET_BOUNDING_RECT },
+    { 0 }
+};
+
+static void set_uia_rect(struct UiaRect *rect, double left, double top, double width, double height)
+{
+    rect->left = left;
+    rect->top = top;
+    rect->width = width;
+    rect->height = height;
+}
+
+#define check_uia_rect_val( v, rect ) \
+        check_uia_rect_val_( (v), (rect), __FILE__, __LINE__)
+static void check_uia_rect_val_(VARIANT *v, struct UiaRect *rect, const char *file, int line)
+{
+    LONG lbound, ubound, elems, idx;
+    SAFEARRAY *sa;
+    double tmp[4];
+    VARTYPE vt;
+    HRESULT hr;
+    UINT dims;
+
+    ok_(file, line)(V_VT(v) == (VT_R8 | VT_ARRAY), "Unexpected rect VT hr %d.\n", V_VT(v));
+    if (V_VT(v) != (VT_R8 | VT_ARRAY))
+        return;
+
+    sa = V_ARRAY(v);
+    hr = SafeArrayGetVartype(sa, &vt);
+    ok_(file, line)(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok_(file, line)(vt == VT_R8, "Unexpected vt %d\n", vt);
+
+    dims = SafeArrayGetDim(sa);
+    ok_(file, line)(dims == 1, "Unexpected dims %d\n", dims);
+
+    lbound = ubound = elems = 0;
+    hr = SafeArrayGetLBound(sa, 1, &lbound);
+    ok_(file, line)(hr == S_OK, "Unexpected hr %#lx for SafeArrayGetLBound\n", hr);
+    ok_(file, line)(lbound == 0, "Unexpected lbound %ld\n", lbound);
+
+    hr = SafeArrayGetUBound(sa, 1, &ubound);
+    ok_(file, line)(hr == S_OK, "Unexpected hr %#lx for SafeArrayGetUBound\n", hr);
+    ok_(file, line)(ubound == 3, "Unexpected ubound %ld\n", ubound);
+
+    elems = (ubound - lbound) + 1;
+    ok_(file, line)(elems == 4, "Unexpected rect elems %ld\n", elems);
+
+    for (idx = 0; idx < ARRAY_SIZE(tmp); idx++)
+    {
+        hr = SafeArrayGetElement(sa, &idx, &tmp[idx]);
+        ok_(file, line)(hr == S_OK, "Unexpected hr %#lx for SafeArrayGetElement at idx %ld.\n", hr, idx);
+    }
+
+    ok_(file, line)(tmp[0] == rect->left, "Unexpected left value %f, expected %f\n", tmp[0], rect->left);
+    ok_(file, line)(tmp[1] == rect->top, "Unexpected top value %f, expected %f\n", tmp[1], rect->top);
+    ok_(file, line)(tmp[2] == rect->width, "Unexpected width value %f, expected %f\n", tmp[2], rect->width);
+    ok_(file, line)(tmp[3] == rect->height, "Unexpected height value %f, expected %f\n", tmp[3], rect->height);
+}
+
+#define check_uia_rect_rect_val( rect, uia_rect ) \
+        check_uia_rect_rect_val_( (rect), (uia_rect), __FILE__, __LINE__)
+static void check_uia_rect_rect_val_(RECT *rect, struct UiaRect *uia_rect, const char *file, int line)
+{
+    ok_(file, line)(rect->left == (LONG)uia_rect->left, "Unexpected left value %ld, expected %ld\n", rect->left, (LONG)uia_rect->left);
+    ok_(file, line)(rect->top == (LONG)uia_rect->top, "Unexpected top value %ld, expected %ld\n", rect->top, (LONG)uia_rect->top);
+    ok_(file, line)(rect->right == (LONG)(uia_rect->left + uia_rect->width), "Unexpected right value %ld, expected %ld\n", rect->right,
+            (LONG)(uia_rect->left + uia_rect->width));
+    ok_(file, line)(rect->bottom == (LONG)(uia_rect->top + uia_rect->height), "Unexpected bottom value %ld, expected %ld\n", rect->bottom,
+            (LONG)(uia_rect->top + uia_rect->height));
+}
+
+static void check_uia_prop_val(PROPERTYID prop_id, enum UIAutomationType type, VARIANT *v, BOOL from_com)
 {
     LONG idx;
 
@@ -4641,22 +5139,40 @@ static void check_uia_prop_val(PROPERTYID prop_id, enum UIAutomationType type, V
         HRESULT hr;
         VARIANT v1;
 
+        if (from_com)
+        {
+            IUIAutomationElement *elem;
+
+            ok(V_VT(v) == VT_UNKNOWN, "Unexpected VT %d\n", V_VT(v));
+            hr = IUnknown_QueryInterface(V_UNKNOWN(v), &IID_IUIAutomationElement, (void **)&elem);
+            VariantClear(v);
+            ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
+            ok(Provider_child.ref == 2, "Unexpected refcnt %ld\n", Provider_child.ref);
+
+            hr = IUIAutomationElement_GetCurrentPropertyValueEx(elem, UIA_ControlTypePropertyId, TRUE, &v1);
+            ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
+            IUIAutomationElement_Release(elem);
+        }
+        else
+        {
 #ifdef _WIN64
-        ok(V_VT(v) == VT_I8, "Unexpected VT %d\n", V_VT(v));
-        tmp_node = (HUIANODE)V_I8(v);
+            ok(V_VT(v) == VT_I8, "Unexpected VT %d\n", V_VT(v));
+            tmp_node = (HUIANODE)V_I8(v);
 #else
-        ok(V_VT(v) == VT_I4, "Unexpected VT %d\n", V_VT(v));
-        tmp_node = (HUIANODE)V_I4(v);
+            ok(V_VT(v) == VT_I4, "Unexpected VT %d\n", V_VT(v));
+            tmp_node = (HUIANODE)V_I4(v);
 #endif
-        ok(Provider_child.ref == 2, "Unexpected refcnt %ld\n", Provider_child.ref);
+            ok(Provider_child.ref == 2, "Unexpected refcnt %ld\n", Provider_child.ref);
+
+            hr = UiaGetPropertyValue(tmp_node, UIA_ControlTypePropertyId, &v1);
+            ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
+            ok(UiaNodeRelease(tmp_node), "Failed to release node\n");
+        }
 
-        hr = UiaGetPropertyValue(tmp_node, UIA_ControlTypePropertyId, &v1);
-        ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
         ok(V_VT(&v1) == VT_I4, "Unexpected VT %d\n", V_VT(&v1));
         ok(V_I4(&v1) == uia_i4_prop_val, "Unexpected I4 %#lx\n", V_I4(&v1));
-
-        ok(UiaNodeRelease(tmp_node), "Failed to release node\n");
         ok(Provider_child.ref == 1, "Unexpected refcnt %ld\n", Provider_child.ref);
+
         ok_method_sequence(get_elem_prop_seq, NULL);
         break;
     }
@@ -4765,6 +5281,7 @@ static const struct uia_element_property element_properties[] = {
 static void test_UiaGetPropertyValue(void)
 {
     const struct uia_element_property *elem_prop;
+    struct UiaRect rect;
     IUnknown *unk_ns;
     unsigned int i;
     HUIANODE node;
@@ -4801,7 +5318,7 @@ static void test_UiaGetPropertyValue(void)
         winetest_push_context("prop_id %d", prop_id);
         hr = UiaGetPropertyValue(node, prop_id, &v);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        check_uia_prop_val(prop_id, elem_prop->type, &v);
+        check_uia_prop_val(prop_id, elem_prop->type, &v, FALSE);
 
         /*
          * Some properties have special behavior if an invalid value is
@@ -4827,9 +5344,73 @@ static void test_UiaGetPropertyValue(void)
         winetest_pop_context();
     }
 
-    Provider.ret_invalid_prop_type = FALSE;
+    /* IValueProvider pattern property IDs. */
+    Provider.value_pattern_data.is_supported = FALSE;
+    hr = UiaGetPropertyValue(node, UIA_ValueIsReadOnlyPropertyId, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(V_VT(&v) == VT_UNKNOWN, "Unexpected vt %d\n", V_VT(&v));
+    ok(V_UNKNOWN(&v) == unk_ns, "unexpected IUnknown %p\n", V_UNKNOWN(&v));
+    ok_method_sequence(get_pattern_prop_seq, NULL);
+    VariantClear(&v);
+
+    Provider.value_pattern_data.is_supported = TRUE;
+    for (i = 0; i < 2; i++)
+    {
+        Provider.value_pattern_data.is_read_only = i;
+
+        hr = UiaGetPropertyValue(node, UIA_ValueIsReadOnlyPropertyId, &v);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(V_VT(&v) == VT_BOOL, "Unexpected VT %d\n", V_VT(&v));
+        ok(check_variant_bool(&v, i), "Unexpected BOOL %#x\n", V_BOOL(&v));
+        ok_method_sequence(get_pattern_prop_seq, NULL);
+        VariantClear(&v);
+    }
+
     ok(UiaNodeRelease(node), "UiaNodeRelease returned FALSE\n");
     ok(Provider.ref == 1, "Unexpected refcnt %ld\n", Provider.ref);
+    initialize_provider(&Provider, ProviderOptions_ServerSideProvider, NULL, FALSE);
+
+    /*
+     * Windows 7 will call get_FragmentRoot in an endless loop until the fragment root returns an HWND.
+     * It's the only version with this behavior.
+     */
+    if (!UiaLookupId(AutomationIdentifierType_Property, &OptimizeForVisualContent_Property_GUID))
+    {
+        win_skip("Skipping UIA_BoundingRectanglePropertyId tests for Win7\n");
+        goto exit;
+    }
+
+    initialize_provider(&Provider_child, ProviderOptions_ServerSideProvider, NULL, FALSE);
+    node = (void *)0xdeadbeef;
+    hr = UiaNodeFromProvider(&Provider_child.IRawElementProviderSimple_iface, &node);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(Provider_child.ref == 2, "Unexpected refcnt %ld\n", Provider_child.ref);
+
+    /* Non-empty bounding rectangle, will return a VT_R8 SAFEARRAY. */
+    set_uia_rect(&rect, 0, 0, 50, 50);
+    Provider_child.bounds_rect = rect;
+    hr = UiaGetPropertyValue(node, UIA_BoundingRectanglePropertyId, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    check_uia_rect_val(&v, &rect);
+    VariantClear(&v);
+
+    ok_method_sequence(get_bounding_rect_seq, "get_bounding_rect_seq");
+
+    /* Empty bounding rectangle will return ReservedNotSupportedValue. */
+    set_uia_rect(&rect, 0, 0, 0, 0);
+    Provider_child.bounds_rect = rect;
+    hr = UiaGetPropertyValue(node, UIA_BoundingRectanglePropertyId, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(V_VT(&v) == VT_UNKNOWN, "Unexpected vt %d\n", V_VT(&v));
+    ok(V_UNKNOWN(&v) == unk_ns, "unexpected IUnknown %p\n", V_UNKNOWN(&v));
+    VariantClear(&v);
+    ok_method_sequence(get_empty_bounding_rect_seq, "get_empty_bounding_rect_seq");
+
+    ok(UiaNodeRelease(node), "UiaNodeRelease returned FALSE\n");
+    ok(Provider_child.ref == 1, "Unexpected refcnt %ld\n", Provider_child.ref);
+    initialize_provider(&Provider_child, ProviderOptions_ServerSideProvider, NULL, FALSE);
+
+exit:
 
     IUnknown_Release(unk_ns);
     CoUninitialize();
@@ -5496,7 +6077,7 @@ static DWORD WINAPI uia_node_from_handle_test_thread(LPVOID param)
 
     hr = UiaGetPropertyValue(node, UIA_ControlTypePropertyId, &v);
     ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
-    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v);
+    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v, FALSE);
 
     /*
      * On Windows, nested providers are always called on a separate thread if
@@ -5655,7 +6236,7 @@ static DWORD WINAPI uia_node_from_handle_test_thread(LPVOID param)
 
     hr = UiaGetPropertyValue(node, UIA_ControlTypePropertyId, &v);
     ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
-    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v);
+    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v, FALSE);
 
     /* Nodes returned from a nested node will be tracked and disconnectable. */
     Provider_child.prov_opts = ProviderOptions_ServerSideProvider;
@@ -5748,7 +6329,7 @@ static DWORD WINAPI uia_node_from_handle_test_thread(LPVOID param)
 
     hr = UiaGetPropertyValue(node, UIA_ControlTypePropertyId, &v);
     ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
-    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v);
+    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v, FALSE);
 
     /* Finally, disconnect node. */
     Provider.hwnd = hwnd;
@@ -5970,7 +6551,7 @@ static void test_UiaNodeFromHandle(const char *name)
     Provider.expected_tid = GetCurrentThreadId();
     hr = UiaGetPropertyValue(node, UIA_ControlTypePropertyId, &v);
     ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
-    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v);
+    check_uia_prop_val(UIA_ControlTypePropertyId, UIAutomationType_Int, &v, FALSE);
 
     /* UIAutomationType_Element properties will return a normal node. */
     Provider_child.prov_opts = ProviderOptions_ServerSideProvider;
@@ -6901,19 +7482,6 @@ static void test_cache_req_sa_(SAFEARRAY *sa, LONG exp_lbound[2], LONG exp_elems
     }
 }
 
-/*
- * This sequence of method calls is always used when creating an HUIANODE from
- * an IRawElementProviderSimple.
- */
-#define NODE_CREATE_SEQ(prov) \
-    { prov , PROV_GET_PROVIDER_OPTIONS }, \
-    /* Win10v1507 and below call this. */ \
-    { prov , PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */ \
-    { prov , PROV_GET_HOST_RAW_ELEMENT_PROVIDER }, \
-    { prov , PROV_GET_PROPERTY_VALUE }, \
-    { prov , FRAG_NAVIGATE }, /* NavigateDirection_Parent */ \
-    { prov , PROV_GET_PROVIDER_OPTIONS, METHOD_OPTIONAL } \
-
 static const struct prov_method_sequence cache_req_seq1[] = {
     { &Provider, PROV_GET_PROPERTY_VALUE, METHOD_TODO }, /* UIA_ProviderDescriptionPropertyId. */
     { 0 }
@@ -7412,18 +7980,6 @@ static void test_UiaGetUpdatedCache(void)
     CoUninitialize();
 }
 
-/*
- * This sequence of method calls is always used when creating an HUIANODE from
- * an IRawElementProviderSimple that returns an HWND from get_HostRawElementProvider.
- */
-#define NODE_CREATE_SEQ2(prov) \
-    { prov , PROV_GET_PROVIDER_OPTIONS }, \
-    /* Win10v1507 and below call this. */ \
-    { prov , PROV_GET_PROPERTY_VALUE, METHOD_OPTIONAL }, /* UIA_NativeWindowHandlePropertyId */ \
-    { prov , PROV_GET_HOST_RAW_ELEMENT_PROVIDER }, \
-    { prov , FRAG_NAVIGATE }, /* NavigateDirection_Parent */ \
-    { prov , PROV_GET_PROVIDER_OPTIONS, METHOD_OPTIONAL } \
-
 static const struct prov_method_sequence nav_seq1[] = {
     NODE_CREATE_SEQ2(&Provider),
     { &Provider, PROV_GET_PROVIDER_OPTIONS },
@@ -8240,6 +8796,8 @@ static void initialize_provider(struct Provider *prov, int prov_opts, HWND hwnd,
     prov->override_hwnd = NULL;
     prov->prop_override = NULL;
     prov->prop_override_count = 0;
+    memset(&prov->bounds_rect, 0, sizeof(prov->bounds_rect));
+    memset(&prov->value_pattern_data, 0, sizeof(prov->value_pattern_data));
     if (initialize_nav_links)
     {
         prov->frag_root = NULL;
@@ -9175,6 +9733,356 @@ static void test_UiaFind(void)
     CoUninitialize();
 }
 
+static HWND create_test_hwnd(const char *class_name)
+{
+    WNDCLASSA cls = { 0 };
+
+    cls.lpfnWndProc = test_wnd_proc;
+    cls.hInstance = GetModuleHandleA(NULL);
+    cls.lpszClassName = class_name;
+    RegisterClassA(&cls);
+
+    return CreateWindowA(class_name, "Test window", WS_OVERLAPPEDWINDOW,
+            0, 0, 100, 100, NULL, NULL, NULL, NULL);
+}
+
+static IUIAutomationElement *create_test_element_from_hwnd(IUIAutomation *uia_iface, HWND hwnd, BOOL block_hwnd_provs)
+{
+    IUIAutomationElement *element;
+    HRESULT hr;
+    VARIANT v;
+
+    if (block_hwnd_provs)
+    {
+        SET_EXPECT(prov_callback_base_hwnd);
+        SET_EXPECT(prov_callback_nonclient);
+        base_hwnd_prov = proxy_prov = parent_proxy_prov = nc_prov = NULL;
+        UiaRegisterProviderCallback(test_uia_provider_callback);
+    }
+    else
+        UiaRegisterProviderCallback(NULL);
+
+    initialize_provider(&Provider, ProviderOptions_ServerSideProvider, hwnd, TRUE);
+    prov_root = &Provider.IRawElementProviderSimple_iface;
+    SET_EXPECT(winproc_GETOBJECT_UiaRoot);
+    /* Only sent on Win7. */
+    SET_EXPECT(winproc_GETOBJECT_CLIENT);
+    hr = IUIAutomation_ElementFromHandle(uia_iface, hwnd, &element);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(!!element, "element == NULL\n");
+    ok(Provider.ref == 2, "Unexpected refcnt %ld\n", Provider.ref);
+    CHECK_CALLED(winproc_GETOBJECT_UiaRoot);
+    called_winproc_GETOBJECT_CLIENT = expect_winproc_GETOBJECT_CLIENT = 0;
+    if (block_hwnd_provs)
+    {
+        CHECK_CALLED(prov_callback_base_hwnd);
+        CHECK_CALLED(prov_callback_nonclient);
+    }
+
+    hr = IUIAutomationElement_GetCurrentPropertyValueEx(element, UIA_ProviderDescriptionPropertyId, TRUE, &v);
+    todo_wine ok(hr == S_OK, "Unexpected hr %#lx\n", hr);
+    if (SUCCEEDED(hr))
+    {
+        check_node_provider_desc_prefix(V_BSTR(&v), GetCurrentProcessId(), hwnd);
+        if (!block_hwnd_provs)
+        {
+            check_node_provider_desc(V_BSTR(&v), L"Main", L"Provider", FALSE);
+            check_node_provider_desc(V_BSTR(&v), L"Nonclient", NULL, FALSE);
+            check_node_provider_desc(V_BSTR(&v), L"Hwnd", NULL, TRUE);
+        }
+        else
+            check_node_provider_desc(V_BSTR(&v), L"Main", L"Provider", TRUE);
+
+        VariantClear(&v);
+    }
+
+    ok_method_sequence(node_from_hwnd2, "create_test_element");
+    UiaRegisterProviderCallback(NULL);
+
+    return element;
+}
+
+static void test_ElementFromHandle(IUIAutomation *uia_iface, BOOL is_cui8)
+{
+    HWND hwnd = create_test_hwnd("test_ElementFromHandle class");
+    IUIAutomationElement2 *element_2;
+    IUIAutomationElement *element;
+    HRESULT hr;
+
+    element = create_test_element_from_hwnd(uia_iface, hwnd, FALSE);
+    hr = IUIAutomationElement_QueryInterface(element, &IID_IUIAutomationElement2, (void **)&element_2);
+    if (is_cui8)
+    {
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(!!element_2, "element_2 == NULL\n");
+        IUIAutomationElement2_Release(element_2);
+    }
+    else
+        ok(hr == E_NOINTERFACE, "Unexpected hr %#lx.\n", hr);
+
+    IUIAutomationElement_Release(element);
+    ok(Provider.ref == 1, "Unexpected refcnt %ld\n", Provider.ref);
+
+    DestroyWindow(hwnd);
+    UnregisterClassA("test_ElementFromHandle class", NULL);
+    prov_root = NULL;
+}
+
+static void test_Element_GetPropertyValue(IUIAutomation *uia_iface)
+{
+    HWND hwnd = create_test_hwnd("test_Element_GetPropertyValue class");
+    const struct uia_element_property *elem_prop;
+    struct Provider_prop_override prop_override;
+    IUIAutomationElement *element, *element2;
+    int i, prop_id, tmp_int;
+    struct UiaRect uia_rect;
+    IUnknown *unk_ns;
+    BSTR tmp_bstr;
+    HRESULT hr;
+    RECT rect;
+    VARIANT v;
+
+    element = create_test_element_from_hwnd(uia_iface, hwnd, TRUE);
+    Provider.frag_root = &Provider.IRawElementProviderFragmentRoot_iface;
+    initialize_provider(&Provider_child, ProviderOptions_ServerSideProvider, NULL, TRUE);
+    provider_add_child(&Provider, &Provider_child);
+
+    hr = UiaGetReservedNotSupportedValue(&unk_ns);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    VariantInit(&v);
+    for (i = 0; i < ARRAY_SIZE(element_properties); i++)
+    {
+        elem_prop = &element_properties[i];
+
+        /* Skip ElementArray properties for now. */
+        if (elem_prop->type == UIAutomationType_ElementArray)
+            continue;
+
+        Provider.ret_invalid_prop_type = FALSE;
+        VariantClear(&v);
+        if (!(prop_id = UiaLookupId(AutomationIdentifierType_Property, elem_prop->prop_guid)))
+        {
+            win_skip("No propertyId for GUID %s, skipping further tests.\n", debugstr_guid(elem_prop->prop_guid));
+            break;
+        }
+
+        winetest_push_context("Element prop_id %d", prop_id);
+        hr = IUIAutomationElement_GetCurrentPropertyValueEx(element, prop_id, TRUE, &v);
+        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        check_uia_prop_val(prop_id, elem_prop->type, &v, TRUE);
+
+        /*
+         * Some properties have special behavior if an invalid value is
+         * returned, skip them here.
+         */
+        if (!elem_prop->skip_invalid)
+        {
+            Provider.ret_invalid_prop_type = TRUE;
+            hr = IUIAutomationElement_GetCurrentPropertyValueEx(element, prop_id, TRUE, &v);
+            ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+            if (SUCCEEDED(hr))
+            {
+                ok_method_sequence(get_prop_invalid_type_seq, NULL);
+                ok(V_VT(&v) == VT_UNKNOWN, "Unexpected vt %d\n", V_VT(&v));
+                ok(V_UNKNOWN(&v) == unk_ns, "unexpected IUnknown %p\n", V_UNKNOWN(&v));
+                VariantClear(&v);
+            }
+        }
+
+        winetest_pop_context();
+    }
+
+    /*
+     * IUIAutomationElement_get_CurrentControlType tests. If the value
+     * returned for UIA_ControlTypePropertyId is not a registered control
+     * type ID, we'll get back UIA_CustomControlTypeId.
+     */
+    tmp_int = 0xdeadb33f;
+    hr = IUIAutomationElement_get_CurrentControlType(element, &tmp_int);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    /*
+     * Win10v1507 and below don't check whether or not the returned control
+     * type ID is valid.
+     */
+    ok(tmp_int == UIA_CustomControlTypeId || broken(tmp_int == 0xdeadbeef), "Unexpected control type %#x\n", tmp_int);
+    ok_method_sequence(get_prop_seq, NULL);
+
+    Provider.ret_invalid_prop_type = TRUE;
+    tmp_int = 0xdeadbeef;
+    hr = IUIAutomationElement_get_CurrentControlType(element, &tmp_int);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(tmp_int == UIA_CustomControlTypeId, "Unexpected control type %#x\n", tmp_int);
+    Provider.ret_invalid_prop_type = FALSE;
+    ok_method_sequence(get_prop_invalid_type_seq, NULL);
+
+    /* Finally, a valid control type. */
+    V_VT(&v) = VT_I4;
+    V_I4(&v) = UIA_HyperlinkControlTypeId;
+    set_property_override(&prop_override, UIA_ControlTypePropertyId, &v);
+    set_provider_prop_override(&Provider, &prop_override, 1);
+    hr = IUIAutomationElement_get_CurrentControlType(element, &tmp_int);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(tmp_int == UIA_HyperlinkControlTypeId, "Unexpected control type %#x\n", tmp_int);
+    set_provider_prop_override(&Provider, NULL, 0);
+    ok_method_sequence(get_prop_seq, NULL);
+
+    /*
+     * IUIAutomationElement_get_CurrentName tests.
+     */
+    tmp_bstr = NULL;
+    hr = IUIAutomationElement_get_CurrentName(element, &tmp_bstr);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(!lstrcmpW(tmp_bstr, uia_bstr_prop_str), "Unexpected BSTR %s\n", wine_dbgstr_w(tmp_bstr));
+    SysFreeString(tmp_bstr);
+    ok_method_sequence(get_prop_seq, NULL);
+
+    tmp_bstr = NULL;
+    Provider.ret_invalid_prop_type = TRUE;
+    hr = IUIAutomationElement_get_CurrentName(element, &tmp_bstr);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(!lstrcmpW(tmp_bstr, L""), "Unexpected BSTR %s\n", wine_dbgstr_w(tmp_bstr));
+    SysFreeString(tmp_bstr);
+    initialize_provider(&Provider, ProviderOptions_ServerSideProvider, NULL, FALSE);
+    ok_method_sequence(get_prop_invalid_type_seq, NULL);
+
+    /*
+     * Windows 7 will call get_FragmentRoot in an endless loop until the fragment root returns an HWND.
+     * It's the only version with this behavior.
+     */
+    if (!UiaLookupId(AutomationIdentifierType_Property, &OptimizeForVisualContent_Property_GUID))
+    {
+        win_skip("Skipping UIA_BoundingRectanglePropertyId tests for Win7\n");
+        goto exit;
+    }
+
+    /*
+     * IUIAutomationElement_get_CurrentBoundingRectangle/UIA_BoundRectanglePropertyId tests.
+     */
+    hr = IUIAutomationElement_GetCurrentPropertyValueEx(element, UIA_LabeledByPropertyId, TRUE, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(V_VT(&v) == VT_UNKNOWN, "Unexpected vt %d\n", V_VT(&v));
+    ok(Provider_child.ref == 2, "Unexpected refcnt %ld\n", Provider.ref);
+
+    hr = IUnknown_QueryInterface(V_UNKNOWN(&v), &IID_IUIAutomationElement, (void **)&element2);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(!!element2, "element2 == NULL\n");
+    VariantClear(&v);
+
+    /* Non-empty bounding rectangle, will return a VT_R8 SAFEARRAY. */
+    set_uia_rect(&uia_rect, 0, 0, 50, 50);
+    Provider_child.bounds_rect = uia_rect;
+    hr = IUIAutomationElement_GetCurrentPropertyValueEx(element2, UIA_BoundingRectanglePropertyId, TRUE, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    check_uia_rect_val(&v, &uia_rect);
+    VariantClear(&v);
+    ok_method_sequence(get_bounding_rect_seq2, "get_bounding_rect_seq2");
+
+    hr = IUIAutomationElement_get_CurrentBoundingRectangle(element2, &rect);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    check_uia_rect_rect_val(&rect, &uia_rect);
+    memset(&rect, 0, sizeof(rect));
+    ok_method_sequence(get_bounding_rect_seq3, "get_bounding_rect_seq3");
+
+    /* Empty bounding rectangle will return ReservedNotSupportedValue. */
+    set_uia_rect(&uia_rect, 0, 0, 0, 0);
+    Provider_child.bounds_rect = uia_rect;
+    hr = IUIAutomationElement_GetCurrentPropertyValueEx(element2, UIA_BoundingRectanglePropertyId, TRUE, &v);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(V_VT(&v) == VT_UNKNOWN, "Unexpected vt %d\n", V_VT(&v));
+    ok(V_UNKNOWN(&v) == unk_ns, "unexpected IUnknown %p\n", V_UNKNOWN(&v));
+    VariantClear(&v);
+    ok_method_sequence(get_empty_bounding_rect_seq, "get_empty_bounding_rect_seq");
+
+    /* Returns an all 0 rect. */
+    hr = IUIAutomationElement_get_CurrentBoundingRectangle(element2, &rect);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    check_uia_rect_rect_val(&rect, &uia_rect);
+    ok_method_sequence(get_empty_bounding_rect_seq, "get_empty_bounding_rect_seq");
+
+    IUIAutomationElement_Release(element2);
+    ok(Provider_child.ref == 1, "Unexpected refcnt %ld\n", Provider_child.ref);
+    initialize_provider(&Provider_child, ProviderOptions_ServerSideProvider, NULL, FALSE);
+
+exit:
+    IUIAutomationElement_Release(element);
+    ok(Provider.ref == 1, "Unexpected refcnt %ld\n", Provider.ref);
+
+    DestroyWindow(hwnd);
+    UnregisterClassA("test_Element_GetPropertyValue class", NULL);
+}
+
+struct uia_com_classes {
+    const GUID *clsid;
+    const GUID *iid;
+};
+
+static const struct uia_com_classes com_classes[] = {
+    { &CLSID_CUIAutomation,  &IID_IUnknown },
+    { &CLSID_CUIAutomation,  &IID_IUIAutomation },
+    { &CLSID_CUIAutomation8, &IID_IUnknown },
+    { &CLSID_CUIAutomation8, &IID_IUIAutomation },
+    { &CLSID_CUIAutomation8, &IID_IUIAutomation2 },
+    { &CLSID_CUIAutomation8, &IID_IUIAutomation3 },
+    { &CLSID_CUIAutomation8, &IID_IUIAutomation4 },
+    { &CLSID_CUIAutomation8, &IID_IUIAutomation5 },
+    { &CLSID_CUIAutomation8, &IID_IUIAutomation6 },
+};
+
+static void test_CUIAutomation(void)
+{
+    IUIAutomation *uia_iface;
+    BOOL has_cui8 = TRUE;
+    HRESULT hr;
+    int i;
+
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);
+
+    for (i = 0; i < ARRAY_SIZE(com_classes); i++)
+    {
+        IUnknown *iface = NULL;
+
+        hr = CoCreateInstance(com_classes[i].clsid, NULL, CLSCTX_INPROC_SERVER, com_classes[i].iid,
+                (void **)&iface);
+
+        if ((com_classes[i].clsid == &CLSID_CUIAutomation8) && (hr == REGDB_E_CLASSNOTREG))
+        {
+            win_skip("CLSID_CUIAutomation8 class not registered, skipping further tests.\n");
+            has_cui8 = FALSE;
+            break;
+        }
+        else if ((com_classes[i].clsid == &CLSID_CUIAutomation8) && (hr == E_NOINTERFACE) &&
+                (com_classes[i].iid != &IID_IUIAutomation2) && (com_classes[i].iid != &IID_IUIAutomation) &&
+                (com_classes[i].iid != &IID_IUnknown))
+        {
+            win_skip("No object for clsid %s, iid %s, skipping further tests.\n", debugstr_guid(com_classes[i].clsid),
+                debugstr_guid(com_classes[i].iid));
+            break;
+        }
+
+        ok(hr == S_OK, "Failed to create interface for clsid %s, iid %s, hr %#lx\n",
+                debugstr_guid(com_classes[i].clsid), debugstr_guid(com_classes[i].iid), hr);
+        ok(!!iface, "iface == NULL\n");
+        IUnknown_Release(iface);
+    }
+
+    if (has_cui8)
+        hr = CoCreateInstance(&CLSID_CUIAutomation8, NULL, CLSCTX_INPROC_SERVER, &IID_IUIAutomation,
+                (void **)&uia_iface);
+    else
+        hr = CoCreateInstance(&CLSID_CUIAutomation, NULL, CLSCTX_INPROC_SERVER, &IID_IUIAutomation,
+                (void **)&uia_iface);
+    ok(hr == S_OK, "Failed to create IUIAutomation interface, hr %#lx\n", hr);
+    ok(!!uia_iface, "uia_iface == NULL\n");
+
+    test_ElementFromHandle(uia_iface, has_cui8);
+    test_Element_GetPropertyValue(uia_iface);
+
+    IUIAutomation_Release(uia_iface);
+    CoUninitialize();
+}
+
 /*
  * Once a process returns a UI Automation provider with
  * UiaReturnRawElementProvider it ends up in an implicit MTA until exit. This
@@ -9241,6 +10149,7 @@ START_TEST(uiautomation)
     test_UiaGetUpdatedCache();
     test_UiaNavigate();
     test_UiaFind();
+    test_CUIAutomation();
     if (uia_dll)
     {
         pUiaProviderFromIAccessible = (void *)GetProcAddress(uia_dll, "UiaProviderFromIAccessible");
diff --git a/dlls/uiautomationcore/uia_classes.idl b/dlls/uiautomationcore/uia_classes.idl
index 2dc7981b702..7272a09bfd6 100644
--- a/dlls/uiautomationcore/uia_classes.idl
+++ b/dlls/uiautomationcore/uia_classes.idl
@@ -25,11 +25,30 @@ struct uia_prop_info {
     int prop_id;
     int prop_type;
     int type;
+    int pattern_id;
+};
+
+struct uia_event_info {
+    const GUID *guid;
+    int event_id;
+    int event_arg_type;
+};
+
+struct uia_pattern_info {
+    const GUID *guid;
+    int pattern_id;
+    const GUID *pattern_iid;
+};
+
+struct uia_control_type_info {
+    const GUID *guid;
+    int control_type_id;
 };
 
 [
    version(1.0),
    uuid(8a9ca8eb-856b-43d9-abd7-4a590054064f),
+   id(1),
 ]
 library UIA_wine_private
 {
diff --git a/dlls/uiautomationcore/uia_classes_client.idl b/dlls/uiautomationcore/uia_classes_client.idl
new file mode 100644
index 00000000000..f6dcb236bea
--- /dev/null
+++ b/dlls/uiautomationcore/uia_classes_client.idl
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2022 Connor McAdams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep regtypelib
+
+#include "uiautomationclient.idl"
diff --git a/dlls/uiautomationcore/uia_classes_core.idl b/dlls/uiautomationcore/uia_classes_core.idl
new file mode 100644
index 00000000000..3cd0a7134ed
--- /dev/null
+++ b/dlls/uiautomationcore/uia_classes_core.idl
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2022 Connor McAdams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep regtypelib
+
+#include "uiautomationcore.idl"
diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 14f9977a4d6..ce2aeb21622 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -147,7 +147,7 @@ int uia_compare_safearrays(SAFEARRAY *sa1, SAFEARRAY *sa2, int prop_type)
 
     if (prop_type != UIAutomationType_IntArray)
     {
-        FIXME("Array type %#x value comparsion currently unimplemented.\n", prop_type);
+        FIXME("Array type %#x value comparison currently unimplemented.\n", prop_type);
         return -1;
     }
 
@@ -1391,10 +1391,89 @@ static HRESULT uia_provider_get_special_prop_val(struct uia_provider *prov,
         break;
     }
 
+    case UIA_BoundingRectanglePropertyId:
+    {
+        IRawElementProviderFragment *elfrag;
+        struct UiaRect rect = { 0 };
+        double rect_vals[4];
+        SAFEARRAY *sa;
+        LONG idx;
+
+        hr = IRawElementProviderSimple_QueryInterface(prov->elprov, &IID_IRawElementProviderFragment, (void **)&elfrag);
+        if (FAILED(hr) || !elfrag)
+            break;
+
+        hr = IRawElementProviderFragment_get_BoundingRectangle(elfrag, &rect);
+        IRawElementProviderFragment_Release(elfrag);
+        if (FAILED(hr) || (rect.width <= 0 || rect.height <= 0))
+            break;
+
+        if (!(sa = SafeArrayCreateVector(VT_R8, 0, ARRAY_SIZE(rect_vals))))
+            break;
+
+        rect_vals[0] = rect.left;
+        rect_vals[1] = rect.top;
+        rect_vals[2] = rect.width;
+        rect_vals[3] = rect.height;
+        for (idx = 0; idx < ARRAY_SIZE(rect_vals); idx++)
+        {
+            hr = SafeArrayPutElement(sa, &idx, &rect_vals[idx]);
+            if (FAILED(hr))
+            {
+                SafeArrayDestroy(sa);
+                break;
+            }
+        }
+
+        V_VT(ret_val) = VT_R8 | VT_ARRAY;
+        V_ARRAY(ret_val) = sa;
+        break;
+    }
+
+    default:
+        break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT uia_provider_get_pattern_prop_val(struct uia_provider *prov,
+        const struct uia_prop_info *prop_info, VARIANT *ret_val)
+{
+    const struct uia_pattern_info *pattern_info = uia_pattern_info_from_id(prop_info->pattern_id);
+    IUnknown *unk, *pattern_prov;
+    HRESULT hr;
+
+    unk = pattern_prov = NULL;
+    hr = IRawElementProviderSimple_GetPatternProvider(prov->elprov, prop_info->pattern_id, &unk);
+    if (FAILED(hr) || !unk)
+        return S_OK;
+
+    hr = IUnknown_QueryInterface(unk, pattern_info->pattern_iid, (void **)&pattern_prov);
+    IUnknown_Release(unk);
+    if (FAILED(hr) || !pattern_prov)
+    {
+        WARN("Failed to get pattern interface from object\n");
+        return S_OK;
+    }
+
+    switch (prop_info->prop_id)
+    {
+    case UIA_ValueIsReadOnlyPropertyId:
+    {
+        BOOL val;
+
+        hr = IValueProvider_get_IsReadOnly((IValueProvider *)pattern_prov, &val);
+        if (SUCCEEDED(hr))
+            variant_init_bool(ret_val, val);
+        break;
+    }
+
     default:
         break;
     }
 
+    IUnknown_Release(pattern_prov);
     return S_OK;
 }
 
@@ -1414,6 +1493,9 @@ static HRESULT WINAPI uia_provider_get_prop_val(IWineUiaProvider *iface,
     case PROP_TYPE_SPECIAL:
         return uia_provider_get_special_prop_val(prov, prop_info, ret_val);
 
+    case PROP_TYPE_PATTERN_PROP:
+        return uia_provider_get_pattern_prop_val(prov, prop_info, ret_val);
+
     default:
         break;
     }
diff --git a/dlls/uiautomationcore/uia_com_client.c b/dlls/uiautomationcore/uia_com_client.c
new file mode 100644
index 00000000000..b6f308275bb
--- /dev/null
+++ b/dlls/uiautomationcore/uia_com_client.c
@@ -0,0 +1,1723 @@
+/*
+ * Copyright 2022 Connor McAdams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "uia_private.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);
+
+/*
+ * IUIAutomationElement interface.
+ */
+struct uia_element {
+    IUIAutomationElement9 IUIAutomationElement9_iface;
+    LONG ref;
+
+    BOOL from_cui8;
+    HUIANODE node;
+};
+
+static inline struct uia_element *impl_from_IUIAutomationElement9(IUIAutomationElement9 *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_element, IUIAutomationElement9_iface);
+}
+
+static HRESULT WINAPI uia_element_QueryInterface(IUIAutomationElement9 *iface, REFIID riid, void **ppv)
+{
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IUIAutomationElement) || (element->from_cui8 &&
+            (IsEqualIID(riid, &IID_IUIAutomationElement2) || IsEqualIID(riid, &IID_IUIAutomationElement3) ||
+            IsEqualIID(riid, &IID_IUIAutomationElement4) || IsEqualIID(riid, &IID_IUIAutomationElement5) ||
+            IsEqualIID(riid, &IID_IUIAutomationElement6) || IsEqualIID(riid, &IID_IUIAutomationElement7) ||
+            IsEqualIID(riid, &IID_IUIAutomationElement8) || IsEqualIID(riid, &IID_IUIAutomationElement9))))
+        *ppv = iface;
+    else
+        return E_NOINTERFACE;
+
+    IUIAutomationElement9_AddRef(iface);
+    return S_OK;
+}
+
+static ULONG WINAPI uia_element_AddRef(IUIAutomationElement9 *iface)
+{
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+    ULONG ref = InterlockedIncrement(&element->ref);
+
+    TRACE("%p, refcount %ld\n", element, ref);
+    return ref;
+}
+
+static ULONG WINAPI uia_element_Release(IUIAutomationElement9 *iface)
+{
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+    ULONG ref = InterlockedDecrement(&element->ref);
+
+    TRACE("%p, refcount %ld\n", element, ref);
+    if (!ref)
+    {
+        UiaNodeRelease(element->node);
+        heap_free(element);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI uia_element_SetFocus(IUIAutomationElement9 *iface)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetRuntimeId(IUIAutomationElement9 *iface, SAFEARRAY **runtime_id)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindFirst(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, IUIAutomationElement **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindAll(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, IUIAutomationElementArray **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindFirstBuildCache(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, IUIAutomationCacheRequest *cache_req, IUIAutomationElement **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindAllBuildCache(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, IUIAutomationCacheRequest *cache_req, IUIAutomationElementArray **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_BuildUpdatedCache(IUIAutomationElement9 *iface, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationElement **updated_elem)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCurrentPropertyValue(IUIAutomationElement9 *iface, PROPERTYID prop_id,
+        VARIANT *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT create_uia_element(IUIAutomationElement **iface, BOOL from_cui8, HUIANODE node);
+static HRESULT WINAPI uia_element_GetCurrentPropertyValueEx(IUIAutomationElement9 *iface, PROPERTYID prop_id,
+        BOOL ignore_default, VARIANT *ret_val)
+{
+    const struct uia_prop_info *prop_info = uia_prop_info_from_id(prop_id);
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+    HRESULT hr;
+
+    TRACE("%p, %d, %d, %p\n", iface, prop_id, ignore_default, ret_val);
+
+    if (!ignore_default)
+        FIXME("Default values currently unimplemented\n");
+
+    VariantInit(ret_val);
+    if (prop_info->type == UIAutomationType_ElementArray)
+    {
+        FIXME("ElementArray property types currently unsupported for IUIAutomationElement\n");
+        return E_NOTIMPL;
+    }
+
+    hr = UiaGetPropertyValue(element->node, prop_id, ret_val);
+    if ((prop_info->type == UIAutomationType_Element) && (V_VT(ret_val) != VT_UNKNOWN))
+    {
+        IUIAutomationElement *out_elem;
+        HUIANODE node;
+
+        hr = UiaHUiaNodeFromVariant(ret_val, &node);
+        VariantClear(ret_val);
+        if (FAILED(hr))
+            return hr;
+
+        hr = create_uia_element(&out_elem, element->from_cui8, node);
+        if (SUCCEEDED(hr))
+        {
+            V_VT(ret_val) = VT_UNKNOWN;
+            V_UNKNOWN(ret_val) = (IUnknown *)out_elem;
+        }
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI uia_element_GetCachedPropertyValue(IUIAutomationElement9 *iface, PROPERTYID prop_id,
+        VARIANT *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCachedPropertyValueEx(IUIAutomationElement9 *iface, PROPERTYID prop_id,
+        BOOL ignore_default, VARIANT *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCurrentPatternAs(IUIAutomationElement9 *iface, PATTERNID pattern_id,
+        REFIID riid, void **out_pattern)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCachedPatternAs(IUIAutomationElement9 *iface, PATTERNID pattern_id,
+        REFIID riid, void **out_pattern)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCurrentPattern(IUIAutomationElement9 *iface, PATTERNID pattern_id,
+        IUnknown **out_pattern)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCachedPattern(IUIAutomationElement9 *iface, PATTERNID pattern_id,
+        IUnknown **patternObject)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCachedParent(IUIAutomationElement9 *iface, IUIAutomationElement **parent)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCachedChildren(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **children)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentProcessId(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentControlType(IUIAutomationElement9 *iface, CONTROLTYPEID *ret_val)
+{
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+    const struct uia_control_type_info *control_type_info = NULL;
+    HRESULT hr;
+    VARIANT v;
+
+    TRACE("%p, %p\n", iface, ret_val);
+
+    VariantInit(&v);
+    *ret_val = UIA_CustomControlTypeId;
+    hr = UiaGetPropertyValue(element->node, UIA_ControlTypePropertyId, &v);
+    if (SUCCEEDED(hr) && V_VT(&v) == VT_I4)
+    {
+        if ((control_type_info = uia_control_type_info_from_id(V_I4(&v))))
+            *ret_val = control_type_info->control_type_id;
+        else
+            WARN("Provider returned invalid control type ID %ld\n", V_I4(&v));
+    }
+
+    VariantClear(&v);
+    return hr;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentLocalizedControlType(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentName(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+    HRESULT hr;
+    VARIANT v;
+
+    TRACE("%p, %p\n", iface, ret_val);
+
+    VariantInit(&v);
+    hr = UiaGetPropertyValue(element->node, UIA_NamePropertyId, &v);
+    if (SUCCEEDED(hr) && V_VT(&v) == VT_BSTR && V_BSTR(&v))
+        *ret_val = SysAllocString(V_BSTR(&v));
+    else
+        *ret_val = SysAllocString(L"");
+
+    VariantClear(&v);
+    return hr;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAcceleratorKey(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAccessKey(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentHasKeyboardFocus(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsKeyboardFocusable(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsEnabled(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAutomationId(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentClassName(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentHelpText(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentCulture(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsControlElement(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsContentElement(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsPassword(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentNativeWindowHandle(IUIAutomationElement9 *iface, UIA_HWND *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentItemType(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsOffscreen(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentOrientation(IUIAutomationElement9 *iface, enum OrientationType *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentFrameworkId(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsRequiredForForm(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentItemStatus(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentBoundingRectangle(IUIAutomationElement9 *iface, RECT *ret_val)
+{
+    struct uia_element *element = impl_from_IUIAutomationElement9(iface);
+    HRESULT hr;
+    VARIANT v;
+
+    TRACE("%p, %p\n", element, ret_val);
+
+    memset(ret_val, 0, sizeof(*ret_val));
+    VariantInit(&v);
+    hr = UiaGetPropertyValue(element->node, UIA_BoundingRectanglePropertyId, &v);
+    if (SUCCEEDED(hr) && V_VT(&v) == (VT_R8 | VT_ARRAY))
+    {
+        double vals[4];
+        LONG idx;
+
+        for (idx = 0; idx < ARRAY_SIZE(vals); idx++)
+            SafeArrayGetElement(V_ARRAY(&v), &idx, &vals[idx]);
+
+        ret_val->left = vals[0];
+        ret_val->top = vals[1];
+        ret_val->right = ret_val->left + vals[2];
+        ret_val->bottom = ret_val->top + vals[3];
+    }
+
+    VariantClear(&v);
+    return hr;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentLabeledBy(IUIAutomationElement9 *iface, IUIAutomationElement **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAriaRole(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAriaProperties(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsDataValidForForm(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentControllerFor(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentDescribedBy(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentFlowsTo(IUIAutomationElement9 *iface, IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentProviderDescription(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedProcessId(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedControlType(IUIAutomationElement9 *iface, CONTROLTYPEID *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedLocalizedControlType(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedName(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAcceleratorKey(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAccessKey(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedHasKeyboardFocus(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsKeyboardFocusable(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsEnabled(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAutomationId(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedClassName(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedHelpText(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedCulture(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsControlElement(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsContentElement(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsPassword(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedNativeWindowHandle(IUIAutomationElement9 *iface, UIA_HWND *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedItemType(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsOffscreen(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedOrientation(IUIAutomationElement9 *iface,
+        enum OrientationType *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedFrameworkId(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsRequiredForForm(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedItemStatus(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedBoundingRectangle(IUIAutomationElement9 *iface, RECT *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedLabeledBy(IUIAutomationElement9 *iface, IUIAutomationElement **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAriaRole(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAriaProperties(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsDataValidForForm(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedControllerFor(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedDescribedBy(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedFlowsTo(IUIAutomationElement9 *iface, IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedProviderDescription(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetClickablePoint(IUIAutomationElement9 *iface, POINT *clickable, BOOL *got_clickable)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentOptimizeForVisualContent(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedOptimizeForVisualContent(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentLiveSetting(IUIAutomationElement9 *iface, enum LiveSetting *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedLiveSetting(IUIAutomationElement9 *iface, enum LiveSetting *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentFlowsFrom(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedFlowsFrom(IUIAutomationElement9 *iface, IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_ShowContextMenu(IUIAutomationElement9 *iface)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsPeripheral(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsPeripheral(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentPositionInSet(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentSizeOfSet(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentLevel(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAnnotationTypes(IUIAutomationElement9 *iface, SAFEARRAY **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentAnnotationObjects(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedPositionInSet(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedSizeOfSet(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedLevel(IUIAutomationElement9 *iface, int *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAnnotationTypes(IUIAutomationElement9 *iface, SAFEARRAY **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedAnnotationObjects(IUIAutomationElement9 *iface,
+        IUIAutomationElementArray **ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentLandmarkType(IUIAutomationElement9 *iface, LANDMARKTYPEID *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentLocalizedLandmarkType(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedLandmarkType(IUIAutomationElement9 *iface, LANDMARKTYPEID *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedLocalizedLandmarkType(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentFullDescription(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedFullDescription(IUIAutomationElement9 *iface, BSTR *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindFirstWithOptions(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, enum TreeTraversalOptions traversal_opts, IUIAutomationElement *root,
+        IUIAutomationElement **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindAllWithOptions(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, enum TreeTraversalOptions traversal_opts, IUIAutomationElement *root,
+        IUIAutomationElementArray **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindFirstWithOptionsBuildCache(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, IUIAutomationCacheRequest *cache_req,
+        enum TreeTraversalOptions traversal_opts, IUIAutomationElement *root, IUIAutomationElement **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_FindAllWithOptionsBuildCache(IUIAutomationElement9 *iface, enum TreeScope scope,
+        IUIAutomationCondition *condition, IUIAutomationCacheRequest *cache_req,
+        enum TreeTraversalOptions traversal_opts, IUIAutomationElement *root, IUIAutomationElementArray **found)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_GetCurrentMetadataValue(IUIAutomationElement9 *iface, int target_id,
+        METADATAID metadata_id, VARIANT *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentHeadingLevel(IUIAutomationElement9 *iface, HEADINGLEVELID *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedHeadingLevel(IUIAutomationElement9 *iface, HEADINGLEVELID *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CurrentIsDialog(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_element_get_CachedIsDialog(IUIAutomationElement9 *iface, BOOL *ret_val)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static const IUIAutomationElement9Vtbl uia_element_vtbl = {
+    uia_element_QueryInterface,
+    uia_element_AddRef,
+    uia_element_Release,
+    uia_element_SetFocus,
+    uia_element_GetRuntimeId,
+    uia_element_FindFirst,
+    uia_element_FindAll,
+    uia_element_FindFirstBuildCache,
+    uia_element_FindAllBuildCache,
+    uia_element_BuildUpdatedCache,
+    uia_element_GetCurrentPropertyValue,
+    uia_element_GetCurrentPropertyValueEx,
+    uia_element_GetCachedPropertyValue,
+    uia_element_GetCachedPropertyValueEx,
+    uia_element_GetCurrentPatternAs,
+    uia_element_GetCachedPatternAs,
+    uia_element_GetCurrentPattern,
+    uia_element_GetCachedPattern,
+    uia_element_GetCachedParent,
+    uia_element_GetCachedChildren,
+    uia_element_get_CurrentProcessId,
+    uia_element_get_CurrentControlType,
+    uia_element_get_CurrentLocalizedControlType,
+    uia_element_get_CurrentName,
+    uia_element_get_CurrentAcceleratorKey,
+    uia_element_get_CurrentAccessKey,
+    uia_element_get_CurrentHasKeyboardFocus,
+    uia_element_get_CurrentIsKeyboardFocusable,
+    uia_element_get_CurrentIsEnabled,
+    uia_element_get_CurrentAutomationId,
+    uia_element_get_CurrentClassName,
+    uia_element_get_CurrentHelpText,
+    uia_element_get_CurrentCulture,
+    uia_element_get_CurrentIsControlElement,
+    uia_element_get_CurrentIsContentElement,
+    uia_element_get_CurrentIsPassword,
+    uia_element_get_CurrentNativeWindowHandle,
+    uia_element_get_CurrentItemType,
+    uia_element_get_CurrentIsOffscreen,
+    uia_element_get_CurrentOrientation,
+    uia_element_get_CurrentFrameworkId,
+    uia_element_get_CurrentIsRequiredForForm,
+    uia_element_get_CurrentItemStatus,
+    uia_element_get_CurrentBoundingRectangle,
+    uia_element_get_CurrentLabeledBy,
+    uia_element_get_CurrentAriaRole,
+    uia_element_get_CurrentAriaProperties,
+    uia_element_get_CurrentIsDataValidForForm,
+    uia_element_get_CurrentControllerFor,
+    uia_element_get_CurrentDescribedBy,
+    uia_element_get_CurrentFlowsTo,
+    uia_element_get_CurrentProviderDescription,
+    uia_element_get_CachedProcessId,
+    uia_element_get_CachedControlType,
+    uia_element_get_CachedLocalizedControlType,
+    uia_element_get_CachedName,
+    uia_element_get_CachedAcceleratorKey,
+    uia_element_get_CachedAccessKey,
+    uia_element_get_CachedHasKeyboardFocus,
+    uia_element_get_CachedIsKeyboardFocusable,
+    uia_element_get_CachedIsEnabled,
+    uia_element_get_CachedAutomationId,
+    uia_element_get_CachedClassName,
+    uia_element_get_CachedHelpText,
+    uia_element_get_CachedCulture,
+    uia_element_get_CachedIsControlElement,
+    uia_element_get_CachedIsContentElement,
+    uia_element_get_CachedIsPassword,
+    uia_element_get_CachedNativeWindowHandle,
+    uia_element_get_CachedItemType,
+    uia_element_get_CachedIsOffscreen,
+    uia_element_get_CachedOrientation,
+    uia_element_get_CachedFrameworkId,
+    uia_element_get_CachedIsRequiredForForm,
+    uia_element_get_CachedItemStatus,
+    uia_element_get_CachedBoundingRectangle,
+    uia_element_get_CachedLabeledBy,
+    uia_element_get_CachedAriaRole,
+    uia_element_get_CachedAriaProperties,
+    uia_element_get_CachedIsDataValidForForm,
+    uia_element_get_CachedControllerFor,
+    uia_element_get_CachedDescribedBy,
+    uia_element_get_CachedFlowsTo,
+    uia_element_get_CachedProviderDescription,
+    uia_element_GetClickablePoint,
+    uia_element_get_CurrentOptimizeForVisualContent,
+    uia_element_get_CachedOptimizeForVisualContent,
+    uia_element_get_CurrentLiveSetting,
+    uia_element_get_CachedLiveSetting,
+    uia_element_get_CurrentFlowsFrom,
+    uia_element_get_CachedFlowsFrom,
+    uia_element_ShowContextMenu,
+    uia_element_get_CurrentIsPeripheral,
+    uia_element_get_CachedIsPeripheral,
+    uia_element_get_CurrentPositionInSet,
+    uia_element_get_CurrentSizeOfSet,
+    uia_element_get_CurrentLevel,
+    uia_element_get_CurrentAnnotationTypes,
+    uia_element_get_CurrentAnnotationObjects,
+    uia_element_get_CachedPositionInSet,
+    uia_element_get_CachedSizeOfSet,
+    uia_element_get_CachedLevel,
+    uia_element_get_CachedAnnotationTypes,
+    uia_element_get_CachedAnnotationObjects,
+    uia_element_get_CurrentLandmarkType,
+    uia_element_get_CurrentLocalizedLandmarkType,
+    uia_element_get_CachedLandmarkType,
+    uia_element_get_CachedLocalizedLandmarkType,
+    uia_element_get_CurrentFullDescription,
+    uia_element_get_CachedFullDescription,
+    uia_element_FindFirstWithOptions,
+    uia_element_FindAllWithOptions,
+    uia_element_FindFirstWithOptionsBuildCache,
+    uia_element_FindAllWithOptionsBuildCache,
+    uia_element_GetCurrentMetadataValue,
+    uia_element_get_CurrentHeadingLevel,
+    uia_element_get_CachedHeadingLevel,
+    uia_element_get_CurrentIsDialog,
+    uia_element_get_CachedIsDialog,
+};
+
+static HRESULT create_uia_element(IUIAutomationElement **iface, BOOL from_cui8, HUIANODE node)
+{
+    struct uia_element *element = heap_alloc_zero(sizeof(*element));
+
+    *iface = NULL;
+    if (!element)
+        return E_OUTOFMEMORY;
+
+    element->IUIAutomationElement9_iface.lpVtbl = &uia_element_vtbl;
+    element->ref = 1;
+    element->from_cui8 = from_cui8;
+    element->node = node;
+
+    *iface = (IUIAutomationElement *)&element->IUIAutomationElement9_iface;
+    return S_OK;
+}
+
+/*
+ * IUIAutomation interface.
+ */
+struct uia_iface {
+    IUIAutomation6 IUIAutomation6_iface;
+    LONG ref;
+
+    BOOL is_cui8;
+};
+
+static inline struct uia_iface *impl_from_IUIAutomation6(IUIAutomation6 *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_iface, IUIAutomation6_iface);
+}
+
+static HRESULT WINAPI uia_iface_QueryInterface(IUIAutomation6 *iface, REFIID riid, void **ppv)
+{
+    struct uia_iface *uia_iface = impl_from_IUIAutomation6(iface);
+
+    *ppv = NULL;
+    if (IsEqualIID(riid, &IID_IUIAutomation) || IsEqualIID(riid, &IID_IUnknown))
+        *ppv = iface;
+    else if (uia_iface->is_cui8 &&
+            (IsEqualIID(riid, &IID_IUIAutomation2) ||
+            IsEqualIID(riid, &IID_IUIAutomation3) ||
+            IsEqualIID(riid, &IID_IUIAutomation4) ||
+            IsEqualIID(riid, &IID_IUIAutomation5) ||
+            IsEqualIID(riid, &IID_IUIAutomation6)))
+        *ppv = iface;
+    else
+        return E_NOINTERFACE;
+
+    IUIAutomation6_AddRef(iface);
+    return S_OK;
+}
+
+static ULONG WINAPI uia_iface_AddRef(IUIAutomation6 *iface)
+{
+    struct uia_iface *uia_iface = impl_from_IUIAutomation6(iface);
+    ULONG ref = InterlockedIncrement(&uia_iface->ref);
+
+    TRACE("%p, refcount %ld\n", uia_iface, ref);
+    return ref;
+}
+
+static ULONG WINAPI uia_iface_Release(IUIAutomation6 *iface)
+{
+    struct uia_iface *uia_iface = impl_from_IUIAutomation6(iface);
+    ULONG ref = InterlockedDecrement(&uia_iface->ref);
+
+    TRACE("%p, refcount %ld\n", uia_iface, ref);
+    if (!ref)
+        heap_free(uia_iface);
+    return ref;
+}
+
+static HRESULT WINAPI uia_iface_CompareElements(IUIAutomation6 *iface, IUIAutomationElement *elem1,
+        IUIAutomationElement *elem2, BOOL *match)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, elem1, elem2, match);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CompareRuntimeIds(IUIAutomation6 *iface, SAFEARRAY *rt_id1, SAFEARRAY *rt_id2,
+        BOOL *match)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, rt_id1, rt_id2, match);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_GetRootElement(IUIAutomation6 *iface, IUIAutomationElement **root)
+{
+    FIXME("%p, %p: stub\n", iface, root);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_ElementFromHandle(IUIAutomation6 *iface, UIA_HWND hwnd, IUIAutomationElement **out_elem)
+{
+    struct uia_iface *uia_iface = impl_from_IUIAutomation6(iface);
+    HUIANODE node;
+    HRESULT hr;
+
+    TRACE("%p, %p, %p\n", iface, hwnd, out_elem);
+
+    hr = UiaNodeFromHandle((HWND)hwnd, &node);
+    if (FAILED(hr))
+        return hr;
+
+    return create_uia_element(out_elem, uia_iface->is_cui8, node);
+}
+
+static HRESULT WINAPI uia_iface_ElementFromPoint(IUIAutomation6 *iface, POINT pt, IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %s, %p: stub\n", iface, wine_dbgstr_point(&pt), out_elem);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_GetFocusedElement(IUIAutomation6 *iface, IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %p: stub\n", iface, out_elem);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_GetRootElementBuildCache(IUIAutomation6 *iface, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationElement **out_root)
+{
+    FIXME("%p, %p, %p: stub\n", iface, cache_req, out_root);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_ElementFromHandleBuildCache(IUIAutomation6 *iface, UIA_HWND hwnd,
+        IUIAutomationCacheRequest *cache_req, IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, hwnd, cache_req, out_elem);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_ElementFromPointBuildCache(IUIAutomation6 *iface, POINT pt,
+        IUIAutomationCacheRequest *cache_req, IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %s, %p, %p: stub\n", iface, wine_dbgstr_point(&pt), cache_req, out_elem);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_GetFocusedElementBuildCache(IUIAutomation6 *iface,
+        IUIAutomationCacheRequest *cache_req, IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %p, %p: stub\n", iface, cache_req, out_elem);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateTreeWalker(IUIAutomation6 *iface, IUIAutomationCondition *cond,
+        IUIAutomationTreeWalker **out_walker)
+{
+    FIXME("%p, %p, %p: stub\n", iface, cond, out_walker);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ControlViewWalker(IUIAutomation6 *iface, IUIAutomationTreeWalker **out_walker)
+{
+    FIXME("%p, %p: stub\n", iface, out_walker);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ContentViewWalker(IUIAutomation6 *iface, IUIAutomationTreeWalker **out_walker)
+{
+    FIXME("%p, %p: stub\n", iface, out_walker);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_RawViewWalker(IUIAutomation6 *iface, IUIAutomationTreeWalker **out_walker)
+{
+    FIXME("%p, %p: stub\n", iface, out_walker);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_RawViewCondition(IUIAutomation6 *iface, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p: stub\n", iface, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ControlViewCondition(IUIAutomation6 *iface, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p: stub\n", iface, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ContentViewCondition(IUIAutomation6 *iface, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p: stub\n", iface, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateCacheRequest(IUIAutomation6 *iface, IUIAutomationCacheRequest **out_cache_req)
+{
+    FIXME("%p, %p: stub\n", iface, out_cache_req);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateTrueCondition(IUIAutomation6 *iface, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p: stub\n", iface, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateFalseCondition(IUIAutomation6 *iface, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p: stub\n", iface, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreatePropertyCondition(IUIAutomation6 *iface, PROPERTYID prop_id, VARIANT val,
+        IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %d, %s, %p: stub\n", iface, prop_id, debugstr_variant(&val), out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreatePropertyConditionEx(IUIAutomation6 *iface, PROPERTYID prop_id, VARIANT val,
+        enum PropertyConditionFlags flags, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %d, %s, %#x, %p: stub\n", iface, prop_id, debugstr_variant(&val), flags, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateAndCondition(IUIAutomation6 *iface, IUIAutomationCondition *cond1,
+        IUIAutomationCondition *cond2, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, cond1, cond2, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateAndConditionFromArray(IUIAutomation6 *iface, SAFEARRAY *conds,
+        IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %p: stub\n", iface, conds, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateAndConditionFromNativeArray(IUIAutomation6 *iface, IUIAutomationCondition **conds,
+        int conds_count, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %d, %p: stub\n", iface, conds, conds_count, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateOrCondition(IUIAutomation6 *iface, IUIAutomationCondition *cond1,
+        IUIAutomationCondition *cond2, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, cond1, cond2, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateOrConditionFromArray(IUIAutomation6 *iface, SAFEARRAY *conds,
+        IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %p: stub\n", iface, conds, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateOrConditionFromNativeArray(IUIAutomation6 *iface, IUIAutomationCondition **conds,
+        int conds_count, IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %d, %p: stub\n", iface, conds, conds_count, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateNotCondition(IUIAutomation6 *iface, IUIAutomationCondition *cond,
+        IUIAutomationCondition **out_condition)
+{
+    FIXME("%p, %p, %p: stub\n", iface, cond, out_condition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddAutomationEventHandler(IUIAutomation6 *iface, EVENTID event_id,
+        IUIAutomationElement *elem, enum TreeScope scope, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationEventHandler *handler)
+{
+    FIXME("%p, %d, %p, %#x, %p, %p: stub\n", iface, event_id, elem, scope, cache_req, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveAutomationEventHandler(IUIAutomation6 *iface, EVENTID event_id,
+        IUIAutomationElement *elem, IUIAutomationEventHandler *handler)
+{
+    FIXME("%p, %d, %p, %p: stub\n", iface, event_id, elem, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddPropertyChangedEventHandlerNativeArray(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, enum TreeScope scope, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationPropertyChangedEventHandler *handler, PROPERTYID *props, int props_count)
+{
+    FIXME("%p, %p, %#x, %p, %p, %p, %d: stub\n", iface, elem, scope, cache_req, handler, props, props_count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddPropertyChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, enum TreeScope scope, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationPropertyChangedEventHandler *handler, SAFEARRAY *props)
+{
+    FIXME("%p, %p, %#x, %p, %p, %p: stub\n", iface, elem, scope, cache_req, handler, props);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemovePropertyChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, IUIAutomationPropertyChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddStructureChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, enum TreeScope scope, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationStructureChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %#x, %p, %p: stub\n", iface, elem, scope, cache_req, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveStructureChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, IUIAutomationStructureChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddFocusChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationCacheRequest *cache_req, IUIAutomationFocusChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %p: stub\n", iface, cache_req, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveFocusChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationFocusChangedEventHandler *handler)
+{
+    FIXME("%p, %p: stub\n", iface, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveAllEventHandlers(IUIAutomation6 *iface)
+{
+    FIXME("%p: stub\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_IntNativeArrayToSafeArray(IUIAutomation6 *iface, int *arr, int arr_count,
+        SAFEARRAY **out_sa)
+{
+    FIXME("%p, %p, %d, %p: stub\n", iface, arr, arr_count, out_sa);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_IntSafeArrayToNativeArray(IUIAutomation6 *iface, SAFEARRAY *sa, int **out_arr,
+        int *out_arr_count)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, sa, out_arr, out_arr_count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RectToVariant(IUIAutomation6 *iface, RECT rect, VARIANT *out_var)
+{
+    FIXME("%p, %s, %p: stub\n", iface, wine_dbgstr_rect(&rect), out_var);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_VariantToRect(IUIAutomation6 *iface, VARIANT var, RECT *out_rect)
+{
+    FIXME("%p, %s, %p: stub\n", iface, debugstr_variant(&var), out_rect);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_SafeArrayToRectNativeArray(IUIAutomation6 *iface, SAFEARRAY *sa, RECT **out_rect_arr,
+        int *out_rect_arr_count)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, sa, out_rect_arr, out_rect_arr_count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CreateProxyFactoryEntry(IUIAutomation6 *iface, IUIAutomationProxyFactory *factory,
+        IUIAutomationProxyFactoryEntry **out_entry)
+{
+    FIXME("%p, %p, %p: stub\n", iface, factory, out_entry);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ProxyFactoryMapping(IUIAutomation6 *iface,
+        IUIAutomationProxyFactoryMapping **out_factory_map)
+{
+    FIXME("%p, %p: stub\n", iface, out_factory_map);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_GetPropertyProgrammaticName(IUIAutomation6 *iface, PROPERTYID prop_id, BSTR *out_name)
+{
+    FIXME("%p, %d, %p: stub\n", iface, prop_id, out_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_GetPatternProgrammaticName(IUIAutomation6 *iface, PATTERNID pattern_id, BSTR *out_name)
+{
+    FIXME("%p, %d, %p: stub\n", iface, pattern_id, out_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_PollForPotentialSupportedPatterns(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        SAFEARRAY **out_pattern_ids, SAFEARRAY **out_pattern_names)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, elem, out_pattern_ids, out_pattern_names);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_PollForPotentialSupportedProperties(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        SAFEARRAY **out_prop_ids, SAFEARRAY **out_prop_names)
+{
+    FIXME("%p, %p, %p, %p: stub\n", iface, elem, out_prop_ids, out_prop_names);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_CheckNotSupported(IUIAutomation6 *iface, VARIANT in_val, BOOL *match)
+{
+    FIXME("%p, %s, %p: stub\n", iface, debugstr_variant(&in_val), match);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ReservedNotSupportedValue(IUIAutomation6 *iface, IUnknown **out_unk)
+{
+    FIXME("%p, %p: stub\n", iface, out_unk);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ReservedMixedAttributeValue(IUIAutomation6 *iface, IUnknown **out_unk)
+{
+    FIXME("%p, %p: stub\n", iface, out_unk);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_ElementFromIAccessible(IUIAutomation6 *iface, IAccessible *acc, int cid,
+        IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %p, %d, %p: stub\n", iface, acc, cid, out_elem);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_ElementFromIAccessibleBuildCache(IUIAutomation6 *iface, IAccessible *acc, int cid,
+        IUIAutomationCacheRequest *cache_req, IUIAutomationElement **out_elem)
+{
+    FIXME("%p, %p, %d, %p, %p: stub\n", iface, acc, cid, cache_req, out_elem);
+    return E_NOTIMPL;
+}
+
+/* IUIAutomation2 methods */
+static HRESULT WINAPI uia_iface_get_AutoSetFocus(IUIAutomation6 *iface, BOOL *out_auto_set_focus)
+{
+    FIXME("%p, %p: stub\n", iface, out_auto_set_focus);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_put_AutoSetFocus(IUIAutomation6 *iface, BOOL auto_set_focus)
+{
+    FIXME("%p, %d: stub\n", iface, auto_set_focus);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ConnectionTimeout(IUIAutomation6 *iface, DWORD *out_timeout)
+{
+    FIXME("%p, %p: stub\n", iface, out_timeout);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_put_ConnectionTimeout(IUIAutomation6 *iface, DWORD timeout)
+{
+    FIXME("%p, %ld: stub\n", iface, timeout);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_TransactionTimeout(IUIAutomation6 *iface, DWORD *out_timeout)
+{
+    FIXME("%p, %p: stub\n", iface, out_timeout);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_put_TransactionTimeout(IUIAutomation6 *iface, DWORD timeout)
+{
+    FIXME("%p, %ld: stub\n", iface, timeout);
+    return E_NOTIMPL;
+}
+
+/* IUIAutomation3 methods */
+static HRESULT WINAPI uia_iface_AddTextEditTextChangedEventHandler(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        enum TreeScope scope, enum TextEditChangeType change_type, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationTextEditTextChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %#x, %d, %p, %p: stub\n", iface, elem, scope, change_type, cache_req, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveTextEditTextChangedEventHandler(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        IUIAutomationTextEditTextChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler);
+    return E_NOTIMPL;
+}
+
+/* IUIAutomation4 methods */
+static HRESULT WINAPI uia_iface_AddChangesEventHandler(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        enum TreeScope scope, int *change_types, int change_types_count, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationChangesEventHandler *handler)
+{
+    FIXME("%p, %p, %#x, %p, %d, %p, %p: stub\n", iface, elem, scope, change_types, change_types_count, cache_req,
+            handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveChangesEventHandler(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        IUIAutomationChangesEventHandler *handler)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler);
+    return E_NOTIMPL;
+}
+
+/* IUIAutomation5 methods */
+static HRESULT WINAPI uia_iface_AddNotificationEventHandler(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        enum TreeScope scope, IUIAutomationCacheRequest *cache_req, IUIAutomationNotificationEventHandler *handler)
+{
+    FIXME("%p, %p, %#x, %p, %p: stub\n", iface, elem, scope, cache_req, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveNotificationEventHandler(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        IUIAutomationNotificationEventHandler *handler)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler);
+    return E_NOTIMPL;
+}
+
+/* IUIAutomation6 methods */
+static HRESULT WINAPI uia_iface_CreateEventHandlerGroup(IUIAutomation6 *iface,
+        IUIAutomationEventHandlerGroup **out_handler_group)
+{
+    FIXME("%p, %p: stub\n", iface, out_handler_group);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddEventHandlerGroup(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        IUIAutomationEventHandlerGroup *handler_group)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler_group);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveEventHandlerGroup(IUIAutomation6 *iface, IUIAutomationElement *elem,
+        IUIAutomationEventHandlerGroup *handler_group)
+{
+    FIXME("%p, %p, %p: stub\n", iface, elem, handler_group);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_ConnectionRecoveryBehavior(IUIAutomation6 *iface,
+        enum ConnectionRecoveryBehaviorOptions *out_conn_recovery_opts)
+{
+    FIXME("%p, %p: stub\n", iface, out_conn_recovery_opts);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_put_ConnectionRecoveryBehavior(IUIAutomation6 *iface,
+        enum ConnectionRecoveryBehaviorOptions conn_recovery_opts)
+{
+    FIXME("%p, %#x: stub\n", iface, conn_recovery_opts);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_get_CoalesceEvents(IUIAutomation6 *iface,
+        enum CoalesceEventsOptions *out_coalesce_events_opts)
+{
+    FIXME("%p, %p: stub\n", iface, out_coalesce_events_opts);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_put_CoalesceEvents(IUIAutomation6 *iface,
+        enum CoalesceEventsOptions coalesce_events_opts)
+{
+    FIXME("%p, %#x: stub\n", iface, coalesce_events_opts);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_AddActiveTextPositionChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, enum TreeScope scope, IUIAutomationCacheRequest *cache_req,
+        IUIAutomationActiveTextPositionChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %#x, %p, %p: stub\n", iface, elem, scope, cache_req, handler);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_iface_RemoveActiveTextPositionChangedEventHandler(IUIAutomation6 *iface,
+        IUIAutomationElement *elem, IUIAutomationActiveTextPositionChangedEventHandler *handler)
+{
+    FIXME("%p, %p, %p\n", iface, elem, handler);
+    return E_NOTIMPL;
+}
+
+static const IUIAutomation6Vtbl uia_iface_vtbl = {
+    uia_iface_QueryInterface,
+    uia_iface_AddRef,
+    uia_iface_Release,
+    /* IUIAutomation methods */
+    uia_iface_CompareElements,
+    uia_iface_CompareRuntimeIds,
+    uia_iface_GetRootElement,
+    uia_iface_ElementFromHandle,
+    uia_iface_ElementFromPoint,
+    uia_iface_GetFocusedElement,
+    uia_iface_GetRootElementBuildCache,
+    uia_iface_ElementFromHandleBuildCache,
+    uia_iface_ElementFromPointBuildCache,
+    uia_iface_GetFocusedElementBuildCache,
+    uia_iface_CreateTreeWalker,
+    uia_iface_get_ControlViewWalker,
+    uia_iface_get_ContentViewWalker,
+    uia_iface_get_RawViewWalker,
+    uia_iface_get_RawViewCondition,
+    uia_iface_get_ControlViewCondition,
+    uia_iface_get_ContentViewCondition,
+    uia_iface_CreateCacheRequest,
+    uia_iface_CreateTrueCondition,
+    uia_iface_CreateFalseCondition,
+    uia_iface_CreatePropertyCondition,
+    uia_iface_CreatePropertyConditionEx,
+    uia_iface_CreateAndCondition,
+    uia_iface_CreateAndConditionFromArray,
+    uia_iface_CreateAndConditionFromNativeArray,
+    uia_iface_CreateOrCondition,
+    uia_iface_CreateOrConditionFromArray,
+    uia_iface_CreateOrConditionFromNativeArray,
+    uia_iface_CreateNotCondition,
+    uia_iface_AddAutomationEventHandler,
+    uia_iface_RemoveAutomationEventHandler,
+    uia_iface_AddPropertyChangedEventHandlerNativeArray,
+    uia_iface_AddPropertyChangedEventHandler,
+    uia_iface_RemovePropertyChangedEventHandler,
+    uia_iface_AddStructureChangedEventHandler,
+    uia_iface_RemoveStructureChangedEventHandler,
+    uia_iface_AddFocusChangedEventHandler,
+    uia_iface_RemoveFocusChangedEventHandler,
+    uia_iface_RemoveAllEventHandlers,
+    uia_iface_IntNativeArrayToSafeArray,
+    uia_iface_IntSafeArrayToNativeArray,
+    uia_iface_RectToVariant,
+    uia_iface_VariantToRect,
+    uia_iface_SafeArrayToRectNativeArray,
+    uia_iface_CreateProxyFactoryEntry,
+    uia_iface_get_ProxyFactoryMapping,
+    uia_iface_GetPropertyProgrammaticName,
+    uia_iface_GetPatternProgrammaticName,
+    uia_iface_PollForPotentialSupportedPatterns,
+    uia_iface_PollForPotentialSupportedProperties,
+    uia_iface_CheckNotSupported,
+    uia_iface_get_ReservedNotSupportedValue,
+    uia_iface_get_ReservedMixedAttributeValue,
+    uia_iface_ElementFromIAccessible,
+    uia_iface_ElementFromIAccessibleBuildCache,
+    /* IUIAutomation2 methods */
+    uia_iface_get_AutoSetFocus,
+    uia_iface_put_AutoSetFocus,
+    uia_iface_get_ConnectionTimeout,
+    uia_iface_put_ConnectionTimeout,
+    uia_iface_get_TransactionTimeout,
+    uia_iface_put_TransactionTimeout,
+    /* IUIAutomation3 methods */
+    uia_iface_AddTextEditTextChangedEventHandler,
+    uia_iface_RemoveTextEditTextChangedEventHandler,
+    /* IUIAutomation4 methods */
+    uia_iface_AddChangesEventHandler,
+    uia_iface_RemoveChangesEventHandler,
+    /* IUIAutomation5 methods */
+    uia_iface_AddNotificationEventHandler,
+    uia_iface_RemoveNotificationEventHandler,
+    /* IUIAutomation6 methods */
+    uia_iface_CreateEventHandlerGroup,
+    uia_iface_AddEventHandlerGroup,
+    uia_iface_RemoveEventHandlerGroup,
+    uia_iface_get_ConnectionRecoveryBehavior,
+    uia_iface_put_ConnectionRecoveryBehavior,
+    uia_iface_get_CoalesceEvents,
+    uia_iface_put_CoalesceEvents,
+    uia_iface_AddActiveTextPositionChangedEventHandler,
+    uia_iface_RemoveActiveTextPositionChangedEventHandler,
+};
+
+HRESULT create_uia_iface(IUnknown **iface, BOOL is_cui8)
+{
+    struct uia_iface *uia;
+
+    uia = heap_alloc_zero(sizeof(*uia));
+    if (!uia)
+        return E_OUTOFMEMORY;
+
+    uia->IUIAutomation6_iface.lpVtbl = &uia_iface_vtbl;
+    uia->is_cui8 = is_cui8;
+    uia->ref = 1;
+
+    *iface = (IUnknown *)&uia->IUIAutomation6_iface;
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_ids.c b/dlls/uiautomationcore/uia_ids.c
index a3a60c8aec9..64f2ecced93 100644
--- a/dlls/uiautomationcore/uia_ids.c
+++ b/dlls/uiautomationcore/uia_ids.c
@@ -30,6 +30,27 @@ static int __cdecl uia_property_guid_compare(const void *a, const void *b)
     return memcmp(guid, property->guid, sizeof(*guid));
 }
 
+static int __cdecl uia_event_guid_compare(const void *a, const void *b)
+{
+    const GUID *guid = a;
+    const struct uia_event_info *event = b;
+    return memcmp(guid, event->guid, sizeof(*guid));
+}
+
+static int __cdecl uia_pattern_guid_compare(const void *a, const void *b)
+{
+    const GUID *guid = a;
+    const struct uia_pattern_info *pattern = b;
+    return memcmp(guid, pattern->guid, sizeof(*guid));
+}
+
+static int __cdecl uia_control_type_guid_compare(const void *a, const void *b)
+{
+    const GUID *guid = a;
+    const struct uia_control_type_info *control = b;
+    return memcmp(guid, control->guid, sizeof(*guid));
+}
+
 /* Sorted by GUID. */
 static const struct uia_prop_info default_uia_properties[] = {
     { &AutomationId_Property_GUID,                       UIA_AutomationIdPropertyId,
@@ -83,7 +104,9 @@ static const struct uia_prop_info default_uia_properties[] = {
     { &IsDropTargetPatternAvailable_Property_GUID,       UIA_IsDropTargetPatternAvailablePropertyId, },
     { &Dock_DockPosition_Property_GUID,                  UIA_DockDockPositionPropertyId, },
     { &Styles_StyleId_Property_GUID,                     UIA_StylesStyleIdPropertyId, },
-    { &Value_IsReadOnly_Property_GUID,                   UIA_ValueIsReadOnlyPropertyId, },
+    { &Value_IsReadOnly_Property_GUID,                   UIA_ValueIsReadOnlyPropertyId,
+      PROP_TYPE_PATTERN_PROP,                            UIAutomationType_Bool,
+      UIA_ValuePatternId, },
     { &IsSpreadsheetPatternAvailable_Property_GUID,      UIA_IsSpreadsheetPatternAvailablePropertyId, },
     { &Styles_StyleName_Property_GUID,                   UIA_StylesStyleNamePropertyId, },
     { &IsAnnotationPatternAvailable_Property_GUID,       UIA_IsAnnotationPatternAvailablePropertyId, },
@@ -211,7 +234,8 @@ static const struct uia_prop_info default_uia_properties[] = {
       PROP_TYPE_ELEM_PROP,                               UIAutomationType_Bool, },
     { &IsWindowPatternAvailable_Property_GUID,           UIA_IsWindowPatternAvailablePropertyId, },
     { &RangeValue_Minimum_Property_GUID,                 UIA_RangeValueMinimumPropertyId, },
-    { &BoundingRectangle_Property_GUID,                  UIA_BoundingRectanglePropertyId, },
+    { &BoundingRectangle_Property_GUID,                  UIA_BoundingRectanglePropertyId,
+      PROP_TYPE_SPECIAL,                                 UIAutomationType_Rect, },
     { &LegacyIAccessible_Value_Property_GUID,            UIA_LegacyIAccessibleValuePropertyId, },
     { &IsDragPatternAvailable_Property_GUID,             UIA_IsDragPatternAvailablePropertyId, },
     { &DescribedBy_Property_GUID,                        UIA_DescribedByPropertyId,
@@ -308,6 +332,271 @@ const struct uia_prop_info *uia_prop_info_from_id(PROPERTYID prop_id)
     return &default_uia_properties[prop_id_idx[prop_id - PROP_ID_MIN]];
 }
 
+/* Sorted by GUID. */
+static const struct uia_event_info default_uia_events[] = {
+    { &Selection_InvalidatedEvent_Event_GUID,                     UIA_Selection_InvalidatedEventId,
+      EventArgsType_Simple, },
+    { &Window_WindowOpened_Event_GUID,                            UIA_Window_WindowOpenedEventId,
+      EventArgsType_Simple, },
+    { &TextEdit_TextChanged_Event_GUID,                           UIA_TextEdit_TextChangedEventId,
+      EventArgsType_TextEditTextChanged, },
+    { &Drag_DragStart_Event_GUID,                                 UIA_Drag_DragStartEventId,
+      EventArgsType_Simple, },
+    { &Changes_Event_GUID,                                        UIA_ChangesEventId,
+      EventArgsType_Changes, },
+    { &DropTarget_DragLeave_Event_GUID,                           UIA_DropTarget_DragLeaveEventId,
+      EventArgsType_Simple, },
+    { &AutomationFocusChanged_Event_GUID,                         UIA_AutomationFocusChangedEventId,
+      EventArgsType_Simple, },
+    { &AsyncContentLoaded_Event_GUID,                             UIA_AsyncContentLoadedEventId,
+      EventArgsType_AsyncContentLoaded, },
+    { &MenuModeStart_Event_GUID,                                  UIA_MenuModeStartEventId,
+      EventArgsType_Simple, },
+    { &HostedFragmentRootsInvalidated_Event_GUID,                 UIA_HostedFragmentRootsInvalidatedEventId,
+      EventArgsType_Simple, },
+    { &LayoutInvalidated_Event_GUID,                              UIA_LayoutInvalidatedEventId,
+      EventArgsType_Simple, },
+    { &MenuOpened_Event_GUID,                                     UIA_MenuOpenedEventId,
+      EventArgsType_Simple, },
+    { &SystemAlert_Event_GUID,                                    UIA_SystemAlertEventId,
+      EventArgsType_Simple, },
+    { &StructureChanged_Event_GUID,                               UIA_StructureChangedEventId,
+      EventArgsType_StructureChanged, },
+    { &InputDiscarded_Event_GUID,                                 UIA_InputDiscardedEventId,
+      EventArgsType_Simple, },
+    { &MenuClosed_Event_GUID,                                     UIA_MenuClosedEventId,
+      EventArgsType_Simple, },
+    { &Text_TextChangedEvent_Event_GUID,                          UIA_Text_TextChangedEventId,
+      EventArgsType_Simple, },
+    { &TextEdit_ConversionTargetChanged_Event_GUID,               UIA_TextEdit_ConversionTargetChangedEventId,
+      EventArgsType_Simple, },
+    { &Drag_DragComplete_Event_GUID,                              UIA_Drag_DragCompleteEventId,
+      EventArgsType_Simple, },
+    { &InputReachedOtherElement_Event_GUID,                       UIA_InputReachedOtherElementEventId,
+      EventArgsType_Simple, },
+    { &LiveRegionChanged_Event_GUID,                              UIA_LiveRegionChangedEventId,
+      EventArgsType_Simple, },
+    { &InputReachedTarget_Event_GUID,                             UIA_InputReachedTargetEventId,
+      EventArgsType_Simple, },
+    { &DropTarget_DragEnter_Event_GUID,                           UIA_DropTarget_DragEnterEventId,
+      EventArgsType_Simple, },
+    { &MenuModeEnd_Event_GUID,                                    UIA_MenuModeEndEventId,
+      EventArgsType_Simple, },
+    { &Text_TextSelectionChangedEvent_Event_GUID,                 UIA_Text_TextSelectionChangedEventId,
+      EventArgsType_Simple, },
+    { &AutomationPropertyChanged_Event_GUID,                      UIA_AutomationPropertyChangedEventId,
+      EventArgsType_PropertyChanged, },
+    { &SelectionItem_ElementRemovedFromSelectionEvent_Event_GUID, UIA_SelectionItem_ElementRemovedFromSelectionEventId,
+      EventArgsType_Simple, },
+    { &SelectionItem_ElementAddedToSelectionEvent_Event_GUID,     UIA_SelectionItem_ElementAddedToSelectionEventId,
+      EventArgsType_Simple, },
+    { &DropTarget_Dropped_Event_GUID,                             UIA_DropTarget_DroppedEventId,
+      EventArgsType_Simple, },
+    { &ToolTipClosed_Event_GUID,                                  UIA_ToolTipClosedEventId,
+      EventArgsType_Simple, },
+    { &Invoke_Invoked_Event_GUID,                                 UIA_Invoke_InvokedEventId,
+      EventArgsType_Simple, },
+    { &Notification_Event_GUID,                                   UIA_NotificationEventId,
+      EventArgsType_Notification, },
+    { &Window_WindowClosed_Event_GUID,                            UIA_Window_WindowClosedEventId,
+      EventArgsType_WindowClosed, },
+    { &Drag_DragCancel_Event_GUID,                                UIA_Drag_DragCancelEventId,
+      EventArgsType_Simple, },
+    { &SelectionItem_ElementSelectedEvent_Event_GUID,             UIA_SelectionItem_ElementSelectedEventId,
+      EventArgsType_Simple, },
+    { &ToolTipOpened_Event_GUID,                                  UIA_ToolTipOpenedEventId,
+      EventArgsType_Simple, },
+};
+
+static const struct uia_event_info *uia_event_info_from_guid(const GUID *guid)
+{
+    struct uia_event_info *event;
+
+    if ((event = bsearch(guid, default_uia_events, ARRAY_SIZE(default_uia_events), sizeof(*event),
+            uia_event_guid_compare)))
+        return event;
+
+    return NULL;
+}
+
+/* Sorted by GUID. */
+static const struct uia_pattern_info default_uia_patterns[] = {
+    { &ScrollItem_Pattern_GUID,         UIA_ScrollItemPatternId,
+      &IID_IScrollItemProvider, },
+    { &Tranform_Pattern2_GUID,          UIA_TransformPattern2Id,
+      &IID_ITransformProvider2, },
+    { &ItemContainer_Pattern_GUID,      UIA_ItemContainerPatternId,
+      &IID_IItemContainerProvider, },
+    { &Drag_Pattern_GUID,               UIA_DragPatternId,
+      &IID_IDragProvider, },
+    { &Window_Pattern_GUID,             UIA_WindowPatternId,
+      &IID_IWindowProvider, },
+    { &VirtualizedItem_Pattern_GUID,    UIA_VirtualizedItemPatternId,
+      &IID_IVirtualizedItemProvider, },
+    { &Dock_Pattern_GUID,               UIA_DockPatternId,
+      &IID_IDockProvider, },
+    { &Styles_Pattern_GUID,             UIA_StylesPatternId,
+      &IID_IStylesProvider, },
+    { &DropTarget_Pattern_GUID,         UIA_DropTargetPatternId,
+      &IID_IDropTargetProvider, },
+    { &Text_Pattern_GUID,               UIA_TextPatternId,
+      &IID_ITextProvider, },
+    { &Toggle_Pattern_GUID,             UIA_TogglePatternId,
+      &IID_IToggleProvider, },
+    { &GridItem_Pattern_GUID,           UIA_GridItemPatternId,
+      &IID_IGridItemProvider, },
+    { &RangeValue_Pattern_GUID,         UIA_RangeValuePatternId,
+      &IID_IRangeValueProvider, },
+    { &TextEdit_Pattern_GUID,           UIA_TextEditPatternId,
+      &IID_ITextEditProvider, },
+    { &CustomNavigation_Pattern_GUID,   UIA_CustomNavigationPatternId,
+      &IID_ICustomNavigationProvider, },
+    { &Table_Pattern_GUID,              UIA_TablePatternId,
+      &IID_ITableProvider, },
+    { &Value_Pattern_GUID,              UIA_ValuePatternId,
+      &IID_IValueProvider, },
+    { &LegacyIAccessible_Pattern_GUID,  UIA_LegacyIAccessiblePatternId,
+      &IID_ILegacyIAccessibleProvider, },
+    { &Text_Pattern2_GUID,              UIA_TextPattern2Id,
+      &IID_ITextProvider2, },
+    { &ExpandCollapse_Pattern_GUID,     UIA_ExpandCollapsePatternId,
+      &IID_IExpandCollapseProvider, },
+    { &SynchronizedInput_Pattern_GUID,  UIA_SynchronizedInputPatternId,
+      &IID_ISynchronizedInputProvider, },
+    { &Scroll_Pattern_GUID,             UIA_ScrollPatternId,
+      &IID_IScrollProvider, },
+    { &TextChild_Pattern_GUID,          UIA_TextChildPatternId,
+      &IID_ITextChildProvider, },
+    { &TableItem_Pattern_GUID,          UIA_TableItemPatternId,
+      &IID_ITableItemProvider, },
+    { &Spreadsheet_Pattern_GUID,        UIA_SpreadsheetPatternId,
+      &IID_ISpreadsheetProvider, },
+    { &Grid_Pattern_GUID,               UIA_GridPatternId,
+      &IID_IGridProvider, },
+    { &Annotation_Pattern_GUID,         UIA_AnnotationPatternId,
+      &IID_IAnnotationProvider, },
+    { &Transform_Pattern_GUID,          UIA_TransformPatternId,
+      &IID_ITransformProvider, },
+    { &MultipleView_Pattern_GUID,       UIA_MultipleViewPatternId,
+      &IID_IMultipleViewProvider, },
+    { &Selection_Pattern_GUID,          UIA_SelectionPatternId,
+      &IID_ISelectionProvider, },
+    { &SelectionItem_Pattern_GUID,      UIA_SelectionItemPatternId,
+      &IID_ISelectionItemProvider, },
+    { &Invoke_Pattern_GUID,             UIA_InvokePatternId,
+      &IID_IInvokeProvider, },
+    { &ObjectModel_Pattern_GUID,        UIA_ObjectModelPatternId,
+      &IID_IObjectModelProvider, },
+    { &SpreadsheetItem_Pattern_GUID,    UIA_SpreadsheetItemPatternId,
+      &IID_ISpreadsheetItemProvider, },
+};
+
+static const int pattern_id_idx[] = {
+    0x1f, 0x1d, 0x10, 0x0c, 0x15, 0x13, 0x19, 0x0b,
+    0x1c, 0x04, 0x1e, 0x06, 0x0f, 0x17, 0x09, 0x0a,
+    0x1b, 0x00, 0x11, 0x02, 0x05, 0x14, 0x20, 0x1a,
+    0x12, 0x07, 0x18, 0x21, 0x01, 0x16, 0x03, 0x08,
+    0x0d, 0x0e,
+};
+
+#define PATTERN_ID_MIN 10000
+#define PATTERN_ID_MAX (PATTERN_ID_MIN + ARRAY_SIZE(default_uia_patterns))
+
+static const struct uia_pattern_info *uia_pattern_info_from_guid(const GUID *guid)
+{
+    struct uia_pattern_info *pattern;
+
+    if ((pattern = bsearch(guid, default_uia_patterns, ARRAY_SIZE(default_uia_patterns), sizeof(*pattern),
+            uia_pattern_guid_compare)))
+        return pattern;
+
+    return NULL;
+}
+
+const struct uia_pattern_info *uia_pattern_info_from_id(PATTERNID pattern_id)
+{
+    if ((pattern_id < PATTERN_ID_MIN) || (pattern_id > PATTERN_ID_MAX))
+        return NULL;
+
+    return &default_uia_patterns[pattern_id_idx[pattern_id - PATTERN_ID_MIN]];
+}
+
+/* Sorted by GUID. */
+static const struct uia_control_type_info default_uia_control_types[] = {
+    { &Table_Control_GUID,        UIA_TableControlTypeId },
+    { &StatusBar_Control_GUID,    UIA_StatusBarControlTypeId },
+    { &Group_Control_GUID,        UIA_GroupControlTypeId },
+    { &SplitButton_Control_GUID,  UIA_SplitButtonControlTypeId },
+    { &CheckBox_Control_GUID,     UIA_CheckBoxControlTypeId },
+    { &Hyperlink_Control_GUID,    UIA_HyperlinkControlTypeId },
+    { &Tab_Control_GUID,          UIA_TabControlTypeId },
+    { &ScrollBar_Control_GUID,    UIA_ScrollBarControlTypeId },
+    { &Spinner_Control_GUID,      UIA_SpinnerControlTypeId },
+    { &Menu_Control_GUID,         UIA_MenuControlTypeId },
+    { &Window_Control_GUID,       UIA_WindowControlTypeId },
+    { &DataItem_Control_GUID,     UIA_DataItemControlTypeId },
+    { &SemanticZoom_Control_GUID, UIA_SemanticZoomControlTypeId },
+    { &Slider_Control_GUID,       UIA_SliderControlTypeId },
+    { &TabItem_Control_GUID,      UIA_TabItemControlTypeId },
+    { &MenuBar_Control_GUID,      UIA_MenuBarControlTypeId },
+    { &ToolBar_Control_GUID,      UIA_ToolBarControlTypeId },
+    { &Pane_Control_GUID,         UIA_PaneControlTypeId },
+    { &Button_Control_GUID,       UIA_ButtonControlTypeId },
+    { &ComboBox_Control_GUID,     UIA_ComboBoxControlTypeId },
+    { &Document_Control_GUID,     UIA_DocumentControlTypeId },
+    { &Thumb_Control_GUID,        UIA_ThumbControlTypeId },
+    { &ProgressBar_Control_GUID,  UIA_ProgressBarControlTypeId },
+    { &Calendar_Control_GUID,     UIA_CalendarControlTypeId },
+    { &AppBar_Control_GUID,       UIA_AppBarControlTypeId },
+    { &Tree_Control_GUID,         UIA_TreeControlTypeId },
+    { &Separator_Control_GUID,    UIA_SeparatorControlTypeId },
+    { &DataGrid_Control_GUID,     UIA_DataGridControlTypeId },
+    { &TreeItem_Control_GUID,     UIA_TreeItemControlTypeId },
+    { &TitleBar_Control_GUID,     UIA_TitleBarControlTypeId },
+    { &Custom_Control_GUID,       UIA_CustomControlTypeId },
+    { &Edit_Control_GUID,         UIA_EditControlTypeId },
+    { &HeaderItem_Control_GUID,   UIA_HeaderItemControlTypeId },
+    { &Header_Control_GUID,       UIA_HeaderControlTypeId },
+    { &ToolTip_Control_GUID,      UIA_ToolTipControlTypeId },
+    { &MenuItem_Control_GUID,     UIA_MenuItemControlTypeId },
+    { &RadioButton_Control_GUID,  UIA_RadioButtonControlTypeId },
+    { &Text_Control_GUID,         UIA_TextControlTypeId },
+    { &List_Control_GUID,         UIA_ListControlTypeId },
+    { &Image_Control_GUID,        UIA_ImageControlTypeId },
+    { &ListItem_Control_GUID,     UIA_ListItemControlTypeId },
+};
+
+static const int control_type_id_idx[] = {
+    0x12, 0x17, 0x04, 0x13, 0x1f, 0x05, 0x27, 0x28,
+    0x26, 0x09, 0x0f, 0x23, 0x16, 0x24, 0x07, 0x0d,
+    0x08, 0x01, 0x06, 0x0e, 0x25, 0x10, 0x22, 0x19,
+    0x1c, 0x1e, 0x02, 0x15, 0x1b, 0x0b, 0x14, 0x03,
+    0x0a, 0x11, 0x21, 0x20, 0x00, 0x1d, 0x1a, 0x0c,
+    0x18,
+};
+
+#define CONTROL_TYPE_ID_MIN 50000
+#define CONTROL_TYPE_ID_MAX (CONTROL_TYPE_ID_MIN + ARRAY_SIZE(default_uia_control_types))
+
+static const struct uia_control_type_info *uia_control_type_info_from_guid(const GUID *guid)
+{
+    struct uia_control_type_info *control_type;
+
+    if ((control_type = bsearch(guid, default_uia_control_types, ARRAY_SIZE(default_uia_control_types),
+                    sizeof(*control_type), uia_control_type_guid_compare)))
+        return control_type;
+
+    return NULL;
+}
+
+const struct uia_control_type_info *uia_control_type_info_from_id(CONTROLTYPEID control_type_id)
+{
+    if ((control_type_id < CONTROL_TYPE_ID_MIN) || (control_type_id > CONTROL_TYPE_ID_MAX))
+        return NULL;
+
+    return &default_uia_control_types[control_type_id_idx[control_type_id - CONTROL_TYPE_ID_MIN]];
+}
+
 /***********************************************************************
  *          UiaLookupId (uiautomationcore.@)
  */
@@ -331,9 +620,42 @@ int WINAPI UiaLookupId(enum AutomationIdentifierType type, const GUID *guid)
         break;
     }
 
-    case AutomationIdentifierType_Pattern:
     case AutomationIdentifierType_Event:
+    {
+        const struct uia_event_info *event = uia_event_info_from_guid(guid);
+
+        if (event)
+            ret_id = event->event_id;
+        else
+            FIXME("Failed to find eventId for GUID %s\n", debugstr_guid(guid));
+
+        break;
+    }
+
+    case AutomationIdentifierType_Pattern:
+    {
+        const struct uia_pattern_info *pattern = uia_pattern_info_from_guid(guid);
+
+        if (pattern)
+            ret_id = pattern->pattern_id;
+        else
+            FIXME("Failed to find patternId for GUID %s\n", debugstr_guid(guid));
+
+        break;
+    }
+
     case AutomationIdentifierType_ControlType:
+    {
+        const struct uia_control_type_info *control_type = uia_control_type_info_from_guid(guid);
+
+        if (control_type)
+            ret_id = control_type->control_type_id;
+        else
+            FIXME("Failed to find control type Id for GUID %s\n", debugstr_guid(guid));
+
+        break;
+    }
+
     case AutomationIdentifierType_TextAttribute:
     case AutomationIdentifierType_LandmarkType:
     case AutomationIdentifierType_Annotation:
diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index 2c741398c82..aa297983867 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -317,6 +317,57 @@ HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple
     return S_OK;
 }
 
+/***********************************************************************
+ *          UiaRaiseStructureChangedEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
+        int *runtime_id, int runtime_id_len)
+{
+    FIXME("(%p, %d, %p, %d): stub\n", provider, struct_change_type, runtime_id, runtime_id_len);
+    return S_OK;
+}
+
+/***********************************************************************
+ *          UiaRaiseAsyncContentLoadedEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple *provider,
+        enum AsyncContentLoadedState async_content_loaded_state, double percent_complete)
+{
+    FIXME("(%p, %d, %f): stub\n", provider, async_content_loaded_state, percent_complete);
+    return S_OK;
+}
+
+/***********************************************************************
+ *          UiaRaiseTextEditTextChangedEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseTextEditTextChangedEvent(IRawElementProviderSimple *provider,
+        enum TextEditChangeType text_edit_change_type, SAFEARRAY *changed_data)
+{
+    FIXME("(%p, %d, %p): stub\n", provider, text_edit_change_type, changed_data);
+    return S_OK;
+}
+
+/***********************************************************************
+ *          UiaRaiseNotificationEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *provider, enum NotificationKind notification_kind,
+        enum NotificationProcessing notification_processing, BSTR display_str, BSTR activity_id)
+{
+    FIXME("(%p, %d, %d, %s, %s): stub\n", provider, notification_kind, notification_processing,
+            debugstr_w(display_str), debugstr_w(activity_id));
+    return S_OK;
+}
+
+/***********************************************************************
+ *          UiaRaiseChangesEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseChangesEvent(IRawElementProviderSimple *provider, int event_id_count,
+        struct UiaChangeInfo *uia_changes)
+{
+    FIXME("(%p, %d, %p): stub\n", provider, event_id_count, uia_changes);
+    return S_OK;
+}
+
 HRESULT WINAPI UiaHostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple **provider)
 {
     struct hwnd_host_provider *host_prov;
@@ -361,3 +412,126 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     return TRUE;
 }
+
+/* UIAutomation ClassFactory */
+struct uia_cf {
+    IClassFactory IClassFactory_iface;
+    LONG ref;
+
+    const GUID *clsid;
+};
+
+static struct uia_cf *impl_from_IClassFactory(IClassFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_cf, IClassFactory_iface);
+}
+
+static HRESULT WINAPI uia_cf_QueryInterface(IClassFactory *iface, REFIID riid, void **ppv)
+{
+    *ppv = NULL;
+    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
+        *ppv = iface;
+    else
+        return E_NOINTERFACE;
+
+    IClassFactory_AddRef(iface);
+    return S_OK;
+}
+
+static ULONG WINAPI uia_cf_AddRef(IClassFactory *iface)
+{
+    struct uia_cf *cf = impl_from_IClassFactory(iface);
+    ULONG ref = InterlockedIncrement(&cf->ref);
+
+    TRACE("%p, refcount %ld\n", cf, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI uia_cf_Release(IClassFactory *iface)
+{
+    struct uia_cf *cf = impl_from_IClassFactory(iface);
+    ULONG ref = InterlockedDecrement(&cf->ref);
+
+    TRACE("%p, refcount %ld\n", cf, ref);
+
+    if (!ref)
+        heap_free(cf);
+
+    return ref;
+}
+
+static HRESULT WINAPI uia_cf_CreateInstance(IClassFactory *iface, IUnknown *pouter, REFIID riid, void **ppv)
+{
+    struct uia_cf *cf = impl_from_IClassFactory(iface);
+    IUnknown *obj = NULL;
+    HRESULT hr;
+
+    TRACE("%p, %p, %s, %p\n", iface, pouter, debugstr_guid(riid), ppv);
+
+    *ppv = NULL;
+    if (pouter)
+        return CLASS_E_NOAGGREGATION;
+
+    if (IsEqualGUID(cf->clsid, &CLSID_CUIAutomation))
+        hr = create_uia_iface(&obj, FALSE);
+    else if (IsEqualGUID(cf->clsid, &CLSID_CUIAutomation8))
+        hr = create_uia_iface(&obj, TRUE);
+    else
+        return E_NOINTERFACE;
+
+    if (SUCCEEDED(hr))
+    {
+        hr = IUnknown_QueryInterface(obj, riid, ppv);
+        IUnknown_Release(obj);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI uia_cf_LockServer(IClassFactory *iface, BOOL do_lock)
+{
+    FIXME("%p, %d: stub\n", iface, do_lock);
+    return S_OK;
+}
+
+static const IClassFactoryVtbl uia_cf_Vtbl =
+{
+    uia_cf_QueryInterface,
+    uia_cf_AddRef,
+    uia_cf_Release,
+    uia_cf_CreateInstance,
+    uia_cf_LockServer
+};
+
+static inline HRESULT create_uia_cf(REFCLSID clsid, REFIID riid, void **ppv)
+{
+    struct uia_cf *cf = heap_alloc_zero(sizeof(*cf));
+    HRESULT hr;
+
+    *ppv = NULL;
+    if (!cf)
+        return E_OUTOFMEMORY;
+
+    cf->IClassFactory_iface.lpVtbl = &uia_cf_Vtbl;
+    cf->clsid = clsid;
+    cf->ref = 1;
+
+    hr = IClassFactory_QueryInterface(&cf->IClassFactory_iface, riid, ppv);
+    IClassFactory_Release(&cf->IClassFactory_iface);
+
+    return hr;
+}
+
+/***********************************************************************
+ *          DllGetClassObject (uiautomationcore.@)
+ */
+HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv)
+{
+    TRACE("(%s, %s, %p)\n", debugstr_guid(clsid), debugstr_guid(riid), ppv);
+
+    if (IsEqualGUID(clsid, &CLSID_CUIAutomation) || IsEqualGUID(clsid, &CLSID_CUIAutomation8))
+        return create_uia_cf(clsid, riid, ppv);
+
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 63820d0b937..157ae3583f8 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -28,6 +28,7 @@ enum uia_prop_type {
     PROP_TYPE_UNKNOWN,
     PROP_TYPE_ELEM_PROP,
     PROP_TYPE_SPECIAL,
+    PROP_TYPE_PATTERN_PROP,
 };
 
 /*
@@ -91,14 +92,25 @@ static inline struct uia_provider *impl_from_IWineUiaProvider(IWineUiaProvider *
     return CONTAINING_RECORD(iface, struct uia_provider, IWineUiaProvider_iface);
 }
 
+static inline void variant_init_bool(VARIANT *v, BOOL val)
+{
+    V_VT(v) = VT_BOOL;
+    V_BOOL(v) = val ? VARIANT_TRUE : VARIANT_FALSE;
+}
+
 /* uia_client.c */
 int uia_compare_safearrays(SAFEARRAY *sa1, SAFEARRAY *sa2, int prop_type) DECLSPEC_HIDDEN;
 int get_node_provider_type_at_idx(struct uia_node *node, int idx) DECLSPEC_HIDDEN;
 HRESULT create_uia_node_from_elprov(IRawElementProviderSimple *elprov, HUIANODE *out_node,
         BOOL get_hwnd_providers) DECLSPEC_HIDDEN;
 
+/* uia_com_client.c */
+HRESULT create_uia_iface(IUnknown **iface, BOOL is_cui8) DECLSPEC_HIDDEN;
+
 /* uia_ids.c */
 const struct uia_prop_info *uia_prop_info_from_id(PROPERTYID prop_id) DECLSPEC_HIDDEN;
+const struct uia_pattern_info *uia_pattern_info_from_id(PATTERNID pattern_id) DECLSPEC_HIDDEN;
+const struct uia_control_type_info *uia_control_type_info_from_id(CONTROLTYPEID control_type_id) DECLSPEC_HIDDEN;
 
 /* uia_provider.c */
 void uia_stop_provider_thread(void) DECLSPEC_HIDDEN;
diff --git a/dlls/uiautomationcore/uia_provider.c b/dlls/uiautomationcore/uia_provider.c
index fc718fabe43..58d1db9bae8 100644
--- a/dlls/uiautomationcore/uia_provider.c
+++ b/dlls/uiautomationcore/uia_provider.c
@@ -35,12 +35,6 @@ static void variant_init_i4(VARIANT *v, int val)
     V_I4(v) = val;
 }
 
-static void variant_init_bool(VARIANT *v, BOOL val)
-{
-    V_VT(v) = VT_BOOL;
-    V_BOOL(v) = val ? VARIANT_TRUE : VARIANT_FALSE;
-}
-
 static BOOL msaa_check_acc_state(IAccessible *acc, VARIANT cid, ULONG flag)
 {
     HRESULT hr;
@@ -670,6 +664,19 @@ HRESULT WINAPI msaa_provider_GetPropertyValue(IRawElementProviderSimple *iface,
                     STATE_SYSTEM_PROTECTED));
         break;
 
+    case UIA_NamePropertyId:
+    {
+        BSTR name;
+
+        hr = IAccessible_get_accName(msaa_prov->acc, msaa_prov->cid, &name);
+        if (SUCCEEDED(hr) && name)
+        {
+            V_VT(ret_val) = VT_BSTR;
+            V_BSTR(ret_val) = name;
+        }
+        break;
+    }
+
     default:
         FIXME("Unimplemented propertyId %d\n", prop_id);
         break;
@@ -874,8 +881,34 @@ static HRESULT WINAPI msaa_fragment_GetRuntimeId(IRawElementProviderFragment *if
 static HRESULT WINAPI msaa_fragment_get_BoundingRectangle(IRawElementProviderFragment *iface,
         struct UiaRect *ret_val)
 {
-    FIXME("%p, %p: stub!\n", iface, ret_val);
-    return E_NOTIMPL;
+    struct msaa_provider *msaa_prov = impl_from_msaa_fragment(iface);
+    LONG left, top, width, height;
+    HRESULT hr;
+
+    TRACE("%p, %p\n", iface, ret_val);
+
+    memset(ret_val, 0, sizeof(*ret_val));
+
+    /*
+     * If this IAccessible is at the root of its HWND, the BaseHwnd provider
+     * will supply the bounding rectangle.
+     */
+    if (msaa_check_root_acc(msaa_prov))
+        return S_OK;
+
+    if (msaa_check_acc_state(msaa_prov->acc, msaa_prov->cid, STATE_SYSTEM_OFFSCREEN))
+        return S_OK;
+
+    hr = IAccessible_accLocation(msaa_prov->acc, &left, &top, &width, &height, msaa_prov->cid);
+    if (FAILED(hr))
+        return hr;
+
+    ret_val->left = left;
+    ret_val->top = top;
+    ret_val->width = width;
+    ret_val->height = height;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI msaa_fragment_GetEmbeddedFragmentRoots(IRawElementProviderFragment *iface,
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index 11ca7be7f97..7168135487b 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -1,5 +1,5 @@
 @ stdcall -private DllCanUnloadNow()
-@ stub DllGetClassObject
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stub DockPattern_SetDockPosition
@@ -84,13 +84,13 @@
 @ stub UiaPatternRelease
 #@ stub UiaProviderForNonClient
 @ stdcall UiaProviderFromIAccessible(ptr long long ptr)
-@ stub UiaRaiseAsyncContentLoadedEvent
+@ stdcall UiaRaiseAsyncContentLoadedEvent(ptr long double)
 @ stdcall UiaRaiseAutomationEvent(ptr long)
 @ stdcall UiaRaiseAutomationPropertyChangedEvent(ptr long int128 int128)
-#@ stub UiaRaiseChangesEvent
-#@ stub UiaRaiseNotificationEvent
-@ stub UiaRaiseStructureChangedEvent
-#@ stub UiaRaiseTextEditTextChangedEvent
+@ stdcall UiaRaiseChangesEvent(ptr long ptr)
+@ stdcall UiaRaiseNotificationEvent(ptr long long wstr wstr)
+@ stdcall UiaRaiseStructureChangedEvent(ptr long ptr long)
+@ stdcall UiaRaiseTextEditTextChangedEvent(ptr long ptr)
 @ stdcall UiaRegisterProviderCallback(ptr)
 @ stdcall UiaRemoveEvent(ptr)
 @ stdcall UiaReturnRawElementProvider(long long long ptr)
diff --git a/dlls/urlmon/sec_mgr.c b/dlls/urlmon/sec_mgr.c
index 78e4c96fd60..82266066e0f 100644
--- a/dlls/urlmon/sec_mgr.c
+++ b/dlls/urlmon/sec_mgr.c
@@ -1548,6 +1548,7 @@ static HRESULT WINAPI ZoneMgrImpl_CreateZoneEnumerator(IInternetZoneManagerEx2*
     ZoneMgrImpl* This = impl_from_IInternetZoneManagerEx2(iface);
     LPDWORD * new_maps;
     LPDWORD data;
+    DWORD new_map_count;
     DWORD i;
 
     TRACE("(%p)->(%p, %p, 0x%08lx)\n", This, pdwEnum, pdwCount, dwFlags);
@@ -1569,25 +1570,15 @@ static HRESULT WINAPI ZoneMgrImpl_CreateZoneEnumerator(IInternetZoneManagerEx2*
         }
     }
 
-    if (This->zonemaps) {
-        /* try to double the nr. of pointers in the array */
-        new_maps = realloc(This->zonemaps, This->zonemap_count * 2 * sizeof(DWORD*));
-        if (new_maps) {
-            memset(new_maps + This->zonemap_count, 0, This->zonemap_count * sizeof(DWORD*));
-            This->zonemap_count *= 2;
-        }
-    }
-    else
-    {
-        This->zonemap_count = 2;
-        new_maps = calloc(This->zonemap_count, sizeof(DWORD*));
-    }
-
+    /* try to double the number of pointers in the array */
+    new_map_count = This->zonemaps ? This->zonemap_count * 2 : 2;
+    new_maps = _recalloc(This->zonemaps, new_map_count, sizeof(DWORD*));
     if (!new_maps) {
         free(data);
         return E_FAIL;
     }
     This->zonemaps = new_maps;
+    This->zonemap_count = new_map_count;
     This->zonemaps[i] = data;
     *pdwEnum = i;
     *pdwCount = data[0];
diff --git a/dlls/user.exe16/dialog.c b/dlls/user.exe16/dialog.c
index b61ae5cd519..2b6731e4aaf 100644
--- a/dlls/user.exe16/dialog.c
+++ b/dlls/user.exe16/dialog.c
@@ -186,7 +186,7 @@ static BOOL DIALOG_CreateControls16( HWND hwnd, LPCSTR template,
         SEGPTR segptr;
 
         template = DIALOG_GetControl16( template, &info );
-        segptr = MapLS( info.data );
+        segptr = MapLS( (void *)info.data );
 
         caption = (char *)info.windowName;
         if (caption && IS_INTRESOURCE(caption))
diff --git a/dlls/user.exe16/hook.c b/dlls/user.exe16/hook.c
index d140e16e426..6d40982297c 100644
--- a/dlls/user.exe16/hook.c
+++ b/dlls/user.exe16/hook.c
@@ -290,8 +290,8 @@ static LRESULT CALLBACK call_WH_CBT( INT code, WPARAM wp, LPARAM lp )
             cs16.y              = cbtcw32->lpcs->y;
             cs16.x              = cbtcw32->lpcs->x;
             cs16.style          = cbtcw32->lpcs->style;
-            cs16.lpszName       = MapLS( cbtcw32->lpcs->lpszName );
-            cs16.lpszClass      = MapLS( cbtcw32->lpcs->lpszClass );
+            cs16.lpszName       = MapLS( (void *)cbtcw32->lpcs->lpszName );
+            cs16.lpszClass      = MapLS( (void *)cbtcw32->lpcs->lpszClass );
             cs16.dwExStyle      = cbtcw32->lpcs->dwExStyle;
 
             cbtcw16.lpcs = (CREATESTRUCT16 *)MapLS( &cs16 );
diff --git a/dlls/user.exe16/message.c b/dlls/user.exe16/message.c
index 59c58ed9bd9..203d543ce90 100644
--- a/dlls/user.exe16/message.c
+++ b/dlls/user.exe16/message.c
@@ -945,15 +945,15 @@ LRESULT WINPROC_CallProc32ATo16( winproc_callback16_t callback, HWND hwnd, UINT
             BOOL mdi_child = (GetWindowLongW(hwnd, GWL_EXSTYLE) & WS_EX_MDICHILD);
 
             CREATESTRUCT32Ato16( cs32, &cs );
-            cs.lpszName  = MapLS( cs32->lpszName );
-            cs.lpszClass = MapLS( cs32->lpszClass );
+            cs.lpszName  = MapLS( (void *)cs32->lpszName );
+            cs.lpszClass = MapLS( (void *)cs32->lpszClass );
 
             if (mdi_child)
             {
                 MDICREATESTRUCTA *mdi_cs = cs32->lpCreateParams;
                 MDICREATESTRUCT32Ato16( mdi_cs, &mdi_cs16 );
-                mdi_cs16.szTitle = MapLS( mdi_cs->szTitle );
-                mdi_cs16.szClass = MapLS( mdi_cs->szClass );
+                mdi_cs16.szTitle = MapLS( (void *)mdi_cs->szTitle );
+                mdi_cs16.szClass = MapLS( (void *)mdi_cs->szClass );
                 cs.lpCreateParams = MapLS( &mdi_cs16 );
             }
             lParam = MapLS( &cs );
@@ -975,8 +975,8 @@ LRESULT WINPROC_CallProc32ATo16( winproc_callback16_t callback, HWND hwnd, UINT
             MDICREATESTRUCT16 cs;
 
             MDICREATESTRUCT32Ato16( cs32, &cs );
-            cs.szTitle = MapLS( cs32->szTitle );
-            cs.szClass = MapLS( cs32->szClass );
+            cs.szTitle = MapLS( (void *)cs32->szTitle );
+            cs.szClass = MapLS( (void *)cs32->szClass );
             lParam = MapLS( &cs );
             ret = callback( HWND_16(hwnd), msg, wParam, lParam, result, arg );
             UnMapLS( lParam );
diff --git a/dlls/user.exe16/window.c b/dlls/user.exe16/window.c
index 69d178e31b0..eac3468a6e0 100644
--- a/dlls/user.exe16/window.c
+++ b/dlls/user.exe16/window.c
@@ -1671,7 +1671,7 @@ BOOL16 WINAPI GetClassInfoEx16( HINSTANCE16 hInst16, SEGPTR name, WNDCLASSEX16 *
         wc->hCursor       = get_icon_16( wc32.hCursor );
         wc->hbrBackground = HBRUSH_16(wc32.hbrBackground);
         wc->lpszClassName = 0;
-        wc->lpszMenuName  = MapLS(wc32.lpszMenuName);  /* FIXME: leak */
+        wc->lpszMenuName  = MapLS((void *)wc32.lpszMenuName);  /* FIXME: leak */
     }
     return ret;
 }
diff --git a/dlls/user32/clipboard.c b/dlls/user32/clipboard.c
index dd33bd7df82..72c7720dc17 100644
--- a/dlls/user32/clipboard.c
+++ b/dlls/user32/clipboard.c
@@ -157,11 +157,13 @@ static HANDLE marshal_data( UINT format, HANDLE handle, size_t *ret_size )
         }
     case CF_UNICODETEXT:
         {
-            WCHAR *ptr;
+            char *ptr;
             if (!(size = GlobalSize( handle ))) return 0;
             if ((data_size_t)size != size) return 0;
+            if (size < sizeof(WCHAR)) return 0;
             if (!(ptr = GlobalLock( handle ))) return 0;
-            ptr[(size + 1) / sizeof(WCHAR) - 1] = 0;  /* enforce null-termination */
+            /* enforce nul-termination the Windows way: ignoring alignment */
+            *((WCHAR *)(ptr + size) - 1) = 0;
             GlobalUnlock( handle );
             *ret_size = size;
             return handle;
diff --git a/dlls/user32/edit.c b/dlls/user32/edit.c
index 74411d385e2..47c61f59c24 100644
--- a/dlls/user32/edit.c
+++ b/dlls/user32/edit.c
@@ -113,6 +113,7 @@ typedef struct
 					   should be sent to the first parent. */
 	HWND hwndListBox;		/* handle of ComboBox's listbox or NULL */
 	INT wheelDeltaRemainder;        /* scroll wheel delta left over after scrolling whole lines */
+	BYTE lead_byte;			/* DBCS lead byte store for WM_CHAR */
 	/*
 	 *	only for multi line controls
 	 */
@@ -4975,8 +4976,24 @@ LRESULT EditWndProc_common( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, B
 		    charW = wParam;
 		else
 		{
-		    CHAR charA = wParam;
-		    MultiByteToWideChar(CP_ACP, 0, &charA, 1, &charW, 1);
+		    BYTE low = wParam;
+		    DWORD cp = get_input_codepage();
+		    if (es->lead_byte)
+		    {
+			char ch[2];
+			ch[0] = es->lead_byte;
+			ch[1] = low;
+			MultiByteToWideChar(cp, 0, ch, 2, &charW, 1);
+		    }
+		    else if (IsDBCSLeadByteEx(cp, low))
+		    {
+			es->lead_byte = low;
+			result = 1;
+			break;
+		    }
+		    else
+			MultiByteToWideChar(cp, 0, (char *)&low, 1, &charW, 1);
+		    es->lead_byte = 0;
 		}
 
                 if (es->hwndListBox)
diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index c5387cf9212..2f4dc06f6ce 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -495,20 +495,49 @@ BOOL WINAPI UnloadKeyboardLayout( HKL layout )
 }
 
 
-/***********************************************************************
- *		EnableMouseInPointer (USER32.@)
- */
-BOOL WINAPI EnableMouseInPointer(BOOL enable)
+static DWORD CALLBACK devnotify_window_callbackW(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
 {
-    FIXME("(%#x) stub\n", enable);
-
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    SendMessageTimeoutW(handle, WM_DEVICECHANGE, flags, (LPARAM)header, SMTO_ABORTIFHUNG, 2000, NULL);
+    return 0;
 }
 
-static DWORD CALLBACK devnotify_window_callback(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
+static DWORD CALLBACK devnotify_window_callbackA(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
 {
-    SendMessageTimeoutW(handle, WM_DEVICECHANGE, flags, (LPARAM)header, SMTO_ABORTIFHUNG, 2000, NULL);
+    if (flags & 0x8000)
+    {
+        switch (header->dbch_devicetype)
+        {
+        case DBT_DEVTYP_DEVICEINTERFACE:
+        {
+            const DEV_BROADCAST_DEVICEINTERFACE_W *ifaceW = (const DEV_BROADCAST_DEVICEINTERFACE_W *)header;
+            size_t lenW = wcslen( ifaceW->dbcc_name );
+            DEV_BROADCAST_DEVICEINTERFACE_A *ifaceA;
+            DWORD lenA;
+
+            if (!(ifaceA = malloc( offsetof(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name[lenW * 3 + 1]) )))
+                return 0;
+            lenA = WideCharToMultiByte( CP_ACP, 0, ifaceW->dbcc_name, lenW + 1,
+                                        ifaceA->dbcc_name, lenW * 3 + 1, NULL, NULL );
+
+            ifaceA->dbcc_size = offsetof(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name[lenA + 1]);
+            ifaceA->dbcc_devicetype = ifaceW->dbcc_devicetype;
+            ifaceA->dbcc_reserved = ifaceW->dbcc_reserved;
+            ifaceA->dbcc_classguid = ifaceW->dbcc_classguid;
+            SendMessageTimeoutA( handle, WM_DEVICECHANGE, flags, (LPARAM)ifaceA, SMTO_ABORTIFHUNG, 2000, NULL );
+            free( ifaceA );
+            return 0;
+        }
+
+        default:
+            FIXME( "unimplemented W to A mapping for %#lx\n", header->dbch_devicetype );
+            /* fall through */
+        case DBT_DEVTYP_HANDLE:
+        case DBT_DEVTYP_OEM:
+            break;
+        }
+    }
+
+    SendMessageTimeoutA( handle, WM_DEVICECHANGE, flags, (LPARAM)header, SMTO_ABORTIFHUNG, 2000, NULL );
     return 0;
 }
 
@@ -591,8 +620,10 @@ HDEVNOTIFY WINAPI RegisterDeviceNotificationW( HANDLE handle, void *filter, DWOR
 
     if (flags & DEVICE_NOTIFY_SERVICE_HANDLE)
         details.cb = devnotify_service_callback;
+    else if (IsWindowUnicode( handle ))
+        details.cb = devnotify_window_callbackW;
     else
-        details.cb = devnotify_window_callback;
+        details.cb = devnotify_window_callbackA;
 
     return I_ScRegisterDeviceNotification( &details, filter, 0 );
 }
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 9ad4abd21b5..33e81c76e4b 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -1192,7 +1192,7 @@ LONG WINAPI BroadcastSystemMessageW( DWORD flags, LPDWORD recipients, UINT msg,
 LONG WINAPI BroadcastSystemMessageExA( DWORD flags, LPDWORD recipients, UINT msg, WPARAM wp, LPARAM lp, PBSMINFO pinfo )
 {
     map_wparam_AtoW( msg, &wp, WMCHAR_MAP_NOMAPPING );
-    return BroadcastSystemMessageExW( flags, recipients, msg, wp, lp, NULL );
+    return BroadcastSystemMessageExW( flags, recipients, msg, wp, lp, pinfo );
 }
 
 
diff --git a/dlls/user32/tests/clipboard.c b/dlls/user32/tests/clipboard.c
index 3131c2e0e8c..87df06b6621 100644
--- a/dlls/user32/tests/clipboard.c
+++ b/dlls/user32/tests/clipboard.c
@@ -986,7 +986,9 @@ static void test_synthesized(void)
 
     SetLastError(0xdeadbeef);
     data = GetClipboardData( CF_TEXT );
-    ok(GetLastError() == 0xdeadbeef, "bad last error %ld\n", GetLastError());
+    ok(GetLastError() == ERROR_NOT_FOUND /* win11 */ ||
+       broken(GetLastError() == 0xdeadbeef),
+       "bad last error %ld\n", GetLastError());
     ok(!data, "GetClipboardData() should have returned NULL\n");
 
     r = CloseClipboard();
@@ -1587,7 +1589,9 @@ static void test_handles( HWND hwnd )
 
     SetLastError( 0xdeadbeef );
     data = GetClipboardData( CF_RIFF );
-    ok( GetLastError() == 0xdeadbeef, "unexpected last error %ld\n", GetLastError() );
+    ok( GetLastError() == ERROR_NOT_FOUND /* win11 */ ||
+        broken(GetLastError() == 0xdeadbeef),
+        "unexpected last error %ld\n", GetLastError() );
     ok( !data, "wrong data %p\n", data );
 
     h = SetClipboardData( CF_PRIVATEFIRST + 7, htext4 );
@@ -2213,35 +2217,39 @@ static const struct
     UINT  len;
 } test_data[] =
 {
-    { "foo", {}, 3 },      /* 0 */
+    { "foo", {}, 3 },                 /* 0 */
     { "foo", {}, 4 },
     { "foo\0bar", {}, 7 },
     { "foo\0bar", {}, 8 },
-    { "", {'f','o','o'}, 3 * sizeof(WCHAR) },
-    { "", {'f','o','o',0}, 4 * sizeof(WCHAR) },     /* 5 */
+    { "", {}, 0 },
+    { "", {'f'}, 1 },                 /* 5 */
+    { "", {'f'}, 2 },
+    { "", {0x3b1,0x3b2,0x3b3}, 5 }, /* Alpha, beta, ... */
+    { "", {0x3b1,0x3b2,0x3b3}, 6 },
+    { "", {0x3b1,0x3b2,0x3b3,0}, 7 }, /* 10 */
+    { "", {0x3b1,0x3b2,0x3b3,0}, 8 },
+    { "", {0x3b1,0x3b2,0x3b3,0,0x3b4}, 9 },
     { "", {'f','o','o',0,'b','a','r'}, 7 * sizeof(WCHAR) },
     { "", {'f','o','o',0,'b','a','r',0}, 8 * sizeof(WCHAR) },
-    { "", {'f','o','o'}, 1 },
-    { "", {'f','o','o'}, 2 },
-    { "", {'f','o','o'}, 5 },     /* 10 */
-    { "", {'f','o','o',0}, 7 },
-    { "", {'f','o','o',0}, 9 },
 };
 
 static void test_string_data(void)
 {
     UINT i;
     BOOL r;
-    HANDLE data;
+    HANDLE data, clip;
     char cmd[16];
     char bufferA[12];
     WCHAR bufferW[12];
 
     for (i = 0; i < ARRAY_SIZE(test_data); i++)
     {
-        /* 1-byte Unicode strings crash on Win64 */
 #ifdef _WIN64
-        if (!test_data[i].strA[0] && test_data[i].len < sizeof(WCHAR)) continue;
+        /* Before Windows 11 1-byte Unicode strings crash on Win64
+         * because it underflows when 'appending' a 2 bytes NUL character!
+         */
+        if (!test_data[i].strA[0] && test_data[i].len < sizeof(WCHAR) &&
+            strcmp(winetest_platform, "windows") == 0) continue;
 #endif
         winetest_push_context("%d", i);
         r = open_clipboard( 0 );
@@ -2261,11 +2269,17 @@ static void test_string_data(void)
         else
         {
             memcpy( data, test_data[i].strW, test_data[i].len );
-            SetClipboardData( CF_UNICODETEXT, data );
-            memcpy( bufferW, test_data[i].strW, test_data[i].len );
-            bufferW[(test_data[i].len + 1) / sizeof(WCHAR) - 1] = 0;
-            ok( !memcmp( data, bufferW, test_data[i].len ),
-                "wrong data %s\n", wine_dbgstr_wn( data, (test_data[i].len + 1) / sizeof(WCHAR) ));
+            clip = SetClipboardData( CF_UNICODETEXT, data );
+            if (test_data[i].len >= sizeof(WCHAR))
+            {
+                ok( clip == data, "SetClipboardData() returned %p != %p\n", clip, data );
+                memcpy( bufferW, test_data[i].strW, test_data[i].len );
+                *((WCHAR *)((char *)bufferW + test_data[i].len) - 1) = 0;
+                ok( !memcmp( data, bufferW, test_data[i].len ),
+                    "wrong data %s\n", wine_dbgstr_an( data, test_data[i].len ));
+            }
+            else
+                ok( !clip || broken(clip != NULL), "expected SetClipboardData() to fail\n" );
         }
         r = CloseClipboard();
         ok( r, "gle %ld\n", GetLastError() );
@@ -2305,13 +2319,27 @@ static void test_string_data_process( int i )
     else
     {
         data = GetClipboardData( CF_UNICODETEXT );
-        ok( data != 0, "could not get data\n" );
-        len = GlobalSize( data );
-        ok( len == test_data[i].len, "wrong size %u / %u\n", len, test_data[i].len );
-        memcpy( bufferW, test_data[i].strW, test_data[i].len );
-        bufferW[(test_data[i].len + 1) / sizeof(WCHAR) - 1] = 0;
-        ok( !memcmp( data, bufferW, len ),
-            "wrong data %s\n", wine_dbgstr_wn( data, (len + 1) / sizeof(WCHAR) ));
+        if (!data)
+        {
+            ok( test_data[i].len < sizeof(WCHAR), "got no data for len=%d\n", test_data[i].len );
+            ok( !IsClipboardFormatAvailable( CF_UNICODETEXT ), "unicode available\n" );
+        }
+        else if (test_data[i].len == 0)
+        {
+            /* 0-byte string handling is broken on Windows <= 10 */
+            len = GlobalSize( data );
+            ok( broken(len == 1), "wrong size %u / 0\n", len );
+            ok( broken(*((char*)data) == 0), "wrong data %s\n", wine_dbgstr_an( data, len ));
+        }
+        else
+        {
+            len = GlobalSize( data );
+            ok( len == test_data[i].len, "wrong size %u / %u\n", len, test_data[i].len );
+            memcpy( bufferW, test_data[i].strW, test_data[i].len );
+            *((WCHAR *)((char *)bufferW + test_data[i].len) - 1) = 0;
+            ok( !memcmp( data, bufferW, len ), "wrong data %s\n", wine_dbgstr_an( data, len ));
+        }
+
         data = GetClipboardData( CF_TEXT );
         if (test_data[i].len >= sizeof(WCHAR))
         {
@@ -2321,12 +2349,15 @@ static void test_string_data_process( int i )
                                         bufferA, ARRAY_SIZE(bufferA), NULL, NULL );
             bufferA[len2 - 1] = 0;
             ok( len == len2, "wrong size %u / %u\n", len, len2 );
-            ok( !memcmp( data, bufferA, len ), "wrong data %.*s\n", len, (char *)data );
+            ok( !memcmp( data, bufferA, len ), "wrong data %s, expected %s\n",
+                wine_dbgstr_an( data, len ), wine_dbgstr_an( bufferA, len2 ));
         }
         else
         {
+            BOOL available = IsClipboardFormatAvailable( CF_TEXT );
+            ok( !available || broken(available /* win10 */),
+                "available text %d\n", available );
             ok( !data, "got data for empty string\n" );
-            ok( IsClipboardFormatAvailable( CF_TEXT ), "text not available\n" );
         }
     }
     r = CloseClipboard();
diff --git a/dlls/user32/tests/edit.c b/dlls/user32/tests/edit.c
index b70cf2d6e06..78328ee1729 100644
--- a/dlls/user32/tests/edit.c
+++ b/dlls/user32/tests/edit.c
@@ -3366,6 +3366,58 @@ static void test_wordbreak_proc(void)
     DestroyWindow(hwnd);
 }
 
+static void test_dbcs_WM_CHAR(void)
+{
+    WCHAR textW[] = { 0x4e00, 0x4e8c, 0x4e09, 0 }; /* one, two, three */
+    unsigned char bytes[7];
+    HWND hwnd[2];
+    int i;
+
+    WideCharToMultiByte(CP_ACP, 0, textW, -1, (char *)bytes, ARRAY_SIZE(bytes), NULL, NULL);
+    if (!IsDBCSLeadByte(bytes[0]))
+    {
+        skip("Skipping DBCS WM_CHAR test in this codepage\n");
+        return;
+    }
+    hwnd[0] = create_editcontrol(ES_AUTOHSCROLL | ES_AUTOVSCROLL, 0);
+    hwnd[1] = create_editcontrolW(ES_AUTOHSCROLL | ES_AUTOVSCROLL, 0);
+
+    for (i = 0; i < ARRAY_SIZE(hwnd); i++)
+    {
+        const unsigned char* p;
+        WCHAR strW[4];
+        char str[7];
+        MSG msg;
+        BOOL r;
+        int n;
+
+        winetest_push_context("%c", i ? 'W' : 'A');
+
+        r = SetWindowTextA(hwnd[i], "");
+        ok(r, "SetWindowText failed\n");
+
+        for (p = bytes; *p; p++)
+            PostMessageA(hwnd[i], WM_CHAR, *p, 1);
+
+        while (PeekMessageA(&msg, hwnd[i], 0, 0, PM_REMOVE))
+            DispatchMessageA(&msg);
+
+        n = GetWindowTextW(hwnd[i], strW, ARRAY_SIZE(strW));
+        ok(n > 0, "GetWindowTextW failed\n");
+        ok(!wcscmp(strW, textW), "got %s, expected %s\n",
+           wine_dbgstr_w(strW), wine_dbgstr_w(textW));
+
+        n = GetWindowTextA(hwnd[i], str, ARRAY_SIZE(str));
+        ok(n > 0, "GetWindowText failed\n");
+        ok(!strcmp(str, (char*)bytes), "got %s, expected %s\n",
+           wine_dbgstr_a(str), wine_dbgstr_a((char *)bytes));
+
+        DestroyWindow(hwnd[i]);
+
+        winetest_pop_context();
+    }
+}
+
 START_TEST(edit)
 {
     BOOL b;
@@ -3403,6 +3455,7 @@ START_TEST(edit)
     test_paste();
     test_EM_GETLINE();
     test_wordbreak_proc();
+    test_dbcs_WM_CHAR();
 
     UnregisterWindowClasses();
 }
diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index bf913b8e6a6..ee39b11fc12 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -2296,13 +2296,15 @@ static LRESULT CALLBACK rawinputbuffer_wndproc(HWND hwnd, UINT msg, WPARAM wpara
 
 static void test_GetRawInputBuffer(void)
 {
-    unsigned int size, count, rawinput_size, header_size;
+    unsigned int size, count, rawinput_size, header_size, scan_code;
     RAWINPUTDEVICE raw_devices[1];
     char buffer[16 * sizeof(RAWINPUT64)];
     HWND hwnd;
     BOOL ret;
     POINT pt;
 
+#define HEADER_FIELD(field) (is_wow64 ? ((RAWINPUT64 *)buffer)->header.field : ((RAWINPUT *)buffer)->header.field)
+
     if (is_wow64) rawinput_size = sizeof(RAWINPUT64);
     else rawinput_size = sizeof(RAWINPUT);
 
@@ -2392,6 +2394,8 @@ static void test_GetRawInputBuffer(void)
     count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
     ok(count == 1U, "GetRawInputBuffer returned %u\n", count);
     ok(size == sizeof(buffer), "GetRawInputBuffer returned unexpected size: %u\n", size);
+    ok(HEADER_FIELD(dwType) == RIM_TYPEMOUSE, "Unexpected rawinput dwType: %ld\n", HEADER_FIELD(dwType));
+    ok(HEADER_FIELD(wParam) == 0 || HEADER_FIELD(wParam) == 1, "Expected wparam 0 or 1, got %Iu\n", (WPARAM)HEADER_FIELD(wParam));
     ok(rawinput_buffer_mouse_x(buffer, 0) == 5, "Unexpected rawinput data: %d\n", rawinput_buffer_mouse_x(buffer, 0));
 
 
@@ -2428,7 +2432,43 @@ static void test_GetRawInputBuffer(void)
     ok(ret, "RegisterRawInputDevices failed\n");
     ok(GetLastError() == 0xdeadbeef, "RegisterRawInputDevices returned %08lx\n", GetLastError());
 
+
+    /* some keyboard tests to better check fields under wow64 */
+    raw_devices[0].usUsagePage = 0x01;
+    raw_devices[0].usUsage = 0x06;
+    raw_devices[0].dwFlags = RIDEV_INPUTSINK;
+    raw_devices[0].hwndTarget = hwnd;
+
+    SetLastError(0xdeadbeef);
+    ret = RegisterRawInputDevices(raw_devices, ARRAY_SIZE(raw_devices), sizeof(RAWINPUTDEVICE));
+    ok(ret, "RegisterRawInputDevices failed\n");
+    ok(GetLastError() == 0xdeadbeef, "RegisterRawInputDevices returned %08lx\n", GetLastError());
+
+    keybd_event('X', 0x2d, 0, 0);
+    keybd_event('X', 0x2d, KEYEVENTF_KEYUP, 0);
+
+    size = sizeof(buffer);
+    memset(buffer, 0, sizeof(buffer));
+    count = GetRawInputBuffer((RAWINPUT*)buffer, &size, sizeof(RAWINPUTHEADER));
+    ok(count == 2U, "GetRawInputBuffer returned %u\n", count);
+    ok(size == sizeof(buffer), "GetRawInputBuffer returned unexpected size: %u\n", size);
+
+    ok(HEADER_FIELD(dwType) == RIM_TYPEKEYBOARD, "Unexpected rawinput dwType: %ld\n", HEADER_FIELD(dwType));
+    ok(HEADER_FIELD(wParam) == 0 || HEADER_FIELD(wParam) == 1, "Expected wparam 0 or 1, got %Iu\n", (WPARAM)HEADER_FIELD(wParam));
+    scan_code = is_wow64 ? ((RAWINPUT64 *)buffer)->data.keyboard.MakeCode : ((RAWINPUT *)buffer)->data.keyboard.MakeCode;
+    ok(scan_code == 0x2d, "Unexpected rawinput keyboard scan code: %x\n", scan_code);
+
+    raw_devices[0].dwFlags = RIDEV_REMOVE;
+    raw_devices[0].hwndTarget = 0;
+
+    SetLastError(0xdeadbeef);
+    ret = RegisterRawInputDevices(raw_devices, ARRAY_SIZE(raw_devices), sizeof(RAWINPUTDEVICE));
+    ok(ret, "RegisterRawInputDevices failed\n");
+    ok(GetLastError() == 0xdeadbeef, "RegisterRawInputDevices returned %08lx\n", GetLastError());
+
     DestroyWindow(hwnd);
+
+#undef HEADER_FIELD
 }
 
 static BOOL rawinput_test_received_legacy;
@@ -3129,12 +3169,14 @@ static void test_ToUnicode(void)
 
 static void test_ToAscii(void)
 {
+    WCHAR wstr[16];
+    char str[16];
     WORD character;
     BYTE state[256];
     const BYTE SC_RETURN = 0x1c, SC_A = 0x1e;
     const BYTE HIGHEST_BIT = 0x80;
-    int ret;
-    BOOL us_kbd = (GetKeyboardLayout(0) == (HKL)(ULONG_PTR)0x04090409);
+    int ret, len;
+    DWORD gle;
 
     memset(state, 0, sizeof(state));
 
@@ -3143,10 +3185,32 @@ static void test_ToAscii(void)
     ok(ret == 1, "ToAscii for Return key didn't return 1 (was %i)\n", ret);
     ok(character == '\r', "ToAscii for Return was %i (expected 13)\n", character);
 
+    wstr[0] = 0;
+    ret = ToUnicode('A', SC_A, state, wstr, sizeof(wstr), 0);
+    ok(ret == 1, "ToUnicode(A) returned %i, expected 1\n", ret);
+
+    str[0] = '\0';
+    len = WideCharToMultiByte(CP_ACP, 0, wstr, -1, str, sizeof(str), NULL, NULL);
+    gle = GetLastError();
+    ok(len > 0, "Could not convert %s (gle %lu)\n", wine_dbgstr_w(wstr), gle);
+
     character = 0;
     ret = ToAscii('A', SC_A, state, &character, 0);
-    ok(ret == 1, "ToAscii for character 'A' didn't return 1 (was %i)\n", ret);
-    if (us_kbd) ok(character == 'a', "ToAscii for character 'A' was %i (expected %i)\n", character, 'a');
+    if (len == 1 || len == 2)
+        ok(ret == 1, "ToAscii(A) returned %i, expected 1\n", ret);
+    else
+        /* ToAscii() can only return 2 chars => it fails if len > 2 */
+        ok(ret == 0, "ToAscii(A) returned %i, expected 0\n", ret);
+    switch ((ULONG_PTR)GetKeyboardLayout(0))
+    {
+    case 0x04090409: /* Qwerty */
+    case 0x04070407: /* Qwertz */
+    case 0x040c040c: /* Azerty */
+        ok(lstrcmpW(wstr, L"a") == 0, "ToUnicode(A) returned %s\n", wine_dbgstr_w(wstr));
+        ok(character == 'a', "ToAscii(A) returned char=%i, expected %i\n", character, 'a');
+        break;
+    /* Other keyboard layouts may or may not return 'a' */
+    }
 
     state[VK_CONTROL] |= HIGHEST_BIT;
     state[VK_LCONTROL] |= HIGHEST_BIT;
@@ -4804,17 +4868,15 @@ static void test_EnableMouseInPointer_process( const char *arg )
     ok( !ret, "EnableMouseInPointer succeeded\n" );
     todo_wine
     ok( GetLastError() == ERROR_ACCESS_DENIED, "got error %lu\n", GetLastError() );
-    if (!pIsMouseInPointerEnabled) ret = !enable;
-    else ret = pIsMouseInPointerEnabled();
-    todo_wine_if(!pIsMouseInPointerEnabled)
+    ret = pIsMouseInPointerEnabled();
+    todo_wine_if(enable)
     ok( ret == enable, "IsMouseInPointerEnabled returned %u, error %lu\n", ret, GetLastError() );
 
     ret = pEnableMouseInPointer( enable );
     todo_wine
     ok( ret, "EnableMouseInPointer failed, error %lu\n", GetLastError() );
-    if (!pIsMouseInPointerEnabled) ret = !enable;
-    else ret = pIsMouseInPointerEnabled();
-    todo_wine_if(!pIsMouseInPointerEnabled)
+    ret = pIsMouseInPointerEnabled();
+    todo_wine_if(enable)
     ok( ret == enable, "IsMouseInPointerEnabled returned %u, error %lu\n", ret, GetLastError() );
 
     test_GetPointerInfo( enable );
diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 35e4f0dd1f8..6faaa2c2f40 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -20,9 +20,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <assert.h>
 #include <limits.h>
 #include <stdarg.h>
+#include <stdbool.h>
 #include <stdio.h>
 
 #include "windef.h"
@@ -119,6 +119,13 @@ static const WCHAR testWindowClassW[] =
 
 static LRESULT WINAPI ParentMsgCheckProcA(HWND, UINT, WPARAM, LPARAM);
 
+static void register_class(const WNDCLASSA *class)
+{
+    BOOL ret = RegisterClassA(class);
+    ok(ret, "Failed to register class %s, error %lu.\n",
+            debugstr_a(class->lpszClassName), GetLastError());
+}
+
 /*
 FIXME: add tests for these
 Window Edge Styles (Win31/Win95/98 look), in order of precedence:
@@ -2418,7 +2425,6 @@ static void add_message_(int line, const struct recvd_message *msg)
 	sequence_size *= 2;
 	sequence = HeapReAlloc( GetProcessHeap(), 0, sequence, sequence_size * sizeof(*sequence) );
     }
-    assert(sequence);
 
     seq = &sequence[sequence_cnt++];
     seq->hwnd = msg->hwnd;
@@ -4099,9 +4105,10 @@ static LRESULT WINAPI mdi_frame_wnd_proc(HWND hwnd, UINT message, WPARAM wParam,
     return ret;
 }
 
-static BOOL mdi_RegisterWindowClasses(void)
+static void mdi_register_classes(void)
 {
     WNDCLASSA cls;
+    BOOL ret;
 
     cls.style = 0;
     cls.lpfnWndProc = mdi_frame_wnd_proc;
@@ -4113,20 +4120,19 @@ static BOOL mdi_RegisterWindowClasses(void)
     cls.hbrBackground = GetStockObject(WHITE_BRUSH);
     cls.lpszMenuName = NULL;
     cls.lpszClassName = "MDI_frame_class";
-    if (!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = mdi_child_wnd_proc;
     cls.lpszClassName = "MDI_child_class";
-    if (!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
-    if (!GetClassInfoA(0, "MDIClient", &cls)) assert(0);
+    ret = GetClassInfoA(0, "MDIClient", &cls);
+    ok(ret, "Failed to get class info, error %lu.\n", GetLastError());
     old_mdi_client_proc = cls.lpfnWndProc;
     cls.hInstance = GetModuleHandleA(0);
     cls.lpfnWndProc = mdi_client_hook_proc;
     cls.lpszClassName = "MDI_client_class";
-    if (!RegisterClassA(&cls)) assert(0);
-
-    return TRUE;
+    register_class(&cls);
 }
 
 static void test_mdi_messages(void)
@@ -4139,7 +4145,7 @@ static void test_mdi_messages(void)
     HMENU hMenu = CreateMenu();
     LONG val;
 
-    if (!mdi_RegisterWindowClasses()) assert(0);
+    mdi_register_classes();
 
     flush_sequence();
 
@@ -4150,7 +4156,7 @@ static void test_mdi_messages(void)
                                 100, 100, CW_USEDEFAULT, CW_USEDEFAULT,
                                 GetDesktopWindow(), hMenu,
                                 GetModuleHandleA(0), NULL);
-    assert(mdi_frame);
+    ok(!!mdi_frame, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIframeSeq, "Create MDI frame window", FALSE);
 
     ok(GetActiveWindow() == mdi_frame, "wrong active window %p\n", GetActiveWindow());
@@ -4165,7 +4171,7 @@ static void test_mdi_messages(void)
                                  WS_CHILD | WS_VISIBLE | MDIS_ALLCHILDSTYLES,
                                  rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                                  mdi_frame, 0, GetModuleHandleA(0), &client_cs);
-    assert(mdi_client);
+    ok(!!mdi_client, "Failed to create window, error %lu.\n", GetLastError());
     SetWindowLongA(mdi_client, 0, 0xdeadbeef);
 
     ok_sequence(WmCreateMDIclientSeq, "Create visible MDI client window", FALSE);
@@ -4184,7 +4190,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child);
+    ok(!!mdi_child, "Failed to create window, error %lu.\n", GetLastError());
 
     flush_sequence();
     ShowWindow(mdi_child, SW_SHOWNORMAL);
@@ -4225,7 +4231,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_VISIBLE,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child);
+    ok(!!mdi_child, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildVisibleSeq, "Create visible MDI child window", FALSE);
 
     ok(GetWindowLongA(mdi_child, GWL_STYLE) & WS_VISIBLE, "MDI child should be visible\n");
@@ -4261,7 +4267,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child2);
+    ok(!!mdi_child2, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildInvisibleSeq, "Create invisible MDI child window", FALSE);
 
     ok(!(GetWindowLongA(mdi_child2, GWL_STYLE) & WS_VISIBLE), "MDI child should not be visible\n");
@@ -4425,7 +4431,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_VISIBLE | WS_MAXIMIZEBOX | WS_MAXIMIZE,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child);
+    ok(!!mdi_child, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildVisibleMaxSeq1, "Create maximized visible 1st MDI child window", TRUE);
     ok(IsZoomed(mdi_child), "1st MDI child should be maximized\n");
 
@@ -4444,7 +4450,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_VISIBLE | WS_MAXIMIZEBOX | WS_MAXIMIZE,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child2);
+    ok(!!mdi_child2, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildVisibleMaxSeq2, "Create maximized visible 2nd MDI child 2 window", TRUE);
     ok(IsZoomed(mdi_child2), "2nd MDI child should be maximized\n");
     ok(!IsZoomed(mdi_child), "1st MDI child should NOT be maximized\n");
@@ -4487,7 +4493,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_VISIBLE | WS_MAXIMIZEBOX | WS_MAXIMIZE,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child2);
+    ok(!!mdi_child2, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildVisibleMaxSeq2, "Create maximized visible 2nd MDI child 2 window", TRUE);
     ok(IsZoomed(mdi_child2), "2nd MDI child should be maximized\n");
     ok(!IsZoomed(mdi_child), "1st MDI child should NOT be maximized\n");
@@ -4533,7 +4539,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_MAXIMIZE | WS_CAPTION | WS_THICKFRAME,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child2);
+    ok(!!mdi_child2, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildInvisibleMaxSeq4, "Create maximized invisible MDI child window", FALSE);
     ok(IsZoomed(mdi_child2), "MDI child should be maximized\n");
     ok(!(GetWindowLongA(mdi_child2, GWL_STYLE) & WS_VISIBLE), "MDI child should be not visible\n");
@@ -4571,7 +4577,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_VISIBLE | WS_MAXIMIZEBOX | WS_MAXIMIZE,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child);
+    ok(!!mdi_child, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildVisibleMaxSeq1, "Create maximized visible 1st MDI child window(Switch test)", TRUE);
     ok(IsZoomed(mdi_child), "1st MDI child should be maximized(Switch test)\n");
 
@@ -4590,7 +4596,7 @@ static void test_mdi_messages(void)
                                 WS_CHILD | WS_VISIBLE | WS_MAXIMIZEBOX | WS_MAXIMIZE,
                                 0, 0, CW_USEDEFAULT, CW_USEDEFAULT,
                                 mdi_client, 0, GetModuleHandleA(0), NULL);
-    assert(mdi_child2);
+    ok(!!mdi_child2, "Failed to create window, error %lu.\n", GetLastError());
     ok_sequence(WmCreateMDIchildVisibleMaxSeq2, "Create maximized visible 2nd MDI child window (Switch test)", TRUE);
 
     ok(IsZoomed(mdi_child2), "2nd MDI child should be maximized(Switch test)\n");
@@ -6733,8 +6739,10 @@ log_it:
 static void subclass_button(void)
 {
     WNDCLASSA cls;
+    BOOL ret;
 
-    if (!GetClassInfoA(0, "button", &cls)) assert(0);
+    ret = GetClassInfoA(0, "button", &cls);
+    ok(ret, "Failed to get class info, error %lu.\n", GetLastError());
 
     old_button_proc = cls.lpfnWndProc;
 
@@ -6742,7 +6750,7 @@ static void subclass_button(void)
     cls.lpfnWndProc = button_hook_proc;
     cls.lpszClassName = "my_button_class";
     UnregisterClassA(cls.lpszClassName, cls.hInstance);
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 }
 
 static void test_button_messages(void)
@@ -7663,8 +7671,10 @@ static LRESULT CALLBACK static_hook_proc(HWND hwnd, UINT message, WPARAM wParam,
 static void subclass_static(void)
 {
     WNDCLASSA cls;
+    BOOL ret;
 
-    if (!GetClassInfoA(0, "static", &cls)) assert(0);
+    ret = GetClassInfoA(0, "static", &cls);
+    ok(ret, "Failed to get class info, error %lu.\n", GetLastError());
 
     old_static_proc = cls.lpfnWndProc;
 
@@ -7672,7 +7682,7 @@ static void subclass_static(void)
     cls.lpfnWndProc = static_hook_proc;
     cls.lpszClassName = "my_static_class";
     UnregisterClassA(cls.lpszClassName, cls.hInstance);
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 }
 
 static void test_static_messages(void)
@@ -7938,8 +7948,10 @@ static LRESULT CALLBACK combobox_hook_proc(HWND hwnd, UINT message, WPARAM wPara
 static void subclass_combobox(void)
 {
     WNDCLASSA cls;
+    BOOL ret;
 
-    if (!GetClassInfoA(0, "ComboBox", &cls)) assert(0);
+    ret = GetClassInfoA(0, "ComboBox", &cls);
+    ok(ret, "Failed to get class info, error %lu.\n", GetLastError());
 
     old_combobox_proc = cls.lpfnWndProc;
 
@@ -7947,7 +7959,7 @@ static void subclass_combobox(void)
     cls.lpfnWndProc = combobox_hook_proc;
     cls.lpszClassName = "my_combobox_class";
     UnregisterClassA(cls.lpszClassName, cls.hInstance);
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 }
 
 static void test_combobox_messages(void)
@@ -8129,7 +8141,7 @@ static void register_wmime_keydown_class(void)
     cls.lpfnWndProc = wmime_keydown_procA;
     cls.hInstance = GetModuleHandleA(0);
     cls.lpszClassName = "wmime_keydown_class";
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 }
 
 static void test_wmime_keydown_message(void)
@@ -8362,6 +8374,7 @@ static void test_paint_messages(void)
 {
     BOOL ret;
     RECT rect, rect2;
+    DWORD style;
     POINT pt;
     MSG msg;
     HWND hparent, hchild;
@@ -8902,7 +8915,8 @@ static void test_paint_messages(void)
     flush_events();
     ok_sequence( WmParentOnlyPaint, "WmParentOnlyPaint", FALSE );
 
-    assert( GetWindowLongA(hparent, GWL_STYLE) & WS_CLIPCHILDREN );
+    style = GetWindowLongA(hparent, GWL_STYLE);
+    ok(style & WS_CLIPCHILDREN, "Got unexpected style %#lx.\n", style);
     UpdateWindow( hparent );
     flush_events();
     flush_sequence();
@@ -8929,7 +8943,8 @@ static void test_paint_messages(void)
     flush_events();
     ok_sequence( WmParentPaint, "WmParentPaint", FALSE );
 
-    assert( !(GetWindowLongA(hparent, GWL_STYLE) & WS_CLIPCHILDREN) );
+    style = GetWindowLongA(hparent, GWL_STYLE);
+    ok(!(style & WS_CLIPCHILDREN), "Got unexpected style %#lx.\n", style);
     UpdateWindow( hparent );
     flush_events();
     flush_sequence();
@@ -10168,7 +10183,7 @@ static void test_accelerators(void)
     BOOL us_kbd = (GetKeyboardLayout(0) == (HKL)(ULONG_PTR)0x04090409);
     BOOL ret;
 
-    assert(hwnd != 0);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     UpdateWindow(hwnd);
     flush_events();
     flush_sequence();
@@ -10182,7 +10197,7 @@ static void test_accelerators(void)
     ok(state == 0, "wrong CapsLock state %04x\n", state);
 
     hAccel = LoadAcceleratorsA(GetModuleHandleA(NULL), MAKEINTRESOURCEA(1));
-    assert(hAccel != 0);
+    ok(!!hAccel, "Failed to load accelerators, error %lu.\n", GetLastError());
 
     flush_events();
     pump_msg_loop(hwnd, 0);
@@ -10248,7 +10263,7 @@ static void test_accelerators(void)
     ok( ret, "DestroyAcceleratorTable error %ld\n", GetLastError());
 
     hAccel = LoadAcceleratorsA(GetModuleHandleA(NULL), MAKEINTRESOURCEA(2));
-    assert(hAccel != 0);
+    ok(!!hAccel, "Failed to load accelerators, error %lu.\n", GetLastError());
 
     if (winetest_debug > 1) trace("testing VK_N press/release\n");
     flush_sequence();
@@ -10817,7 +10832,7 @@ static LRESULT WINAPI HotkeyMsgCheckProcA(HWND hwnd, UINT message, WPARAM wParam
     return ret;
 }
 
-static BOOL RegisterWindowClasses(void)
+static void register_classes(void)
 {
     WNDCLASSA cls;
     WNDCLASSW clsW;
@@ -10832,39 +10847,39 @@ static BOOL RegisterWindowClasses(void)
     cls.hbrBackground = GetStockObject(WHITE_BRUSH);
     cls.lpszMenuName = NULL;
     cls.lpszClassName = "TestWindowClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = HotkeyMsgCheckProcA;
     cls.lpszClassName = "HotkeyWindowClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = ShowWindowProcA;
     cls.lpszClassName = "ShowWindowClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = PopupMsgCheckProcA;
     cls.lpszClassName = "TestPopupClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = ParentMsgCheckProcA;
     cls.lpszClassName = "TestParentClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = StopQuitMsgCheckProcA;
     cls.lpszClassName = "StopQuitClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = DefWindowProcA;
     cls.lpszClassName = "SimpleWindowClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = PaintLoopProcA;
     cls.lpszClassName = "PaintLoopWindowClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.style = CS_NOCLOSE;
     cls.lpszClassName = "NoCloseWindowClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     ok(GetClassInfoA(0, "#32770", &cls), "GetClassInfo failed\n");
     cls.style = 0;
@@ -10872,27 +10887,27 @@ static BOOL RegisterWindowClasses(void)
     cls.hbrBackground = 0;
     cls.lpfnWndProc = TestDlgProcA;
     cls.lpszClassName = "TestDialogClass";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = DefWindowProcA;
     cls.style = CS_PARENTDC;
     cls.lpszClassName = "SimpleWindowClassWithParentDC";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = DefWindowProcA;
     cls.style = CS_HREDRAW;
     cls.lpszClassName = "SimpleWindowClassWithHRedraw";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = DefWindowProcA;
     cls.style = CS_VREDRAW;
     cls.lpszClassName = "SimpleWindowClassWithVRedraw";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     cls.lpfnWndProc = DefWindowProcA;
     cls.style = CS_HREDRAW | CS_VREDRAW;
     cls.lpszClassName = "SimpleWindowClassWithHVRedraw";
-    if(!RegisterClassA(&cls)) return FALSE;
+    register_class(&cls);
 
     clsW.style = 0;
     clsW.lpfnWndProc = MsgCheckProcW;
@@ -10905,8 +10920,6 @@ static BOOL RegisterWindowClasses(void)
     clsW.lpszMenuName = NULL;
     clsW.lpszClassName = testWindowClassW;
     RegisterClassW(&clsW);  /* ignore error, this fails on Win9x */
-
-    return TRUE;
 }
 
 static BOOL is_our_logged_class(HWND hwnd)
@@ -11026,8 +11039,12 @@ static void CALLBACK win_event_proc(HWINEVENTHOOK hevent,
 static const WCHAR wszUnicode[] = {'U','n','i','c','o','d','e',0};
 static const WCHAR wszAnsi[] = {'U',0};
 
+static const GUID iface_guid = {0x66666666};
+
 static LRESULT CALLBACK MsgConversionProcW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 {
+    const DEV_BROADCAST_DEVICEINTERFACE_A *ifaceA = (const void *)lParam;
+
     switch (uMsg)
     {
     case CB_FINDSTRINGEXACT:
@@ -11036,6 +11053,19 @@ static LRESULT CALLBACK MsgConversionProcW(HWND hwnd, UINT uMsg, WPARAM wParam,
         if (!lstrcmpW((LPCWSTR)lParam, wszAnsi))
             return 0;
         return -1;
+
+    case WM_DEVICECHANGE:
+        if (wParam == DBT_DEVICEARRIVAL && IsEqualGUID(&ifaceA->dbcc_classguid, &iface_guid))
+        {
+            DWORD expect_size = offsetof(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name[strlen(ifaceA->dbcc_name)]);
+
+            ok(ifaceA->dbcc_size == expect_size, "Expected %lu, got %lu.\n", expect_size, ifaceA->dbcc_size);
+            ok(ifaceA->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE,
+                    "Got notification type %#lx.\n", ifaceA->dbcc_devicetype);
+            ok(!ifaceA->dbcc_reserved, "Got reserved %#lx.\n", ifaceA->dbcc_reserved);
+            ok(!strcmp(ifaceA->dbcc_name, "test name"), "Got name %s.\n", debugstr_a(ifaceA->dbcc_name));
+            return 2;
+        }
     }
     return DefWindowProcW(hwnd, uMsg, wParam, lParam);
 }
@@ -11067,6 +11097,8 @@ static void test_message_conversion(void)
 {
     static const WCHAR wszMsgConversionClass[] =
         {'M','s','g','C','o','n','v','e','r','s','i','o','n','C','l','a','s','s',0};
+    char buffer[200];
+    DEV_BROADCAST_DEVICEINTERFACE_A *dev_interface = (void *)buffer;
     WNDCLASSW cls;
     LRESULT lRes;
     HWND hwnd;
@@ -11149,12 +11181,25 @@ static void test_message_conversion(void)
     ok(lRes == 0 && (GetLastError() == ERROR_MESSAGE_SYNC_ONLY || GetLastError() == ERROR_INVALID_PARAMETER),
         "SendMessageCallback on sync only message returned %Id, last error %ld\n", lRes, GetLastError());
 
+    /* Test WM_DEVICECHANGE. */
+
+    dev_interface->dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
+    dev_interface->dbcc_reserved = 0;
+    dev_interface->dbcc_classguid = iface_guid;
+    strcpy(dev_interface->dbcc_name, "test name");
+    dev_interface->dbcc_size = offsetof(DEV_BROADCAST_DEVICEINTERFACE_A,
+            dbcc_name[strlen(dev_interface->dbcc_name)]);
+    lRes = SendMessageA(hwnd, WM_DEVICECHANGE, DBT_DEVICEARRIVAL, (LPARAM)dev_interface);
+    ok(lRes == 2, "Got %Id, error %lu.\n", lRes, GetLastError());
+
+    DestroyWindow(hwnd);
+
     /* Check WM_GETTEXTLENGTH A->W behaviour, whether WM_GETTEXT is also sent or not */
 
     hwnd = CreateWindowW (testWindowClassW, wszUnicode,
                           WS_OVERLAPPEDWINDOW,
                           100, 100, 200, 200, 0, 0, 0, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     flush_sequence();
     lRes = SendMessageA (hwnd, WM_GETTEXTLENGTH, 0, 0);
     ok_sequence(WmGetTextLengthAfromW, "ANSI WM_GETTEXTLENGTH to Unicode window", FALSE);
@@ -11580,10 +11625,8 @@ static DWORD WINAPI win_event_global_thread_proc(void *param)
     MSG msg;
     HANDLE hevent = *(HANDLE *)param;
 
-    assert(pNotifyWinEvent);
-
     hwnd = CreateWindowExA(0, "static", NULL, WS_POPUP, 0,0,0,0,0,0,0, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     if (winetest_debug > 1) trace("created thread window %p\n", hwnd);
 
     *(HWND *)param = hwnd;
@@ -11615,7 +11658,7 @@ static DWORD WINAPI cbt_global_hook_thread_proc(void *param)
      */
 
     hwnd = CreateWindowExA(0, "static", NULL, WS_POPUP, 0,0,0,0,0,0,0, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     if (winetest_debug > 1) trace("created thread window %p\n", hwnd);
 
     *(HWND *)param = hwnd;
@@ -11646,7 +11689,7 @@ static DWORD WINAPI mouse_ll_global_thread_proc(void *param)
     HANDLE hevent = *(HANDLE *)param;
 
     hwnd = CreateWindowExA(0, "static", NULL, WS_POPUP, 0,0,0,0,0,0,0, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     if (winetest_debug > 1) trace("created thread window %p\n", hwnd);
 
     *(HWND *)param = hwnd;
@@ -11685,7 +11728,7 @@ static void test_winevents(void)
 			   WS_OVERLAPPEDWINDOW,
 			   CW_USEDEFAULT, CW_USEDEFAULT, 300, 300, 0,
 			   NULL, NULL, 0);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
 
     /****** start of global hook test *************/
     hCBT_global_hook = SetWindowsHookExA(WH_CBT, cbt_global_hook_proc, GetModuleHandleA(0), 0);
@@ -11697,7 +11740,7 @@ static void test_winevents(void)
     }
 
     hevent = CreateEventA(NULL, 0, 0, NULL);
-    assert(hevent);
+    ok(!!hevent, "Failed to create event, error %lu.\n", GetLastError());
     hwnd2 = hevent;
 
     hthread = CreateThread(NULL, 0, cbt_global_hook_thread_proc, &hwnd2, 0, &tid);
@@ -11760,7 +11803,7 @@ static void test_winevents(void)
     ok(hhook != 0, "SetWinEventHook error %ld\n", GetLastError());
 
     hevent = CreateEventA(NULL, 0, 0, NULL);
-    assert(hevent);
+    ok(!!hevent, "Failed to create event, error %lu.\n", GetLastError());
     hwnd2 = hevent;
 
     hthread = CreateThread(NULL, 0, win_event_global_thread_proc, &hwnd2, 0, &tid);
@@ -11796,7 +11839,7 @@ static void test_winevents(void)
     ok(hhook != 0, "SetWinEventHook error %ld\n", GetLastError());
 
     hevent = CreateEventA(NULL, 0, 0, NULL);
-    assert(hevent);
+    ok(!!hevent, "Failed to create event, error %lu.\n", GetLastError());
     hwnd2 = hevent;
 
     flush_sequence();
@@ -11843,7 +11886,7 @@ static void test_winevents(void)
     }
 
     hevent = CreateEventA(NULL, 0, 0, NULL);
-    assert(hevent);
+    ok(!!hevent, "Failed to create event, error %lu.\n", GetLastError());
     hwnd2 = hevent;
 
     hthread = CreateThread(NULL, 0, mouse_ll_global_thread_proc, &hwnd2, 0, &tid);
@@ -12140,19 +12183,19 @@ static void test_DestroyWindow(void)
 
     parent = CreateWindowExA(0, "TestWindowClass", NULL, WS_OVERLAPPEDWINDOW,
 			     100, 100, 200, 200, 0, 0, 0, NULL);
-    assert(parent != 0);
+    ok(!!parent, "Failed to create window, error %lu.\n", GetLastError());
     child1 = CreateWindowExA(0, "TestWindowClass", NULL, WS_CHILD,
 			     0, 0, 50, 50, parent, (HMENU)child_id++, 0, NULL);
-    assert(child1 != 0);
+    ok(!!child1, "Failed to create window, error %lu.\n", GetLastError());
     child2 = CreateWindowExA(0, "TestWindowClass", NULL, WS_CHILD,
 			     0, 0, 50, 50, GetDesktopWindow(), (HMENU)child_id++, 0, NULL);
-    assert(child2 != 0);
+    ok(!!child2, "Failed to create window, error %lu.\n", GetLastError());
     child3 = CreateWindowExA(0, "TestWindowClass", NULL, WS_CHILD,
 			     0, 0, 50, 50, child1, (HMENU)child_id++, 0, NULL);
-    assert(child3 != 0);
+    ok(!!child3, "Failed to create window, error %lu.\n", GetLastError());
     child4 = CreateWindowExA(0, "TestWindowClass", NULL, WS_POPUP,
 			     0, 0, 50, 50, parent, 0, 0, NULL);
-    assert(child4 != 0);
+    ok(!!child4, "Failed to create window, error %lu.\n", GetLastError());
 
     /* test owner/parent of child2 */
     test = GetParent(child2);
@@ -12807,8 +12850,10 @@ static DWORD WINAPI test_edit_ime_messages(void *unused_arg)
 static void subclass_edit(void)
 {
     WNDCLASSA cls;
+    BOOL ret;
 
-    if (!GetClassInfoA(0, "edit", &cls)) assert(0);
+    ret = GetClassInfoA(0, "edit", &cls);
+    ok(ret, "Failed to get class info, error %lu.\n", GetLastError());
 
     old_edit_proc = cls.lpfnWndProc;
 
@@ -12816,7 +12861,7 @@ static void subclass_edit(void)
     cls.lpfnWndProc = edit_hook_proc;
     cls.lpszClassName = "my_edit_class";
     UnregisterClassA(cls.lpszClassName, cls.hInstance);
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 }
 
 static void test_edit_messages(void)
@@ -12982,8 +13027,7 @@ static DWORD CALLBACK send_msg_thread_2(void *param)
             break;
 
         default:
-            if (winetest_debug > 1) trace("unexpected return: %04lx\n", ret);
-            assert(0);
+            ok(0, "Unexpected return %#lx.\n", ret);
             break;
         }
     }
@@ -13002,7 +13046,7 @@ static void test_PeekMessage(void)
 
     info.hwnd = CreateWindowA("TestWindowClass", NULL, WS_OVERLAPPEDWINDOW,
                               100, 100, 200, 200, 0, 0, 0, NULL);
-    assert(info.hwnd);
+    ok(!!info.hwnd, "Failed to create window, error %lu.\n", GetLastError());
     ShowWindow(info.hwnd, SW_SHOW);
     UpdateWindow(info.hwnd);
     SetFocus(info.hwnd);
@@ -13515,7 +13559,7 @@ static void test_PeekMessage2(void)
     /* Initialise window and make sure it is ready for events */
     hwnd = CreateWindowA("TestWindowClass", "PeekMessage2", WS_OVERLAPPEDWINDOW,
                         10, 10, 800, 800, NULL, NULL, NULL, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     if (winetest_debug > 1) trace("Window for test_PeekMessage2 %p\n", hwnd);
     ShowWindow(hwnd, SW_SHOW);
     UpdateWindow(hwnd);
@@ -14039,13 +14083,13 @@ static void test_TrackMouseEvent(void)
 			  WS_OVERLAPPEDWINDOW | WS_VISIBLE,
 			  CW_USEDEFAULT, CW_USEDEFAULT, 300, 300, 0,
 			  NULL, NULL, 0);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
 
     hchild = CreateWindowExA(0, "TestWindowClass", NULL,
 			  WS_CHILD | WS_BORDER | WS_VISIBLE,
 			  50, 50, 200, 200, hwnd,
 			  NULL, NULL, 0);
-    assert(hchild);
+    ok(!!hchild, "Failed to create window, error %lu.\n", GetLastError());
 
     SetWindowPos( hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE );
     flush_events();
@@ -14709,7 +14753,7 @@ static void test_ShowWindow(void)
     hwnd = CreateWindowExA(0, "ShowWindowClass", NULL, WS_BASE,
                           120, 120, 90, 90,
                           0, 0, 0, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
 
     style = GetWindowLongA(hwnd, GWL_STYLE) & ~WS_BASE;
     ok(style == 0, "expected style 0, got %08lx\n", style);
@@ -15143,7 +15187,7 @@ static void test_dialog_messages(void)
     cls.hInstance = GetModuleHandleA(NULL);
     /* need a cast since a dlgproc is used as a wndproc */
     cls.lpfnWndProc = (WNDPROC)test_dlg_proc;
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 
     SetFocus(0);
     flush_sequence();
@@ -15183,7 +15227,7 @@ static void test_dialog_messages(void)
 
     UnregisterClassA( cls.lpszClassName, cls.hInstance );
     cls.lpfnWndProc = test_dlg_proc4;
-    ok( RegisterClassA(&cls), "failed to register class again\n" );
+    register_class(&cls);
     hdlg = CreateDialogParamA(0, "FOCUS_TEST_DIALOG_4", 0, test_dlg_proc3, 0);
     ok(IsWindow(hdlg), "CreateDialogParam failed\n");
     ok_sequence(WmCreateDialogParamSeq_4, "CreateDialogParam_4", TRUE);
@@ -15296,7 +15340,7 @@ static void test_EndDialog(void)
     cls.lpszClassName = "MyDialogClass";
     cls.hInstance = GetModuleHandleA(NULL);
     cls.lpfnWndProc = (WNDPROC)test_dlg_proc;
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 
     flush_sequence();
     SetForegroundWindow(hother);
@@ -16641,7 +16685,7 @@ static void test_menu_messages(void)
     cls.lpszMenuName = NULL;
     cls.lpszClassName = "TestMenuClass";
     UnregisterClassA(cls.lpszClassName, cls.hInstance);
-    if (!RegisterClassA(&cls)) assert(0);
+    register_class(&cls);
 
     SetLastError(0xdeadbeef);
     hwnd = CreateWindowExA(0, "TestMenuClass", NULL, WS_OVERLAPPEDWINDOW | WS_VISIBLE,
@@ -16950,7 +16994,7 @@ static void test_defwinproc(void)
 
     hwnd = CreateWindowExA(0, "TestWindowClass", "test_defwndproc",
             WS_VISIBLE | WS_CAPTION | WS_OVERLAPPEDWINDOW, 0,0,500,100,0,0,0, NULL);
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
     flush_events();
 
     buffA[0] = 0;
@@ -17112,8 +17156,7 @@ static void test_desktop_winproc(void)
     cls.hCursor = LoadCursorA(0, (LPCSTR)IDC_ARROW);
     cls.hbrBackground = GetStockObject(WHITE_BRUSH);
     cls.lpszClassName = "TestDesktopClass";
-    ret = !!RegisterClassA(&cls);
-    ok(ret, "Failed to register class.\n");
+    register_class(&cls);
 
     hwnd = CreateWindowExA(0, cls.lpszClassName, "test_desktop_wndproc",
             WS_VISIBLE | WS_CAPTION | WS_OVERLAPPEDWINDOW, 0, 0, 500, 100, 0, 0, 0, NULL);
@@ -17218,16 +17261,18 @@ static void test_clipboard_viewers(void)
         WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
         CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
         GetDesktopWindow(), NULL, hInst, NULL);
+    ok(!!hWnd1, "Failed to create window, error %lu.\n", GetLastError());
     hWnd2 = CreateWindowExA(0, "SimpleWindowClass", "Clipboard viewer test wnd 2",
         WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
         CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
         GetDesktopWindow(), NULL, hInst, NULL);
+    ok(!!hWnd2, "Failed to create window, error %lu.\n", GetLastError());
     hWnd3 = CreateWindowExA(0, "SimpleWindowClass", "Clipboard viewer test wnd 3",
         WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
         CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
         GetDesktopWindow(), NULL, hInst, NULL);
+    ok(!!hWnd3, "Failed to create window, error %lu.\n", GetLastError());
     if (winetest_debug > 1) trace("clipbd viewers: hWnd1=%p, hWnd2=%p, hWnd3=%p\n", hWnd1, hWnd2, hWnd3);
-    assert(hWnd1 && hWnd2 && hWnd3);
 
     CountClipboardFormats(); /* Ensure that we do not have an X11 update to the clipboard */
     flush_sequence();
@@ -17347,7 +17392,7 @@ static void test_PostMessage(void)
         win_skip("Skipping some PostMessage tests on Win9x/WinMe\n");
         return;
     }
-    assert(hwnd);
+    ok(!!hwnd, "Failed to create window, error %lu.\n", GetLastError());
 
     flush_events();
 
@@ -17601,7 +17646,7 @@ static void do_wait_idle_child( int arg )
     cls.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
     cls.hCursor       = LoadCursorA(0, (LPCSTR)IDC_ARROW);
     cls.lpszClassName = "TestClass";
-    RegisterClassA( &cls );
+    register_class(&cls);
 
     PeekMessageA( &msg, 0, 0, 0, PM_NOREMOVE );  /* create the msg queue */
 
@@ -17758,7 +17803,7 @@ static DWORD CALLBACK wait_idle_thread( void *arg )
     cls.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
     cls.hCursor       = LoadCursorA(0, (LPCSTR)IDC_ARROW);
     cls.lpszClassName = "TestClass";
-    RegisterClassA( &cls );
+    register_class(&cls);
 
     hwnd = CreateWindowExA(0, "TestClass", NULL, WS_POPUP, 0, 0, 10, 10, 0, 0, 0, NULL);
     while (GetMessageA( &msg, 0, 0, 0 )) DispatchMessageA( &msg );
@@ -19306,7 +19351,7 @@ static void test_InSendMessage(void)
     cls.lpfnWndProc = insendmessage_wnd_proc;
     cls.hInstance = GetModuleHandleA(NULL);
     cls.lpszClassName = "InSendMessage_test";
-    RegisterClassA(&cls);
+    register_class(&cls);
 
     win = CreateWindowA( "InSendMessage_test", NULL, 0, 0, 0, 0, 0, NULL, 0, NULL, 0 );
     ok( win != NULL, "CreateWindow failed: %ld\n", GetLastError() );
@@ -19598,7 +19643,7 @@ START_TEST(msg)
     init_procs();
     ImmDisableIME(0);
 
-    if (!RegisterWindowClasses()) assert(0);
+    register_classes();
 
     if (pSetWinEventHook)
     {
diff --git a/dlls/user32/tests/sysparams.c b/dlls/user32/tests/sysparams.c
index 5c199a07769..6ed7755b91b 100644
--- a/dlls/user32/tests/sysparams.c
+++ b/dlls/user32/tests/sysparams.c
@@ -3123,7 +3123,8 @@ static void test_EnumDisplaySettings(void)
 {
     static const DWORD mode_fields = DM_DISPLAYORIENTATION | DM_BITSPERPEL |
             DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY;
-    static const DWORD setting_fields = mode_fields | DM_POSITION;
+    static const DWORD setting_fields = DM_DISPLAYORIENTATION | DM_BITSPERPEL |
+            DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY | DM_POSITION;
     CHAR primary_adapter[CCHDEVICENAME];
     DPI_AWARENESS_CONTEXT ctx = NULL;
     DWORD err, val, device, mode;
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 1628c7ca74a..38462607ccd 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -205,7 +205,7 @@
 @ stdcall EditWndProc(long long long long) EditWndProcA
 @ stdcall EmptyClipboard() NtUserEmptyClipboard
 @ stdcall EnableMenuItem(long long long) NtUserEnableMenuItem
-@ stdcall EnableMouseInPointer(long)
+@ stdcall EnableMouseInPointer(long) NtUserEnableMouseInPointer
 @ stdcall EnableNonClientDpiScaling(long)
 @ stdcall -import EnableScrollBar(long long long) NtUserEnableScrollBar
 @ stdcall EnableWindow(long long)
@@ -475,6 +475,7 @@
 # @ stub IsHungThread
 @ stdcall IsIconic(long)
 @ stdcall IsMenu(long)
+@ stdcall IsMouseInPointerEnabled() NtUserIsMouseInPointerEnabled
 @ stdcall IsProcessDPIAware()
 @ stdcall IsRectEmpty(ptr)
 # @ stub IsServerSideWindow
diff --git a/dlls/user32/user_main.c b/dlls/user32/user_main.c
index 0ddbd710b6b..56d5849f469 100644
--- a/dlls/user32/user_main.c
+++ b/dlls/user32/user_main.c
@@ -21,7 +21,7 @@
 #include "user_private.h"
 #include "controls.h"
 #include "imm.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 #include "wine/debug.h"
 
 
diff --git a/dlls/user32/winproc.c b/dlls/user32/winproc.c
index 6cd41b51435..9fd35e1d24e 100644
--- a/dlls/user32/winproc.c
+++ b/dlls/user32/winproc.c
@@ -831,7 +831,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
             if (!check_string( str, size )) return FALSE;
             cs.lpszClass = str;
         }
-        memcpy( &ps->cs, &cs, sizeof(cs) );
+        memcpy( *buffer, &cs, sizeof(cs) );
         break;
     }
     case WM_GETTEXT:
@@ -865,7 +865,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
         dis.hDC        = unpack_handle( ps->dis.hDC );
         dis.rcItem     = ps->dis.rcItem;
         dis.itemData   = (ULONG_PTR)unpack_ptr( ps->dis.itemData );
-        memcpy( &ps->dis, &dis, sizeof(dis) );
+        memcpy( *buffer, &dis, sizeof(dis) );
         break;
     }
     case WM_MEASUREITEM:
@@ -878,7 +878,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
         mis.itemWidth  = ps->mis.itemWidth;
         mis.itemHeight = ps->mis.itemHeight;
         mis.itemData   = (ULONG_PTR)unpack_ptr( ps->mis.itemData );
-        memcpy( &ps->mis, &mis, sizeof(mis) );
+        memcpy( *buffer, &mis, sizeof(mis) );
         break;
     }
     case WM_DELETEITEM:
@@ -890,7 +890,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
         dls.itemID     = ps->dls.itemID;
         dls.hwndItem   = unpack_handle( ps->dls.hwndItem );
         dls.itemData   = (ULONG_PTR)unpack_ptr( ps->dls.itemData );
-        memcpy( &ps->dls, &dls, sizeof(dls) );
+        memcpy( *buffer, &dls, sizeof(dls) );
         break;
     }
     case WM_COMPAREITEM:
@@ -905,7 +905,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
         cis.itemID2    = ps->cis.itemID2;
         cis.itemData2  = (ULONG_PTR)unpack_ptr( ps->cis.itemData2 );
         cis.dwLocaleId = ps->cis.dwLocaleId;
-        memcpy( &ps->cis, &cis, sizeof(cis) );
+        memcpy( *buffer, &cis, sizeof(cis) );
         break;
     }
     case WM_WINDOWPOSCHANGING:
@@ -920,7 +920,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
         wp.cx              = ps->wp.cx;
         wp.cy              = ps->wp.cy;
         wp.flags           = ps->wp.flags;
-        memcpy( &ps->wp, &wp, sizeof(wp) );
+        memcpy( *buffer, &wp, sizeof(wp) );
         break;
     }
     case WM_COPYDATA:
@@ -1080,7 +1080,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
         mnm.hmenuIn   = unpack_handle( ps->mnm.hmenuIn );
         mnm.hmenuNext = unpack_handle( ps->mnm.hmenuNext );
         mnm.hwndNext  = unpack_handle( ps->mnm.hwndNext );
-        memcpy( &ps->mnm, &mnm, sizeof(mnm) );
+        memcpy( *buffer, &mnm, sizeof(mnm) );
         break;
     }
     case WM_SIZING:
@@ -1116,7 +1116,7 @@ static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lpa
             if (!check_string( str, size )) return FALSE;
             mcs.szTitle = str;
         }
-        memcpy( &ps->mcs, &mcs, sizeof(mcs) );
+        memcpy( *buffer, &mcs, sizeof(mcs) );
         break;
     }
     case WM_MDIGETACTIVE:
diff --git a/dlls/vbscript/global.c b/dlls/vbscript/global.c
index 9eac80218fd..0baab7e4420 100644
--- a/dlls/vbscript/global.c
+++ b/dlls/vbscript/global.c
@@ -1184,6 +1184,9 @@ static HRESULT Global_LBound(BuiltinDisp *This, VARIANT *arg, unsigned args_cnt,
     case VT_VARIANT|VT_ARRAY|VT_BYREF:
         sa = *V_ARRAYREF(arg);
         break;
+    case VT_EMPTY:
+    case VT_NULL:
+        return MAKE_VBSERROR(VBSE_TYPE_MISMATCH);
     default:
         FIXME("arg %s not supported\n", debugstr_variant(arg));
         return E_NOTIMPL;
@@ -1222,6 +1225,9 @@ static HRESULT Global_UBound(BuiltinDisp *This, VARIANT *arg, unsigned args_cnt,
     case VT_VARIANT|VT_ARRAY|VT_BYREF:
         sa = *V_ARRAYREF(arg);
         break;
+    case VT_EMPTY:
+    case VT_NULL:
+        return MAKE_VBSERROR(VBSE_TYPE_MISMATCH);
     default:
         FIXME("arg %s not supported\n", debugstr_variant(arg));
         return E_NOTIMPL;
@@ -2172,6 +2178,12 @@ static HRESULT Global_Second(BuiltinDisp *This, VARIANT *arg, unsigned args_cnt,
     return FAILED(hres) ? hres : return_short(res, st.wSecond);
 }
 
+static HRESULT Global_SetLocale(BuiltinDisp *This, VARIANT *args, unsigned args_cnt, VARIANT *res)
+{
+    FIXME("\n");
+    return E_NOTIMPL;
+}
+
 static HRESULT Global_DateValue(BuiltinDisp *This, VARIANT *arg, unsigned args_cnt, VARIANT *res)
 {
     FIXME("\n");
@@ -2572,12 +2584,12 @@ static HRESULT Global_Join(BuiltinDisp *This, VARIANT *arg, unsigned args_cnt, V
 
 static HRESULT Global_Split(BuiltinDisp *This, VARIANT *args, unsigned args_cnt, VARIANT *res)
 {
-    BSTR str, string, delimiter = NULL;
+    BSTR string, delimiter = NULL;
     int count, max, mode, len, start, end, ret, delimiterlen = 1;
     int i, *indices = NULL, *new_indices, indices_max = 8;
     SAFEARRAYBOUND bounds;
     SAFEARRAY *sa = NULL;
-    VARIANT *data, var;
+    VARIANT *data;
     HRESULT hres = S_OK;
 
     TRACE("%s %u...\n", debugstr_variant(args), args_cnt);
@@ -2685,19 +2697,13 @@ static HRESULT Global_Split(BuiltinDisp *This, VARIANT *args, unsigned args_cnt,
 
     start = 0;
     for (i = 0; i < count; i++) {
-        str = SysAllocStringLen(string + start, indices[i] - start);
-        if (!str) {
+        V_VT(&data[i]) = VT_BSTR;
+        V_BSTR(&data[i]) = SysAllocStringLen(string + start, indices[i] - start);
+
+        if (!V_BSTR(&data[i])) {
             hres = E_OUTOFMEMORY;
             break;
         }
-        V_VT(&var) = VT_BSTR;
-        V_BSTR(&var) = str;
-
-        hres = VariantCopyInd(data+i, &var);
-        if(FAILED(hres)) {
-            SafeArrayUnaccessData(sa);
-            goto error;
-        }
         start = indices[i]+delimiterlen;
     }
     SafeArrayUnaccessData(sa);
@@ -3048,6 +3054,12 @@ static HRESULT Global_FormatPercent(BuiltinDisp *This, VARIANT *args, unsigned a
     return return_bstr(res, str);
 }
 
+static HRESULT Global_GetLocale(BuiltinDisp *This, VARIANT *args, unsigned args_cnt, VARIANT *res)
+{
+    FIXME("\n");
+    return E_NOTIMPL;
+}
+
 static HRESULT Global_FormatDateTime(BuiltinDisp *This, VARIANT *args, unsigned args_cnt, VARIANT *res)
 {
     int format = 0;
@@ -3270,6 +3282,7 @@ static const builtin_prop_t global_props[] = {
     {L"FormatDateTime",            Global_FormatDateTime, 0, 1, 2},
     {L"FormatNumber",              Global_FormatNumber, 0, 1, 5},
     {L"FormatPercent",             Global_FormatPercent, 0, 1, 5},
+    {L"GetLocale",                 Global_GetLocale, 0, 0},
     {L"GetObject",                 Global_GetObject, 0, 0, 2},
     {L"GetRef",                    Global_GetRef, 0, 1},
     {L"Hex",                       Global_Hex, 0, 1},
@@ -3316,6 +3329,7 @@ static const builtin_prop_t global_props[] = {
     {L"ScriptEngineMajorVersion",  Global_ScriptEngineMajorVersion, 0, 0},
     {L"ScriptEngineMinorVersion",  Global_ScriptEngineMinorVersion, 0, 0},
     {L"Second",                    Global_Second, 0, 1},
+    {L"SetLocale",                 Global_SetLocale, 0, 0, 1},
     {L"Sgn",                       Global_Sgn, 0, 1},
     {L"Sin",                       Global_Sin, 0, 1},
     {L"Space",                     Global_Space, 0, 1},
diff --git a/dlls/vbscript/interp.c b/dlls/vbscript/interp.c
index b3be3bea6cf..eb1dcab5f01 100644
--- a/dlls/vbscript/interp.c
+++ b/dlls/vbscript/interp.c
@@ -1375,24 +1375,31 @@ static HRESULT interp_redim_preserve(exec_ctx_t *ctx)
     if(array == NULL || array->cDims == 0) {
         /* can initially allocate the array */
         array = SafeArrayCreate(VT_VARIANT, dim_cnt, bounds);
-        VariantClear(v);
-        V_VT(v) = VT_ARRAY|VT_VARIANT;
-        V_ARRAY(v) = array;
-        return S_OK;
+        if(!array)
+            hres = E_OUTOFMEMORY;
+	else {
+            VariantClear(v);
+            V_VT(v) = VT_ARRAY|VT_VARIANT;
+            V_ARRAY(v) = array;
+        }
     } else if(array->cDims != dim_cnt) {
         /* can't otherwise change the number of dimensions */
         TRACE("Can't resize %s, cDims %d != %d\n", debugstr_w(identifier), array->cDims, dim_cnt);
-        return MAKE_VBSERROR(VBSE_OUT_OF_BOUNDS);
+        hres = MAKE_VBSERROR(VBSE_OUT_OF_BOUNDS);
     } else {
         /* can resize the last dimensions (if others match */
         for(i = 0; i+1 < dim_cnt; ++i) {
             if(array->rgsabound[array->cDims - 1 - i].cElements != bounds[i].cElements) {
                 TRACE("Can't resize %s, bound[%d] %ld != %ld\n", debugstr_w(identifier), i, array->rgsabound[i].cElements, bounds[i].cElements);
-                return MAKE_VBSERROR(VBSE_OUT_OF_BOUNDS);
+                hres = MAKE_VBSERROR(VBSE_OUT_OF_BOUNDS);
+                break;
             }
         }
-        return SafeArrayRedim(array, &bounds[dim_cnt-1]);
+        if(SUCCEEDED(hres))
+            hres = SafeArrayRedim(array, &bounds[dim_cnt-1]);
     }
+    free(bounds);
+    return hres;
 }
 
 static HRESULT interp_step(exec_ctx_t *ctx)
@@ -1480,7 +1487,7 @@ static HRESULT interp_newenum(exec_ctx_t *ctx)
     case VT_VARIANT|VT_ARRAY|VT_BYREF: {
         IEnumVARIANT *iter;
 
-        hres = create_safearray_iter(V_ISBYREF(v.v) ? *V_ARRAYREF(v.v) : V_ARRAY(v.v), &iter);
+        hres = create_safearray_iter(V_ISBYREF(v.v) ? *V_ARRAYREF(v.v) : V_ARRAY(v.v), v.owned && !V_ISBYREF(v.v), &iter);
         if(FAILED(hres))
             return hres;
 
diff --git a/dlls/vbscript/lex.c b/dlls/vbscript/lex.c
index 38ee4a5fd4b..8c5c69ea429 100644
--- a/dlls/vbscript/lex.c
+++ b/dlls/vbscript/lex.c
@@ -473,7 +473,7 @@ static int parse_next_token(void *lval, unsigned *loc, parser_ctx_t *ctx)
     case '#':
         return parse_date_literal(ctx, lval);
     case '&':
-        if(*++ctx->ptr == 'h' || *ctx->ptr == 'H')
+        if((*++ctx->ptr == 'h' || *ctx->ptr == 'H') && hex_to_int(ctx->ptr[1]) != -1)
             return parse_hex_literal(ctx, lval);
         return '&';
     case '=':
diff --git a/dlls/vbscript/parser.y b/dlls/vbscript/parser.y
index 382504a3d5a..9ae6c478bfa 100644
--- a/dlls/vbscript/parser.y
+++ b/dlls/vbscript/parser.y
@@ -314,13 +314,12 @@ ElseIfs
     | ElseIf ElseIfs                        { $1->next = $2; $$ = $1; }
 
 ElseIf
-    : tELSEIF Expression tTHEN tNL StatementsNl_opt
+    : tELSEIF Expression tTHEN StSep_opt StatementsNl_opt
                                             { $$ = new_elseif_decl(ctx, @$, $2, $5); }
 
 Else_opt
     : /* empty */                           { $$ = NULL; }
-    | tELSE tNL StatementsNl_opt            { $$ = $3; }
-    | tELSE StatementsNl_opt                { $$ = $2; }
+    | tELSE StSep_opt StatementsNl_opt      { $$ = $3; }
 
 CaseClausules
     : /* empty */                                                      { $$ = NULL; }
diff --git a/dlls/vbscript/tests/Makefile.in b/dlls/vbscript/tests/Makefile.in
index 35379baf198..927280bef22 100644
--- a/dlls/vbscript/tests/Makefile.in
+++ b/dlls/vbscript/tests/Makefile.in
@@ -2,6 +2,7 @@ TESTDLL   = vbscript.dll
 IMPORTS   = oleaut32 ole32 advapi32
 
 C_SRCS = \
+	caller.c \
 	createobj.c \
 	run.c \
 	vbscript.c
diff --git a/dlls/vbscript/tests/api.vbs b/dlls/vbscript/tests/api.vbs
index 459d3ace33e..842cce33f83 100644
--- a/dlls/vbscript/tests/api.vbs
+++ b/dlls/vbscript/tests/api.vbs
@@ -150,7 +150,7 @@ Call ok(Chr("120") = "x", "Chr(""120"") = " & Chr("120"))
 sub testChrError
     on error resume next
 
-    if isEnglishLang then
+    if MaxCharSize = 1 then
         call Err.clear()
         call Chr(-1)
         call ok(Err.number = 5, "Err.number = " & Err.number)
@@ -159,6 +159,13 @@ sub testChrError
         call Err.clear()
         call Chr(256)
         call ok(Err.number = 5, "Err.number = " & Err.number)
+    else
+        call Err.clear()
+        call Chr(-1)
+        call ok(Err.number = 0, "Err.number = " & Err.number)
+        call Err.clear()
+        call Chr(256)
+        call ok(Err.number = 0, "Err.number = " & Err.number)
     end if
 
     call Err.clear()
@@ -285,17 +292,43 @@ Call ok(Lbound(arr2) = 0, "Lbound(x) = " & Lbound(x))
 Call ok(Lbound(arr2, 1) = 0, "Lbound(x) = " & Lbound(x))
 Call ok(Lbound(arr2, 2) = 0, "Lbound(x) = " & Lbound(x))
 
+sub testLBoundError()
+    on error resume next
+    call Err.clear()
+    call LBound()
+    call ok(Err.number = 450, "Err.number = " & Err.number)
+    call Err.clear()
+    call LBound(Empty)
+    call ok(Err.number = 13, "Err.number = " & Err.number)
+    call Err.clear()
+    call LBound(Null)
+    call ok(Err.number = 13, "Err.number = " & Err.number)
+    call Err.clear()
+    call LBound(arr, 1, 2)
+    call ok(Err.number = 450, "Err.number = " & Err.number)
+    if isEnglishLang then call ok(Err.description = "Wrong number of arguments or invalid property assignment", _
+                                  "Err.description = " & Err.description)
+end sub
+
 sub testUBoundError()
     on error resume next
     call Err.clear()
     call UBound()
     call ok(Err.number = 450, "Err.number = " & Err.number)
     call Err.clear()
+    call UBound(Empty)
+    call ok(Err.number = 13, "Err.number = " & Err.number)
+    call Err.clear()
+    call UBound(Null)
+    call ok(Err.number = 13, "Err.number = " & Err.number)
+    call Err.clear()
     call UBound(arr, 1, 2)
     call ok(Err.number = 450, "Err.number = " & Err.number)
     if isEnglishLang then call ok(Err.description = "Wrong number of arguments or invalid property assignment", _
                                   "Err.description = " & Err.description)
 end sub
+
+call testLBoundError()
 call testUBoundError()
 
 Dim newObject
@@ -1639,6 +1672,7 @@ Call ok(Abs(True) = 1, "Abs(True) = " & Abs(True))
 Call ok(getVT(Abs(True)) = "VT_I2", "getVT(Abs(True)) = " & getVT(Abs(True)))
 Call ok(Abs(CByte(1)) = 1, "Abs(CByte(1)) = " & Abs(CByte(1)))
 Call ok(getVT(Abs(CByte(1))) = "VT_UI1", "getVT(Abs(CByte(1))) = " & getVT(Abs(CByte(1))))
+Call ok(Abs("30000") = 30000, "Abs(""30000"") = " & Abs("30000"))
 
 Sub testAbsError(strings, error_num1, error_num2)
     on error resume next
diff --git a/dlls/vbscript/tests/caller.c b/dlls/vbscript/tests/caller.c
new file mode 100644
index 00000000000..19eccfe715d
--- /dev/null
+++ b/dlls/vbscript/tests/caller.c
@@ -0,0 +1,551 @@
+/*
+ * Copyright 2023 Gabriel Ivăncescu for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdio.h>
+
+#define COBJMACROS
+#define CONST_VTABLE
+
+#include <ole2.h>
+#include <dispex.h>
+#include <activscp.h>
+#include <objsafe.h>
+
+#include "wine/test.h"
+
+#ifdef _WIN64
+
+#define IActiveScriptParse_QueryInterface IActiveScriptParse64_QueryInterface
+#define IActiveScriptParse_Release IActiveScriptParse64_Release
+#define IActiveScriptParse_InitNew IActiveScriptParse64_InitNew
+#define IActiveScriptParse_ParseScriptText IActiveScriptParse64_ParseScriptText
+
+#else
+
+#define IActiveScriptParse_QueryInterface IActiveScriptParse32_QueryInterface
+#define IActiveScriptParse_Release IActiveScriptParse32_Release
+#define IActiveScriptParse_InitNew IActiveScriptParse32_InitNew
+#define IActiveScriptParse_ParseScriptText IActiveScriptParse32_ParseScriptText
+
+#endif
+
+extern const CLSID CLSID_VBScript;
+
+#define DEFINE_EXPECT(func) \
+    static BOOL expect_ ## func = FALSE, called_ ## func = FALSE
+
+#define SET_EXPECT(func) \
+    expect_ ## func = TRUE
+
+#define CHECK_EXPECT2(func) \
+    do { \
+        ok(expect_ ##func, "unexpected call " #func "\n"); \
+        called_ ## func = TRUE; \
+    }while(0)
+
+#define CHECK_EXPECT(func) \
+    do { \
+        CHECK_EXPECT2(func); \
+        expect_ ## func = FALSE; \
+    }while(0)
+
+#define CHECK_CALLED(func) \
+    do { \
+        ok(called_ ## func, "expected " #func "\n"); \
+        expect_ ## func = called_ ## func = FALSE; \
+    }while(0)
+
+#define CLEAR_CALLED(func) \
+    expect_ ## func = called_ ## func = FALSE
+
+DEFINE_EXPECT(sp_caller_QI_NULL);
+DEFINE_EXPECT(testGetCaller);
+DEFINE_EXPECT(testGetCallerVBS);
+DEFINE_EXPECT(testGetCallerNested);
+DEFINE_EXPECT(OnEnterScript);
+DEFINE_EXPECT(OnLeaveScript);
+
+static IActiveScript *active_script;
+static IServiceProvider *test_get_caller_sp;
+
+#define DISPID_TEST_TESTGETCALLER    0x1000
+#define DISPID_TEST_TESTGETCALLERVBS 0x1001
+#define DISPID_TEST_TESTGETCALLERNESTED 0x1002
+
+#define parse_script(a,s) _parse_script(__LINE__,a,s)
+static void _parse_script(unsigned line, IActiveScript *active_script, const WCHAR *script)
+{
+    IActiveScriptParse *parser;
+    HRESULT hres;
+
+    hres = IActiveScript_QueryInterface(active_script, &IID_IActiveScriptParse, (void**)&parser);
+    ok_(__FILE__,line)(hres == S_OK, "Could not get IActiveScriptParse: %08lx\n", hres);
+
+    hres = IActiveScriptParse_ParseScriptText(parser, script, NULL, NULL, NULL, 0, 0, 0, NULL, NULL);
+    ok_(__FILE__,line)(hres == S_OK, "ParseScriptText failed: %08lx\n", hres);
+    IActiveScriptParse_Release(parser);
+}
+
+static IServiceProvider sp_caller_obj;
+
+static HRESULT WINAPI sp_caller_QueryInterface(IServiceProvider *iface, REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IServiceProvider, riid))
+        *ppv = &sp_caller_obj;
+    else {
+        ok(IsEqualGUID(&IID_NULL, riid), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+        CHECK_EXPECT(sp_caller_QI_NULL);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    return S_OK;
+}
+
+static ULONG WINAPI sp_caller_AddRef(IServiceProvider *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI sp_caller_Release(IServiceProvider *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI sp_caller_QueryService(IServiceProvider *iface, REFGUID guidService,
+        REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(guidService, &SID_GetCaller)) {
+        ok(IsEqualGUID(riid, &IID_IServiceProvider), "unexpected riid %s\n", wine_dbgstr_guid(riid));
+        *ppv = NULL;
+        return S_OK;
+    }
+
+    ok(0, "unexpected guidService %s with riid %s\n", wine_dbgstr_guid(guidService), wine_dbgstr_guid(riid));
+    *ppv = NULL;
+    return E_NOINTERFACE;
+}
+
+static const IServiceProviderVtbl sp_caller_vtbl = {
+    sp_caller_QueryInterface,
+    sp_caller_AddRef,
+    sp_caller_Release,
+    sp_caller_QueryService
+};
+
+static IServiceProvider sp_caller_obj = { &sp_caller_vtbl };
+
+static HRESULT WINAPI DispatchEx_QueryInterface(IDispatchEx *iface, REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(riid, &IID_IUnknown)) {
+        *ppv = iface;
+    }else if(IsEqualGUID(riid, &IID_IDispatch) || IsEqualGUID(riid, &IID_IDispatchEx)) {
+        *ppv = iface;
+    }else if(IsEqualGUID(&IID_IObjectSafety, riid)) {
+        ok(0, "Unexpected IID_IObjectSafety query\n");
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    return S_OK;
+}
+
+static ULONG WINAPI DispatchEx_AddRef(IDispatchEx *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI DispatchEx_Release(IDispatchEx *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI DispatchEx_GetTypeInfoCount(IDispatchEx *iface, UINT *pctinfo)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetTypeInfo(IDispatchEx *iface, UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetIDsOfNames(IDispatchEx *iface, REFIID riid, LPOLESTR *rgszNames,
+        UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_Invoke(IDispatchEx *iface, DISPID dispIdMember, REFIID riid, LCID lcid,
+        WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR bstrName, DWORD grfdex)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_DeleteMemberByDispID(IDispatchEx *iface, DISPID id)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetMemberProperties(IDispatchEx *iface, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetMemberName(IDispatchEx *iface, DISPID id, BSTR *pbstrName)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetNextDispID(IDispatchEx *iface, DWORD grfdex, DISPID id, DISPID *pid)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DispatchEx_GetNameSpaceParent(IDispatchEx *iface, IUnknown **ppunk)
+{
+    ok(0, "unexpected call\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Test_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD grfdex, DISPID *pid)
+{
+    if(!lstrcmpW(bstrName, L"testGetCaller")) {
+        ok(grfdex == fdexNameCaseInsensitive, "grfdex = %lx\n", grfdex);
+        *pid = DISPID_TEST_TESTGETCALLER;
+        return S_OK;
+    }
+    if(!lstrcmpW(bstrName, L"testGetCallerVBS")) {
+        ok(grfdex == fdexNameCaseInsensitive, "grfdex = %lx\n", grfdex);
+        *pid = DISPID_TEST_TESTGETCALLERVBS;
+        return S_OK;
+    }
+    if(!lstrcmpW(bstrName, L"testGetCallerNested")) {
+        ok(grfdex == fdexNameCaseInsensitive, "grfdex = %lx\n", grfdex);
+        *pid = DISPID_TEST_TESTGETCALLERNESTED;
+        return S_OK;
+    }
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Test_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
+        VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
+{
+    IServiceProvider *caller = (void*)0xdeadbeef;
+    HRESULT hres;
+
+    ok(pspCaller != NULL, "pspCaller == NULL\n");
+
+    switch(id) {
+    case DISPID_TEST_TESTGETCALLER: {
+        void *iface = (void*)0xdeadbeef;
+
+        CHECK_EXPECT(testGetCaller);
+        CHECK_CALLED(OnEnterScript);
+
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %x\n", wFlags);
+        ok(pdp != NULL, "pdp == NULL\n");
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pvarRes, "pvarRes != NULL\n");
+        ok(pei != NULL, "pei == NULL\n");
+
+        SET_EXPECT(OnEnterScript);
+        SET_EXPECT(OnLeaveScript);
+        SET_EXPECT(testGetCallerNested);
+        parse_script(active_script, L"Call testGetCallerNested(1,2)");
+        CHECK_CALLED(testGetCallerNested);
+        CHECK_CALLED(OnLeaveScript);
+        CHECK_CALLED(OnEnterScript);
+        SET_EXPECT(OnLeaveScript);
+
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_IServiceProvider, (void**)&caller);
+        ok(hres == S_OK, "Could not get SID_GetCaller service: %08lx\n", hres);
+        ok(caller == test_get_caller_sp, "caller != test_get_caller_sp\n");
+        if(caller) IServiceProvider_Release(caller);
+
+        if(test_get_caller_sp)
+            SET_EXPECT(sp_caller_QI_NULL);
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_NULL, &iface);
+        ok(hres == (test_get_caller_sp ? E_NOINTERFACE : S_OK), "Could not query SID_GetCaller with IID_NULL: %08lx\n", hres);
+        ok(iface == NULL, "iface != NULL\n");
+        if(test_get_caller_sp)
+            CHECK_CALLED(sp_caller_QI_NULL);
+        break;
+    }
+
+    case DISPID_TEST_TESTGETCALLERVBS:
+        CHECK_EXPECT(testGetCallerVBS);
+
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %x\n", wFlags);
+        ok(pdp != NULL, "pdp == NULL\n");
+        ok(pdp->cArgs == 1, "cArgs = %d\n", pdp->cArgs);
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pvarRes, "pvarRes != NULL\n");
+        ok(pei != NULL, "pei == NULL\n");
+        ok(V_VT(pdp->rgvarg) == VT_I2, "V_VT(rgvarg) = %d\n", V_VT(pdp->rgvarg));
+        ok(V_I2(pdp->rgvarg) == 42, "V_I2(rgvarg) = %d\n", V_I2(pdp->rgvarg));
+
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_IServiceProvider, (void**)&caller);
+        ok(hres == E_NOINTERFACE, "QueryService(SID_GetCaller) returned: %08lx\n", hres);
+        ok(caller == NULL, "caller != NULL\n");
+        break;
+
+    case DISPID_TEST_TESTGETCALLERNESTED:
+        CHECK_EXPECT(testGetCallerNested);
+
+        ok(wFlags == DISPATCH_METHOD, "wFlags = %x\n", wFlags);
+        ok(pdp != NULL, "pdp == NULL\n");
+        ok(pdp->cArgs == 2, "cArgs = %d\n", pdp->cArgs);
+        ok(!pdp->rgdispidNamedArgs, "rgdispidNamedArgs != NULL\n");
+        ok(!pvarRes, "pvarRes != NULL\n");
+        ok(pei != NULL, "pei == NULL\n");
+        ok(V_VT(&pdp->rgvarg[0]) == VT_I2, "V_VT(rgvarg[0]) = %d\n", V_VT(&pdp->rgvarg[0]));
+        ok(V_VT(&pdp->rgvarg[1]) == VT_I2, "V_VT(rgvarg[1]) = %d\n", V_VT(&pdp->rgvarg[1]));
+        ok(V_I2(&pdp->rgvarg[0]) == 2, "V_I2(rgvarg[0]) = %d\n", V_I2(&pdp->rgvarg[0]));
+        ok(V_I2(&pdp->rgvarg[1]) == 1, "V_I2(rgvarg[1]) = %d\n", V_I2(&pdp->rgvarg[1]));
+
+        hres = IServiceProvider_QueryService(pspCaller, &SID_GetCaller, &IID_IServiceProvider, (void**)&caller);
+        ok(hres == E_NOINTERFACE, "QueryService(SID_GetCaller) returned: %08lx\n", hres);
+        ok(caller == NULL, "caller != NULL\n");
+        break;
+
+    default:
+        ok(0, "unexpected call\n");
+        return E_NOTIMPL;
+    }
+
+    return S_OK;
+}
+
+static IDispatchExVtbl testObjVtbl = {
+    DispatchEx_QueryInterface,
+    DispatchEx_AddRef,
+    DispatchEx_Release,
+    DispatchEx_GetTypeInfoCount,
+    DispatchEx_GetTypeInfo,
+    DispatchEx_GetIDsOfNames,
+    DispatchEx_Invoke,
+    Test_GetDispID,
+    Test_InvokeEx,
+    DispatchEx_DeleteMemberByName,
+    DispatchEx_DeleteMemberByDispID,
+    DispatchEx_GetMemberProperties,
+    DispatchEx_GetMemberName,
+    DispatchEx_GetNextDispID,
+    DispatchEx_GetNameSpaceParent
+};
+
+static IDispatchEx testObj = { &testObjVtbl };
+
+static HRESULT WINAPI ActiveScriptSite_QueryInterface(IActiveScriptSite *iface, REFIID riid, void **ppv)
+{
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        *ppv = iface;
+    }else if(IsEqualGUID(&IID_IActiveScriptSite, riid)) {
+        *ppv = iface;
+    }else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI ActiveScriptSite_AddRef(IActiveScriptSite *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI ActiveScriptSite_Release(IActiveScriptSite *iface)
+{
+    return 1;
+}
+
+static HRESULT WINAPI ActiveScriptSite_GetLCID(IActiveScriptSite *iface, LCID *plcid)
+{
+    *plcid = GetUserDefaultLCID();
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScriptSite_GetItemInfo(IActiveScriptSite *iface, LPCOLESTR pstrName,
+        DWORD dwReturnMask, IUnknown **ppiunkItem, ITypeInfo **ppti)
+{
+    ok(dwReturnMask == SCRIPTINFO_IUNKNOWN, "unexpected dwReturnMask %lx\n", dwReturnMask);
+    ok(!ppti, "ppti != NULL\n");
+    ok(!lstrcmpW(pstrName, L"test"), "pstrName = %s\n", wine_dbgstr_w(pstrName));
+
+    *ppiunkItem = (IUnknown*)&testObj;
+    return S_OK;
+}
+
+static HRESULT WINAPI ActiveScriptSite_GetDocVersionString(IActiveScriptSite *iface, BSTR *pbstrVersion)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ActiveScriptSite_OnScriptTerminate(IActiveScriptSite *iface,
+        const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ActiveScriptSite_OnStateChange(IActiveScriptSite *iface, SCRIPTSTATE ssScriptState)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ActiveScriptSite_OnScriptError(IActiveScriptSite *iface, IActiveScriptError *pscripterror)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ActiveScriptSite_OnEnterScript(IActiveScriptSite *iface)
+{
+    CHECK_EXPECT(OnEnterScript);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ActiveScriptSite_OnLeaveScript(IActiveScriptSite *iface)
+{
+    CHECK_EXPECT(OnLeaveScript);
+    return E_NOTIMPL;
+}
+
+static const IActiveScriptSiteVtbl ActiveScriptSiteVtbl = {
+    ActiveScriptSite_QueryInterface,
+    ActiveScriptSite_AddRef,
+    ActiveScriptSite_Release,
+    ActiveScriptSite_GetLCID,
+    ActiveScriptSite_GetItemInfo,
+    ActiveScriptSite_GetDocVersionString,
+    ActiveScriptSite_OnScriptTerminate,
+    ActiveScriptSite_OnStateChange,
+    ActiveScriptSite_OnScriptError,
+    ActiveScriptSite_OnEnterScript,
+    ActiveScriptSite_OnLeaveScript
+};
+
+static IActiveScriptSite ActiveScriptSite = { &ActiveScriptSiteVtbl };
+
+static IActiveScript *create_script(void)
+{
+    IActiveScriptParse *parser;
+    IActiveScript *script;
+    HRESULT hres;
+
+    hres = CoCreateInstance(&CLSID_VBScript, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
+            &IID_IActiveScript, (void**)&script);
+    if(FAILED(hres))
+        return NULL;
+
+    hres = IActiveScript_QueryInterface(script, &IID_IActiveScriptParse, (void**)&parser);
+    ok(hres == S_OK, "Could not get IActiveScriptParse: %08lx\n", hres);
+
+    hres = IActiveScriptParse_InitNew(parser);
+    ok(hres == S_OK, "InitNew failed: %08lx\n", hres);
+    IActiveScriptParse_Release(parser);
+
+    hres = IActiveScript_SetScriptSite(script, &ActiveScriptSite);
+    ok(hres == S_OK, "SetScriptSite failed: %08lx\n", hres);
+
+    hres = IActiveScript_AddNamedItem(script, L"test",
+            SCRIPTITEM_ISVISIBLE|SCRIPTITEM_ISSOURCE|SCRIPTITEM_GLOBALMEMBERS);
+    ok(hres == S_OK, "AddNamedItem failed: %08lx\n", hres);
+
+    hres = IActiveScript_SetScriptState(script, SCRIPTSTATE_STARTED);
+    ok(hres == S_OK, "SetScriptState(SCRIPTSTATE_STARTED) failed: %08lx\n", hres);
+
+    return script;
+}
+
+static void run_scripts(void)
+{
+    DISPPARAMS dp = { 0 };
+    IDispatchEx *dispex;
+    IDispatch *disp;
+    DISPID dispid;
+    HRESULT hres;
+    BSTR bstr;
+
+    active_script = create_script();
+
+    SET_EXPECT(OnEnterScript);
+    SET_EXPECT(OnLeaveScript);
+    SET_EXPECT(testGetCallerVBS);
+    parse_script(active_script,
+                 L"Sub testGetCallerFunc\nCall testGetCaller\nEnd Sub\n"
+                 L"Call testGetCallerVBS(42)");
+    CHECK_CALLED(testGetCallerVBS);
+    CHECK_CALLED(OnLeaveScript);
+    CHECK_CALLED(OnEnterScript);
+
+    hres = IActiveScript_GetScriptDispatch(active_script, NULL, &disp);
+    ok(hres == S_OK, "GetScriptDispatch failed: %08lx\n", hres);
+    hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
+    ok(hres == S_OK, "Could not get IDispatchEx: %08lx\n", hres);
+    IDispatch_Release(disp);
+    bstr = SysAllocString(L"testGetCallerFunc");
+    hres = IDispatchEx_GetDispID(dispex, bstr, 0, &dispid);
+    ok(hres == S_OK, "GetDispID failed: %08lx\n", hres);
+    SysFreeString(bstr);
+
+    SET_EXPECT(OnEnterScript);
+    SET_EXPECT(OnLeaveScript);
+    SET_EXPECT(testGetCaller);
+    hres = IDispatchEx_InvokeEx(dispex, dispid, 0, DISPATCH_METHOD, &dp, NULL, NULL, NULL);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    CHECK_CALLED(testGetCaller);
+    CHECK_CALLED(OnLeaveScript);
+    test_get_caller_sp = &sp_caller_obj;
+    SET_EXPECT(OnEnterScript);
+    SET_EXPECT(OnLeaveScript);
+    SET_EXPECT(testGetCaller);
+    hres = IDispatchEx_InvokeEx(dispex, dispid, 0, DISPATCH_METHOD, &dp, NULL, NULL, test_get_caller_sp);
+    ok(hres == S_OK, "InvokeEx failed: %08lx\n", hres);
+    CHECK_CALLED(testGetCaller);
+    CHECK_CALLED(OnLeaveScript);
+    IDispatchEx_Release(dispex);
+
+    IActiveScript_Release(active_script);
+    active_script = NULL;
+}
+
+START_TEST(caller)
+{
+    CoInitialize(NULL);
+
+    run_scripts();
+
+    CoUninitialize();
+}
diff --git a/dlls/vbscript/tests/lang.vbs b/dlls/vbscript/tests/lang.vbs
index 3a67cd09dff..77e132133b0 100644
--- a/dlls/vbscript/tests/lang.vbs
+++ b/dlls/vbscript/tests/lang.vbs
@@ -18,7 +18,7 @@
 
 OPTION EXPLICIT  : : DIM W
 
-dim x, y, z, e
+dim x, y, z, e, hi
 Dim obj
 
 call ok(true, "true is not true?")
@@ -62,6 +62,11 @@ Call ok(&hfffe& = 65534, "&hfffe& <> -2")
 Call ok(&hffffffff& = -1, "&hffffffff& <> -1")
 Call ok((&h01or&h02)=3,"&h01or&h02 <> 3")
 
+' Test concat when no space and var begins with h
+hi = "y"
+x = "x" &hi
+Call ok(x = "xy", "x = " & x & " expected ""xy""")
+
 W = 5
 Call ok(W = 5, "W = " & W & " expected " & 5)
 
@@ -298,6 +303,15 @@ Else x = true
 End If
 Call ok(x, "else not called?")
 
+' Else with colon before statement following newline
+x = false
+If false Then
+   Call ok(false, "inside if false")
+Else
+: x = true
+End If
+Call ok(x, "else not called?")
+
 x = false
 If false Then
    Call ok(false, "inside if false")
@@ -328,6 +342,23 @@ ElseIf not False Then
 End If
 Call ok(x, "elseif not called?")
 
+' ElseIf with statement on same line
+x = false
+If false Then
+   Call ok(false, "inside if false")
+ElseIf not False Then x = true
+End If
+Call ok(x, "elseif not called?")
+
+' ElseIf with statement following statement separator
+x = false
+If false Then
+   Call ok(false, "inside if false")
+ElseIf not False Then
+: x = true
+End If
+Call ok(x, "elseif not called?")
+
 x = false
 if 1 then x = true
 Call ok(x, "if 1 not run?")
diff --git a/dlls/vbscript/tests/run.c b/dlls/vbscript/tests/run.c
index 022d714dea5..294b635ea41 100644
--- a/dlls/vbscript/tests/run.c
+++ b/dlls/vbscript/tests/run.c
@@ -147,6 +147,7 @@ DEFINE_EXPECT(OnLeaveScript);
 #define DISPID_GLOBAL_UNKOBJ          1026
 #define DISPID_GLOBAL_THROWEXCEPTION  1027
 #define DISPID_GLOBAL_ISARRAYFIXED    1028
+#define DISPID_GLOBAL_MAXCHARSIZE     1029
 
 #define DISPID_TESTOBJ_PROPGET      2000
 #define DISPID_TESTOBJ_PROPPUT      2001
@@ -158,6 +159,7 @@ DEFINE_EXPECT(OnLeaveScript);
 #define MAKE_VBSERROR(code) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_VBS, code)
 
 static BOOL strict_dispid_check, is_english, allow_ui;
+static UINT MaxCharSize;
 static int first_day_of_week;
 static const char *test_name = "(null)";
 static int test_counter;
@@ -229,6 +231,7 @@ static const char *vt2a(VARIANT *v)
  */
 static void detect_locale(void)
 {
+    CPINFOEXA cpinfo;
     HMODULE kernel32 = GetModuleHandleA("kernel32.dll");
     LANGID (WINAPI *pGetThreadUILanguage)(void) = (void*)GetProcAddress(kernel32, "GetThreadUILanguage");
 
@@ -236,6 +239,9 @@ static void detect_locale(void)
                   PRIMARYLANGID(GetUserDefaultUILanguage()) == LANG_ENGLISH &&
                   PRIMARYLANGID(GetUserDefaultLangID()) == LANG_ENGLISH);
 
+    GetCPInfoExA( CP_THREAD_ACP, 0, &cpinfo );
+    MaxCharSize = cpinfo.MaxCharSize;
+
     GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_IFIRSTDAYOFWEEK | LOCALE_RETURN_NUMBER,
                    (void*)&first_day_of_week, sizeof(first_day_of_week));
     first_day_of_week = 1 + (first_day_of_week + 1) % 7;
@@ -1142,6 +1148,7 @@ static HRESULT WINAPI Global_GetDispID(IDispatchEx *iface, BSTR bstrName, DWORD
         { L"reportSuccess",   DISPID_GLOBAL_REPORTSUCCESS, REF_EXPECT(global_success_d) },
         { L"getVT",           DISPID_GLOBAL_GETVT },
         { L"isEnglishLang",   DISPID_GLOBAL_ISENGLANG },
+        { L"MaxCharSize",     DISPID_GLOBAL_MAXCHARSIZE },
         { L"firstDayOfWeek",  DISPID_GLOBAL_WEEKSTARTDAY },
         { L"globalCallback",  DISPID_GLOBAL_GLOBALCALLBACK },
         { L"testObj",         DISPID_GLOBAL_TESTOBJ },
@@ -1264,6 +1271,11 @@ static HRESULT WINAPI Global_InvokeEx(IDispatchEx *iface, DISPID id, LCID lcid,
         V_BOOL(pvarRes) = is_english ? VARIANT_TRUE : VARIANT_FALSE;
         return S_OK;
 
+    case DISPID_GLOBAL_MAXCHARSIZE:
+        V_VT(pvarRes) = VT_I4;
+        V_I4(pvarRes) = MaxCharSize;
+        return S_OK;
+
     case DISPID_GLOBAL_WEEKSTARTDAY:
         V_VT(pvarRes) = VT_I4;
         V_I4(pvarRes) = first_day_of_week;
diff --git a/dlls/vbscript/utils.c b/dlls/vbscript/utils.c
index 03b1abde481..4bfc2c65a0a 100644
--- a/dlls/vbscript/utils.c
+++ b/dlls/vbscript/utils.c
@@ -28,6 +28,7 @@ typedef struct {
     LONG ref;
 
     SAFEARRAY *sa;
+    BOOL owned;
     ULONG i, size;
 } safearray_iter;
 
@@ -75,8 +76,11 @@ static ULONG WINAPI safearray_iter_IEnumVARIANT_Release(IEnumVARIANT *iface)
     TRACE("(%p) ref=%ld\n", iface, ref);
 
     if(!ref) {
-        if(This->sa)
+        if(This->sa) {
             SafeArrayUnlock(This->sa);
+            if(This->owned)
+                SafeArrayDestroy(This->sa);
+	}
         free(This);
     }
 
@@ -160,7 +164,7 @@ static ULONG get_safearray_size(SAFEARRAY *sa)
     return ret;
 }
 
-HRESULT create_safearray_iter(SAFEARRAY *sa, IEnumVARIANT **ev)
+HRESULT create_safearray_iter(SAFEARRAY *sa, BOOL owned, IEnumVARIANT **ev)
 {
     safearray_iter *iter;
     HRESULT hres;
@@ -185,6 +189,7 @@ HRESULT create_safearray_iter(SAFEARRAY *sa, IEnumVARIANT **ev)
     iter->IEnumVARIANT_iface.lpVtbl = &safearray_iter_EnumVARIANTVtbl;
     iter->ref = 1;
     iter->sa = sa;
+    iter->owned = owned;
     iter->i = 0;
     iter->size = get_safearray_size(sa);
 
diff --git a/dlls/vbscript/vbdisp.c b/dlls/vbscript/vbdisp.c
index e19ed2b53d4..0ede0cfd6ba 100644
--- a/dlls/vbscript/vbdisp.c
+++ b/dlls/vbscript/vbdisp.c
@@ -413,6 +413,8 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
         VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
 {
     vbdisp_t *This = impl_from_IDispatchEx(iface);
+    IServiceProvider *prev_caller;
+    HRESULT hres;
 
     TRACE("(%p)->(%lx %lx %x %p %p %p %p)\n", This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
 
@@ -422,7 +424,17 @@ static HRESULT WINAPI DispatchEx_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
     if(pvarRes)
         V_VT(pvarRes) = VT_EMPTY;
 
-    return invoke_vbdisp(This, id, wFlags, TRUE, pdp, pvarRes);
+    prev_caller = This->desc->ctx->vbcaller->caller;
+    This->desc->ctx->vbcaller->caller = pspCaller;
+    if(pspCaller)
+        IServiceProvider_AddRef(pspCaller);
+
+    hres = invoke_vbdisp(This, id, wFlags, TRUE, pdp, pvarRes);
+
+    This->desc->ctx->vbcaller->caller = prev_caller;
+    if(pspCaller)
+        IServiceProvider_Release(pspCaller);
+    return hres;
 }
 
 static HRESULT WINAPI DispatchEx_DeleteMemberByName(IDispatchEx *iface, BSTR bstrName, DWORD grfdex)
@@ -1414,6 +1426,7 @@ static HRESULT WINAPI ScriptDisp_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
         VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
 {
     ScriptDisp *This = ScriptDisp_from_IDispatchEx(iface);
+    IServiceProvider *prev_caller;
     HRESULT hres;
 
     TRACE("(%p)->(%lx %lx %x %p %p %p %p)\n", This, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
@@ -1421,11 +1434,18 @@ static HRESULT WINAPI ScriptDisp_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
     if (!This->ctx)
         return E_UNEXPECTED;
 
+    prev_caller = This->ctx->vbcaller->caller;
+    This->ctx->vbcaller->caller = pspCaller;
+    if(pspCaller)
+        IServiceProvider_AddRef(pspCaller);
+
     if (id & DISPID_FUNCTION_MASK)
     {
         id &= ~DISPID_FUNCTION_MASK;
-        if (id > This->global_funcs_cnt)
-            return DISP_E_MEMBERNOTFOUND;
+        if (id > This->global_funcs_cnt) {
+            hres = DISP_E_MEMBERNOTFOUND;
+            goto done;
+        }
 
         switch (wFlags)
         {
@@ -1438,19 +1458,28 @@ static HRESULT WINAPI ScriptDisp_InvokeEx(IDispatchEx *iface, DISPID id, LCID lc
             hres = E_NOTIMPL;
         }
 
-        return hres;
+        goto done;
     }
 
-    if (id > This->global_vars_cnt)
-        return DISP_E_MEMBERNOTFOUND;
+    if (id > This->global_vars_cnt) {
+        hres = DISP_E_MEMBERNOTFOUND;
+        goto done;
+    }
 
     if (This->global_vars[id - 1]->is_const)
     {
         FIXME("const not supported\n");
-        return E_NOTIMPL;
+        hres = E_NOTIMPL;
+        goto done;
     }
 
-    return invoke_variant_prop(This->ctx, &This->global_vars[id - 1]->v, wFlags, pdp, pvarRes);
+    hres = invoke_variant_prop(This->ctx, &This->global_vars[id - 1]->v, wFlags, pdp, pvarRes);
+
+done:
+    This->ctx->vbcaller->caller = prev_caller;
+    if(pspCaller)
+        IServiceProvider_Release(pspCaller);
+    return hres;
 }
 
 static HRESULT WINAPI ScriptDisp_DeleteMemberByName(IDispatchEx *iface, BSTR bstrName, DWORD grfdex)
@@ -1661,7 +1690,7 @@ HRESULT disp_call(script_ctx_t *ctx, IDispatch *disp, DISPID id, DISPPARAMS *dp,
 
     hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
     if(SUCCEEDED(hres)) {
-        hres = IDispatchEx_InvokeEx(dispex, id, ctx->lcid, flags, dp, retv, &ei, NULL /* CALLER_FIXME */);
+        hres = IDispatchEx_InvokeEx(dispex, id, ctx->lcid, flags, dp, retv, &ei, &ctx->vbcaller->IServiceProvider_iface);
         IDispatchEx_Release(dispex);
     }else {
         UINT err = 0;
@@ -1699,7 +1728,7 @@ HRESULT disp_propput(script_ctx_t *ctx, IDispatch *disp, DISPID id, WORD flags,
 
     hres = IDispatch_QueryInterface(disp, &IID_IDispatchEx, (void**)&dispex);
     if(SUCCEEDED(hres)) {
-        hres = IDispatchEx_InvokeEx(dispex, id, ctx->lcid, flags, dp, NULL, &ei, NULL /* FIXME! */);
+        hres = IDispatchEx_InvokeEx(dispex, id, ctx->lcid, flags, dp, NULL, &ei, &ctx->vbcaller->IServiceProvider_iface);
         IDispatchEx_Release(dispex);
     }else {
         UINT err = 0;
diff --git a/dlls/vbscript/vbscript.c b/dlls/vbscript/vbscript.c
index b6364410931..39a5e3b1648 100644
--- a/dlls/vbscript/vbscript.c
+++ b/dlls/vbscript/vbscript.c
@@ -96,6 +96,7 @@ static HRESULT exec_global_code(script_ctx_t *ctx, vbscode_t *code, VARIANT *res
     ScriptDisp *obj = ctx->script_obj;
     function_t *func_iter, **new_funcs;
     dynamic_var_t *var, **new_vars;
+    IServiceProvider *prev_caller;
     size_t cnt, i;
     HRESULT hres;
 
@@ -185,7 +186,12 @@ static HRESULT exec_global_code(script_ctx_t *ctx, vbscode_t *code, VARIANT *res
     }
 
     code->pending_exec = FALSE;
-    return exec_script(ctx, TRUE, &code->main_code, NULL, NULL, res);
+
+    prev_caller = ctx->vbcaller->caller;
+    ctx->vbcaller->caller = SP_CALLER_UNINITIALIZED;
+    hres = exec_script(ctx, TRUE, &code->main_code, NULL, NULL, res);
+    ctx->vbcaller->caller = prev_caller;
+    return hres;
 }
 
 static void exec_queued_code(script_ctx_t *ctx)
@@ -366,6 +372,89 @@ static void decrease_state(VBScript *This, SCRIPTSTATE state)
     }
 }
 
+static inline struct vbcaller *vbcaller_from_IServiceProvider(IServiceProvider *iface)
+{
+    return CONTAINING_RECORD(iface, struct vbcaller, IServiceProvider_iface);
+}
+
+static HRESULT WINAPI vbcaller_QueryInterface(IServiceProvider *iface, REFIID riid, void **ppv)
+{
+    struct vbcaller *This = vbcaller_from_IServiceProvider(iface);
+
+    if(IsEqualGUID(&IID_IUnknown, riid) || IsEqualGUID(&IID_IServiceProvider, riid)) {
+        *ppv = &This->IServiceProvider_iface;
+    }else {
+        WARN("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI vbcaller_AddRef(IServiceProvider *iface)
+{
+    struct vbcaller *This = vbcaller_from_IServiceProvider(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI vbcaller_Release(IServiceProvider *iface)
+{
+    struct vbcaller *This = vbcaller_from_IServiceProvider(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref=%ld\n", This, ref);
+
+    if(!ref)
+        free(This);
+
+    return ref;
+}
+
+static HRESULT WINAPI vbcaller_QueryService(IServiceProvider *iface, REFGUID guidService,
+        REFIID riid, void **ppv)
+{
+    struct vbcaller *This = vbcaller_from_IServiceProvider(iface);
+
+    if(IsEqualGUID(guidService, &SID_GetCaller)) {
+        TRACE("(%p)->(SID_GetCaller)\n", This);
+        *ppv = NULL;
+        if(!This->caller)
+            return S_OK;
+        return (This->caller == SP_CALLER_UNINITIALIZED) ? E_NOINTERFACE : IServiceProvider_QueryInterface(This->caller, riid, ppv);
+    }
+
+    FIXME("(%p)->(%s %s %p)\n", This, debugstr_guid(guidService), debugstr_guid(riid), ppv);
+
+    *ppv = NULL;
+    return E_NOINTERFACE;
+}
+
+static const IServiceProviderVtbl ServiceProviderVtbl = {
+    vbcaller_QueryInterface,
+    vbcaller_AddRef,
+    vbcaller_Release,
+    vbcaller_QueryService
+};
+
+static struct vbcaller *create_vbcaller(void)
+{
+    struct vbcaller *ret;
+
+    ret = malloc(sizeof(*ret));
+    if(ret) {
+        ret->IServiceProvider_iface.lpVtbl = &ServiceProviderVtbl;
+        ret->ref = 1;
+        ret->caller = SP_CALLER_UNINITIALIZED;
+    }
+    return ret;
+}
+
 static inline VBScriptError *impl_from_IActiveScriptError(IActiveScriptError *iface)
 {
     return CONTAINING_RECORD(iface, VBScriptError, IActiveScriptError_iface);
@@ -545,6 +634,7 @@ static ULONG WINAPI VBScript_Release(IActiveScript *iface)
     if(!ref) {
         decrease_state(This, SCRIPTSTATE_CLOSED);
         detach_global_objects(This->ctx);
+        IServiceProvider_Release(&This->ctx->vbcaller->IServiceProvider_iface);
         free(This->ctx);
         free(This);
     }
@@ -1102,6 +1192,7 @@ static const IObjectSafetyVtbl VBScriptSafetyVtbl = {
 
 HRESULT WINAPI VBScriptFactory_CreateInstance(IClassFactory *iface, IUnknown *pUnkOuter, REFIID riid, void **ppv)
 {
+    struct vbcaller *vbcaller;
     script_ctx_t *ctx;
     VBScript *ret;
     HRESULT hres;
@@ -1112,6 +1203,11 @@ HRESULT WINAPI VBScriptFactory_CreateInstance(IClassFactory *iface, IUnknown *pU
     if(!ret)
         return E_OUTOFMEMORY;
 
+    if(!(vbcaller = create_vbcaller())) {
+        free(ret);
+        return E_OUTOFMEMORY;
+    }
+
     ret->IActiveScript_iface.lpVtbl = &VBScriptVtbl;
     ret->IActiveScriptDebug_iface.lpVtbl = &VBScriptDebugVtbl;
     ret->IActiveScriptParse_iface.lpVtbl = &VBScriptParseVtbl;
@@ -1123,10 +1219,12 @@ HRESULT WINAPI VBScriptFactory_CreateInstance(IClassFactory *iface, IUnknown *pU
 
     ctx = ret->ctx = calloc(1, sizeof(*ctx));
     if(!ctx) {
+        IServiceProvider_Release(&vbcaller->IServiceProvider_iface);
         free(ret);
         return E_OUTOFMEMORY;
     }
 
+    ctx->vbcaller = vbcaller;
     ctx->safeopt = INTERFACE_USES_DISPEX;
     list_init(&ctx->objects);
     list_init(&ctx->code_list);
diff --git a/dlls/vbscript/vbscript.h b/dlls/vbscript/vbscript.h
index 8286b37bbab..13bcf704bf0 100644
--- a/dlls/vbscript/vbscript.h
+++ b/dlls/vbscript/vbscript.h
@@ -180,12 +180,23 @@ static inline VARIANT *get_arg(DISPPARAMS *dp, DWORD i)
     return dp->rgvarg + dp->cArgs-i-1;
 }
 
+#define SP_CALLER_UNINITIALIZED ((IServiceProvider*)IntToPtr(-1))
+
+struct vbcaller {
+    IServiceProvider IServiceProvider_iface;
+
+    LONG ref;
+
+    IServiceProvider *caller;
+};
+
 struct _script_ctx_t {
     IActiveScriptSite *site;
     LCID lcid;
     UINT codepage;
 
     IInternetHostSecurityManager *secmgr;
+    struct vbcaller *vbcaller;
     DWORD safeopt;
 
     ScriptDisp *script_obj;
@@ -404,7 +415,7 @@ BSTR string_replace(BSTR,BSTR,BSTR,int,int,int) DECLSPEC_HIDDEN;
 
 void map_vbs_exception(EXCEPINFO *) DECLSPEC_HIDDEN;
 
-HRESULT create_safearray_iter(SAFEARRAY *sa, IEnumVARIANT **ev) DECLSPEC_HIDDEN;
+HRESULT create_safearray_iter(SAFEARRAY *sa, BOOL owned, IEnumVARIANT **ev) DECLSPEC_HIDDEN;
 
 #define FACILITY_VBS 0xa
 #define MAKE_VBSERROR(code) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_VBS, code)
diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index faab5d51af6..9cae1750b73 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -422,6 +422,7 @@ static const struct column col_stdregprov[] =
     { L"CreateKey",      CIM_FLAG_ARRAY|COL_FLAG_METHOD },
     { L"EnumKey",        CIM_FLAG_ARRAY|COL_FLAG_METHOD },
     { L"EnumValues",     CIM_FLAG_ARRAY|COL_FLAG_METHOD },
+    { L"GetBinaryValue", CIM_FLAG_ARRAY|COL_FLAG_METHOD },
     { L"GetStringValue", CIM_FLAG_ARRAY|COL_FLAG_METHOD },
     { L"SetStringValue", CIM_FLAG_ARRAY|COL_FLAG_METHOD },
     { L"SetDWORDValue",  CIM_FLAG_ARRAY|COL_FLAG_METHOD },
@@ -482,6 +483,13 @@ static const struct column col_videocontroller[] =
     { L"VideoModeDescription",        CIM_STRING|COL_FLAG_DYNAMIC },
     { L"VideoProcessor",              CIM_STRING|COL_FLAG_DYNAMIC },
 };
+
+static const struct column col_volume[] =
+{
+    { L"DeviceId",      CIM_STRING|COL_FLAG_DYNAMIC|COL_FLAG_KEY },
+    { L"DriveLetter",   CIM_STRING|COL_FLAG_DYNAMIC },
+};
+
 static const struct column col_winsat[] =
 {
     { L"CPUScore",              CIM_REAL32 },
@@ -864,6 +872,7 @@ struct record_stdregprov
     class_method *createkey;
     class_method *enumkey;
     class_method *enumvalues;
+    class_method *getbinaryvalue;
     class_method *getstringvalue;
     class_method *setstringvalue;
     class_method *setdwordvalue;
@@ -923,6 +932,13 @@ struct record_videocontroller
     const WCHAR *videomodedescription;
     const WCHAR *videoprocessor;
 };
+
+struct record_volume
+{
+    const WCHAR *deviceid;
+    const WCHAR *driveletter;
+};
+
 struct record_winsat
 {
     FLOAT        cpuscore;
@@ -966,6 +982,11 @@ static const struct record_param data_param[] =
     { L"StdRegProv", L"EnumValues", -1, L"ReturnValue", CIM_UINT32 },
     { L"StdRegProv", L"EnumValues", -1, L"sNames", CIM_STRING|CIM_FLAG_ARRAY },
     { L"StdRegProv", L"EnumValues", -1, L"Types", CIM_SINT32|CIM_FLAG_ARRAY },
+    { L"StdRegProv", L"GetBinaryValue", 1, L"hDefKey", CIM_SINT32, 0x80000002 },
+    { L"StdRegProv", L"GetBinaryValue", 1, L"sSubKeyName", CIM_STRING },
+    { L"StdRegProv", L"GetBinaryValue", 1, L"sValueName", CIM_STRING },
+    { L"StdRegProv", L"GetBinaryValue", -1, L"ReturnValue", CIM_UINT32 },
+    { L"StdRegProv", L"GetBinaryValue", -1, L"uValue", CIM_UINT8|CIM_FLAG_ARRAY },
     { L"StdRegProv", L"GetStringValue", 1, L"hDefKey", CIM_SINT32, 0x80000002 },
     { L"StdRegProv", L"GetStringValue", 1, L"sSubKeyName", CIM_STRING },
     { L"StdRegProv", L"GetStringValue", 1, L"sValueName", CIM_STRING },
@@ -1033,6 +1054,7 @@ static const struct record_stdregprov data_stdregprov[] =
         reg_create_key,
         reg_enum_key,
         reg_enum_values,
+        reg_get_binaryvalue,
         reg_get_stringvalue,
         reg_set_stringvalue,
         reg_set_dwordvalue,
@@ -3609,6 +3631,7 @@ static WCHAR *get_osbuildnumber( OSVERSIONINFOEXW *ver )
     if (ret) swprintf( ret, 11, L"%u", ver->dwBuildNumber );
     return ret;
 }
+
 static WCHAR *get_oscaption( OSVERSIONINFOEXW *ver )
 {
     static const WCHAR windowsW[] = L"Microsoft Windows ";
@@ -3623,12 +3646,17 @@ static WCHAR *get_oscaption( OSVERSIONINFOEXW *ver )
     static const WCHAR win8W[] = L"8 Pro";
     static const WCHAR win81W[] = L"8.1 Pro";
     static const WCHAR win10W[] = L"10 Pro";
+    static const WCHAR win11W[] = L"11 Pro";
     int len = ARRAY_SIZE( windowsW ) - 1;
     WCHAR *ret;
 
     if (!(ret = malloc( len * sizeof(WCHAR) + sizeof(win2003W) ))) return NULL;
     memcpy( ret, windowsW, sizeof(windowsW) );
-    if (ver->dwMajorVersion == 10 && ver->dwMinorVersion == 0) memcpy( ret + len, win10W, sizeof(win10W) );
+    if (ver->dwMajorVersion == 10 && ver->dwMinorVersion == 0)
+    {
+        if (ver->dwBuildNumber >= 22000) memcpy( ret + len, win11W, sizeof(win11W) );
+        else memcpy( ret + len, win10W, sizeof(win10W) );
+    }
     else if (ver->dwMajorVersion == 6 && ver->dwMinorVersion == 3) memcpy( ret + len, win81W, sizeof(win81W) );
     else if (ver->dwMajorVersion == 6 && ver->dwMinorVersion == 2) memcpy( ret + len, win8W, sizeof(win8W) );
     else if (ver->dwMajorVersion == 6 && ver->dwMinorVersion == 1)
@@ -3650,6 +3678,7 @@ static WCHAR *get_oscaption( OSVERSIONINFOEXW *ver )
     else memcpy( ret + len, win2000W, sizeof(win2000W) );
     return ret;
 }
+
 static WCHAR *get_osname( const WCHAR *caption )
 {
     static const WCHAR partitionW[] = L"|C:\\WINDOWS|\\Device\\Harddisk0\\Partition1";
@@ -3675,6 +3704,7 @@ static WCHAR *get_osversion( OSVERSIONINFOEXW *ver )
     if (ret) swprintf( ret, 33, L"%u.%u.%u", ver->dwMajorVersion, ver->dwMinorVersion, ver->dwBuildNumber );
     return ret;
 }
+
 static DWORD get_operatingsystemsku(void)
 {
     DWORD ret = PRODUCT_UNDEFINED;
@@ -4180,6 +4210,60 @@ static enum fill_status fill_videocontroller( struct table *table, const struct
     return status;
 }
 
+static WCHAR *get_volume_driveletter( const WCHAR *volume )
+{
+    DWORD len = 0;
+    WCHAR *ret;
+
+    if (!GetVolumePathNamesForVolumeNameW( volume, NULL, 0, &len ) && GetLastError() != ERROR_MORE_DATA) return NULL;
+    if (!(ret = malloc( len * sizeof(WCHAR) ))) return NULL;
+    if (!GetVolumePathNamesForVolumeNameW( volume, ret, len, &len ) || !wcschr( ret, ':' ))
+    {
+        free( ret );
+        return NULL;
+    }
+    wcschr( ret, ':' )[1] = 0;
+    return ret;
+}
+
+static enum fill_status fill_volume( struct table *table, const struct expr *cond )
+{
+    struct record_volume *rec;
+    enum fill_status status = FILL_STATUS_UNFILTERED;
+    UINT row = 0, offset = 0;
+    WCHAR path[MAX_PATH];
+    HANDLE handle;
+
+    if (!resize_table( table, 2, sizeof(*rec) )) return FILL_STATUS_FAILED;
+
+    handle = FindFirstVolumeW( path, ARRAY_SIZE(path) );
+    while (handle != INVALID_HANDLE_VALUE)
+    {
+        if (!resize_table( table, row + 1, sizeof(*rec) )) return FILL_STATUS_FAILED;
+
+        rec = (struct record_volume *)(table->data + offset);
+        rec->deviceid    = wcsdup( path );
+        rec->driveletter = get_volume_driveletter( path );
+
+        if (!match_row( table, row, cond, &status )) free_row_values( table, row );
+        else
+        {
+            offset += sizeof(*rec);
+            row++;
+        }
+
+        if (!FindNextVolumeW( handle, path, ARRAY_SIZE(path) ))
+        {
+            FindVolumeClose( handle );
+            handle = INVALID_HANDLE_VALUE;
+        }
+    }
+
+    TRACE("created %u rows\n", row);
+    table->num_rows = row;
+    return status;
+}
+
 static WCHAR *get_sounddevice_pnpdeviceid( DXGI_ADAPTER_DESC *desc )
 {
     static const WCHAR fmtW[] = L"HDAUDIO\\FUNC_01&VEN_%04X&DEV_%04X&SUBSYS_%08X&REV_%04X\\0&DEADBEEF&0&DEAD";
@@ -4262,6 +4346,7 @@ static struct table cimv2_builtin_classes[] =
     { L"Win32_SoundDevice", C(col_sounddevice), 0, 0, NULL, fill_sounddevice },
     { L"Win32_SystemEnclosure", C(col_systemenclosure), 0, 0, NULL, fill_systemenclosure },
     { L"Win32_VideoController", C(col_videocontroller), 0, 0, NULL, fill_videocontroller },
+    { L"Win32_Volume", C(col_volume), 0, 0, NULL, fill_volume },
     { L"Win32_WinSAT", C(col_winsat), D(data_winsat) },
 };
 
diff --git a/dlls/wbemprox/main.c b/dlls/wbemprox/main.c
index 20ca1a08530..30363658636 100644
--- a/dlls/wbemprox/main.c
+++ b/dlls/wbemprox/main.c
@@ -37,7 +37,7 @@ static HINSTANCE instance;
 
 struct list *table_list[WBEMPROX_NAMESPACE_LAST];
 
-typedef HRESULT (*fnCreateInstance)( LPVOID *ppObj );
+typedef HRESULT (*fnCreateInstance)( LPVOID *ppObj, REFIID riid );
 
 typedef struct
 {
@@ -77,8 +77,6 @@ static HRESULT WINAPI wbemprox_cf_CreateInstance( IClassFactory *iface, LPUNKNOW
                                                   REFIID riid, LPVOID *ppobj )
 {
     wbemprox_cf *This = impl_from_IClassFactory( iface );
-    HRESULT r;
-    IUnknown *punk;
 
     TRACE("%p %s %p\n", pOuter, debugstr_guid(riid), ppobj);
 
@@ -87,13 +85,7 @@ static HRESULT WINAPI wbemprox_cf_CreateInstance( IClassFactory *iface, LPUNKNOW
     if (pOuter)
         return CLASS_E_NOAGGREGATION;
 
-    r = This->pfnCreateInstance( (LPVOID *)&punk );
-    if (FAILED(r))
-        return r;
-
-    r = IUnknown_QueryInterface( punk, riid, ppobj );
-    IUnknown_Release( punk );
-    return r;
+    return This->pfnCreateInstance( ppobj, riid );
 }
 
 static HRESULT WINAPI wbemprox_cf_LockServer( IClassFactory *iface, BOOL dolock )
diff --git a/dlls/wbemprox/reg.c b/dlls/wbemprox/reg.c
index 81ed914ae2f..cd7db81aed7 100644
--- a/dlls/wbemprox/reg.c
+++ b/dlls/wbemprox/reg.c
@@ -75,7 +75,7 @@ static HRESULT to_i4_array( DWORD *values, DWORD count, VARIANT *var )
     return S_OK;
 }
 
-static unsigned int reg_get_access_mask( IWbemContext *context )
+static unsigned int get_access_mask( IWbemContext *context )
 {
     VARIANT value;
 
@@ -106,7 +106,7 @@ static HRESULT create_key( HKEY root, const WCHAR *subkey, IWbemContext *context
 
     TRACE("%p, %s\n", root, debugstr_w(subkey));
 
-    res = RegCreateKeyExW( root, subkey, 0, NULL, 0, reg_get_access_mask( context ), NULL, &hkey, NULL );
+    res = RegCreateKeyExW( root, subkey, 0, NULL, 0, get_access_mask( context ), NULL, &hkey, NULL );
     set_variant( VT_UI4, res, NULL, retval );
     if (!res)
     {
@@ -172,7 +172,7 @@ static HRESULT enum_key( HKEY root, const WCHAR *subkey, VARIANT *names, IWbemCo
     TRACE("%p, %s\n", root, debugstr_w(subkey));
 
     if (!(strings = malloc( count * sizeof(BSTR) ))) return E_OUTOFMEMORY;
-    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_ENUMERATE_SUB_KEYS | reg_get_access_mask( context ), &hkey )))
+    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_ENUMERATE_SUB_KEYS | get_access_mask( context ), &hkey )))
     {
         set_variant( VT_UI4, res, NULL, retval );
         free( strings );
@@ -271,7 +271,7 @@ done:
 }
 
 static HRESULT enum_values( HKEY root, const WCHAR *subkey, VARIANT *names, VARIANT *types, IWbemContext *context,
-        VARIANT *retval )
+                            VARIANT *retval )
 {
     HKEY hkey = NULL;
     HRESULT hr = S_OK;
@@ -282,7 +282,7 @@ static HRESULT enum_values( HKEY root, const WCHAR *subkey, VARIANT *names, VARI
 
     TRACE("%p, %s\n", root, debugstr_w(subkey));
 
-    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_QUERY_VALUE | reg_get_access_mask( context ), &hkey ))) goto done;
+    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_QUERY_VALUE | get_access_mask( context ), &hkey ))) goto done;
     if ((res = RegQueryInfoKeyW( hkey, NULL, NULL, NULL, NULL, NULL, NULL, &count, &buflen, NULL, NULL, NULL )))
         goto done;
 
@@ -386,7 +386,7 @@ done:
 }
 
 static HRESULT get_stringvalue( HKEY root, const WCHAR *subkey, const WCHAR *name, VARIANT *value,
-        IWbemContext *context, VARIANT *retval )
+                                IWbemContext *context, VARIANT *retval )
 {
     DWORD size, mask, flags = RRF_RT_REG_SZ;
     HRESULT hr = S_OK;
@@ -395,7 +395,7 @@ static HRESULT get_stringvalue( HKEY root, const WCHAR *subkey, const WCHAR *nam
 
     TRACE("%p, %s, %s\n", root, debugstr_w(subkey), debugstr_w(name));
 
-    mask = reg_get_access_mask( context );
+    mask = get_access_mask( context );
 
     if (mask & KEY_WOW64_64KEY)
         flags |= RRF_SUBKEY_WOW6464KEY;
@@ -403,13 +403,8 @@ static HRESULT get_stringvalue( HKEY root, const WCHAR *subkey, const WCHAR *nam
         flags |= RRF_SUBKEY_WOW6432KEY;
 
     if ((res = RegGetValueW( root, subkey, name, flags, NULL, NULL, &size ))) goto done;
-    if (!(str = SysAllocStringLen( NULL, size / sizeof(WCHAR) - 1 )))
-    {
-        hr = E_OUTOFMEMORY;
-        goto done;
-    }
-    if (!(res = RegGetValueW( root, subkey, name, flags, NULL, str, &size )))
-        set_variant( VT_BSTR, 0, str, value );
+    if (!(str = SysAllocStringLen( NULL, size / sizeof(WCHAR) - 1 ))) return E_OUTOFMEMORY;
+    if (!(res = RegGetValueW( root, subkey, name, flags, NULL, str, &size ))) set_variant( VT_BSTR, 0, str, value );
 
 done:
     set_variant( VT_UI4, res, NULL, retval );
@@ -480,15 +475,124 @@ done:
     return hr;
 }
 
+static HRESULT to_ui1_array( BYTE *value, DWORD size, VARIANT *var )
+{
+    SAFEARRAY *sa;
+    HRESULT hr;
+    LONG i;
+
+    if (!(sa = SafeArrayCreateVector( VT_UI1, 0, size ))) return E_OUTOFMEMORY;
+    for (i = 0; i < size; i++)
+    {
+        if ((hr = SafeArrayPutElement( sa, &i, &value[i] )) != S_OK)
+        {
+            SafeArrayDestroy( sa );
+            return hr;
+        }
+    }
+    set_variant( VT_UI1|VT_ARRAY, 0, sa, var );
+    return S_OK;
+}
+
+static HRESULT get_binaryvalue( HKEY root, const WCHAR *subkey, const WCHAR *name, VARIANT *value,
+                                IWbemContext *context, VARIANT *retval )
+{
+    DWORD size, mask, flags = RRF_RT_REG_BINARY;
+    HRESULT hr = S_OK;
+    BYTE *buf = NULL;
+    LONG res;
+
+    TRACE("%p, %s, %s\n", root, debugstr_w(subkey), debugstr_w(name));
+
+    mask = get_access_mask( context );
+
+    if (mask & KEY_WOW64_64KEY)
+        flags |= RRF_SUBKEY_WOW6464KEY;
+    else if (mask & KEY_WOW64_32KEY)
+        flags |= RRF_SUBKEY_WOW6432KEY;
+
+    if ((res = RegGetValueW( root, subkey, name, flags, NULL, NULL, &size ))) goto done;
+    if (!(buf = malloc( size ))) return E_OUTOFMEMORY;
+    if (!(res = RegGetValueW( root, subkey, name, flags, NULL, buf, &size ))) hr = to_ui1_array( buf, size, value );
+
+done:
+    set_variant( VT_UI4, res, NULL, retval );
+    free( buf );
+    return hr;
+}
+
+HRESULT reg_get_binaryvalue( IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out )
+{
+    VARIANT defkey, subkey, name, value, retval;
+    IWbemClassObject *sig, *out_params = NULL;
+    HRESULT hr;
+
+    TRACE("%p, %p, %p, %p\n", obj, context, in, out);
+
+    hr = IWbemClassObject_Get( in, L"hDefKey", 0, &defkey, NULL, NULL );
+    if (hr != S_OK) return hr;
+    hr = IWbemClassObject_Get( in, L"sSubKeyName", 0, &subkey, NULL, NULL );
+    if (hr != S_OK) return hr;
+    hr = IWbemClassObject_Get( in, L"sValueName", 0, &name, NULL, NULL );
+    if (hr != S_OK)
+    {
+        VariantClear( &subkey );
+        return hr;
+    }
+
+    hr = create_signature( WBEMPROX_NAMESPACE_CIMV2, L"StdRegProv", L"GetBinaryValue", PARAM_OUT, &sig );
+    if (hr != S_OK)
+    {
+        VariantClear( &name );
+        VariantClear( &subkey );
+        return hr;
+    }
+    if (out)
+    {
+        hr = IWbemClassObject_SpawnInstance( sig, 0, &out_params );
+        if (hr != S_OK)
+        {
+            VariantClear( &name );
+            VariantClear( &subkey );
+            IWbemClassObject_Release( sig );
+            return hr;
+        }
+    }
+    VariantInit( &value );
+    hr = get_binaryvalue( (HKEY)(INT_PTR)V_I4(&defkey), V_BSTR(&subkey), V_BSTR(&name), &value, context, &retval );
+    if (hr != S_OK) goto done;
+    if (out_params)
+    {
+        if (!V_UI4( &retval ))
+        {
+            hr = IWbemClassObject_Put( out_params, L"uValue", 0, &value, CIM_UINT8|CIM_FLAG_ARRAY );
+            if (hr != S_OK) goto done;
+        }
+        hr = IWbemClassObject_Put( out_params, L"ReturnValue", 0, &retval, CIM_UINT32 );
+    }
+
+done:
+    VariantClear( &name );
+    VariantClear( &subkey );
+    IWbemClassObject_Release( sig );
+    if (hr == S_OK && out)
+    {
+        *out = out_params;
+        IWbemClassObject_AddRef( out_params );
+    }
+    if (out_params) IWbemClassObject_Release( out_params );
+    return hr;
+}
+
 static void set_stringvalue( HKEY root, const WCHAR *subkey, const WCHAR *name, const WCHAR *value,
-        IWbemContext *context, VARIANT *retval )
+                             IWbemContext *context, VARIANT *retval )
 {
     HKEY hkey;
     LONG res;
 
     TRACE("%p, %s, %s, %s\n", root, debugstr_w(subkey), debugstr_w(name), debugstr_w(value));
 
-    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_SET_VALUE | reg_get_access_mask( context ), &hkey )))
+    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_SET_VALUE | get_access_mask( context ), &hkey )))
     {
         set_variant( VT_UI4, res, NULL, retval );
         return;
@@ -571,7 +675,7 @@ static void set_dwordvalue( HKEY root, const WCHAR *subkey, const WCHAR *name, D
 
     TRACE( "%p, %s, %s, %#lx\n", root, debugstr_w(subkey), debugstr_w(name), value );
 
-    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_SET_VALUE | reg_get_access_mask( context ), &hkey )))
+    if ((res = RegOpenKeyExW( root, subkey, 0, KEY_SET_VALUE | get_access_mask( context ), &hkey )))
     {
         set_variant( VT_UI4, res, NULL, retval );
         return;
@@ -648,7 +752,7 @@ static void delete_key( HKEY root, const WCHAR *subkey, IWbemContext *context, V
 
     TRACE("%p, %s\n", root, debugstr_w(subkey));
 
-    res = RegDeleteKeyExW( root, subkey, reg_get_access_mask( context ), 0 );
+    res = RegDeleteKeyExW( root, subkey, get_access_mask( context ), 0 );
     set_variant( VT_UI4, res, NULL, retval );
 }
 
diff --git a/dlls/wbemprox/services.c b/dlls/wbemprox/services.c
index 6fc05be9f3c..203b0e90784 100644
--- a/dlls/wbemprox/services.c
+++ b/dlls/wbemprox/services.c
@@ -1058,7 +1058,7 @@ static HRESULT WINAPI wbem_context_Clone(
 
     TRACE("%p, %p\n", iface, newcopy);
 
-    if (SUCCEEDED(hr = WbemContext_create( (void **)&cloned_context )))
+    if (SUCCEEDED(hr = WbemContext_create( (void **)&cloned_context, &IID_IWbemContext )))
     {
         LIST_FOR_EACH_ENTRY( value, &context->values, struct wbem_context_value, entry )
         {
@@ -1225,12 +1225,16 @@ static const IWbemContextVtbl wbem_context_vtbl =
     wbem_context_DeleteAll,
 };
 
-HRESULT WbemContext_create( void **obj )
+HRESULT WbemContext_create( void **obj, REFIID riid )
 {
     struct wbem_context *context;
 
     TRACE("(%p)\n", obj);
 
+    if ( !IsEqualGUID( riid, &IID_IWbemContext ) &&
+         !IsEqualGUID( riid, &IID_IUnknown ) )
+        return E_NOINTERFACE;
+
     if (!(context = malloc( sizeof(*context) ))) return E_OUTOFMEMORY;
 
     context->IWbemContext_iface.lpVtbl = &wbem_context_vtbl;
diff --git a/dlls/wbemprox/tests/query.c b/dlls/wbemprox/tests/query.c
index 4503ace0b68..beceffe7e69 100644
--- a/dlls/wbemprox/tests/query.c
+++ b/dlls/wbemprox/tests/query.c
@@ -1042,6 +1042,49 @@ static void test_StdRegProv( IWbemServices *services )
     IWbemClassObject_Release( out );
     IWbemClassObject_Release( sig_in );
 
+    hr = IWbemClassObject_GetMethod( reg, L"GetBinaryValue", 0, &sig_in, NULL );
+    ok( hr == S_OK, "failed to get GetStringValue method %#lx\n", hr );
+
+    hr = IWbemClassObject_SpawnInstance( sig_in, 0, &in );
+    ok( hr == S_OK, "failed to spawn instance %#lx\n", hr );
+
+    V_VT( &defkey ) = VT_I4;
+    V_I4( &defkey ) = 0x80000001;
+    hr = IWbemClassObject_Put( in, L"hDefKey", 0, &defkey, 0 );
+    ok( hr == S_OK, "failed to set root %#lx\n", hr );
+
+    V_VT( &subkey ) = VT_BSTR;
+    V_BSTR( &subkey ) = SysAllocString( L"Control Panel\\Desktop" );
+    hr = IWbemClassObject_Put( in, L"sSubKeyName", 0, &subkey, 0 );
+    ok( hr == S_OK, "failed to set subkey %#lx\n", hr );
+
+    V_VT( &valuename ) = VT_BSTR;
+    V_BSTR( &valuename ) = SysAllocString( L"UserPreferencesMask" );
+    hr = IWbemClassObject_Put( in, L"sValueName", 0, &valuename, 0 );
+    ok( hr == S_OK, "failed to set value name %#lx\n", hr );
+
+    out = NULL;
+    method = SysAllocString( L"GetBinaryValue" );
+    hr = IWbemServices_ExecMethod( services, class, method, 0, NULL, in, &out, NULL );
+    ok( hr == S_OK, "failed to execute method %#lx\n", hr );
+    SysFreeString( method );
+
+    type = 0xdeadbeef;
+    VariantInit( &retval );
+    hr = IWbemClassObject_Get( out, L"ReturnValue", 0, &retval, &type, NULL );
+    ok( hr == S_OK, "failed to get return value %#lx\n", hr );
+    ok( V_VT( &retval ) == VT_I4, "unexpected variant type %#x\n", V_VT( &retval ) );
+    ok( !V_I4( &retval ), "unexpected error %ld\n", V_I4( &retval ) );
+    ok( type == CIM_UINT32, "unexpected type %#lx\n", type );
+
+    check_property( out, L"uValue", VT_UI1|VT_ARRAY, CIM_UINT8|CIM_FLAG_ARRAY );
+
+    VariantClear( &valuename );
+    VariantClear( &subkey );
+    IWbemClassObject_Release( in );
+    IWbemClassObject_Release( out );
+    IWbemClassObject_Release( sig_in );
+
     IWbemClassObject_Release( reg );
     SysFreeString( class );
 }
@@ -1752,6 +1795,45 @@ static void test_Win32_VideoController( IWbemServices *services )
     SysFreeString( wql );
 }
 
+static void test_Win32_Volume( IWbemServices *services )
+{
+    BSTR wql = SysAllocString( L"wql" ), query = SysAllocString( L"SELECT * FROM Win32_Volume" );
+    IEnumWbemClassObject *result;
+    IWbemClassObject *obj;
+    HRESULT hr;
+    VARIANT val;
+    CIMTYPE type;
+    DWORD count;
+
+    hr = IWbemServices_ExecQuery( services, wql, query, 0, NULL, &result );
+    if (hr != S_OK)
+    {
+        win_skip( "Win32_Volume not available\n" );
+        return;
+    }
+
+    for (;;)
+    {
+        hr = IEnumWbemClassObject_Next( result, 10000, 1, &obj, &count );
+        if (hr != S_OK) break;
+
+        check_property( obj, L"DeviceID", VT_BSTR, CIM_STRING );
+
+        type = 0xdeadbeef;
+        memset( &val, 0, sizeof(val) );
+        hr = IWbemClassObject_Get( obj, L"DriveLetter", 0, &val, &type, NULL );
+        ok( hr == S_OK, "got %#lx\n", hr );
+        ok( V_VT( &val ) == VT_BSTR || V_VT( &val ) == VT_NULL, "unexpected variant type 0x%x\n", V_VT( &val ) );
+        ok( type == CIM_STRING, "unexpected type %#lx\n", type );
+        trace( "driveletter %s\n", wine_dbgstr_w(V_BSTR( &val )) );
+        VariantClear( &val );
+    }
+
+    IEnumWbemClassObject_Release( result );
+    SysFreeString( query );
+    SysFreeString( wql );
+}
+
 static void test_Win32_Printer( IWbemServices *services )
 {
     BSTR wql = SysAllocString( L"wql" ), query = SysAllocString( L"SELECT * FROM Win32_Printer" );
@@ -2306,6 +2388,7 @@ START_TEST(query)
     test_Win32_SoundDevice( services );
     test_Win32_SystemEnclosure( services );
     test_Win32_VideoController( services );
+    test_Win32_Volume( services );
     test_Win32_WinSAT( services );
     test_SystemRestore( services );
     test_empty_namespace( locator );
diff --git a/dlls/wbemprox/wbemlocator.c b/dlls/wbemprox/wbemlocator.c
index 32408cf6a90..6e5bddea156 100644
--- a/dlls/wbemprox/wbemlocator.c
+++ b/dlls/wbemprox/wbemlocator.c
@@ -202,12 +202,16 @@ static const IWbemLocatorVtbl wbem_locator_vtbl =
     wbem_locator_ConnectServer
 };
 
-HRESULT WbemLocator_create( LPVOID *ppObj )
+HRESULT WbemLocator_create( LPVOID *ppObj, REFIID riid )
 {
     wbem_locator *wl;
 
     TRACE("(%p)\n", ppObj);
 
+    if ( !IsEqualGUID( riid, &IID_IWbemLocator ) &&
+         !IsEqualGUID( riid, &IID_IUnknown ) )
+        return E_NOINTERFACE;
+
     if (!(wl = malloc( sizeof(*wl) ))) return E_OUTOFMEMORY;
 
     wl->IWbemLocator_iface.lpVtbl = &wbem_locator_vtbl;
diff --git a/dlls/wbemprox/wbemprox_private.h b/dlls/wbemprox/wbemprox_private.h
index 893fd922e19..4f23a8b8451 100644
--- a/dlls/wbemprox/wbemprox_private.h
+++ b/dlls/wbemprox/wbemprox_private.h
@@ -246,9 +246,9 @@ void set_variant( VARTYPE, LONGLONG, void *, VARIANT * ) DECLSPEC_HIDDEN;
 HRESULT create_signature( enum wbm_namespace ns, const WCHAR *, const WCHAR *, enum param_direction,
                           IWbemClassObject ** ) DECLSPEC_HIDDEN;
 
-HRESULT WbemLocator_create(LPVOID *) DECLSPEC_HIDDEN;
+HRESULT WbemLocator_create(LPVOID *, REFIID) DECLSPEC_HIDDEN;
 HRESULT WbemServices_create(const WCHAR *, IWbemContext *, LPVOID *) DECLSPEC_HIDDEN;
-HRESULT WbemContext_create(void **) DECLSPEC_HIDDEN;
+HRESULT WbemContext_create(void **, REFIID) DECLSPEC_HIDDEN;
 HRESULT create_class_object(enum wbm_namespace ns, const WCHAR *, IEnumWbemClassObject *, UINT,
                             struct record *, IWbemClassObject **) DECLSPEC_HIDDEN;
 HRESULT EnumWbemClassObject_create(struct query *, LPVOID *) DECLSPEC_HIDDEN;
@@ -259,6 +259,7 @@ HRESULT process_create(IWbemClassObject *obj, IWbemContext *context, IWbemClassO
 HRESULT reg_create_key(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
 HRESULT reg_enum_key(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
 HRESULT reg_enum_values(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
+HRESULT reg_get_binaryvalue(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
 HRESULT reg_get_stringvalue(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
 HRESULT reg_set_stringvalue(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
 HRESULT reg_set_dwordvalue(IWbemClassObject *obj, IWbemContext *context, IWbemClassObject *in, IWbemClassObject **out) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/class.c b/dlls/win32u/class.c
index 9f3b4251e65..396e2285797 100644
--- a/dlls/win32u/class.c
+++ b/dlls/win32u/class.c
@@ -108,7 +108,7 @@ static WINDOWPROC *find_winproc( WNDPROC func, BOOL ansi )
 
 /* return the window proc for a given handle, or NULL for an invalid handle,
  * or WINPROC_PROC16 for a handle to a 16-bit proc. */
-WINDOWPROC *get_winproc_ptr( WNDPROC handle )
+static WINDOWPROC *get_winproc_ptr( WNDPROC handle )
 {
     UINT index = LOWORD(handle);
     if ((ULONG_PTR)handle >> 16 != WINPROC_HANDLE) return NULL;
diff --git a/dlls/win32u/clipboard.c b/dlls/win32u/clipboard.c
index d53cd966d36..6cf484a56ca 100644
--- a/dlls/win32u/clipboard.c
+++ b/dlls/win32u/clipboard.c
@@ -720,7 +720,11 @@ HANDLE WINAPI NtUserGetClipboardData( UINT format, struct get_clipboard_params *
             params->data_size = size;
             return 0;
         }
-        if (status == STATUS_OBJECT_NAME_NOT_FOUND) return 0; /* no such format */
+        if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+        {
+            RtlSetLastWin32Error( ERROR_NOT_FOUND ); /* no such format */
+            return 0;
+        }
         if (status)
         {
             RtlSetLastWin32Error( RtlNtStatusToDosError( status ));
diff --git a/dlls/win32u/dce.c b/dlls/win32u/dce.c
index 1cc6a0d605e..5df30550cae 100644
--- a/dlls/win32u/dce.c
+++ b/dlls/win32u/dce.c
@@ -1449,7 +1449,6 @@ static void update_now( HWND hwnd, UINT rdw_flags )
  */
 BOOL WINAPI NtUserRedrawWindow( HWND hwnd, const RECT *rect, HRGN hrgn, UINT flags )
 {
-    LARGE_INTEGER zero = { .QuadPart = 0 };
     static const RECT empty;
     BOOL ret;
 
@@ -1470,7 +1469,7 @@ BOOL WINAPI NtUserRedrawWindow( HWND hwnd, const RECT *rect, HRGN hrgn, UINT fla
     }
 
     /* process pending expose events before painting */
-    if (flags & RDW_UPDATENOW) user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, &zero, QS_PAINT, 0 );
+    if (flags & RDW_UPDATENOW) user_driver->pProcessEvents( QS_PAINT );
 
     if (rect && !hrgn)
     {
@@ -1729,7 +1728,7 @@ INT WINAPI NtUserScrollWindowEx( HWND hwnd, INT dx, INT dy, const RECT *rect,
     TRACE( "%p, %d,%d update_rgn=%p update_rect = %p %s %04x\n",
            hwnd, dx, dy, update_rgn, update_rect, wine_dbgstr_rect(rect), flags );
     TRACE( "clip_rect = %s\n", wine_dbgstr_rect(clip_rect) );
-    if (flags & ~(SW_SCROLLCHILDREN | SW_INVALIDATE | SW_ERASE))
+    if (flags & ~(SW_SCROLLCHILDREN | SW_INVALIDATE | SW_ERASE | SW_NODCCACHE))
         FIXME( "some flags (%04x) are unhandled\n", flags );
 
     rdw_flags = (flags & SW_ERASE) && (flags & SW_INVALIDATE) ?
diff --git a/dlls/win32u/defwnd.c b/dlls/win32u/defwnd.c
index e58d4e5a793..182703e22be 100644
--- a/dlls/win32u/defwnd.c
+++ b/dlls/win32u/defwnd.c
@@ -1292,7 +1292,7 @@ static BOOL draw_push_button( HDC dc, RECT *r, UINT flags )
     return TRUE;
 }
 
-BOOL draw_frame_caption( HDC dc, RECT *r, UINT flags )
+static BOOL draw_frame_caption( HDC dc, RECT *r, UINT flags )
 {
     RECT rect;
     int small_diam = make_square_rect( r, &rect ) - 2;
diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index 68a009f576e..23ef7f64390 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -731,7 +731,6 @@ struct windrv_physdev
     struct gdi_physdev     dev;
     struct dibdrv_physdev *dibdrv;
     struct window_surface *surface;
-    DWORD                  start_ticks;
 };
 
 static const struct gdi_dc_funcs window_driver;
@@ -745,13 +744,15 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     /* gdi_lock should not be locked */
     dev->surface->funcs->lock( dev->surface );
-    if (IsRectEmpty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (IsRectEmpty( dev->dibdrv->bounds ) || dev->surface->draw_start_ticks == 0)
+        dev->surface->draw_start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
 {
+    BOOL should_flush = NtGetTickCount() - dev->surface->draw_start_ticks > FLUSH_PERIOD;
     dev->surface->funcs->unlock( dev->surface );
-    if (NtGetTickCount() - dev->start_ticks > FLUSH_PERIOD) dev->surface->funcs->flush( dev->surface );
+    if (should_flush) dev->surface->funcs->flush( dev->surface );
 }
 
 static void CDECL unlock_bits_surface( struct gdi_image_bits *bits )
diff --git a/dlls/win32u/driver.c b/dlls/win32u/driver.c
index e2c9ba04efd..1c0708461a1 100644
--- a/dlls/win32u/driver.c
+++ b/dlls/win32u/driver.c
@@ -806,13 +806,9 @@ static void nulldrv_GetDC( HDC hdc, HWND hwnd, HWND top_win, const RECT *win_rec
 {
 }
 
-static NTSTATUS nulldrv_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                     const LARGE_INTEGER *timeout,
-                                                     DWORD mask, DWORD flags )
+static BOOL nulldrv_ProcessEvents( DWORD mask )
 {
-    if (!count && timeout && !timeout->QuadPart) return WAIT_TIMEOUT;
-    return NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                     !!(flags & MWMO_ALERTABLE), timeout );
+    return FALSE;
 }
 
 static void nulldrv_ReleaseDC( HWND hwnd, HDC hdc )
@@ -1193,7 +1189,7 @@ static const struct user_driver_funcs lazy_load_driver =
     nulldrv_DestroyWindow,
     loaderdrv_FlashWindowEx,
     loaderdrv_GetDC,
-    nulldrv_MsgWaitForMultipleObjectsEx,
+    nulldrv_ProcessEvents,
     nulldrv_ReleaseDC,
     nulldrv_ScrollDC,
     nulldrv_SetCapture,
@@ -1268,7 +1264,7 @@ void __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version
     SET_USER_FUNC(DestroyWindow);
     SET_USER_FUNC(FlashWindowEx);
     SET_USER_FUNC(GetDC);
-    SET_USER_FUNC(MsgWaitForMultipleObjectsEx);
+    SET_USER_FUNC(ProcessEvents);
     SET_USER_FUNC(ReleaseDC);
     SET_USER_FUNC(ScrollDC);
     SET_USER_FUNC(SetCapture);
diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 832ffc0bed0..742a31b59a4 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -3551,7 +3551,7 @@ static BOOL CDECL font_EnumFonts( PHYSDEV dev, LOGFONTW *lf, FONTENUMPROCW proc,
             {
                 if (!face_matches( family->family_name, face, face_name )) continue;
                 if (!enum_face_charsets( family, face, enum_charsets, count, proc, lparam, orig_name ))
-                    return FALSE;
+                    return FALSE; /* enum_face_charsets() unlocked font_lock */
 	    }
 	}
     }
@@ -3562,7 +3562,7 @@ static BOOL CDECL font_EnumFonts( PHYSDEV dev, LOGFONTW *lf, FONTENUMPROCW proc,
         {
             face = LIST_ENTRY( list_head(get_family_face_list(family)), struct gdi_font_face, entry );
             if (!enum_face_charsets( family, face, enum_charsets, count, proc, lparam, NULL ))
-                return FALSE;
+                return FALSE; /* enum_face_charsets() unlocked font_lock */
 	}
     }
     pthread_mutex_unlock( &font_lock );
@@ -7083,7 +7083,7 @@ BOOL WINAPI NtGdiGetCharWidthInfo( HDC hdc, struct char_width_info *info )
 /***********************************************************************
  *           DrawTextW    (win32u.so)
  */
-INT WINAPI DrawTextW( HDC hdc, const WCHAR *str, INT count, RECT *rect, UINT flags )
+INT WINAPI DECLSPEC_HIDDEN DrawTextW( HDC hdc, const WCHAR *str, INT count, RECT *rect, UINT flags )
 {
     struct draw_text_params *params;
     ULONG ret_len, size;
diff --git a/dlls/win32u/gdiobj.c b/dlls/win32u/gdiobj.c
index f88efbaa679..df273beadde 100644
--- a/dlls/win32u/gdiobj.c
+++ b/dlls/win32u/gdiobj.c
@@ -1150,6 +1150,7 @@ static struct unix_funcs unix_funcs =
     __wine_get_file_outline_text_metric,
     __wine_get_icm_profile,
     __wine_send_input,
+    __wine_send_internal_message_timeout,
 };
 
 void gdi_init(void)
diff --git a/dlls/win32u/imm.c b/dlls/win32u/imm.c
index e9d7c699130..1ccc09c97b2 100644
--- a/dlls/win32u/imm.c
+++ b/dlls/win32u/imm.c
@@ -27,7 +27,7 @@
 #include <pthread.h>
 #include "win32u_private.h"
 #include "ntuser_private.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
@@ -277,12 +277,11 @@ BOOL register_imm_window( HWND hwnd )
     /* Create default IME window */
     if (!thread_data->window_cnt++)
     {
-        UNICODE_STRING class_name, name;
         static const WCHAR imeW[] = {'I','M','E',0};
         static const WCHAR default_imeW[] = {'D','e','f','a','u','l','t',' ','I','M','E',0};
+        UNICODE_STRING class_name = RTL_CONSTANT_STRING( imeW );
+        UNICODE_STRING name = RTL_CONSTANT_STRING( default_imeW );
 
-        RtlInitUnicodeString( &class_name, imeW );
-        RtlInitUnicodeString( &name, default_imeW );
         thread_data->default_hwnd = NtUserCreateWindowEx( 0, &class_name, &class_name, &name,
                                                           WS_POPUP | WS_DISABLED | WS_CLIPSIBLINGS,
                                                           0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, FALSE );
@@ -394,7 +393,7 @@ void cleanup_imm_thread(void)
     NtUserDestroyInputContext( UlongToHandle( thread_info->client_info.default_imc ));
 }
 
-BOOL WINAPI ImmProcessKey( HWND hwnd, HKL hkl, UINT vkey, LPARAM key_data, DWORD unknown )
+BOOL WINAPI DECLSPEC_HIDDEN ImmProcessKey( HWND hwnd, HKL hkl, UINT vkey, LPARAM key_data, DWORD unknown )
 {
     struct imm_process_key_params params =
         { .hwnd = hwnd, .hkl = hkl, .vkey = vkey, .key_data = key_data };
@@ -403,7 +402,7 @@ BOOL WINAPI ImmProcessKey( HWND hwnd, HKL hkl, UINT vkey, LPARAM key_data, DWORD
     return KeUserModeCallback( NtUserImmProcessKey, &params, sizeof(params), &ret_ptr, &ret_len );
 }
 
-BOOL WINAPI ImmTranslateMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM key_data )
+BOOL WINAPI DECLSPEC_HIDDEN ImmTranslateMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM key_data )
 {
     struct imm_translate_message_params params =
         { .hwnd = hwnd, .msg = msg, .wparam = wparam, .key_data = key_data };
diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index fd16d03f733..f768453594f 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -36,6 +36,7 @@
 #include "ntuser_private.h"
 #include "wine/server.h"
 #include "wine/debug.h"
+#include "kbd.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 WINE_DECLARE_DEBUG_CHANNEL(keyboard);
@@ -49,10 +50,491 @@ static const WCHAR keyboard_layouts_keyW[] =
     '\\','C','o','n','t','r','o','l',
     '\\','K','e','y','b','o','a','r','d',' ','L','a','y','o','u','t','s'
 };
+static const WCHAR escW[] = {'E','s','c',0};
+static const WCHAR backspaceW[] = {'B','a','c','k','s','p','a','c','e',0};
+static const WCHAR tabW[] = {'T','a','b',0};
+static const WCHAR enterW[] = {'E','n','t','e','r',0};
+static const WCHAR ctrlW[] = {'C','t','r','l',0};
+static const WCHAR shiftW[] = {'S','h','i','f','t',0};
+static const WCHAR right_shiftW[] = {'R','i','g','h','t',' ','S','h','i','f','t',0};
+static const WCHAR num_mulW[] = {'N','u','m',' ','*',0};
+static const WCHAR altW[] = {'A','l','t',0};
+static const WCHAR spaceW[] = {'S','p','a','c','e',0};
+static const WCHAR caps_lockW[] = {'C','a','p','s',' ','L','o','c','k',0};
+static const WCHAR f1W[] = {'F','1',0};
+static const WCHAR f2W[] = {'F','2',0};
+static const WCHAR f3W[] = {'F','3',0};
+static const WCHAR f4W[] = {'F','4',0};
+static const WCHAR f5W[] = {'F','5',0};
+static const WCHAR f6W[] = {'F','6',0};
+static const WCHAR f7W[] = {'F','7',0};
+static const WCHAR f8W[] = {'F','8',0};
+static const WCHAR f9W[] = {'F','9',0};
+static const WCHAR f10W[] = {'F','1','0',0};
+static const WCHAR pauseW[] = {'P','a','u','s','e',0};
+static const WCHAR scroll_lockW[] = {'S','c','r','o','l','l',' ','L','o','c','k',0};
+static const WCHAR num_7W[] = {'N','u','m',' ','7',0};
+static const WCHAR num_8W[] = {'N','u','m',' ','8',0};
+static const WCHAR num_9W[] = {'N','u','m',' ','9',0};
+static const WCHAR num_minusW[] = {'N','u','m',' ','-',0};
+static const WCHAR num_4W[] = {'N','u','m',' ','4',0};
+static const WCHAR num_5W[] = {'N','u','m',' ','5',0};
+static const WCHAR num_6W[] = {'N','u','m',' ','6',0};
+static const WCHAR num_plusW[] = {'N','u','m',' ','+',0};
+static const WCHAR num_1W[] = {'N','u','m',' ','1',0};
+static const WCHAR num_2W[] = {'N','u','m',' ','2',0};
+static const WCHAR num_3W[] = {'N','u','m',' ','3',0};
+static const WCHAR num_0W[] = {'N','u','m',' ','0',0};
+static const WCHAR num_delW[] = {'N','u','m',' ','D','e','l',0};
+static const WCHAR sys_reqW[] = {'S','y','s',' ','R','e','q',0};
+static const WCHAR f11W[] = {'F','1','1',0};
+static const WCHAR f12W[] = {'F','1','2',0};
+static const WCHAR f13W[] = {'F','1','3',0};
+static const WCHAR f14W[] = {'F','1','4',0};
+static const WCHAR f15W[] = {'F','1','5',0};
+static const WCHAR f16W[] = {'F','1','6',0};
+static const WCHAR f17W[] = {'F','1','7',0};
+static const WCHAR f18W[] = {'F','1','8',0};
+static const WCHAR f19W[] = {'F','1','9',0};
+static const WCHAR f20W[] = {'F','2','0',0};
+static const WCHAR f21W[] = {'F','2','1',0};
+static const WCHAR f22W[] = {'F','2','2',0};
+static const WCHAR f23W[] = {'F','2','3',0};
+static const WCHAR f24W[] = {'F','2','4',0};
+static const WCHAR num_enterW[] = {'N','u','m',' ','E','n','t','e','r',0};
+static const WCHAR right_ctrlW[] = {'R','i','g','h','t',' ','C','t','r','l',0};
+static const WCHAR num_divW[] = {'N','u','m',' ','/',0};
+static const WCHAR prnt_scrnW[] = {'P','r','n','t',' ','S','c','r','n',0};
+static const WCHAR right_altW[] = {'R','i','g','h','t',' ','A','l','t',0};
+static const WCHAR num_lockW[] = {'N','u','m',' ','L','o','c','k',0};
+static const WCHAR breakW[] = {'B','r','e','a','k',0};
+static const WCHAR homeW[] = {'H','o','m','e',0};
+static const WCHAR upW[] = {'U','p',0};
+static const WCHAR page_upW[] = {'P','a','g','e',' ','U','p',0};
+static const WCHAR leftW[] = {'L','e','f','t',0};
+static const WCHAR rightW[] = {'R','i','g','h','t',0};
+static const WCHAR endW[] = {'E','n','d',0};
+static const WCHAR downW[] = {'D','o','w','n',0};
+static const WCHAR page_downW[] = {'P','a','g','e',' ','D','o','w','n',0};
+static const WCHAR insertW[] = {'I','n','s','e','r','t',0};
+static const WCHAR deleteW[] = {'D','e','l','e','t','e',0};
+static const WCHAR zerozeroW[] = {'<','0','0','>',0};
+static const WCHAR helpW[] = {'H','e','l','p',0};
+static const WCHAR left_windowsW[] = {'L','e','f','t',' ','W','i','n','d','o','w','s',0};
+static const WCHAR right_windowsW[] = {'R','i','g','h','t',' ','W','i','n','d','o','w','s',0};
+static const WCHAR applicationW[] = {'A','p','p','l','i','c','a','t','i','o','n',0};
+
+static const VK_TO_BIT vk_to_bit[] =
+{
+    {.Vk = VK_SHIFT, .ModBits = KBDSHIFT},
+    {.Vk = VK_CONTROL, .ModBits = KBDCTRL},
+    {.Vk = VK_MENU, .ModBits = KBDALT},
+    {0},
+};
+
+static const MODIFIERS modifiers =
+{
+    .pVkToBit = (VK_TO_BIT *)vk_to_bit,
+    .wMaxModBits = 3,
+    .ModNumber = {0, 1, 2, 3},
+};
+
+static const VK_TO_WCHARS2 vk_to_wchars2[] =
+{
+    {.VirtualKey = VK_OEM_3,      .wch = {'`', '~'}},
+    {.VirtualKey = '1',           .wch = {'1', '!'}},
+    {.VirtualKey = '3',           .wch = {'3', '#'}},
+    {.VirtualKey = '4',           .wch = {'4', '$'}},
+    {.VirtualKey = '5',           .wch = {'5', '%'}},
+    {.VirtualKey = '7',           .wch = {'7', '&'}},
+    {.VirtualKey = '8',           .wch = {'8', '*'}},
+    {.VirtualKey = '9',           .wch = {'9', '('}},
+    {.VirtualKey = '0',           .wch = {'0', ')'}},
+    {.VirtualKey = VK_OEM_PLUS,   .wch = {'=', '+'}},
+    {.VirtualKey = 'Q',           .wch = {'q', 'Q'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'W',           .wch = {'w', 'W'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'E',           .wch = {'e', 'E'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'R',           .wch = {'r', 'R'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'T',           .wch = {'t', 'T'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'Y',           .wch = {'y', 'Y'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'U',           .wch = {'u', 'U'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'I',           .wch = {'i', 'I'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'O',           .wch = {'o', 'O'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'P',           .wch = {'p', 'P'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'A',           .wch = {'a', 'A'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'S',           .wch = {'s', 'S'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'D',           .wch = {'d', 'D'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'F',           .wch = {'f', 'F'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'G',           .wch = {'g', 'G'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'H',           .wch = {'h', 'H'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'J',           .wch = {'j', 'J'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'K',           .wch = {'k', 'K'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'L',           .wch = {'l', 'L'}, .Attributes = CAPLOK},
+    {.VirtualKey = VK_OEM_1,      .wch = {';', ':'}},
+    {.VirtualKey = VK_OEM_7,      .wch = {'\'', '\"'}},
+    {.VirtualKey = 'Z',           .wch = {'z', 'Z'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'X',           .wch = {'x', 'X'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'C',           .wch = {'c', 'C'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'V',           .wch = {'v', 'V'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'B',           .wch = {'b', 'B'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'N',           .wch = {'n', 'N'}, .Attributes = CAPLOK},
+    {.VirtualKey = 'M',           .wch = {'m', 'M'}, .Attributes = CAPLOK},
+    {.VirtualKey = VK_OEM_COMMA,  .wch = {',', '<'}},
+    {.VirtualKey = VK_OEM_PERIOD, .wch = {'.', '>'}},
+    {.VirtualKey = VK_OEM_2,      .wch = {'/', '?'}},
+    {.VirtualKey = VK_DECIMAL,    .wch = {'.', '.'}},
+    {.VirtualKey = VK_TAB,        .wch = {'\t', '\t'}},
+    {.VirtualKey = VK_ADD,        .wch = {'+', '+'}},
+    {.VirtualKey = VK_DIVIDE,     .wch = {'/', '/'}},
+    {.VirtualKey = VK_MULTIPLY,   .wch = {'*', '*'}},
+    {.VirtualKey = VK_SUBTRACT,   .wch = {'-', '-'}},
+    {0},
+};
+
+static const VK_TO_WCHARS3 vk_to_wchars3[] =
+{
+    {.VirtualKey = VK_OEM_4,   .wch = {'[', '{', '\x001b'}},
+    {.VirtualKey = VK_OEM_6,   .wch = {']', '}', '\x001d'}},
+    {.VirtualKey = VK_OEM_5,   .wch = {'\\', '|', '\x001c'}},
+    {.VirtualKey = VK_OEM_102, .wch = {'\\', '|', '\x001c'}},
+    {.VirtualKey = VK_BACK,    .wch = {'\b', '\b', '\x007f'}},
+    {.VirtualKey = VK_ESCAPE,  .wch = {'\x001b', '\x001b', '\x001b'}},
+    {.VirtualKey = VK_RETURN,  .wch = {'\r', '\r', '\n'}},
+    {.VirtualKey = VK_SPACE,   .wch = {' ', ' ', ' '}},
+    {.VirtualKey = VK_CANCEL,  .wch = {'\x0003', '\x0003', '\x0003'}},
+    {0},
+};
+
+static const VK_TO_WCHARS4 vk_to_wchars4[] =
+{
+    {.VirtualKey = '2',          .wch = {'2', '@', WCH_NONE, '\x0000'}},
+    {.VirtualKey = '6',          .wch = {'6', '^', WCH_NONE, '\x001e'}},
+    {.VirtualKey = VK_OEM_MINUS, .wch = {'-', '_', WCH_NONE, '\x001f'}},
+    {0},
+};
+
+static const VK_TO_WCHARS1 vk_to_wchars1[] =
+{
+    {.VirtualKey = VK_NUMPAD0, .wch = {'0'}},
+    {.VirtualKey = VK_NUMPAD1, .wch = {'1'}},
+    {.VirtualKey = VK_NUMPAD2, .wch = {'2'}},
+    {.VirtualKey = VK_NUMPAD3, .wch = {'3'}},
+    {.VirtualKey = VK_NUMPAD4, .wch = {'4'}},
+    {.VirtualKey = VK_NUMPAD5, .wch = {'5'}},
+    {.VirtualKey = VK_NUMPAD6, .wch = {'6'}},
+    {.VirtualKey = VK_NUMPAD7, .wch = {'7'}},
+    {.VirtualKey = VK_NUMPAD8, .wch = {'8'}},
+    {.VirtualKey = VK_NUMPAD9, .wch = {'9'}},
+    {0},
+};
+
+static const VK_TO_WCHAR_TABLE vk_to_wchar_table[] =
+{
+    {.pVkToWchars = (VK_TO_WCHARS1 *)vk_to_wchars3, .nModifications = 3, .cbSize = sizeof(vk_to_wchars3[0])},
+    {.pVkToWchars = (VK_TO_WCHARS1 *)vk_to_wchars4, .nModifications = 4, .cbSize = sizeof(vk_to_wchars4[0])},
+    {.pVkToWchars = (VK_TO_WCHARS1 *)vk_to_wchars2, .nModifications = 2, .cbSize = sizeof(vk_to_wchars2[0])},
+    {.pVkToWchars = (VK_TO_WCHARS1 *)vk_to_wchars1, .nModifications = 1, .cbSize = sizeof(vk_to_wchars1[0])},
+    {0},
+};
+
+static const VSC_LPWSTR key_names[] =
+{
+    {.vsc = 0x01, .pwsz = (WCHAR *)escW},
+    {.vsc = 0x0e, .pwsz = (WCHAR *)backspaceW},
+    {.vsc = 0x0f, .pwsz = (WCHAR *)tabW},
+    {.vsc = 0x1c, .pwsz = (WCHAR *)enterW},
+    {.vsc = 0x1d, .pwsz = (WCHAR *)ctrlW},
+    {.vsc = 0x2a, .pwsz = (WCHAR *)shiftW},
+    {.vsc = 0x36, .pwsz = (WCHAR *)right_shiftW},
+    {.vsc = 0x37, .pwsz = (WCHAR *)num_mulW},
+    {.vsc = 0x38, .pwsz = (WCHAR *)altW},
+    {.vsc = 0x39, .pwsz = (WCHAR *)spaceW},
+    {.vsc = 0x3a, .pwsz = (WCHAR *)caps_lockW},
+    {.vsc = 0x3b, .pwsz = (WCHAR *)f1W},
+    {.vsc = 0x3c, .pwsz = (WCHAR *)f2W},
+    {.vsc = 0x3d, .pwsz = (WCHAR *)f3W},
+    {.vsc = 0x3e, .pwsz = (WCHAR *)f4W},
+    {.vsc = 0x3f, .pwsz = (WCHAR *)f5W},
+    {.vsc = 0x40, .pwsz = (WCHAR *)f6W},
+    {.vsc = 0x41, .pwsz = (WCHAR *)f7W},
+    {.vsc = 0x42, .pwsz = (WCHAR *)f8W},
+    {.vsc = 0x43, .pwsz = (WCHAR *)f9W},
+    {.vsc = 0x44, .pwsz = (WCHAR *)f10W},
+    {.vsc = 0x45, .pwsz = (WCHAR *)pauseW},
+    {.vsc = 0x46, .pwsz = (WCHAR *)scroll_lockW},
+    {.vsc = 0x47, .pwsz = (WCHAR *)num_7W},
+    {.vsc = 0x48, .pwsz = (WCHAR *)num_8W},
+    {.vsc = 0x49, .pwsz = (WCHAR *)num_9W},
+    {.vsc = 0x4a, .pwsz = (WCHAR *)num_minusW},
+    {.vsc = 0x4b, .pwsz = (WCHAR *)num_4W},
+    {.vsc = 0x4c, .pwsz = (WCHAR *)num_5W},
+    {.vsc = 0x4d, .pwsz = (WCHAR *)num_6W},
+    {.vsc = 0x4e, .pwsz = (WCHAR *)num_plusW},
+    {.vsc = 0x4f, .pwsz = (WCHAR *)num_1W},
+    {.vsc = 0x50, .pwsz = (WCHAR *)num_2W},
+    {.vsc = 0x51, .pwsz = (WCHAR *)num_3W},
+    {.vsc = 0x52, .pwsz = (WCHAR *)num_0W},
+    {.vsc = 0x53, .pwsz = (WCHAR *)num_delW},
+    {.vsc = 0x54, .pwsz = (WCHAR *)sys_reqW},
+    {.vsc = 0x57, .pwsz = (WCHAR *)f11W},
+    {.vsc = 0x58, .pwsz = (WCHAR *)f12W},
+    {.vsc = 0x7c, .pwsz = (WCHAR *)f13W},
+    {.vsc = 0x7d, .pwsz = (WCHAR *)f14W},
+    {.vsc = 0x7e, .pwsz = (WCHAR *)f15W},
+    {.vsc = 0x7f, .pwsz = (WCHAR *)f16W},
+    {.vsc = 0x80, .pwsz = (WCHAR *)f17W},
+    {.vsc = 0x81, .pwsz = (WCHAR *)f18W},
+    {.vsc = 0x82, .pwsz = (WCHAR *)f19W},
+    {.vsc = 0x83, .pwsz = (WCHAR *)f20W},
+    {.vsc = 0x84, .pwsz = (WCHAR *)f21W},
+    {.vsc = 0x85, .pwsz = (WCHAR *)f22W},
+    {.vsc = 0x86, .pwsz = (WCHAR *)f23W},
+    {.vsc = 0x87, .pwsz = (WCHAR *)f24W},
+    {0},
+};
+
+static const VSC_LPWSTR key_names_ext[] =
+{
+    {.vsc = 0x1c, .pwsz = (WCHAR *)num_enterW},
+    {.vsc = 0x1d, .pwsz = (WCHAR *)right_ctrlW},
+    {.vsc = 0x35, .pwsz = (WCHAR *)num_divW},
+    {.vsc = 0x37, .pwsz = (WCHAR *)prnt_scrnW},
+    {.vsc = 0x38, .pwsz = (WCHAR *)right_altW},
+    {.vsc = 0x45, .pwsz = (WCHAR *)num_lockW},
+    {.vsc = 0x46, .pwsz = (WCHAR *)breakW},
+    {.vsc = 0x47, .pwsz = (WCHAR *)homeW},
+    {.vsc = 0x48, .pwsz = (WCHAR *)upW},
+    {.vsc = 0x49, .pwsz = (WCHAR *)page_upW},
+    {.vsc = 0x4b, .pwsz = (WCHAR *)leftW},
+    {.vsc = 0x4d, .pwsz = (WCHAR *)rightW},
+    {.vsc = 0x4f, .pwsz = (WCHAR *)endW},
+    {.vsc = 0x50, .pwsz = (WCHAR *)downW},
+    {.vsc = 0x51, .pwsz = (WCHAR *)page_downW},
+    {.vsc = 0x52, .pwsz = (WCHAR *)insertW},
+    {.vsc = 0x53, .pwsz = (WCHAR *)deleteW},
+    {.vsc = 0x54, .pwsz = (WCHAR *)zerozeroW},
+    {.vsc = 0x56, .pwsz = (WCHAR *)helpW},
+    {.vsc = 0x5b, .pwsz = (WCHAR *)left_windowsW},
+    {.vsc = 0x5c, .pwsz = (WCHAR *)right_windowsW},
+    {.vsc = 0x5d, .pwsz = (WCHAR *)applicationW},
+    {0},
+};
+
+static const USHORT vsc_to_vk[] =
+{
+    T00, T01, T02, T03, T04, T05, T06, T07,
+    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
+    T10, T11, T12, T13, T14, T15, T16, T17,
+    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
+    T20, T21, T22, T23, T24, T25, T26, T27,
+    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
+    T30, T31, T32, T33, T34, T35, T36 | KBDEXT, T37 | KBDMULTIVK,
+    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
+    T40, T41, T42, T43, T44, T45 | KBDEXT | KBDMULTIVK, T46 | KBDMULTIVK, T47 | KBDNUMPAD | KBDSPECIAL,
+    T48 | KBDNUMPAD | KBDSPECIAL, T49 | KBDNUMPAD | KBDSPECIAL, T4A, T4B | KBDNUMPAD | KBDSPECIAL,
+    T4C | KBDNUMPAD | KBDSPECIAL, T4D | KBDNUMPAD | KBDSPECIAL, T4E, T4F | KBDNUMPAD | KBDSPECIAL,
+    T50 | KBDNUMPAD | KBDSPECIAL, T51 | KBDNUMPAD | KBDSPECIAL, T52 | KBDNUMPAD | KBDSPECIAL,
+    T53 | KBDNUMPAD | KBDSPECIAL, T54, T55, T56, T57,
+    T58, T59, T5A, T5B, T5C, T5D, T5E, T5F,
+    T60, T61, T62, T63, T64, T65, T66, T67,
+    T68, T69, T6A, T6B, T6C, T6D, T6E, T6F,
+    T70, T71, T72, T73, T74, T75, T76, T77,
+    T78, T79, T7A, T7B, T7C, T7D, T7E
+};
+
+static const VSC_VK vsc_to_vk_e0[] =
+{
+    {0x10, X10 | KBDEXT},
+    {0x19, X19 | KBDEXT},
+    {0x1d, X1D | KBDEXT},
+    {0x20, X20 | KBDEXT},
+    {0x21, X21 | KBDEXT},
+    {0x22, X22 | KBDEXT},
+    {0x24, X24 | KBDEXT},
+    {0x2e, X2E | KBDEXT},
+    {0x30, X30 | KBDEXT},
+    {0x32, X32 | KBDEXT},
+    {0x35, X35 | KBDEXT},
+    {0x37, X37 | KBDEXT},
+    {0x38, X38 | KBDEXT},
+    {0x47, X47 | KBDEXT},
+    {0x48, X48 | KBDEXT},
+    {0x49, X49 | KBDEXT},
+    {0x4b, X4B | KBDEXT},
+    {0x4d, X4D | KBDEXT},
+    {0x4f, X4F | KBDEXT},
+    {0x50, X50 | KBDEXT},
+    {0x51, X51 | KBDEXT},
+    {0x52, X52 | KBDEXT},
+    {0x53, X53 | KBDEXT},
+    {0x5b, X5B | KBDEXT},
+    {0x5c, X5C | KBDEXT},
+    {0x5d, X5D | KBDEXT},
+    {0x5f, X5F | KBDEXT},
+    {0x65, X65 | KBDEXT},
+    {0x66, X66 | KBDEXT},
+    {0x67, X67 | KBDEXT},
+    {0x68, X68 | KBDEXT},
+    {0x69, X69 | KBDEXT},
+    {0x6a, X6A | KBDEXT},
+    {0x6b, X6B | KBDEXT},
+    {0x6c, X6C | KBDEXT},
+    {0x6d, X6D | KBDEXT},
+    {0x1c, X1C | KBDEXT},
+    {0x46, X46 | KBDEXT},
+    {0},
+};
+
+static const VSC_VK vsc_to_vk_e1[] =
+{
+    {0x1d, Y1D},
+    {0},
+};
+
+static const KBDTABLES kbdus_tables =
+{
+    .pCharModifiers = (MODIFIERS *)&modifiers,
+    .pVkToWcharTable = (VK_TO_WCHAR_TABLE *)vk_to_wchar_table,
+    .pKeyNames = (VSC_LPWSTR *)key_names,
+    .pKeyNamesExt = (VSC_LPWSTR *)key_names_ext,
+    .pusVSCtoVK = (USHORT *)vsc_to_vk,
+    .bMaxVSCtoVK = sizeof(vsc_to_vk) / sizeof(vsc_to_vk[0]),
+    .pVSCtoVK_E0 = (VSC_VK *)vsc_to_vk_e0,
+    .pVSCtoVK_E1 = (VSC_VK *)vsc_to_vk_e1,
+    .fLocaleFlags = MAKELONG(0, KBD_VERSION),
+};
 
 
 LONG global_key_state_counter = 0;
 
+
+static void kbd_tables_init_vsc2vk( const KBDTABLES *tables, BYTE vsc2vk[0x300] )
+{
+    const VSC_VK *entry;
+    WORD vsc;
+
+    memset( vsc2vk, 0, 0x300 );
+
+    for (vsc = 0; tables->pusVSCtoVK && vsc <= tables->bMaxVSCtoVK; ++vsc)
+    {
+        if (tables->pusVSCtoVK[vsc] == VK__none_) continue;
+        vsc2vk[vsc] = (BYTE)tables->pusVSCtoVK[vsc];
+    }
+    for (entry = tables->pVSCtoVK_E0; entry && entry->Vsc; entry++)
+    {
+        if (entry->Vk == VK__none_) continue;
+        vsc2vk[entry->Vsc + 0x100] = (BYTE)entry->Vk;
+    }
+    for (entry = tables->pVSCtoVK_E1; entry && entry->Vsc; entry++)
+    {
+        if (entry->Vk == VK__none_) continue;
+        vsc2vk[entry->Vsc + 0x200] = (BYTE)entry->Vk;
+    }
+}
+
+#define NEXT_ENTRY(t, e) ((void *)&(e)->wch[(t)->nModifications])
+
+static void kbd_tables_init_vk2char( const KBDTABLES *tables, BYTE vk2char[0x100] )
+{
+    const VK_TO_WCHAR_TABLE *table;
+    const VK_TO_WCHARS1 *entry;
+
+    memset( vk2char, 0, 0x100 );
+
+    for (table = tables->pVkToWcharTable; table->pVkToWchars; table++)
+    {
+        for (entry = table->pVkToWchars; entry->VirtualKey; entry = NEXT_ENTRY(table, entry))
+        {
+            if (entry->VirtualKey & ~0xff) continue;
+            vk2char[entry->VirtualKey] = entry->wch[0];
+        }
+    }
+}
+
+static UINT kbd_tables_get_mod_bits( const KBDTABLES *tables, UINT mod )
+{
+    const MODIFIERS *mods = tables->pCharModifiers;
+    WORD bits;
+
+    for (bits = 0; bits <= mods->wMaxModBits; ++bits)
+        if (mods->ModNumber[bits] == mod) return bits;
+
+    return -1;
+}
+
+static UINT kbd_tables_get_mod_num( const KBDTABLES *tables, const BYTE *state, BOOL caps )
+{
+    const MODIFIERS *mods = tables->pCharModifiers;
+    const VK_TO_BIT *entry;
+    WORD bits = 0;
+
+    for (entry = mods->pVkToBit; entry->Vk; ++entry)
+        if (state[entry->Vk] & 0x80) bits |= entry->ModBits;
+    if (caps) bits |= KBDSHIFT;
+
+    if (bits > mods->wMaxModBits) return -1;
+    return mods->ModNumber[bits];
+}
+
+static WORD kbd_tables_wchar_to_vkey( const KBDTABLES *tables, WCHAR wch )
+{
+    const VK_TO_WCHAR_TABLE *table;
+    const VK_TO_WCHARS1 *entry;
+    WORD bits;
+    BYTE mod;
+
+    if (wch == '\x001b') return VK_ESCAPE;
+
+    for (table = tables->pVkToWcharTable; table->pVkToWchars; table++)
+    {
+        for (entry = table->pVkToWchars; entry->VirtualKey; entry = NEXT_ENTRY(table, entry))
+        {
+            for (mod = 0; mod < table->nModifications; ++mod)
+            {
+                if (entry->wch[mod] == WCH_NONE || entry->wch[mod] != wch) continue;
+                bits = kbd_tables_get_mod_bits( tables, mod );
+                return (bits << 8) | entry->VirtualKey;
+            }
+        }
+    }
+
+    if (wch >= 0x0001 && wch <= 0x001a) return (0x200) | ('A' + wch - 1);  /* CTRL + A-Z */
+    return wch >= 0x0080 ? -1 : 0;
+}
+
+static WCHAR kbd_tables_vkey_to_wchar( const KBDTABLES *tables, UINT vkey, const BYTE *state )
+{
+    UINT mod, caps_mod, alt, ctrl, caps;
+    const VK_TO_WCHAR_TABLE *table;
+    const VK_TO_WCHARS1 *entry;
+
+    alt = state[VK_MENU] & 0x80;
+    ctrl = state[VK_CONTROL] & 0x80;
+    caps = state[VK_CAPITAL] & 1;
+
+    if (ctrl && alt) return WCH_NONE;
+    if (!ctrl && vkey == VK_ESCAPE) return VK_ESCAPE;
+
+    mod = caps_mod = kbd_tables_get_mod_num( tables, state, FALSE );
+    if (caps) caps_mod = kbd_tables_get_mod_num( tables, state, TRUE );
+
+    for (table = tables->pVkToWcharTable; table->pVkToWchars; table++)
+    {
+        if (table->nModifications <= mod) continue;
+        for (entry = table->pVkToWchars; entry->VirtualKey; entry = NEXT_ENTRY(table, entry))
+        {
+            if (entry->VirtualKey != vkey) continue;
+            if ((entry->Attributes & CAPLOK) && table->nModifications > caps_mod) return entry->wch[caps_mod];
+            return entry->wch[mod];
+        }
+    }
+
+    if (ctrl && vkey >= 'A' && vkey <= 'Z') return vkey - 'A' + 1;
+    return WCH_NONE;
+}
+
+#undef NEXT_ENTRY
+
 /**********************************************************************
  *	     NtUserAttachThreadInput    (win32u.@)
  */
@@ -268,8 +750,7 @@ BOOL WINAPI NtUserGetCursorInfo( CURSORINFO *info )
 
 static void check_for_events( UINT flags )
 {
-    LARGE_INTEGER zero = { .QuadPart = 0 };
-    if (user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, &zero, flags, 0 ) == WAIT_TIMEOUT)
+    if (!user_driver->pProcessEvents( flags ))
         flush_window_surfaces( TRUE );
 }
 
@@ -493,197 +974,34 @@ BOOL WINAPI NtUserSetKeyboardState( BYTE *state )
  */
 WORD WINAPI NtUserVkKeyScanEx( WCHAR chr, HKL layout )
 {
-    WORD shift = 0x100, ctrl = 0x200;
+    const KBDTABLES *kbd_tables = &kbdus_tables;
     SHORT ret;
 
     TRACE_(keyboard)( "chr %s, layout %p\n", debugstr_wn(&chr, 1), layout );
 
     if ((ret = user_driver->pVkKeyScanEx( chr, layout )) != -256) return ret;
-
-    /* FIXME: English keyboard layout specific */
-
-    if (chr == VK_CANCEL || chr == VK_BACK || chr == VK_TAB || chr == VK_RETURN ||
-        chr == VK_ESCAPE || chr == VK_SPACE) ret = chr;
-    else if (chr >= '0' && chr <= '9') ret = chr;
-    else if (chr == ')') ret = shift + '0';
-    else if (chr == '!') ret = shift + '1';
-    else if (chr == '@') ret = shift + '2';
-    else if (chr == '#') ret = shift + '3';
-    else if (chr == '$') ret = shift + '4';
-    else if (chr == '%') ret = shift + '5';
-    else if (chr == '^') ret = shift + '6';
-    else if (chr == '&') ret = shift + '7';
-    else if (chr == '*') ret = shift + '8';
-    else if (chr == '(') ret = shift + '9';
-    else if (chr >= 'a' && chr <= 'z') ret = chr - 'a' + 'A';
-    else if (chr >= 'A' && chr <= 'Z') ret = shift + chr;
-    else if (chr == ';') ret = VK_OEM_1;
-    else if (chr == '=') ret = VK_OEM_PLUS;
-    else if (chr == ',') ret = VK_OEM_COMMA;
-    else if (chr == '-') ret = VK_OEM_MINUS;
-    else if (chr == '.') ret = VK_OEM_PERIOD;
-    else if (chr == '/') ret = VK_OEM_2;
-    else if (chr == '`') ret = VK_OEM_3;
-    else if (chr == '[') ret = VK_OEM_4;
-    else if (chr == '\\') ret = VK_OEM_5;
-    else if (chr == ']') ret = VK_OEM_6;
-    else if (chr == '\'') ret = VK_OEM_7;
-    else if (chr == ':') ret = shift + VK_OEM_1;
-    else if (chr == '+') ret = shift + VK_OEM_PLUS;
-    else if (chr == '<') ret = shift + VK_OEM_COMMA;
-    else if (chr == '_') ret = shift + VK_OEM_MINUS;
-    else if (chr == '>') ret = shift + VK_OEM_PERIOD;
-    else if (chr == '?') ret = shift + VK_OEM_2;
-    else if (chr == '~') ret = shift + VK_OEM_3;
-    else if (chr == '{') ret = shift + VK_OEM_4;
-    else if (chr == '|') ret = shift + VK_OEM_5;
-    else if (chr == '}') ret = shift + VK_OEM_6;
-    else if (chr == '\"') ret = shift + VK_OEM_7;
-    else if (chr == 0x7f) ret = ctrl + VK_BACK;
-    else if (chr == '\n') ret = ctrl + VK_RETURN;
-    else if (chr == 0xf000) ret = ctrl + '2';
-    else if (chr == 0x0000) ret = ctrl + shift + '2';
-    else if (chr >= 0x0001 && chr <= 0x001a) ret = ctrl + 'A' + chr - 1;
-    else if (chr >= 0x001c && chr <= 0x001d) ret = ctrl + VK_OEM_3 + chr;
-    else if (chr == 0x001e) ret = ctrl + shift + '6';
-    else if (chr == 0x001f) ret = ctrl + shift + VK_OEM_MINUS;
-    else ret = -1;
+    ret = kbd_tables_wchar_to_vkey( kbd_tables, chr );
 
     TRACE_(keyboard)( "ret %04x\n", ret );
     return ret;
 }
 
-/* English keyboard layout (0x0409) */
-static const UINT kbd_en_vsc2vk[] =
-{
-    0x00, 0x1b, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0xbd, 0xbb, 0x08, 0x09,
-    0x51, 0x57, 0x45, 0x52, 0x54, 0x59, 0x55, 0x49, 0x4f, 0x50, 0xdb, 0xdd, 0x0d, 0xa2, 0x41, 0x53,
-    0x44, 0x46, 0x47, 0x48, 0x4a, 0x4b, 0x4c, 0xba, 0xde, 0xc0, 0xa0, 0xdc, 0x5a, 0x58, 0x43, 0x56,
-    0x42, 0x4e, 0x4d, 0xbc, 0xbe, 0xbf, 0xa1, 0x6a, 0xa4, 0x20, 0x14, 0x70, 0x71, 0x72, 0x73, 0x74,
-    0x75, 0x76, 0x77, 0x78, 0x79, 0x90, 0x91, 0x24, 0x26, 0x21, 0x6d, 0x25, 0x0c, 0x27, 0x6b, 0x23,
-    0x28, 0x22, 0x2d, 0x2e, 0x2c, 0x00, 0xe2, 0x7a, 0x7b, 0x0c, 0xee, 0xf1, 0xea, 0xf9, 0xf5, 0xf3,
-    0x00, 0x00, 0xfb, 0x2f, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0xed,
-    0x00, 0xe9, 0x00, 0xc1, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x09, 0x00, 0xc2, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    /* 0xe000 */
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x0d, 0xa3, 0x00, 0x00,
-    0xad, 0xb7, 0xb3, 0x00, 0xb2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x00,
-    0xaf, 0x00, 0xac, 0x00, 0x00, 0x6f, 0x00, 0x2c, 0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x24, 0x26, 0x21, 0x00, 0x25, 0x00, 0x27, 0x00, 0x23,
-    0x28, 0x22, 0x2d, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x5c, 0x5d, 0x00, 0x5f,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xab, 0xa8, 0xa9, 0xa7, 0xa6, 0xb6, 0xb4, 0xb5, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    /* 0xe100 */
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
-
-static const UINT kbd_en_vk2char[] =
-{
-    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00,
-     ' ', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-     '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7', '8',  '9', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00,  'A',  'B',  'C',  'D',  'E',  'F',  'G', 'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
-     'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W', 'X',  'Y',  'Z', 0x00, 0x00, 0x00, 0x00, 0x00,
-     '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7', '8',  '9',  '*',  '+', 0x00,  '-',  '.',  '/',
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  ';',  '=',  ',',  '-',  '.',  '/',
-     '`', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  '[', '\\',  ']', '\'', 0x00,
-    0x00, 0x00, '\\', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
-
-static const char *kbd_en_vscname[] =
-{
-    0, "Esc", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Backspace", "Tab",
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Enter", "Ctrl", 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Shift", 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, "Right Shift", "Num *", "Alt", "Space", "Caps Lock", "F1", "F2", "F3", "F4", "F5",
-    "F6", "F7", "F8", "F9", "F10", "Pause", "Scroll Lock", "Num 7", "Num 8", "Num 9", "Num -", "Num 4", "Num 5", "Num 6", "Num +", "Num 1",
-    "Num 2", "Num 3", "Num 0", "Num Del", "Sys Req", 0, 0, "F11", "F12", 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "F13", "F14", "F15", "F16",
-    "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    /* extended */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Num Enter", "Right Ctrl", 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, "Num /", 0, "Prnt Scrn", "Right Alt", 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, "Num Lock", "Break", "Home", "Up", "Page Up", 0, "Left", 0, "Right", 0, "End",
-    "Down", "Page Down", "Insert", "Delete", "<00>", 0, "Help", 0, 0, 0, 0, "Left Windows", "Right Windows", "Application", 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-};
 
 /******************************************************************************
  *	     NtUserMapVirtualKeyEx    (win32u.@)
  */
 UINT WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout )
 {
-    const UINT *vsc2vk, *vk2char;
-    UINT vsc2vk_size, vk2char_size;
+    const KBDTABLES *kbd_tables = &kbdus_tables;
+    BYTE vsc2vk[0x300], vk2char[0x100];
     UINT ret;
 
     TRACE_(keyboard)( "code %u, type %u, layout %p.\n", code, type, layout );
 
     if ((ret = user_driver->pMapVirtualKeyEx( code, type, layout )) != -1) return ret;
 
-    /* FIXME: English keyboard layout specific */
-
-    vsc2vk = kbd_en_vsc2vk;
-    vsc2vk_size = ARRAYSIZE(kbd_en_vsc2vk);
-    vk2char = kbd_en_vk2char;
-    vk2char_size = ARRAYSIZE(kbd_en_vk2char);
+    kbd_tables_init_vsc2vk( kbd_tables, vsc2vk );
+    kbd_tables_init_vk2char( kbd_tables, vk2char );
 
     switch (type)
     {
@@ -707,8 +1025,8 @@ UINT WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout )
         case VK_DECIMAL: code = VK_DELETE; break;
         }
 
-        for (ret = 0; ret < vsc2vk_size; ++ret) if (vsc2vk[ret] == code) break;
-        if (ret >= vsc2vk_size) ret = 0;
+        for (ret = 0; ret < ARRAY_SIZE(vsc2vk); ++ret) if (vsc2vk[ret] == code) break;
+        if (ret >= ARRAY_SIZE(vsc2vk)) ret = 0;
 
         if (type == MAPVK_VK_TO_VSC)
         {
@@ -720,7 +1038,7 @@ UINT WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout )
     case MAPVK_VSC_TO_VK:
     case MAPVK_VSC_TO_VK_EX:
         if (code & 0xe000) code -= 0xdf00;
-        if (code >= vsc2vk_size) ret = 0;
+        if (code >= ARRAY_SIZE(vsc2vk)) ret = 0;
         else ret = vsc2vk[code];
 
         if (type == MAPVK_VSC_TO_VK)
@@ -734,7 +1052,8 @@ UINT WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout )
         }
         break;
     case MAPVK_VK_TO_CHAR:
-        if (code >= vk2char_size) ret = 0;
+        if (code >= ARRAY_SIZE(vk2char)) ret = 0;
+        else if (code >= 'A' && code <= 'Z') ret = code;
         else ret = vk2char[code];
         break;
     default:
@@ -752,21 +1071,16 @@ UINT WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout )
 INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
 {
     INT code = ((lparam >> 16) & 0x1ff), vkey, len;
-    UINT vsc2vk_size, vscname_size;
-    const char *const *vscname;
-    const UINT *vsc2vk;
+    const KBDTABLES *kbd_tables = &kbdus_tables;
+    VSC_LPWSTR *key_name;
+    BYTE vsc2vk[0x300];
 
-    TRACE_(keyboard)( "lparam %d, buffer %p, size %d.\n", (int)lparam, buffer, size );
+    TRACE_(keyboard)( "lparam %#x, buffer %p, size %d.\n", (int)lparam, buffer, size );
 
     if (!buffer || !size) return 0;
     if ((len = user_driver->pGetKeyNameText( lparam, buffer, size )) >= 0) return len;
 
-    /* FIXME: English keyboard layout specific */
-
-    vsc2vk = kbd_en_vsc2vk;
-    vsc2vk_size = ARRAYSIZE(kbd_en_vsc2vk);
-    vscname = kbd_en_vscname;
-    vscname_size = ARRAYSIZE(kbd_en_vscname);
+    kbd_tables_init_vsc2vk( kbd_tables, vsc2vk );
 
     if (lparam & 0x2000000)
     {
@@ -775,26 +1089,27 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
         case VK_RSHIFT:
         case VK_RCONTROL:
         case VK_RMENU:
-            for (code = 0; code < vsc2vk_size; ++code)
+            for (code = 0; code < ARRAY_SIZE(vsc2vk); ++code)
                 if (vsc2vk[code] == (vkey - 1)) break;
             break;
         }
     }
 
-    if (code < vscname_size)
+    if (code < 0x100) key_name = kbd_tables->pKeyNames;
+    else key_name = kbd_tables->pKeyNamesExt;
+    while (key_name->vsc && key_name->vsc != (BYTE)code) key_name++;
+
+    if (key_name->vsc == (BYTE)code)
     {
-        if (vscname[code])
-        {
-            len = min( size - 1, strlen(vscname[code]) );
-            ascii_to_unicode( buffer, vscname[code], len );
-        }
-        else if (size > 1)
-        {
-            HKL hkl = NtUserGetKeyboardLayout( 0 );
-            vkey = NtUserMapVirtualKeyEx( code & 0xff, MAPVK_VSC_TO_VK, hkl );
-            buffer[0] = NtUserMapVirtualKeyEx( vkey, MAPVK_VK_TO_CHAR, hkl );
-            len = 1;
-        }
+        len = min( size - 1, wcslen( key_name->pwsz ) );
+        memcpy( buffer, key_name->pwsz, len * sizeof(WCHAR) );
+    }
+    else if (size > 1)
+    {
+        HKL hkl = NtUserGetKeyboardLayout( 0 );
+        vkey = NtUserMapVirtualKeyEx( code & 0xff, MAPVK_VSC_TO_VK, hkl );
+        buffer[0] = NtUserMapVirtualKeyEx( vkey, MAPVK_VK_TO_CHAR, hkl );
+        len = 1;
     }
     buffer[len] = 0;
 
@@ -808,86 +1123,23 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
 INT WINAPI NtUserToUnicodeEx( UINT virt, UINT scan, const BYTE *state,
                               WCHAR *str, int size, UINT flags, HKL layout )
 {
-    BOOL shift, ctrl, alt, numlock;
-    WCHAR buffer[2];
+    const KBDTABLES *kbd_tables = &kbdus_tables;
+    WCHAR buffer[2] = {0};
     INT len;
 
-    TRACE_(keyboard)( "virt %u, scan %u, state %p, str %p, size %d, flags %x, layout %p.\n",
+    TRACE_(keyboard)( "virt %#x, scan %#x, state %p, str %p, size %d, flags %#x, layout %p.\n",
                       virt, scan, state, str, size, flags, layout );
 
     if (!state) return 0;
     if ((len = user_driver->pToUnicodeEx( virt, scan, state, str, size, flags, layout )) >= -1)
         return len;
 
-    alt = state[VK_MENU] & 0x80;
-    shift = state[VK_SHIFT] & 0x80;
-    ctrl = state[VK_CONTROL] & 0x80;
-    numlock = state[VK_NUMLOCK] & 0x01;
+    if (scan & 0x8000) buffer[0] = 0; /* key up */
+    else buffer[0] = kbd_tables_vkey_to_wchar( kbd_tables, virt, state );
 
-    /* FIXME: English keyboard layout specific */
+    if (buffer[0] != WCH_NONE) len = 1;
+    else buffer[0] = len = 0;
 
-    if (scan & 0x8000) buffer[0] = 0; /* key up */
-    else if (virt == VK_ESCAPE) buffer[0] = VK_ESCAPE;
-    else if (!ctrl)
-    {
-        switch (virt)
-        {
-        case VK_BACK:       buffer[0] = '\b'; break;
-        case VK_OEM_1:      buffer[0] = shift ? ':' : ';'; break;
-        case VK_OEM_2:      buffer[0] = shift ? '?' : '/'; break;
-        case VK_OEM_3:      buffer[0] = shift ? '~' : '`'; break;
-        case VK_OEM_4:      buffer[0] = shift ? '{' : '['; break;
-        case VK_OEM_5:      buffer[0] = shift ? '|' : '\\'; break;
-        case VK_OEM_6:      buffer[0] = shift ? '}' : ']'; break;
-        case VK_OEM_7:      buffer[0] = shift ? '"' : '\''; break;
-        case VK_OEM_COMMA:  buffer[0] = shift ? '<' : ','; break;
-        case VK_OEM_MINUS:  buffer[0] = shift ? '_' : '-'; break;
-        case VK_OEM_PERIOD: buffer[0] = shift ? '>' : '.'; break;
-        case VK_OEM_PLUS:   buffer[0] = shift ? '+' : '='; break;
-        case VK_RETURN:     buffer[0] = '\r'; break;
-        case VK_SPACE:      buffer[0] = ' '; break;
-        case VK_TAB:        buffer[0] = '\t'; break;
-        case VK_MULTIPLY:   buffer[0] = '*'; break;
-        case VK_ADD:        buffer[0] = '+'; break;
-        case VK_SUBTRACT:   buffer[0] = '-'; break;
-        case VK_DIVIDE:     buffer[0] = '/'; break;
-        default:
-            if (virt >= '0' && virt <= '9')
-                buffer[0] = shift ? ")!@#$%^&*("[virt - '0'] : virt;
-            else if (virt >= 'A' && virt <= 'Z')
-                buffer[0] = shift || (state[VK_CAPITAL] & 0x01) ? virt : virt + 'a' - 'A';
-            else if (virt >= VK_NUMPAD0 && virt <= VK_NUMPAD9 && numlock && !shift)
-                buffer[0] = '0' + virt - VK_NUMPAD0;
-            else if (virt == VK_DECIMAL && numlock && !shift)
-                buffer[0] = '.';
-            else
-                buffer[0] = 0;
-            break;
-        }
-    }
-    else if (!alt) /* Control codes */
-    {
-        switch (virt)
-        {
-        case VK_OEM_4:     buffer[0] = 0x1b; break;
-        case VK_OEM_5:     buffer[0] = 0x1c; break;
-        case VK_OEM_6:     buffer[0] = 0x1d; break;
-        case '6':          buffer[0] = shift ? 0x1e : 0; break;
-        case VK_OEM_MINUS: buffer[0] = shift ? 0x1f : 0; break;
-        case VK_BACK:      buffer[0] = 0x7f; break;
-        case VK_RETURN:    buffer[0] = shift ? 0 : '\n'; break;
-        case '2':          buffer[0] = shift ? 0xffff : 0xf000; break;
-        case VK_SPACE:     buffer[0] = ' '; break;
-        default:
-            if (virt >= 'A' && virt <= 'Z') buffer[0] = virt - 'A' + 1;
-            else buffer[0] = 0;
-            break;
-        }
-    }
-    else buffer[0] = 0;
-    buffer[1] = 0;
-    len = lstrlenW( buffer );
-    if (buffer[0] == 0xffff) buffer[0] = 0;
     lstrcpynW( str, buffer, size );
 
     TRACE_(keyboard)( "ret %d, str %s.\n", len, debugstr_w(str) );
@@ -1780,7 +2032,7 @@ BOOL set_foreground_window( HWND hwnd, BOOL mouse )
     return ret;
 }
 
-struct
+static struct
 {
     HBITMAP bitmap;
     unsigned int timeout;
@@ -2153,6 +2405,39 @@ void toggle_caret( HWND hwnd )
     if (ret && !hidden) display_caret( hwnd, &r );
 }
 
+
+/**********************************************************************
+ *       NtUserEnableMouseInPointer    (win32u.@)
+ */
+BOOL WINAPI NtUserEnableMouseInPointer( BOOL enable )
+{
+    FIXME( "enable %u stub!\n", enable );
+    RtlSetLastWin32Error( ERROR_CALL_NOT_IMPLEMENTED );
+    return FALSE;
+}
+
+/**********************************************************************
+ *       NtUserIsMouseInPointerEnabled    (win32u.@)
+ */
+BOOL WINAPI NtUserIsMouseInPointerEnabled(void)
+{
+    FIXME( "stub!\n" );
+    RtlSetLastWin32Error( ERROR_CALL_NOT_IMPLEMENTED );
+    return FALSE;
+}
+
+/**********************************************************************
+ *       NtUserGetPointerInfoList    (win32u.@)
+ */
+BOOL WINAPI NtUserGetPointerInfoList( UINT32 id, POINTER_INPUT_TYPE type, UINT_PTR unk0, UINT_PTR unk1, SIZE_T size,
+                                      UINT32 *entry_count, UINT32 *pointer_count, void *pointer_info )
+{
+    FIXME( "id %#x, type %#x, unk0 %#zx, unk1 %#zx, size %#zx, entry_count %p, pointer_count %p, pointer_info %p stub!\n",
+           id, (int)type, unk0, unk1, (size_t)size, entry_count, pointer_count, pointer_info );
+    RtlSetLastWin32Error( ERROR_CALL_NOT_IMPLEMENTED );
+    return FALSE;
+}
+
 HWND get_shell_window(void)
 {
     HWND hwnd = 0;
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index f439b7da23b..7e3b5acbc95 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -33,7 +33,7 @@
 #include "hidusage.h"
 #include "dbt.h"
 #include "dde.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 
@@ -2086,9 +2086,8 @@ static inline void check_for_driver_events( UINT msg )
 {
     if (get_user_thread_info()->message_count > 200)
     {
-        LARGE_INTEGER zero = { .QuadPart = 0 };
         flush_window_surfaces( FALSE );
-        user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, &zero, QS_ALLINPUT, 0 );
+        user_driver->pProcessEvents( QS_ALLINPUT );
     }
     else if (msg == WM_TIMER || msg == WM_SYSTIMER)
     {
@@ -2117,13 +2116,20 @@ static DWORD wait_message( DWORD count, const HANDLE *handles, DWORD timeout, DW
     if (enable_thunk_lock)
         lock = KeUserModeCallback( NtUserThunkLock, NULL, 0, &ret_ptr, &ret_len );
 
-    ret = user_driver->pMsgWaitForMultipleObjectsEx( count, handles, get_nt_timeout( &time, timeout ),
-                                                     mask, flags );
-    if (HIWORD(ret))  /* is it an error code? */
+    if (user_driver->pProcessEvents( mask )) ret = count ? count - 1 : 0;
+    else if (count)
     {
-        RtlSetLastWin32Error( RtlNtStatusToDosError(ret) );
-        ret = WAIT_FAILED;
+        ret = NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
+                                        !!(flags & MWMO_ALERTABLE), get_nt_timeout( &time, timeout ));
+        if (ret == count - 1) user_driver->pProcessEvents( mask );
+        else if (HIWORD(ret)) /* is it an error code? */
+        {
+            RtlSetLastWin32Error( RtlNtStatusToDosError(ret) );
+            ret = WAIT_FAILED;
+        }
     }
+    else ret = WAIT_TIMEOUT;
+
     if (ret == WAIT_TIMEOUT && !count && !timeout) NtYieldExecution();
     if ((mask & QS_INPUT) == QS_INPUT) get_user_thread_info()->message_count = 0;
 
@@ -2929,8 +2935,8 @@ static BOOL map_wparam_AtoW( UINT message, WPARAM *wparam, enum wm_char_mapping
  *
  * Call a window procedure, translating args from Ansi to Unicode.
  */
-LRESULT call_messageAtoW( winproc_callback_t callback, HWND hwnd, UINT msg, WPARAM wparam,
-                          LPARAM lparam, LRESULT *result, void *arg, enum wm_char_mapping mapping )
+static LRESULT call_messageAtoW( winproc_callback_t callback, HWND hwnd, UINT msg, WPARAM wparam,
+                                 LPARAM lparam, LRESULT *result, void *arg, enum wm_char_mapping mapping )
 {
     LRESULT ret = 0;
 
@@ -3388,6 +3394,20 @@ static BOOL send_message_callback( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lp
     return process_message( &info, NULL, ansi );
 }
 
+/***********************************************************************
+ *		     __wine_send_internal_message_timeout  (win32u.@)
+ *
+ * Same as SendMessageTimeoutW but sends the message to a specific thread
+ * without requiring a window handle. Only works for internal Wine messages.
+ */
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    return send_internal_message_timeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                          flags, timeout, res_ptr );
+}
+
 /***********************************************************************
  *           NtUserPostMessage  (win32u.@)
  */
diff --git a/dlls/win32u/ntgdi_private.h b/dlls/win32u/ntgdi_private.h
index be3e4d8cd56..ce5e30ab07d 100644
--- a/dlls/win32u/ntgdi_private.h
+++ b/dlls/win32u/ntgdi_private.h
@@ -152,7 +152,7 @@ extern DWORD stretch_bits( const BITMAPINFO *src_info, struct bitblt_coords *src
 extern void get_mono_dc_colors( DC *dc, int color_table_size, BITMAPINFO *info, int count ) DECLSPEC_HIDDEN;
 
 /* brush.c */
-extern HBRUSH create_brush( const LOGBRUSH *brush );
+extern HBRUSH create_brush( const LOGBRUSH *brush ) DECLSPEC_HIDDEN;
 extern BOOL store_brush_pattern( LOGBRUSH *brush, struct brush_pattern *pattern ) DECLSPEC_HIDDEN;
 extern void free_brush_pattern( struct brush_pattern *pattern ) DECLSPEC_HIDDEN;
 
@@ -160,7 +160,7 @@ extern void free_brush_pattern( struct brush_pattern *pattern ) DECLSPEC_HIDDEN;
 extern BOOL clip_device_rect( DC *dc, RECT *dst, const RECT *src ) DECLSPEC_HIDDEN;
 extern BOOL clip_visrect( DC *dc, RECT *dst, const RECT *src ) DECLSPEC_HIDDEN;
 extern void set_visible_region( HDC hdc, HRGN hrgn, const RECT *vis_rect,
-                                const RECT *device_rect, struct window_surface *surface );
+                                const RECT *device_rect, struct window_surface *surface ) DECLSPEC_HIDDEN;
 extern void update_dc_clipping( DC * dc ) DECLSPEC_HIDDEN;
 
 /* Return the total DC region (if any) */
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 4e13822c6fb..385e7c0ded5 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -253,7 +253,7 @@ static inline UINT win_get_flags( HWND hwnd )
 }
 
 WND *get_win_ptr( HWND hwnd ) DECLSPEC_HIDDEN;
-BOOL is_child( HWND parent, HWND child );
+BOOL is_child( HWND parent, HWND child ) DECLSPEC_HIDDEN;
 BOOL is_window( HWND hwnd ) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_NTUSER_PRIVATE_H */
diff --git a/dlls/win32u/rawinput.c b/dlls/win32u/rawinput.c
index ab1252ccea6..1ddbca0896a 100644
--- a/dlls/win32u/rawinput.c
+++ b/dlls/win32u/rawinput.c
@@ -671,10 +671,20 @@ UINT WINAPI NtUserGetRawInputBuffer( RAWINPUT *data, UINT *data_size, UINT heade
         if (!rawinput_from_hardware_message( data, msg_data )) break;
         if (overhead)
         {
+            /* Under WoW64, GetRawInputBuffer always gives 64-bit RAWINPUT structs. */
+            RAWINPUT64 *ri64 = (RAWINPUT64 *)data;
             memmove( (char *)&data->data + overhead, &data->data,
                      data->header.dwSize - sizeof(RAWINPUTHEADER) );
+            ri64->header.dwSize += overhead;
+
+            /* Need to copy wParam before hDevice so it's not overwritten. */
+            ri64->header.wParam = data->header.wParam;
+#ifdef _WIN64
+            ri64->header.hDevice = data->header.hDevice;
+#else
+            ri64->header.hDevice = HandleToULong(data->header.hDevice);
+#endif
         }
-        data->header.dwSize += overhead;
         remaining -= data->header.dwSize;
         data = NEXTRAWINPUTBLOCK(data);
         msg_data = (struct hardware_msg_data *)((char *)msg_data + msg_data->size);
diff --git a/dlls/win32u/scroll.c b/dlls/win32u/scroll.c
index ce3af5189d3..19a9a1379f4 100644
--- a/dlls/win32u/scroll.c
+++ b/dlls/win32u/scroll.c
@@ -282,7 +282,7 @@ static BOOL get_scroll_bar_rect( HWND hwnd, int bar, RECT *rect, int *arrow_size
  *
  * Redraw the whole scrollbar.
  */
-void draw_scroll_bar( HWND hwnd, HDC hdc, int bar, enum SCROLL_HITTEST hit_test,
+static void draw_scroll_bar( HWND hwnd, HDC hdc, int bar, enum SCROLL_HITTEST hit_test,
                       const struct SCROLL_TRACKING_INFO *tracking_info, BOOL draw_arrows,
                       BOOL draw_interior )
 {
diff --git a/dlls/win32u/syscall.c b/dlls/win32u/syscall.c
index 32812a3d881..9020aa01126 100644
--- a/dlls/win32u/syscall.c
+++ b/dlls/win32u/syscall.c
@@ -145,6 +145,7 @@ static void * const syscalls[] =
     NtUserDrawIconEx,
     NtUserEmptyClipboard,
     NtUserEnableMenuItem,
+    NtUserEnableMouseInPointer,
     NtUserEnableScrollBar,
     NtUserEndDeferWindowPosEx,
     NtUserEndMenu,
@@ -192,6 +193,7 @@ static void * const syscalls[] =
     NtUserGetMouseMovePointsEx,
     NtUserGetObjectInformation,
     NtUserGetOpenClipboardWindow,
+    NtUserGetPointerInfoList,
     NtUserGetPriorityClipboardFormat,
     NtUserGetProcessDpiAwarenessContext,
     NtUserGetProcessWindowStation,
@@ -221,6 +223,7 @@ static void * const syscalls[] =
     NtUserInvalidateRect,
     NtUserInvalidateRgn,
     NtUserIsClipboardFormatAvailable,
+    NtUserIsMouseInPointerEnabled,
     NtUserKillTimer,
     NtUserLockWindowUpdate,
     NtUserLogicalToPerMonitorDPIPhysicalPoint,
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 2269193b7ff..bcdb8c5103b 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -170,6 +170,7 @@ static const WCHAR monitorW[] = {'M','o','n','i','t','o','r',0};
 static const WCHAR yesW[] = {'Y','e','s',0};
 static const WCHAR noW[] = {'N','o',0};
 static const WCHAR mode_countW[] = {'M','o','d','e','C','o','u','n','t',0};
+static const WCHAR edidW[] = {'E','D','I','D',0};
 
 static const char  guid_devclass_displayA[] = "{4D36E968-E325-11CE-BFC1-08002BE10318}";
 static const WCHAR guid_devclass_displayW[] =
@@ -218,6 +219,18 @@ struct adapter
     DEVMODEW *modes;
 };
 
+#define MONITOR_INFO_HAS_MONITOR_ID 0x00000001
+#define MONITOR_INFO_HAS_MONITOR_NAME 0x00000002
+struct edid_monitor_info
+{
+    unsigned int flags;
+    /* MONITOR_INFO_HAS_MONITOR_ID */
+    unsigned short manufacturer, product_code;
+    char monitor_id_string[8];
+    /* MONITOR_INFO_HAS_MONITOR_NAME */
+    WCHAR monitor_name[14];
+};
+
 struct monitor
 {
     struct list entry;
@@ -230,6 +243,7 @@ struct monitor
     RECT rc_monitor;
     RECT rc_work;
     BOOL is_clone;
+    struct edid_monitor_info edid_info;
 };
 
 static struct list adapters = LIST_INIT(adapters);
@@ -438,6 +452,46 @@ static void adapter_release( struct adapter *adapter )
 
 C_ASSERT(sizeof(DEVMODEW) - offsetof(DEVMODEW, dmFields) == 0x94);
 
+static void get_monitor_info_from_edid( struct edid_monitor_info *info, const unsigned char *edid, unsigned int edid_len )
+{
+    unsigned int i, j;
+    unsigned short w;
+    unsigned char d;
+    const char *s;
+
+    info->flags = 0;
+    if (!edid || edid_len < 128) return;
+
+    w = (edid[8] << 8) | edid[9]; /* Manufacturer ID, big endian. */
+    for (i = 0; i < 3; ++i)
+    {
+        d = w & 0x1f;
+        if (!d || d - 1 > 'Z' - 'A') return;
+        info->monitor_id_string[2 - i] = 'A' + d - 1;
+        w >>= 5;
+    }
+    if (w) return;
+    w = edid[10] | (edid[11] << 8); /* Product code, little endian. */
+    info->manufacturer = *(unsigned short *)(edid + 8);
+    info->product_code = w;
+    sprintf( info->monitor_id_string + 3, "%04X", w );
+    info->flags = MONITOR_INFO_HAS_MONITOR_ID;
+    TRACE( "Monitor id %s.\n", info->monitor_id_string );
+
+    for (i = 0; i < 4; ++i)
+    {
+        if (edid[54 + i * 18 + 3] != 0xfc) continue;
+        /* "Display name" ASCII descriptor. */
+        s = (const char *)&edid[54 + i * 18 + 5];
+        for (j = 0; s[j] && j < 13; ++j)
+            info->monitor_name[j] = s[j];
+        while (j && isspace(s[j - 1])) --j;
+        info->monitor_name[j] = 0;
+        info->flags |= MONITOR_INFO_HAS_MONITOR_NAME;
+        break;
+    }
+}
+
 static BOOL write_adapter_mode( HKEY adapter_key, UINT index, const DEVMODEW *mode )
 {
     WCHAR bufferW[MAX_PATH] = {0};
@@ -717,7 +771,7 @@ static BOOL read_monitor_settings( struct adapter *adapter, UINT index, struct m
     char buffer[4096];
     KEY_VALUE_PARTIAL_INFORMATION *value = (void *)buffer;
     WCHAR *device_name, *value_str = (WCHAR *)value->Data, *ptr;
-    HKEY hkey;
+    HKEY hkey, subkey;
     DWORD size, len;
 
     monitor->flags = adapter->id ? 0 : MONITORINFOF_PRIMARY;
@@ -824,6 +878,14 @@ static BOOL read_monitor_settings( struct adapter *adapter, UINT index, struct m
     monitor->dev.device_id[size++] = '\\';
     lstrcpyW( monitor->dev.device_id + size, device_name );
 
+    /* EDID */
+    if ((subkey = reg_open_key( hkey, device_parametersW, sizeof(device_parametersW) )))
+    {
+        if (query_reg_value( subkey, edidW, value, sizeof(buffer) ))
+            get_monitor_info_from_edid( &monitor->edid_info, value->Data, value->DataLength );
+        NtClose( subkey );
+    }
+
     NtClose( hkey );
     return TRUE;
 }
@@ -871,7 +933,7 @@ static void prepare_devices(void)
                                                 REG_OPTION_VOLATILE, NULL );
 
     /* delete monitors */
-    reg_empty_key( enum_key, "DISPLAY\\DEFAULT_MONITOR" );
+    reg_empty_key( enum_key, "DISPLAY" );
     sprintf( buffer, "Class\\%s", guid_devclass_monitorA );
     hkey = reg_create_key( control_key, bufferW, asciiz_to_unicode( bufferW, buffer ) - sizeof(WCHAR),
                            0, NULL );
@@ -1305,20 +1367,25 @@ static void add_monitor( const struct gdi_monitor *monitor, void *param )
     struct device_manager_ctx *ctx = param;
     char buffer[MAX_PATH], instance[64];
     unsigned int monitor_index, output_index;
+    struct edid_monitor_info monitor_info;
+    char monitor_id_string[16];
     WCHAR bufferW[MAX_PATH];
     HKEY hkey, subkey;
-
-    static const WCHAR default_monitorW[] =
-        {'M','O','N','I','T','O','R','\\','D','e','f','a','u','l','t','_','M','o','n','i','t','o','r',0,0};
-
-    TRACE( "%s %s %s\n", debugstr_w(monitor->name), wine_dbgstr_rect(&monitor->rc_monitor),
-           wine_dbgstr_rect(&monitor->rc_work) );
+    unsigned int len;
 
     monitor_index = ctx->monitor_count++;
     output_index = ctx->output_count++;
 
+    TRACE( "%u %s %s\n", monitor_index, wine_dbgstr_rect(&monitor->rc_monitor), wine_dbgstr_rect(&monitor->rc_work) );
+
+    get_monitor_info_from_edid( &monitor_info, monitor->edid, monitor->edid_len );
+    if (monitor_info.flags & MONITOR_INFO_HAS_MONITOR_ID)
+        strcpy( monitor_id_string, monitor_info.monitor_id_string );
+    else
+        strcpy( monitor_id_string, "Default_Monitor" );
+
     sprintf( buffer, "MonitorID%u", monitor_index );
-    sprintf( instance, "DISPLAY\\Default_Monitor\\%04X&%04X", ctx->video_count - 1, monitor_index );
+    sprintf( instance, "DISPLAY\\%s\\%04X&%04X", monitor_id_string, ctx->video_count - 1, monitor_index );
     set_reg_ascii_value( ctx->adapter_key, buffer, instance );
 
     hkey = reg_create_key( enum_key, bufferW, asciiz_to_unicode( bufferW, instance ) - sizeof(WCHAR),
@@ -1327,20 +1394,22 @@ static void add_monitor( const struct gdi_monitor *monitor, void *param )
 
     link_device( bufferW, guid_devinterface_monitorW );
 
-    lstrcpyW( bufferW, monitor->name );
-    if (!bufferW[0]) asciiz_to_unicode( bufferW, "Generic Non-PnP Monitor" );
+    asciiz_to_unicode( bufferW, "Generic Non-PnP Monitor" );
     set_reg_value( hkey, device_descW, REG_SZ, bufferW, (lstrlenW( bufferW ) + 1) * sizeof(WCHAR) );
 
     set_reg_value( hkey, classW, REG_SZ, monitorW, sizeof(monitorW) );
     sprintf( buffer, "%s\\%04X", guid_devclass_monitorA, output_index );
     set_reg_ascii_value( hkey, "Driver", buffer );
     set_reg_value( hkey, class_guidW, REG_SZ, guid_devclass_monitorW, sizeof(guid_devclass_monitorW) );
-    set_reg_value( hkey, hardware_idW, REG_MULTI_SZ, default_monitorW, sizeof(default_monitorW) );
+
+    sprintf( buffer, "MONITOR\\%s", monitor_id_string );
+    len = asciiz_to_unicode( bufferW, buffer );
+    bufferW[len / sizeof(WCHAR)] = 0;
+    set_reg_value( hkey, hardware_idW, REG_MULTI_SZ, bufferW, len + sizeof(WCHAR) );
 
     if ((subkey = reg_create_key( hkey, device_parametersW, sizeof(device_parametersW), 0, NULL )))
     {
         static const WCHAR bad_edidW[] = {'B','A','D','_','E','D','I','D',0};
-        static const WCHAR edidW[] = {'E','D','I','D',0};
 
         if (monitor->edid_len)
             set_reg_value( subkey, edidW, REG_BINARY, monitor->edid, monitor->edid_len );
@@ -5679,10 +5748,20 @@ NTSTATUS WINAPI NtUserDisplayConfigGetDeviceInfo( DISPLAYCONFIG_DEVICE_INFO_HEAD
                 continue;
 
             target_name->outputTechnology = DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL;
-            /* FIXME: get real monitor name. */
             snprintf( buffer, ARRAY_SIZE(buffer), "Display%u", monitor->output_id + 1 );
             asciiz_to_unicode( target_name->monitorFriendlyDeviceName, buffer );
             lstrcpyW( target_name->monitorDevicePath, monitor->dev.interface_name );
+            if (monitor->edid_info.flags & MONITOR_INFO_HAS_MONITOR_ID)
+            {
+                target_name->edidManufactureId = monitor->edid_info.manufacturer;
+                target_name->edidProductCodeId = monitor->edid_info.product_code;
+                target_name->flags.edidIdsValid = 1;
+            }
+            if (monitor->edid_info.flags & MONITOR_INFO_HAS_MONITOR_NAME)
+            {
+                wcscpy( target_name->monitorFriendlyDeviceName, monitor->edid_info.monitor_name );
+                target_name->flags.friendlyNameFromEdid = 1;
+            }
             ret = STATUS_SUCCESS;
             break;
         }
diff --git a/dlls/win32u/tests/win32u.c b/dlls/win32u/tests/win32u.c
index 87419f6fadb..60ef2d38b5f 100644
--- a/dlls/win32u/tests/win32u.c
+++ b/dlls/win32u/tests/win32u.c
@@ -24,6 +24,28 @@
 #include "winbase.h"
 #include "ntuser.h"
 
+#define check_member_( file, line, val, exp, fmt, member )                                         \
+    ok_(file, line)( (val).member == (exp).member, "got " #member " " fmt "\n", (val).member )
+#define check_member( val, exp, fmt, member )                                                      \
+    check_member_( __FILE__, __LINE__, val, exp, fmt, member )
+
+static void flush_events(void)
+{
+    int min_timeout = 100, diff = 200;
+    DWORD time = GetTickCount() + diff;
+    MSG msg;
+
+    while (diff > 0)
+    {
+        if (MsgWaitForMultipleObjects( 0, NULL, FALSE, min_timeout, QS_ALLINPUT ) == WAIT_TIMEOUT) break;
+        while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE ))
+        {
+            TranslateMessage( &msg );
+            DispatchMessageA( &msg );
+        }
+        diff = time - GetTickCount();
+    }
+}
 
 static void test_NtUserEnumDisplayDevices(void)
 {
@@ -822,6 +844,284 @@ static void test_inter_process_child( HWND hwnd )
     PostMessageA( hwnd, WM_USER, 0, 0 );
 }
 
+static DWORD CALLBACK test_NtUserGetPointerInfoList_thread( void *arg )
+{
+    POINTER_INFO pointer_info[4] = {0};
+    UINT32 entry_count, pointer_count;
+    HWND hwnd;
+    BOOL ret;
+
+    hwnd = CreateWindowW( L"test", L"test name", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+                          100, 100, 200, 200, 0, 0, NULL, 0 );
+    flush_events();
+
+    memset( &pointer_info, 0xcd, sizeof(pointer_info) );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    ok( pointer_count == 2, "got pointer_count %u\n", pointer_count );
+    ok( entry_count == 2, "got entry_count %u\n", entry_count );
+
+    DestroyWindow( hwnd );
+
+    return 0;
+}
+
+#define check_pointer_info( a, b ) check_pointer_info_( __LINE__, a, b )
+static void check_pointer_info_( int line, const POINTER_INFO *actual, const POINTER_INFO *expected )
+{
+    check_member( *actual, *expected, "%#lx", pointerType );
+    check_member( *actual, *expected, "%#x", pointerId );
+    check_member( *actual, *expected, "%#x", frameId );
+    check_member( *actual, *expected, "%#x", pointerFlags );
+    check_member( *actual, *expected, "%p", sourceDevice );
+    check_member( *actual, *expected, "%p", hwndTarget );
+    check_member( *actual, *expected, "%+ld", ptPixelLocation.x );
+    check_member( *actual, *expected, "%+ld", ptPixelLocation.y );
+    check_member( *actual, *expected, "%+ld", ptHimetricLocation.x );
+    check_member( *actual, *expected, "%+ld", ptHimetricLocation.y );
+    check_member( *actual, *expected, "%+ld", ptPixelLocationRaw.x );
+    check_member( *actual, *expected, "%+ld", ptPixelLocationRaw.y );
+    check_member( *actual, *expected, "%+ld", ptHimetricLocationRaw.x );
+    check_member( *actual, *expected, "%+ld", ptHimetricLocationRaw.y );
+    check_member( *actual, *expected, "%lu", dwTime );
+    check_member( *actual, *expected, "%u", historyCount );
+    check_member( *actual, *expected, "%#x", InputData );
+    check_member( *actual, *expected, "%#lx", dwKeyStates );
+    check_member( *actual, *expected, "%I64u", PerformanceCount );
+    check_member( *actual, *expected, "%#x", ButtonChangeType );
+}
+
+static void test_NtUserGetPointerInfoList( BOOL mouse_in_pointer_enabled )
+{
+    void *invalid_ptr = (void *)0xdeadbeef;
+    POINTER_TOUCH_INFO touch_info[4] = {0};
+    POINTER_PEN_INFO pen_info[4] = {0};
+    POINTER_INFO pointer_info[4] = {0};
+    UINT32 entry_count, pointer_count;
+    WNDCLASSW cls =
+    {
+        .lpfnWndProc   = DefWindowProcW,
+        .hInstance     = GetModuleHandleW( NULL ),
+        .hbrBackground = GetStockObject( WHITE_BRUSH ),
+        .lpszClassName = L"test",
+    };
+    HANDLE thread;
+    SIZE_T size;
+    ATOM class;
+    DWORD res;
+    HWND hwnd;
+    BOOL ret;
+
+    class = RegisterClassW( &cls );
+    ok( class, "RegisterClassW failed: %lu\n", GetLastError() );
+
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), invalid_ptr, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_NOACCESS, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), &entry_count, invalid_ptr, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_NOACCESS, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), &entry_count, &pointer_count, invalid_ptr );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_NOACCESS || broken(GetLastError() == ERROR_INVALID_PARAMETER) /* w10 32bit */, "got error %lu\n", GetLastError() );
+
+    memset( pointer_info, 0xcd, sizeof(pointer_info) );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    ok( pointer_count == 2, "got pointer_count %u\n", pointer_count );
+    ok( entry_count == 2, "got entry_count %u\n", entry_count );
+
+    SetCursorPos( 500, 500 );  /* avoid generating mouse message on window creation */
+
+    hwnd = CreateWindowW( L"test", L"test name", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+                          100, 100, 200, 200, 0, 0, NULL, 0 );
+    flush_events();
+
+    memset( pointer_info, 0xcd, sizeof(pointer_info) );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    ok( pointer_count == 2, "got pointer_count %u\n", pointer_count );
+    ok( entry_count == 2, "got entry_count %u\n", entry_count );
+
+    SetCursorPos( 200, 200 );
+    flush_events();
+    mouse_event( MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0 );
+    flush_events();
+    mouse_event( MOUSEEVENTF_LEFTUP, 0, 0, 0, 0 );
+    flush_events();
+    mouse_event( MOUSEEVENTF_MOVE, 10, 10, 0, 0 );
+    flush_events();
+
+    memset( pointer_info, 0xcd, sizeof(pointer_info) );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO), &entry_count, &pointer_count, pointer_info );
+    todo_wine_if(mouse_in_pointer_enabled)
+    ok( ret == mouse_in_pointer_enabled, "NtUserGetPointerInfoList failed, error %lu\n", GetLastError() );
+    if (!ret)
+    {
+        todo_wine
+        ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+        goto done;
+    }
+
+    ok( pointer_count == 1, "got pointer_count %u\n", pointer_count );
+    ok( entry_count == 1, "got entry_count %u\n", entry_count );
+    ok( pointer_info[0].pointerType == PT_MOUSE, "got pointerType %lu\n", pointer_info[0].pointerType );
+    ok( pointer_info[0].pointerId == 1, "got pointerId %u\n", pointer_info[0].pointerId );
+    ok( !!pointer_info[0].frameId, "got frameId %u\n", pointer_info[0].frameId );
+    ok( pointer_info[0].pointerFlags == (0x20000 | POINTER_MESSAGE_FLAG_INRANGE | POINTER_MESSAGE_FLAG_PRIMARY),
+        "got pointerFlags %#x\n", pointer_info[0].pointerFlags );
+    ok( pointer_info[0].sourceDevice == INVALID_HANDLE_VALUE || broken(!!pointer_info[0].sourceDevice) /* w1064v1809 32bit */,
+        "got sourceDevice %p\n", pointer_info[0].sourceDevice );
+    ok( pointer_info[0].hwndTarget == hwnd, "got hwndTarget %p\n", pointer_info[0].hwndTarget );
+    ok( !!pointer_info[0].ptPixelLocation.x, "got ptPixelLocation %s\n", wine_dbgstr_point( &pointer_info[0].ptPixelLocation ) );
+    ok( !!pointer_info[0].ptPixelLocation.y, "got ptPixelLocation %s\n", wine_dbgstr_point( &pointer_info[0].ptPixelLocation ) );
+    ok( !!pointer_info[0].ptHimetricLocation.x, "got ptHimetricLocation %s\n", wine_dbgstr_point( &pointer_info[0].ptHimetricLocation ) );
+    ok( !!pointer_info[0].ptHimetricLocation.y, "got ptHimetricLocation %s\n", wine_dbgstr_point( &pointer_info[0].ptHimetricLocation ) );
+    ok( !!pointer_info[0].ptPixelLocationRaw.x, "got ptPixelLocationRaw %s\n", wine_dbgstr_point( &pointer_info[0].ptPixelLocationRaw ) );
+    ok( !!pointer_info[0].ptPixelLocationRaw.y, "got ptPixelLocationRaw %s\n", wine_dbgstr_point( &pointer_info[0].ptPixelLocationRaw ) );
+    ok( !!pointer_info[0].ptHimetricLocationRaw.x, "got ptHimetricLocationRaw %s\n", wine_dbgstr_point( &pointer_info[0].ptHimetricLocationRaw ) );
+    ok( !!pointer_info[0].ptHimetricLocationRaw.y, "got ptHimetricLocationRaw %s\n", wine_dbgstr_point( &pointer_info[0].ptHimetricLocationRaw ) );
+    ok( !!pointer_info[0].dwTime, "got dwTime %lu\n", pointer_info[0].dwTime );
+    ok( pointer_info[0].historyCount == 1, "got historyCount %u\n", pointer_info[0].historyCount );
+    ok( pointer_info[0].InputData == 0, "got InputData %u\n", pointer_info[0].InputData );
+    ok( pointer_info[0].dwKeyStates == 0, "got dwKeyStates %lu\n", pointer_info[0].dwKeyStates );
+    ok( !!pointer_info[0].PerformanceCount, "got PerformanceCount %I64u\n", pointer_info[0].PerformanceCount );
+    ok( pointer_info[0].ButtonChangeType == 0, "got ButtonChangeType %u\n", pointer_info[0].ButtonChangeType );
+
+    thread = CreateThread( NULL, 0, test_NtUserGetPointerInfoList_thread, NULL, 0, NULL );
+    res = WaitForSingleObject( thread, 5000 );
+    ok( !res, "WaitForSingleObject returned %#lx, error %lu\n", res, GetLastError() );
+
+    memset( pen_info, 0xa5, sizeof(pen_info) );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_PEN, 0, 0, sizeof(POINTER_PEN_INFO), &entry_count, &pointer_count, pen_info );
+    ok( ret, "NtUserGetPointerInfoList failed, error %lu\n", GetLastError() );
+    ok( pointer_count == 1, "got pointer_count %u\n", pointer_count );
+    ok( entry_count == 1, "got entry_count %u\n", entry_count );
+    check_pointer_info( &pen_info[0].pointerInfo, &pointer_info[0] );
+    memset( touch_info, 0xa5, sizeof(touch_info) );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_TOUCH, 0, 0, sizeof(POINTER_TOUCH_INFO), &entry_count, &pointer_count, touch_info );
+    ok( ret, "NtUserGetPointerInfoList failed, error %lu\n", GetLastError() );
+    ok( pointer_count == 1, "got pointer_count %u\n", pointer_count );
+    ok( entry_count == 1, "got entry_count %u\n", entry_count );
+    check_pointer_info( &touch_info[0].pointerInfo, &pointer_info[0] );
+
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO) - 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_PEN, 0, 0, sizeof(POINTER_PEN_INFO) - 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_TOUCH, 0, 0, sizeof(POINTER_TOUCH_INFO) - 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_TOUCHPAD, 0, 0, sizeof(POINTER_TOUCH_INFO) - 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_POINTER, 0, 0, sizeof(POINTER_INFO) + 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_PEN, 0, 0, sizeof(POINTER_PEN_INFO) + 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_TOUCH, 0, 0, sizeof(POINTER_TOUCH_INFO) + 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    entry_count = pointer_count = 2;
+    ret = NtUserGetPointerInfoList( 1, PT_TOUCHPAD, 0, 0, sizeof(POINTER_TOUCH_INFO) + 1, &entry_count, &pointer_count, pointer_info );
+    ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+
+    for (size = 0; size < 0xfff; ++size)
+    {
+        char buffer[0x1000];
+        entry_count = pointer_count = 2;
+        ret = NtUserGetPointerInfoList( 1, PT_MOUSE, 0, 0, size, &entry_count, &pointer_count, buffer );
+        ok( !ret, "NtUserGetPointerInfoList succeeded\n" );
+        ok( GetLastError() == ERROR_INVALID_PARAMETER, "got error %lu\n", GetLastError() );
+    }
+
+done:
+    DestroyWindow( hwnd );
+
+    ret = UnregisterClassW( L"test", GetModuleHandleW(NULL) );
+    ok( ret, "UnregisterClassW failed: %lu\n", GetLastError() );
+}
+
+static void test_NtUserEnableMouseInPointer_process( const char *arg )
+{
+    DWORD enable = strtoul( arg, 0, 10 );
+    BOOL ret;
+
+    ret = NtUserIsMouseInPointerEnabled();
+    ok( !ret, "NtUserIsMouseInPointerEnabled returned %u, error %lu\n", ret, GetLastError() );
+
+    ret = NtUserEnableMouseInPointer( enable );
+    todo_wine
+    ok( ret, "NtUserEnableMouseInPointer failed, error %lu\n", GetLastError() );
+    ret = NtUserIsMouseInPointerEnabled();
+    todo_wine_if(enable)
+    ok( ret == enable, "NtUserIsMouseInPointerEnabled returned %u, error %lu\n", ret, GetLastError() );
+
+    SetLastError( 0xdeadbeef );
+    ret = NtUserEnableMouseInPointer( !enable );
+    ok( !ret, "NtUserEnableMouseInPointer succeeded\n" );
+    todo_wine
+    ok( GetLastError() == ERROR_ACCESS_DENIED, "got error %lu\n", GetLastError() );
+    ret = NtUserIsMouseInPointerEnabled();
+    todo_wine_if(enable)
+    ok( ret == enable, "NtUserIsMouseInPointerEnabled returned %u, error %lu\n", ret, GetLastError() );
+
+    ret = NtUserEnableMouseInPointer( enable );
+    todo_wine
+    ok( ret, "NtUserEnableMouseInPointer failed, error %lu\n", GetLastError() );
+    ret = NtUserIsMouseInPointerEnabled();
+    todo_wine_if(enable)
+    ok( ret == enable, "NtUserIsMouseInPointerEnabled returned %u, error %lu\n", ret, GetLastError() );
+
+    test_NtUserGetPointerInfoList( enable );
+}
+
+static void test_NtUserEnableMouseInPointer( char **argv, BOOL enable )
+{
+    STARTUPINFOA startup = {.cb = sizeof(STARTUPINFOA)};
+    PROCESS_INFORMATION info = {0};
+    char cmdline[MAX_PATH * 2];
+    BOOL ret;
+
+    sprintf( cmdline, "%s %s NtUserEnableMouseInPointer %u", argv[0], argv[1], enable );
+    ret = CreateProcessA( NULL, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &startup, &info );
+    ok( ret, "CreateProcessA failed, error %lu\n", GetLastError() );
+    if (!ret) return;
+
+    wait_child_process( info.hProcess );
+    CloseHandle( info.hThread );
+    CloseHandle( info.hProcess );
+}
+
 START_TEST(win32u)
 {
     char **argv;
@@ -837,6 +1137,14 @@ START_TEST(win32u)
         return;
     }
 
+    if (argc > 3 && !strcmp( argv[2], "NtUserEnableMouseInPointer" ))
+    {
+        winetest_push_context( "enable %s", argv[3] );
+        test_NtUserEnableMouseInPointer_process( argv[3] );
+        winetest_pop_context();
+        return;
+    }
+
     test_NtUserEnumDisplayDevices();
     test_window_props();
     test_class();
@@ -851,4 +1159,7 @@ START_TEST(win32u)
 
     test_NtUserCloseWindowStation();
     test_NtUserDisplayConfigGetDeviceInfo();
+
+    test_NtUserEnableMouseInPointer( argv, FALSE );
+    test_NtUserEnableMouseInPointer( argv, TRUE );
 }
diff --git a/dlls/win32u/win32u.spec b/dlls/win32u/win32u.spec
index c3ed3c0559a..12e1d0701f6 100644
--- a/dlls/win32u/win32u.spec
+++ b/dlls/win32u/win32u.spec
@@ -861,7 +861,7 @@
 @ stub NtUserEnableChildWindowDpiMessage
 @ stub NtUserEnableIAMAccess
 @ stdcall -syscall NtUserEnableMenuItem(long long long)
-@ stub NtUserEnableMouseInPointer
+@ stdcall -syscall NtUserEnableMouseInPointer(long)
 @ stub NtUserEnableMouseInPointerForWindow
 @ stub NtUserEnableMouseInputForCursorSuppression
 @ stub NtUserEnableNonClientDpiScaling
@@ -971,7 +971,7 @@
 @ stub NtUserGetPointerDeviceRects
 @ stub NtUserGetPointerDevices
 @ stub NtUserGetPointerFrameTimes
-@ stub NtUserGetPointerInfoList
+@ stdcall -syscall NtUserGetPointerInfoList(long long long long long ptr ptr ptr)
 @ stub NtUserGetPointerInputTransform
 @ stub NtUserGetPointerProprietaryId
 @ stub NtUserGetPointerType
@@ -1051,7 +1051,7 @@
 @ stdcall -syscall NtUserInvalidateRgn(long long long)
 @ stub NtUserIsChildWindowDpiMessageEnabled
 @ stdcall -syscall NtUserIsClipboardFormatAvailable(long)
-@ stub NtUserIsMouseInPointerEnabled
+@ stdcall -syscall NtUserIsMouseInPointerEnabled()
 @ stub NtUserIsMouseInputEnabled
 @ stub NtUserIsNonClientDpiScalingEnabled
 @ stub NtUserIsResizeLayoutSynchronizationEnabled
@@ -1328,3 +1328,6 @@
 @ cdecl __wine_get_brush_bitmap_info(long ptr ptr ptr)
 @ cdecl __wine_get_icm_profile(long long ptr ptr)
 @ cdecl __wine_get_file_outline_text_metric(wstr ptr)
+
+# message
+@ cdecl __wine_send_internal_message_timeout(long long long long long long long ptr)
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 96b1b7647fe..ad9cc134eb7 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -208,6 +208,9 @@ struct unix_funcs
     BOOL (CDECL *get_file_outline_text_metric)( const WCHAR *path, OUTLINETEXTMETRICW *otm );
     BOOL (CDECL *get_icm_profile)( HDC hdc, BOOL allow_default, DWORD *size, WCHAR *filename );
     BOOL (CDECL *wine_send_input)( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+    LRESULT (CDECL *wine_send_internal_message_timeout)( DWORD dest_pid, DWORD dest_tid,
+                                                         UINT msg, WPARAM wparam, LPARAM lparam,
+                                                         UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 };
 
 /* clipboard.c */
@@ -314,7 +317,7 @@ extern LRESULT send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid, UI
 extern LRESULT send_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
 extern BOOL send_notify_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL ansi ) DECLSPEC_HIDDEN;
 extern LRESULT send_message_timeout( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                     UINT flags, UINT timeout, BOOL ansi );
+                                     UINT flags, UINT timeout, BOOL ansi ) DECLSPEC_HIDDEN;
 
 /* rawinput.c */
 extern BOOL process_rawinput_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data ) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/wrappers.c b/dlls/win32u/wrappers.c
index e128705ef37..d0d068c3e78 100644
--- a/dlls/win32u/wrappers.c
+++ b/dlls/win32u/wrappers.c
@@ -804,6 +804,15 @@ BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *raw
     return unix_funcs->wine_send_input( hwnd, input, rawinput );
 }
 
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    if (!unix_funcs) return 0;
+    return unix_funcs->wine_send_internal_message_timeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                                           flags, timeout, res_ptr );
+}
+
 extern void wrappers_init( unixlib_handle_t handle )
 {
     const void *args;
diff --git a/dlls/windows.gaming.input/force_feedback.c b/dlls/windows.gaming.input/force_feedback.c
index f7a233b46d4..cff3c184bf9 100644
--- a/dlls/windows.gaming.input/force_feedback.c
+++ b/dlls/windows.gaming.input/force_feedback.c
@@ -109,37 +109,79 @@ static ULONG WINAPI effect_impl_Release( IWineForceFeedbackEffectImpl *iface )
     return ref;
 }
 
+static int effect_reorient_direction( const WineForceFeedbackEffectParameters *params, Vector3 *direction )
+{
+    int sign = +1;
+
+    switch (params->type)
+    {
+    case WineForceFeedbackEffectType_Constant:
+        *direction = params->constant.direction;
+        sign = params->constant.direction.X < 0 ? -1 : +1;
+        break;
+
+    case WineForceFeedbackEffectType_Ramp:
+        *direction = params->ramp.start_vector;
+        sign = params->ramp.start_vector.X < 0 ? -1 : +1;
+        break;
+
+    case WineForceFeedbackEffectType_Periodic_SineWave:
+    case WineForceFeedbackEffectType_Periodic_TriangleWave:
+    case WineForceFeedbackEffectType_Periodic_SquareWave:
+    case WineForceFeedbackEffectType_Periodic_SawtoothWaveDown:
+    case WineForceFeedbackEffectType_Periodic_SawtoothWaveUp:
+        *direction = params->periodic.direction;
+        break;
+
+    case WineForceFeedbackEffectType_Condition_Spring:
+    case WineForceFeedbackEffectType_Condition_Damper:
+    case WineForceFeedbackEffectType_Condition_Inertia:
+    case WineForceFeedbackEffectType_Condition_Friction:
+        *direction = params->condition.direction;
+        sign = -1;
+        break;
+    }
+
+    direction->X *= -sign;
+    direction->Y *= -sign;
+    direction->Z *= -sign;
+
+    return sign;
+}
+
 static HRESULT WINAPI effect_impl_put_Parameters( IWineForceFeedbackEffectImpl *iface, WineForceFeedbackEffectParameters params,
                                                   WineForceFeedbackEffectEnvelope *envelope )
 {
     struct effect *impl = impl_from_IWineForceFeedbackEffectImpl( iface );
+    Vector3 direction = {0};
+    double magnitude = 0;
     DWORD count = 0;
     HRESULT hr;
+    int sign;
 
     TRACE( "iface %p, params %p, envelope %p.\n", iface, &params, envelope );
 
     EnterCriticalSection( &impl->cs );
+
+    sign = effect_reorient_direction( &params, &direction );
+    /* Y and Z axes seems to be always ignored, is it really the case? */
+    magnitude += direction.X * direction.X;
+
     switch (params.type)
     {
     case WineForceFeedbackEffectType_Constant:
         impl->repeat_count = params.constant.repeat_count;
-        impl->constant_force.lMagnitude = round( params.constant.gain * params.constant.direction.X * 10000 );
-        impl->params.dwDuration = params.constant.duration.Duration / 10;
-        impl->params.dwStartDelay = params.constant.start_delay.Duration / 10;
-        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( -params.constant.direction.X * 10000 );
-        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( -params.constant.direction.Y * 10000 );
-        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( -params.constant.direction.Z * 10000 );
+        impl->constant_force.lMagnitude = sign * round( params.constant.gain * sqrt( magnitude ) * 10000 );
+        impl->params.dwDuration = min( max( params.constant.duration.Duration / 10, 0 ), INFINITE );
+        impl->params.dwStartDelay = min( max( params.constant.start_delay.Duration / 10, 0 ), INFINITE );
         break;
 
     case WineForceFeedbackEffectType_Ramp:
         impl->repeat_count = params.ramp.repeat_count;
-        impl->ramp_force.lStart = round( params.ramp.gain * params.ramp.start_vector.X * 10000 );
+        impl->ramp_force.lStart = sign * round( params.ramp.gain * sqrt( magnitude ) * 10000 );
         impl->ramp_force.lEnd = round( params.ramp.gain * params.ramp.end_vector.X * 10000 );
-        impl->params.dwDuration = params.ramp.duration.Duration / 10;
-        impl->params.dwStartDelay = params.ramp.start_delay.Duration / 10;
-        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( -params.ramp.start_vector.X * 10000 );
-        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( -params.ramp.start_vector.Y * 10000 );
-        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( -params.ramp.start_vector.Z * 10000 );
+        impl->params.dwDuration = min( max( params.ramp.duration.Duration / 10, 0 ), INFINITE );
+        impl->params.dwStartDelay = min( max( params.ramp.start_delay.Duration / 10, 0 ), INFINITE );
         break;
 
     case WineForceFeedbackEffectType_Periodic_SineWave:
@@ -152,11 +194,8 @@ static HRESULT WINAPI effect_impl_put_Parameters( IWineForceFeedbackEffectImpl *
         impl->periodic.dwPeriod = 1000000 / params.periodic.frequency;
         impl->periodic.dwPhase = round( params.periodic.phase * 36000 );
         impl->periodic.lOffset = round( params.periodic.bias * 10000 );
-        impl->params.dwDuration = params.periodic.duration.Duration / 10;
-        impl->params.dwStartDelay = params.periodic.start_delay.Duration / 10;
-        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( -params.periodic.direction.X * 10000 );
-        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( -params.periodic.direction.Y * 10000 );
-        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( -params.periodic.direction.Z * 10000 );
+        impl->params.dwDuration = min( max( params.periodic.duration.Duration / 10, 0 ), INFINITE );
+        impl->params.dwStartDelay = min( max( params.periodic.start_delay.Duration / 10, 0 ), INFINITE );
         break;
 
     case WineForceFeedbackEffectType_Condition_Spring:
@@ -172,18 +211,19 @@ static HRESULT WINAPI effect_impl_put_Parameters( IWineForceFeedbackEffectImpl *
         impl->condition.lOffset = round( params.condition.bias * 10000 );
         impl->params.dwDuration = -1;
         impl->params.dwStartDelay = 0;
-        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( params.condition.direction.X * 10000 );
-        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( params.condition.direction.Y * 10000 );
-        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( params.condition.direction.Z * 10000 );
         break;
     }
 
+    if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( direction.X * 10000 );
+    if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( direction.Y * 10000 );
+    if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( direction.Z * 10000 );
+
     if (!envelope) impl->params.lpEnvelope = NULL;
     else
     {
-        impl->envelope.dwAttackTime = envelope->attack_duration.Duration / 10;
+        impl->envelope.dwAttackTime = min( max( envelope->attack_duration.Duration / 10, 0 ), INFINITE );
         impl->envelope.dwAttackLevel = round( envelope->attack_gain * 10000 );
-        impl->envelope.dwFadeTime = impl->params.dwDuration - envelope->release_duration.Duration / 10;
+        impl->envelope.dwFadeTime = impl->params.dwDuration - min( max( envelope->release_duration.Duration / 10, 0 ), INFINITE );
         impl->envelope.dwFadeLevel = round( envelope->release_gain * 10000 );
         impl->params.lpEnvelope = &impl->envelope;
     }
diff --git a/dlls/windows.globalization/classes.idl b/dlls/windows.globalization/classes.idl
index 94fc53c0dd5..ded6b7572e8 100644
--- a/dlls/windows.globalization/classes.idl
+++ b/dlls/windows.globalization/classes.idl
@@ -20,4 +20,16 @@
 
 #pragma makedep register
 
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+#define DO_NO_IMPORTS
+#include "windows.globalization.idl"
 #include "windows.system.userprofile.idl"
diff --git a/dlls/windows.globalization/main.c b/dlls/windows.globalization/main.c
index 21ea2908679..d5a5895938f 100644
--- a/dlls/windows.globalization/main.c
+++ b/dlls/windows.globalization/main.c
@@ -234,16 +234,156 @@ struct windows_globalization
     LONG ref;
 };
 
+struct language_factory
+{
+    IActivationFactory IActivationFactory_iface;
+    ILanguageFactory ILanguageFactory_iface;
+    LONG ref;
+};
+
+struct language
+{
+    ILanguage ILanguage_iface;
+    LONG ref;
+    WCHAR name[LOCALE_NAME_MAX_LENGTH];
+};
+
 static inline struct windows_globalization *impl_from_IActivationFactory(IActivationFactory *iface)
 {
     return CONTAINING_RECORD(iface, struct windows_globalization, IActivationFactory_iface);
 }
 
+static inline struct language_factory *impl_language_factory_from_IActivationFactory(IActivationFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct language_factory, IActivationFactory_iface);
+}
+
 static inline struct windows_globalization *impl_from_IGlobalizationPreferencesStatics(IGlobalizationPreferencesStatics *iface)
 {
     return CONTAINING_RECORD(iface, struct windows_globalization, IGlobalizationPreferencesStatics_iface);
 }
 
+static inline struct language_factory *impl_from_ILanguageFactory(ILanguageFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct language_factory, ILanguageFactory_iface);
+}
+
+static inline struct language *impl_from_ILanguage(ILanguage *iface)
+{
+    return CONTAINING_RECORD(iface, struct language, ILanguage_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE language_QueryInterface(
+        ILanguage *iface, REFIID iid, void **out)
+{
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_IAgileObject) ||
+        IsEqualGUID(iid, &IID_ILanguage))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE language_AddRef(
+        ILanguage *iface)
+{
+    struct language *language = impl_from_ILanguage(iface);
+    ULONG ref = InterlockedIncrement(&language->ref);
+    TRACE("iface %p, ref %lu.\n", iface, ref);
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE language_Release(
+        ILanguage *iface)
+{
+    struct language *language = impl_from_ILanguage(iface);
+    ULONG ref = InterlockedDecrement(&language->ref);
+
+    TRACE("iface %p, ref %lu.\n", iface, ref);
+
+    if (!ref)
+        free(language);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE language_GetIids(
+        ILanguage *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_GetRuntimeClassName(
+        ILanguage *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_GetTrustLevel(
+        ILanguage *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_get_LanguageTag(
+        ILanguage *iface, HSTRING *value)
+{
+    struct language *language = impl_from_ILanguage(iface);
+
+    TRACE("iface %p, value %p.\n", iface, value);
+
+    return WindowsCreateString(language->name, wcslen(language->name), value);
+}
+
+static HRESULT STDMETHODCALLTYPE language_get_DisplayName(
+        ILanguage *iface, HSTRING *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_get_NativeName(
+        ILanguage *iface, HSTRING *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_get_Script(
+        ILanguage *iface, HSTRING *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static const struct ILanguageVtbl language_vtbl =
+{
+    language_QueryInterface,
+    language_AddRef,
+    language_Release,
+    /* IInspectable methods */
+    language_GetIids,
+    language_GetRuntimeClassName,
+    language_GetTrustLevel,
+    /* ILanguage methods */
+    language_get_LanguageTag,
+    language_get_DisplayName,
+    language_get_NativeName,
+    language_get_Script,
+};
+
 static HRESULT STDMETHODCALLTYPE windows_globalization_QueryInterface(
         IActivationFactory *iface, REFIID iid, void **out)
 {
@@ -454,13 +594,141 @@ static const struct IGlobalizationPreferencesStaticsVtbl globalization_preferenc
     globalization_preferences_get_WeekStartsOn,
 };
 
-static struct windows_globalization windows_globalization =
+static struct windows_globalization userprofile_preferences =
 {
     {&activation_factory_vtbl},
     {&globalization_preferences_vtbl},
     0
 };
 
+static HRESULT STDMETHODCALLTYPE windows_globalization_language_factory_QueryInterface(
+        IActivationFactory *iface, REFIID iid, void **out)
+{
+    struct language_factory *factory = impl_language_factory_from_IActivationFactory(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_IAgileObject) ||
+        IsEqualGUID(iid, &IID_IActivationFactory))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    if (IsEqualGUID(iid, &IID_ILanguageFactory))
+    {
+        IUnknown_AddRef(iface);
+        *out = &factory->ILanguageFactory_iface;
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static const struct IActivationFactoryVtbl activation_factory_language_vtbl =
+{
+    windows_globalization_language_factory_QueryInterface,
+    windows_globalization_AddRef,
+    windows_globalization_Release,
+    /* IInspectable methods */
+    windows_globalization_GetIids,
+    windows_globalization_GetRuntimeClassName,
+    windows_globalization_GetTrustLevel,
+    /* IActivationFactory methods */
+    windows_globalization_ActivateInstance,
+};
+
+static HRESULT STDMETHODCALLTYPE language_factory_QueryInterface(
+        ILanguageFactory *iface, REFIID iid, void **object)
+{
+    struct language_factory *factory = impl_from_ILanguageFactory(iface);
+    return IActivationFactory_QueryInterface(&factory->IActivationFactory_iface, iid, object);
+}
+
+static ULONG STDMETHODCALLTYPE language_factory_AddRef(
+        ILanguageFactory *iface)
+{
+    struct language_factory *factory = impl_from_ILanguageFactory(iface);
+    return IActivationFactory_AddRef(&factory->IActivationFactory_iface);
+}
+
+static ULONG STDMETHODCALLTYPE language_factory_Release(
+        ILanguageFactory *iface)
+{
+    struct language_factory *factory = impl_from_ILanguageFactory(iface);
+    return IActivationFactory_Release(&factory->IActivationFactory_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE language_factory_GetIids(
+        ILanguageFactory *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_factory_GetRuntimeClassName(
+        ILanguageFactory *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_factory_GetTrustLevel(
+        ILanguageFactory *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE language_factory_CreateLanguage(
+        ILanguageFactory *iface, HSTRING tag, ILanguage **value)
+{
+    const WCHAR *name = WindowsGetStringRawBuffer(tag, NULL);
+    WCHAR buffer[LOCALE_NAME_MAX_LENGTH];
+    struct language *language;
+
+    TRACE("iface %p, tag %p, value %p.\n", iface, tag, value);
+
+    if (!GetLocaleInfoEx(name, LOCALE_SNAME, buffer, ARRAY_SIZE(buffer)))
+        return E_INVALIDARG;
+
+    if (!(language = calloc(1, sizeof(*language))))
+        return E_OUTOFMEMORY;
+
+    language->ILanguage_iface.lpVtbl = &language_vtbl;
+    language->ref = 1;
+    wcscpy(language->name, buffer);
+
+    *value = &language->ILanguage_iface;
+
+    return S_OK;
+}
+
+static const struct ILanguageFactoryVtbl language_factory_vtbl =
+{
+    language_factory_QueryInterface,
+    language_factory_AddRef,
+    language_factory_Release,
+    /* IInspectable methods */
+    language_factory_GetIids,
+    language_factory_GetRuntimeClassName,
+    language_factory_GetTrustLevel,
+    /* ILanguageFactory methods */
+    language_factory_CreateLanguage,
+};
+
+static struct language_factory language_factory =
+{
+    {&activation_factory_language_vtbl},
+    {&language_factory_vtbl},
+    0
+};
+
 HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
 {
     FIXME("clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out);
@@ -469,8 +737,23 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
 
 HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
 {
+    const WCHAR *name = WindowsGetStringRawBuffer(classid, NULL);
+
     TRACE("classid %s, factory %p.\n", debugstr_hstring(classid), factory);
-    *factory = &windows_globalization.IActivationFactory_iface;
-    IUnknown_AddRef(*factory);
-    return S_OK;
+
+    *factory = NULL;
+
+    if (!wcscmp(name, RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences))
+    {
+        *factory = &userprofile_preferences.IActivationFactory_iface;
+        IUnknown_AddRef(*factory);
+    }
+    else if (!wcscmp(name, RuntimeClass_Windows_Globalization_Language))
+    {
+        *factory = &language_factory.IActivationFactory_iface;
+        IUnknown_AddRef(*factory);
+    }
+
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
 }
diff --git a/dlls/windows.globalization/tests/globalization.c b/dlls/windows.globalization/tests/globalization.c
index c42cb67496e..3c12818b743 100644
--- a/dlls/windows.globalization/tests/globalization.c
+++ b/dlls/windows.globalization/tests/globalization.c
@@ -29,6 +29,8 @@
 #define WIDL_using_Windows_Foundation
 #define WIDL_using_Windows_Foundation_Collections
 #include "windows.foundation.h"
+#define WIDL_using_Windows_Globalization
+#include "windows.globalization.h"
 #define WIDL_using_Windows_System_UserProfile
 #include "windows.system.userprofile.h"
 
@@ -227,6 +229,90 @@ static void test_GlobalizationPreferences(void)
     RoUninitialize();
 }
 
+static void test_Language(void)
+{
+    static const WCHAR *class_name = L"Windows.Globalization.Language";
+
+    IAgileObject *agile_object, *tmp_agile_object;
+    IInspectable *inspectable, *tmp_inspectable;
+    WCHAR buffer[LOCALE_NAME_MAX_LENGTH];
+    ILanguageFactory *language_factory;
+    IActivationFactory *factory;
+    ILanguage *language;
+    HSTRING tag, str;
+    const WCHAR *buf;
+    HRESULT hr;
+
+    hr = RoInitialize(RO_INIT_MULTITHREADED);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = WindowsCreateString(class_name, wcslen(class_name), &str);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = RoGetActivationFactory(str, &IID_IActivationFactory, (void **)&factory);
+    ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG), "Unexpected hr %#lx.\n", hr);
+    WindowsDeleteString(str);
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip("%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w(class_name));
+        RoUninitialize();
+        return;
+    }
+
+    hr = IActivationFactory_QueryInterface(factory, &IID_IInspectable, (void **)&inspectable);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = IActivationFactory_QueryInterface(factory, &IID_IAgileObject, (void **)&agile_object);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = IActivationFactory_QueryInterface(factory, &IID_ILanguageFactory, (void **)&language_factory);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+
+    hr = ILanguageFactory_QueryInterface(language_factory, &IID_IInspectable, (void **)&tmp_inspectable);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(tmp_inspectable == inspectable, "Unexpected interface pointer %p, expected %p.\n", tmp_inspectable, inspectable);
+    IInspectable_Release(tmp_inspectable);
+
+    hr = ILanguageFactory_QueryInterface(language_factory, &IID_IAgileObject, (void **)&tmp_agile_object);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(tmp_agile_object == agile_object, "Unexpected interface pointer %p, expected %p.\n", tmp_agile_object, agile_object);
+    IAgileObject_Release(tmp_agile_object);
+
+    /* Invalid language tag */
+    hr = WindowsCreateString(L"test-tag", 8, &str);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    hr = ILanguageFactory_CreateLanguage(language_factory, str, &language);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    if (SUCCEEDED(hr))
+        ILanguage_Release(language);
+    WindowsDeleteString(str);
+
+    hr = WindowsCreateString(L"en-us", 5, &str);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    hr = ILanguageFactory_CreateLanguage(language_factory, str, &language);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    WindowsDeleteString(str);
+
+    hr = ILanguage_get_LanguageTag(language, &tag);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    buf = WindowsGetStringRawBuffer(tag, NULL);
+    ok(!wcscmp(buf, L"en-US"), "Unexpected tag %s.\n", debugstr_w(buf));
+    GetLocaleInfoEx(L"en-us", LOCALE_SNAME, buffer, ARRAY_SIZE(buffer));
+    ok(!wcscmp(buf, buffer), "Unexpected tag %s, locale name %s.\n", debugstr_w(buf), debugstr_w(buffer));
+
+    WindowsDeleteString(tag);
+
+    ILanguage_Release(language);
+
+    ILanguageFactory_Release(language_factory);
+
+    IAgileObject_Release(agile_object);
+    IInspectable_Release(inspectable);
+    IActivationFactory_Release(factory);
+
+    RoUninitialize();
+}
+
 START_TEST(globalization)
 {
     HMODULE kernel32;
@@ -235,4 +321,5 @@ START_TEST(globalization)
     pGetUserDefaultGeoName = (void*)GetProcAddress(kernel32, "GetUserDefaultGeoName");
 
     test_GlobalizationPreferences();
+    test_Language();
 }
diff --git a/dlls/windows.media.speech/private.h b/dlls/windows.media.speech/private.h
index 13964329697..e80d73ec1fb 100644
--- a/dlls/windows.media.speech/private.h
+++ b/dlls/windows.media.speech/private.h
@@ -23,6 +23,7 @@
 #include <stdarg.h>
 
 #define COBJMACROS
+#include "corerror.h"
 #include "windef.h"
 #include "winbase.h"
 #include "winstring.h"
@@ -69,8 +70,8 @@ struct vector_iids
     const GUID *view;
 };
 
-typedef HRESULT (WINAPI *async_action_callback)( IInspectable *invoker );
-typedef HRESULT (WINAPI *async_operation_inspectable_callback)( IInspectable *invoker, IInspectable **result );
+typedef HRESULT (*async_action_callback)( IInspectable *invoker );
+typedef HRESULT (*async_operation_inspectable_callback)( IInspectable *invoker, IInspectable **result );
 
 HRESULT async_action_create( IInspectable *invoker, async_action_callback callback, IAsyncAction **out );
 HRESULT async_operation_inspectable_create( const GUID *iid, IInspectable *invoker, async_operation_inspectable_callback callback,
diff --git a/dlls/windows.media.speech/recognizer.c b/dlls/windows.media.speech/recognizer.c
index bdcc57f883e..c2f386206b8 100644
--- a/dlls/windows.media.speech/recognizer.c
+++ b/dlls/windows.media.speech/recognizer.c
@@ -19,6 +19,10 @@
 
 #include "private.h"
 
+#include "initguid.h"
+#include "audioclient.h"
+#include "mmdeviceapi.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(speech);
@@ -156,8 +160,20 @@ struct session
     ISpeechContinuousRecognitionSession ISpeechContinuousRecognitionSession_iface;
     LONG ref;
 
+    IVector_ISpeechRecognitionConstraint *constraints;
+
+    SpeechRecognizerState recognizer_state;
+
     struct list completed_handlers;
     struct list result_handlers;
+
+    IAudioClient *audio_client;
+    IAudioCaptureClient *capture_client;
+    WAVEFORMATEX capture_wfx;
+
+    HANDLE worker_thread, worker_control_event, audio_buf_event;
+    BOOLEAN worker_running, worker_paused;
+    CRITICAL_SECTION cs;
 };
 
 /*
@@ -171,6 +187,107 @@ static inline struct session *impl_from_ISpeechContinuousRecognitionSession( ISp
     return CONTAINING_RECORD(iface, struct session, ISpeechContinuousRecognitionSession_iface);
 }
 
+static DWORD CALLBACK session_worker_thread_cb( void *args )
+{
+    ISpeechContinuousRecognitionSession *iface = args;
+    struct session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+    BOOLEAN running = TRUE, paused = FALSE;
+    UINT32 frame_count, tmp_buf_size;
+    BYTE *audio_buf, *tmp_buf;
+    DWORD flags, status;
+    HANDLE events[2];
+    HRESULT hr;
+
+    SetThreadDescription(GetCurrentThread(), L"wine_speech_recognition_session_worker");
+
+    if (FAILED(hr = IAudioClient_Start(impl->audio_client)))
+        goto error;
+
+    if (FAILED(hr = IAudioClient_GetBufferSize(impl->audio_client, &frame_count)))
+        goto error;
+
+    tmp_buf_size = sizeof(*tmp_buf) * frame_count * impl->capture_wfx.nBlockAlign;
+    if (!(tmp_buf = malloc(tmp_buf_size)))
+    {
+        ERR("Memory allocation failed.\n");
+        return 1;
+    }
+
+    while (running)
+    {
+        BOOLEAN old_paused = paused;
+        UINT32 count = 0;
+
+        events[count++] = impl->worker_control_event;
+        if (!paused) events[count++] = impl->audio_buf_event;
+
+        status = WaitForMultipleObjects(count, events, FALSE, INFINITE);
+        if (status == 0) /* worker_control_event signaled */
+        {
+            EnterCriticalSection(&impl->cs);
+            paused = impl->worker_paused;
+            running = impl->worker_running;
+            LeaveCriticalSection(&impl->cs);
+
+            if (old_paused < paused)
+            {
+                if (FAILED(hr = IAudioClient_Stop(impl->audio_client))) goto error;
+                if (FAILED(hr = IAudioClient_Reset(impl->audio_client))) goto error;
+                TRACE("session worker paused.\n");
+            }
+            else if (old_paused > paused)
+            {
+                if (FAILED(hr = IAudioClient_Start(impl->audio_client))) goto error;
+                TRACE("session worker resumed.\n");
+            }
+        }
+        else if (status == 1) /* audio_buf_event signaled */
+        {
+            SIZE_T packet_size = 0, tmp_buf_offset = 0;
+            UINT32 frames_available = 0;
+
+            while (tmp_buf_offset < tmp_buf_size
+                   && IAudioCaptureClient_GetBuffer(impl->capture_client, &audio_buf, &frames_available, &flags, NULL, NULL) == S_OK)
+            {
+                packet_size = frames_available * impl->capture_wfx.nBlockAlign;
+                if (tmp_buf_offset + packet_size > tmp_buf_size)
+                {
+                    /* Defer processing until the next iteration of the worker loop. */
+                    IAudioCaptureClient_ReleaseBuffer(impl->capture_client, 0);
+                    SetEvent(impl->audio_buf_event);
+                    break;
+                }
+
+                memcpy(tmp_buf + tmp_buf_offset, audio_buf, packet_size);
+                tmp_buf_offset += packet_size;
+
+                IAudioCaptureClient_ReleaseBuffer(impl->capture_client, frames_available);
+            }
+
+            /* TODO: Send mic data to recognizer and handle results. */
+        }
+        else
+        {
+            ERR("Unexpected state entered. Aborting worker.\n");
+            break;
+        }
+    }
+
+    if (FAILED(hr = IAudioClient_Stop(impl->audio_client)))
+        ERR("IAudioClient_Stop failed with %#lx.\n", hr);
+
+    if (FAILED(hr = IAudioClient_Reset(impl->audio_client)))
+        ERR("IAudioClient_Reset failed with %#lx.\n", hr);
+
+    free(tmp_buf);
+
+    return 0;
+
+error:
+    ERR("The recognition session worker encountered a serious error and needs to stop. hr: %lx.\n", hr);
+    return 1;
+}
+
 static HRESULT WINAPI session_QueryInterface( ISpeechContinuousRecognitionSession *iface, REFIID iid, void **out )
 {
     struct session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
@@ -206,8 +323,28 @@ static ULONG WINAPI session_Release( ISpeechContinuousRecognitionSession *iface
 
     if (!ref)
     {
+        HANDLE thread;
+
+        EnterCriticalSection(&impl->cs);
+        thread = impl->worker_thread;
+        impl->worker_running = FALSE;
+        impl->worker_thread = INVALID_HANDLE_VALUE;
+        LeaveCriticalSection(&impl->cs);
+
+        SetEvent(impl->worker_control_event);
+        WaitForSingleObject(thread, INFINITE);
+        CloseHandle(thread);
+
         typed_event_handlers_clear(&impl->completed_handlers);
         typed_event_handlers_clear(&impl->result_handlers);
+
+        IAudioCaptureClient_Release(impl->capture_client);
+        IAudioClient_Release(impl->audio_client);
+
+        impl->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&impl->cs);
+
+        IVector_ISpeechRecognitionConstraint_Release(impl->constraints);
         free(impl);
     }
 
@@ -244,15 +381,45 @@ static HRESULT WINAPI session_set_AutoStopSilenceTimeout( ISpeechContinuousRecog
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI start_callback( IInspectable *invoker )
+static HRESULT session_start_async( IInspectable *invoker )
 {
     return S_OK;
 }
 
 static HRESULT WINAPI session_StartAsync( ISpeechContinuousRecognitionSession *iface, IAsyncAction **action )
 {
-    FIXME("iface %p, action %p stub!\n", iface, action);
-    return async_action_create(NULL, start_callback, action);
+    struct session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+    HRESULT hr;
+
+    TRACE("iface %p, action %p.\n", iface, action);
+
+    if (FAILED(hr = async_action_create(NULL, session_start_async, action)))
+        return hr;
+
+    EnterCriticalSection(&impl->cs);
+    if (impl->worker_running || impl->worker_thread)
+    {
+        hr = COR_E_INVALIDOPERATION;
+    }
+    else if (!(impl->worker_thread = CreateThread(NULL, 0, session_worker_thread_cb, impl, 0, NULL)))
+    {
+        hr = HRESULT_FROM_WIN32(GetLastError());
+        impl->worker_running = FALSE;
+    }
+    else
+    {
+        impl->worker_running = TRUE;
+        impl->recognizer_state = SpeechRecognizerState_Capturing;
+    }
+    LeaveCriticalSection(&impl->cs);
+
+    if (FAILED(hr))
+    {
+        IAsyncAction_Release(*action);
+        *action = NULL;
+    }
+
+    return hr;
 }
 
 static HRESULT WINAPI session_StartWithModeAsync( ISpeechContinuousRecognitionSession *iface,
@@ -263,10 +430,54 @@ static HRESULT WINAPI session_StartWithModeAsync( ISpeechContinuousRecognitionSe
     return E_NOTIMPL;
 }
 
+static HRESULT session_stop_async( IInspectable *invoker )
+{
+    return S_OK;
+}
+
 static HRESULT WINAPI session_StopAsync( ISpeechContinuousRecognitionSession *iface, IAsyncAction **action )
 {
-    FIXME("iface %p, action %p stub!\n", iface, action);
-    return E_NOTIMPL;
+    struct session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+    HANDLE thread;
+    HRESULT hr;
+
+    TRACE("iface %p, action %p.\n", iface, action);
+
+    if (FAILED(hr = async_action_create(NULL, session_stop_async, action)))
+        return hr;
+
+    EnterCriticalSection(&impl->cs);
+    if (impl->worker_running && impl->worker_thread)
+    {
+        thread = impl->worker_thread;
+        impl->worker_thread = INVALID_HANDLE_VALUE;
+        impl->worker_running = FALSE;
+        impl->worker_paused = FALSE;
+        impl->recognizer_state = SpeechRecognizerState_Idle;
+    }
+    else
+    {
+        hr = COR_E_INVALIDOPERATION;
+    }
+    LeaveCriticalSection(&impl->cs);
+
+    if (SUCCEEDED(hr))
+    {
+        SetEvent(impl->worker_control_event);
+        WaitForSingleObject(thread, INFINITE);
+        CloseHandle(thread);
+
+        EnterCriticalSection(&impl->cs);
+        impl->worker_thread = NULL;
+        LeaveCriticalSection(&impl->cs);
+    }
+    else
+    {
+        IAsyncAction_Release(*action);
+        *action = NULL;
+    }
+
+    return hr;
 }
 
 static HRESULT WINAPI session_CancelAsync( ISpeechContinuousRecognitionSession *iface, IAsyncAction **action )
@@ -275,16 +486,53 @@ static HRESULT WINAPI session_CancelAsync( ISpeechContinuousRecognitionSession *
     return E_NOTIMPL;
 }
 
+static HRESULT session_pause_async( IInspectable *invoker )
+{
+    return S_OK;
+}
+
 static HRESULT WINAPI session_PauseAsync( ISpeechContinuousRecognitionSession *iface, IAsyncAction **action )
 {
-    FIXME("iface %p, action %p stub!\n", iface, action);
-    return E_NOTIMPL;
+    struct session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("iface %p, action %p.\n", iface, action);
+
+    *action = NULL;
+
+    if (FAILED(hr = async_action_create(NULL, session_pause_async, action)))
+        return hr;
+
+    EnterCriticalSection(&impl->cs);
+    if (impl->worker_running)
+    {
+        impl->worker_paused = TRUE;
+        impl->recognizer_state = SpeechRecognizerState_Paused;
+    }
+    LeaveCriticalSection(&impl->cs);
+
+    SetEvent(impl->worker_control_event);
+
+    return hr;
 }
 
 static HRESULT WINAPI session_Resume( ISpeechContinuousRecognitionSession *iface )
 {
-    FIXME("iface %p stub!\n", iface);
-    return E_NOTIMPL;
+    struct session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    EnterCriticalSection(&impl->cs);
+    if (impl->worker_running)
+    {
+        impl->worker_paused = FALSE;
+        impl->recognizer_state = SpeechRecognizerState_Capturing;
+    }
+    LeaveCriticalSection(&impl->cs);
+
+    SetEvent(impl->worker_control_event);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI session_add_Completed( ISpeechContinuousRecognitionSession *iface,
@@ -360,7 +608,6 @@ struct recognizer
     LONG ref;
 
     ISpeechContinuousRecognitionSession *session;
-    IVector_ISpeechRecognitionConstraint *constraints;
 };
 
 /*
@@ -424,7 +671,6 @@ static ULONG WINAPI recognizer_Release( ISpeechRecognizer *iface )
     if (!ref)
     {
         ISpeechContinuousRecognitionSession_Release(impl->session);
-        IVector_ISpeechRecognitionConstraint_Release(impl->constraints);
         free(impl);
     }
 
@@ -452,8 +698,11 @@ static HRESULT WINAPI recognizer_GetTrustLevel( ISpeechRecognizer *iface, TrustL
 static HRESULT WINAPI recognizer_get_Constraints( ISpeechRecognizer *iface, IVector_ISpeechRecognitionConstraint **vector )
 {
     struct recognizer *impl = impl_from_ISpeechRecognizer(iface);
+    struct session *session = impl_from_ISpeechContinuousRecognitionSession(impl->session);
+
     TRACE("iface %p, operation %p.\n", iface, vector);
-    IVector_ISpeechRecognitionConstraint_AddRef((*vector = impl->constraints));
+
+    IVector_ISpeechRecognitionConstraint_AddRef((*vector = session->constraints));
     return S_OK;
 }
 
@@ -475,7 +724,7 @@ static HRESULT WINAPI recognizer_get_UIOptions( ISpeechRecognizer *iface, ISpeec
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI compile_callback( IInspectable *invoker, IInspectable **result )
+static HRESULT recognizer_compile_constraints_async( IInspectable *invoker, IInspectable **result )
 {
     return compilation_result_create(SpeechRecognitionResultStatus_Success, (ISpeechRecognitionCompilationResult **) result);
 }
@@ -485,7 +734,7 @@ static HRESULT WINAPI recognizer_CompileConstraintsAsync( ISpeechRecognizer *ifa
 {
     IAsyncOperation_IInspectable **value = (IAsyncOperation_IInspectable **)operation;
     FIXME("iface %p, operation %p semi-stub!\n", iface, operation);
-    return async_operation_inspectable_create(&IID_IAsyncOperation_SpeechRecognitionCompilationResult, NULL, compile_callback, value);
+    return async_operation_inspectable_create(&IID_IAsyncOperation_SpeechRecognitionCompilationResult, NULL, recognizer_compile_constraints_async, value);
 }
 
 static HRESULT WINAPI recognizer_RecognizeAsync( ISpeechRecognizer *iface,
@@ -601,8 +850,19 @@ static HRESULT WINAPI recognizer2_get_ContinuousRecognitionSession( ISpeechRecog
 
 static HRESULT WINAPI recognizer2_get_State( ISpeechRecognizer2 *iface, SpeechRecognizerState *state )
 {
-    FIXME("iface %p, state %p stub!\n", iface, state);
-    return E_NOTIMPL;
+    struct recognizer *impl = impl_from_ISpeechRecognizer2(iface);
+    struct session *session = impl_from_ISpeechContinuousRecognitionSession(impl->session);
+
+    FIXME("iface %p, state %p not all states are supported, yet.\n", iface, state);
+
+    if (!state)
+        return E_POINTER;
+
+    EnterCriticalSection(&session->cs);
+    *state = session->recognizer_state;
+    LeaveCriticalSection(&session->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI recognizer2_StopRecognitionAsync( ISpeechRecognizer2 *iface, IAsyncAction **action )
@@ -770,6 +1030,55 @@ static const struct IActivationFactoryVtbl activation_factory_vtbl =
 
 DEFINE_IINSPECTABLE(recognizer_factory, ISpeechRecognizerFactory, struct recognizer_statics, IActivationFactory_iface)
 
+static HRESULT recognizer_factory_create_audio_capture(struct session *session)
+{
+    const REFERENCE_TIME buffer_duration = 5000000; /* 0.5 second */
+    IMMDeviceEnumerator *mm_enum = NULL;
+    IMMDevice *mm_device = NULL;
+    WAVEFORMATEX wfx = { 0 };
+    WCHAR *str = NULL;
+    HRESULT hr = S_OK;
+
+    if (!(session->audio_buf_event = CreateEventW(NULL, FALSE, FALSE, NULL)))
+        return HRESULT_FROM_WIN32(GetLastError());
+
+    if (FAILED(hr = CoCreateInstance(&CLSID_MMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER, &IID_IMMDeviceEnumerator, (void **)&mm_enum)))
+        goto cleanup;
+
+    if (FAILED(hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(mm_enum, eCapture, eMultimedia, &mm_device)))
+        goto cleanup;
+
+    if (FAILED(hr = IMMDevice_Activate(mm_device, &IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void **)&session->audio_client)))
+        goto cleanup;
+
+    hr = IMMDevice_GetId(mm_device, &str);
+    TRACE("selected capture device ID: %s, hr %#lx\n", debugstr_w(str), hr);
+
+    wfx.wFormatTag = WAVE_FORMAT_PCM;
+    wfx.nSamplesPerSec = 16000;
+    wfx.nChannels = 1;
+    wfx.wBitsPerSample = 16;
+    wfx.nBlockAlign = (wfx.wBitsPerSample + 7) / 8 * wfx.nChannels;
+    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
+    TRACE("wfx tag %u, channels %u, samples %lu, bits %u, align %u.\n", wfx.wFormatTag, wfx.nChannels, wfx.nSamplesPerSec, wfx.wBitsPerSample, wfx.nBlockAlign);
+
+    if (FAILED(hr = IAudioClient_Initialize(session->audio_client, AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_EVENTCALLBACK, buffer_duration, 0, &wfx, NULL)))
+        goto cleanup;
+
+    if (FAILED(hr = IAudioClient_SetEventHandle(session->audio_client, session->audio_buf_event)))
+        goto cleanup;
+
+    hr = IAudioClient_GetService(session->audio_client, &IID_IAudioCaptureClient, (void **)&session->capture_client);
+
+    session->capture_wfx = wfx;
+
+cleanup:
+    if (mm_device) IMMDevice_Release(mm_device);
+    if (mm_enum) IMMDeviceEnumerator_Release(mm_enum);
+    CoTaskMemFree(str);
+    return hr;
+}
+
 static HRESULT WINAPI recognizer_factory_Create( ISpeechRecognizerFactory *iface, ILanguage *language, ISpeechRecognizer **speechrecognizer )
 {
     struct recognizer *impl;
@@ -797,25 +1106,45 @@ static HRESULT WINAPI recognizer_factory_Create( ISpeechRecognizerFactory *iface
     if (language)
         FIXME("language parameter unused. Stub!\n");
 
+    /* Init ISpeechContinuousRecognitionSession */
     session->ISpeechContinuousRecognitionSession_iface.lpVtbl = &session_vtbl;
     session->ref = 1;
+
     list_init(&session->completed_handlers);
     list_init(&session->result_handlers);
 
+    if (!(session->worker_control_event = CreateEventW(NULL, FALSE, FALSE, NULL)))
+    {
+        hr = HRESULT_FROM_WIN32(GetLastError());
+        goto error;
+    }
+
+    if (FAILED(hr = vector_inspectable_create(&constraints_iids, (IVector_IInspectable**)&session->constraints)))
+        goto error;
+
+    if (FAILED(hr = recognizer_factory_create_audio_capture(session)))
+        goto error;
+
+    InitializeCriticalSection(&session->cs);
+    session->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": recognition_session.cs");
+
+    /* Init ISpeechRecognizer */
     impl->ISpeechRecognizer_iface.lpVtbl = &speech_recognizer_vtbl;
     impl->IClosable_iface.lpVtbl = &closable_vtbl;
     impl->ISpeechRecognizer2_iface.lpVtbl = &speech_recognizer2_vtbl;
     impl->session = &session->ISpeechContinuousRecognitionSession_iface;
     impl->ref = 1;
-    if (FAILED(hr = vector_inspectable_create(&constraints_iids, (IVector_IInspectable**)&impl->constraints)))
-        goto error;
-
-    TRACE("created SpeechRecognizer %p.\n", impl);
 
     *speechrecognizer = &impl->ISpeechRecognizer_iface;
+    TRACE("created SpeechRecognizer %p.\n", *speechrecognizer);
     return S_OK;
 
 error:
+    if (session->capture_client) IAudioCaptureClient_Release(session->capture_client);
+    if (session->audio_client) IAudioClient_Release(session->audio_client);
+    if (session->audio_buf_event) CloseHandle(session->audio_buf_event);
+    if (session->constraints) IVector_ISpeechRecognitionConstraint_Release(session->constraints);
+    if (session->worker_control_event) CloseHandle(session->worker_control_event);
     free(session);
     free(impl);
 
diff --git a/dlls/windows.media.speech/synthesizer.c b/dlls/windows.media.speech/synthesizer.c
index ce257c7c355..39d14b84ab7 100644
--- a/dlls/windows.media.speech/synthesizer.c
+++ b/dlls/windows.media.speech/synthesizer.c
@@ -375,7 +375,7 @@ static HRESULT WINAPI synthesizer_GetTrustLevel( ISpeechSynthesizer *iface, Trus
     return E_NOTIMPL;
 }
 
-static HRESULT CALLBACK text_to_stream_operation( IInspectable *invoker, IInspectable **result )
+static HRESULT synthesizer_synthesize_text_to_stream_async( IInspectable *invoker, IInspectable **result )
 {
     return synthesis_stream_create((ISpeechSynthesisStream **)result);
 }
@@ -385,10 +385,10 @@ static HRESULT WINAPI synthesizer_SynthesizeTextToStreamAsync( ISpeechSynthesize
 {
     TRACE("iface %p, text %p, operation %p.\n", iface, text, operation);
     return async_operation_inspectable_create(&IID_IAsyncOperation_SpeechSynthesisStream, NULL,
-                                              text_to_stream_operation, (IAsyncOperation_IInspectable **)operation);
+                                              synthesizer_synthesize_text_to_stream_async, (IAsyncOperation_IInspectable **)operation);
 }
 
-static HRESULT CALLBACK ssml_to_stream_operation( IInspectable *invoker, IInspectable **result )
+static HRESULT synthesizer_synthesize_ssml_to_stream_async( IInspectable *invoker, IInspectable **result )
 {
     return synthesis_stream_create((ISpeechSynthesisStream **)result);
 }
@@ -398,7 +398,7 @@ static HRESULT WINAPI synthesizer_SynthesizeSsmlToStreamAsync( ISpeechSynthesize
 {
     TRACE("iface %p, ssml %p, operation %p.\n", iface, ssml, operation);
     return async_operation_inspectable_create(&IID_IAsyncOperation_SpeechSynthesisStream, NULL,
-                                              ssml_to_stream_operation, (IAsyncOperation_IInspectable **)operation);
+                                              synthesizer_synthesize_ssml_to_stream_async, (IAsyncOperation_IInspectable **)operation);
 }
 
 static HRESULT WINAPI synthesizer_put_Voice( ISpeechSynthesizer *iface, IVoiceInformation *value )
diff --git a/dlls/windows.media.speech/tests/speech.c b/dlls/windows.media.speech/tests/speech.c
index 445d10923ae..6bc5a8b1751 100644
--- a/dlls/windows.media.speech/tests/speech.c
+++ b/dlls/windows.media.speech/tests/speech.c
@@ -18,6 +18,7 @@
 #define COBJMACROS
 #include <stdarg.h>
 
+#include "corerror.h"
 #include "windef.h"
 #include "winbase.h"
 #include "winerror.h"
@@ -1619,6 +1620,7 @@ static void test_Recognition(void)
     struct iterator_hstring iterator_hstring;
     struct iterable_hstring iterable_hstring;
     EventRegistrationToken token = { .value = 0 };
+    SpeechRecognizerState recog_state;
     HSTRING commands[3], hstr, tag;
     HANDLE put_thread;
     LONG ref, old_ref;
@@ -1717,6 +1719,11 @@ static void test_Recognition(void)
     ok(hr == S_OK, "ISpeechContinuousRecognitionSession_add_ResultGenerated failed, hr %#lx.\n", hr);
     ok(token.value != 0xdeadbeef, "Got unexpexted token: %#I64x.\n", token.value);
 
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Idle, "recog_state was %u.\n", recog_state);
+
     hr = ISpeechRecognizer_CompileConstraintsAsync(recognizer, &operation);
     ok(hr == S_OK, "ISpeechRecognizer_CompileConstraintsAsync failed, hr %#lx.\n", hr);
     await_async_inspectable((IAsyncOperation_IInspectable *)operation,
@@ -1735,6 +1742,11 @@ static void test_Recognition(void)
 
     await_async_void(action, &action_handler);
 
+    action2 = (void *)0xdeadbeef;
+    hr = ISpeechContinuousRecognitionSession_StartAsync(session, &action2);
+    ok(hr == COR_E_INVALIDOPERATION, "ISpeechContinuousRecognitionSession_StartAsync failed, hr %#lx.\n", hr);
+    ok(action2 == NULL, "action2 was %p.\n", action2);
+
     hr = IAsyncAction_QueryInterface(action, &IID_IAsyncInfo, (void **)&info);
     ok(hr == S_OK, "IAsyncAction_QueryInterface failed, hr %#lx.\n", hr);
     check_async_info((IInspectable *)action, 1, Completed, S_OK);
@@ -1757,14 +1769,48 @@ static void test_Recognition(void)
 
     IAsyncInfo_Release(info);
 
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Capturing, "recog_state was %u.\n", recog_state);
+
     /*
      * TODO: Use a loopback device together with prerecorded audio files to test the recognizer's functionality.
      */
 
-    hr = ISpeechContinuousRecognitionSession_StopAsync(session, &action2);
-    todo_wine ok(hr == S_OK, "ISpeechContinuousRecognitionSession_StopAsync failed, hr %#lx.\n", hr);
+    hr = ISpeechContinuousRecognitionSession_PauseAsync(session, &action2);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_PauseAsync failed, hr %#lx.\n", hr);
+    await_async_void(action2, &action_handler);
+    check_async_info((IInspectable *)action2, 3, Completed, S_OK);
+    IAsyncAction_Release(action2);
+
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Paused ||
+       broken(recog_state == SpeechRecognizerState_Capturing) /* Broken on Win10 1507 */, "recog_state was %u.\n", recog_state);
+
+    /* Check what happens if we try to pause again, when the session is already paused. */
+    hr = ISpeechContinuousRecognitionSession_PauseAsync(session, &action2);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_PauseAsync failed, hr %#lx.\n", hr);
+    await_async_void(action2, &action_handler);
+    check_async_info((IInspectable *)action2, 4, Completed, S_OK);
+    IAsyncAction_Release(action2);
+
+    hr = ISpeechContinuousRecognitionSession_Resume(session);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_Resume failed, hr %#lx.\n", hr);
+
+    /* Resume when already resumed. */
+    hr = ISpeechContinuousRecognitionSession_Resume(session);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_Resume failed, hr %#lx.\n", hr);
 
-    if (FAILED(hr)) goto skip_action;
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Capturing, "recog_state was %u.\n", recog_state);
+
+    hr = ISpeechContinuousRecognitionSession_StopAsync(session, &action2);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_StopAsync failed, hr %#lx.\n", hr);
 
     async_void_handler_create_static(&action_handler);
     action_handler.event_block = CreateEventW(NULL, FALSE, FALSE, NULL);
@@ -1776,40 +1822,92 @@ static void test_Recognition(void)
     put_param.handler = &action_handler.IAsyncActionCompletedHandler_iface;
     put_param.action = action2;
     put_thread = CreateThread(NULL, 0, action_put_completed_thread, &put_param, 0, NULL);
-    todo_wine ok(!WaitForSingleObject(action_handler.event_finished , 5000), "Wait for event_finished failed.\n");
+    ok(!WaitForSingleObject(action_handler.event_finished , 5000), "Wait for event_finished failed.\n");
 
     handler = (void *)0xdeadbeef;
     old_ref = action_handler.ref;
     hr = IAsyncAction_get_Completed(action2, &handler);
-    todo_wine ok(hr == S_OK, "IAsyncAction_get_Completed failed, hr %#lx.\n", hr);
+    ok(hr == S_OK, "IAsyncAction_get_Completed failed, hr %#lx.\n", hr);
 
-    todo_wine ok(handler == &action_handler.IAsyncActionCompletedHandler_iface || /* Broken on 1507. */
-                            broken(handler != NULL && handler != (void *)0xdeadbeef), "Handler was %p.\n", handler);
+    todo_wine ok(handler == &action_handler.IAsyncActionCompletedHandler_iface, "Handler was %p.\n", handler);
 
     ref = action_handler.ref - old_ref;
     todo_wine ok(ref == 1, "The ref was increased by %lu.\n", ref);
-    IAsyncActionCompletedHandler_Release(handler);
+    if (handler) IAsyncActionCompletedHandler_Release(handler);
 
     hr = IAsyncAction_QueryInterface(action2, &IID_IAsyncInfo, (void **)&info);
-    todo_wine ok(hr == S_OK, "IAsyncAction_QueryInterface failed, hr %#lx.\n", hr);
+    ok(hr == S_OK, "IAsyncAction_QueryInterface failed, hr %#lx.\n", hr);
 
     hr = IAsyncInfo_Close(info); /* If IAsyncInfo_Close would wait for the handler to finish, the test would get stuck here. */
-    todo_wine ok(hr == S_OK, "IAsyncInfo_Close failed, hr %#lx.\n", hr);
-    check_async_info((IInspectable *)action2, 3, AsyncStatus_Closed, S_OK);
+    ok(hr == S_OK, "IAsyncInfo_Close failed, hr %#lx.\n", hr);
+    check_async_info((IInspectable *)action2, 5, AsyncStatus_Closed, S_OK);
 
     set = SetEvent(action_handler.event_block);
-    todo_wine ok(set == TRUE, "Event 'event_block' wasn't set.\n");
-    todo_wine ok(!WaitForSingleObject(put_thread , 1000), "Wait for put_thread failed.\n");
+    ok(set == TRUE, "Event 'event_block' wasn't set.\n");
+    ok(!WaitForSingleObject(put_thread, 1000), "Wait for put_thread failed.\n");
     IAsyncInfo_Release(info);
 
     CloseHandle(action_handler.event_finished);
     CloseHandle(action_handler.event_block);
     CloseHandle(put_thread);
 
-    todo_wine ok(action != action2, "actions were the same!\n");
+    ok(action != action2, "actions were the same!\n");
 
     IAsyncAction_Release(action2);
-skip_action:
+    IAsyncAction_Release(action);
+
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Idle, "recog_state was %u.\n", recog_state);
+
+    /* Try stopping, when already stopped. */
+    hr = ISpeechContinuousRecognitionSession_StopAsync(session, &action);
+    ok(hr == COR_E_INVALIDOPERATION, "ISpeechContinuousRecognitionSession_StopAsync failed, hr %#lx.\n", hr);
+    ok(action == NULL, "action was %p.\n", action);
+
+    /* Test, if Start/StopAsync resets the pause state. */
+    hr = ISpeechContinuousRecognitionSession_StartAsync(session, &action);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_StartAsync failed, hr %#lx.\n", hr);
+    await_async_void(action, &action_handler);
+    IAsyncAction_Release(action);
+
+    hr = ISpeechContinuousRecognitionSession_PauseAsync(session, &action);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_PauseAsync failed, hr %#lx.\n", hr);
+    await_async_void(action, &action_handler);
+    IAsyncAction_Release(action);
+
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Paused ||
+       broken(recog_state == SpeechRecognizerState_Capturing) /* Broken on Win10 1507 */, "recog_state was %u.\n", recog_state);
+
+    hr = ISpeechContinuousRecognitionSession_StopAsync(session, &action);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_PauseAsync failed, hr %#lx.\n", hr);
+    await_async_void(action, &action_handler);
+    IAsyncAction_Release(action);
+
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Idle, "recog_state was %u.\n", recog_state);
+
+    hr = ISpeechContinuousRecognitionSession_StartAsync(session, &action);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_PauseAsync failed, hr %#lx.\n", hr);
+    await_async_void(action, &action_handler);
+    IAsyncAction_Release(action);
+
+    recog_state = 0xdeadbeef;
+    hr = ISpeechRecognizer2_get_State(recognizer2, &recog_state);
+    ok(hr == S_OK, "ISpeechRecognizer2_get_State failed, hr %#lx.\n", hr);
+    ok(recog_state == SpeechRecognizerState_Capturing
+       || broken(recog_state == SpeechRecognizerState_Idle) /* Sometimes Windows is a little behind. */,
+       "recog_state was %u.\n", recog_state);
+
+    hr = ISpeechContinuousRecognitionSession_StopAsync(session, &action);
+    ok(hr == S_OK, "ISpeechContinuousRecognitionSession_PauseAsync failed, hr %#lx.\n", hr);
+    await_async_void(action, &action_handler);
     IAsyncAction_Release(action);
 
     hr = ISpeechContinuousRecognitionSession_remove_ResultGenerated(session, token);
diff --git a/dlls/windows.system.profile.systemmanufacturers/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
new file mode 100644
index 00000000000..9d07caa287c
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
@@ -0,0 +1,8 @@
+MODULE  = windows.system.profile.systemmanufacturers.dll
+IMPORTS = combase oleaut32
+
+C_SRCS = \
+	main.c
+
+IDL_SRCS = \
+	classes.idl
diff --git a/dlls/windows.system.profile.systemmanufacturers/classes.idl b/dlls/windows.system.profile.systemmanufacturers/classes.idl
new file mode 100644
index 00000000000..6072a782222
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/classes.idl
@@ -0,0 +1,23 @@
+/*
+ * Runtime Classes for windows.system.profile.systemmanufacturers.dll
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+#include "windows.system.profile.systemmanufacturers.idl"
diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
new file mode 100644
index 00000000000..d2feb32054e
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -0,0 +1,236 @@
+/* WinRT Windows.System.Profile.SystemManufacturers Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "initguid.h"
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(smbios);
+
+static const char *debugstr_hstring( HSTRING hstr )
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+struct smbios_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    ISmbiosInformationStatics ISmbiosInformationStatics_iface;
+    LONG ref;
+};
+
+static inline struct smbios_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct smbios_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_ISmbiosInformationStatics ))
+    {
+        *out = &impl->ISmbiosInformationStatics_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+DEFINE_IINSPECTABLE( statics, ISmbiosInformationStatics, struct smbios_statics, IActivationFactory_iface )
+
+static HRESULT get_bios_serialnumber( BSTR *value )
+{
+    const WCHAR *class = L"Win32_BIOS";
+    IEnumWbemClassObject *wbem_enum;
+    IWbemClassObject *wbem_class;
+    IWbemServices *wbem_service;
+    IWbemLocator *wbem_locator;
+    VARIANT serial;
+    ULONG count;
+    HRESULT hr;
+    BSTR bstr;
+
+    hr = CoCreateInstance( &CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (void**)&wbem_locator );
+    if (FAILED(hr)) return hr;
+
+    bstr = SysAllocString( L"ROOT\\CIMV2" );
+    if (!bstr)
+    {
+        IWbemLocator_Release( wbem_locator );
+        return E_OUTOFMEMORY;
+    }
+    hr = IWbemLocator_ConnectServer( wbem_locator, bstr, NULL, NULL, NULL, 0, NULL, NULL, &wbem_service );
+    IWbemLocator_Release( wbem_locator );
+    SysFreeString( bstr );
+    if (FAILED(hr)) return hr;
+
+    bstr = SysAllocString( class );
+    if (!bstr)
+    {
+        IWbemServices_Release( wbem_service );
+        return E_OUTOFMEMORY;
+    }
+    hr = IWbemServices_CreateInstanceEnum( wbem_service, bstr, WBEM_FLAG_SYSTEM_ONLY, NULL, &wbem_enum );
+    IWbemServices_Release( wbem_service );
+    SysFreeString( bstr );
+    if (FAILED(hr)) return hr;
+
+    hr = IEnumWbemClassObject_Next( wbem_enum, 1000, 1, &wbem_class, &count );
+    IEnumWbemClassObject_Release( wbem_enum );
+    if (FAILED(hr)) return hr;
+
+    hr = IWbemClassObject_Get( wbem_class, L"SerialNumber", 0, &serial, NULL, NULL );
+    IWbemClassObject_Release( wbem_class );
+    if (FAILED(hr)) return hr;
+
+    *value = V_BSTR( &serial );
+    VariantClear( &serial );
+    return hr;
+}
+
+static HRESULT WINAPI statics_get_SerialNumber( ISmbiosInformationStatics *iface, HSTRING *value )
+{
+    BSTR serial;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED( hr = get_bios_serialnumber( &serial ) )) return hr;
+    if (FAILED( hr = WindowsCreateString( serial, wcslen(serial), value ) )) return hr;
+
+    TRACE( "Returning serial number: %s.\n", debugstr_w( serial ) );
+    return hr;
+}
+
+static const struct ISmbiosInformationStaticsVtbl statics_vtbl =
+{
+    statics_QueryInterface,
+    statics_AddRef,
+    statics_Release,
+    /* IInspectable methods */
+    statics_GetIids,
+    statics_GetRuntimeClassName,
+    statics_GetTrustLevel,
+    /* ISmbiosInformationStatics methods */
+    statics_get_SerialNumber,
+};
+
+static struct smbios_statics smbios_statics =
+{
+    {&factory_vtbl},
+    {&statics_vtbl},
+    1,
+};
+
+static IActivationFactory *smbios_factory = &smbios_statics.IActivationFactory_iface;
+
+HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID riid, void **out )
+{
+    FIXME( "clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out );
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory( HSTRING classid, IActivationFactory **factory )
+{
+    const WCHAR *name = WindowsGetStringRawBuffer( classid, NULL );
+
+    TRACE( "classid %s, factory %p.\n", debugstr_hstring(classid), factory );
+
+    *factory = NULL;
+
+    if (!wcscmp( name, RuntimeClass_Windows_System_Profile_SystemManufacturers_SmbiosInformation ))
+        IActivationFactory_QueryInterface( smbios_factory, &IID_IActivationFactory, (void **)factory );
+
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
new file mode 100644
index 00000000000..374a2829130
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -0,0 +1,71 @@
+/* WinRT Windows.System.Profile.SystemManufacturers Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "activation.h"
+
+#define WIDL_using_Windows_System_Profile_SystemManufacturers
+#include "windows.system.profile.systemmanufacturers.h"
+
+#include "wbemcli.h"
+
+#define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
+    static inline impl_type *impl_from( iface_type *iface )                                        \
+    {                                                                                              \
+        return CONTAINING_RECORD( iface, impl_type, iface_mem );                                   \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_QueryInterface( (IInspectable *)(expr), iid, out );                    \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_AddRef( iface_type *iface )                                          \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_AddRef( (IInspectable *)(expr) );                                      \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_Release( iface_type *iface )                                         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_Release( (IInspectable *)(expr) );                                     \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetIids( iface_type *iface, ULONG *iid_count, IID **iids )         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetIids( (IInspectable *)(expr), iid_count, iids );                    \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetRuntimeClassName( iface_type *iface, HSTRING *class_name )      \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetRuntimeClassName( (IInspectable *)(expr), class_name );             \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetTrustLevel( iface_type *iface, TrustLevel *trust_level )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetTrustLevel( (IInspectable *)(expr), trust_level );                  \
+    }
+#define DEFINE_IINSPECTABLE( pfx, iface_type, impl_type, base_iface )                              \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
new file mode 100644
index 00000000000..ade0c6b12dd
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL = windows.system.profile.systemmanufacturers.dll
+IMPORTS = combase
+
+C_SRCS = \
+	smbios.c
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
new file mode 100644
index 00000000000..8d02b2c423a
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+#include "initguid.h"
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "roapi.h"
+
+#define WIDL_using_Windows_System_Profile_SystemManufacturers
+#include "windows.system.profile.systemmanufacturers.h"
+
+#include "wine/test.h"
+
+#define check_interface( obj, iid ) check_interface_( __LINE__, obj, iid )
+static void check_interface_( unsigned int line, void *obj, const IID *iid )
+{
+    IUnknown *iface = obj;
+    IUnknown *unk;
+    HRESULT hr;
+
+    hr = IUnknown_QueryInterface( iface, iid, (void **)&unk );
+    ok_(__FILE__, line)( hr == S_OK, "got hr %#lx.\n", hr );
+    IUnknown_Release( unk );
+}
+
+static void test_Smbios_Statics(void)
+{
+    static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
+    ISmbiosInformationStatics *smbios_statics;
+    IActivationFactory *factory;
+    HSTRING str, serial;
+    const WCHAR *buf;
+    HRESULT hr;
+    UINT32 len;
+    LONG ref;
+
+    hr = WindowsCreateString( smbios_statics_name, wcslen( smbios_statics_name ), &str );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    hr = RoGetActivationFactory( str, &IID_IActivationFactory, (void **)&factory );
+    WindowsDeleteString( str );
+    ok( hr == S_OK || broken( hr == REGDB_E_CLASSNOTREG ), "got hr %#lx.\n", hr );
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip( "%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w( smbios_statics_name ) );
+        return;
+    }
+
+    check_interface( factory, &IID_IUnknown );
+    check_interface( factory, &IID_IInspectable );
+    check_interface( factory, &IID_IAgileObject );
+
+    hr = IActivationFactory_QueryInterface( factory, &IID_ISmbiosInformationStatics, (void **)&smbios_statics );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    if (0) /* Win8 Crash */
+    {
+        hr = ISmbiosInformationStatics_get_SerialNumber( smbios_statics, &serial );
+        ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
+        if (hr == S_OK)
+        {
+            buf = WindowsGetStringRawBuffer( serial, &len );
+            ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
+            WindowsDeleteString( serial );
+        }
+    }
+
+    ref = ISmbiosInformationStatics_Release( smbios_statics );
+    ok( ref == 2, "got ref %ld.\n", ref );
+
+    ref = IActivationFactory_Release( factory );
+    ok( ref == 1, "got ref %ld.\n", ref );
+}
+
+START_TEST(smbios)
+{
+    HRESULT hr;
+
+    hr = RoInitialize( RO_INIT_MULTITHREADED );
+    ok( hr == S_OK, "RoInitialize failed, hr %#lx\n", hr );
+
+    test_Smbios_Statics();
+
+    RoUninitialize();
+}
diff --git a/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec b/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec
new file mode 100644
index 00000000000..31a5eafe950
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec
@@ -0,0 +1,3 @@
+@ stdcall -private DllGetActivationFactory(ptr ptr)
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
diff --git a/dlls/windows.ui/Makefile.in b/dlls/windows.ui/Makefile.in
new file mode 100644
index 00000000000..592d023f353
--- /dev/null
+++ b/dlls/windows.ui/Makefile.in
@@ -0,0 +1,9 @@
+MODULE  = windows.ui.dll
+IMPORTS = combase advapi32
+
+C_SRCS = \
+	main.c \
+	uisettings.c
+
+IDL_SRCS = \
+	classes.idl
diff --git a/dlls/windows.ui/classes.idl b/dlls/windows.ui/classes.idl
new file mode 100644
index 00000000000..e6680b2e550
--- /dev/null
+++ b/dlls/windows.ui/classes.idl
@@ -0,0 +1,23 @@
+/*
+ * Runtime Classes for windows.ui.dll
+ *
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+#include "windows.ui.viewmanagement.idl"
diff --git a/dlls/windows.ui/main.c b/dlls/windows.ui/main.c
new file mode 100644
index 00000000000..8896e0d1e71
--- /dev/null
+++ b/dlls/windows.ui/main.c
@@ -0,0 +1,55 @@
+/* WinRT Windows.UI Implementation
+ *
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "initguid.h"
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ui);
+
+static const char *debugstr_hstring( HSTRING hstr )
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer( hstr, &len );
+    return wine_dbgstr_wn( str, len );
+}
+
+HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID riid, void **out )
+{
+    FIXME( "clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out );
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory( HSTRING classid, IActivationFactory **factory )
+{
+    const WCHAR *buffer = WindowsGetStringRawBuffer( classid, NULL );
+
+    TRACE( "class %s, factory %p.\n", debugstr_hstring(classid), factory );
+
+    *factory = NULL;
+
+    if (!wcscmp( buffer, RuntimeClass_Windows_UI_ViewManagement_UISettings ))
+        IActivationFactory_QueryInterface( uisettings_factory, &IID_IActivationFactory, (void **)factory );
+
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
diff --git a/dlls/windows.ui/private.h b/dlls/windows.ui/private.h
new file mode 100644
index 00000000000..1af5faf152b
--- /dev/null
+++ b/dlls/windows.ui/private.h
@@ -0,0 +1,41 @@
+/* WinRT Windows.UI Implementation
+ *
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINDOWS_UI_PRIVATE_H
+#define __WINE_WINDOWS_UI_PRIVATE_H
+
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "activation.h"
+
+#define WIDL_using_Windows_Foundation
+#include "windows.foundation.h"
+#define WIDL_using_Windows_UI
+#include "windows.ui.h"
+#define WIDL_using_Windows_UI_ViewManagement
+#include "windows.ui.viewmanagement.h"
+
+extern IActivationFactory *uisettings_factory;
+
+#endif
diff --git a/dlls/windows.ui/tests/Makefile.in b/dlls/windows.ui/tests/Makefile.in
new file mode 100644
index 00000000000..76dbfb1677c
--- /dev/null
+++ b/dlls/windows.ui/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL = windows.ui.dll
+IMPORTS = combase advapi32
+
+C_SRCS = \
+	uisettings.c
diff --git a/dlls/windows.ui/tests/uisettings.c b/dlls/windows.ui/tests/uisettings.c
new file mode 100644
index 00000000000..bd1e7a02d20
--- /dev/null
+++ b/dlls/windows.ui/tests/uisettings.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+#include "initguid.h"
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "roapi.h"
+
+#define WIDL_using_Windows_Foundation
+#include "windows.foundation.h"
+#define WIDL_using_Windows_UI
+#include "windows.ui.h"
+#define WIDL_using_Windows_UI_ViewManagement
+#include "windows.ui.viewmanagement.h"
+
+#include "wine/test.h"
+
+static const WCHAR *subkey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
+static const WCHAR *name = L"AppsUseLightTheme";
+static const HKEY root = HKEY_CURRENT_USER;
+
+#define check_interface( obj, iid, exp ) check_interface_( __LINE__, obj, iid, exp )
+static void check_interface_( unsigned int line, void *obj, const IID *iid, BOOL supported )
+{
+    IUnknown *iface = obj;
+    IUnknown *unk;
+    HRESULT hr, expected_hr;
+
+    expected_hr = supported ? S_OK : E_NOINTERFACE;
+
+    hr = IUnknown_QueryInterface( iface, iid, (void **)&unk );
+    ok_( __FILE__, line )( hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr );
+    if (SUCCEEDED(hr))
+        IUnknown_Release( unk );
+}
+
+static DWORD get_app_theme(void)
+{
+    DWORD ret = 0, len = sizeof(ret), type;
+    HKEY hkey;
+
+    if (RegOpenKeyExW( root, subkey, 0, KEY_QUERY_VALUE, &hkey )) return 1;
+    if (RegQueryValueExW( hkey, name, NULL, &type, (BYTE *)&ret, &len ) || type != REG_DWORD) ret = 1;
+    RegCloseKey( hkey );
+    return ret;
+}
+
+static DWORD set_app_theme( DWORD mode )
+{
+    DWORD ret = 1, len = sizeof(ret);
+    HKEY hkey;
+
+    if (RegOpenKeyExW( root, subkey, 0, KEY_SET_VALUE, &hkey )) return 0;
+    if (RegSetValueExW( hkey, name, 0, REG_DWORD, (const BYTE *)&mode, len )) ret = 0;
+    RegCloseKey( hkey );
+    return ret;
+}
+
+static void reset_color( Color *value )
+{
+    value->A = 1;
+    value->R = 1;
+    value->G = 1;
+    value->B = 1;
+}
+
+static void test_UISettings(void)
+{
+    static const WCHAR *uisettings_name = L"Windows.UI.ViewManagement.UISettings";
+    IActivationFactory *factory;
+    IUISettings3 *uisettings3;
+    IInspectable *inspectable;
+    DWORD default_theme;
+    UIColorType type;
+    Color value;
+    HSTRING str;
+    HRESULT hr;
+    LONG ref;
+
+    hr = WindowsCreateString( uisettings_name, wcslen( uisettings_name ), &str );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    hr = RoGetActivationFactory( str, &IID_IActivationFactory, (void **)&factory );
+    ok( hr == S_OK || broken( hr == REGDB_E_CLASSNOTREG ), "got hr %#lx.\n", hr );
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip( "%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w( uisettings_name ) );
+        return;
+    }
+
+    check_interface( factory, &IID_IUnknown, TRUE );
+    check_interface( factory, &IID_IInspectable, TRUE );
+    check_interface( factory, &IID_IAgileObject, FALSE );
+    check_interface( factory, &IID_IUISettings3, FALSE );
+
+    hr = RoActivateInstance( str, &inspectable );
+    ok( hr == S_OK, "Got unexpected hr %#lx.\n", hr );
+    WindowsDeleteString( str );
+
+    hr = IInspectable_QueryInterface( inspectable, &IID_IUISettings3, (void **)&uisettings3 );
+    ok( hr == S_OK || broken( hr == E_NOINTERFACE ), "Got unexpected hr %#lx.\n", hr );
+    if (FAILED(hr))
+    {
+        win_skip( "IUISettings3 not supported.\n" );
+        goto skip_uisettings3;
+    }
+
+    check_interface( inspectable, &IID_IAgileObject, TRUE );
+
+    default_theme = get_app_theme();
+
+    /* Light Theme */
+    if (!set_app_theme( 1 )) goto done;
+
+    reset_color( &value );
+    type = UIColorType_Foreground;
+    hr = IUISettings3_GetColorValue( uisettings3, type, &value );
+    ok( hr == S_OK, "GetColorValue returned %#lx\n", hr );
+    ok( value.A == 255 && value.R == 0 && value.G == 0 && value.B == 0,
+        "got unexpected value.A == %d value.R == %d value.G == %d value.B == %d\n", value.A, value.R, value.G, value.B );
+
+    reset_color( &value );
+    type = UIColorType_Background;
+    hr = IUISettings3_GetColorValue( uisettings3, type, &value );
+    ok( hr == S_OK, "GetColorValue returned %#lx\n", hr );
+    ok( value.A == 255 && value.R == 255 && value.G == 255 && value.B == 255,
+        "got unexpected value.A == %d value.R == %d value.G == %d value.B == %d\n", value.A, value.R, value.G, value.B );
+
+    /* Dark Theme */
+    if (!set_app_theme( 0 )) goto done;
+
+    reset_color( &value );
+    type = UIColorType_Foreground;
+    hr = IUISettings3_GetColorValue( uisettings3, type, &value );
+    ok( hr == S_OK, "GetColorValue returned %#lx\n", hr );
+    todo_wine ok( value.A == 255 && value.R == 255 && value.G == 255 && value.B == 255,
+                  "got unexpected value.A == %d value.R == %d value.G == %d value.B == %d\n", value.A, value.R, value.G, value.B );
+
+    reset_color( &value );
+    type = UIColorType_Background;
+    hr = IUISettings3_GetColorValue( uisettings3, type, &value );
+    ok( hr == S_OK, "GetColorValue returned %#lx\n", hr );
+    todo_wine ok( value.A == 255 && value.R == 0 && value.G == 0 && value.B == 0,
+                  "got unexpected value.A == %d value.R == %d value.G == %d value.B == %d\n", value.A, value.R, value.G, value.B );
+
+done:
+    set_app_theme( default_theme );
+    IUISettings3_Release( uisettings3 );
+
+skip_uisettings3:
+    IInspectable_Release( inspectable );
+    ref = IActivationFactory_Release( factory );
+    ok( ref == 1, "got ref %ld.\n", ref );
+}
+
+START_TEST(uisettings)
+{
+    HRESULT hr;
+
+    hr = RoInitialize( RO_INIT_MULTITHREADED );
+    ok( hr == S_OK, "RoInitialize failed, hr %#lx\n", hr );
+
+    test_UISettings();
+
+    RoUninitialize();
+}
diff --git a/dlls/windows.ui/uisettings.c b/dlls/windows.ui/uisettings.c
new file mode 100644
index 00000000000..943fbb6a37e
--- /dev/null
+++ b/dlls/windows.ui/uisettings.c
@@ -0,0 +1,273 @@
+/* WinRT Windows.UI Implementation
+ *
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ui);
+
+struct uisettings
+{
+    IUISettings3 IUISettings3_iface;
+    LONG ref;
+};
+
+static inline struct uisettings *impl_from_IUISettings3( IUISettings3 *iface )
+{
+    return CONTAINING_RECORD( iface, struct uisettings, IUISettings3_iface );
+}
+
+static HRESULT WINAPI uisettings3_QueryInterface( IUISettings3 *iface, REFIID iid, void **out )
+{
+    struct uisettings *impl = impl_from_IUISettings3( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IUISettings3 ))
+    {
+        *out = &impl->IUISettings3_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI uisettings3_AddRef( IUISettings3 *iface )
+{
+    struct uisettings *impl = impl_from_IUISettings3( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI uisettings3_Release( IUISettings3 *iface )
+{
+    struct uisettings *impl = impl_from_IUISettings3( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+
+    if (!ref) free( impl );
+    return ref;
+}
+
+static HRESULT WINAPI uisettings3_GetIids( IUISettings3 *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uisettings3_GetRuntimeClassName( IUISettings3 *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uisettings3_GetTrustLevel( IUISettings3 *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static DWORD get_app_theme(void)
+{
+    static const WCHAR *subkey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
+    static const WCHAR *name = L"AppsUseLightTheme";
+    static const HKEY root = HKEY_CURRENT_USER;
+    DWORD ret = 0, len = sizeof(ret), type;
+    HKEY hkey;
+
+    if (RegOpenKeyExW( root, subkey, 0, KEY_QUERY_VALUE, &hkey )) return 1;
+    if (RegQueryValueExW( hkey, name, NULL, &type, (BYTE *)&ret, &len ) || type != REG_DWORD) ret = 1;
+    RegCloseKey( hkey );
+    return ret;
+}
+
+static void set_color_value( BYTE a, BYTE r, BYTE g, BYTE b, Color *out )
+{
+    out->A = a;
+    out->R = r;
+    out->G = g;
+    out->B = b;
+}
+
+static HRESULT WINAPI uisettings3_GetColorValue( IUISettings3 *iface, UIColorType type, Color *value )
+{
+    DWORD theme;
+
+    TRACE( "iface %p, type %d, value %p.\n", iface, type, value );
+
+    switch (type)
+    {
+    case UIColorType_Foreground:
+    case UIColorType_Background:
+        theme = get_app_theme();
+        break;
+    default:
+        FIXME( "type %d not implemented.\n", type );
+        return E_NOTIMPL;
+    }
+
+    if (type == UIColorType_Foreground)
+        set_color_value( 255, theme ? 0 : 255, theme ? 0 : 255, theme ? 0 : 255, value );
+    else
+        set_color_value( 255, theme ? 255 : 0, theme ? 255 : 0, theme ? 255 : 0, value );
+
+    TRACE( "Returning value.A = %d, value.R = %d, value.G = %d, value.B = %d\n", value->A, value->R, value->G, value->B );
+    return S_OK;
+}
+
+static HRESULT WINAPI uisettings3_add_ColorValuesChanged( IUISettings3 *iface, ITypedEventHandler_UISettings_IInspectable *handler, EventRegistrationToken *cookie )
+{
+    FIXME( "iface %p, handler %p, cookie %p stub!\n", iface, handler, cookie );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uisettings3_remove_ColorValuesChanged( IUISettings3 *iface, EventRegistrationToken cookie )
+{
+    FIXME( "iface %p, cookie %#I64x stub!\n", iface, cookie.value );
+    return E_NOTIMPL;
+}
+
+static const struct IUISettings3Vtbl uisettings3_vtbl =
+{
+    uisettings3_QueryInterface,
+    uisettings3_AddRef,
+    uisettings3_Release,
+    /* IInspectable methods */
+    uisettings3_GetIids,
+    uisettings3_GetRuntimeClassName,
+    uisettings3_GetTrustLevel,
+    /* IUISettings3 methods */
+    uisettings3_GetColorValue,
+    uisettings3_add_ColorValuesChanged,
+    uisettings3_remove_ColorValuesChanged,
+};
+
+struct uisettings_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    LONG ref;
+};
+
+static inline struct uisettings_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct uisettings_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct uisettings_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct uisettings_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct uisettings_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    struct uisettings *impl;
+
+    TRACE( "iface %p, instance %p.\n", iface, instance );
+
+    if (!(impl = calloc( 1, sizeof(*impl) )))
+    {
+        *instance = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    impl->IUISettings3_iface.lpVtbl = &uisettings3_vtbl;
+    impl->ref = 1;
+
+    *instance = (IInspectable *)&impl->IUISettings3_iface;
+    return S_OK;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+static struct uisettings_statics uisettings_statics =
+{
+    {&factory_vtbl},
+    1,
+};
+
+IActivationFactory *uisettings_factory = &uisettings_statics.IActivationFactory_iface;
diff --git a/dlls/windows.ui/windows.ui.spec b/dlls/windows.ui/windows.ui.spec
new file mode 100644
index 00000000000..7801fb70dcc
--- /dev/null
+++ b/dlls/windows.ui/windows.ui.spec
@@ -0,0 +1,7 @@
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetActivationFactory(ptr ptr)
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
+@ stub CreateControlInput
+@ stub CreateControlInputEx
diff --git a/dlls/wineandroid.drv/android.h b/dlls/wineandroid.drv/android.h
index 22652f11d27..0d073a63bcc 100644
--- a/dlls/wineandroid.drv/android.h
+++ b/dlls/wineandroid.drv/android.h
@@ -89,9 +89,7 @@ extern SHORT ANDROID_VkKeyScanEx( WCHAR ch, HKL hkl ) DECLSPEC_HIDDEN;
 extern void ANDROID_SetCursor( HCURSOR handle ) DECLSPEC_HIDDEN;
 extern BOOL ANDROID_CreateWindow( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void ANDROID_DestroyWindow( HWND hwnd ) DECLSPEC_HIDDEN;
-extern NTSTATUS ANDROID_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                     const LARGE_INTEGER *timeout,
-                                                     DWORD mask, DWORD flags ) DECLSPEC_HIDDEN;
+extern BOOL ANDROID_ProcessEvents( DWORD mask ) DECLSPEC_HIDDEN;
 extern LRESULT ANDROID_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp ) DECLSPEC_HIDDEN;
 extern void ANDROID_SetCursor( HCURSOR handle ) DECLSPEC_HIDDEN;
 extern void ANDROID_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha,
diff --git a/dlls/wineandroid.drv/init.c b/dlls/wineandroid.drv/init.c
index acf6b9abbbe..074aa6c6257 100644
--- a/dlls/wineandroid.drv/init.c
+++ b/dlls/wineandroid.drv/init.c
@@ -352,7 +352,7 @@ static const struct user_driver_funcs android_drv_funcs =
     .pCreateWindow = ANDROID_CreateWindow,
     .pDesktopWindowProc = ANDROID_DesktopWindowProc,
     .pDestroyWindow = ANDROID_DestroyWindow,
-    .pMsgWaitForMultipleObjectsEx = ANDROID_MsgWaitForMultipleObjectsEx,
+    .pProcessEvents = ANDROID_ProcessEvents,
     .pSetCapture = ANDROID_SetCapture,
     .pSetLayeredWindowAttributes = ANDROID_SetLayeredWindowAttributes,
     .pSetParent = ANDROID_SetParent,
diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
index a339c20ceda..f01df37a400 100644
--- a/dlls/wineandroid.drv/window.c
+++ b/dlls/wineandroid.drv/window.c
@@ -1200,20 +1200,17 @@ LRESULT ANDROID_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
 
 
 /***********************************************************************
- *           ANDROID_MsgWaitForMultipleObjectsEx
+ *           ANDROID_ProcessEvents
  */
-NTSTATUS ANDROID_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                              const LARGE_INTEGER *timeout,
-                                              DWORD mask, DWORD flags )
+BOOL ANDROID_ProcessEvents( DWORD mask )
 {
     if (GetCurrentThreadId() == desktop_tid)
     {
         /* don't process nested events */
         if (current_event) mask = 0;
-        if (process_events( mask )) return count - 1;
+        return process_events( mask );
     }
-    return NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                     !!(flags & MWMO_ALERTABLE), timeout );
+    return FALSE;
 }
 
 /**********************************************************************
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index c02f786a11f..ae676f80565 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -645,17 +645,16 @@ static void sdl_bus_free_mappings(struct sdl_bus_options *options)
 static void sdl_bus_load_mappings(struct sdl_bus_options *options)
 {
     ULONG idx = 0, len, count = 0, capacity, info_size, info_max_size;
+    UNICODE_STRING path = RTL_CONSTANT_STRING(L"map");
     KEY_VALUE_FULL_INFORMATION *info;
     OBJECT_ATTRIBUTES attr = {0};
     char **mappings = NULL;
-    UNICODE_STRING path;
     NTSTATUS status;
     HANDLE key;
 
     options->mappings_count = 0;
     options->mappings = NULL;
 
-    RtlInitUnicodeString(&path, L"map");
     InitializeObjectAttributes(&attr, &path, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, driver_key, NULL);
     status = NtOpenKey(&key, KEY_ALL_ACCESS, &attr);
     if (status) return;
diff --git a/dlls/wined3d/adapter_vk.c b/dlls/wined3d/adapter_vk.c
index 713aaec9e39..cf8a7aec6dc 100644
--- a/dlls/wined3d/adapter_vk.c
+++ b/dlls/wined3d/adapter_vk.c
@@ -40,6 +40,7 @@ static const struct wined3d_state_entry_template misc_state_template_vk[] =
     {STATE_VDECL,                                         {STATE_VDECL,                                         state_nop}},
     {STATE_DEPTH_STENCIL,                                 {STATE_DEPTH_STENCIL,                                 state_nop}},
     {STATE_STENCIL_REF,                                   {STATE_STENCIL_REF,                                   state_nop}},
+    {STATE_DEPTH_BOUNDS,                                  {STATE_DEPTH_BOUNDS,                                  state_nop}},
     {STATE_RASTERIZER,                                    {STATE_RASTERIZER,                                    state_nop}},
     {STATE_SCISSORRECT,                                   {STATE_SCISSORRECT,                                   state_nop}},
     {STATE_POINTSPRITECOORDORIGIN,                        {STATE_POINTSPRITECOORDORIGIN,                        state_nop}},
@@ -95,17 +96,8 @@ static const struct wined3d_state_entry_template misc_state_template_vk[] =
 
     {STATE_VIEWPORT,                                      {STATE_VIEWPORT,                                      state_nop}},
     {STATE_INDEXBUFFER,                                   {STATE_INDEXBUFFER,                                   state_nop}},
-    {STATE_RENDER(WINED3D_RS_ANTIALIAS),                  {STATE_RENDER(WINED3D_RS_ANTIALIAS),                  state_nop}},
-    {STATE_RENDER(WINED3D_RS_TEXTUREPERSPECTIVE),         {STATE_RENDER(WINED3D_RS_TEXTUREPERSPECTIVE),         state_nop}},
-    {STATE_RENDER(WINED3D_RS_WRAPU),                      {STATE_RENDER(WINED3D_RS_WRAPU),                      state_nop}},
-    {STATE_RENDER(WINED3D_RS_WRAPV),                      {STATE_RENDER(WINED3D_RS_WRAPV),                      state_nop}},
     {STATE_RENDER(WINED3D_RS_LINEPATTERN),                {STATE_RENDER(WINED3D_RS_LINEPATTERN),                state_nop}},
-    {STATE_RENDER(WINED3D_RS_MONOENABLE),                 {STATE_RENDER(WINED3D_RS_MONOENABLE),                 state_nop}},
-    {STATE_RENDER(WINED3D_RS_ROP2),                       {STATE_RENDER(WINED3D_RS_ROP2),                       state_nop}},
-    {STATE_RENDER(WINED3D_RS_PLANEMASK),                  {STATE_RENDER(WINED3D_RS_PLANEMASK),                  state_nop}},
-    {STATE_RENDER(WINED3D_RS_LASTPIXEL),                  {STATE_RENDER(WINED3D_RS_LASTPIXEL),                  state_nop}},
     {STATE_RENDER(WINED3D_RS_DITHERENABLE),               {STATE_RENDER(WINED3D_RS_DITHERENABLE),               state_nop}},
-    {STATE_RENDER(WINED3D_RS_SUBPIXEL),                   {STATE_RENDER(WINED3D_RS_SUBPIXEL),                   state_nop}},
     {STATE_RENDER(WINED3D_RS_SUBPIXELX),                  {STATE_RENDER(WINED3D_RS_SUBPIXELX),                  state_nop}},
     {STATE_RENDER(WINED3D_RS_STIPPLEDALPHA),              {STATE_RENDER(WINED3D_RS_STIPPLEDALPHA),              state_nop}},
     {STATE_RENDER(WINED3D_RS_STIPPLEENABLE),              {STATE_RENDER(WINED3D_RS_STIPPLEENABLE),              state_nop}},
@@ -145,7 +137,6 @@ static const struct wined3d_state_entry_template misc_state_template_vk[] =
     {STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION), {STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION), state_nop}},
     {STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),       {STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),       state_nop}},
     {STATE_RENDER(WINED3D_RS_DEBUGMONITORTOKEN),          {STATE_RENDER(WINED3D_RS_DEBUGMONITORTOKEN),          state_nop}},
-    {STATE_RENDER(WINED3D_RS_ZVISIBLE),                   {STATE_RENDER(WINED3D_RS_ZVISIBLE),                   state_nop}},
     /* Samplers */
     {STATE_SAMPLER(0),                                    {STATE_SAMPLER(0),                                    state_nop}},
     {STATE_SAMPLER(1),                                    {STATE_SAMPLER(1),                                    state_nop}},
@@ -308,6 +299,7 @@ static void wined3d_disable_vulkan_features(struct wined3d_physical_device_info
     features->shaderSampledImageArrayDynamicIndexing = VK_FALSE;
     features->shaderStorageBufferArrayDynamicIndexing = VK_FALSE;
     features->shaderStorageImageArrayDynamicIndexing = VK_FALSE;
+    features->shaderInt64 = VK_FALSE;
     features->shaderInt16 = VK_FALSE;
     features->shaderResourceResidency = VK_FALSE;
     features->shaderResourceMinLod = VK_FALSE;
@@ -2266,6 +2258,8 @@ static bool feature_level_10_supported(const struct wined3d_physical_device_info
             && info->features2.features.depthClamp
             && info->features2.features.depthBiasClamp
             && info->features2.features.pipelineStatisticsQuery
+            && info->features2.features.shaderClipDistance
+            && info->features2.features.shaderCullDistance
             && info->vertex_divisor_features.vertexAttributeInstanceRateDivisor
             && info->vertex_divisor_features.vertexAttributeInstanceRateZeroDivisor;
 }
@@ -2280,6 +2274,8 @@ static bool feature_level_11_supported(const struct wined3d_physical_device_info
     return shader_model >= 5
             && info->features2.features.multiDrawIndirect
             && info->features2.features.drawIndirectFirstInstance
+            && info->features2.features.fragmentStoresAndAtomics
+            && info->features2.features.shaderImageGatherExtended
             && info->features2.features.tessellationShader;
 }
 
diff --git a/dlls/wined3d/context_gl.c b/dlls/wined3d/context_gl.c
index 0217e12d903..5574997bf05 100644
--- a/dlls/wined3d/context_gl.c
+++ b/dlls/wined3d/context_gl.c
@@ -2726,7 +2726,7 @@ static void wined3d_context_gl_destroy_allocator_block(struct wined3d_context_gl
     struct wined3d_device_gl *device_gl = wined3d_device_gl(context_gl->c.device);
     struct wined3d_retired_block_gl *r;
 
-    if (device_gl->completed_fence_id > fence_id)
+    if (device_gl->completed_fence_id >= fence_id)
     {
         wined3d_device_gl_free_memory(device_gl, block);
         TRACE("Freed block %p.\n", block);
diff --git a/dlls/wined3d/context_vk.c b/dlls/wined3d/context_vk.c
index 769e5347cc5..1acb8a8d201 100644
--- a/dlls/wined3d/context_vk.c
+++ b/dlls/wined3d/context_vk.c
@@ -667,7 +667,7 @@ void wined3d_context_vk_destroy_vk_framebuffer(struct wined3d_context_vk *contex
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyFramebuffer(device_vk->vk_device, vk_framebuffer, NULL));
         TRACE("Destroyed framebuffer 0x%s.\n", wine_dbgstr_longlong(vk_framebuffer));
@@ -708,7 +708,7 @@ static void wined3d_context_vk_reset_vk_descriptor_pool(struct wined3d_context_v
 {
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         wined3d_context_vk_return_vk_descriptor_pool(context_vk, vk_descriptor_pool);
         TRACE("Reset descriptor pool 0x%s.\n", wine_dbgstr_longlong(vk_descriptor_pool));
@@ -733,7 +733,7 @@ void wined3d_context_vk_destroy_vk_memory(struct wined3d_context_vk *context_vk,
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkFreeMemory(device_vk->vk_device, vk_memory, NULL));
         TRACE("Freed memory 0x%s.\n", wine_dbgstr_longlong(vk_memory));
@@ -756,7 +756,7 @@ void wined3d_context_vk_destroy_allocator_block(struct wined3d_context_vk *conte
 {
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         wined3d_context_vk_free_memory(context_vk, block);
         TRACE("Freed block %p.\n", block);
@@ -811,7 +811,7 @@ static void wined3d_context_vk_destroy_bo_slab_slice(struct wined3d_context_vk *
 {
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         wined3d_bo_slab_vk_free_slice(slab, idx, context_vk);
         return;
@@ -836,7 +836,7 @@ static void wined3d_context_vk_destroy_vk_buffer(struct wined3d_context_vk *cont
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyBuffer(device_vk->vk_device, vk_buffer, NULL));
         TRACE("Destroyed buffer 0x%s.\n", wine_dbgstr_longlong(vk_buffer));
@@ -861,7 +861,7 @@ void wined3d_context_vk_destroy_vk_image(struct wined3d_context_vk *context_vk,
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyImage(device_vk->vk_device, vk_image, NULL));
         TRACE("Destroyed image 0x%s.\n", wine_dbgstr_longlong(vk_image));
@@ -886,7 +886,7 @@ void wined3d_context_vk_destroy_vk_buffer_view(struct wined3d_context_vk *contex
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyBufferView(device_vk->vk_device, vk_view, NULL));
         TRACE("Destroyed buffer view 0x%s.\n", wine_dbgstr_longlong(vk_view));
@@ -911,7 +911,7 @@ void wined3d_context_vk_destroy_vk_image_view(struct wined3d_context_vk *context
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyImageView(device_vk->vk_device, vk_view, NULL));
         TRACE("Destroyed image view 0x%s.\n", wine_dbgstr_longlong(vk_view));
@@ -971,7 +971,7 @@ void wined3d_context_vk_destroy_vk_pipeline(struct wined3d_context_vk *context_v
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyPipeline(device_vk->vk_device, vk_pipeline, NULL));
         TRACE("Destroyed pipeline 0x%s.\n", wine_dbgstr_longlong(vk_pipeline));
@@ -997,7 +997,7 @@ void wined3d_context_vk_destroy_vk_sampler(struct wined3d_context_vk *context_vk
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroySampler(device_vk->vk_device, vk_sampler, NULL));
         TRACE("Destroyed sampler 0x%s.\n", wine_dbgstr_longlong(vk_sampler));
@@ -1022,7 +1022,7 @@ void wined3d_context_vk_destroy_vk_event(struct wined3d_context_vk *context_vk,
     const struct wined3d_vk_info *vk_info = context_vk->vk_info;
     struct wined3d_retired_object_vk *o;
 
-    if (context_vk->completed_command_buffer_id > command_buffer_id)
+    if (context_vk->completed_command_buffer_id >= command_buffer_id)
     {
         VK_CALL(vkDestroyEvent(device_vk->vk_device, vk_event, NULL));
         TRACE("Destroyed event 0x%s.\n", wine_dbgstr_longlong(vk_event));
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index 4579cba27fe..bca0b017c1f 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -109,6 +109,7 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_BLEND_STATE,
     WINED3D_CS_OP_SET_DEPTH_STENCIL_STATE,
     WINED3D_CS_OP_SET_RASTERIZER_STATE,
+    WINED3D_CS_OP_SET_DEPTH_BOUNDS,
     WINED3D_CS_OP_SET_RENDER_STATE,
     WINED3D_CS_OP_SET_TEXTURE_STATE,
     WINED3D_CS_OP_SET_SAMPLER_STATE,
@@ -340,6 +341,13 @@ struct wined3d_cs_set_rasterizer_state
     struct wined3d_rasterizer_state *state;
 };
 
+struct wined3d_cs_set_depth_bounds
+{
+    enum wined3d_cs_op opcode;
+    bool enable;
+    float min_depth, max_depth;
+};
+
 struct wined3d_cs_set_render_state
 {
     enum wined3d_cs_op opcode;
@@ -592,6 +600,7 @@ static const char *debug_cs_op(enum wined3d_cs_op op)
         WINED3D_TO_STR(WINED3D_CS_OP_SET_BLEND_STATE);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_DEPTH_STENCIL_STATE);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_RASTERIZER_STATE);
+        WINED3D_TO_STR(WINED3D_CS_OP_SET_DEPTH_BOUNDS);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_RENDER_STATE);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_TEXTURE_STATE);
         WINED3D_TO_STR(WINED3D_CS_OP_SET_SAMPLER_STATE);
@@ -1750,6 +1759,30 @@ void wined3d_device_context_emit_set_rasterizer_state(struct wined3d_device_cont
     wined3d_device_context_submit(context, WINED3D_CS_QUEUE_DEFAULT);
 }
 
+static void wined3d_cs_exec_set_depth_bounds(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_bounds *op = data;
+
+    cs->state.depth_bounds_enable = op->enable;
+    cs->state.depth_bounds_min = op->min_depth;
+    cs->state.depth_bounds_max = op->max_depth;
+    device_invalidate_state(cs->c.device, STATE_DEPTH_BOUNDS);
+}
+
+void wined3d_device_context_set_depth_bounds(struct wined3d_device_context *context,
+        bool enable, float min_depth, float max_depth)
+{
+    struct wined3d_cs_set_depth_bounds *op;
+
+    op = wined3d_device_context_require_space(context, sizeof(*op), WINED3D_CS_QUEUE_DEFAULT);
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_BOUNDS;
+    op->enable = enable;
+    op->min_depth = min_depth;
+    op->max_depth = max_depth;
+
+    wined3d_device_context_submit(context, WINED3D_CS_QUEUE_DEFAULT);
+}
+
 static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
 {
     const struct wined3d_cs_set_render_state *op = data;
@@ -2846,6 +2879,7 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_SET_BLEND_STATE             */ wined3d_cs_exec_set_blend_state,
     /* WINED3D_CS_OP_SET_DEPTH_STENCIL_STATE     */ wined3d_cs_exec_set_depth_stencil_state,
     /* WINED3D_CS_OP_SET_RASTERIZER_STATE        */ wined3d_cs_exec_set_rasterizer_state,
+    /* WINED3D_CS_OP_SET_DEPTH_BOUNDS            */ wined3d_cs_exec_set_depth_bounds,
     /* WINED3D_CS_OP_SET_RENDER_STATE            */ wined3d_cs_exec_set_render_state,
     /* WINED3D_CS_OP_SET_TEXTURE_STATE           */ wined3d_cs_exec_set_texture_state,
     /* WINED3D_CS_OP_SET_SAMPLER_STATE           */ wined3d_cs_exec_set_sampler_state,
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index b294af3c5fa..677535e0e7e 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -3900,6 +3900,7 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
     const unsigned int word_bit_count = sizeof(DWORD) * CHAR_BIT;
     struct wined3d_device_context *context = &device->cs->c;
     unsigned int i, j, start, idx;
+    bool set_depth_bounds = false;
     struct wined3d_range range;
     uint32_t map;
 
@@ -4031,6 +4032,68 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
                     set_rasterizer_state = TRUE;
                     break;
 
+                case WINED3D_RS_ADAPTIVETESS_X:
+                case WINED3D_RS_ADAPTIVETESS_Z:
+                case WINED3D_RS_ADAPTIVETESS_W:
+                    set_depth_bounds = true;
+                    wined3d_device_set_render_state(device, idx, state->rs[idx]);
+                    break;
+
+                case WINED3D_RS_ANTIALIAS:
+                    if (state->rs[WINED3D_RS_ANTIALIAS])
+                        FIXME("Antialias not supported yet.\n");
+                    break;
+
+                case WINED3D_RS_TEXTUREPERSPECTIVE:
+                    break;
+
+                case WINED3D_RS_WRAPU:
+                    if (state->rs[WINED3D_RS_WRAPU])
+                        FIXME("Render state WINED3D_RS_WRAPU not implemented yet.\n");
+                    break;
+
+                case WINED3D_RS_WRAPV:
+                    if (state->rs[WINED3D_RS_WRAPV])
+                        FIXME("Render state WINED3D_RS_WRAPV not implemented yet.\n");
+                    break;
+
+                case WINED3D_RS_MONOENABLE:
+                    if (state->rs[WINED3D_RS_MONOENABLE])
+                        FIXME("Render state WINED3D_RS_MONOENABLE not implemented yet.\n");
+                    break;
+
+                case WINED3D_RS_ROP2:
+                    if (state->rs[WINED3D_RS_ROP2])
+                        FIXME("Render state WINED3D_RS_ROP2 not implemented yet.\n");
+                    break;
+
+                case WINED3D_RS_PLANEMASK:
+                    if (state->rs[WINED3D_RS_PLANEMASK])
+                        FIXME("Render state WINED3D_RS_PLANEMASK not implemented yet.\n");
+                    break;
+
+                case WINED3D_RS_LASTPIXEL:
+                    if (!state->rs[WINED3D_RS_LASTPIXEL])
+                    {
+                        static bool warned;
+                        if (!warned)
+                        {
+                            FIXME("Last Pixel Drawing Disabled, not handled yet.\n");
+                            warned = true;
+                        }
+                    }
+                    break;
+
+                case WINED3D_RS_ZVISIBLE:
+                    if (state->rs[WINED3D_RS_ZVISIBLE])
+                        FIXME("WINED3D_RS_ZVISIBLE not implemented.\n");
+                    break;
+
+                case WINED3D_RS_SUBPIXEL:
+                    if (state->rs[WINED3D_RS_SUBPIXEL])
+                        FIXME("Render state WINED3D_RS_SUBPIXEL not implemented yet.\n");
+                    break;
+
                 default:
                     wined3d_device_set_render_state(device, idx, state->rs[idx]);
                     break;
@@ -4219,6 +4282,14 @@ void CDECL wined3d_device_apply_stateblock(struct wined3d_device *device,
         }
     }
 
+    if (set_depth_bounds)
+    {
+        wined3d_device_context_set_depth_bounds(context,
+                state->rs[WINED3D_RS_ADAPTIVETESS_X] == WINED3DFMT_NVDB,
+                int_to_float(state->rs[WINED3D_RS_ADAPTIVETESS_Z]),
+                int_to_float(state->rs[WINED3D_RS_ADAPTIVETESS_W]));
+    }
+
     for (i = 0; i < ARRAY_SIZE(changed->textureState); ++i)
     {
         map = changed->textureState[i];
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 9b6901d25c0..91246b3667d 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -2750,6 +2750,7 @@ static const struct wined3d_state_entry_template misc_state_template_no3d[] =
     {STATE_SAMPLE_MASK,                                   {STATE_VDECL}},
     {STATE_DEPTH_STENCIL,                                 {STATE_VDECL}},
     {STATE_STENCIL_REF,                                   {STATE_VDECL}},
+    {STATE_DEPTH_BOUNDS,                                  {STATE_VDECL}},
     {STATE_STREAMSRC,                                     {STATE_VDECL}},
     {STATE_VDECL,                                         {STATE_VDECL, state_nop}},
     {STATE_RASTERIZER,                                    {STATE_VDECL}},
@@ -2807,18 +2808,9 @@ static const struct wined3d_state_entry_template misc_state_template_no3d[] =
 
     {STATE_VIEWPORT,                                      {STATE_VDECL}},
     {STATE_INDEXBUFFER,                                   {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_ANTIALIAS),                  {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_TEXTUREPERSPECTIVE),         {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_WRAPU),                      {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_WRAPV),                      {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_LINEPATTERN),                {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_MONOENABLE),                 {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_ROP2),                       {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_PLANEMASK),                  {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_LASTPIXEL),                  {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_ZFUNC),                      {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_DITHERENABLE),               {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_SUBPIXEL),                   {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_SUBPIXELX),                  {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_STIPPLEDALPHA),              {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_STIPPLEENABLE),              {STATE_VDECL}},
@@ -2858,7 +2850,6 @@ static const struct wined3d_state_entry_template misc_state_template_no3d[] =
     {STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION), {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),       {STATE_VDECL}},
     {STATE_RENDER(WINED3D_RS_DEBUGMONITORTOKEN),          {STATE_VDECL}},
-    {STATE_RENDER(WINED3D_RS_ZVISIBLE),                   {STATE_VDECL}},
     /* Samplers */
     {STATE_SAMPLER(0),                                    {STATE_VDECL}},
     {STATE_SAMPLER(1),                                    {STATE_VDECL}},
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index a6d0b174e31..909a246c578 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -1210,6 +1210,24 @@ static void depth(struct wined3d_context *context, const struct wined3d_state *s
         checkGLcall("glDepthFunc");
     }
 
+    if (gl_info->supported[EXT_DEPTH_BOUNDS_TEST])
+    {
+        /* If min is larger than max, an INVALID_VALUE error is generated.
+         * In d3d9, the test is not performed in this case. */
+        if (state->depth_bounds_enable && state->depth_bounds_min <= state->depth_bounds_max)
+        {
+            gl_info->gl_ops.gl.p_glEnable(GL_DEPTH_BOUNDS_TEST_EXT);
+            checkGLcall("glEnable(GL_DEPTH_BOUNDS_TEST_EXT)");
+            GL_EXTCALL(glDepthBoundsEXT(state->depth_bounds_min, state->depth_bounds_max));
+            checkGLcall("glDepthBoundsEXT");
+        }
+        else
+        {
+            gl_info->gl_ops.gl.p_glDisable(GL_DEPTH_BOUNDS_TEST_EXT);
+            checkGLcall("glDisable(GL_DEPTH_BOUNDS_TEST_EXT)");
+        }
+    }
+
     if (context->last_was_rhw && !isStateDirty(context, STATE_TRANSFORM(WINED3D_TS_PROJECTION)))
         context_apply_state(context, state, STATE_TRANSFORM(WINED3D_TS_PROJECTION));
 }
@@ -1769,24 +1787,6 @@ static void state_localviewer(struct wined3d_context *context, const struct wine
     }
 }
 
-static void state_lastpixel(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_LASTPIXEL])
-    {
-        TRACE("Last Pixel Drawing Enabled\n");
-    }
-    else
-    {
-        static BOOL warned;
-        if (!warned) {
-            FIXME("Last Pixel Drawing Disabled, not handled yet\n");
-            warned = TRUE;
-        } else {
-            TRACE("Last Pixel Drawing Disabled, not handled yet\n");
-        }
-    }
-}
-
 void state_pointsprite_w(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     static BOOL warned;
@@ -1969,24 +1969,12 @@ static void depthbias(struct wined3d_context *context, const struct wined3d_stat
     checkGLcall("depth bias");
 }
 
-static void state_zvisible(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_ZVISIBLE])
-        FIXME("WINED3D_RS_ZVISIBLE not implemented.\n");
-}
-
 static void state_stippledalpha(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     if (state->render_states[WINED3D_RS_STIPPLEDALPHA])
         FIXME("Stippled Alpha not supported yet.\n");
 }
 
-static void state_antialias(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_ANTIALIAS])
-        FIXME("Antialias not supported yet.\n");
-}
-
 static void state_sample_mask(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     const struct wined3d_gl_info *gl_info = wined3d_context_gl(context)->gl_info;
@@ -2060,80 +2048,6 @@ static void state_tessellation(struct wined3d_context *context, const struct win
                 state->render_states[WINED3D_RS_ENABLEADAPTIVETESSELLATION]);
 }
 
-static void state_nvdb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    const struct wined3d_gl_info *gl_info = wined3d_context_gl(context)->gl_info;
-    union
-    {
-        uint32_t d;
-        float f;
-    } zmin, zmax;
-
-    if (state->render_states[WINED3D_RS_ADAPTIVETESS_X] == WINED3DFMT_NVDB)
-    {
-        zmin.d = state->render_states[WINED3D_RS_ADAPTIVETESS_Z];
-        zmax.d = state->render_states[WINED3D_RS_ADAPTIVETESS_W];
-
-        /* If zmin is larger than zmax INVALID_VALUE error is generated.
-         * In d3d9 test is not performed in this case*/
-        if (zmin.f <= zmax.f)
-        {
-            gl_info->gl_ops.gl.p_glEnable(GL_DEPTH_BOUNDS_TEST_EXT);
-            checkGLcall("glEnable(GL_DEPTH_BOUNDS_TEST_EXT)");
-            GL_EXTCALL(glDepthBoundsEXT(zmin.f, zmax.f));
-            checkGLcall("glDepthBoundsEXT(...)");
-        }
-        else
-        {
-            gl_info->gl_ops.gl.p_glDisable(GL_DEPTH_BOUNDS_TEST_EXT);
-            checkGLcall("glDisable(GL_DEPTH_BOUNDS_TEST_EXT)");
-        }
-    }
-    else
-    {
-        gl_info->gl_ops.gl.p_glDisable(GL_DEPTH_BOUNDS_TEST_EXT);
-        checkGLcall("glDisable(GL_DEPTH_BOUNDS_TEST_EXT)");
-    }
-
-    state_tessellation(context, state, STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION));
-}
-
-static void state_wrapu(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_WRAPU])
-        FIXME("Render state WINED3D_RS_WRAPU not implemented yet.\n");
-}
-
-static void state_wrapv(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_WRAPV])
-        FIXME("Render state WINED3D_RS_WRAPV not implemented yet.\n");
-}
-
-static void state_monoenable(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_MONOENABLE])
-        FIXME("Render state WINED3D_RS_MONOENABLE not implemented yet.\n");
-}
-
-static void state_rop2(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_ROP2])
-        FIXME("Render state WINED3D_RS_ROP2 not implemented yet.\n");
-}
-
-static void state_planemask(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_PLANEMASK])
-        FIXME("Render state WINED3D_RS_PLANEMASK not implemented yet.\n");
-}
-
-static void state_subpixel(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
-{
-    if (state->render_states[WINED3D_RS_SUBPIXEL])
-        FIXME("Render state WINED3D_RS_SUBPIXEL not implemented yet.\n");
-}
-
 static void state_subpixelx(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
     if (state->render_states[WINED3D_RS_SUBPIXELX])
@@ -4740,6 +4654,7 @@ const struct wined3d_state_entry_template misc_state_template_gl[] =
     { STATE_DEPTH_STENCIL,                                { STATE_DEPTH_STENCIL,                                depth_stencil_2s    }, EXT_STENCIL_TWO_SIDE            },
     { STATE_DEPTH_STENCIL,                                { STATE_DEPTH_STENCIL,                                depth_stencil       }, WINED3D_GL_EXT_NONE             },
     { STATE_STENCIL_REF,                                  { STATE_DEPTH_STENCIL,                                NULL                }, WINED3D_GL_EXT_NONE             },
+    { STATE_DEPTH_BOUNDS,                                 { STATE_DEPTH_STENCIL,                                NULL                }, WINED3D_GL_EXT_NONE             },
     { STATE_STREAMSRC,                                    { STATE_STREAMSRC,                                    streamsrc           }, WINED3D_GL_EXT_NONE             },
     { STATE_VDECL,                                        { STATE_VDECL,                                        vdecl_miscpart      }, WINED3D_GL_EXT_NONE             },
     { STATE_RASTERIZER,                                   { STATE_RASTERIZER,                                   rasterizer_cc       }, ARB_CLIP_CONTROL                },
@@ -4805,18 +4720,9 @@ const struct wined3d_state_entry_template misc_state_template_gl[] =
     { STATE_VIEWPORT,                                     { STATE_VIEWPORT,                                     viewport_miscpart   }, WINED3D_GL_EXT_NONE             },
     { STATE_INDEXBUFFER,                                  { STATE_INDEXBUFFER,                                  indexbuffer         }, ARB_VERTEX_BUFFER_OBJECT        },
     { STATE_INDEXBUFFER,                                  { STATE_INDEXBUFFER,                                  state_nop           }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_ANTIALIAS),                 { STATE_RENDER(WINED3D_RS_ANTIALIAS),                 state_antialias     }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_TEXTUREPERSPECTIVE),        { STATE_RENDER(WINED3D_RS_TEXTUREPERSPECTIVE),        state_nop           }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_WRAPU),                     { STATE_RENDER(WINED3D_RS_WRAPU),                     state_wrapu         }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_WRAPV),                     { STATE_RENDER(WINED3D_RS_WRAPV),                     state_wrapv         }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_LINEPATTERN),               { STATE_RENDER(WINED3D_RS_LINEPATTERN),               state_linepattern   }, WINED3D_GL_LEGACY_CONTEXT       },
     { STATE_RENDER(WINED3D_RS_LINEPATTERN),               { STATE_RENDER(WINED3D_RS_LINEPATTERN),               state_linepattern_w }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_MONOENABLE),                { STATE_RENDER(WINED3D_RS_MONOENABLE),                state_monoenable    }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_ROP2),                      { STATE_RENDER(WINED3D_RS_ROP2),                      state_rop2          }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_PLANEMASK),                 { STATE_RENDER(WINED3D_RS_PLANEMASK),                 state_planemask     }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_LASTPIXEL),                 { STATE_RENDER(WINED3D_RS_LASTPIXEL),                 state_lastpixel     }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_DITHERENABLE),              { STATE_RENDER(WINED3D_RS_DITHERENABLE),              state_ditherenable  }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_SUBPIXEL),                  { STATE_RENDER(WINED3D_RS_SUBPIXEL),                  state_subpixel      }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_SUBPIXELX),                 { STATE_RENDER(WINED3D_RS_SUBPIXELX),                 state_subpixelx     }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_STIPPLEDALPHA),             { STATE_RENDER(WINED3D_RS_STIPPLEDALPHA),             state_stippledalpha }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_STIPPLEENABLE),             { STATE_RENDER(WINED3D_RS_STIPPLEENABLE),             state_stippleenable }, WINED3D_GL_EXT_NONE             },
@@ -4853,12 +4759,10 @@ const struct wined3d_state_entry_template misc_state_template_gl[] =
     { STATE_RENDER(WINED3D_RS_ADAPTIVETESS_Y),            { STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),NULL                }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_ADAPTIVETESS_Z),            { STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),NULL                }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_ADAPTIVETESS_W),            { STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),NULL                }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),{ STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),state_nvdb          }, EXT_DEPTH_BOUNDS_TEST           },
     { STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),{ STATE_RENDER(WINED3D_RS_ENABLEADAPTIVETESSELLATION),state_tessellation  }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),      { STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),      state_msaa          }, ARB_MULTISAMPLE                 },
     { STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),      { STATE_RENDER(WINED3D_RS_MULTISAMPLEANTIALIAS),      state_msaa_w        }, WINED3D_GL_EXT_NONE             },
     { STATE_RENDER(WINED3D_RS_DEBUGMONITORTOKEN),         { STATE_RENDER(WINED3D_RS_DEBUGMONITORTOKEN),         state_debug_monitor }, WINED3D_GL_EXT_NONE             },
-    { STATE_RENDER(WINED3D_RS_ZVISIBLE),                  { STATE_RENDER(WINED3D_RS_ZVISIBLE),                  state_zvisible      }, WINED3D_GL_EXT_NONE             },
     /* Samplers */
     { STATE_SAMPLER(0),                                   { STATE_SAMPLER(0),                                   sampler             }, WINED3D_GL_EXT_NONE             },
     { STATE_SAMPLER(1),                                   { STATE_SAMPLER(1),                                   sampler             }, WINED3D_GL_EXT_NONE             },
@@ -5613,12 +5517,11 @@ static void validate_state_table(struct wined3d_state_entry *state_table)
     }
     rs_holes[] =
     {
-        {  1,   1},
-        {  3,   3},
-        {  7,   8},
-        { 14,  14},
-        { 17,  23},
+        {  1,   8},
+        { 11,  14},
+        { 16,  23},
         { 27,  27},
+        { 30,  31},
         { 40,  40},
         { 42,  45},
         { 47,  47},
@@ -5669,6 +5572,7 @@ static void validate_state_table(struct wined3d_state_entry *state_table)
         STATE_BLEND_FACTOR,
         STATE_DEPTH_STENCIL,
         STATE_STENCIL_REF,
+        STATE_DEPTH_BOUNDS,
     };
     unsigned int i, current;
 
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 8d416494eb8..33b938ad460 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -4313,6 +4313,11 @@ HRESULT CDECL wined3d_texture_update_overlay(struct wined3d_texture *texture, un
     return WINED3D_OK;
 }
 
+struct wined3d_swapchain * CDECL wined3d_texture_get_swapchain(struct wined3d_texture *texture)
+{
+    return texture->swapchain;
+}
+
 void * CDECL wined3d_texture_get_sub_resource_parent(struct wined3d_texture *texture, unsigned int sub_resource_idx)
 {
     TRACE("texture %p, sub_resource_idx %u.\n", texture, sub_resource_idx);
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index fb350acf56f..aff2b00e08d 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -74,101 +74,102 @@ struct wined3d_format_channels
     DWORD red_offset, green_offset, blue_offset, alpha_offset;
     UINT bpp;
     BYTE depth_size, stencil_size;
+    const char *channels;
 };
 
 static const struct wined3d_format_channels formats[] =
 {
     /*                                          size            offset
-     *  format id                           r   g   b   a    r   g   b   a    bpp depth stencil */
-    {WINED3DFMT_UNKNOWN,                    0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
+     *  format id                           r   g   b   a    r   g   b   a    bpp   z   s   channels */
+    {WINED3DFMT_UNKNOWN,                    0,  0,  0,  0,   0,  0,  0,  0,    0,   0,  0},
     /* FourCC formats */
-    {WINED3DFMT_UYVY,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_YUY2,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_YV12,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_NV12,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_DXT1,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_DXT2,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_DXT3,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_DXT4,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_DXT5,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_MULTI2_ARGB8,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_G8R8_G8B8,                  0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_R8G8_B8G8,                  0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
+    {WINED3DFMT_UYVY,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_YUY2,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_YV12,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_NV12,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_DXT1,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_DXT2,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_DXT3,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_DXT4,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_DXT5,                       0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_MULTI2_ARGB8,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_G8R8_G8B8,                  0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_R8G8_B8G8,                  0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
     /* Hmm? */
-    {WINED3DFMT_R8G8_SNORM_Cx,              0,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_R11G11B10_FLOAT,           11, 11, 10,  0,   0, 11, 22,  0,    4,   0,     0},
+    {WINED3DFMT_R8G8_SNORM_Cx,              0,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_R11G11B10_FLOAT,           11, 11, 10,  0,   0, 11, 22,  0,    4,   0,  0,   "FFF"},
     /* Palettized formats */
-    {WINED3DFMT_P8_UINT_A8_UNORM,           0,  0,  0,  8,   0,  0,  0,  8,    2,   0,     0},
-    {WINED3DFMT_P8_UINT,                    0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
+    {WINED3DFMT_P8_UINT_A8_UNORM,           0,  0,  0,  8,   0,  0,  0,  8,    2,   0,  0},
+    {WINED3DFMT_P8_UINT,                    0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
     /* Standard ARGB formats. */
-    {WINED3DFMT_B8G8R8_UNORM,               8,  8,  8,  0,  16,  8,  0,  0,    3,   0,     0},
-    {WINED3DFMT_B5G6R5_UNORM,               5,  6,  5,  0,  11,  5,  0,  0,    2,   0,     0},
-    {WINED3DFMT_B5G5R5X1_UNORM,             5,  5,  5,  0,  10,  5,  0,  0,    2,   0,     0},
-    {WINED3DFMT_B5G5R5A1_UNORM,             5,  5,  5,  1,  10,  5,  0, 15,    2,   0,     0},
-    {WINED3DFMT_B4G4R4A4_UNORM,             4,  4,  4,  4,   8,  4,  0, 12,    2,   0,     0},
-    {WINED3DFMT_B2G3R3_UNORM,               3,  3,  2,  0,   5,  2,  0,  0,    1,   0,     0},
-    {WINED3DFMT_A8_UNORM,                   0,  0,  0,  8,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_B2G3R3A8_UNORM,             3,  3,  2,  8,   5,  2,  0,  8,    2,   0,     0},
-    {WINED3DFMT_B4G4R4X4_UNORM,             4,  4,  4,  0,   8,  4,  0,  0,    2,   0,     0},
-    {WINED3DFMT_R8G8B8X8_UNORM,             8,  8,  8,  0,   0,  8, 16,  0,    4,   0,     0},
-    {WINED3DFMT_B10G10R10A2_UNORM,         10, 10, 10,  2,  20, 10,  0, 30,    4,   0,     0},
+    {WINED3DFMT_B8G8R8_UNORM,               8,  8,  8,  0,  16,  8,  0,  0,    3,   0,  0,   "uuu"},
+    {WINED3DFMT_B5G6R5_UNORM,               5,  6,  5,  0,  11,  5,  0,  0,    2,   0,  0,   "uuu"},
+    {WINED3DFMT_B5G5R5X1_UNORM,             5,  5,  5,  0,  10,  5,  0,  0,    2,   0,  0,   "uuuX"},
+    {WINED3DFMT_B5G5R5A1_UNORM,             5,  5,  5,  1,  10,  5,  0, 15,    2,   0,  0,   "uuuu"},
+    {WINED3DFMT_B4G4R4A4_UNORM,             4,  4,  4,  4,   8,  4,  0, 12,    2,   0,  0,   "uuuu"},
+    {WINED3DFMT_B2G3R3_UNORM,               3,  3,  2,  0,   5,  2,  0,  0,    1,   0,  0,   "uuu"},
+    {WINED3DFMT_A8_UNORM,                   0,  0,  0,  8,   0,  0,  0,  0,    1,   0,  0,   "u"},
+    {WINED3DFMT_B2G3R3A8_UNORM,             3,  3,  2,  8,   5,  2,  0,  8,    2,   0,  0,   "uuuu"},
+    {WINED3DFMT_B4G4R4X4_UNORM,             4,  4,  4,  0,   8,  4,  0,  0,    2,   0,  0,   "uuuX"},
+    {WINED3DFMT_R8G8B8X8_UNORM,             8,  8,  8,  0,   0,  8, 16,  0,    4,   0,  0,   "uuuX"},
+    {WINED3DFMT_B10G10R10A2_UNORM,         10, 10, 10,  2,  20, 10,  0, 30,    4,   0,  0,   "uuuu"},
     /* Luminance */
-    {WINED3DFMT_L8_UNORM,                   0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_L8A8_UNORM,                 0,  0,  0,  8,   0,  0,  0,  8,    2,   0,     0},
-    {WINED3DFMT_L4A4_UNORM,                 0,  0,  0,  4,   0,  0,  0,  4,    1,   0,     0},
-    {WINED3DFMT_L16_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
+    {WINED3DFMT_L8_UNORM,                   0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_L8A8_UNORM,                 0,  0,  0,  8,   0,  0,  0,  8,    2,   0,  0},
+    {WINED3DFMT_L4A4_UNORM,                 0,  0,  0,  4,   0,  0,  0,  4,    1,   0,  0},
+    {WINED3DFMT_L16_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
     /* Bump mapping stuff */
-    {WINED3DFMT_R5G5_SNORM_L6_UNORM,        5,  5,  0,  0,   0,  5,  0,  0,    2,   0,     0},
-    {WINED3DFMT_R8G8_SNORM_L8X8_UNORM,      8,  8,  0,  0,   0,  8,  0,  0,    4,   0,     0},
-    {WINED3DFMT_R10G11B11_SNORM,           10, 11, 11,  0,   0, 10, 21,  0,    4,   0,     0},
-    {WINED3DFMT_R10G10B10_SNORM_A2_UNORM,  10, 10, 10,  2,   0, 10, 20, 30,    4,   0,     0},
+    {WINED3DFMT_R5G5_SNORM_L6_UNORM,        5,  5,  0,  0,   0,  5,  0,  0,    2,   0,  0},
+    {WINED3DFMT_R8G8_SNORM_L8X8_UNORM,      8,  8,  0,  0,   0,  8,  0,  0,    4,   0,  0},
+    {WINED3DFMT_R10G11B11_SNORM,           10, 11, 11,  0,   0, 10, 21,  0,    4,   0,  0,   "iii"},
+    {WINED3DFMT_R10G10B10_SNORM_A2_UNORM,  10, 10, 10,  2,   0, 10, 20, 30,    4,   0,  0,   "iiiu"},
     /* Depth stencil formats */
-    {WINED3DFMT_D16_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
-    {WINED3DFMT_D32_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
-    {WINED3DFMT_S1_UINT_D15_UNORM,          0,  0,  0,  0,   0,  0,  0,  0,    2,  15,     1},
-    {WINED3DFMT_X8D24_UNORM,                0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     0},
-    {WINED3DFMT_S4X4_UINT_D24_UNORM,        0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     4},
-    {WINED3DFMT_S8_UINT_D24_FLOAT,          0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
+    {WINED3DFMT_D16_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    2,  16,  0,   "D"},
+    {WINED3DFMT_D32_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    4,  32,  0,   "D"},
+    {WINED3DFMT_S1_UINT_D15_UNORM,          0,  0,  0,  0,   0,  0,  0,  0,    2,  15,  1,   "SD"},
+    {WINED3DFMT_X8D24_UNORM,                0,  0,  0,  0,   0,  0,  0,  0,    4,  24,  0,   "XD"},
+    {WINED3DFMT_S4X4_UINT_D24_UNORM,        0,  0,  0,  0,   0,  0,  0,  0,    4,  24,  4,   "SXD"},
+    {WINED3DFMT_S8_UINT_D24_FLOAT,          0,  0,  0,  0,   0,  0,  0,  0,    4,  24,  8,   "SD"},
     /* Vendor-specific formats */
-    {WINED3DFMT_ATI1N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_ATI2N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_NVDB,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
-    {WINED3DFMT_ATOC,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
-    {WINED3DFMT_INST,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
-    {WINED3DFMT_INTZ,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
-    {WINED3DFMT_RESZ,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
-    {WINED3DFMT_NVHU,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_NVHS,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_NULL,                       8,  8,  8,  8,   0,  8, 16, 24,    4,   0,     0},
+    {WINED3DFMT_ATI1N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_ATI2N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_NVDB,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,  0},
+    {WINED3DFMT_ATOC,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,  0},
+    {WINED3DFMT_INST,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,  0},
+    {WINED3DFMT_INTZ,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,  8},
+    {WINED3DFMT_RESZ,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,  0},
+    {WINED3DFMT_NVHU,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_NVHS,                       0,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_NULL,                       8,  8,  8,  8,   0,  8, 16, 24,    4,   0,  0},
     /* Unsure about them, could not find a Windows driver that supports them */
-    {WINED3DFMT_R16,                       16,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_AL16,                       0,  0,  0, 16,   0,  0,  0, 16,    4,   0,     0},
+    {WINED3DFMT_R16,                       16,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_AL16,                       0,  0,  0, 16,   0,  0,  0, 16,    4,   0,  0},
     /* DirectX 10 HDR formats */
-    {WINED3DFMT_R9G9B9E5_SHAREDEXP,         0,  0,  0,  0,   0,  0,  0,  0,    4,   0,     0},
+    {WINED3DFMT_R9G9B9E5_SHAREDEXP,         0,  0,  0,  0,   0,  0,  0,  0,    4,   0,  0},
     /* Typeless */
-    {WINED3DFMT_R32G32B32A32_TYPELESS,     32, 32, 32, 32,   0, 32, 64, 96,   16,   0,     0},
-    {WINED3DFMT_R32G32B32_TYPELESS,        32, 32, 32,  0,   0, 32, 64,  0,   12,   0,     0},
-    {WINED3DFMT_R16G16B16A16_TYPELESS,     16, 16, 16, 16,   0, 16, 32, 48,    8,   0,     0},
-    {WINED3DFMT_R32G32_TYPELESS,           32, 32,  0,  0,   0, 32,  0,  0,    8,   0,     0},
-    {WINED3DFMT_R32G8X24_TYPELESS,         32,  8,  0,  0,   0,  0,  0,  0,    8,   0,     0},
-    {WINED3DFMT_R10G10B10A2_TYPELESS,      10, 10, 10,  2,   0, 10, 20, 30,    4,   0,     0},
-    {WINED3DFMT_R10G10B10X2_TYPELESS,      10, 10, 10,  0,   0, 10, 20,  0,    4,   0,     0},
-    {WINED3DFMT_R8G8B8A8_TYPELESS,          8,  8,  8,  8,   0,  8, 16, 24,    4,   0,     0},
-    {WINED3DFMT_R16G16_TYPELESS,           16, 16,  0,  0,   0, 16,  0,  0,    4,   0,     0},
-    {WINED3DFMT_R32_TYPELESS,              32,  0,  0,  0,   0,  0,  0,  0,    4,   0,     0},
-    {WINED3DFMT_R24G8_TYPELESS,            24,  8,  0,  0,   0,  0,  0,  0,    4,   0,     0},
-    {WINED3DFMT_R8G8_TYPELESS,              8,  8,  0,  0,   0,  8,  0,  0,    2,   0,     0},
-    {WINED3DFMT_R16_TYPELESS,              16,  0,  0,  0,   0,  0,  0,  0,    2,   0,     0},
-    {WINED3DFMT_R8_TYPELESS,                8,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC1_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC2_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC3_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC4_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC5_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC6H_TYPELESS,              0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_BC7_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
-    {WINED3DFMT_B8G8R8A8_TYPELESS,          8,  8,  8,  8,  16,  8,  0, 24,    4,   0,     0},
-    {WINED3DFMT_B8G8R8X8_TYPELESS,          8,  8,  8,  0,  16,  8,  0,  0,    4,   0,     0},
+    {WINED3DFMT_R32G32B32A32_TYPELESS,     32, 32, 32, 32,   0, 32, 64, 96,   16,   0,  0},
+    {WINED3DFMT_R32G32B32_TYPELESS,        32, 32, 32,  0,   0, 32, 64,  0,   12,   0,  0},
+    {WINED3DFMT_R16G16B16A16_TYPELESS,     16, 16, 16, 16,   0, 16, 32, 48,    8,   0,  0},
+    {WINED3DFMT_R32G32_TYPELESS,           32, 32,  0,  0,   0, 32,  0,  0,    8,   0,  0},
+    {WINED3DFMT_R32G8X24_TYPELESS,         32,  8,  0,  0,   0,  0,  0,  0,    8,   0,  0},
+    {WINED3DFMT_R10G10B10A2_TYPELESS,      10, 10, 10,  2,   0, 10, 20, 30,    4,   0,  0},
+    {WINED3DFMT_R10G10B10X2_TYPELESS,      10, 10, 10,  0,   0, 10, 20,  0,    4,   0,  0},
+    {WINED3DFMT_R8G8B8A8_TYPELESS,          8,  8,  8,  8,   0,  8, 16, 24,    4,   0,  0},
+    {WINED3DFMT_R16G16_TYPELESS,           16, 16,  0,  0,   0, 16,  0,  0,    4,   0,  0},
+    {WINED3DFMT_R32_TYPELESS,              32,  0,  0,  0,   0,  0,  0,  0,    4,   0,  0},
+    {WINED3DFMT_R24G8_TYPELESS,            24,  8,  0,  0,   0,  0,  0,  0,    4,   0,  0},
+    {WINED3DFMT_R8G8_TYPELESS,              8,  8,  0,  0,   0,  8,  0,  0,    2,   0,  0},
+    {WINED3DFMT_R16_TYPELESS,              16,  0,  0,  0,   0,  0,  0,  0,    2,   0,  0},
+    {WINED3DFMT_R8_TYPELESS,                8,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC1_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC2_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC3_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC4_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC5_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC6H_TYPELESS,              0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_BC7_TYPELESS,               0,  0,  0,  0,   0,  0,  0,  0,    1,   0,  0},
+    {WINED3DFMT_B8G8R8A8_TYPELESS,          8,  8,  8,  8,  16,  8,  0, 24,    4,   0,  0},
+    {WINED3DFMT_B8G8R8X8_TYPELESS,          8,  8,  8,  0,  16,  8,  0,  0,    4,   0,  0},
 };
 
 struct wined3d_typed_format_info
@@ -319,7 +320,6 @@ static const struct wined3d_format_base_flags format_base_flags[] =
     {WINED3DFMT_ATI2N,                 WINED3D_FORMAT_ATTR_MAPPABLE | WINED3D_FORMAT_ATTR_BROKEN_PITCH},
     {WINED3DFMT_D16_LOCKABLE,          WINED3D_FORMAT_ATTR_MAPPABLE},
     {WINED3DFMT_INTZ,                  WINED3D_FORMAT_ATTR_MAPPABLE},
-    {WINED3DFMT_R11G11B10_FLOAT,       WINED3D_FORMAT_ATTR_FLOAT},
     {WINED3DFMT_D32_FLOAT,             WINED3D_FORMAT_ATTR_FLOAT},
     {WINED3DFMT_S8_UINT_D24_FLOAT,     WINED3D_FORMAT_ATTR_FLOAT},
     {WINED3DFMT_D32_FLOAT_S8X24_UINT,  WINED3D_FORMAT_ATTR_FLOAT},
@@ -349,16 +349,6 @@ static const struct wined3d_format_base_flags format_base_flags[] =
     {WINED3DFMT_R32_SINT,              WINED3D_FORMAT_ATTR_CAST_TO_BLOCK},
     {WINED3DFMT_R16_UINT,              0,
         WINED3D_FORMAT_CAP_INDEX_BUFFER},
-    {WINED3DFMT_A8_UNORM,              WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B10G10R10A2_UNORM,     WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B2G3R3_UNORM,          WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B4G4R4A4_UNORM,        WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B4G4R4X4_UNORM,        WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B5G5R5A1_UNORM,        WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B5G5R5X1_UNORM,        WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B5G6R5_UNORM,          WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_B8G8R8_UNORM,          WINED3D_FORMAT_ATTR_NORMALISED},
-    {WINED3DFMT_R10G10B10A2_UNORM,     WINED3D_FORMAT_ATTR_NORMALISED},
     {WINED3DFMT_R8G8_SNORM,            WINED3D_FORMAT_ATTR_BUMPMAP},
     {WINED3DFMT_R5G5_SNORM_L6_UNORM,   WINED3D_FORMAT_ATTR_BUMPMAP},
     {WINED3DFMT_R8G8_SNORM_L8X8_UNORM, WINED3D_FORMAT_ATTR_BUMPMAP},
@@ -2048,10 +2038,46 @@ static enum wined3d_channel_type map_channel_type(char t)
     }
 }
 
+static void parse_channel_desc(struct wined3d_format *format, const char *channel_desc)
+{
+    unsigned int component_count = 0;
+    unsigned int attrs = 0;
+    unsigned int j;
+
+    for (j = 0; j < strlen(channel_desc); ++j)
+    {
+        enum wined3d_channel_type channel_type = map_channel_type(channel_desc[j]);
+
+        if (channel_type == WINED3D_CHANNEL_TYPE_UNORM || channel_type == WINED3D_CHANNEL_TYPE_SNORM)
+            attrs |= WINED3D_FORMAT_ATTR_NORMALISED;
+        if (channel_type == WINED3D_CHANNEL_TYPE_UINT || channel_type == WINED3D_CHANNEL_TYPE_SINT)
+            attrs |= WINED3D_FORMAT_ATTR_INTEGER;
+        if (channel_type == WINED3D_CHANNEL_TYPE_FLOAT)
+            attrs |= WINED3D_FORMAT_ATTR_FLOAT;
+        if (channel_type != WINED3D_CHANNEL_TYPE_UNUSED)
+            ++component_count;
+
+        if (channel_type == WINED3D_CHANNEL_TYPE_DEPTH && !format->depth_size)
+        {
+            format->depth_size = format->red_size;
+            format->red_size = format->red_offset = 0;
+        }
+
+        if (channel_type == WINED3D_CHANNEL_TYPE_STENCIL && !format->stencil_size)
+        {
+            format->stencil_size = format->green_size;
+            format->green_size = format->green_offset = 0;
+        }
+    }
+
+    format->attrs |= attrs;
+    format->component_count = component_count;
+}
+
 static BOOL init_format_base_info(struct wined3d_adapter *adapter)
 {
     struct wined3d_format *format;
-    unsigned int i, j;
+    unsigned int i;
 
     for (i = 0; i < ARRAY_SIZE(formats); ++i)
     {
@@ -2073,13 +2099,14 @@ static BOOL init_format_base_info(struct wined3d_adapter *adapter)
         format->block_width = 1;
         format->block_height = 1;
         format->block_byte_count = formats[i].bpp;
+
+        if (formats[i].channels)
+            parse_channel_desc(format, formats[i].channels);
     }
 
     for (i = 0; i < ARRAY_SIZE(typed_formats); ++i)
     {
         struct wined3d_format *typeless_format;
-        unsigned int component_count = 0;
-        unsigned int attrs = 0;
 
         if (!(format = get_format_internal(adapter, typed_formats[i].id)))
             return FALSE;
@@ -2106,34 +2133,7 @@ static BOOL init_format_base_info(struct wined3d_adapter *adapter)
 
         typeless_format->typeless_id = typeless_format->id;
 
-        for (j = 0; j < strlen(typed_formats[i].channels); ++j)
-        {
-            enum wined3d_channel_type channel_type = map_channel_type(typed_formats[i].channels[j]);
-
-            if (channel_type == WINED3D_CHANNEL_TYPE_UNORM || channel_type == WINED3D_CHANNEL_TYPE_SNORM)
-                attrs |= WINED3D_FORMAT_ATTR_NORMALISED;
-            if (channel_type == WINED3D_CHANNEL_TYPE_UINT || channel_type == WINED3D_CHANNEL_TYPE_SINT)
-                attrs |= WINED3D_FORMAT_ATTR_INTEGER;
-            if (channel_type == WINED3D_CHANNEL_TYPE_FLOAT)
-                attrs |= WINED3D_FORMAT_ATTR_FLOAT;
-            if (channel_type != WINED3D_CHANNEL_TYPE_UNUSED)
-                ++component_count;
-
-            if (channel_type == WINED3D_CHANNEL_TYPE_DEPTH && !format->depth_size)
-            {
-                format->depth_size = format->red_size;
-                format->red_size = format->red_offset = 0;
-            }
-
-            if (channel_type == WINED3D_CHANNEL_TYPE_STENCIL && !format->stencil_size)
-            {
-                format->stencil_size = format->green_size;
-                format->green_size = format->green_offset = 0;
-            }
-        }
-
-        format->component_count = component_count;
-        format->attrs |= attrs;
+        parse_channel_desc(format, typed_formats[i].channels);
     }
 
     for (i = 0; i < ARRAY_SIZE(ddi_formats); ++i)
@@ -5416,6 +5416,8 @@ const char *debug_d3dstate(uint32_t state)
         return "STATE_MATERIAL";
     if (STATE_IS_RASTERIZER(state))
         return "STATE_RASTERIZER";
+    if (STATE_IS_DEPTH_BOUNDS(state))
+        return "STATE_DEPTH_BOUNDS";
     if (STATE_IS_POINTSPRITECOORDORIGIN(state))
         return "STATE_POINTSPRITECOORDORIGIN";
     if (STATE_IS_BASEVERTEXINDEX(state))
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index 827ac295ddc..b22adf07c9c 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -301,6 +301,7 @@
 @ cdecl wined3d_texture_get_resource(ptr)
 @ cdecl wined3d_texture_get_sub_resource_desc(ptr long ptr)
 @ cdecl wined3d_texture_get_sub_resource_parent(ptr long)
+@ cdecl wined3d_texture_get_swapchain(ptr)
 @ cdecl wined3d_texture_incref(ptr)
 @ cdecl wined3d_texture_release_dc(ptr long ptr)
 @ cdecl wined3d_texture_set_color_key(ptr long ptr)
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 7abf77bb445..459ac7a19c8 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -62,6 +62,18 @@ static inline size_t align(size_t addr, size_t alignment)
     return (addr + (alignment - 1)) & ~(alignment - 1);
 }
 
+static inline float int_to_float(uint32_t i)
+{
+    union
+    {
+        uint32_t u;
+        float f;
+    } u;
+
+    u.u = i;
+    return u.f;
+}
+
 #define MAKEDWORD_VERSION(maj, min) (((maj & 0xffffu) << 16) | (min & 0xffffu))
 
 /* Driver quirks */
@@ -1927,7 +1939,10 @@ void dispatch_compute(struct wined3d_device *device, const struct wined3d_state
 #define STATE_RASTERIZER (STATE_MATERIAL + 1)
 #define STATE_IS_RASTERIZER(a) ((a) == STATE_RASTERIZER)
 
-#define STATE_POINTSPRITECOORDORIGIN (STATE_RASTERIZER + 1)
+#define STATE_DEPTH_BOUNDS (STATE_RASTERIZER + 1)
+#define STATE_IS_DEPTH_BOUNDS(a) ((a) == STATE_DEPTH_BOUNDS)
+
+#define STATE_POINTSPRITECOORDORIGIN (STATE_DEPTH_BOUNDS + 1)
 #define STATE_IS_POINTSPRITECOORDORIGIN(a) ((a) == STATE_POINTSPRITECOORDORIGIN)
 
 #define STATE_BASEVERTEXINDEX  (STATE_POINTSPRITECOORDORIGIN + 1)
@@ -3916,6 +3931,8 @@ struct wined3d_state
     unsigned int sample_mask;
     struct wined3d_depth_stencil_state *depth_stencil_state;
     unsigned int stencil_ref;
+    bool depth_bounds_enable;
+    float depth_bounds_min, depth_bounds_max;
     struct wined3d_rasterizer_state *rasterizer_state;
 };
 
@@ -5135,6 +5152,8 @@ void wined3d_cs_init_object(struct wined3d_cs *cs,
         void (*callback)(void *object), void *object) DECLSPEC_HIDDEN;
 void wined3d_cs_map_bo_address(struct wined3d_cs *cs,
         struct wined3d_bo_address *addr, size_t size, unsigned int flags) DECLSPEC_HIDDEN;
+void wined3d_device_context_set_depth_bounds(struct wined3d_device_context *context,
+        bool enable, float min_depth, float max_depth);
 
 static inline void wined3d_cs_finish(struct wined3d_cs *cs, enum wined3d_cs_queue_id queue_id)
 {
diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 064a8b68343..82b1c148d6b 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -16,6 +16,7 @@ C_SRCS = \
 	quartz_parser.c \
 	quartz_transform.c \
 	resampler.c \
+	video_decoder.c \
 	video_processor.c \
 	wg_allocator.c \
 	wg_format.c \
diff --git a/dlls/winegstreamer/aac_decoder.c b/dlls/winegstreamer/aac_decoder.c
index a2a6984dd18..d79ede69c9d 100644
--- a/dlls/winegstreamer/aac_decoder.c
+++ b/dlls/winegstreamer/aac_decoder.c
@@ -30,8 +30,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
-extern const GUID MFAudioFormat_RAW_AAC;
-
 static struct
 {
     const GUID *const guid;
@@ -500,8 +498,20 @@ static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD
 
 static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
-    return E_NOTIMPL;
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    bool accepts_input;
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, flags %p.\n", iface, id, flags);
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = wg_transform_get_status(decoder->wg_transform, &accepts_input)))
+        return hr;
+
+    *flags = accepts_input ? MFT_INPUT_STATUS_ACCEPT_DATA : 0;
+    return S_OK;
 }
 
 static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 3890db543ff..5b4c01a3cd0 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -104,6 +104,7 @@ struct wg_transform *wg_transform_create(const struct wg_format *input_format,
         const struct wg_format *output_format);
 void wg_transform_destroy(struct wg_transform *transform);
 bool wg_transform_set_output_format(struct wg_transform *transform, struct wg_format *format);
+bool wg_transform_get_status(struct wg_transform *transform, bool *accepts_input);
 
 unsigned int wg_format_get_max_size(const struct wg_format *format);
 
@@ -147,4 +148,6 @@ HRESULT aac_decoder_create(REFIID riid, void **ret);
 HRESULT h264_decoder_create(REFIID riid, void **ret);
 HRESULT video_processor_create(REFIID riid, void **ret);
 
+extern const GUID MFAudioFormat_RAW_AAC;
+
 #endif /* __GST_PRIVATE_INCLUDED__ */
diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index ead00e20840..439701098ad 100644
--- a/dlls/winegstreamer/h264_decoder.c
+++ b/dlls/winegstreamer/h264_decoder.c
@@ -548,8 +548,15 @@ static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD
 
 static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
-    return E_NOTIMPL;
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, id %#lx, flags %p.\n", iface, id, flags);
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *flags = MFT_INPUT_STATUS_ACCEPT_DATA;
+    return S_OK;
 }
 
 static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
@@ -718,6 +725,8 @@ HRESULT h264_decoder_create(REFIID riid, void **ret)
         goto failed;
     if (FAILED(hr = IMFAttributes_SetUINT32(decoder->attributes, &MF_LOW_LATENCY, 0)))
         goto failed;
+    if (FAILED(hr = IMFAttributes_SetUINT32(decoder->attributes, &MF_SA_D3D11_AWARE, TRUE)))
+        goto failed;
     if (FAILED(hr = MFCreateAttributes(&decoder->output_attributes, 0)))
         goto failed;
     if (FAILED(hr = wg_sample_queue_create(&decoder->wg_sample_queue)))
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 2675430019f..1afa51ac0aa 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -384,6 +384,22 @@ HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample
     return params.result;
 }
 
+bool wg_transform_get_status(struct wg_transform *transform, bool *accepts_input)
+{
+    struct wg_transform_get_status_params params =
+    {
+        .transform = transform,
+    };
+
+    TRACE("transform %p, accepts_input %p.\n", transform, accepts_input);
+
+    if (WINE_UNIX_CALL(unix_wg_transform_get_status, &params))
+        return false;
+
+    *accepts_input = params.accepts_input;
+    return true;
+}
+
 bool wg_transform_set_output_format(struct wg_transform *transform, struct wg_format *format)
 {
     struct wg_transform_set_output_format_params params =
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index a09c67b4f11..4cd095fb82e 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -38,6 +38,7 @@ DEFINE_GUID(DMOVideoFormat_RGB555,D3DFMT_X1R5G5B5,0x524f,0x11ce,0x9f,0x53,0x00,0
 DEFINE_GUID(DMOVideoFormat_RGB8,D3DFMT_P8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
 DEFINE_MEDIATYPE_GUID(MFAudioFormat_RAW_AAC,WAVE_FORMAT_RAW_AAC1);
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_VC1S,MAKEFOURCC('V','C','1','S'));
+DEFINE_MEDIATYPE_GUID(MFVideoFormat_IV50,MAKEFOURCC('I','V','5','0'));
 
 struct class_factory
 {
@@ -510,13 +511,15 @@ static IMFMediaType *mf_media_type_from_wg_format_video(const struct wg_format *
     {
         if (format->u.video.format == video_formats[i].format)
         {
+            int32_t height = abs(format->u.video.height);
+            int32_t width = format->u.video.width;
+
             if (FAILED(MFCreateMediaType(&type)))
                 return NULL;
 
             IMFMediaType_SetGUID(type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
             IMFMediaType_SetGUID(type, &MF_MT_SUBTYPE, video_formats[i].subtype);
-            IMFMediaType_SetUINT64(type, &MF_MT_FRAME_SIZE,
-                    make_uint64(format->u.video.width, format->u.video.height));
+            IMFMediaType_SetUINT64(type, &MF_MT_FRAME_SIZE, make_uint64(width, height));
             IMFMediaType_SetUINT64(type, &MF_MT_FRAME_RATE,
                     make_uint64(format->u.video.fps_n, format->u.video.fps_d));
             IMFMediaType_SetUINT32(type, &MF_MT_COMPRESSED, FALSE);
@@ -529,8 +532,8 @@ static IMFMediaType *mf_media_type_from_wg_format_video(const struct wg_format *
                 {
                     .OffsetX = {.value = format->u.video.padding.left},
                     .OffsetY = {.value = format->u.video.padding.top},
-                    .Area.cx = format->u.video.width - format->u.video.padding.right - format->u.video.padding.left,
-                    .Area.cy = format->u.video.height - format->u.video.padding.bottom - format->u.video.padding.top,
+                    .Area.cx = width - format->u.video.padding.right - format->u.video.padding.left,
+                    .Area.cy = height - format->u.video.padding.bottom - format->u.video.padding.top,
                 };
 
                 IMFMediaType_SetBlob(type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
@@ -555,6 +558,7 @@ IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format)
         case WG_MAJOR_TYPE_VIDEO_CINEPAK:
         case WG_MAJOR_TYPE_VIDEO_H264:
         case WG_MAJOR_TYPE_VIDEO_WMV:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             FIXME("Format %u not implemented!\n", format->major_type);
             /* fallthrough */
         case WG_MAJOR_TYPE_UNKNOWN:
@@ -620,7 +624,7 @@ static void mf_media_type_to_wg_format_audio(IMFMediaType *type, const GUID *sub
     FIXME("Unrecognized audio subtype %s, depth %u.\n", debugstr_guid(subtype), depth);
 }
 
-static void mf_media_type_to_wg_format_audio_mpeg4(IMFMediaType *type, struct wg_format *format)
+static void mf_media_type_to_wg_format_audio_mpeg4(IMFMediaType *type, const GUID *subtype, struct wg_format *format)
 {
     /* Audio specific config is stored at after HEAACWAVEINFO in MF_MT_USER_DATA
      * https://docs.microsoft.com/en-us/windows/win32/api/mmreg/ns-mmreg-heaacwaveformat
@@ -642,6 +646,7 @@ static void mf_media_type_to_wg_format_audio_mpeg4(IMFMediaType *type, struct wg
     BYTE buffer[64];
     HEAACWAVEFORMAT *user_data = (HEAACWAVEFORMAT *)buffer;
     UINT32 codec_data_size;
+    BOOL raw_aac;
 
     if (FAILED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, buffer, sizeof(buffer), &codec_data_size)))
     {
@@ -649,27 +654,44 @@ static void mf_media_type_to_wg_format_audio_mpeg4(IMFMediaType *type, struct wg
         return;
     }
 
-    codec_data_size -= min(codec_data_size, offsetof(HEAACWAVEFORMAT, pbAudioSpecificConfig));
+    raw_aac = IsEqualGUID(subtype, &MFAudioFormat_RAW_AAC);
+    if (!raw_aac)
+        codec_data_size -= min(codec_data_size, offsetof(HEAACWAVEFORMAT, pbAudioSpecificConfig));
     if (codec_data_size > sizeof(format->u.audio_mpeg4.codec_data))
     {
         FIXME("Codec data needs %u bytes.\n", codec_data_size);
         return;
     }
+    if (raw_aac)
+        memcpy(format->u.audio_mpeg4.codec_data, buffer, codec_data_size);
+    else
+        memcpy(format->u.audio_mpeg4.codec_data, user_data->pbAudioSpecificConfig, codec_data_size);
 
     format->major_type = WG_MAJOR_TYPE_AUDIO_MPEG4;
 
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_PAYLOAD_TYPE, &format->u.audio_mpeg4.payload_type)))
-        format->u.audio_mpeg4.payload_type = -1;
+        format->u.audio_mpeg4.payload_type = 0;
 
     format->u.audio_mpeg4.codec_data_len = codec_data_size;
-    memcpy(format->u.audio_mpeg4.codec_data, user_data->pbAudioSpecificConfig, codec_data_size);
+}
+
+static enum wg_video_format mf_video_format_to_wg(const GUID *subtype)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
+    {
+        if (IsEqualGUID(subtype, video_formats[i].subtype))
+            return video_formats[i].format;
+    }
+    FIXME("Unrecognized video subtype %s.\n", debugstr_guid(subtype));
+    return WG_VIDEO_FORMAT_UNKNOWN;
 }
 
 static void mf_media_type_to_wg_format_video(IMFMediaType *type, const GUID *subtype, struct wg_format *format)
 {
     UINT64 frame_rate, frame_size;
     MFVideoArea aperture;
-    unsigned int i;
     UINT32 size;
 
     if (FAILED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
@@ -699,15 +721,7 @@ static void mf_media_type_to_wg_format_video(IMFMediaType *type, const GUID *sub
         format->u.video.fps_d = (UINT32)frame_rate;
     }
 
-    for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
-    {
-        if (IsEqualGUID(subtype, video_formats[i].subtype))
-        {
-            format->u.video.format = video_formats[i].format;
-            return;
-        }
-    }
-    FIXME("Unrecognized video subtype %s.\n", debugstr_guid(subtype));
+    format->u.video.format = mf_video_format_to_wg(subtype);
 }
 
 static void mf_media_type_to_wg_format_audio_wma(IMFMediaType *type, const GUID *subtype, struct wg_format *format)
@@ -804,6 +818,33 @@ static void mf_media_type_to_wg_format_video_h264(IMFMediaType *type, struct wg_
         format->u.video_h264.level = level;
 }
 
+static void mf_media_type_to_wg_format_video_indeo(IMFMediaType *type, uint32_t version, struct wg_format *format)
+{
+    UINT64 frame_rate, frame_size;
+
+    memset(format, 0, sizeof(*format));
+    format->major_type = WG_MAJOR_TYPE_VIDEO_INDEO;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
+    {
+        format->u.video_indeo.width = frame_size >> 32;
+        format->u.video_indeo.height = (UINT32)frame_size;
+    }
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_RATE, &frame_rate)) && (UINT32)frame_rate)
+    {
+        format->u.video_indeo.fps_n = frame_rate >> 32;
+        format->u.video_indeo.fps_d = (UINT32)frame_rate;
+    }
+    else
+    {
+        format->u.video_indeo.fps_n = 1;
+        format->u.video_indeo.fps_d = 1;
+    }
+
+    format->u.video_indeo.version = version;
+}
+
 void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
 {
     GUID major_type, subtype;
@@ -828,8 +869,8 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
             mf_media_type_to_wg_format_audio_wma(type, &subtype, format);
-        else if (IsEqualGUID(&subtype, &MFAudioFormat_AAC))
-            mf_media_type_to_wg_format_audio_mpeg4(type, format);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_AAC) || IsEqualGUID(&subtype, &MFAudioFormat_RAW_AAC))
+            mf_media_type_to_wg_format_audio_mpeg4(type, &subtype, format);
         else
             mf_media_type_to_wg_format_audio(type, &subtype, format);
     }
@@ -837,6 +878,8 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
     {
         if (IsEqualGUID(&subtype, &MFVideoFormat_H264))
             mf_media_type_to_wg_format_video_h264(type, format);
+        else if (IsEqualGUID(&subtype, &MFVideoFormat_IV50))
+            mf_media_type_to_wg_format_video_indeo(type, 5, format);
         else
             mf_media_type_to_wg_format_video(type, &subtype, format);
     }
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 5561b106327..c12e9ee3397 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -377,6 +377,7 @@ unsigned int wg_format_get_max_size(const struct wg_format *format)
         case WG_MAJOR_TYPE_AUDIO_WMA:
         case WG_MAJOR_TYPE_VIDEO_H264:
         case WG_MAJOR_TYPE_VIDEO_WMV:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             FIXME("Format %u not implemented!\n", format->major_type);
             return 0;
 
@@ -548,6 +549,7 @@ bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool
     case WG_MAJOR_TYPE_AUDIO_WMA:
     case WG_MAJOR_TYPE_VIDEO_H264:
     case WG_MAJOR_TYPE_VIDEO_WMV:
+    case WG_MAJOR_TYPE_VIDEO_INDEO:
         FIXME("Format %u not implemented!\n", format->major_type);
         /* fallthrough */
     case WG_MAJOR_TYPE_UNKNOWN:
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 617204e97c7..ce67134af16 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -37,6 +37,7 @@ extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_set_output_format(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_push_data(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_read_data(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_get_status(void *args) DECLSPEC_HIDDEN;
 
 /* wg_allocator_release_sample can be used to release any sample that was requested. */
 typedef struct wg_sample *(*wg_allocator_request_sample_cb)(gsize size, void *context);
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 5424633003e..19629d12fd0 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -43,6 +43,7 @@ struct wg_format
         WG_MAJOR_TYPE_VIDEO_CINEPAK,
         WG_MAJOR_TYPE_VIDEO_H264,
         WG_MAJOR_TYPE_VIDEO_WMV,
+        WG_MAJOR_TYPE_VIDEO_INDEO,
     } major_type;
 
     union
@@ -133,6 +134,12 @@ struct wg_format
             uint32_t fps_n, fps_d;
             uint32_t version;
         } video_wmv;
+        struct
+        {
+            int32_t width, height;
+            uint32_t fps_n, fps_d;
+            uint32_t version;
+        } video_indeo;
     } u;
 };
 
@@ -310,6 +317,12 @@ struct wg_transform_set_output_format_params
     const struct wg_format *format;
 };
 
+struct wg_transform_get_status_params
+{
+    struct wg_transform *transform;
+    UINT32 accepts_input;
+};
+
 enum unix_funcs
 {
     unix_wg_parser_create,
@@ -343,6 +356,7 @@ enum unix_funcs
 
     unix_wg_transform_push_data,
     unix_wg_transform_read_data,
+    unix_wg_transform_get_status,
 };
 
 #endif /* __WINE_WINEGSTREAMER_UNIXLIB_H */
diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
new file mode 100644
index 00000000000..66df8173038
--- /dev/null
+++ b/dlls/winegstreamer/video_decoder.c
@@ -0,0 +1,506 @@
+/* Generic Video Decoder Transform
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ * Copyright 2023 Shaun Ren for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+DEFINE_MEDIATYPE_GUID(MFVideoFormat_IV50, MAKEFOURCC('I','V','5','0'));
+
+static const GUID *const input_types[] =
+{
+    &MFVideoFormat_IV50,
+};
+static const GUID *const output_types[] =
+{
+    &MFVideoFormat_YV12,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB565,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+};
+
+struct video_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    struct wg_format wg_format;
+    struct wg_transform *wg_transform;
+    struct wg_sample_queue *wg_sample_queue;
+};
+
+static struct video_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_decoder, IMFTransform_iface);
+}
+
+static HRESULT try_create_wg_transform(struct video_decoder *decoder)
+{
+    struct wg_format input_format;
+    struct wg_format output_format;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+    decoder->wg_transform = NULL;
+
+    mf_media_type_to_wg_format(decoder->input_type, &input_format);
+    if (input_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    output_format.u.video.fps_d = 0;
+    output_format.u.video.fps_n = 0;
+
+    if (!(decoder->wg_transform = wg_transform_create(&input_format, &output_format)))
+    {
+        ERR("Failed to create transform with input major_type %u.\n", input_format.major_type);
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+            IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI transform_AddRef(IMFTransform *iface)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %lu.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI transform_Release(IMFTransform *iface)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
+
+        wg_sample_queue_destroy(decoder->wg_sample_queue);
+        free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p.\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p.\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %lu, inputs %p, output_size %lu, outputs %p.\n",
+            iface, input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %#lx, info %p.\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("iface %p, id %#lx, info %p.\n", iface, id, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p semi-stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p.\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %#lx.\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %lu, ids %p.\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id,
+        DWORD index, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    UINT64 frame_size;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(input_types); ++i)
+        if (IsEqualGUID(&subtype, input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(hr = IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)) ||
+            (frame_size >> 32) == 0 || (UINT32)frame_size == 0)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    if (decoder->input_type)
+        IMFMediaType_Release(decoder->input_type);
+    IMFMediaType_AddRef((decoder->input_type = type));
+
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    UINT64 frame_size;
+    struct wg_format output_format;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(output_types); ++i)
+        if (IsEqualGUID(&subtype, output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(hr = IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
+        return hr;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    if (decoder->output_type)
+        IMFMediaType_Release(decoder->output_type);
+    IMFMediaType_AddRef((decoder->output_type = type));
+
+    if (decoder->wg_transform)
+    {
+        mf_media_type_to_wg_format(decoder->output_type, &output_format);
+
+        output_format.u.video.width = frame_size >> 32;
+        output_format.u.video.height = (UINT32)frame_size;
+        output_format.u.video.fps_d = 0;
+        output_format.u.video.fps_n = 0;
+
+        if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN
+            || !wg_transform_set_output_format(decoder->wg_transform, &output_format))
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+            return MF_E_INVALIDMEDIATYPE;
+        }
+    }
+    else if (FAILED(hr = try_create_wg_transform(decoder)))
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+        return hr;
+    }
+
+    decoder->wg_format.u.video.width = frame_size >> 32;
+    decoder->wg_format.u.video.height = (UINT32)frame_size;
+
+    return hr;
+}
+
+static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    TRACE("iface %p, lower %I64d, upper %I64d.\n", iface, lower, upper);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %#lx, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %Ix stub!\n", iface, message, param);
+    return S_OK;
+}
+
+static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+    HRESULT hr;
+
+    TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    hr = wg_transform_push_mf(decoder->wg_transform, sample, decoder->wg_sample_queue);
+
+    return hr;
+}
+
+static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct video_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_format wg_format;
+    UINT32 sample_size;
+    UINT64 frame_rate;
+    GUID subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count != 1)
+        return E_INVALIDARG;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = samples->dwStatus = 0;
+    if (!samples->pSample)
+        return E_INVALIDARG;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(decoder->output_type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+    if (FAILED(hr = MFCalculateImageSize(&subtype, decoder->wg_format.u.video.width,
+            decoder->wg_format.u.video.height, &sample_size)))
+        return hr;
+
+    if (SUCCEEDED(hr = wg_transform_read_mf(decoder->wg_transform, samples->pSample,
+            sample_size, &wg_format, &samples->dwStatus)))
+        wg_sample_queue_flush(decoder->wg_sample_queue, false);
+
+    if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        decoder->wg_format = wg_format;
+
+        if (FAILED(hr = MFCalculateImageSize(&subtype, decoder->wg_format.u.video.width,
+            decoder->wg_format.u.video.height, &sample_size)))
+            return hr;
+
+        /* keep the frame rate that was requested, GStreamer doesn't provide any */
+        if (SUCCEEDED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &frame_rate)))
+        {
+            decoder->wg_format.u.video.fps_n = frame_rate >> 32;
+            decoder->wg_format.u.video.fps_d = (UINT32)frame_rate;
+        }
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
+    return hr;
+}
+
+static const IMFTransformVtbl transform_vtbl =
+{
+    transform_QueryInterface,
+    transform_AddRef,
+    transform_Release,
+    transform_GetStreamLimits,
+    transform_GetStreamCount,
+    transform_GetStreamIDs,
+    transform_GetInputStreamInfo,
+    transform_GetOutputStreamInfo,
+    transform_GetAttributes,
+    transform_GetInputStreamAttributes,
+    transform_GetOutputStreamAttributes,
+    transform_DeleteInputStream,
+    transform_AddInputStreams,
+    transform_GetInputAvailableType,
+    transform_GetOutputAvailableType,
+    transform_SetInputType,
+    transform_SetOutputType,
+    transform_GetInputCurrentType,
+    transform_GetOutputCurrentType,
+    transform_GetInputStatus,
+    transform_GetOutputStatus,
+    transform_SetOutputBounds,
+    transform_ProcessEvent,
+    transform_ProcessMessage,
+    transform_ProcessInput,
+    transform_ProcessOutput,
+};
+
+HRESULT WINAPI winegstreamer_create_video_decoder(IMFTransform **out)
+{
+    struct video_decoder *decoder;
+    HRESULT hr;
+
+    TRACE("out %p.\n", out);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &transform_vtbl;
+    decoder->refcount = 1;
+
+    decoder->wg_format.u.video.fps_d = 1;
+    decoder->wg_format.u.video.fps_n = 1;
+
+    if (FAILED(hr = wg_sample_queue_create(&decoder->wg_sample_queue)))
+        goto failed;
+
+    *out = &decoder->IMFTransform_iface;
+    TRACE("created decoder %p.\n", *out);
+    return S_OK;
+
+failed:
+    free(decoder);
+    return hr;
+}
diff --git a/dlls/winegstreamer/wg_format.c b/dlls/winegstreamer/wg_format.c
index a7876977d6c..63f1e3931b5 100644
--- a/dlls/winegstreamer/wg_format.c
+++ b/dlls/winegstreamer/wg_format.c
@@ -573,6 +573,25 @@ static GstCaps *wg_format_to_caps_video_wmv(const struct wg_format *format)
     return caps;
 }
 
+static GstCaps *wg_format_to_caps_video_indeo(const struct wg_format *format)
+{
+    GstCaps *caps;
+
+    if (!(caps = gst_caps_new_empty_simple("video/x-indeo")))
+        return NULL;
+
+    if (format->u.video_indeo.width)
+        gst_caps_set_simple(caps, "width", G_TYPE_INT, format->u.video_indeo.width, NULL);
+    if (format->u.video_indeo.height)
+        gst_caps_set_simple(caps, "height", G_TYPE_INT, format->u.video_indeo.height, NULL);
+    if (format->u.video_indeo.fps_d || format->u.video_indeo.fps_n)
+        gst_caps_set_simple(caps, "framerate", GST_TYPE_FRACTION, format->u.video_indeo.fps_n, format->u.video_indeo.fps_d, NULL);
+    if (format->u.video_indeo.version)
+        gst_caps_set_simple(caps, "indeoversion", G_TYPE_INT, format->u.video_indeo.version, NULL);
+
+    return caps;
+}
+
 GstCaps *wg_format_to_caps(const struct wg_format *format)
 {
     switch (format->major_type)
@@ -595,6 +614,8 @@ GstCaps *wg_format_to_caps(const struct wg_format *format)
             return wg_format_to_caps_video_h264(format);
         case WG_MAJOR_TYPE_VIDEO_WMV:
             return wg_format_to_caps_video_wmv(format);
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
+            return wg_format_to_caps_video_indeo(format);
     }
     assert(0);
     return NULL;
@@ -612,6 +633,7 @@ bool wg_format_compare(const struct wg_format *a, const struct wg_format *b)
         case WG_MAJOR_TYPE_AUDIO_WMA:
         case WG_MAJOR_TYPE_VIDEO_H264:
         case WG_MAJOR_TYPE_VIDEO_WMV:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             GST_FIXME("Format %u not implemented!", a->major_type);
             /* fallthrough */
         case WG_MAJOR_TYPE_UNKNOWN:
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index d2db1f039e4..5bb824f4399 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -33,6 +33,7 @@
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <gst/audio/audio.h>
+#include <gst/tag/tag.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -93,6 +94,8 @@ struct wg_parser
     bool sink_connected;
 
     bool unlimited_buffering;
+
+    gchar *sink_caps;
 };
 
 struct wg_parser_stream
@@ -476,7 +479,9 @@ static NTSTATUS wg_parser_stream_notify_qos(void *args)
 static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
         GstCaps *caps, GstElementFactory *fact, gpointer user)
 {
+    struct wg_parser *parser = user;
     const char *name = gst_element_factory_get_longname(fact);
+    const char *klass = gst_element_factory_get_klass(fact);
 
     GST_INFO("Using \"%s\".", name);
 
@@ -490,6 +495,10 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
         GST_WARNING("Disabled video acceleration since it breaks in wine.");
         return GST_AUTOPLUG_SELECT_SKIP;
     }
+
+    if (!parser->sink_caps && strstr(klass, GST_ELEMENT_FACTORY_KLASS_DEMUXER))
+        parser->sink_caps = g_strdup(gst_structure_get_name(gst_caps_get_structure(caps, 0)));
+
     return GST_AUTOPLUG_SELECT_TRY;
 }
 
@@ -1276,47 +1285,72 @@ static gboolean src_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
 static void query_tags(struct wg_parser_stream *stream)
 {
     const gchar *struct_name;
-    GstTagList *tag_list;
     GstEvent *tag_event;
-    guint i, tag_count;
-    const GValue *val;
-    GstSample *sample;
-    GstBuffer *buf;
-    gsize size;
-
-    if (!(tag_event = gst_pad_get_sticky_event(stream->their_src, GST_EVENT_TAG, 0)))
-        return;
+    guint i, j;
 
-    gst_event_parse_tag(tag_event, &tag_list);
-    gst_tag_list_get_string(tag_list, "language-code", &stream->tags[WG_PARSER_TAG_LANGUAGE]);
+    stream->tags[WG_PARSER_TAG_NAME]     = NULL;
+    stream->tags[WG_PARSER_TAG_LANGUAGE] = NULL;
 
-    /* Extract stream name from Quick Time demuxer private tag where it puts unrecognized chunks. */
-    tag_count = gst_tag_list_get_tag_size(tag_list, "private-qt-tag");
-    for (i = 0; i < tag_count; ++i)
+    i = 0;
+    while ((tag_event = gst_pad_get_sticky_event(stream->their_src, GST_EVENT_TAG, i++)))
     {
-        if (!(val = gst_tag_list_get_value_index(tag_list, "private-qt-tag", i)))
-            continue;
-        if (!GST_VALUE_HOLDS_SAMPLE(val) || !(sample = gst_value_get_sample(val)))
-            continue;
-        struct_name = gst_structure_get_name(gst_sample_get_info(sample));
-        if (!struct_name || strcmp(struct_name, "application/x-gst-qt-name-tag"))
-            continue;
-        if (!(buf = gst_sample_get_buffer(sample)))
-            continue;
-        if ((size = gst_buffer_get_size(buf)) < 8)
-            continue;
-        size -= 8;
-        if (!(stream->tags[WG_PARSER_TAG_NAME] = g_malloc(size + 1)))
-            continue;
-        if (gst_buffer_extract(buf, 8, stream->tags[WG_PARSER_TAG_NAME], size) != size)
+        GstTagList *tag_list;
+
+        gst_event_parse_tag(tag_event, &tag_list);
+
+        if (!stream->tags[WG_PARSER_TAG_NAME])
+        {
+            /* Extract stream name from Quick Time demuxer private tag where it puts unrecognized chunks. */
+            const GValue *val;
+            GstSample *sample;
+            GstBuffer *buf;
+            gsize size;
+            guint tag_count = gst_tag_list_get_tag_size(tag_list, "private-qt-tag");
+
+            for (j = 0; j < tag_count; ++j)
+            {
+                if (!(val = gst_tag_list_get_value_index(tag_list, "private-qt-tag", j)))
+                    continue;
+                if (!GST_VALUE_HOLDS_SAMPLE(val) || !(sample = gst_value_get_sample(val)))
+                    continue;
+                struct_name = gst_structure_get_name(gst_sample_get_info(sample));
+                if (!struct_name || strcmp(struct_name, "application/x-gst-qt-name-tag"))
+                    continue;
+                if (!(buf = gst_sample_get_buffer(sample)))
+                    continue;
+                if ((size = gst_buffer_get_size(buf)) < 8)
+                    continue;
+                size -= 8;
+                if (!(stream->tags[WG_PARSER_TAG_NAME] = g_malloc(size + 1)))
+                    continue;
+                if (gst_buffer_extract(buf, 8, stream->tags[WG_PARSER_TAG_NAME], size) != size)
+                {
+                    g_free(stream->tags[WG_PARSER_TAG_NAME]);
+                    stream->tags[WG_PARSER_TAG_NAME] = NULL;
+                    continue;
+                }
+                stream->tags[WG_PARSER_TAG_NAME][size] = 0;
+            }
+        }
+
+        if (!stream->tags[WG_PARSER_TAG_LANGUAGE])
         {
-            g_free(stream->tags[WG_PARSER_TAG_NAME]);
-            stream->tags[WG_PARSER_TAG_NAME] = NULL;
-            continue;
+            gchar *lang_code = NULL;
+
+            gst_tag_list_get_string(tag_list, GST_TAG_LANGUAGE_CODE, &lang_code);
+            if (stream->parser->sink_caps && !strcmp(stream->parser->sink_caps, "video/quicktime"))
+            {
+                /* For QuickTime media, we convert the language tags to ISO 639-1. */
+                const gchar *lang_code_iso_639_1 = lang_code ? gst_tag_get_language_code_iso_639_1(lang_code) : NULL;
+                stream->tags[WG_PARSER_TAG_LANGUAGE] = lang_code_iso_639_1 ? g_strdup(lang_code_iso_639_1) : NULL;
+                g_free(lang_code);
+            }
+            else
+                stream->tags[WG_PARSER_TAG_LANGUAGE] = lang_code;
         }
-        stream->tags[WG_PARSER_TAG_NAME][size] = 0;
+
+        gst_event_unref(tag_event);
     }
-    gst_event_unref(tag_event);
 }
 
 static NTSTATUS wg_parser_connect(void *args)
@@ -1377,7 +1411,7 @@ static NTSTATUS wg_parser_connect(void *args)
         struct wg_parser_stream *stream = parser->streams[i];
         gint64 duration;
 
-        /* If we receieved a buffer waiting for tags or caps does not make sense anymore. */
+        /* If we received a buffer, waiting for tags or caps does not make sense anymore. */
         while ((!stream->has_caps || !stream->has_tags) && !parser->error && !stream->has_buffer)
             pthread_cond_wait(&parser->init_cond, &parser->mutex);
 
@@ -1479,6 +1513,9 @@ out:
         parser->container = NULL;
     }
 
+    g_free(parser->sink_caps);
+    parser->sink_caps = NULL;
+
     pthread_mutex_lock(&parser->mutex);
     parser->sink_connected = false;
     pthread_mutex_unlock(&parser->mutex);
@@ -1522,6 +1559,9 @@ static NTSTATUS wg_parser_disconnect(void *args)
     gst_object_unref(parser->container);
     parser->container = NULL;
 
+    g_free(parser->sink_caps);
+    parser->sink_caps = NULL;
+
     return S_OK;
 }
 
@@ -1775,4 +1815,5 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
 
     X(wg_transform_push_data),
     X(wg_transform_read_data),
+    X(wg_transform_get_status),
 };
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 302a64eb57b..65a34511284 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -427,6 +427,7 @@ NTSTATUS wg_transform_create(void *args)
         case WG_MAJOR_TYPE_AUDIO_MPEG4:
         case WG_MAJOR_TYPE_AUDIO_WMA:
         case WG_MAJOR_TYPE_VIDEO_CINEPAK:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             if (!(element = transform_find_element(GST_ELEMENT_FACTORY_TYPE_DECODER, src_caps, raw_caps))
                     || !transform_append_element(transform, element, &first, &last))
             {
@@ -482,6 +483,7 @@ NTSTATUS wg_transform_create(void *args)
         case WG_MAJOR_TYPE_VIDEO_H264:
         case WG_MAJOR_TYPE_UNKNOWN:
         case WG_MAJOR_TYPE_VIDEO_WMV:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             GST_FIXME("Format %u not implemented!", output_format.major_type);
             goto out;
     }
@@ -931,3 +933,12 @@ NTSTATUS wg_transform_read_data(void *args)
     wg_allocator_release_sample(transform->allocator, sample, discard_data);
     return STATUS_SUCCESS;
 }
+
+NTSTATUS wg_transform_get_status(void *args)
+{
+    struct wg_transform_get_status_params *params = args;
+    struct wg_transform *transform = params->transform;
+
+    params->accepts_input = gst_atomic_queue_length(transform->input_queue) < transform->input_max_length;
+    return STATUS_SUCCESS;
+}
diff --git a/dlls/winegstreamer/winegstreamer.spec b/dlls/winegstreamer/winegstreamer.spec
index 9804e324044..095f75a0865 100644
--- a/dlls/winegstreamer/winegstreamer.spec
+++ b/dlls/winegstreamer/winegstreamer.spec
@@ -3,3 +3,4 @@
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stdcall winegstreamer_create_wm_sync_reader(ptr ptr)
+@ stdcall winegstreamer_create_video_decoder(ptr)
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 18b0e8a90bc..736dbba452c 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1579,6 +1579,8 @@ static const char *get_major_type_string(enum wg_major_type type)
             return "h264";
         case WG_MAJOR_TYPE_VIDEO_WMV:
             return "wmv";
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
+            return "indeo";
         case WG_MAJOR_TYPE_UNKNOWN:
             return "unknown";
     }
@@ -1700,7 +1702,8 @@ static HRESULT WINAPI unknown_inner_QueryInterface(IUnknown *iface, REFIID iid,
         *out = &reader->IWMReaderTimecode_iface;
     else
     {
-        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        *out = NULL;
         return E_NOINTERFACE;
     }
 
@@ -1933,6 +1936,7 @@ static HRESULT WINAPI reader_GetOutputFormat(IWMSyncReader2 *iface,
         case WG_MAJOR_TYPE_VIDEO_CINEPAK:
         case WG_MAJOR_TYPE_VIDEO_H264:
         case WG_MAJOR_TYPE_VIDEO_WMV:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             FIXME("Format %u not implemented!\n", format.major_type);
             break;
         case WG_MAJOR_TYPE_UNKNOWN:
@@ -1974,6 +1978,7 @@ static HRESULT WINAPI reader_GetOutputFormatCount(IWMSyncReader2 *iface, DWORD o
         case WG_MAJOR_TYPE_VIDEO_CINEPAK:
         case WG_MAJOR_TYPE_VIDEO_H264:
         case WG_MAJOR_TYPE_VIDEO_WMV:
+        case WG_MAJOR_TYPE_VIDEO_INDEO:
             FIXME("Format %u not implemented!\n", format.major_type);
             /* fallthrough */
         case WG_MAJOR_TYPE_AUDIO:
diff --git a/dlls/winegstreamer/wmv_decoder.c b/dlls/winegstreamer/wmv_decoder.c
index 1b03d9aa639..473fabab867 100644
--- a/dlls/winegstreamer/wmv_decoder.c
+++ b/dlls/winegstreamer/wmv_decoder.c
@@ -29,21 +29,45 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
-extern const GUID MFVideoFormat_VC1S;
+extern const GUID MEDIASUBTYPE_VC1S;
 
-DEFINE_GUID(MFVideoFormat_WMV_Unknown, 0x7ce12ca9,0xbfbf,0x43d9,0x9d,0x00,0x82,0xb8,0xed,0x54,0x31,0x6b);
+DEFINE_GUID(MEDIASUBTYPE_WMV_Unknown, 0x7ce12ca9,0xbfbf,0x43d9,0x9d,0x00,0x82,0xb8,0xed,0x54,0x31,0x6b);
+
+struct decoder_type
+{
+    const GUID *subtype;
+    WORD bpp;
+    DWORD compression;
+};
 
 static const GUID *const wmv_decoder_input_types[] =
 {
-    &MFVideoFormat_WMV1,
-    &MFVideoFormat_WMV2,
+    &MEDIASUBTYPE_WMV1,
+    &MEDIASUBTYPE_WMV2,
     &MEDIASUBTYPE_WMVA,
     &MEDIASUBTYPE_WMVP,
     &MEDIASUBTYPE_WVP2,
-    &MFVideoFormat_WMV_Unknown,
-    &MFVideoFormat_WVC1,
-    &MFVideoFormat_WMV3,
-    &MFVideoFormat_VC1S,
+    &MEDIASUBTYPE_WMV_Unknown,
+    &MEDIASUBTYPE_WVC1,
+    &MEDIASUBTYPE_WMV3,
+    &MEDIASUBTYPE_VC1S,
+};
+
+static const struct decoder_type wmv_decoder_output_types[] =
+{
+    { &MEDIASUBTYPE_NV12,   12, MAKEFOURCC('N', 'V', '1', '2') },
+    { &MEDIASUBTYPE_YV12,   12, MAKEFOURCC('Y', 'V', '1', '2') },
+    { &MEDIASUBTYPE_IYUV,   12, MAKEFOURCC('I', 'Y', 'U', 'V') },
+    { &MEDIASUBTYPE_I420,   12, MAKEFOURCC('I', '4', '2', '0') },
+    { &MEDIASUBTYPE_YUY2,   16, MAKEFOURCC('Y', 'U', 'Y', '2') },
+    { &MEDIASUBTYPE_UYVY,   16, MAKEFOURCC('U', 'Y', 'V', 'Y') },
+    { &MEDIASUBTYPE_YVYU,   16, MAKEFOURCC('Y', 'V', 'Y', 'U') },
+    { &MEDIASUBTYPE_NV11,   12, MAKEFOURCC('N', 'V', '1', '1') },
+    { &MEDIASUBTYPE_RGB32,  32, BI_RGB },
+    { &MEDIASUBTYPE_RGB24,  24, BI_RGB },
+    { &MEDIASUBTYPE_RGB565, 16, BI_BITFIELDS },
+    { &MEDIASUBTYPE_RGB555, 16, BI_RGB },
+    { &MEDIASUBTYPE_RGB8,   8,  BI_RGB },
 };
 
 struct wmv_decoder
@@ -57,8 +81,15 @@ struct wmv_decoder
     LONG refcount;
 
     struct wg_format input_format;
+    struct wg_format output_format;
+    GUID output_subtype;
 };
 
+static bool wg_format_is_set(struct wg_format *format)
+{
+    return format->major_type != WG_MAJOR_TYPE_UNKNOWN;
+}
+
 static inline struct wmv_decoder *impl_from_IUnknown(IUnknown *iface)
 {
     return CONTAINING_RECORD(iface, struct wmv_decoder, IUnknown_inner);
@@ -387,8 +418,58 @@ static HRESULT WINAPI media_object_GetInputType(IMediaObject *iface, DWORD index
 static HRESULT WINAPI media_object_GetOutputType(IMediaObject *iface, DWORD index, DWORD type_index,
         DMO_MEDIA_TYPE *type)
 {
-    FIXME("iface %p, index %lu, type_index %lu, type %p stub!\n", iface, index, type_index, type);
-    return E_NOTIMPL;
+    struct wmv_decoder *decoder = impl_from_IMediaObject(iface);
+    VIDEOINFOHEADER *info;
+    const GUID *subtype;
+    LONG width, height;
+    UINT32 image_size;
+    HRESULT hr;
+
+    TRACE("iface %p, index %lu, type_index %lu, type %p.\n", iface, index, type_index, type);
+
+    if (index > 0)
+        return DMO_E_INVALIDSTREAMINDEX;
+    if (type_index >= ARRAY_SIZE(wmv_decoder_output_types))
+        return DMO_E_NO_MORE_ITEMS;
+    if (!type)
+        return S_OK;
+    if (!wg_format_is_set(&decoder->input_format))
+        return DMO_E_TYPE_NOT_SET;
+
+    width = decoder->input_format.u.video_wmv.width;
+    height = decoder->input_format.u.video_wmv.height;
+    subtype = wmv_decoder_output_types[type_index].subtype;
+    if (FAILED(hr = MFCalculateImageSize(subtype, width, height, &image_size)))
+    {
+        FIXME("Failed to get image size of subtype %s.\n", debugstr_guid(subtype));
+        return hr;
+    }
+
+    memset(type, 0, sizeof(*type));
+    type->majortype = MFMediaType_Video;
+    type->subtype = *subtype;
+    type->bFixedSizeSamples = TRUE;
+    type->bTemporalCompression = FALSE;
+    type->lSampleSize = image_size;
+    type->formattype = FORMAT_VideoInfo;
+    type->cbFormat = sizeof(VIDEOINFOHEADER);
+    type->pbFormat = CoTaskMemAlloc(type->cbFormat);
+    memset(type->pbFormat, 0, type->cbFormat);
+
+    info = (VIDEOINFOHEADER *)type->pbFormat;
+    info->rcSource.right  = width;
+    info->rcSource.bottom = height;
+    info->rcTarget.right  = width;
+    info->rcTarget.bottom = height;
+    info->bmiHeader.biSize = sizeof(info->bmiHeader);
+    info->bmiHeader.biWidth  = width;
+    info->bmiHeader.biHeight = height;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = wmv_decoder_output_types[type_index].bpp;
+    info->bmiHeader.biCompression = wmv_decoder_output_types[type_index].compression;
+    info->bmiHeader.biSizeImage = image_size;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index,
@@ -434,8 +515,47 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
 static HRESULT WINAPI media_object_SetOutputType(IMediaObject *iface, DWORD index,
         const DMO_MEDIA_TYPE *type, DWORD flags)
 {
-    FIXME("iface %p, index %lu, type %p, flags %#lx stub!\n", iface, index, type, flags);
-    return E_NOTIMPL;
+    struct wmv_decoder *decoder = impl_from_IMediaObject(iface);
+    struct wg_format wg_format;
+    unsigned int i;
+
+    TRACE("iface %p, index %lu, type %p, flags %#lx,\n", iface, index, type, flags);
+
+    if (index > 0)
+        return DMO_E_INVALIDSTREAMINDEX;
+
+    if (!type)
+    {
+        if (flags & DMO_SET_TYPEF_CLEAR)
+        {
+            memset(&decoder->output_format, 0, sizeof(decoder->output_format));
+            return S_OK;
+        }
+        return E_POINTER;
+    }
+
+    if (!wg_format_is_set(&decoder->input_format))
+        return DMO_E_TYPE_NOT_SET;
+
+    if (!IsEqualGUID(&type->majortype, &MEDIATYPE_Video))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    for (i = 0; i < ARRAY_SIZE(wmv_decoder_output_types); ++i)
+        if (IsEqualGUID(&type->subtype, wmv_decoder_output_types[i].subtype))
+            break;
+    if (i == ARRAY_SIZE(wmv_decoder_output_types))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    if (!amt_to_wg_format((const AM_MEDIA_TYPE *)type, &wg_format))
+        return DMO_E_TYPE_NOT_ACCEPTED;
+
+    if (!(flags & DMO_SET_TYPEF_TEST_ONLY))
+    {
+        decoder->output_subtype = type->subtype;
+        decoder->output_format = wg_format;
+    }
+
+    return S_OK;
 }
 
 static HRESULT WINAPI media_object_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
@@ -460,8 +580,25 @@ static HRESULT WINAPI media_object_GetInputSizeInfo(IMediaObject *iface, DWORD i
 
 static HRESULT WINAPI media_object_GetOutputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size, DWORD *alignment)
 {
-    FIXME("iface %p, index %lu, size %p, alignment %p stub!\n", iface, index, size, alignment);
-    return E_NOTIMPL;
+    struct wmv_decoder *decoder = impl_from_IMediaObject(iface);
+    HRESULT hr;
+
+    TRACE("iface %p, index %lu, size %p, alignment %p.\n", iface, index, size, alignment);
+
+    if (index > 0)
+        return DMO_E_INVALIDSTREAMINDEX;
+    if (!wg_format_is_set(&decoder->output_format))
+        return DMO_E_TYPE_NOT_SET;
+
+    if (FAILED(hr = MFCalculateImageSize(&decoder->output_subtype,
+            decoder->output_format.u.video.width, decoder->output_format.u.video.height, (UINT32 *)size)))
+    {
+        FIXME("Failed to get image size of subtype %s.\n", debugstr_guid(&decoder->output_subtype));
+        return hr;
+    }
+    *alignment = 1;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI media_object_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
diff --git a/dlls/winemac.drv/cocoa_display.m b/dlls/winemac.drv/cocoa_display.m
index 04f6dda4481..b5096a39ca4 100644
--- a/dlls/winemac.drv/cocoa_display.m
+++ b/dlls/winemac.drv/cocoa_display.m
@@ -675,7 +675,6 @@ int macdrv_get_monitors(uint32_t adapter_id, struct macdrv_monitor** new_monitor
                 if (j == 0)
                     primary_index = monitor_count;
 
-                strcpy(monitors[monitor_count].name, "Generic Non-PnP Monitor");
                 monitors[monitor_count].state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
                 monitors[monitor_count].rc_monitor = displays[j].frame;
                 monitors[monitor_count].rc_work = displays[j].work_frame;
diff --git a/dlls/winemac.drv/display.c b/dlls/winemac.drv/display.c
index dab81cc8ffb..19ff72a7130 100644
--- a/dlls/winemac.drv/display.c
+++ b/dlls/winemac.drv/display.c
@@ -1192,9 +1192,6 @@ BOOL macdrv_UpdateDisplayDevices( const struct gdi_device_manager *device_manage
                     .rc_work = rect_from_cgrect(monitor->rc_work),
                     .state_flags = monitor->state_flags,
                 };
-                RtlUTF8ToUnicodeN(gdi_monitor.name, sizeof(gdi_monitor.name), &len,
-                                  monitor->name, strlen(monitor->name));
-                TRACE("monitor: %s\n", debugstr_a(monitor->name));
                 device_manager->add_monitor( &gdi_monitor, param );
             }
 
diff --git a/dlls/winemac.drv/event.c b/dlls/winemac.drv/event.c
index e4f76e2b0e1..5b717b4b730 100644
--- a/dlls/winemac.drv/event.c
+++ b/dlls/winemac.drv/event.c
@@ -510,24 +510,16 @@ static int process_events(macdrv_event_queue queue, macdrv_event_mask mask)
 
 
 /***********************************************************************
- *              MsgWaitForMultipleObjectsEx   (MACDRV.@)
+ *              ProcessEvents   (MACDRV.@)
  */
-NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
-                                            const LARGE_INTEGER *timeout, DWORD mask, DWORD flags)
+NTSTATUS macdrv_ProcessEvents(DWORD mask)
 {
-    DWORD ret;
     struct macdrv_thread_data *data = macdrv_thread_data();
     macdrv_event_mask event_mask = get_event_mask(mask);
 
-    TRACE("count %d, handles %p, timeout %p, mask %x, flags %x\n", (unsigned int)count,
-          handles, timeout, (unsigned int)mask, (unsigned int)flags);
+    TRACE("mask %x\n", (unsigned int)mask);
 
-    if (!data)
-    {
-        if (!count && timeout && !timeout->QuadPart) return WAIT_TIMEOUT;
-        return NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                         !!(flags & MWMO_ALERTABLE), timeout );
-    }
+    if (!data) return FALSE;
 
     if (data->current_event && data->current_event->type != QUERY_EVENT &&
         data->current_event->type != QUERY_EVENT_NO_PREEMPT_WAIT &&
@@ -535,14 +527,5 @@ NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
         data->current_event->type != WINDOW_DRAG_BEGIN)
         event_mask = 0;  /* don't process nested events */
 
-    if (process_events(data->queue, event_mask)) ret = count - 1;
-    else if (count || !timeout || timeout->QuadPart)
-    {
-        ret = NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                        !!(flags & MWMO_ALERTABLE), timeout );
-        if (ret == count - 1) process_events(data->queue, event_mask);
-    }
-    else ret = WAIT_TIMEOUT;
-
-    return ret;
+    return process_events(data->queue, event_mask);
 }
diff --git a/dlls/winemac.drv/gdi.c b/dlls/winemac.drv/gdi.c
index fd1da722061..d22532fd3b7 100644
--- a/dlls/winemac.drv/gdi.c
+++ b/dlls/winemac.drv/gdi.c
@@ -282,7 +282,7 @@ static const struct user_driver_funcs macdrv_funcs =
     .pGetKeyboardLayoutList = macdrv_GetKeyboardLayoutList,
     .pGetKeyNameText = macdrv_GetKeyNameText,
     .pMapVirtualKeyEx = macdrv_MapVirtualKeyEx,
-    .pMsgWaitForMultipleObjectsEx = macdrv_MsgWaitForMultipleObjectsEx,
+    .pProcessEvents = macdrv_ProcessEvents,
     .pRegisterHotKey = macdrv_RegisterHotKey,
     .pSetCapture = macdrv_SetCapture,
     .pSetCursor = macdrv_SetCursor,
diff --git a/dlls/winemac.drv/ime.c b/dlls/winemac.drv/ime.c
index 19a974b3c24..5780c942283 100644
--- a/dlls/winemac.drv/ime.c
+++ b/dlls/winemac.drv/ime.c
@@ -36,7 +36,7 @@
 
 #include "macdrv_dll.h"
 #include "imm.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
@@ -52,12 +52,6 @@ typedef struct _IMEPRIVATE {
     UINT repeat;
 } IMEPRIVATE, *LPIMEPRIVATE;
 
-typedef struct _tagTRANSMSG {
-    UINT message;
-    WPARAM wParam;
-    LPARAM lParam;
-} TRANSMSG, *LPTRANSMSG;
-
 static const WCHAR UI_CLASS_NAME[] = {'W','i','n','e',' ','M','a','c',' ','I','M','E',0};
 
 static HIMC *hSelectedFrom = NULL;
@@ -454,15 +448,15 @@ static void GenerateIMEMessage(HIMC hIMC, UINT msg, WPARAM wParam, LPARAM lParam
     UnlockRealIMC(hIMC);
 }
 
-static BOOL GenerateMessageToTransKey(LPDWORD lpTransBuf, UINT *uNumTranMsgs,
+static BOOL GenerateMessageToTransKey(TRANSMSGLIST *lpTransBuf, UINT *uNumTranMsgs,
                                       UINT msg, WPARAM wParam, LPARAM lParam)
 {
     LPTRANSMSG ptr;
 
-    if (*uNumTranMsgs + 1 >= (UINT)*lpTransBuf)
+    if (*uNumTranMsgs + 1 >= lpTransBuf->uMsgCount)
         return FALSE;
 
-    ptr = (LPTRANSMSG)(lpTransBuf + 1 + *uNumTranMsgs * 3);
+    ptr = lpTransBuf->TransMsg + *uNumTranMsgs;
     ptr->message = msg;
     ptr->wParam = wParam;
     ptr->lParam = lParam;
@@ -652,7 +646,7 @@ BOOL WINAPI ImeSetActiveContext(HIMC hIMC, BOOL fFlag)
 }
 
 UINT WINAPI ImeToAsciiEx(UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState,
-                         LPDWORD lpdwTransKey, UINT fuState, HIMC hIMC)
+                         TRANSMSGLIST *lpdwTransKey, UINT fuState, HIMC hIMC)
 {
     struct process_text_input_params params;
     UINT vkey;
@@ -1367,7 +1361,7 @@ static BOOL WINAPI register_classes( INIT_ONCE *once, void *param, void **contex
     return TRUE;
 }
 
-BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass, LPCWSTR lpszOption)
+BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass, DWORD flags)
 {
     static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
 
diff --git a/dlls/winemac.drv/macdrv.h b/dlls/winemac.drv/macdrv.h
index 40f70e55094..281d49c1e9a 100644
--- a/dlls/winemac.drv/macdrv.h
+++ b/dlls/winemac.drv/macdrv.h
@@ -169,9 +169,7 @@ extern INT macdrv_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyStat
 extern INT macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
 extern BOOL macdrv_SystemParametersInfo(UINT action, UINT int_param, void *ptr_param,
                                         UINT flags) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
-                                                   const LARGE_INTEGER *timeout, DWORD mask,
-                                                   DWORD flags) DECLSPEC_HIDDEN;
+extern BOOL macdrv_ProcessEvents(DWORD mask) DECLSPEC_HIDDEN;
 extern void macdrv_ThreadDetach(void) DECLSPEC_HIDDEN;
 
 
diff --git a/dlls/winemac.drv/macdrv_cocoa.h b/dlls/winemac.drv/macdrv_cocoa.h
index 6196032c08d..a82dd319330 100644
--- a/dlls/winemac.drv/macdrv_cocoa.h
+++ b/dlls/winemac.drv/macdrv_cocoa.h
@@ -291,8 +291,6 @@ static inline CGPoint cgpoint_win_from_mac(CGPoint point)
 /* Represent a monitor in EnumDisplayDevices context */
 struct macdrv_monitor
 {
-    /* Name, in UTF-8 encoding */
-    char name[128];
     /* as RcMonitor in MONITORINFO struct after conversion by rect_from_cgrect */
     CGRect rc_monitor;
     /* as RcWork in MONITORINFO struct after conversion by rect_from_cgrect */
diff --git a/dlls/wineps.drv/escape.c b/dlls/wineps.drv/escape.c
index 0149e192520..9ced2221b1c 100644
--- a/dlls/wineps.drv/escape.c
+++ b/dlls/wineps.drv/escape.c
@@ -459,17 +459,9 @@ INT CDECL PSDRV_StartDoc( PHYSDEV dev, const DOCINFOW *doc )
     }
 
     di.pDocName = (LPWSTR) doc->lpszDocName;
+    di.pOutputFile = (LPWSTR) doc->lpszOutput;
     di.pDatatype = NULL;
 
-    if(doc->lpszOutput)
-        di.pOutputFile = (LPWSTR) doc->lpszOutput;
-    else if(physDev->job.output)
-        di.pOutputFile = physDev->job.output;
-    else
-        di.pOutputFile = NULL;
-
-    TRACE("using output: %s\n", debugstr_w(di.pOutputFile));
-
     /* redirection located in HKCU\Software\Wine\Printing\Spooler
        is done during winspool.drv,ScheduleJob */
     physDev->job.id = StartDocPrinterW(physDev->job.hprinter, 1, (LPBYTE) &di);
diff --git a/dlls/wineps.drv/init.c b/dlls/wineps.drv/init.c
index 0d4467b6964..579e59e621b 100644
--- a/dlls/wineps.drv/init.c
+++ b/dlls/wineps.drv/init.c
@@ -387,8 +387,6 @@ static BOOL CDECL PSDRV_CreateDC( PHYSDEV *pdev, LPCWSTR device, LPCWSTR output,
 
     if (!(physDev = create_psdrv_physdev( pi ))) return FALSE;
 
-    if (output && *output) physDev->job.output = strdupW( output );
-
     if(initData)
     {
         dump_devmode(initData);
@@ -432,7 +430,6 @@ static BOOL CDECL PSDRV_DeleteDC( PHYSDEV dev )
     TRACE("\n");
 
     HeapFree( GetProcessHeap(), 0, physDev->Devmode );
-    HeapFree( GetProcessHeap(), 0, physDev->job.output );
     HeapFree( GetProcessHeap(), 0, physDev );
 
     return TRUE;
diff --git a/dlls/wineps.drv/psdrv.h b/dlls/wineps.drv/psdrv.h
index 2af021508b7..153601d4c86 100644
--- a/dlls/wineps.drv/psdrv.h
+++ b/dlls/wineps.drv/psdrv.h
@@ -352,7 +352,6 @@ enum passthrough
 typedef struct {
     DWORD		id;             /* Job id */
     HANDLE              hprinter;       /* Printer handle */
-    LPWSTR              output;	        /* Output file/port */
     LPWSTR              doc_name;       /* Document Name */
     BOOL		banding;        /* Have we received a NEXTBAND */
     BOOL		OutOfPage;      /* Page header not sent yet */
diff --git a/dlls/winepulse.drv/Makefile.in b/dlls/winepulse.drv/Makefile.in
index d938aac052e..7a78f4e854e 100644
--- a/dlls/winepulse.drv/Makefile.in
+++ b/dlls/winepulse.drv/Makefile.in
@@ -6,5 +6,4 @@ UNIX_CFLAGS  = $(PULSE_CFLAGS)
 
 C_SRCS = \
 	mmdevdrv.c \
-	mult.c \
 	pulse.c
diff --git a/dlls/winepulse.drv/mult.c b/dlls/winepulse.drv/mult.h
similarity index 99%
rename from dlls/winepulse.drv/mult.c
rename to dlls/winepulse.drv/mult.h
index 26b5e83c9ca..58f516a0d4d 100644
--- a/dlls/winepulse.drv/mult.c
+++ b/dlls/winepulse.drv/mult.h
@@ -20,11 +20,6 @@
 
 #include <windef.h>
 
-#if 0
-#pragma makedep unix
-#endif
-
-
 /**********************************************************************
  * A-law and u-law sample manipulation functions
  * Multiply with the given volume (vol must be between 0...1 inclusive)
@@ -32,7 +27,7 @@
  * These were taken from PulseAudio's sources but adjusted to directly
  * fit our usage (since we use floats directly) so they should be exact.
  */
-UINT8 mult_alaw_sample(UINT8 sample, float vol)
+static UINT8 mult_alaw_sample(UINT8 sample, float vol)
 {
     static const float decode_to_13bits_float[1 << 8] =
     {
@@ -708,7 +703,7 @@ UINT8 mult_alaw_sample(UINT8 sample, float vol)
     return encode[(int)(vol * decode_to_13bits_float[sample]) + ARRAY_SIZE(encode) / 2];
 }
 
-UINT8 mult_ulaw_sample(UINT8 sample, float vol)
+static UINT8 mult_ulaw_sample(UINT8 sample, float vol)
 {
     static const float decode_to_14bits_float[1 << 8] =
     {
diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 41d988e692b..9446feb452c 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -44,6 +44,8 @@
 
 #include "../mmdevapi/unixlib.h"
 
+#include "mult.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(pulse);
 
 enum phys_device_bus_type {
@@ -117,9 +119,6 @@ static const REFERENCE_TIME DefaultPeriod = 100000;
 static pthread_mutex_t pulse_mutex;
 static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
 
-UINT8 mult_alaw_sample(UINT8, float);
-UINT8 mult_ulaw_sample(UINT8, float);
-
 static void pulse_lock(void)
 {
     pthread_mutex_lock(&pulse_mutex);
diff --git a/dlls/wineusb.sys/wineusb.c b/dlls/wineusb.sys/wineusb.c
index f965241d59e..801393cacf6 100644
--- a/dlls/wineusb.sys/wineusb.c
+++ b/dlls/wineusb.sys/wineusb.c
@@ -331,11 +331,11 @@ struct string_buffer
 
 static void WINAPIV append_id(struct string_buffer *buffer, const WCHAR *format, ...)
 {
-    __ms_va_list args;
+    va_list args;
     WCHAR *string;
     int len;
 
-    __ms_va_start(args, format);
+    va_start(args, format);
 
     len = _vsnwprintf(NULL, 0, format, args) + 1;
     if (!(string = ExAllocatePool(PagedPool, (buffer->len + len) * sizeof(WCHAR))))
@@ -354,7 +354,7 @@ static void WINAPIV append_id(struct string_buffer *buffer, const WCHAR *format,
     buffer->string = string;
     buffer->len += len;
 
-    __ms_va_end(args);
+    va_end(args);
 }
 
 static void get_device_id(const struct usb_device *device, struct string_buffer *buffer)
diff --git a/dlls/winevulkan/loader_thunks.c b/dlls/winevulkan/loader_thunks.c
index 5ccf1df27e2..9cca3f4929b 100644
--- a/dlls/winevulkan/loader_thunks.c
+++ b/dlls/winevulkan/loader_thunks.c
@@ -870,6 +870,25 @@ void WINAPI vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint3
     UNIX_CALL(vkCmdDraw, &params);
 }
 
+void WINAPI vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
+{
+    struct vkCmdDrawClusterHUAWEI_params params;
+    params.commandBuffer = commandBuffer;
+    params.groupCountX = groupCountX;
+    params.groupCountY = groupCountY;
+    params.groupCountZ = groupCountZ;
+    UNIX_CALL(vkCmdDrawClusterHUAWEI, &params);
+}
+
+void WINAPI vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
+{
+    struct vkCmdDrawClusterIndirectHUAWEI_params params;
+    params.commandBuffer = commandBuffer;
+    params.buffer = buffer;
+    params.offset = offset;
+    UNIX_CALL(vkCmdDrawClusterIndirectHUAWEI, &params);
+}
+
 void WINAPI vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
 {
     struct vkCmdDrawIndexed_params params;
@@ -5431,6 +5450,18 @@ VkResult WINAPI vkSetEvent(VkDevice device, VkEvent event)
     return params.result;
 }
 
+void WINAPI vkSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata)
+{
+    struct vkSetHdrMetadataEXT_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.swapchainCount = swapchainCount;
+    params.pSwapchains = pSwapchains;
+    params.pMetadata = pMetadata;
+    status = UNIX_CALL(vkSetHdrMetadataEXT, &params);
+    assert(!status);
+}
+
 VkResult WINAPI vkSetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data)
 {
     struct vkSetPrivateData_params params;
@@ -5735,6 +5766,8 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkCmdDispatchBaseKHR", vkCmdDispatchBaseKHR},
     {"vkCmdDispatchIndirect", vkCmdDispatchIndirect},
     {"vkCmdDraw", vkCmdDraw},
+    {"vkCmdDrawClusterHUAWEI", vkCmdDrawClusterHUAWEI},
+    {"vkCmdDrawClusterIndirectHUAWEI", vkCmdDrawClusterIndirectHUAWEI},
     {"vkCmdDrawIndexed", vkCmdDrawIndexed},
     {"vkCmdDrawIndexedIndirect", vkCmdDrawIndexedIndirect},
     {"vkCmdDrawIndexedIndirectCount", vkCmdDrawIndexedIndirectCount},
@@ -6100,6 +6133,7 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkSetDebugUtilsObjectTagEXT", vkSetDebugUtilsObjectTagEXT},
     {"vkSetDeviceMemoryPriorityEXT", vkSetDeviceMemoryPriorityEXT},
     {"vkSetEvent", vkSetEvent},
+    {"vkSetHdrMetadataEXT", vkSetHdrMetadataEXT},
     {"vkSetPrivateData", vkSetPrivateData},
     {"vkSetPrivateDataEXT", vkSetPrivateDataEXT},
     {"vkSignalSemaphore", vkSignalSemaphore},
diff --git a/dlls/winevulkan/loader_thunks.h b/dlls/winevulkan/loader_thunks.h
index b80a0349329..ef9ada8a3e4 100644
--- a/dlls/winevulkan/loader_thunks.h
+++ b/dlls/winevulkan/loader_thunks.h
@@ -100,6 +100,8 @@ enum unix_call
     unix_vkCmdDispatchBaseKHR,
     unix_vkCmdDispatchIndirect,
     unix_vkCmdDraw,
+    unix_vkCmdDrawClusterHUAWEI,
+    unix_vkCmdDrawClusterIndirectHUAWEI,
     unix_vkCmdDrawIndexed,
     unix_vkCmdDrawIndexedIndirect,
     unix_vkCmdDrawIndexedIndirectCount,
@@ -526,6 +528,7 @@ enum unix_call
     unix_vkSetDebugUtilsObjectTagEXT,
     unix_vkSetDeviceMemoryPriorityEXT,
     unix_vkSetEvent,
+    unix_vkSetHdrMetadataEXT,
     unix_vkSetPrivateData,
     unix_vkSetPrivateDataEXT,
     unix_vkSignalSemaphore,
@@ -1214,6 +1217,21 @@ struct vkCmdDraw_params
     uint32_t firstInstance;
 };
 
+struct vkCmdDrawClusterHUAWEI_params
+{
+    VkCommandBuffer commandBuffer;
+    uint32_t groupCountX;
+    uint32_t groupCountY;
+    uint32_t groupCountZ;
+};
+
+struct vkCmdDrawClusterIndirectHUAWEI_params
+{
+    VkCommandBuffer commandBuffer;
+    VkBuffer DECLSPEC_ALIGN(8) buffer;
+    VkDeviceSize DECLSPEC_ALIGN(8) offset;
+};
+
 struct vkCmdDrawIndexed_params
 {
     VkCommandBuffer commandBuffer;
@@ -4511,6 +4529,14 @@ struct vkSetEvent_params
     VkResult result;
 };
 
+struct vkSetHdrMetadataEXT_params
+{
+    VkDevice device;
+    uint32_t swapchainCount;
+    const VkSwapchainKHR *pSwapchains;
+    const VkHdrMetadataEXT *pMetadata;
+};
+
 struct vkSetPrivateData_params
 {
     VkDevice device;
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 801b804745f..51d938fa8b3 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -65,7 +65,7 @@ from enum import Enum
 LOGGER = logging.Logger("vulkan")
 LOGGER.addHandler(logging.StreamHandler())
 
-VK_XML_VERSION = "1.3.237"
+VK_XML_VERSION = "1.3.240"
 WINE_VK_VERSION = (1, 3)
 
 # Filenames to create.
@@ -97,24 +97,19 @@ UNSUPPORTED_EXTENSIONS = [
     # Device extensions
     "VK_AMD_display_native_hdr",
     "VK_EXT_full_screen_exclusive",
-    "VK_EXT_hdr_metadata", # Needs WSI work.
     "VK_GOOGLE_display_timing",
     "VK_KHR_external_fence_win32",
     "VK_KHR_external_semaphore_win32",
     # Relates to external_semaphore and needs type conversions in bitflags.
     "VK_KHR_shared_presentable_image", # Needs WSI work.
+    "VK_KHR_video_queue", # TODO Video extensions use separate headers + xml
     "VK_KHR_win32_keyed_mutex",
     "VK_NV_external_memory_rdma", # Needs shared resources work.
 
     # Extensions for other platforms
-    "VK_EXT_external_memory_dma_buf",
-    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_objects",
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
-    "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
-    "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
 
     # Extensions which require callback handling
@@ -130,6 +125,11 @@ UNSUPPORTED_EXTENSIONS = [
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
     "VK_KHR_external_memory_win32",
+    "VK_EXT_external_memory_dma_buf",
+    "VK_EXT_image_drm_format_modifier",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory_fd",
+    "VK_KHR_external_semaphore_fd",
 }
 
 # The Vulkan loader provides entry-points for core functionality and important
@@ -189,7 +189,7 @@ FUNCTION_OVERRIDES = {
     "vkGetInstanceProcAddr": {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
 
     # Instance functions
-    "vkCreateDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
+    "vkCreateDevice" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
     "vkDestroyInstance" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkEnumerateDeviceExtensionProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkEnumerateDeviceLayerProperties": {"dispatch": True, "driver": False, "thunk": ThunkType.NONE},
@@ -206,7 +206,7 @@ FUNCTION_OVERRIDES = {
     "vkAllocateCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkCreateCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
-    "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
+    "vkDestroyDevice" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetDeviceProcAddr" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
     "vkGetDeviceQueue" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -234,6 +234,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceWin32PresentationSupportKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
 
     # VK_KHR_swapchain
+    "vkAcquireNextImageKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
@@ -1168,7 +1169,7 @@ class VkVariable(object):
         parent = self.parent
         len = prefix
 
-        # check if lenght is a member of another struct (for example pAllocateInfo->commandBufferCount)
+        # check if length is a member of another struct (for example pAllocateInfo->commandBufferCount)
         i = len_str.find("->")
         if i != -1:
             var = parent[parent.index(len_str[0:i])]
@@ -2392,7 +2393,7 @@ class StructConversionFunction(object):
 
             body += "        default:\n"
             if self.direction == Direction.INPUT:
-                body += ident + "FIXME(\"Unhandled sType %u.\", in_header->sType);\n"
+                body += ident + "FIXME(\"Unhandled sType %u.\\n\", in_header->sType);\n"
             body += "            break;\n"
             body += "        }\n"
             body += "    }\n"
diff --git a/dlls/winevulkan/vulkan_thunks.c b/dlls/winevulkan/vulkan_thunks.c
index 8cf554b6fff..d7345be1449 100644
--- a/dlls/winevulkan/vulkan_thunks.c
+++ b/dlls/winevulkan/vulkan_thunks.c
@@ -108,6 +108,14 @@ typedef struct VkExportMemoryWin32HandleInfoKHR32
     LPCWSTR name;
 } VkExportMemoryWin32HandleInfoKHR32;
 
+typedef struct VkImportMemoryFdInfoKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+} VkImportMemoryFdInfoKHR32;
+
 typedef struct VkMemoryAllocateFlagsInfo32
 {
     VkStructureType sType;
@@ -2402,6 +2410,14 @@ typedef struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32
     VkBool32 subpassShading;
 } VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32;
 
+typedef struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkBool32 clustercullingShader;
+    VkBool32 multiviewClusterCullingShader;
+} VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32;
+
 typedef struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32
 {
     VkStructureType sType;
@@ -2737,6 +2753,13 @@ typedef struct VkPhysicalDeviceFaultFeaturesEXT32
     VkBool32 deviceFaultVendorBinary;
 } VkPhysicalDeviceFaultFeaturesEXT32;
 
+typedef struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkBool32 pipelineLibraryGroupHandles;
+} VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32;
+
 typedef struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32
 {
     VkStructureType sType;
@@ -3216,6 +3239,15 @@ typedef struct VkGraphicsPipelineCreateInfo32
     int32_t basePipelineIndex;
 } VkGraphicsPipelineCreateInfo32;
 
+typedef struct VkSubresourceLayout32
+{
+    VkDeviceSize DECLSPEC_ALIGN(8) offset;
+    VkDeviceSize DECLSPEC_ALIGN(8) size;
+    VkDeviceSize DECLSPEC_ALIGN(8) rowPitch;
+    VkDeviceSize DECLSPEC_ALIGN(8) arrayPitch;
+    VkDeviceSize DECLSPEC_ALIGN(8) depthPitch;
+} VkSubresourceLayout32;
+
 typedef struct VkDedicatedAllocationImageCreateInfoNV32
 {
     VkStructureType sType;
@@ -3247,6 +3279,23 @@ typedef struct VkImageFormatListCreateInfo32
 } VkImageFormatListCreateInfo32;
 typedef VkImageFormatListCreateInfo32 VkImageFormatListCreateInfoKHR32;
 
+typedef struct VkImageDrmFormatModifierListCreateInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t drmFormatModifierCount;
+    PTR32 pDrmFormatModifiers;
+} VkImageDrmFormatModifierListCreateInfoEXT32;
+
+typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    PTR32 pPlaneLayouts;
+} VkImageDrmFormatModifierExplicitCreateInfoEXT32;
+
 typedef struct VkImageStencilUsageCreateInfo32
 {
     VkStructureType sType;
@@ -4277,15 +4326,6 @@ typedef struct VkImageSparseMemoryRequirementsInfo232
 } VkImageSparseMemoryRequirementsInfo232;
 typedef VkImageSparseMemoryRequirementsInfo232 VkImageSparseMemoryRequirementsInfo2KHR32;
 
-typedef struct VkSubresourceLayout32
-{
-    VkDeviceSize DECLSPEC_ALIGN(8) offset;
-    VkDeviceSize DECLSPEC_ALIGN(8) size;
-    VkDeviceSize DECLSPEC_ALIGN(8) rowPitch;
-    VkDeviceSize DECLSPEC_ALIGN(8) arrayPitch;
-    VkDeviceSize DECLSPEC_ALIGN(8) depthPitch;
-} VkSubresourceLayout32;
-
 typedef struct VkImageSubresource2EXT32
 {
     VkStructureType sType;
@@ -4431,6 +4471,28 @@ typedef struct VkExternalSemaphoreProperties32
 } VkExternalSemaphoreProperties32;
 typedef VkExternalSemaphoreProperties32 VkExternalSemaphorePropertiesKHR32;
 
+typedef struct VkDrmFormatModifierPropertiesEXT32
+{
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierPropertiesEXT32;
+
+typedef struct VkDrmFormatModifierProperties2EXT32
+{
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierProperties2EXT32;
+
+typedef struct VkDrmFormatModifierPropertiesListEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t drmFormatModifierCount;
+    PTR32 pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesListEXT32;
+
 typedef struct VkSubpassResolvePerformanceQueryEXT32
 {
     VkStructureType sType;
@@ -4448,6 +4510,14 @@ typedef struct VkFormatProperties332
 } VkFormatProperties332;
 typedef VkFormatProperties332 VkFormatProperties3KHR32;
 
+typedef struct VkDrmFormatModifierPropertiesList2EXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t drmFormatModifierCount;
+    PTR32 pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesList2EXT32;
+
 typedef struct VkFormatProperties232
 {
     VkStructureType sType;
@@ -4481,6 +4551,16 @@ typedef struct VkPhysicalDeviceExternalImageFormatInfo32
 } VkPhysicalDeviceExternalImageFormatInfo32;
 typedef VkPhysicalDeviceExternalImageFormatInfo32 VkPhysicalDeviceExternalImageFormatInfoKHR32;
 
+typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    VkSharingMode sharingMode;
+    uint32_t queueFamilyIndexCount;
+    PTR32 pQueueFamilyIndices;
+} VkPhysicalDeviceImageDrmFormatModifierInfoEXT32;
+
 typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT32
 {
     VkStructureType sType;
@@ -5212,6 +5292,15 @@ typedef struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32
     uint32_t maxSubpassShadingWorkgroupSizeAspectRatio;
 } VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32;
 
+typedef struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t maxWorkGroupCount[3];
+    uint32_t maxWorkGroupSize[3];
+    uint32_t maxOutputClusterCount;
+} VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32;
+
 typedef struct VkPhysicalDeviceLineRasterizationPropertiesEXT32
 {
     VkStructureType sType;
@@ -6033,6 +6122,20 @@ typedef struct VkDebugUtilsObjectTagInfoEXT32
     PTR32 pTag;
 } VkDebugUtilsObjectTagInfoEXT32;
 
+typedef struct VkHdrMetadataEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkXYColorEXT displayPrimaryRed;
+    VkXYColorEXT displayPrimaryGreen;
+    VkXYColorEXT displayPrimaryBlue;
+    VkXYColorEXT whitePoint;
+    float maxLuminance;
+    float minLuminance;
+    float maxContentLightLevel;
+    float maxFrameAverageLightLevel;
+} VkHdrMetadataEXT32;
+
 typedef struct VkSemaphoreSignalInfo32
 {
     VkStructureType sType;
@@ -6218,7 +6321,7 @@ static inline void convert_VkDescriptorSetAllocateInfo_win32_to_host(struct conv
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -6289,6 +6392,18 @@ static inline void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
+        {
+            VkImportMemoryFdInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImportMemoryFdInfoKHR32 *in_ext = (const VkImportMemoryFdInfoKHR32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+            out_ext->pNext = NULL;
+            out_ext->handleType = in_ext->handleType;
+            out_ext->fd = in_ext->fd;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
         {
             VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -6348,7 +6463,7 @@ static inline void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -6453,7 +6568,7 @@ static inline void convert_VkCommandBufferInheritanceInfo_win32_to_host(struct c
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -6503,7 +6618,7 @@ static inline void convert_VkCommandBufferBeginInfo_win32_to_host(struct convers
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -6616,7 +6731,7 @@ static inline void convert_VkBindBufferMemoryInfo_win32_to_host(struct conversio
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -6724,7 +6839,7 @@ static inline void convert_VkBindImageMemoryInfo_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -6831,7 +6946,7 @@ static inline void convert_VkAccelerationStructureGeometryTrianglesDataKHR_win32
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -7153,7 +7268,7 @@ static inline void convert_VkRenderPassBeginInfo_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -7289,7 +7404,7 @@ static inline void convert_VkRenderingInfo_win32_to_host(struct conversion_conte
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -7323,7 +7438,7 @@ static inline void convert_VkDescriptorBufferBindingInfoEXT_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -7375,7 +7490,7 @@ static inline void convert_VkImageBlit2_win32_to_host(struct conversion_context
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -7655,7 +7770,7 @@ static inline void convert_VkBufferImageCopy2_win32_to_host(struct conversion_co
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -7894,7 +8009,7 @@ static inline void convert_VkSubpassEndInfo_win32_to_host(struct conversion_cont
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8092,7 +8207,7 @@ static inline void convert_VkImageMemoryBarrier_win32_to_host(struct conversion_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8218,7 +8333,7 @@ static inline void convert_VkImageMemoryBarrier2_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8366,7 +8481,7 @@ static inline void convert_VkWriteDescriptorSet_win32_to_host(struct conversion_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8649,7 +8764,7 @@ static inline void convert_VkAccelerationStructureCreateInfoKHR_win32_to_host(st
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8683,7 +8798,7 @@ static inline void convert_VkAccelerationStructureCreateInfoNV_win32_to_host(str
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8765,7 +8880,7 @@ static inline void convert_VkBufferCreateInfo_win32_to_host(struct conversion_co
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -8974,7 +9089,7 @@ static inline void convert_VkPipelineShaderStageCreateInfo_win64_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -9075,7 +9190,7 @@ static inline void convert_VkPipelineShaderStageCreateInfo_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -9166,7 +9281,7 @@ static inline void convert_VkComputePipelineCreateInfo_win32_to_host(struct conv
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -9364,7 +9479,7 @@ static inline void convert_VkDescriptorPoolCreateInfo_win32_to_host(struct conve
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -9439,7 +9554,7 @@ static inline void convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -9555,7 +9670,7 @@ static inline void convert_VkDeviceQueueCreateInfo_win32_to_host(struct conversi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -10888,6 +11003,18 @@ static inline void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
+        {
+            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
+            out_ext->pNext = NULL;
+            out_ext->clustercullingShader = in_ext->clustercullingShader;
+            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
         {
             VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -11392,6 +11519,17 @@ static inline void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
+        {
+            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
         {
             VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -11437,7 +11575,7 @@ static inline void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_co
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -12738,6 +12876,18 @@ static inline void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
+        {
+            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
+            out_ext->pNext = NULL;
+            out_ext->clustercullingShader = in_ext->clustercullingShader;
+            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
         {
             VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -13242,6 +13392,17 @@ static inline void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_co
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
+        {
+            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
         {
             VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -13287,7 +13448,7 @@ static inline void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_co
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13331,7 +13492,7 @@ static inline void convert_VkFenceCreateInfo_win32_to_host(struct conversion_con
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13404,7 +13565,7 @@ static inline void convert_VkFramebufferCreateInfo_win32_to_host(struct conversi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13476,7 +13637,7 @@ static inline void convert_VkPipelineVertexInputStateCreateInfo_win32_to_host(st
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13526,7 +13687,7 @@ static inline void convert_VkPipelineTessellationStateCreateInfo_win32_to_host(s
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13734,7 +13895,7 @@ static inline void convert_VkPipelineViewportStateCreateInfo_win32_to_host(struc
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13855,7 +14016,7 @@ static inline void convert_VkPipelineRasterizationStateCreateInfo_win32_to_host(
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -13951,7 +14112,7 @@ static inline void convert_VkPipelineMultisampleStateCreateInfo_win32_to_host(st
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -14055,7 +14216,7 @@ static inline void convert_VkPipelineColorBlendStateCreateInfo_win32_to_host(str
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -14304,7 +14465,7 @@ static inline void convert_VkGraphicsPipelineCreateInfo_win64_to_host(struct con
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -14508,7 +14669,7 @@ static inline void convert_VkGraphicsPipelineCreateInfo_win32_to_host(struct con
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -14588,6 +14749,33 @@ static inline void convert_VkGraphicsPipelineCreateInfo_array_host_to_win32(cons
     }
 }
 
+static inline void convert_VkSubresourceLayout_win32_to_host(const VkSubresourceLayout32 *in, VkSubresourceLayout *out)
+{
+    if (!in) return;
+
+    out->offset = in->offset;
+    out->size = in->size;
+    out->rowPitch = in->rowPitch;
+    out->arrayPitch = in->arrayPitch;
+    out->depthPitch = in->depthPitch;
+}
+
+static inline const VkSubresourceLayout *convert_VkSubresourceLayout_array_win32_to_host(struct conversion_context *ctx, const VkSubresourceLayout32 *in, uint32_t count)
+{
+    VkSubresourceLayout *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkSubresourceLayout_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
 static inline void convert_VkImageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, VkImageCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -14660,6 +14848,31 @@ static inline void convert_VkImageCreateInfo_win32_to_host(struct conversion_con
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
+        {
+            VkImageDrmFormatModifierListCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImageDrmFormatModifierListCreateInfoEXT32 *in_ext = (const VkImageDrmFormatModifierListCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->drmFormatModifierCount = in_ext->drmFormatModifierCount;
+            out_ext->pDrmFormatModifiers = (const uint64_t *)UlongToPtr(in_ext->pDrmFormatModifiers);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
+        {
+            VkImageDrmFormatModifierExplicitCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImageDrmFormatModifierExplicitCreateInfoEXT32 *in_ext = (const VkImageDrmFormatModifierExplicitCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->drmFormatModifier = in_ext->drmFormatModifier;
+            out_ext->drmFormatModifierPlaneCount = in_ext->drmFormatModifierPlaneCount;
+            out_ext->pPlaneLayouts = convert_VkSubresourceLayout_array_win32_to_host(ctx, (const VkSubresourceLayout32 *)UlongToPtr(in_ext->pPlaneLayouts), in_ext->drmFormatModifierPlaneCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
         {
             VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -14707,7 +14920,7 @@ static inline void convert_VkImageCreateInfo_win32_to_host(struct conversion_con
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -14802,7 +15015,7 @@ static inline void convert_VkImageViewCreateInfo_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -14972,7 +15185,7 @@ static inline void convert_VkInstanceCreateInfo_win64_to_host(struct conversion_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15056,7 +15269,7 @@ static inline void convert_VkInstanceCreateInfo_win32_to_host(struct conversion_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15115,7 +15328,7 @@ static inline void convert_VkOpticalFlowSessionCreateInfoNV_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15203,7 +15416,7 @@ static inline void convert_VkQueryPoolCreateInfo_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15373,7 +15586,7 @@ static inline void convert_VkRayTracingPipelineCreateInfoKHR_win32_to_host(struc
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15540,7 +15753,7 @@ static inline void convert_VkRayTracingPipelineCreateInfoNV_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15713,7 +15926,7 @@ static inline void convert_VkRenderPassCreateInfo_win32_to_host(struct conversio
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15755,7 +15968,7 @@ static inline void convert_VkAttachmentDescription2_win32_to_host(struct convers
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15806,7 +16019,7 @@ static inline void convert_VkAttachmentReference2_win32_to_host(struct conversio
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15913,7 +16126,7 @@ static inline void convert_VkSubpassDescription2_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -15972,7 +16185,7 @@ static inline void convert_VkSubpassDependency2_win32_to_host(struct conversion_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -16051,7 +16264,7 @@ static inline void convert_VkRenderPassCreateInfo2_win32_to_host(struct conversi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -16145,7 +16358,7 @@ static inline void convert_VkSamplerCreateInfo_win32_to_host(struct conversion_c
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -16208,7 +16421,7 @@ static inline void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -16243,7 +16456,7 @@ static inline void convert_VkShaderModuleCreateInfo_win32_to_host(struct convers
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -16378,7 +16591,7 @@ static inline void convert_VkSwapchainCreateInfoKHR_win32_to_host(struct convers
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -16810,7 +17023,7 @@ static inline void convert_VkMemoryRequirements2_win32_to_host(struct conversion
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -17006,7 +17219,7 @@ static inline void convert_VkDescriptorSetLayoutSupport_win32_to_host(struct con
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -17455,7 +17668,7 @@ static inline void convert_VkImageMemoryRequirementsInfo2_win32_to_host(struct c
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -17495,17 +17708,6 @@ static inline void convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host(co
         FIXME("Unexpected pNext\n");
 }
 
-static inline void convert_VkSubresourceLayout_win32_to_host(const VkSubresourceLayout32 *in, VkSubresourceLayout *out)
-{
-    if (!in) return;
-
-    out->offset = in->offset;
-    out->size = in->size;
-    out->rowPitch = in->rowPitch;
-    out->arrayPitch = in->arrayPitch;
-    out->depthPitch = in->depthPitch;
-}
-
 static inline void convert_VkSubresourceLayout_host_to_win32(const VkSubresourceLayout *in, VkSubresourceLayout32 *out)
 {
     if (!in) return;
@@ -17552,7 +17754,7 @@ static inline void convert_VkSubresourceLayout2EXT_win32_to_host(struct conversi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -17846,7 +18048,7 @@ static inline void convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(s
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -19100,6 +19302,18 @@ static inline void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conver
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
+        {
+            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
+            out_ext->pNext = NULL;
+            out_ext->clustercullingShader = in_ext->clustercullingShader;
+            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
         {
             VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -19604,6 +19818,17 @@ static inline void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conver
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
+        {
+            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
         {
             VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -19649,7 +19874,7 @@ static inline void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conver
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -20698,6 +20923,16 @@ static inline void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
+        {
+            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI);
+            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
+            out_ext->clustercullingShader = in_ext->clustercullingShader;
+            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
         {
             VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT);
@@ -21114,6 +21349,15 @@ static inline void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysi
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
+        {
+            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT);
+            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
+            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
         {
             VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM);
@@ -21156,6 +21400,68 @@ static inline void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysi
     }
 }
 
+static inline void convert_VkDrmFormatModifierPropertiesEXT_host_to_win32(const VkDrmFormatModifierPropertiesEXT *in, VkDrmFormatModifierPropertiesEXT32 *out)
+{
+    if (!in) return;
+
+    out->drmFormatModifier = in->drmFormatModifier;
+    out->drmFormatModifierPlaneCount = in->drmFormatModifierPlaneCount;
+    out->drmFormatModifierTilingFeatures = in->drmFormatModifierTilingFeatures;
+}
+
+static inline VkDrmFormatModifierPropertiesEXT *convert_VkDrmFormatModifierPropertiesEXT_array_win32_to_host(struct conversion_context *ctx, const VkDrmFormatModifierPropertiesEXT32 *in, uint32_t count)
+{
+    VkDrmFormatModifierPropertiesEXT *out;
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+
+    return out;
+}
+
+static inline void convert_VkDrmFormatModifierPropertiesEXT_array_host_to_win32(const VkDrmFormatModifierPropertiesEXT *in, VkDrmFormatModifierPropertiesEXT32 *out, uint32_t count)
+{
+    unsigned int i;
+
+    if (!in) return;
+
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDrmFormatModifierPropertiesEXT_host_to_win32(&in[i], &out[i]);
+    }
+}
+
+static inline void convert_VkDrmFormatModifierProperties2EXT_host_to_win32(const VkDrmFormatModifierProperties2EXT *in, VkDrmFormatModifierProperties2EXT32 *out)
+{
+    if (!in) return;
+
+    out->drmFormatModifier = in->drmFormatModifier;
+    out->drmFormatModifierPlaneCount = in->drmFormatModifierPlaneCount;
+    out->drmFormatModifierTilingFeatures = in->drmFormatModifierTilingFeatures;
+}
+
+static inline VkDrmFormatModifierProperties2EXT *convert_VkDrmFormatModifierProperties2EXT_array_win32_to_host(struct conversion_context *ctx, const VkDrmFormatModifierProperties2EXT32 *in, uint32_t count)
+{
+    VkDrmFormatModifierProperties2EXT *out;
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+
+    return out;
+}
+
+static inline void convert_VkDrmFormatModifierProperties2EXT_array_host_to_win32(const VkDrmFormatModifierProperties2EXT *in, VkDrmFormatModifierProperties2EXT32 *out, uint32_t count)
+{
+    unsigned int i;
+
+    if (!in) return;
+
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDrmFormatModifierProperties2EXT_host_to_win32(&in[i], &out[i]);
+    }
+}
+
 static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_context *ctx, const VkFormatProperties232 *in, VkFormatProperties2 *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -21170,6 +21476,17 @@ static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_c
     {
         switch (in_header->sType)
         {
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
+        {
+            VkDrmFormatModifierPropertiesListEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDrmFormatModifierPropertiesListEXT32 *in_ext = (const VkDrmFormatModifierPropertiesListEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pDrmFormatModifierProperties = convert_VkDrmFormatModifierPropertiesEXT_array_win32_to_host(ctx, (VkDrmFormatModifierPropertiesEXT32 *)UlongToPtr(in_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
         {
             VkSubpassResolvePerformanceQueryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -21188,8 +21505,19 @@ static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_c
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
+        {
+            VkDrmFormatModifierPropertiesList2EXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDrmFormatModifierPropertiesList2EXT32 *in_ext = (const VkDrmFormatModifierPropertiesList2EXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pDrmFormatModifierProperties = convert_VkDrmFormatModifierProperties2EXT_array_win32_to_host(ctx, (VkDrmFormatModifierProperties2EXT32 *)UlongToPtr(in_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -21208,6 +21536,16 @@ static inline void convert_VkFormatProperties2_host_to_win32(const VkFormatPrope
     {
         switch (in_header->sType)
         {
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
+        {
+            VkDrmFormatModifierPropertiesListEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT);
+            const VkDrmFormatModifierPropertiesListEXT *in_ext = (const VkDrmFormatModifierPropertiesListEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
+            out_ext->drmFormatModifierCount = in_ext->drmFormatModifierCount;
+            convert_VkDrmFormatModifierPropertiesEXT_array_host_to_win32(in_ext->pDrmFormatModifierProperties, (VkDrmFormatModifierPropertiesEXT32 *)UlongToPtr(out_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
         {
             VkSubpassResolvePerformanceQueryEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT);
@@ -21228,6 +21566,16 @@ static inline void convert_VkFormatProperties2_host_to_win32(const VkFormatPrope
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
+        {
+            VkDrmFormatModifierPropertiesList2EXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT);
+            const VkDrmFormatModifierPropertiesList2EXT *in_ext = (const VkDrmFormatModifierPropertiesList2EXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
+            out_ext->drmFormatModifierCount = in_ext->drmFormatModifierCount;
+            convert_VkDrmFormatModifierProperties2EXT_array_host_to_win32(in_ext->pDrmFormatModifierProperties, (VkDrmFormatModifierProperties2EXT32 *)UlongToPtr(out_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header = (void *)out_ext;
+            break;
+        }
         default:
             break;
         }
@@ -21333,6 +21681,20 @@ static inline void convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(struct
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
+        {
+            VkPhysicalDeviceImageDrmFormatModifierInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceImageDrmFormatModifierInfoEXT32 *in_ext = (const VkPhysicalDeviceImageDrmFormatModifierInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->drmFormatModifier = in_ext->drmFormatModifier;
+            out_ext->sharingMode = in_ext->sharingMode;
+            out_ext->queueFamilyIndexCount = in_ext->queueFamilyIndexCount;
+            out_ext->pQueueFamilyIndices = (const uint32_t *)UlongToPtr(in_ext->pQueueFamilyIndices);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
         {
             VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -21380,7 +21742,7 @@ static inline void convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -21446,7 +21808,7 @@ static inline void convert_VkImageFormatProperties2_win32_to_host(struct convers
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -21572,7 +21934,7 @@ static inline void convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(struc
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -22217,6 +22579,15 @@ static inline void convert_VkPhysicalDeviceProperties2_win32_to_host(struct conv
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
+        {
+            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
+            out_ext->pNext = NULL;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
         {
             VkPhysicalDeviceLineRasterizationPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -22423,7 +22794,7 @@ static inline void convert_VkPhysicalDeviceProperties2_win32_to_host(struct conv
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -23022,6 +23393,17 @@ static inline void convert_VkPhysicalDeviceProperties2_host_to_win32(const VkPhy
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
+        {
+            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI);
+            const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
+            memcpy(out_ext->maxWorkGroupCount, in_ext->maxWorkGroupCount, 3 * sizeof(uint32_t));
+            memcpy(out_ext->maxWorkGroupSize, in_ext->maxWorkGroupSize, 3 * sizeof(uint32_t));
+            out_ext->maxOutputClusterCount = in_ext->maxOutputClusterCount;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
         {
             VkPhysicalDeviceLineRasterizationPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT);
@@ -23492,7 +23874,7 @@ static inline void convert_VkQueueFamilyProperties2_win32_to_host(struct convers
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -23708,7 +24090,7 @@ static inline void convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_unwrapped_ho
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -23765,7 +24147,7 @@ static inline void convert_VkSurfaceCapabilities2KHR_win32_to_host(struct conver
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -23860,7 +24242,7 @@ static inline void convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_host(struct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -23890,7 +24272,7 @@ static inline void convert_VkSurfaceFormat2KHR_win32_to_host(struct conversion_c
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -24678,7 +25060,7 @@ static inline void convert_VkBindSparseInfo_win32_to_host(struct conversion_cont
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -24824,7 +25206,7 @@ static inline void convert_VkPresentInfoKHR_win32_to_host(struct conversion_cont
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -24921,7 +25303,7 @@ static inline void convert_VkSubmitInfo_win32_to_host(struct conversion_context
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -25099,7 +25481,7 @@ static inline void convert_VkSubmitInfo2_win32_to_host(struct conversion_context
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -25208,6 +25590,40 @@ static inline void convert_VkDebugUtilsObjectTagInfoEXT_win32_to_host(const VkDe
         FIXME("Unexpected pNext\n");
 }
 
+static inline void convert_VkHdrMetadataEXT_win32_to_host(const VkHdrMetadataEXT32 *in, VkHdrMetadataEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->displayPrimaryRed = in->displayPrimaryRed;
+    out->displayPrimaryGreen = in->displayPrimaryGreen;
+    out->displayPrimaryBlue = in->displayPrimaryBlue;
+    out->whitePoint = in->whitePoint;
+    out->maxLuminance = in->maxLuminance;
+    out->minLuminance = in->minLuminance;
+    out->maxContentLightLevel = in->maxContentLightLevel;
+    out->maxFrameAverageLightLevel = in->maxFrameAverageLightLevel;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
+static inline const VkHdrMetadataEXT *convert_VkHdrMetadataEXT_array_win32_to_host(struct conversion_context *ctx, const VkHdrMetadataEXT32 *in, uint32_t count)
+{
+    VkHdrMetadataEXT *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkHdrMetadataEXT_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
 static inline void convert_VkSemaphoreSignalInfo_win32_to_host(const VkSemaphoreSignalInfo32 *in, VkSemaphoreSignalInfo *out)
 {
     if (!in) return;
@@ -25329,7 +25745,7 @@ static inline void convert_VkDebugUtilsMessengerCallbackDataEXT_win32_to_host(st
             break;
         }
         default:
-            FIXME("Unhandled sType %u.", in_header->sType);
+            FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
         }
     }
@@ -27553,6 +27969,49 @@ static void thunk32_vkCmdDraw(void *args)
     wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDraw(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
 }
 
+#ifdef _WIN64
+static void thunk64_vkCmdDrawClusterHUAWEI(void *args)
+{
+    struct vkCmdDrawClusterHUAWEI_params *params = args;
+
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkCmdDrawClusterHUAWEI(void *args)
+{
+    struct
+    {
+        PTR32 commandBuffer;
+        uint32_t groupCountX;
+        uint32_t groupCountY;
+        uint32_t groupCountZ;
+    } *params = args;
+
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+}
+
+#ifdef _WIN64
+static void thunk64_vkCmdDrawClusterIndirectHUAWEI(void *args)
+{
+    struct vkCmdDrawClusterIndirectHUAWEI_params *params = args;
+
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->funcs.p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->command_buffer, params->buffer, params->offset);
+}
+#endif /* _WIN64 */
+
+static void thunk32_vkCmdDrawClusterIndirectHUAWEI(void *args)
+{
+    struct
+    {
+        PTR32 commandBuffer;
+        VkBuffer DECLSPEC_ALIGN(8) buffer;
+        VkDeviceSize DECLSPEC_ALIGN(8) offset;
+    } *params = args;
+
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->funcs.p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->command_buffer, params->buffer, params->offset);
+}
+
 #ifdef _WIN64
 static void thunk64_vkCmdDrawIndexed(void *args)
 {
@@ -39446,6 +39905,39 @@ static NTSTATUS thunk32_vkSetEvent(void *args)
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_vkSetHdrMetadataEXT(void *args)
+{
+    struct vkSetHdrMetadataEXT_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->device, params->swapchainCount, params->pSwapchains, params->pMetadata);
+
+    wine_device_from_handle(params->device)->funcs.p_vkSetHdrMetadataEXT(wine_device_from_handle(params->device)->device, params->swapchainCount, params->pSwapchains, params->pMetadata);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkSetHdrMetadataEXT(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        uint32_t swapchainCount;
+        PTR32 pSwapchains;
+        PTR32 pMetadata;
+    } *params = args;
+    const VkHdrMetadataEXT *pMetadata_host;
+    struct conversion_context ctx;
+
+    TRACE("%#x, %u, %#x, %#x\n", params->device, params->swapchainCount, params->pSwapchains, params->pMetadata);
+
+    init_conversion_context(&ctx);
+    pMetadata_host = convert_VkHdrMetadataEXT_array_win32_to_host(&ctx, (const VkHdrMetadataEXT32 *)UlongToPtr(params->pMetadata), params->swapchainCount);
+    wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkSetHdrMetadataEXT(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->swapchainCount, (const VkSwapchainKHR *)UlongToPtr(params->pSwapchains), pMetadata_host);
+    free_conversion_context(&ctx);
+    return STATUS_SUCCESS;
+}
+
 #ifdef _WIN64
 static NTSTATUS thunk64_vkSetPrivateData(void *args)
 {
@@ -40027,6 +40519,7 @@ static const char * const vk_device_extensions[] =
     "VK_EXT_global_priority",
     "VK_EXT_global_priority_query",
     "VK_EXT_graphics_pipeline_library",
+    "VK_EXT_hdr_metadata",
     "VK_EXT_host_query_reset",
     "VK_EXT_image_2d_view_of_3d",
     "VK_EXT_image_compression_control",
@@ -40050,6 +40543,7 @@ static const char * const vk_device_extensions[] =
     "VK_EXT_pci_bus_info",
     "VK_EXT_pipeline_creation_cache_control",
     "VK_EXT_pipeline_creation_feedback",
+    "VK_EXT_pipeline_library_group_handles",
     "VK_EXT_pipeline_properties",
     "VK_EXT_pipeline_protected_access",
     "VK_EXT_pipeline_robustness",
@@ -40090,6 +40584,7 @@ static const char * const vk_device_extensions[] =
     "VK_GOOGLE_decorate_string",
     "VK_GOOGLE_hlsl_functionality1",
     "VK_GOOGLE_user_type",
+    "VK_HUAWEI_cluster_culling_shader",
     "VK_HUAWEI_invocation_mask",
     "VK_HUAWEI_subpass_shading",
     "VK_IMG_filter_cubic",
@@ -40357,6 +40852,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     (void *)thunk64_vkCmdDispatchBaseKHR,
     (void *)thunk64_vkCmdDispatchIndirect,
     (void *)thunk64_vkCmdDraw,
+    (void *)thunk64_vkCmdDrawClusterHUAWEI,
+    (void *)thunk64_vkCmdDrawClusterIndirectHUAWEI,
     (void *)thunk64_vkCmdDrawIndexed,
     (void *)thunk64_vkCmdDrawIndexedIndirect,
     (void *)thunk64_vkCmdDrawIndexedIndirectCount,
@@ -40783,6 +41280,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkSetDebugUtilsObjectTagEXT,
     thunk64_vkSetDeviceMemoryPriorityEXT,
     thunk64_vkSetEvent,
+    thunk64_vkSetHdrMetadataEXT,
     thunk64_vkSetPrivateData,
     thunk64_vkSetPrivateDataEXT,
     thunk64_vkSignalSemaphore,
@@ -40898,6 +41396,8 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     (void *)thunk32_vkCmdDispatchBaseKHR,
     (void *)thunk32_vkCmdDispatchIndirect,
     (void *)thunk32_vkCmdDraw,
+    (void *)thunk32_vkCmdDrawClusterHUAWEI,
+    (void *)thunk32_vkCmdDrawClusterIndirectHUAWEI,
     (void *)thunk32_vkCmdDrawIndexed,
     (void *)thunk32_vkCmdDrawIndexedIndirect,
     (void *)thunk32_vkCmdDrawIndexedIndirectCount,
@@ -41324,6 +41824,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkSetDebugUtilsObjectTagEXT,
     thunk32_vkSetDeviceMemoryPriorityEXT,
     thunk32_vkSetEvent,
+    thunk32_vkSetHdrMetadataEXT,
     thunk32_vkSetPrivateData,
     thunk32_vkSetPrivateDataEXT,
     thunk32_vkSignalSemaphore,
diff --git a/dlls/winevulkan/vulkan_thunks.h b/dlls/winevulkan/vulkan_thunks.h
index b31cf348e1c..d7138af239f 100644
--- a/dlls/winevulkan/vulkan_thunks.h
+++ b/dlls/winevulkan/vulkan_thunks.h
@@ -143,6 +143,8 @@ struct vulkan_device_funcs
     void (*p_vkCmdDispatchBaseKHR)(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);
     void (*p_vkCmdDispatchIndirect)(VkCommandBuffer, VkBuffer, VkDeviceSize);
     void (*p_vkCmdDraw)(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t);
+    void (*p_vkCmdDrawClusterHUAWEI)(VkCommandBuffer, uint32_t, uint32_t, uint32_t);
+    void (*p_vkCmdDrawClusterIndirectHUAWEI)(VkCommandBuffer, VkBuffer, VkDeviceSize);
     void (*p_vkCmdDrawIndexed)(VkCommandBuffer, uint32_t, uint32_t, uint32_t, int32_t, uint32_t);
     void (*p_vkCmdDrawIndexedIndirect)(VkCommandBuffer, VkBuffer, VkDeviceSize, uint32_t, uint32_t);
     void (*p_vkCmdDrawIndexedIndirectCount)(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t);
@@ -507,6 +509,7 @@ struct vulkan_device_funcs
     VkResult (*p_vkSetDebugUtilsObjectTagEXT)(VkDevice, const VkDebugUtilsObjectTagInfoEXT *);
     void (*p_vkSetDeviceMemoryPriorityEXT)(VkDevice, VkDeviceMemory, float);
     VkResult (*p_vkSetEvent)(VkDevice, VkEvent);
+    void (*p_vkSetHdrMetadataEXT)(VkDevice, uint32_t, const VkSwapchainKHR *, const VkHdrMetadataEXT *);
     VkResult (*p_vkSetPrivateData)(VkDevice, VkObjectType, uint64_t, VkPrivateDataSlot, uint64_t);
     VkResult (*p_vkSetPrivateDataEXT)(VkDevice, VkObjectType, uint64_t, VkPrivateDataSlot, uint64_t);
     VkResult (*p_vkSignalSemaphore)(VkDevice, const VkSemaphoreSignalInfo *);
@@ -668,6 +671,8 @@ struct vulkan_instance_funcs
     USE_VK_FUNC(vkCmdDispatchBaseKHR) \
     USE_VK_FUNC(vkCmdDispatchIndirect) \
     USE_VK_FUNC(vkCmdDraw) \
+    USE_VK_FUNC(vkCmdDrawClusterHUAWEI) \
+    USE_VK_FUNC(vkCmdDrawClusterIndirectHUAWEI) \
     USE_VK_FUNC(vkCmdDrawIndexed) \
     USE_VK_FUNC(vkCmdDrawIndexedIndirect) \
     USE_VK_FUNC(vkCmdDrawIndexedIndirectCount) \
@@ -1032,6 +1037,7 @@ struct vulkan_instance_funcs
     USE_VK_FUNC(vkSetDebugUtilsObjectTagEXT) \
     USE_VK_FUNC(vkSetDeviceMemoryPriorityEXT) \
     USE_VK_FUNC(vkSetEvent) \
+    USE_VK_FUNC(vkSetHdrMetadataEXT) \
     USE_VK_FUNC(vkSetPrivateData) \
     USE_VK_FUNC(vkSetPrivateDataEXT) \
     USE_VK_FUNC(vkSignalSemaphore) \
diff --git a/dlls/winevulkan/winevulkan.json b/dlls/winevulkan/winevulkan.json
index d8c8c29fded..59cdf0d2611 100644
--- a/dlls/winevulkan/winevulkan.json
+++ b/dlls/winevulkan/winevulkan.json
@@ -2,6 +2,6 @@
     "file_format_version": "1.0.0",
     "ICD": {
         "library_path": ".\\winevulkan.dll",
-        "api_version": "1.3.237"
+        "api_version": "1.3.240"
     }
 }
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
new file mode 100644
index 00000000000..7551d44f67e
--- /dev/null
+++ b/dlls/winewayland.drv/Makefile.in
@@ -0,0 +1,53 @@
+MODULE = winewayland.drv
+UNIXLIB = winewayland.so
+IMPORTS = gdi32 user32 uuid
+DELAYIMPORTS = comctl32 ole32 shell32
+UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
+              $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
+UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
+            $(XKBCOMMON_LIBS) $(GBM_LIBS) $(UDEV_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
+
+C_SRCS = \
+	display.c \
+	dllmain.c \
+	dump_pixels.c \
+	gbm.c \
+	gdi.c \
+	opengl.c \
+	options.c \
+	registry.c \
+	systray.c \
+	unicode.c \
+	vulkan.c \
+	vulkan_remote.c \
+	wayland.c \
+	wayland_buffer_queue.c \
+	wayland_cursor.c \
+	wayland_data_device.c \
+	wayland_data_device_dll.c \
+	wayland_data_device_format.c \
+	wayland_dmabuf.c \
+	wayland_keyboard.c \
+	wayland_keyboard_layout.c \
+	wayland_mutex.c \
+	wayland_native_buffer.c \
+	wayland_output.c \
+	wayland_pointer.c \
+	wayland_remote.c \
+	wayland_shm.c \
+	wayland_shmfd.c \
+	wayland_surface.c \
+	waylanddrv_main.c \
+	window.c \
+	window_surface.c \
+	xkb_util.c \
+
+WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
+
+RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..e6cdece0ff0
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,412 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+#define NEXT_DEVMODEW(mode) ((DEVMODEW *)((char *)((mode) + 1) + (mode)->dmDriverExtra))
+
+static BOOL force_display_devices_refresh;
+
+static void wayland_refresh_display_devices(void)
+{
+    UINT32 num_path, num_mode;
+    force_display_devices_refresh = TRUE;
+    /* Trigger refresh in win32u */
+    NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
+}
+
+static void wayland_resize_desktop_window(void)
+{
+    BOOL wayland_initialized = wayland_process_acquire()->initialized;
+    wayland_process_release();
+
+    /* During process wayland initialization we will get our initial output
+     * information and init the display devices. There is no need to resize the
+     * desktop in this case, since this is the initial display state.
+     * Additionally, initialization may occur in a context that has acquired
+     * the internal Wine user32 lock, and sending messages would lead to an
+     * internal user32 lock error. */
+    if (wayland_initialized)
+        send_message(NtUserGetDesktopWindow(), WM_DISPLAYCHANGE, 0, 0);
+}
+
+/* Initialize registry display settings when new display devices are added */
+static void wayland_init_registry_display_settings(void)
+{
+    DEVMODEW dm = {.dmSize = sizeof(dm)};
+    DISPLAY_DEVICEW dd = {sizeof(dd)};
+    UNICODE_STRING device_name;
+    DWORD i = 0;
+    int ret;
+
+    while (!NtUserEnumDisplayDevices(NULL, i++, &dd, 0))
+    {
+        RtlInitUnicodeString(&device_name, dd.DeviceName);
+
+        /* Skip if the device already has registry display settings */
+        if (NtUserEnumDisplaySettings(&device_name, ENUM_REGISTRY_SETTINGS, &dm, 0))
+            continue;
+
+        if (!NtUserEnumDisplaySettings(&device_name, ENUM_CURRENT_SETTINGS, &dm, 0))
+        {
+            ERR("Failed to query current display settings for %s.\n", wine_dbgstr_w(dd.DeviceName));
+            continue;
+        }
+
+        TRACE("Device %s current display mode %ux%u %ubits %uHz at %d,%d.\n",
+              wine_dbgstr_w(dd.DeviceName), (UINT)dm.dmPelsWidth, (UINT)dm.dmPelsHeight,
+              (UINT)dm.dmBitsPerPel, (UINT)dm.dmDisplayFrequency, (int)dm.dmPosition.x,
+              (int)dm.dmPosition.y);
+
+        ret = NtUserChangeDisplaySettings(&device_name, &dm, NULL,
+                                          CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL);
+        if (ret != DISP_CHANGE_SUCCESSFUL)
+        {
+            ERR("Failed to save registry display settings for %s, returned %d.\n",
+                wine_dbgstr_w(dd.DeviceName), ret);
+        }
+    }
+}
+
+void wayland_init_display_devices()
+{
+    wayland_refresh_display_devices();
+    wayland_notify_wine_monitor_change();
+    wayland_init_registry_display_settings();
+    wayland_resize_desktop_window();
+}
+
+static void wayland_add_device_gpu(const struct gdi_device_manager *device_manager,
+                                   void *param)
+{
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    struct gdi_gpu gpu = {0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    /* TODO: Fill in gpu information from vulkan. */
+
+    TRACE("id=0x%s name=%s\n",
+          wine_dbgstr_longlong(gpu.id), wine_dbgstr_w(gpu.name));
+
+    device_manager->add_gpu(&gpu, param);
+}
+
+static void wayland_add_device_adapter(const struct gdi_device_manager *device_manager,
+                                       void *param, INT output_id)
+{
+    struct gdi_adapter adapter;
+    adapter.id = output_id;
+    adapter.state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
+    if (output_id == 0)
+        adapter.state_flags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    TRACE("id=0x%s state_flags=0x%x\n",
+          wine_dbgstr_longlong(adapter.id), (UINT)adapter.state_flags);
+
+    device_manager->add_adapter(&adapter, param);
+}
+
+static void wayland_add_device_monitor(const struct gdi_device_manager *device_manager,
+                                       void *param, struct wayland_output *output)
+{
+
+    struct gdi_monitor monitor = {0};
+
+    SetRect(&monitor.rc_monitor, output->x, output->y,
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
+
+    /* We don't have a direct way to get the work area in Wayland. */
+    monitor.rc_work = monitor.rc_monitor;
+
+    monitor.state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+
+    TRACE("name=%s rc_monitor=rc_work=%s state_flags=0x%x\n",
+          output->name, wine_dbgstr_rect(&monitor.rc_monitor),
+          (UINT)monitor.state_flags);
+
+    device_manager->add_monitor(&monitor, param);
+}
+
+static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
+{
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY;
+    mode->dmDisplayOrientation = DMDO_DEFAULT;
+    mode->dmDisplayFlags = 0;
+    mode->dmBitsPerPel = output_mode->bpp;
+    mode->dmPelsWidth = output_mode->width;
+    mode->dmPelsHeight = output_mode->height;
+    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+}
+
+static void wayland_add_device_modes(const struct gdi_device_manager *device_manager,
+                                     void *param, struct wayland_output *output)
+{
+
+    struct wayland_output_mode *output_mode;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        DEVMODEW mode;
+        populate_devmode(output_mode, &mode);
+        device_manager->add_mode(&mode, param);
+    }
+}
+
+static void wayland_add_device_output(const struct gdi_device_manager *device_manager,
+                                      void *param, struct wayland_output *output,
+                                      INT output_id)
+{
+    char buf[16];
+    int len;
+
+    /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+    wayland_add_device_adapter(device_manager, param, output_id);
+    wayland_add_device_monitor(device_manager, param, output);
+    wayland_add_device_modes(device_manager, param, output);
+
+    /* Set the wine name in wayland_output so that we can look it up. */
+    len = snprintf(buf, sizeof(buf), "\\\\.\\DISPLAY%u", output_id + 1);
+    if (len > sizeof(buf)) len = sizeof(buf);
+    ascii_to_unicode_z(output->wine_name, ARRAY_SIZE(output->wine_name), buf, len);
+    TRACE("name=%s wine_name=%s\n",
+          output->name, wine_dbgstr_w(output->wine_name));
+}
+
+static struct wayland_output *wayland_get_primary_output(struct wayland *wayland)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (output->current_wine_mode && output->x == 0 && output->y == 0)
+            return output;
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *      UpdateDisplayDevices (WAYLAND.@)
+ */
+BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param)
+{
+    struct wayland *wayland;
+    struct wayland_output *output, *primary;
+    INT output_id = 0;
+
+    if (!force && !force_display_devices_refresh) return TRUE;
+
+    TRACE("force=%d force_refresh=%d\n", force, force_display_devices_refresh);
+
+    force_display_devices_refresh = FALSE;
+
+    wayland = wayland_process_acquire();
+
+    wayland_add_device_gpu(device_manager, param);
+
+    /* Get the primary output (i.e., positioned at 0,0) and add it with id 0. */
+    primary = wayland_get_primary_output(wayland);
+    if (primary)
+    {
+        wayland_add_device_output(device_manager, param, primary, output_id);
+        output_id++;
+    }
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_wine_mode || output == primary) continue;
+        wayland_add_device_output(device_manager, param, output, output_id);
+        output_id++;
+    }
+
+    wayland_process_release();
+
+    return TRUE;
+}
+
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output || !output->current_wine_mode)
+        return FALSE;
+
+    populate_devmode(output->current_wine_mode, mode);
+
+    mode->dmFields |= DM_POSITION;
+    mode->dmPosition.x = output->x;
+    mode->dmPosition.y = output->y;
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *             GetCurrentDisplaySettings  (WAYLAND.@)
+ *
+ */
+BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary, LPDEVMODEW devmode)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    BOOL ret;
+
+    TRACE("(%s,%p) wayland=%p\n", debugstr_w(name), devmode, wayland);
+
+    ret = wayland_get_current_devmode(wayland, name, devmode);
+
+    wayland_process_release();
+
+    if (ret)
+    {
+        TRACE("=> %d,%d+%ux%u@%u %ubpp\n",
+              (int)devmode->dmPosition.x, (int)devmode->dmPosition.y,
+              (UINT)devmode->dmPelsWidth, (UINT)devmode->dmPelsHeight,
+              (UINT)devmode->dmDisplayFrequency, (UINT)devmode->dmBitsPerPel);
+    }
+    else
+    {
+        ERR("Failed to get %s current display settings.\n", wine_dbgstr_w(name));
+    }
+
+    return ret;
+}
+
+static INT wayland_get_current_bpp(struct wayland *wayland, LPCWSTR name)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output || !output->current_wine_mode)
+        return 0;
+
+    return output->current_wine_mode->bpp;
+}
+
+/***********************************************************************
+ *             GetDisplayDepth  (WAYLAND.@)
+ *
+ */
+INT WAYLAND_GetDisplayDepth(LPCWSTR name, BOOL is_primary)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    INT bpp;
+
+    TRACE("(%s) wayland=%p\n", debugstr_w(name), wayland);
+
+    bpp = wayland_get_current_bpp(wayland, name);
+
+    wayland_process_release();
+
+    if (bpp > 0)
+        TRACE("=> %dbpp\n", bpp);
+    else
+        ERR("Failed to get %s display depth, returning 32.\n", wine_dbgstr_w(name));
+
+    return bpp > 0 ? bpp : 32;
+}
+
+static struct wayland_output_mode *get_matching_output_mode(struct wayland_output *output,
+                                                            LPDEVMODEW devmode)
+{
+    struct wayland_output_mode *output_mode;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (devmode->dmPelsWidth == output_mode->width &&
+            devmode->dmPelsHeight == output_mode->height &&
+            output_mode->bpp == devmode->dmBitsPerPel &&
+            output_mode->refresh / 1000 == devmode->dmDisplayFrequency)
+        {
+            return output_mode;
+        }
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *		ChangeDisplaySettings  (WAYLAND.@)
+ *
+ */
+LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW displays, LPCWSTR primary_name,
+                                   HWND hwnd, DWORD flags, LPVOID lpvoid)
+{
+    LONG ret;
+    struct wayland *wayland = wayland_process_acquire();
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+    DEVMODEW *devmode;
+
+    for (devmode = displays; devmode->dmSize; devmode = NEXT_DEVMODEW(devmode))
+    {
+        TRACE("device=%s devmode=%ux%u@%u %ubpp\n",
+              wine_dbgstr_w(devmode->dmDeviceName), (UINT)devmode->dmPelsWidth,
+              (UINT)devmode->dmPelsHeight, (UINT)devmode->dmDisplayFrequency,
+              (UINT)devmode->dmBitsPerPel);
+
+        output = wayland_output_get_by_wine_name(wayland, devmode->dmDeviceName);
+        if (!output)
+        {
+            ret = DISP_CHANGE_BADPARAM;
+            goto out;
+        }
+
+        output_mode = get_matching_output_mode(output, devmode);
+        if (!output_mode)
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+
+        wayland_output_set_wine_mode(output, output_mode);
+
+        TRACE("output=%s (%s) set current wine mode %dx%d wine_scale %f\n",
+              output->name, wine_dbgstr_w(output->wine_name),
+              output_mode->width, output_mode->height, output->wine_scale);
+    }
+
+    /* Release the wayland process instance lock to avoid potential deadlocks
+     * while notifying other thread instances below. */
+    wayland_process_release();
+
+    wayland_notify_wine_monitor_change();
+
+    return DISP_CHANGE_SUCCESSFUL;
+
+out:
+    wayland_process_release();
+    return ret;
+}
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
new file mode 100644
index 00000000000..79463f29f14
--- /dev/null
+++ b/dlls/winewayland.drv/dllmain.c
@@ -0,0 +1,67 @@
+/*
+ * winewayland.drv entry points
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "waylanddrv_dll.h"
+
+BOOL option_show_systray;
+
+typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
+static const kernel_callback kernel_callbacks[] =
+{
+    waylanddrv_client_create_clipboard_window,
+    waylanddrv_client_dnd,
+};
+
+C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == waylanddrv_client_func_last);
+
+static DWORD WINAPI wayland_read_events_thread(void *arg)
+{
+    WAYLANDDRV_UNIX_CALL(read_events, NULL);
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    TerminateProcess(GetCurrentProcess(), 1);
+    return 0;
+}
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    struct waylanddrv_unix_init_params init_params;
+    DWORD tid;
+    void **callback_table;
+
+    if (reason != DLL_PROCESS_ATTACH) return TRUE;
+
+    DisableThreadLibraryCalls(instance);
+    if (__wine_init_unix_call()) return FALSE;
+
+    callback_table = NtCurrentTeb()->Peb->KernelCallbackTable;
+    memcpy(callback_table + NtUserDriverCallbackFirst, kernel_callbacks,
+           sizeof(kernel_callbacks));
+
+    if (WAYLANDDRV_UNIX_CALL(init, &init_params))
+        return FALSE;
+
+    option_show_systray = init_params.option_show_systray;
+
+    /* Read wayland events from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/dump_pixels.c b/dlls/winewayland.drv/dump_pixels.c
new file mode 100644
index 00000000000..fcdb8b1da64
--- /dev/null
+++ b/dlls/winewayland.drv/dump_pixels.c
@@ -0,0 +1,152 @@
+/*
+ * Debugging functions for pixel buffer contents
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* Dump the contents of a pixel buffer, along with the outlines of damage
+ * and window regions, to a netpbm .pam file. */
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels,
+                 int width, int height, BOOL alpha, HRGN damage, HRGN win_region)
+{
+    char fname[128] = {0};
+    RGNDATA *damage_data;
+    RGNDATA *win_region_data;
+    FILE *fp;
+    int x, y;
+
+    damage_data = get_region_data(damage);
+    win_region_data = get_region_data(win_region);
+
+    snprintf(fname, sizeof(fname), fpattern, dbgid);
+    TRACE("dumping pixels to %s\n", fname);
+
+    fp = fopen(fname, "w");
+    assert(fp && "Failed to open target file for dump pixels. Does the target directory exist?");
+
+    fprintf(fp, "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
+            width, height);
+
+    for (y = 0; y < height; ++y)
+    {
+        for (x = 0; x < width; ++x)
+        {
+            BOOL draw_damage = FALSE;
+            BOOL draw_win_region = FALSE;
+            RECT *rgn_rect;
+            RECT *end;
+
+            if (damage_data)
+            {
+                rgn_rect = (RECT *)damage_data->Buffer;
+                end = rgn_rect + damage_data->rdh.nCount;
+
+                /* Draw the outlines of damaged areas. */
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (win_region_data)
+            {
+                /* Draw the outlines of window region areas. */
+                rgn_rect = (RECT *)win_region_data->Buffer;
+                end = rgn_rect + win_region_data->rdh.nCount;
+
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (draw_damage || draw_win_region)
+            {
+                unsigned char rgba[4] = {
+                    draw_damage ? 0xff : 0x00,
+                    draw_win_region ? 0xff : 0x00,
+                    0x00, 0xff
+                };
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+            else
+            {
+                unsigned int *pixel = (unsigned int *)((char *)pixels +
+                                                       width * 4 * y + 4 * x);
+                unsigned char rgba[4] = {
+                    (*pixel & 0x00ff0000) >> 16,
+                    (*pixel & 0x0000ff00) >> 8,
+                    (*pixel & 0xff),
+                    alpha ? (*pixel & 0xff000000) >> 24 : 0xff,
+                };
+
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+        }
+    }
+
+    fflush(fp);
+    fclose(fp);
+
+    free(damage_data);
+    free(win_region_data);
+}
diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
new file mode 100644
index 00000000000..4632a32b6ed
--- /dev/null
+++ b/dlls/winewayland.drv/gbm.c
@@ -0,0 +1,445 @@
+/*
+ * Wayland GBM support
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <drm_fourcc.h>
+#include <fcntl.h>
+#ifdef HAVE_LIBUDEV_H
+#include <libudev.h>
+#endif
+#include <stdlib.h>
+#include <unistd.h>
+#include <xf86drm.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct gbm_device *process_gbm_device;
+static pthread_once_t init_once;
+
+static const char default_seat[] = "seat0";
+static const char default_render_node[] = "/dev/dri/renderD128";
+static const char default_primary_node[] = "/dev/dri/card0";
+static const char primary_node_sysname[] = "card[0-9]*";
+static const char render_node_sysname[] = "renderD[0-9]*";
+
+#ifdef HAVE_UDEV
+
+typedef BOOL (*filter_func)(struct udev_device *, const char *);
+
+/* returns TRUE for every udev_dev whose devnode is not devnode_to_ignore */
+static BOOL filter_has_different_devnode(struct udev_device *udev_dev,
+                                         const char *devnode_to_ignore)
+{
+    const char *devnode;
+
+    assert(udev_dev && devnode_to_ignore);
+
+    /* If we can't get a devnode from the device, we prefer to filter it out */
+    devnode = udev_device_get_devnode(udev_dev);
+    if (!devnode)
+        return FALSE;
+
+    /* devnode is equal to devnode_to_ignore */
+    if (strcmp(devnode, devnode_to_ignore) == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* returns TRUE for every udev_dev that is not the primary system GPU */
+static BOOL filter_is_not_primary_system_gpu(struct udev_device *udev_dev,
+                                             const char *unused_arg)
+{
+    struct udev_device *pci_device;
+    const char *boot_vga;
+
+    assert(udev_dev);
+
+    /* If we can't get pci_device, we prefer to filter the device out */
+    pci_device = udev_device_get_parent(udev_dev);
+    if (!pci_device)
+        return FALSE;
+
+    /* It is the primary system GPU */
+    boot_vga = udev_device_get_sysattr_value(pci_device, "boot_vga");
+    if (boot_vga && strcmp(boot_vga, "1") == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* returns TRUE for every udev_dev whose ID_PATH_TAG is id_path_tag */
+static BOOL filter_has_same_id_path_tag(struct udev_device *udev_dev,
+                                        const char *id_path_tag)
+{
+    const char *dev_id_path_tag;
+
+    assert(udev_dev && id_path_tag);
+
+    /* If we can't get dev_id_path_tag, we prefer to filter the device out */
+    dev_id_path_tag = udev_device_get_property_value(udev_dev, "ID_PATH_TAG");
+    if (!dev_id_path_tag)
+        return FALSE;
+
+    /* ID_PATH_TAG is different from id_path_tag */
+    if (strcmp(dev_id_path_tag, id_path_tag) != 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+static BOOL is_primary_system_gpu_set(void)
+{
+    struct udev *udev;
+    struct udev_enumerate *e = NULL;
+    BOOL ret = FALSE;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+
+    udev_enumerate_add_match_sysattr(e, "boot_vga", "1");
+
+    /* if list is not empty we have a PCI device with boot_vga set to 1 (i.e. we
+     * have a PCI device marked as the primary system GPU) */
+    udev_enumerate_scan_devices(e);
+    if (udev_enumerate_get_list_entry(e)) ret = TRUE;
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return ret;
+}
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc,
+                                  filter_func filter, const char *filter_arg)
+{
+    const char *seat;
+    struct udev *udev = NULL;
+    struct udev_enumerate *e = NULL;
+    struct udev_list_entry *entry;
+    int drm_fd = -1;
+
+    seat = getenv("XDG_SEAT");
+    if (!seat) seat = default_seat;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+    udev_enumerate_add_match_subsystem(e, "drm");
+    udev_enumerate_add_match_sysname(e, sysname);
+
+    udev_enumerate_scan_devices(e);
+    udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e))
+    {
+        const char *path, *device_seat, *devnode;
+        struct udev_device *device;
+
+        path = udev_list_entry_get_name(entry);
+        device = udev_device_new_from_syspath(udev, path);
+        if (!device) continue;
+
+        device_seat = udev_device_get_property_value(device, "ID_SEAT");
+        if (!device_seat) device_seat = default_seat;
+        if (strcmp(device_seat, seat))
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        devnode = udev_device_get_devnode(device);
+        if (!devnode)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        /* If we have a filter, we may ignore certain devices */
+        if (filter && filter(device, filter_arg) == FALSE)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        drm_fd = open(devnode, O_RDWR);
+        TRACE("Trying to open drm device (%s) %s => fd=%d\n", desc, devnode, drm_fd);
+
+        udev_device_unref(device);
+        if (drm_fd >= 0) break;
+    }
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return drm_fd;
+}
+
+#else
+
+typedef void (*filter_func)(void);
+
+static void filter_has_different_devnode(void)
+{
+}
+
+static void filter_is_not_primary_system_gpu(void)
+{
+}
+
+static void filter_has_same_id_path_tag(void)
+{
+}
+
+static BOOL is_primary_system_gpu_set(void)
+{
+    return FALSE;
+}
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc,
+                                  filter_func filter, const char *filter_arg)
+{
+    return -1;
+}
+
+#endif
+
+static char *get_compositor_render_node(void)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    char *compositor_render_node = NULL;
+    drmDevicePtr dev_ptr;
+
+    if (!wayland->dmabuf.default_feedback)
+        goto out;
+
+    if (drmGetDeviceFromDevId(wayland->dmabuf.default_feedback->main_device,
+                              0, &dev_ptr) < 0)
+        goto out;
+
+    if (dev_ptr->available_nodes & (1 << DRM_NODE_RENDER))
+        compositor_render_node = strdup(dev_ptr->nodes[DRM_NODE_RENDER]);
+
+    drmFreeDevice(&dev_ptr);
+
+out:
+    wayland_process_release();
+    return compositor_render_node;
+}
+
+/**********************************************************************
+ *          wayland_gbm_create_surface
+ */
+struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, int height,
+                                               size_t count_modifiers, uint64_t *modifiers,
+                                               BOOL format_is_scanoutable)
+{
+    uint32_t gbm_bo_flags = GBM_BO_USE_RENDERING;
+    size_t i;
+
+    if (TRACE_ON(waylanddrv))
+    {
+        TRACE("%dx%d %.4s scanout=%d count_mods=%zu\n",
+              width, height, (const char *)&drm_format,
+              format_is_scanoutable, count_modifiers);
+
+        for (i = 0; i < count_modifiers; i++)
+            TRACE("    mod: 0x%.16llx\n", (long long)modifiers[i]);
+    }
+
+    if (format_is_scanoutable) gbm_bo_flags |= GBM_BO_USE_SCANOUT;
+
+    if (count_modifiers)
+    {
+        struct gbm_surface *surf;
+
+#ifdef HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2
+        surf = gbm_surface_create_with_modifiers2(process_gbm_device, width, height,
+                                                  drm_format, modifiers, count_modifiers, gbm_bo_flags);
+#else
+        surf = gbm_surface_create_with_modifiers(process_gbm_device, width, height,
+                                                 drm_format, modifiers, count_modifiers);
+#endif
+        if (surf) return surf;
+
+        TRACE("Failed to create gbm surface with explicit modifiers API " \
+              "(errno=%d), falling back to implicit modifiers API\n", errno);
+
+        for (i = 0; i < count_modifiers; i++)
+            if (modifiers[i] == DRM_FORMAT_MOD_INVALID) break;
+
+        if (i == count_modifiers)
+        {
+            ERR("Will not create gbm surface with implicit modifiers API, as " \
+                "that is not supported by the compositor\n");
+            return NULL;
+        }
+    }
+
+    return gbm_surface_create(process_gbm_device, width, height, drm_format, gbm_bo_flags);
+}
+
+static void wayland_gbm_init_once(void)
+{
+    int drm_fd = -1;
+    char *compositor_render_node = get_compositor_render_node();
+    const char *dri_prime = getenv("DRI_PRIME");
+    const char *desc;
+
+    if (option_drm_device)
+    {
+        drm_fd = open(option_drm_device, O_RDWR);
+        TRACE("Trying to open drm device (from options) %s => fd=%d\n",
+              option_drm_device, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open device from DRMDevice driver option\n");
+    }
+
+    if (drm_fd < 0 && dri_prime)
+    {
+        if (strcmp(dri_prime, "1") == 0)
+        {
+            if (compositor_render_node)
+            {
+                /* DRI_PRIME is 1, so we open the non-default device (device
+                 * that is different from whatever the compositor is using) */
+                desc = "from DRI_PRIME == 1, different from compositor render node";
+                drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                                filter_has_different_devnode, compositor_render_node);
+            }
+            else if (is_primary_system_gpu_set())
+            {
+                /* We don't know what device the compositor is using, so we
+                 * consider that the primary system GPU is the default device. */
+                desc = "from DRI_PRIME == 1, different from primary system GPU";
+                drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                                filter_is_not_primary_system_gpu, NULL);
+            }
+        }
+        else
+        {
+            /* DRI_PRIME should be set to ID_TAG_PATH of the GPU the user wants
+             * us to use. */
+            desc = "from DRI_PRIME == ID_PATH_TAG";
+            drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                            filter_has_same_id_path_tag, dri_prime);
+        }
+
+        if (drm_fd < 0)
+            WARN("Failed to open DRI_PRIME device\n");
+    }
+
+    if (drm_fd < 0 && compositor_render_node)
+    {
+        drm_fd = open(compositor_render_node, O_RDWR);
+        TRACE("Trying to open drm device (from compositor render node) %s => fd=%d\n",
+              compositor_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open drm device that compositor is using\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random render node";
+        drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc, NULL, NULL);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_render_node, O_RDWR);
+        TRACE("Trying to open drm device (default render node) %s => fd=%d\n",
+              default_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random primary node";
+        drm_fd = wayland_gbm_get_drm_fd(primary_node_sysname, desc, NULL, NULL);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable primary node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_primary_node, O_RDWR);
+        TRACE("Trying to open drm device (default primary node) %s => fd=%d\n",
+              default_primary_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default primary node\n");
+    }
+
+    free(compositor_render_node);
+
+    if (drm_fd < 0)
+    {
+        ERR("Failed to find a suitable drm device\n");
+        return;
+    }
+
+    process_gbm_device = gbm_create_device(drm_fd);
+    if (!process_gbm_device)
+    {
+        ERR("Failed to create gbm device (errno=%d)\n", errno);
+        close(drm_fd);
+    }
+}
+
+/**********************************************************************
+ *          wayland_gbm_get_render_dev
+ */
+dev_t wayland_gbm_get_render_dev()
+{
+    int dev_fd = gbm_device_get_fd(process_gbm_device);
+    struct stat dev_stat;
+
+    if (dev_fd >= 0 && !fstat(dev_fd, &dev_stat))
+        return dev_stat.st_rdev;
+
+    return 0;
+}
+
+BOOL wayland_gbm_init(void)
+{
+    pthread_once(&init_once, wayland_gbm_init_once);
+
+    return process_gbm_device != NULL;
+}
diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
new file mode 100644
index 00000000000..3ff2ed71205
--- /dev/null
+++ b/dlls/winewayland.drv/gdi.c
@@ -0,0 +1,251 @@
+/*
+ * Wayland gdi functions
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+
+#include <stdlib.h>
+#include <sys/mman.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+typedef struct
+{
+    struct gdi_physdev dev;
+} WAYLAND_PDEVICE;
+
+static inline WAYLAND_PDEVICE *get_wayland_dev(PHYSDEV dev)
+{
+    return (WAYLAND_PDEVICE *)dev;
+}
+
+static WAYLAND_PDEVICE *create_wayland_physdev(void)
+{
+    WAYLAND_PDEVICE *physDev;
+
+    physDev = calloc(1, sizeof(*physDev));
+
+    return physDev;
+}
+
+RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data;
+    DWORD size;
+
+    if (!region) return NULL;
+    if (!(size = NtGdiGetRegionData(region, 0, NULL))) return NULL;
+    if (!(data = malloc(size))) return NULL;
+    if (!NtGdiGetRegionData(region, size, data))
+    {
+        free(data);
+        return NULL;
+    }
+
+    return data;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateDC
+ */
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateCompatibleDC
+ */
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_DeleteDC
+ */
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
+{
+    WAYLAND_PDEVICE *physDev = get_wayland_dev(dev);
+
+    free(physDev);
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_PutImage
+ *
+ * This is a fallback implementation for when the dibdrv cannot perform
+ * this task, typically because the destination belongs to a different
+ * process. In such a case the implementation utilizes the remote surface
+ * infrastructure to commit content to the remote HWND.
+ *
+ * The implementation is very limited, supporting only simple full copies,
+ * but that's enough for some typical cross-process cases, notably software
+ * rendered content in Chrome/CEF.
+ */
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop)
+{
+    HWND hwnd;
+    struct wayland_native_buffer native;
+    struct wayland_remote_surface_proxy *remote = NULL;
+    size_t shm_size;
+    void *shm_data;
+    DWORD ret = ERROR_SUCCESS;
+
+    hwnd = NtUserWindowFromDC(dev->hdc);
+
+    TRACE("hwnd=%p rop=%#x biBitCount=%d compr=%u size=%dx%d "
+          "src=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "dst=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "clip=%p\n",
+          hwnd, (UINT)rop, info->bmiHeader.biBitCount,
+          (UINT)info->bmiHeader.biCompression,
+          (int)info->bmiHeader.biWidth, (int)info->bmiHeader.biHeight,
+          src->log_x, src->log_y, src->log_width, src->log_height,
+          src->x, src->y, src->width, src->height,
+          wine_dbgstr_rect(&src->visrect),
+          dst->log_x, dst->log_y, dst->log_width, dst->log_height,
+          dst->x, dst->y, dst->width, dst->height,
+          wine_dbgstr_rect(&dst->visrect), clip);
+
+    if (info->bmiHeader.biPlanes != 1)
+    {
+        TRACE("Multiplanar buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biBitCount != 32)
+    {
+        TRACE("Non 32-bit buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biCompression != BI_RGB)
+    {
+        TRACE("Non RGB not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biHeight > 0)
+    {
+        TRACE("Bottom-up buffers not supported\n");
+        goto update_format;
+    }
+
+    if (!bits) return ERROR_SUCCESS;  /* just querying the format */
+
+    if (!hwnd)
+    {
+        TRACE("Invalid hwnd=%p\n", hwnd);
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (clip)
+    {
+        TRACE("Clipping not supported\n");
+        return ERROR_CLIPPING_NOT_SUPPORTED;
+    }
+
+    if ((src->width != dst->width) || (src->height != dst->height))
+    {
+        TRACE("Image stretching is not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if ((src->width != info->bmiHeader.biWidth) ||
+        (src->height != -info->bmiHeader.biHeight))
+    {
+        TRACE("Partial blits are not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (rop != SRCCOPY)
+    {
+        TRACE("Raster operations other than SRCCOPY are not supported\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (!wayland_native_buffer_init_shm(&native, src->width, src->height,
+                                        WL_SHM_FORMAT_ARGB8888))
+    {
+        TRACE("Failed to create native shm buffer %dx%d\n", src->width, src->height);
+        return ERROR_OUTOFMEMORY;
+    }
+
+    shm_size = native.strides[0] * native.height;
+    shm_data = mmap(NULL, shm_size, PROT_WRITE, MAP_SHARED, native.fds[0], 0);
+    if (shm_data == MAP_FAILED)
+    {
+        TRACE("Failed to mmap shm buffer size=%zu\n", shm_size);
+        ret = ERROR_OUTOFMEMORY;
+        goto out;
+    }
+    memcpy(shm_data, bits->ptr, shm_size);
+    munmap(shm_data, shm_size);
+
+    remote = wayland_remote_surface_proxy_create(hwnd,
+                                                 WAYLAND_REMOTE_SURFACE_TYPE_NORMAL);
+    if (!remote)
+    {
+        TRACE("Failed to create remote surface proxy\n");
+        ret =  ERROR_OUTOFMEMORY;
+        goto out;
+    }
+
+    wayland_remote_surface_proxy_commit(remote, &native,
+                                        WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+                                        WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+                                        NULL, NULL);
+
+    wayland_remote_surface_proxy_destroy(remote);
+
+out:
+    wayland_native_buffer_deinit(&native);
+    return ret;
+
+update_format:
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    if (info->bmiHeader.biHeight > 0) info->bmiHeader.biHeight = -info->bmiHeader.biHeight;
+    return ERROR_BAD_FORMAT;
+}
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
new file mode 100644
index 00000000000..2f75c90f12e
--- /dev/null
+++ b/dlls/winewayland.drv/opengl.c
@@ -0,0 +1,2011 @@
+/*
+ * Wayland OpenGL functions
+ *
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2005 Alex Woods
+ * Copyright 2005 Raphael Junqueira
+ * Copyright 2006-2009 Roderick Colenbrander
+ * Copyright 2006 Tomas Carnecky
+ * Copyright 2013 Matteo Bruni
+ * Copyright 2012, 2013, 2014, 2017 Alexandre Julliard
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+#if defined(SONAME_LIBEGL) && (defined(SONAME_LIBGL) || defined(SONAME_LIBGLESV2))
+
+#define GLAPIENTRY /* nothing */
+#include "wine/wgl.h"
+#undef GLAPIENTRY
+#include "wine/wgl_driver.h"
+
+#include "ntuser.h"
+#include "winternl.h"
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <assert.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+
+struct wgl_pixel_format
+{
+    EGLConfig config;
+    EGLint native_visual_id;
+};
+
+struct wayland_gl_drawable
+{
+    struct wl_list  link;
+    HWND            hwnd;
+    int             format;
+    int             width;
+    int             height;
+    struct wayland_surface *wayland_surface;
+    struct gbm_surface *gbm_surface;
+    EGLSurface      surface;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_list  buffer_list;
+    int             swap_interval;
+    struct wl_callback *throttle_callback;
+    struct wayland_remote_surface_proxy *remote_surface_proxy;
+    HANDLE remote_throttle_event;
+};
+
+struct wayland_gl_buffer
+{
+    struct wl_list  link;
+    struct wayland_gl_drawable *gl;
+    struct gbm_bo *gbm_bo;
+    struct gbm_surface *gbm_surface;
+    struct wayland_native_buffer native_buffer;
+    struct wayland_dmabuf_buffer *dmabuf_buffer;
+    HANDLE remote_buffer_released_event;
+};
+
+struct wgl_context
+{
+    struct wl_list link;
+    EGLConfig  config;
+    EGLContext context;
+    HWND       draw_hwnd;
+    HWND       read_hwnd;
+    LONG       refresh;
+    BOOL       has_been_current;
+    BOOL       sharing;
+    int        *attribs;
+    BOOL       is_draw_buffer_front;
+};
+
+static void *egl_handle;
+static void *opengl_handle;
+static EGLDisplay egl_display;
+static EGLint egl_version[2];
+static struct opengl_funcs egl_funcs;
+static char wgl_extensions[4096];
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
+static BOOL has_khr_create_context;
+static BOOL has_gl_colorspace;
+
+static struct wayland_mutex gl_object_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": gl_object_mutex"
+};
+
+static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+static struct wl_list gl_contexts = { &gl_contexts, &gl_contexts };
+
+#define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglBindAPI);
+DECL_FUNCPTR(eglCreateContext);
+DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroyContext);
+DECL_FUNCPTR(eglDestroySurface);
+DECL_FUNCPTR(eglGetConfigAttrib);
+DECL_FUNCPTR(eglGetConfigs);
+DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglGetProcAddress);
+DECL_FUNCPTR(eglInitialize);
+DECL_FUNCPTR(eglMakeCurrent);
+DECL_FUNCPTR(eglQueryString);
+DECL_FUNCPTR(eglSwapBuffers);
+#undef DECL_FUNCPTR
+
+static void (*p_glFinish)(void);
+static void (*p_glFlush)(void);
+static void (*p_glDrawBuffer)(GLenum);
+
+static inline BOOL is_onscreen_pixel_format(int format)
+{
+    return format > 0 && format <= nb_onscreen_formats;
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int format)
+{
+    struct wayland_gl_drawable *gl;
+    struct wayland_surface *wayland_surface;
+
+    gl = calloc(1, sizeof(*gl));
+    if (!gl) return NULL;
+
+    wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p wayland_surface=%p\n", hwnd, wayland_surface);
+
+    if (wayland_surface)
+    {
+        BOOL ref_gl = wayland_surface_create_or_ref_glvk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_gl) goto err;
+    }
+    else
+    {
+        gl->remote_surface_proxy =
+            wayland_remote_surface_proxy_create(hwnd, WAYLAND_REMOTE_SURFACE_TYPE_GLVK);
+        if (!gl->remote_surface_proxy) goto err;
+    }
+
+    gl->hwnd = hwnd;
+    gl->format = format;
+    gl->wayland_surface = wayland_surface;
+    if (gl->wayland_surface)
+    {
+        gl->wl_event_queue = wl_display_create_queue(wayland_surface->wayland->wl_display);
+        if (!gl->wl_event_queue) goto err;
+    }
+    wl_list_init(&gl->buffer_list);
+    gl->swap_interval = 1;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_insert(&gl_drawables, &gl->link);
+    return gl;
+
+err:
+    if (gl)
+    {
+        if (gl->wayland_surface) wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
+        if (gl->remote_surface_proxy)
+            wayland_remote_surface_proxy_destroy(gl->remote_surface_proxy);
+        free(gl);
+    }
+    return NULL;
+}
+
+static void wayland_gl_buffer_destroy(struct wayland_gl_buffer *gl_buffer)
+{
+    TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    wl_list_remove(&gl_buffer->link);
+    wayland_native_buffer_deinit(&gl_buffer->native_buffer);
+    if (gl_buffer->dmabuf_buffer)
+        wayland_dmabuf_buffer_destroy(gl_buffer->dmabuf_buffer);
+    if (gl_buffer->remote_buffer_released_event)
+        NtClose(gl_buffer->remote_buffer_released_event);
+    gbm_bo_set_user_data(gl_buffer->gbm_bo, NULL, NULL);
+    free(gl_buffer);
+}
+
+static void wayland_gl_buffer_release(struct wayland_gl_buffer *gl_buffer)
+{
+    TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    if (gl_buffer->remote_buffer_released_event)
+    {
+        NtClose(gl_buffer->remote_buffer_released_event);
+        gl_buffer->remote_buffer_released_event = 0;
+    }
+    gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
+}
+
+static void wayland_gl_drawable_clear_buffers(struct wayland_gl_drawable *gl)
+{
+    struct wayland_gl_buffer *gl_buffer, *tmp;
+
+    wl_list_for_each_safe(gl_buffer, tmp, &gl->buffer_list, link)
+        wayland_gl_buffer_destroy(gl_buffer);
+}
+
+void wayland_destroy_gl_drawable(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd != hwnd) continue;
+        wl_list_remove(&gl->link);
+        wayland_gl_drawable_clear_buffers(gl);
+        if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+        if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->throttle_callback) wl_callback_destroy(gl->throttle_callback);
+        if (gl->remote_surface_proxy)
+            wayland_remote_surface_proxy_destroy(gl->remote_surface_proxy);
+        if (gl->remote_throttle_event) NtClose(gl->remote_throttle_event);
+        if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
+        free(gl);
+        break;
+    }
+    wayland_mutex_unlock(&gl_object_mutex);
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_get(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    if (!hwnd) return NULL;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd == hwnd) return gl;
+    }
+    wayland_mutex_unlock(&gl_object_mutex);
+    return NULL;
+}
+
+static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
+{
+    if (gl) wayland_mutex_unlock(&gl_object_mutex);
+}
+
+static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HWND read_hwnd)
+{
+    BOOL ret;
+    struct wayland_gl_drawable *draw_gl = NULL, *read_gl = NULL;
+
+    draw_gl = wayland_gl_drawable_get(draw_hwnd);
+    read_gl = wayland_gl_drawable_get(read_hwnd);
+
+    TRACE("%p/%p context %p surface %p/%p\n",
+          draw_hwnd, read_hwnd, ctx->context,
+          draw_gl ? draw_gl->surface : NULL,
+          read_gl ? read_gl->surface : NULL);
+
+    ret = p_eglMakeCurrent(egl_display,
+                           draw_gl ? draw_gl->surface : NULL,
+                           read_gl ? read_gl->surface : NULL,
+                           ctx->context);
+    if (ret)
+    {
+        ctx->draw_hwnd = draw_hwnd;
+        ctx->read_hwnd = read_hwnd;
+        InterlockedExchange(&ctx->refresh, FALSE);
+        ctx->has_been_current = TRUE;
+        NtCurrentTeb()->glContext = ctx;
+    }
+
+    wayland_gl_drawable_release(read_gl);
+    wayland_gl_drawable_release(draw_gl);
+
+    return ret;
+}
+
+static struct gbm_surface *wayland_gl_create_gbm_surface(struct wayland_surface *glvk,
+                                                         int width, int height,
+                                                         uint32_t drm_format)
+{
+    struct wayland_dmabuf_format_info format_info;
+    dev_t render_dev;
+    struct wayland_dmabuf_surface_feedback *surface_feedback = glvk ? glvk->surface_feedback : NULL;
+    struct gbm_surface *gbm_surface = NULL;
+
+    if (!(render_dev = wayland_gbm_get_render_dev()))
+    {
+        ERR("Failed to get device's dev_t from GBM device.\n");
+        goto out;
+    }
+
+    if (surface_feedback)
+    {
+        wayland_dmabuf_surface_feedback_lock(glvk->surface_feedback);
+        if (surface_feedback->feedback)
+        {
+            if (wayland_dmabuf_feedback_get_format_info(surface_feedback->feedback, drm_format,
+                                                        render_dev, &format_info))
+            {
+                TRACE("Using per-surface feedback format/modifier information\n");
+                gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                         format_info.count_modifiers,
+                                                         format_info.modifiers,
+                                                         format_info.scanoutable);
+            }
+        }
+        else
+        {
+            /*
+             * Compositor supports feedback but we haven't processed surface
+             * feedback events yet, so set surface_feedback to NULL to enter
+             * the default format info code path below.
+             */
+            surface_feedback = NULL;
+        }
+
+        wayland_dmabuf_surface_feedback_unlock(glvk->surface_feedback);
+    }
+
+    if (!surface_feedback)
+    {
+        struct wayland_dmabuf *dmabuf = &wayland_process_acquire()->dmabuf;
+
+        if (wayland_dmabuf_get_default_format_info(dmabuf, drm_format, render_dev, &format_info))
+        {
+            TRACE("Using default format/modifier information\n");
+            gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                     format_info.count_modifiers,
+                                                     format_info.modifiers,
+                                                     format_info.scanoutable);
+        }
+
+        wayland_process_release();
+    }
+
+out:
+    return gbm_surface;
+}
+
+static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
+{
+    RECT client_rect;
+
+    TRACE("hwnd=%p\n", gl->hwnd);
+
+    wayland_gl_drawable_clear_buffers(gl);
+    if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+    if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
+
+    NtUserGetClientRect(gl->hwnd, &client_rect);
+    gl->width = client_rect.right;
+    gl->height = client_rect.bottom;
+
+    gl->gbm_surface =
+        wayland_gl_create_gbm_surface(gl->wayland_surface ? gl->wayland_surface->glvk : NULL,
+                                      gl->width, gl->height,
+                                      pixel_formats[gl->format - 1].native_visual_id);
+    if (!gl->gbm_surface)
+        ERR("Failed to create GBM surface\n");
+
+    /* First try to create a surface with an SRGB colorspace, if supported. */
+    if (has_gl_colorspace)
+    {
+        EGLint attribs[] = { EGL_GL_COLORSPACE, EGL_GL_COLORSPACE_SRGB, EGL_NONE };
+        gl->surface = p_eglCreateWindowSurface(egl_display,
+                                               pixel_formats[gl->format - 1].config,
+                                               (EGLNativeWindowType) gl->gbm_surface,
+                                               attribs);
+        if (!gl->surface)
+        {
+            TRACE("Failed to create EGL surface with SRGB colorspace, "
+                  "trying with default colorspace\n");
+        }
+    }
+
+    /* Try to create a surface with the default colorspace. */
+    if (!gl->surface)
+    {
+        gl->surface = p_eglCreateWindowSurface(egl_display,
+                                               pixel_formats[gl->format - 1].config,
+                                               (EGLNativeWindowType) gl->gbm_surface,
+                                               NULL);
+        if (!gl->surface)
+            ERR("Failed to create EGL surface\n");
+    }
+
+    if (gl->surface)
+    {
+        struct wgl_context *ctx;
+
+        wl_list_for_each(ctx, &gl_contexts, link)
+        {
+            if (ctx->draw_hwnd != gl->hwnd && ctx->read_hwnd != gl->hwnd) continue;
+            TRACE("hwnd %p refreshing %p %scurrent\n",
+                  gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
+            if (NtCurrentTeb()->glContext == ctx)
+                wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+            else
+                InterlockedExchange(&ctx->refresh, TRUE);
+        }
+    }
+
+    TRACE("hwnd=%p gbm_surface=%p egl_surface=%p\n",
+          gl->hwnd, gl->gbm_surface, gl->surface);
+
+    NtUserRedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+}
+
+static BOOL wayland_gl_surface_feedback_has_update(struct wayland_gl_drawable *gl)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback =
+        gl->wayland_surface ? gl->wayland_surface->glvk->surface_feedback : NULL;
+    BOOL ret = FALSE;
+
+    if (surface_feedback)
+    {
+        wayland_dmabuf_surface_feedback_lock(surface_feedback);
+        ret = surface_feedback->surface_needs_update;
+        surface_feedback->surface_needs_update = FALSE;
+        wayland_dmabuf_surface_feedback_unlock(surface_feedback);
+    }
+
+    TRACE("hwnd=%p => %d\n", gl->hwnd, ret);
+
+    return ret;
+}
+
+static BOOL wayland_gl_drawable_needs_resize(struct wayland_gl_drawable *gl)
+{
+    RECT client_rect;
+    BOOL ret;
+
+    NtUserGetClientRect(gl->hwnd, &client_rect);
+
+    ret = (client_rect.right > 0 && client_rect.bottom > 0 &&
+           (gl->width != client_rect.right || gl->height != client_rect.bottom));
+
+    TRACE("hwnd=%p client=%dx%d gl=%dx%d => %d\n",
+          gl->hwnd, (int)client_rect.right, (int)client_rect.bottom,
+          gl->width, gl->height, ret);
+
+    return ret;
+}
+
+static BOOL wayland_gl_drawable_needs_update(struct wayland_gl_drawable *gl)
+{
+    return wayland_gl_drawable_needs_resize(gl) || wayland_gl_surface_feedback_has_update(gl);
+}
+
+static void gbm_bo_destroy_callback(struct gbm_bo *bo, void *user_data)
+{
+    struct wayland_gl_buffer *gl_buffer = (struct wayland_gl_buffer *) user_data;
+    wayland_gl_buffer_destroy(gl_buffer);
+}
+
+static void dmabuf_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_gl_buffer *gl_buffer = (struct wayland_gl_buffer *) data;
+
+    TRACE("bo=%p\n", gl_buffer->gbm_bo);
+    wayland_gl_buffer_release(gl_buffer);
+}
+
+static const struct wl_buffer_listener dmabuf_buffer_listener = {
+    dmabuf_buffer_release
+};
+
+static struct wayland_gl_buffer *wayland_gl_drawable_track_buffer(struct wayland_gl_drawable *gl,
+                                                                  struct gbm_bo *bo)
+{
+    struct wayland_gl_buffer *gl_buffer =
+        (struct wayland_gl_buffer *) gbm_bo_get_user_data(bo);
+
+    if (!gl_buffer)
+    {
+        gl_buffer = calloc(1, sizeof(*gl_buffer));
+        if (!gl_buffer) goto err;
+
+        wl_list_init(&gl_buffer->link);
+        gl_buffer->gbm_bo = bo;
+        gl_buffer->gbm_surface = gl->gbm_surface;
+        if (!wayland_native_buffer_init_gbm(&gl_buffer->native_buffer, bo)) goto err;
+
+        if (gl->wayland_surface)
+        {
+            gl_buffer->dmabuf_buffer =
+                wayland_dmabuf_buffer_create_from_native(gl->wayland_surface->wayland,
+                                                         &gl_buffer->native_buffer);
+            wayland_native_buffer_deinit(&gl_buffer->native_buffer);
+            if (!gl_buffer->dmabuf_buffer) goto err;
+
+            wl_proxy_set_queue((struct wl_proxy *) gl_buffer->dmabuf_buffer->wl_buffer,
+                               gl->wl_event_queue);
+            wl_buffer_add_listener(gl_buffer->dmabuf_buffer->wl_buffer,
+                                   &dmabuf_buffer_listener, gl_buffer);
+        }
+
+        gbm_bo_set_user_data(bo, gl_buffer, gbm_bo_destroy_callback);
+        wl_list_insert(&gl->buffer_list, &gl_buffer->link);
+    }
+
+    return gl_buffer;
+
+err:
+    if (gl_buffer) wayland_gl_buffer_destroy(gl_buffer);
+    return NULL;
+}
+
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_gl_drawable *draw_gl = data;
+
+    TRACE("hwnd=%p\n", draw_gl->hwnd);
+    draw_gl->throttle_callback = NULL;
+    wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
+static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
+                                       struct wayland_gl_buffer *gl_buffer)
+{
+    BOOL committed = FALSE;
+
+    if (gl->remote_surface_proxy)
+    {
+        enum wayland_remote_buffer_commit buffer_commit =
+            gl->swap_interval > 0 ? WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED :
+                                    WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL;
+
+        if (!wayland_remote_surface_proxy_commit(gl->remote_surface_proxy,
+                                                 &gl_buffer->native_buffer,
+                                                 WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+                                                 buffer_commit,
+                                                 &gl_buffer->remote_buffer_released_event,
+                                                 &gl->remote_throttle_event))
+        {
+            gl_buffer->remote_buffer_released_event = 0;
+            gl->remote_throttle_event = 0;
+            return FALSE;
+        }
+
+        return TRUE;
+    }
+
+    wayland_mutex_lock(&gl->wayland_surface->mutex);
+    if (gl->wayland_surface->drawing_allowed)
+    {
+        struct wl_surface *gl_wl_surface = gl->wayland_surface->glvk->wl_surface;
+        wayland_surface_ensure_mapped(gl->wayland_surface);
+        wl_surface_attach(gl_wl_surface, gl_buffer->dmabuf_buffer->wl_buffer, 0, 0);
+        wl_surface_damage_buffer(gl_wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (gl->swap_interval > 0)
+        {
+            gl->throttle_callback = wl_surface_frame(gl_wl_surface);
+            wl_proxy_set_queue((struct wl_proxy *) gl->throttle_callback,
+                                gl->wl_event_queue);
+            wl_callback_add_listener(gl->throttle_callback, &throttle_listener, gl);
+        }
+        wl_surface_commit(gl_wl_surface);
+        committed = TRUE;
+    }
+    wayland_mutex_unlock(&gl->wayland_surface->mutex);
+
+    return committed;
+}
+
+/* Convert timeout in ms to the timeout format used by ntdll which is:
+ * 100ns units, negative for monotonic time. */
+static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
+{
+    if (timeout_ms == -1) return NULL;
+    time->QuadPart = (ULONGLONG)timeout_ms * -10000;
+    return time;
+}
+
+static DWORD wayland_gl_drawable_wait_remote_throttle(struct wayland_gl_drawable *gl,
+                                                      int timeout_ms)
+{
+    UINT ret;
+    LARGE_INTEGER timeout;
+
+    TRACE("gl->remote_throttle_event=%p timeout_ms=%d\n", gl->remote_throttle_event, timeout_ms);
+    if (!wayland_remote_surface_proxy_dispatch_events(gl->remote_surface_proxy))
+    {
+        ERR("Failed to dispatch remote events\n");
+        return WAIT_FAILED;
+    }
+
+    ret = NtWaitForSingleObject(gl->remote_throttle_event, FALSE,
+                                get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_OBJECT_0)
+    {
+        NtClose(gl->remote_throttle_event);
+        gl->remote_throttle_event = 0;
+    }
+
+    TRACE("=> ret=%d\n", ret);
+    return ret;
+}
+
+static UINT get_tick_count_since(UINT start)
+{
+    UINT now = NtGetTickCount();
+    /* Handle tick count wrap around to zero. */
+    if (now < start)
+        return 0xffffffff - start + now + 1;
+    else
+        return now - start;
+}
+
+static void wayland_gl_drawable_throttle(struct wayland_gl_drawable *gl)
+{
+    static const UINT timeout = 100;
+    UINT start, elapsed;
+
+    if (gl->swap_interval == 0) goto out;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    TRACE("throttle_callback=%p throttle_event=%p\n",
+          gl->throttle_callback, gl->remote_throttle_event);
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (elapsed < timeout &&
+           ((gl->throttle_callback &&
+             wayland_dispatch_queue(gl->wl_event_queue, timeout - elapsed) != -1) ||
+            (gl->remote_throttle_event &&
+             wayland_gl_drawable_wait_remote_throttle(gl, 10) != WAIT_FAILED)))
+    {
+        elapsed = get_tick_count_since(start);
+    }
+
+    TRACE("throttle_callback=%p throttle_event=%p => elapsed=%u\n",
+          gl->throttle_callback, gl->remote_throttle_event,
+          elapsed);
+
+out:
+    if (gl->throttle_callback)
+    {
+        wl_callback_destroy(gl->throttle_callback);
+        gl->throttle_callback = NULL;
+    }
+    if (gl->remote_throttle_event)
+    {
+        NtClose(gl->remote_throttle_event);
+        gl->remote_throttle_event = 0;
+    }
+}
+
+static DWORD wayland_gl_drawable_wait_remote(struct wayland_gl_drawable *gl,
+                                             int timeout_ms)
+{
+    struct wayland_gl_buffer *gl_buffer;
+    HANDLE handles[8];
+    struct wayland_gl_buffer *gl_buffers[8];
+    int count = 0;
+    LARGE_INTEGER timeout;
+    UINT ret;
+
+    if (!wayland_remote_surface_proxy_dispatch_events(gl->remote_surface_proxy))
+        return WAIT_FAILED;
+
+    wl_list_for_each(gl_buffer, &gl->buffer_list, link)
+    {
+        if (!gl_buffer->remote_buffer_released_event) continue;
+        handles[count] = gl_buffer->remote_buffer_released_event;
+        gl_buffers[count] = gl_buffer;
+        count++;
+    }
+
+    TRACE("count=%d handles=%p,%p,%p,%p\n",
+         count, handles[0], handles[1], handles[2], handles[3]);
+    ret = NtWaitForMultipleObjects(count, handles, TRUE, FALSE,
+                                   get_nt_timeout(&timeout, timeout_ms));
+    TRACE("count=%d => ret=%d\n", count, ret);
+    if (ret < WAIT_OBJECT_0 + count)
+        wayland_gl_buffer_release(gl_buffers[ret - WAIT_OBJECT_0]);
+
+    return ret;
+}
+
+static BOOL wgl_context_refresh(struct wgl_context *ctx)
+{
+    BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
+
+    if (ret)
+    {
+        TRACE("refreshing context %p hwnd %p/%p\n",
+              ctx->context, ctx->draw_hwnd, ctx->read_hwnd);
+        wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        NtUserRedrawWindow(ctx->draw_hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+    }
+    return ret;
+}
+
+static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
+{
+    struct wayland_gl_drawable *gl;
+    HWND hwnd = NtUserWindowFromDC(hdc);
+    int prev = 0;
+    BOOL needs_update = FALSE;
+
+    if (!hwnd || hwnd == NtUserGetDesktopWindow())
+    {
+        WARN("not a proper window DC %p/%p\n", hdc, hwnd);
+        return FALSE;
+    }
+    if (!is_onscreen_pixel_format(format))
+    {
+        WARN("Invalid format %d\n", format);
+        return FALSE;
+    }
+    TRACE("%p/%p format %d\n", hdc, hwnd, format);
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        prev = gl->format;
+        /* If we are changing formats, destroy any existing EGL surface so that
+         * it can be recreated by wayland_gl_drawable_update. */
+        if (allow_change && gl->format != format)
+        {
+            gl->format = format;
+            needs_update = TRUE;
+        }
+    }
+    else
+    {
+        gl = wayland_gl_drawable_create(hwnd, format);
+        needs_update = TRUE;
+    }
+
+    if (gl && needs_update) wayland_gl_drawable_update(gl);
+
+    wayland_gl_drawable_release(gl);
+
+    if (prev && prev != format && !allow_change) return FALSE;
+    if (gl->remote_surface_proxy || NtUserSetWindowPixelFormat(hwnd, format))
+        return TRUE;
+
+    wayland_destroy_gl_drawable(hwnd);
+    return FALSE;
+}
+
+struct egl_attribs
+{
+    EGLint *data;
+    int count;
+};
+
+static void egl_attribs_init(struct egl_attribs *attribs)
+{
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static void egl_attribs_add(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    EGLint *new_data = realloc(attribs->data,
+                               sizeof(*attribs->data) * (attribs->count + 2));
+    if (!new_data)
+    {
+        ERR("Could not allocate memory for EGL attributes!\n");
+        return;
+    }
+
+    attribs->data = new_data;
+    attribs->data[attribs->count] = name;
+    attribs->data[attribs->count + 1] = value;
+    attribs->count += 2;
+}
+
+
+static void egl_attribs_add_15_khr(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    BOOL has_egl_15 = egl_version[0] == 1 && egl_version[1] >= 5;
+
+    if (!has_egl_15 && !has_khr_create_context)
+    {
+        WARN("Ignoring EGL context attrib %#x not supported by EGL %d.%d\n",
+             name, egl_version[0], egl_version[1]);
+        return;
+    }
+
+    if (name == EGL_CONTEXT_FLAGS_KHR && has_egl_15)
+    {
+        egl_attribs_add(attribs, EGL_CONTEXT_OPENGL_DEBUG,
+                        (value & WGL_CONTEXT_DEBUG_BIT_ARB) ?
+                             EGL_TRUE : EGL_FALSE);
+        egl_attribs_add(attribs,
+                        EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE,
+                        (value & WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB) ?
+                            EGL_TRUE : EGL_FALSE);
+    }
+    else
+    {
+        egl_attribs_add(attribs, name, value);
+    }
+}
+
+static EGLint *egl_attribs_steal_finished_data(struct egl_attribs *attribs)
+{
+    EGLint *data = NULL;
+
+    if (attribs->data)
+    {
+        data = realloc(attribs->data,
+                       sizeof(*attribs->data) * (attribs->count + 1));
+        if (!data)
+        {
+            ERR("Could not allocate memory for EGL attributes!\n");
+        }
+        else
+        {
+            data[attribs->count] = EGL_NONE;
+            attribs->data = NULL;
+            attribs->count = 0;
+        }
+    }
+
+    return data;
+}
+
+static void egl_attribs_deinit(struct egl_attribs *attribs)
+{
+    free(attribs->data);
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
+                                          struct egl_attribs *attribs)
+{
+    struct wayland_gl_drawable *gl;
+    struct wgl_context *ctx;
+
+    if (!(gl = wayland_gl_drawable_get(NtUserWindowFromDC(hdc)))) return NULL;
+
+    ctx = malloc(sizeof(*ctx));
+    if (!ctx)
+    {
+        ERR("Failed to allocate memory for GL context\n");
+        goto out;
+    }
+
+    ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->attribs = attribs ? egl_attribs_steal_finished_data(attribs) : NULL;
+    ctx->context = p_eglCreateContext(egl_display, ctx->config,
+                                      share ? share->context : EGL_NO_CONTEXT,
+                                      ctx->attribs);
+    ctx->draw_hwnd = 0;
+    ctx->read_hwnd = 0;
+    ctx->refresh = FALSE;
+    ctx->has_been_current = FALSE;
+    ctx->sharing = FALSE;
+    ctx->is_draw_buffer_front = FALSE;
+
+    /* The gl_object_mutex, which is locked when we get the gl_drawable,
+     * also guards access to gl_contexts, so it's safe to add the entry here. */
+    wl_list_insert(&gl_contexts, &ctx->link);
+
+out:
+    wayland_gl_drawable_release(gl);
+
+    TRACE("ctx=%p hdc=%p fmt=%d egl_ctx=%p\n",
+          ctx, hdc, gl->format, ctx ? ctx->context : NULL);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglCopyContext
+ */
+static BOOL wayland_wglCopyContext(struct wgl_context *src,
+                                   struct wgl_context *dst, UINT mask)
+{
+    FIXME("%p -> %p mask %#x unsupported\n", src, dst, mask);
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContext
+ */
+static struct wgl_context *wayland_wglCreateContext(HDC hdc)
+{
+    TRACE("hdc=%p\n", hdc);
+
+    p_eglBindAPI(EGL_OPENGL_API);
+
+    return create_context(hdc, NULL, NULL);
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContextAttribsARB
+ */
+static struct wgl_context *wayland_wglCreateContextAttribsARB(HDC hdc,
+                                                              struct wgl_context *share,
+                                                              const int *attribs)
+{
+    struct egl_attribs egl_attribs = {0};
+    EGLenum api_type = EGL_OPENGL_API;
+    EGLenum profile_mask;
+    struct wgl_context *ctx;
+
+    egl_attribs_init(&egl_attribs);
+
+    TRACE("hdc=%p share=%p attribs=%p\n", hdc, share, attribs);
+
+    while (attribs && *attribs)
+    {
+        TRACE("%#x %#x\n", attribs[0], attribs[1]);
+        switch (*attribs)
+        {
+        case WGL_CONTEXT_PROFILE_MASK_ARB:
+            profile_mask = 0;
+            if (attribs[1] & WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+                api_type = EGL_OPENGL_ES_API;
+            if (attribs[1] & WGL_CONTEXT_CORE_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT;
+            if (attribs[1] & WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT;
+            /* If the WGL profile mask doesn't have ES2 as the only set bit,
+             * pass the mask to EGL. Note that this will also pass empty
+             * WGL masks, in order to elicit the respective EGL error. */
+            if (attribs[1] != WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+            {
+                egl_attribs_add_15_khr(&egl_attribs,
+                                       EGL_CONTEXT_OPENGL_PROFILE_MASK, profile_mask);
+            }
+            break;
+        case WGL_CONTEXT_MAJOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MAJOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_MINOR_VERSION_ARB:
+            egl_attribs_add_15_khr(&egl_attribs, EGL_CONTEXT_MINOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_FLAGS_ARB:
+            egl_attribs_add_15_khr(&egl_attribs, EGL_CONTEXT_FLAGS_KHR, attribs[1]);
+            break;
+        default:
+            FIXME("Unhandled attributes: %#x %#x\n", attribs[0], attribs[1]);
+        }
+        attribs += 2;
+    }
+
+    p_eglBindAPI(api_type);
+
+    ctx = create_context(hdc, share, &egl_attribs);
+
+    egl_attribs_deinit(&egl_attribs);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglDeleteContext
+ */
+static BOOL wayland_wglDeleteContext(struct wgl_context *ctx)
+{
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_remove(&ctx->link);
+    wayland_mutex_unlock(&gl_object_mutex);
+    p_eglDestroyContext(egl_display, ctx->context);
+    free(ctx->attribs);
+    free(ctx);
+    return TRUE;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeContextCurrentARB
+ */
+static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
+                                             struct wgl_context *ctx)
+{
+    BOOL ret = FALSE;
+
+    TRACE("draw_hdc=%p read_hdc=%p ctx=%p\n", draw_hdc, read_hdc, ctx);
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    ret = wgl_context_make_current(ctx, NtUserWindowFromDC(draw_hdc), NtUserWindowFromDC(read_hdc));
+    if (!ret) RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
+
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeCurrent
+ */
+static BOOL wayland_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+{
+    return wayland_wglMakeContextCurrentARB(hdc, hdc, ctx);
+}
+
+/***********************************************************************
+ *		wayland_wglDescribePixelFormat
+ */
+static int wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
+                                          PIXELFORMATDESCRIPTOR *pfd)
+{
+    EGLint val;
+    EGLConfig config;
+
+    if (!pfd) return nb_onscreen_formats;
+    if (!is_onscreen_pixel_format(fmt)) return 0;
+    if (size < sizeof(*pfd)) return 0;
+    config = pixel_formats[fmt - 1].config;
+
+    memset(pfd, 0, sizeof(*pfd));
+    pfd->nSize = sizeof(*pfd);
+    pfd->nVersion = 1;
+    pfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
+                   PFD_SUPPORT_COMPOSITION;
+    pfd->iPixelType = PFD_TYPE_RGBA;
+    pfd->iLayerType = PFD_MAIN_PLANE;
+
+    p_eglGetConfigAttrib(egl_display, config, EGL_BUFFER_SIZE, &val);
+    pfd->cColorBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_RED_SIZE, &val);
+    pfd->cRedBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_GREEN_SIZE, &val);
+    pfd->cGreenBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_BLUE_SIZE, &val);
+    pfd->cBlueBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_ALPHA_SIZE, &val);
+    pfd->cAlphaBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_DEPTH_SIZE, &val);
+    pfd->cDepthBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_STENCIL_SIZE, &val);
+    pfd->cStencilBits = val;
+
+    pfd->cAlphaShift = 0;
+    pfd->cBlueShift = pfd->cAlphaShift + pfd->cAlphaBits;
+    pfd->cGreenShift = pfd->cBlueShift + pfd->cBlueBits;
+    pfd->cRedShift = pfd->cGreenShift + pfd->cGreenBits;
+
+    TRACE("fmt %u color %u %u/%u/%u/%u depth %u stencil %u\n",
+           fmt, pfd->cColorBits, pfd->cRedBits, pfd->cGreenBits, pfd->cBlueBits,
+           pfd->cAlphaBits, pfd->cDepthBits, pfd->cStencilBits);
+    return nb_onscreen_formats;
+}
+
+/***********************************************************************
+ *		wayland_wglGetPixelFormat
+ */
+static int wayland_wglGetPixelFormat(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    int ret = 0;
+
+    if ((gl = wayland_gl_drawable_get(NtUserWindowFromDC(hdc))))
+    {
+        ret = gl->format;
+        /* offscreen formats can't be used with traditional WGL calls */
+        if (!is_onscreen_pixel_format(ret)) ret = 1;
+        wayland_gl_drawable_release(gl);
+    }
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglGetProcAddress
+ */
+static PROC wayland_wglGetProcAddress(LPCSTR name)
+{
+    PROC ret;
+    if (!strncmp(name, "wgl", 3)) return NULL;
+    ret = (PROC)p_eglGetProcAddress(name);
+    TRACE("%s -> %p\n", name, ret);
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormat
+ */
+static BOOL wayland_wglSetPixelFormat(HDC hdc, int format,
+                                      const PIXELFORMATDESCRIPTOR *pfd)
+{
+    return set_pixel_format(hdc, format, FALSE);
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormatWINE
+ */
+static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
+{
+    return set_pixel_format(hdc, format, TRUE);
+}
+
+/***********************************************************************
+ *		wayland_wglShareLists
+ */
+static BOOL wayland_wglShareLists(struct wgl_context *org,
+                                  struct wgl_context *dest)
+{
+    TRACE("(%p, %p)\n", org, dest);
+
+    /* Sharing of display lists works differently in EGL and WGL. In case of
+     * EGL it is done at context creation time but in case of EGL it can also
+     * be done using wglShareLists.
+     *
+     * We handle this by creating an EGL context in wglCreateContext /
+     * wglCreateContextAttribsARB and when a program requests sharing we
+     * recreate the destination context if it hasn't been made current and
+     * it hasn't shared display lists before.
+     */
+
+    if (dest->has_been_current)
+    {
+        ERR("Could not share display lists, the hglrc2 context has been current already!\n");
+        return FALSE;
+    }
+    else if (dest->sharing)
+    {
+        ERR("Could not share display lists because hglrc2 has already shared lists before!\n");
+        return FALSE;
+    }
+    else
+    {
+        /* Re-create the EGL context and share display lists */
+        p_eglDestroyContext(egl_display, dest->context);
+        dest->context = p_eglCreateContext(egl_display, dest->config,
+                                           org->context, dest->attribs);
+        TRACE("re-created EGL context (%p) for WGL context %p (config: %p) "
+              "sharing lists with EGL context %p for WGL context %p (config: %p)\n",
+              dest->context, dest, dest->config, org->context, org, org->config);
+        org->sharing = TRUE;
+        dest->sharing = TRUE;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglSwapBuffers
+ */
+static BOOL wayland_wglSwapBuffers(HDC hdc)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    HWND hwnd = NtUserWindowFromDC(hdc);
+    struct wayland_gl_drawable *draw_gl = wayland_gl_drawable_get(hwnd);
+
+    TRACE("hdc %p hwnd %p ctx %p\n", hdc, hwnd, ctx);
+
+    if (draw_gl && wayland_gl_drawable_needs_update(draw_gl))
+    {
+        wayland_gl_drawable_update(draw_gl);
+        goto out;
+    }
+
+    if ((!ctx || !wgl_context_refresh(ctx)) && draw_gl && draw_gl->surface)
+    {
+        struct wayland_gl_buffer *gl_buffer;
+        struct gbm_bo *bo;
+
+        wayland_gl_drawable_throttle(draw_gl);
+
+        p_eglSwapBuffers(egl_display, draw_gl->surface);
+
+        bo = gbm_surface_lock_front_buffer(draw_gl->gbm_surface);
+        if (!bo)
+        {
+            ERR("Failed to lock front buffer\n");
+            goto out;
+        }
+        gl_buffer = wayland_gl_drawable_track_buffer(draw_gl, bo);
+
+        if (!wayland_gl_drawable_commit(draw_gl, gl_buffer))
+            gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
+
+        /* Wait until we have a free buffer for the application to render into
+         * before we continue. */
+        if (draw_gl->wayland_surface)
+        {
+            while (!gbm_surface_has_free_buffers(draw_gl->gbm_surface) &&
+                   wayland_dispatch_queue(draw_gl->wl_event_queue, -1) != -1)
+            {
+                continue;
+            }
+        }
+        else if (draw_gl->remote_surface_proxy)
+        {
+            static const DWORD wait_timeout = 100;
+            DWORD wait_start = NtGetTickCount();
+            /* If we don't get a free buffer within the specified timeout, drop
+             * one of the previous buffers to ensure we can continue and avoid
+             * potential cross-process deadlocks (e.g., the render process
+             * waiting for the window process to dispatch buffer release messages,
+             * while the window process is waiting for the render process to finish
+             * rendering). */
+            while (!gbm_surface_has_free_buffers(draw_gl->gbm_surface) &&
+                   wayland_gl_drawable_wait_remote(draw_gl, 10) != WAIT_FAILED)
+            {
+                if (get_tick_count_since(wait_start) > wait_timeout)
+                {
+                    struct wayland_gl_buffer *to_release;
+                    wl_list_for_each(to_release, &draw_gl->buffer_list, link)
+                        if (to_release != gl_buffer) break;
+                    wayland_gl_buffer_release(to_release);
+                }
+            }
+        }
+    }
+
+out:
+    wayland_gl_drawable_release(draw_gl);
+
+    return TRUE;
+}
+
+static void wayland_glDrawBuffer(GLenum mode)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    GLint draw_fbo = -1;
+
+    if (!ctx) return;
+
+    egl_funcs.gl.p_glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &draw_fbo);
+
+    TRACE("hwnd %p egl_context %p mode 0x%x draw_fbo %d\n",
+          ctx->draw_hwnd, ctx->context, mode, draw_fbo);
+
+    if (draw_fbo == 0)
+    {
+        BOOL is_draw_buffer_front = (mode == GL_FRONT || mode == GL_FRONT_LEFT);
+        /* Disable the window front buffer if we have one and it's not needed
+         * any longer.  */
+        if (ctx->is_draw_buffer_front && !is_draw_buffer_front)
+            wayland_update_front_buffer(ctx->draw_hwnd, NULL);
+        ctx->is_draw_buffer_front = is_draw_buffer_front;
+    }
+
+    p_glDrawBuffer(mode);
+}
+
+static void read_front_buffer_pixels(void *pixels_out, int width, int height)
+{
+    GLenum prev_read_buffer;
+    GLint prev_read_framebuffer;
+    GLint prev_row_length;
+    GLint prev_image_height;
+    GLint prev_skip_rows;
+    GLint prev_skip_pixels;
+    GLint prev_skip_images;
+    GLint prev_alignment;
+
+    /* Store state we might change */
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_BUFFER, (GLint*)&prev_read_buffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &prev_read_framebuffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ROW_LENGTH, &prev_row_length);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_IMAGE_HEIGHT, &prev_image_height);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_ROWS, &prev_skip_rows);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_PIXELS, &prev_skip_pixels);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_IMAGES, &prev_skip_images);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ALIGNMENT, &prev_alignment);
+
+    /* Set state we need for reading the pixels */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+    egl_funcs.gl.p_glReadBuffer(GL_FRONT);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    egl_funcs.gl.p_glReadPixels(0, 0, width, height, GL_BGRA,  GL_UNSIGNED_BYTE,
+                                pixels_out);
+
+    /* Restore prev state */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, prev_read_framebuffer);
+    egl_funcs.gl.p_glReadBuffer(prev_read_buffer);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, prev_row_length);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, prev_image_height);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, prev_skip_rows);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, prev_skip_pixels);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, prev_skip_images);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, prev_alignment);
+}
+
+static void wayland_glFinish(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFinish();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
+}
+
+static void wayland_glFlush(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFlush();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
+}
+
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static int wayland_wglGetSwapIntervalEXT(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+    int swap_interval;
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        /* This can't happen because a current WGL context is required to get
+         * here. Likely the application is buggy.
+         */
+        WARN("No GL drawable found, returning swap interval 0\n");
+        return 0;
+    }
+
+    swap_interval = gl->swap_interval;
+    wayland_gl_drawable_release(gl);
+
+    return swap_interval;
+}
+
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static BOOL wayland_wglSwapIntervalEXT(int interval)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+
+    TRACE("(%d)\n", interval);
+
+    if (interval < 0)
+    {
+        RtlSetLastWin32Error(ERROR_INVALID_DATA);
+        return FALSE;
+    }
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
+        return FALSE;
+    }
+
+    gl->swap_interval = interval;
+
+    wayland_gl_drawable_release(gl);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringARB
+ */
+static const char *wayland_wglGetExtensionsStringARB(HDC hdc)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringEXT
+ */
+static const char *wayland_wglGetExtensionsStringEXT(void)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+static void register_extension(const char *ext)
+{
+    if (wgl_extensions[0]) strcat(wgl_extensions, " ");
+    strcat(wgl_extensions, ext);
+    TRACE("%s\n", ext);
+}
+
+static BOOL has_extension(const char *list, const char *ext)
+{
+    size_t len = strlen(ext);
+    const char *cur = list;
+
+    if (!cur) return FALSE;
+
+    while ((cur = strstr(cur, ext)))
+    {
+        if ((!cur[len] || cur[len] == ' ') && (cur == list || cur[-1] == ' '))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void init_extensions(int major, int minor)
+{
+    void *ptr;
+    const char *egl_exts = p_eglQueryString(egl_display, EGL_EXTENSIONS);
+
+    register_extension("WGL_ARB_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
+
+    register_extension("WGL_EXT_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
+
+    /* In WineD3D we need the ability to set the pixel format more than once
+     * (e.g. after a device reset).  The default wglSetPixelFormat doesn't
+     * allow this, so add our own which allows it.
+     */
+    register_extension("WGL_WINE_pixel_format_passthrough");
+    egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
+
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
+
+    register_extension("WGL_ARB_create_context");
+    register_extension("WGL_ARB_create_context_profile");
+    egl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
+
+    if (has_extension(egl_exts, "EGL_KHR_create_context"))
+        has_khr_create_context = TRUE;
+
+    register_extension("WGL_EXT_swap_control");
+    egl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
+    egl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
+
+    if ((major == 1 && minor >= 5) || has_extension(egl_exts, "EGL_KHR_gl_colorspace"))
+    {
+        register_extension("WGL_EXT_framebuffer_sRGB");
+        has_gl_colorspace = TRUE;
+    }
+
+    /* load standard functions and extensions exported from the OpenGL library */
+
+#define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
+    ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+#define LOAD_FUNCPTR(func) egl_funcs.ext.p_##func = dlsym(opengl_handle, #func)
+    LOAD_FUNCPTR(glActiveShaderProgram);
+    LOAD_FUNCPTR(glActiveTexture);
+    LOAD_FUNCPTR(glAttachShader);
+    LOAD_FUNCPTR(glBeginQuery);
+    LOAD_FUNCPTR(glBeginTransformFeedback);
+    LOAD_FUNCPTR(glBindAttribLocation);
+    LOAD_FUNCPTR(glBindBuffer);
+    LOAD_FUNCPTR(glBindBufferBase);
+    LOAD_FUNCPTR(glBindBufferRange);
+    LOAD_FUNCPTR(glBindFramebuffer);
+    LOAD_FUNCPTR(glBindImageTexture);
+    LOAD_FUNCPTR(glBindProgramPipeline);
+    LOAD_FUNCPTR(glBindRenderbuffer);
+    LOAD_FUNCPTR(glBindSampler);
+    LOAD_FUNCPTR(glBindTransformFeedback);
+    LOAD_FUNCPTR(glBindVertexArray);
+    LOAD_FUNCPTR(glBindVertexBuffer);
+    LOAD_FUNCPTR(glBlendBarrierKHR);
+    LOAD_FUNCPTR(glBlendColor);
+    LOAD_FUNCPTR(glBlendEquation);
+    LOAD_FUNCPTR(glBlendEquationSeparate);
+    LOAD_FUNCPTR(glBlendFuncSeparate);
+    LOAD_FUNCPTR(glBlitFramebuffer);
+    LOAD_FUNCPTR(glBufferData);
+    LOAD_FUNCPTR(glBufferSubData);
+    LOAD_FUNCPTR(glCheckFramebufferStatus);
+    LOAD_FUNCPTR(glClearBufferfi);
+    LOAD_FUNCPTR(glClearBufferfv);
+    LOAD_FUNCPTR(glClearBufferiv);
+    LOAD_FUNCPTR(glClearBufferuiv);
+    LOAD_FUNCPTR(glClearDepthf);
+    LOAD_FUNCPTR(glClientWaitSync);
+    LOAD_FUNCPTR(glCompileShader);
+    LOAD_FUNCPTR(glCompressedTexImage2D);
+    LOAD_FUNCPTR(glCompressedTexImage3D);
+    LOAD_FUNCPTR(glCompressedTexSubImage2D);
+    LOAD_FUNCPTR(glCompressedTexSubImage3D);
+    LOAD_FUNCPTR(glCopyBufferSubData);
+    LOAD_FUNCPTR(glCopyTexSubImage3D);
+    LOAD_FUNCPTR(glCreateProgram);
+    LOAD_FUNCPTR(glCreateShader);
+    LOAD_FUNCPTR(glCreateShaderProgramv);
+    LOAD_FUNCPTR(glDeleteBuffers);
+    LOAD_FUNCPTR(glDeleteFramebuffers);
+    LOAD_FUNCPTR(glDeleteProgram);
+    LOAD_FUNCPTR(glDeleteProgramPipelines);
+    LOAD_FUNCPTR(glDeleteQueries);
+    LOAD_FUNCPTR(glDeleteRenderbuffers);
+    LOAD_FUNCPTR(glDeleteSamplers);
+    LOAD_FUNCPTR(glDeleteShader);
+    LOAD_FUNCPTR(glDeleteSync);
+    LOAD_FUNCPTR(glDeleteTransformFeedbacks);
+    LOAD_FUNCPTR(glDeleteVertexArrays);
+    LOAD_FUNCPTR(glDepthRangef);
+    LOAD_FUNCPTR(glDetachShader);
+    LOAD_FUNCPTR(glDisableVertexAttribArray);
+    LOAD_FUNCPTR(glDispatchCompute);
+    LOAD_FUNCPTR(glDispatchComputeIndirect);
+    LOAD_FUNCPTR(glDrawArraysIndirect);
+    LOAD_FUNCPTR(glDrawArraysInstanced);
+    LOAD_FUNCPTR(glDrawBuffers);
+    LOAD_FUNCPTR(glDrawElementsIndirect);
+    LOAD_FUNCPTR(glDrawElementsInstanced);
+    LOAD_FUNCPTR(glDrawRangeElements);
+    LOAD_FUNCPTR(glEnableVertexAttribArray);
+    LOAD_FUNCPTR(glEndQuery);
+    LOAD_FUNCPTR(glEndTransformFeedback);
+    LOAD_FUNCPTR(glFenceSync);
+    LOAD_FUNCPTR(glFlushMappedBufferRange);
+    LOAD_FUNCPTR(glFramebufferParameteri);
+    LOAD_FUNCPTR(glFramebufferRenderbuffer);
+    LOAD_FUNCPTR(glFramebufferTexture2D);
+    LOAD_FUNCPTR(glFramebufferTextureEXT);
+    LOAD_FUNCPTR(glFramebufferTextureLayer);
+    LOAD_FUNCPTR(glGenBuffers);
+    LOAD_FUNCPTR(glGenFramebuffers);
+    LOAD_FUNCPTR(glGenProgramPipelines);
+    LOAD_FUNCPTR(glGenQueries);
+    LOAD_FUNCPTR(glGenRenderbuffers);
+    LOAD_FUNCPTR(glGenSamplers);
+    LOAD_FUNCPTR(glGenTransformFeedbacks);
+    LOAD_FUNCPTR(glGenVertexArrays);
+    LOAD_FUNCPTR(glGenerateMipmap);
+    LOAD_FUNCPTR(glGetActiveAttrib);
+    LOAD_FUNCPTR(glGetActiveUniform);
+    LOAD_FUNCPTR(glGetActiveUniformBlockName);
+    LOAD_FUNCPTR(glGetActiveUniformBlockiv);
+    LOAD_FUNCPTR(glGetActiveUniformsiv);
+    LOAD_FUNCPTR(glGetAttachedShaders);
+    LOAD_FUNCPTR(glGetAttribLocation);
+    LOAD_FUNCPTR(glGetBooleani_v);
+    LOAD_FUNCPTR(glGetBufferParameteri64v);
+    LOAD_FUNCPTR(glGetBufferParameteriv);
+    LOAD_FUNCPTR(glGetBufferPointerv);
+    LOAD_FUNCPTR(glGetFragDataLocation);
+    LOAD_FUNCPTR(glGetFramebufferAttachmentParameteriv);
+    LOAD_FUNCPTR(glGetFramebufferParameteriv);
+    LOAD_FUNCPTR(glGetInteger64i_v);
+    LOAD_FUNCPTR(glGetInteger64v);
+    LOAD_FUNCPTR(glGetIntegeri_v);
+    LOAD_FUNCPTR(glGetInternalformativ);
+    LOAD_FUNCPTR(glGetMultisamplefv);
+    LOAD_FUNCPTR(glGetProgramBinary);
+    LOAD_FUNCPTR(glGetProgramInfoLog);
+    LOAD_FUNCPTR(glGetProgramInterfaceiv);
+    LOAD_FUNCPTR(glGetProgramPipelineInfoLog);
+    LOAD_FUNCPTR(glGetProgramPipelineiv);
+    LOAD_FUNCPTR(glGetProgramResourceIndex);
+    LOAD_FUNCPTR(glGetProgramResourceLocation);
+    LOAD_FUNCPTR(glGetProgramResourceName);
+    LOAD_FUNCPTR(glGetProgramResourceiv);
+    LOAD_FUNCPTR(glGetProgramiv);
+    LOAD_FUNCPTR(glGetQueryObjectuiv);
+    LOAD_FUNCPTR(glGetQueryiv);
+    LOAD_FUNCPTR(glGetRenderbufferParameteriv);
+    LOAD_FUNCPTR(glGetSamplerParameterfv);
+    LOAD_FUNCPTR(glGetSamplerParameteriv);
+    LOAD_FUNCPTR(glGetShaderInfoLog);
+    LOAD_FUNCPTR(glGetShaderPrecisionFormat);
+    LOAD_FUNCPTR(glGetShaderSource);
+    LOAD_FUNCPTR(glGetShaderiv);
+    LOAD_FUNCPTR(glGetStringi);
+    LOAD_FUNCPTR(glGetSynciv);
+    LOAD_FUNCPTR(glGetTexParameterIivEXT);
+    LOAD_FUNCPTR(glGetTexParameterIuivEXT);
+    LOAD_FUNCPTR(glGetTransformFeedbackVarying);
+    LOAD_FUNCPTR(glGetUniformBlockIndex);
+    LOAD_FUNCPTR(glGetUniformIndices);
+    LOAD_FUNCPTR(glGetUniformLocation);
+    LOAD_FUNCPTR(glGetUniformfv);
+    LOAD_FUNCPTR(glGetUniformiv);
+    LOAD_FUNCPTR(glGetUniformuiv);
+    LOAD_FUNCPTR(glGetVertexAttribIiv);
+    LOAD_FUNCPTR(glGetVertexAttribIuiv);
+    LOAD_FUNCPTR(glGetVertexAttribPointerv);
+    LOAD_FUNCPTR(glGetVertexAttribfv);
+    LOAD_FUNCPTR(glGetVertexAttribiv);
+    LOAD_FUNCPTR(glInvalidateFramebuffer);
+    LOAD_FUNCPTR(glInvalidateSubFramebuffer);
+    LOAD_FUNCPTR(glIsBuffer);
+    LOAD_FUNCPTR(glIsFramebuffer);
+    LOAD_FUNCPTR(glIsProgram);
+    LOAD_FUNCPTR(glIsProgramPipeline);
+    LOAD_FUNCPTR(glIsQuery);
+    LOAD_FUNCPTR(glIsRenderbuffer);
+    LOAD_FUNCPTR(glIsSampler);
+    LOAD_FUNCPTR(glIsShader);
+    LOAD_FUNCPTR(glIsSync);
+    LOAD_FUNCPTR(glIsTransformFeedback);
+    LOAD_FUNCPTR(glIsVertexArray);
+    LOAD_FUNCPTR(glLinkProgram);
+    LOAD_FUNCPTR(glMapBufferRange);
+    LOAD_FUNCPTR(glMemoryBarrier);
+    LOAD_FUNCPTR(glMemoryBarrierByRegion);
+    LOAD_FUNCPTR(glPauseTransformFeedback);
+    LOAD_FUNCPTR(glProgramBinary);
+    LOAD_FUNCPTR(glProgramParameteri);
+    LOAD_FUNCPTR(glProgramUniform1f);
+    LOAD_FUNCPTR(glProgramUniform1fv);
+    LOAD_FUNCPTR(glProgramUniform1i);
+    LOAD_FUNCPTR(glProgramUniform1iv);
+    LOAD_FUNCPTR(glProgramUniform1ui);
+    LOAD_FUNCPTR(glProgramUniform1uiv);
+    LOAD_FUNCPTR(glProgramUniform2f);
+    LOAD_FUNCPTR(glProgramUniform2fv);
+    LOAD_FUNCPTR(glProgramUniform2i);
+    LOAD_FUNCPTR(glProgramUniform2iv);
+    LOAD_FUNCPTR(glProgramUniform2ui);
+    LOAD_FUNCPTR(glProgramUniform2uiv);
+    LOAD_FUNCPTR(glProgramUniform3f);
+    LOAD_FUNCPTR(glProgramUniform3fv);
+    LOAD_FUNCPTR(glProgramUniform3i);
+    LOAD_FUNCPTR(glProgramUniform3iv);
+    LOAD_FUNCPTR(glProgramUniform3ui);
+    LOAD_FUNCPTR(glProgramUniform3uiv);
+    LOAD_FUNCPTR(glProgramUniform4f);
+    LOAD_FUNCPTR(glProgramUniform4fv);
+    LOAD_FUNCPTR(glProgramUniform4i);
+    LOAD_FUNCPTR(glProgramUniform4iv);
+    LOAD_FUNCPTR(glProgramUniform4ui);
+    LOAD_FUNCPTR(glProgramUniform4uiv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glReleaseShaderCompiler);
+    LOAD_FUNCPTR(glRenderbufferStorage);
+    LOAD_FUNCPTR(glRenderbufferStorageMultisample);
+    LOAD_FUNCPTR(glResumeTransformFeedback);
+    LOAD_FUNCPTR(glSampleCoverage);
+    LOAD_FUNCPTR(glSampleMaski);
+    LOAD_FUNCPTR(glSamplerParameterf);
+    LOAD_FUNCPTR(glSamplerParameterfv);
+    LOAD_FUNCPTR(glSamplerParameteri);
+    LOAD_FUNCPTR(glSamplerParameteriv);
+    LOAD_FUNCPTR(glShaderBinary);
+    LOAD_FUNCPTR(glShaderSource);
+    LOAD_FUNCPTR(glStencilFuncSeparate);
+    LOAD_FUNCPTR(glStencilMaskSeparate);
+    LOAD_FUNCPTR(glStencilOpSeparate);
+    LOAD_FUNCPTR(glTexBufferEXT);
+    LOAD_FUNCPTR(glTexImage3D);
+    LOAD_FUNCPTR(glTexParameterIivEXT);
+    LOAD_FUNCPTR(glTexParameterIuivEXT);
+    LOAD_FUNCPTR(glTexStorage2D);
+    LOAD_FUNCPTR(glTexStorage2DMultisample);
+    LOAD_FUNCPTR(glTexStorage3D);
+    LOAD_FUNCPTR(glTexSubImage3D);
+    LOAD_FUNCPTR(glTransformFeedbackVaryings);
+    LOAD_FUNCPTR(glUniform1f);
+    LOAD_FUNCPTR(glUniform1fv);
+    LOAD_FUNCPTR(glUniform1i);
+    LOAD_FUNCPTR(glUniform1iv);
+    LOAD_FUNCPTR(glUniform1ui);
+    LOAD_FUNCPTR(glUniform1uiv);
+    LOAD_FUNCPTR(glUniform2f);
+    LOAD_FUNCPTR(glUniform2fv);
+    LOAD_FUNCPTR(glUniform2i);
+    LOAD_FUNCPTR(glUniform2iv);
+    LOAD_FUNCPTR(glUniform2ui);
+    LOAD_FUNCPTR(glUniform2uiv);
+    LOAD_FUNCPTR(glUniform3f);
+    LOAD_FUNCPTR(glUniform3fv);
+    LOAD_FUNCPTR(glUniform3i);
+    LOAD_FUNCPTR(glUniform3iv);
+    LOAD_FUNCPTR(glUniform3ui);
+    LOAD_FUNCPTR(glUniform3uiv);
+    LOAD_FUNCPTR(glUniform4f);
+    LOAD_FUNCPTR(glUniform4fv);
+    LOAD_FUNCPTR(glUniform4i);
+    LOAD_FUNCPTR(glUniform4iv);
+    LOAD_FUNCPTR(glUniform4ui);
+    LOAD_FUNCPTR(glUniform4uiv);
+    LOAD_FUNCPTR(glUniformBlockBinding);
+    LOAD_FUNCPTR(glUniformMatrix2fv);
+    LOAD_FUNCPTR(glUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glUniformMatrix3fv);
+    LOAD_FUNCPTR(glUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glUniformMatrix4fv);
+    LOAD_FUNCPTR(glUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glUnmapBuffer);
+    LOAD_FUNCPTR(glUseProgram);
+    LOAD_FUNCPTR(glUseProgramStages);
+    LOAD_FUNCPTR(glValidateProgram);
+    LOAD_FUNCPTR(glValidateProgramPipeline);
+    LOAD_FUNCPTR(glVertexAttrib1f);
+    LOAD_FUNCPTR(glVertexAttrib1fv);
+    LOAD_FUNCPTR(glVertexAttrib2f);
+    LOAD_FUNCPTR(glVertexAttrib2fv);
+    LOAD_FUNCPTR(glVertexAttrib3f);
+    LOAD_FUNCPTR(glVertexAttrib3fv);
+    LOAD_FUNCPTR(glVertexAttrib4f);
+    LOAD_FUNCPTR(glVertexAttrib4fv);
+    LOAD_FUNCPTR(glVertexAttribBinding);
+    LOAD_FUNCPTR(glVertexAttribDivisor);
+    LOAD_FUNCPTR(glVertexAttribFormat);
+    LOAD_FUNCPTR(glVertexAttribI4i);
+    LOAD_FUNCPTR(glVertexAttribI4iv);
+    LOAD_FUNCPTR(glVertexAttribI4ui);
+    LOAD_FUNCPTR(glVertexAttribI4uiv);
+    LOAD_FUNCPTR(glVertexAttribIFormat);
+    LOAD_FUNCPTR(glVertexAttribIPointer);
+    LOAD_FUNCPTR(glVertexAttribPointer);
+    LOAD_FUNCPTR(glVertexBindingDivisor);
+    LOAD_FUNCPTR(glWaitSync);
+#undef LOAD_FUNCPTR
+
+    /* Redirect some standard OpenGL functions. */
+
+#define REDIRECT(func) \
+    do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glDrawBuffer);
+    REDIRECT(glFinish);
+    REDIRECT(glFlush);
+#undef REDIRECT
+}
+
+static BOOL init_pixel_formats(void)
+{
+    EGLint count, i, pass;
+    EGLConfig *egl_configs = NULL;
+    struct wayland_dmabuf *dmabuf = NULL;
+    dev_t render_dev;
+
+    p_eglGetConfigs(egl_display, NULL, 0, &count);
+    if (!count)
+    {
+        ERR("eglGetConfigs returned no configs.\n");
+        goto err;
+    }
+
+    if (!(egl_configs = malloc(count * sizeof(*egl_configs))) ||
+        !(pixel_formats = malloc(count * sizeof(*pixel_formats))))
+    {
+        ERR("Memory allocation failed.\n");
+        goto err;
+    }
+    p_eglGetConfigs(egl_display, egl_configs, count, &count);
+
+    if (!(render_dev = wayland_gbm_get_render_dev()))
+    {
+        ERR("Failed to get device's dev_t from GBM device.\n");
+        goto err;
+    }
+
+    dmabuf = &wayland_process_acquire()->dmabuf;
+    /* Use two passes: the first pass adds the onscreen formats to the format list,
+     * the second offscreen ones. */
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_SURFACE_TYPE, &type);
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+
+            /* Ignore formats not supported by the compositor. */
+            if (!wayland_dmabuf_is_format_supported(dmabuf, visual_id, render_dev))
+                continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_COLOR_BUFFER_TYPE, &color);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RED_SIZE, &r);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_GREEN_SIZE, &g);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_BLUE_SIZE, &b);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_DEPTH_SIZE, &d);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_STENCIL_SIZE, &s);
+
+            /* Some drivers expose 10 bit components which are not typically what
+             * applications want. */
+            if (r > 8 || g > 8 || b > 8) continue;
+
+            pixel_formats[nb_pixel_formats].config = egl_configs[i];
+            pixel_formats[nb_pixel_formats].native_visual_id = visual_id;
+            nb_pixel_formats++;
+            TRACE("%u: config %u id %u type %x visual %u native %u render %x "
+                  "colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render,
+                   color, r, g, b, d, s);
+        }
+        if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
+    }
+    wayland_process_release();
+    free(egl_configs);
+
+    return TRUE;
+
+err:
+    free(egl_configs);
+    free(pixel_formats);
+
+    return FALSE;
+}
+
+static BOOL egl_init(void)
+{
+    static int retval = -1;
+
+    if (retval != -1) return retval;
+    retval = 0;
+
+    if (!(egl_handle = dlopen(SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        ERR("failed to load %s: %s\n", SONAME_LIBEGL, dlerror());
+        return FALSE;
+    }
+
+#ifdef SONAME_LIBGL
+    if (!(opengl_handle = dlopen(SONAME_LIBGL, RTLD_NOW|RTLD_GLOBAL)))
+        WARN("failed to load %s: %s\n", SONAME_LIBGL, dlerror());
+#endif
+
+#ifdef SONAME_LIBGLESV2
+    if (!opengl_handle && (!(opengl_handle = dlopen(SONAME_LIBGLESV2, RTLD_NOW|RTLD_GLOBAL))))
+        WARN("failed to load %s: %s\n", SONAME_LIBGLESV2, dlerror());
+#endif
+
+    if (!opengl_handle)
+    {
+        ERR("failed to load GL or GLESv2 library\n");
+        return FALSE;
+    }
+
+#define LOAD_FUNCPTR(func) do { \
+        if (!(p_##func = dlsym(egl_handle, #func))) \
+        { ERR("can't find symbol %s\n", #func); return FALSE; }    \
+    } while(0)
+    LOAD_FUNCPTR(eglBindAPI);
+    LOAD_FUNCPTR(eglCreateContext);
+    LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroyContext);
+    LOAD_FUNCPTR(eglDestroySurface);
+    LOAD_FUNCPTR(eglGetConfigAttrib);
+    LOAD_FUNCPTR(eglGetConfigs);
+    LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglGetProcAddress);
+    LOAD_FUNCPTR(eglInitialize);
+    LOAD_FUNCPTR(eglMakeCurrent);
+    LOAD_FUNCPTR(eglQueryString);
+    LOAD_FUNCPTR(eglSwapBuffers);
+#undef LOAD_FUNCPTR
+
+    if (!wayland_gbm_init()) return FALSE;
+
+    egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_gbm_device);
+    if (!p_eglInitialize(egl_display, &egl_version[0], &egl_version[1]))
+        return FALSE;
+    TRACE("display %p version %u.%u\n", egl_display, egl_version[0], egl_version[1]);
+
+    if (!init_pixel_formats()) return FALSE;
+
+    init_extensions(egl_version[0], egl_version[1]);
+    retval = 1;
+    return TRUE;
+}
+
+/* generate stubs for GL functions that are not exported */
+
+#define USE_GL_FUNC(name) \
+static void glstub_##name(void) \
+{ \
+    ERR(#name " called\n"); \
+    assert(0); \
+    ExitProcess(1); \
+}
+
+ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+static struct opengl_funcs egl_funcs =
+{
+    .wgl =
+    {
+        .p_wglCopyContext = wayland_wglCopyContext,
+        .p_wglCreateContext = wayland_wglCreateContext,
+        .p_wglDeleteContext = wayland_wglDeleteContext,
+        .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
+        .p_wglGetPixelFormat = wayland_wglGetPixelFormat,
+        .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglMakeCurrent = wayland_wglMakeCurrent,
+        .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
+        .p_wglShareLists = wayland_wglShareLists,
+        .p_wglSwapBuffers = wayland_wglSwapBuffers,
+    },
+#define USE_GL_FUNC(name) (void *)glstub_##name,
+    .gl = { ALL_WGL_FUNCS }
+#undef USE_GL_FUNC
+};
+
+/**********************************************************************
+ *           WAYLAND_wine_get_wgl_driver
+ */
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
+{
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR("version mismatch, opengl32 wants %u but driver has %u\n",
+            version, WINE_WGL_DRIVER_VERSION);
+        return NULL;
+    }
+    if (!egl_init()) return NULL;
+    return &egl_funcs;
+}
+
+/***********************************************************************
+ *		wayland_update_gl_drawable_surface
+ */
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface)
+{
+    struct wayland_gl_drawable *gl;
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+
+        gl->wayland_surface = wayland_surface;
+        if (gl->wayland_surface)
+            wayland_surface_create_or_ref_glvk(gl->wayland_surface);
+
+        wayland_gl_drawable_release(gl);
+    }
+}
+
+#else /* No GL */
+
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
+{
+    ERR("Wine Wayland was built without OpenGL support.\n");
+    return NULL;
+}
+
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface)
+{
+}
+
+void wayland_destroy_gl_drawable(HWND hwnd)
+{
+}
+
+#endif
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
new file mode 100644
index 00000000000..e7aa2e40b3b
--- /dev/null
+++ b/dlls/winewayland.drv/options.c
@@ -0,0 +1,116 @@
+/*
+ * winewayland.drv options
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Code to read options from the registry, adapted from the X11 driver */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+
+#include <string.h>
+
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
+ *              Config options
+ */
+
+char *option_drm_device = NULL;
+enum wayland_hidpi_scaling option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+BOOL option_show_systray = TRUE;
+BOOL option_use_system_cursors = TRUE;
+
+/***********************************************************************
+ *		get_config_key
+ *
+ * Get a config key from either the app-specific or the default config
+ */
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   ULONG type, char *buffer, DWORD size)
+{
+    if (appkey && !reg_get_value_a(appkey, name, type, buffer, &size)) return 0;
+    if (defkey && !reg_get_value_a(defkey, name, type, buffer, &size)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/***********************************************************************
+ *		wayland_read_options_from_registry
+ *
+ * Read the Wayland driver options from the registry.
+ */
+void wayland_read_options_from_registry(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    char buffer[64];
+    HKEY hkey, appkey = 0;
+    DWORD process_name_len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = reg_open_hkcu_key_a("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    process_name_len = process_name ? strlen(process_name) : 0;
+    if (process_name_len > 0)
+    {
+        WCHAR appname[MAX_PATH + sizeof(waylanddriverW) / sizeof(WCHAR)];
+        DWORD reslen;
+        if (!RtlUTF8ToUnicodeN(appname, MAX_PATH * sizeof(WCHAR), &reslen,
+                               process_name, process_name_len))
+        {
+            HKEY tmpkey;
+            memcpy((char *)appname + reslen, waylanddriverW, sizeof(waylanddriverW));
+            /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+            if ((tmpkey = reg_open_hkcu_key_a("Software\\Wine\\AppDefaults")))
+            {
+                appkey = reg_open_key_w(tmpkey, appname);
+                NtClose(tmpkey);
+            }
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "DRMDevice", REG_SZ, buffer, sizeof(buffer)))
+        option_drm_device = strdup(buffer);
+
+    if (!get_config_key(hkey, appkey, "HiDPIScaling", REG_SZ, buffer, sizeof(buffer)))
+    {
+        if (!strcasecmp(buffer, "Application"))
+            option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+        else if (!strcasecmp(buffer, "Compositor"))
+            option_hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
+    }
+
+    if (!get_config_key(hkey, appkey, "ShowSystray", REG_SZ, buffer, sizeof(buffer)))
+        option_show_systray = IS_OPTION_TRUE(buffer[0]);
+
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
+    if (appkey) NtClose(appkey);
+    if (hkey) NtClose(hkey);
+}
diff --git a/dlls/winewayland.drv/registry.c b/dlls/winewayland.drv/registry.c
new file mode 100644
index 00000000000..c511da1a465
--- /dev/null
+++ b/dlls/winewayland.drv/registry.c
@@ -0,0 +1,167 @@
+/*
+ * Registry helpers
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <stdio.h>
+
+/**********************************************************************
+ *          reg_open_key_a
+ *
+ *  Open a registry key with the specified ASCII name.
+ */
+HKEY reg_open_key_a(HKEY root, const char *name)
+{
+    WCHAR nameW[256];
+    if (!name || !*name) return root;
+    if (ascii_to_unicode_maybe_z(nameW, ARRAY_SIZE(nameW), name, -1) > ARRAY_SIZE(nameW))
+        return 0;
+    return reg_open_key_w(root, nameW);
+}
+
+/**********************************************************************
+ *          reg_open_key_w
+ *
+ *  Open a registry key with the specified Unicode name.
+ */
+HKEY reg_open_key_w(HKEY root, const WCHAR *nameW)
+{
+    INT name_len = nameW ? lstrlenW(nameW) * sizeof(WCHAR) : 0;
+    UNICODE_STRING name_unicode = { name_len, name_len, (WCHAR *)nameW };
+    OBJECT_ATTRIBUTES attr;
+    HANDLE ret;
+
+    if (!nameW || !*nameW) return root;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &name_unicode;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
+}
+
+/**********************************************************************
+ *          reg_open_hkcu_key_a
+ *
+ *  Open a registry key under HKCU with the specified ASCII name.
+ */
+HKEY reg_open_hkcu_key_a(const char *name)
+{
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data,
+                                    len, &len))
+        {
+            return 0;
+        }
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = snprintf(buffer, ARRAY_SIZE(buffer), "\\Registry\\User\\S-%u-%u",
+                       sid->Revision,
+                       (int)MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                              sid->IdentifierAuthority.Value[4]),
+                                     MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                              sid->IdentifierAuthority.Value[2])));
+        if (len >= ARRAY_SIZE(buffer)) return 0;
+
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+        {
+            len += snprintf(buffer + len, ARRAY_SIZE(buffer) - len, "-%u",
+                            (UINT)sid->SubAuthority[i]);
+            if (len >= ARRAY_SIZE(buffer)) return 0;
+        }
+
+        hkcu = reg_open_key_a(NULL, buffer);
+    }
+
+    return reg_open_key_a(hkcu, name);
+}
+
+static DWORD reg_get_value_info(HKEY hkey, const WCHAR *nameW, ULONG type,
+                                KEY_VALUE_PARTIAL_INFORMATION *info,
+                                ULONG info_size)
+{
+    unsigned int name_size = lstrlenW(nameW) * sizeof(WCHAR);
+    UNICODE_STRING name_unicode = { name_size, name_size, (WCHAR *)nameW };
+
+    if (NtQueryValueKey(hkey, &name_unicode, KeyValuePartialInformation,
+                        info, info_size, &info_size))
+        return ERROR_FILE_NOT_FOUND;
+
+    if (info->Type != type) return ERROR_DATATYPE_MISMATCH;
+
+    return ERROR_SUCCESS;
+}
+
+/**********************************************************************
+ *          reg_get_value_a
+ *
+ *  Get the value of the specified registry key (or subkey if name is not NULL),
+ *  having the specified type. If the types do not match an error is returned.
+ *  If the stored value is REG_SZ the string is transformed into ASCII before
+ *  being returned.
+ */
+DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
+                      DWORD *buffer_len)
+{
+    WCHAR nameW[256];
+    char info_buf[2048];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)info_buf;
+    ULONG info_size = ARRAY_SIZE(info_buf);
+    DWORD err;
+
+    if (name && ascii_to_unicode_maybe_z(nameW, ARRAY_SIZE(nameW), name, -1) > ARRAY_SIZE(nameW))
+        return ERROR_INSUFFICIENT_BUFFER;
+
+    if ((err = reg_get_value_info(hkey, name ? nameW : NULL, type, info, info_size)))
+        return err;
+
+    if (type == REG_SZ)
+    {
+        size_t nchars = unicode_to_ascii_maybe_z(buffer, *buffer_len, (WCHAR *)info->Data,
+                                                 info->DataLength / sizeof(WCHAR));
+        err = *buffer_len >= nchars ? ERROR_SUCCESS : ERROR_MORE_DATA;
+        *buffer_len = nchars;
+    }
+    else
+    {
+        err = *buffer_len >= info->DataLength ? ERROR_SUCCESS : ERROR_MORE_DATA;
+        if (err == ERROR_SUCCESS) memcpy(buffer, info->Data, info->DataLength);
+        *buffer_len = info->DataLength;
+    }
+
+    return err;
+}
diff --git a/dlls/winewayland.drv/systray.c b/dlls/winewayland.drv/systray.c
new file mode 100644
index 00000000000..bc4bc1d783d
--- /dev/null
+++ b/dlls/winewayland.drv/systray.c
@@ -0,0 +1,744 @@
+/*
+ * Wayland system tray management
+ *
+ * Copyright (C) 2004 Mike Hearn, for CodeWeavers
+ * Copyright (C) 2005 Robert Shearman
+ * Copyright (C) 2008 Alexandre Julliard
+ * Copyright (C) 2021 Alexandros Frantzis, for Collabora
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Adapted from winex11.drv/systray.c */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "commctrl.h"
+#include "shellapi.h"
+
+#include "waylanddrv_dll.h"
+#include "wine/list.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(systray);
+
+/* an individual systray icon */
+struct tray_icon
+{
+    struct list    entry;
+    HICON          image;    /* the image to render */
+    HWND           owner;    /* the HWND passed in to the Shell_NotifyIcon call */
+    HWND           window;   /* the adaptor window */
+    BOOL           layered;  /* whether we are using a layered window */
+    HWND           tooltip;  /* Icon tooltip */
+    UINT           state;    /* state flags */
+    UINT           id;       /* the unique id given by the app */
+    UINT           callback_message;
+    int            display;  /* display index, or -1 if hidden */
+    WCHAR          tiptext[128];    /* tooltip text */
+    WCHAR          info_text[256];  /* info balloon text */
+    WCHAR          info_title[64];  /* info balloon title */
+    UINT           info_flags;      /* flags for info balloon */
+    UINT           info_timeout;    /* timeout for info balloon */
+    HICON          info_icon;       /* info balloon icon */
+    UINT           version;         /* notify icon api version */
+};
+
+static struct list icon_list = LIST_INIT( icon_list );
+
+static const WCHAR icon_classname[] = {'_','_','w','i','n','e','w','a','y','l','a','n','d','_','t','r','a','y','_','i','c','o','n',0};
+static const WCHAR tray_classname[] = {'_','_','w','i','n','e','w','a','y','l','a','n','d','_','s','t','a','n','d','a','l','o','n','e','_','t','r','a','y',0};
+
+static BOOL show_icon( struct tray_icon *icon );
+static BOOL hide_icon( struct tray_icon *icon );
+static BOOL delete_icon( struct tray_icon *icon );
+
+#define SYSTEM_TRAY_REQUEST_DOCK  0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+
+#define MIN_DISPLAYED 8
+#define ICON_BORDER 2
+
+#define BALLOON_CREATE_TIMER 1
+#define BALLOON_SHOW_TIMER   2
+
+#define BALLOON_CREATE_TIMEOUT   2000
+#define BALLOON_SHOW_MIN_TIMEOUT 10000
+#define BALLOON_SHOW_MAX_TIMEOUT 30000
+
+static struct tray_icon *balloon_icon;
+static HWND balloon_window;
+static POINT balloon_pos;
+
+/* stand-alone tray window */
+static HWND standalone_tray;
+static int icon_cx, icon_cy;
+static unsigned int nb_displayed;
+
+/* retrieves icon record by owner window and ID */
+static struct tray_icon *get_icon(HWND owner, UINT id)
+{
+    struct tray_icon *this;
+
+    LIST_FOR_EACH_ENTRY( this, &icon_list, struct tray_icon, entry )
+        if ((this->id == id) && (this->owner == owner)) return this;
+    return NULL;
+}
+
+static void init_common_controls(void)
+{
+    static BOOL initialized = FALSE;
+
+    if (!initialized)
+    {
+        INITCOMMONCONTROLSEX init_tooltip;
+
+        init_tooltip.dwSize = sizeof(INITCOMMONCONTROLSEX);
+        init_tooltip.dwICC = ICC_TAB_CLASSES;
+
+        InitCommonControlsEx(&init_tooltip);
+        initialized = TRUE;
+    }
+}
+
+/* create tooltip window for icon */
+static void create_tooltip(struct tray_icon *icon)
+{
+    init_common_controls();
+    icon->tooltip = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                     WS_POPUP | TTS_ALWAYSTIP,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     icon->window, NULL, NULL, NULL);
+    if (icon->tooltip)
+    {
+        TTTOOLINFOW ti;
+        ZeroMemory(&ti, sizeof(ti));
+        ti.cbSize = sizeof(TTTOOLINFOW);
+        ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+        ti.hwnd = icon->window;
+        ti.uId = (UINT_PTR)icon->window;
+        ti.lpszText = icon->tiptext;
+        SendMessageW(icon->tooltip, TTM_ADDTOOLW, 0, (LPARAM)&ti);
+    }
+}
+
+void update_systray_balloon_position(void)
+{
+    RECT rect;
+    POINT pos;
+
+    if (!balloon_icon) return;
+    GetWindowRect( balloon_icon->window, &rect );
+    pos.x = (rect.left + rect.right) / 2;
+    pos.y = (rect.top + rect.bottom) / 2;
+    if (pos.x == balloon_pos.x && pos.y == balloon_pos.y) return;  /* nothing changed */
+    balloon_pos = pos;
+    SendMessageW( balloon_window, TTM_TRACKPOSITION, 0, MAKELONG( pos.x, pos.y ));
+}
+
+static void balloon_create_timer( struct tray_icon *icon )
+{
+    TTTOOLINFOW ti;
+
+    init_common_controls();
+    balloon_window = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                      WS_POPUP | TTS_ALWAYSTIP | TTS_NOPREFIX | TTS_BALLOON | TTS_CLOSE,
+                                      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+                                      icon->window, NULL, NULL, NULL);
+
+    memset( &ti, 0, sizeof(ti) );
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.uFlags = TTF_TRACK | TTF_IDISHWND;
+    ti.lpszText = icon->info_text;
+    SendMessageW( balloon_window, TTM_ADDTOOLW, 0, (LPARAM)&ti );
+    if ((icon->info_flags & NIIF_ICONMASK) == NIIF_USER)
+        SendMessageW( balloon_window, TTM_SETTITLEW, (WPARAM)icon->info_icon, (LPARAM)icon->info_title );
+    else
+        SendMessageW( balloon_window, TTM_SETTITLEW, icon->info_flags, (LPARAM)icon->info_title );
+    balloon_icon = icon;
+    balloon_pos.x = balloon_pos.y = MAXLONG;
+    update_systray_balloon_position();
+    SendMessageW( balloon_window, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti );
+    KillTimer( icon->window, BALLOON_CREATE_TIMER );
+    SetTimer( icon->window, BALLOON_SHOW_TIMER, icon->info_timeout, NULL );
+}
+
+static BOOL show_balloon( struct tray_icon *icon )
+{
+    if (standalone_tray && !option_show_systray) return FALSE;  /* no systray window */
+    if (!icon->window) return FALSE;  /* not displayed */
+    if (!icon->info_text[0]) return FALSE;  /* no balloon */
+    balloon_icon = icon;
+    SetTimer( icon->window, BALLOON_CREATE_TIMER, BALLOON_CREATE_TIMEOUT, NULL );
+    return TRUE;
+}
+
+static void hide_balloon(void)
+{
+    if (!balloon_icon) return;
+    if (balloon_window)
+    {
+        KillTimer( balloon_icon->window, BALLOON_SHOW_TIMER );
+        DestroyWindow( balloon_window );
+        balloon_window = 0;
+    }
+    else KillTimer( balloon_icon->window, BALLOON_CREATE_TIMER );
+    balloon_icon = NULL;
+}
+
+static void show_next_balloon(void)
+{
+    struct tray_icon *icon;
+
+    LIST_FOR_EACH_ENTRY( icon, &icon_list, struct tray_icon, entry )
+        if (show_balloon( icon )) break;
+}
+
+static void update_balloon( struct tray_icon *icon )
+{
+    if (balloon_icon == icon)
+    {
+        hide_balloon();
+        show_balloon( icon );
+    }
+    else if (!balloon_icon)
+    {
+        if (!show_balloon( icon )) return;
+    }
+    if (!balloon_icon) show_next_balloon();
+}
+
+static void balloon_timer(void)
+{
+    if (balloon_icon) balloon_icon->info_text[0] = 0;  /* clear text now that balloon has been shown */
+    hide_balloon();
+    show_next_balloon();
+}
+
+/* synchronize tooltip text with tooltip window */
+static void update_tooltip_text(struct tray_icon *icon)
+{
+    TTTOOLINFOW ti;
+
+    ZeroMemory(&ti, sizeof(ti));
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.lpszText = icon->tiptext;
+
+    SendMessageW(icon->tooltip, TTM_UPDATETIPTEXTW, 0, (LPARAM)&ti);
+}
+
+/* get the size of the stand-alone tray window */
+static SIZE get_window_size(void)
+{
+    SIZE size;
+    RECT rect;
+
+    rect.left = 0;
+    rect.top = 0;
+    rect.right = icon_cx * max( nb_displayed, MIN_DISPLAYED );
+    rect.bottom = icon_cy;
+    AdjustWindowRect( &rect, WS_CAPTION, FALSE );
+    size.cx = rect.right - rect.left;
+    size.cy = rect.bottom - rect.top;
+    return size;
+}
+
+/* get the position of an icon in the stand-alone tray */
+static POINT get_icon_pos( struct tray_icon *icon )
+{
+    POINT pos;
+
+    pos.x = icon_cx * icon->display;
+    pos.y = 0;
+    return pos;
+}
+
+/* window procedure for the standalone tray window */
+static LRESULT WINAPI standalone_tray_wndproc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    switch (msg)
+    {
+    case WM_MOVE:
+        update_systray_balloon_position();
+        break;
+    case WM_CLOSE:
+        ShowWindow( hwnd, SW_HIDE );
+        hide_balloon();
+        option_show_systray = FALSE;
+        return 0;
+    case WM_DESTROY:
+        standalone_tray = 0;
+        break;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+/* add an icon to the standalone tray window */
+static void add_to_standalone_tray( struct tray_icon *icon )
+{
+    SIZE size;
+    POINT pos;
+
+    if (!standalone_tray)
+    {
+        static const WCHAR winname[] = {'W','i','n','e',' ','S','y','s','t','e','m',' ','T','r','a','y',0};
+
+        size = get_window_size();
+        standalone_tray = CreateWindowExW( 0, tray_classname, winname, WS_CAPTION | WS_SYSMENU,
+                                           CW_USEDEFAULT, CW_USEDEFAULT, size.cx, size.cy, 0, 0, 0, 0 );
+        if (!standalone_tray) return;
+    }
+
+    icon->display = nb_displayed;
+    pos = get_icon_pos( icon );
+    icon->window = CreateWindowW( icon_classname, NULL, WS_CHILD | WS_VISIBLE,
+                                  pos.x, pos.y, icon_cx, icon_cy, standalone_tray, NULL, NULL, icon );
+    if (!icon->window)
+    {
+        icon->display = -1;
+        return;
+    }
+    create_tooltip( icon );
+
+    nb_displayed++;
+    size = get_window_size();
+    SetWindowPos( standalone_tray, 0, 0, 0, size.cx, size.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER );
+    if (nb_displayed == 1 && option_show_systray) ShowWindow( standalone_tray, SW_SHOWNA );
+    TRACE( "added %u now %d icons\n", icon->id, nb_displayed );
+}
+
+/* remove an icon from the stand-alone tray */
+static void remove_from_standalone_tray( struct tray_icon *icon )
+{
+    struct tray_icon *ptr;
+    POINT pos;
+
+    if (icon->display == -1) return;
+
+    LIST_FOR_EACH_ENTRY( ptr, &icon_list, struct tray_icon, entry )
+    {
+        if (ptr == icon) continue;
+        if (ptr->display < icon->display) continue;
+        ptr->display--;
+        pos = get_icon_pos( ptr );
+        SetWindowPos( ptr->window, 0, pos.x, pos.y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER );
+    }
+    icon->display = -1;
+    if (!--nb_displayed) ShowWindow( standalone_tray, SW_HIDE );
+    TRACE( "removed %u now %d icons\n", icon->id, nb_displayed );
+}
+
+static void repaint_tray_icon( struct tray_icon *icon )
+{
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
+    int width = GetSystemMetrics( SM_CXSMICON );
+    int height = GetSystemMetrics( SM_CYSMICON );
+    BITMAPINFO *info;
+    HBITMAP dib, mask;
+    HDC hdc;
+    RECT rc;
+    SIZE size;
+    POINT pos;
+    int i, x, y;
+    void *color_bits, *mask_bits;
+    DWORD *ptr;
+    BOOL has_alpha = FALSE;
+
+    GetWindowRect( icon->window, &rc );
+    size.cx = rc.right - rc.left;
+    size.cy = rc.bottom - rc.top;
+    pos.x = (size.cx - width) / 2;
+    pos.y = (size.cy - height) / 2;
+
+    info = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, FIELD_OFFSET( BITMAPINFO, bmiColors[2] ));
+    if (!info) return;
+    info->bmiHeader.biSize = sizeof(info->bmiHeader);
+    info->bmiHeader.biWidth = size.cx;
+    info->bmiHeader.biHeight = size.cy;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biCompression = BI_RGB;
+
+    hdc = CreateCompatibleDC( 0 );
+    if (!(dib = CreateDIBSection( 0, info, DIB_RGB_COLORS, &color_bits, NULL, 0 ))) goto done;
+    SelectObject( hdc, dib );
+    DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_NORMAL );
+
+    /* check if the icon was drawn with an alpha channel */
+    for (i = 0, ptr = color_bits; i < size.cx * size.cy; i++)
+        if ((has_alpha = (ptr[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (size.cx + 31) / 32 * 4;
+
+        info->bmiHeader.biBitCount = 1;
+        info->bmiColors[0].rgbRed      = 0;
+        info->bmiColors[0].rgbGreen    = 0;
+        info->bmiColors[0].rgbBlue     = 0;
+        info->bmiColors[0].rgbReserved = 0;
+        info->bmiColors[1].rgbRed      = 0xff;
+        info->bmiColors[1].rgbGreen    = 0xff;
+        info->bmiColors[1].rgbBlue     = 0xff;
+        info->bmiColors[1].rgbReserved = 0;
+
+        if (!(mask = CreateDIBSection( 0, info, DIB_RGB_COLORS, &mask_bits, NULL, 0 ))) goto done;
+        memset( mask_bits, 0xff, width_bytes * size.cy );
+        SelectObject( hdc, mask );
+        DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_MASK );
+
+        for (y = 0, ptr = color_bits; y < size.cy; y++)
+            for (x = 0; x < size.cx; x++, ptr++)
+                if (!((((BYTE *)mask_bits)[y * width_bytes + x / 8] << (x % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+
+        SelectObject( hdc, dib );
+        DeleteObject( mask );
+    }
+
+    UpdateLayeredWindow( icon->window, 0, NULL, NULL, hdc, NULL, 0, &blend, ULW_ALPHA );
+done:
+    HeapFree (GetProcessHeap(), 0, info);
+    if (hdc) DeleteDC( hdc );
+    if (dib) DeleteObject( dib );
+}
+
+static BOOL notify_owner( struct tray_icon *icon, UINT msg, LPARAM lparam )
+{
+    WPARAM wp = icon->id;
+    LPARAM lp = msg;
+
+    if (icon->version >= NOTIFYICON_VERSION_4)
+    {
+        POINT pt = { (short)LOWORD(lparam), (short)HIWORD(lparam) };
+
+        ClientToScreen( icon->window, &pt );
+        wp = MAKEWPARAM( pt.x, pt.y );
+        lp = MAKELPARAM( msg, icon->id );
+    }
+
+    TRACE( "relaying 0x%x\n", msg );
+    if (!SendNotifyMessageW( icon->owner, icon->callback_message, wp, lp ) &&
+        (GetLastError() == ERROR_INVALID_WINDOW_HANDLE))
+    {
+        WARN( "application window was destroyed, removing icon %u\n", icon->id );
+        delete_icon( icon );
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/* window procedure for the individual tray icon window */
+static LRESULT WINAPI tray_icon_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    struct tray_icon *icon = NULL;
+
+    TRACE("hwnd=%p, msg=0x%x\n", hwnd, msg);
+
+    /* set the icon data for the window from the data passed into CreateWindow */
+    if (msg == WM_NCCREATE)
+        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LPARAM)((const CREATESTRUCTW *)lparam)->lpCreateParams);
+
+    icon = (struct tray_icon *) GetWindowLongPtrW(hwnd, GWLP_USERDATA);
+
+    switch (msg)
+    {
+    case WM_SIZE:
+        if (icon->window && icon->layered) repaint_tray_icon( icon );
+        break;
+
+    case WM_PAINT:
+        if (!icon->layered)
+        {
+            PAINTSTRUCT ps;
+            RECT rc;
+            HDC hdc;
+            int cx = GetSystemMetrics( SM_CXSMICON );
+            int cy = GetSystemMetrics( SM_CYSMICON );
+
+            hdc = BeginPaint(hwnd, &ps);
+            GetClientRect(hwnd, &rc);
+            TRACE("painting rect %s\n", wine_dbgstr_rect(&rc));
+            DrawIconEx( hdc, (rc.left + rc.right - cx) / 2, (rc.top + rc.bottom - cy) / 2,
+                        icon->image, cx, cy, 0, 0, DI_DEFAULTSIZE|DI_NORMAL );
+            EndPaint(hwnd, &ps);
+            return 0;
+        }
+        break;
+
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_RBUTTONDOWN:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_LBUTTONDBLCLK:
+    case WM_RBUTTONDBLCLK:
+    case WM_MBUTTONDBLCLK:
+        notify_owner( icon, msg, lparam );
+        break;
+
+    case WM_LBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, NIN_SELECT, lparam );
+        break;
+
+    case WM_RBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, WM_CONTEXTMENU, lparam );
+        break;
+
+    case WM_WINDOWPOSCHANGED:
+        update_systray_balloon_position();
+        break;
+
+    case WM_TIMER:
+        switch (wparam)
+        {
+        case BALLOON_CREATE_TIMER:
+            balloon_create_timer( icon );
+            break;
+        case BALLOON_SHOW_TIMER:
+            balloon_timer();
+            break;
+        }
+        return 0;
+
+    case WM_CLOSE:
+        if (icon->display == -1)
+        {
+            TRACE( "icon %u no longer embedded\n", icon->id );
+            hide_icon( icon );
+            add_to_standalone_tray( icon );
+        }
+        return 0;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static BOOL init_systray(void)
+{
+    static BOOL init_done;
+    WNDCLASSEXW class;
+
+    if (init_done) return TRUE;
+
+    icon_cx = GetSystemMetrics( SM_CXSMICON ) + 2 * ICON_BORDER;
+    icon_cy = GetSystemMetrics( SM_CYSMICON ) + 2 * ICON_BORDER;
+
+    memset( &class, 0, sizeof(class) );
+    class.cbSize        = sizeof(class);
+    class.lpfnWndProc   = tray_icon_wndproc;
+    class.hIcon         = LoadIconW(0, (LPCWSTR)IDI_WINLOGO);
+    class.hCursor       = LoadCursorW( 0, (LPCWSTR)IDC_ARROW );
+    class.lpszClassName = icon_classname;
+    class.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register icon tray window class\n" );
+        return FALSE;
+    }
+
+    class.lpfnWndProc   = standalone_tray_wndproc;
+    class.hbrBackground = (HBRUSH)COLOR_WINDOW;
+    class.lpszClassName = tray_classname;
+    class.style         = CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register standalone tray window class\n" );
+        return FALSE;
+    }
+
+    init_done = TRUE;
+    return TRUE;
+}
+
+/* hide a tray icon */
+static BOOL hide_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (!icon->window) return TRUE;  /* already hidden */
+
+    DestroyWindow(icon->window);
+    DestroyWindow(icon->tooltip);
+    icon->window = 0;
+    icon->layered = FALSE;
+    icon->tooltip = 0;
+    remove_from_standalone_tray( icon );
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* make the icon visible */
+static BOOL show_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (icon->window) return TRUE;  /* already shown */
+
+    add_to_standalone_tray( icon );
+
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* Modifies an existing icon record */
+static BOOL modify_icon( struct tray_icon *icon, NOTIFYICONDATAW *nid )
+{
+    TRACE( "id=0x%x hwnd=%p flags=%x\n", nid->uID, nid->hWnd, nid->uFlags );
+
+    if (nid->uFlags & NIF_STATE)
+    {
+        icon->state = (icon->state & ~nid->dwStateMask) | (nid->dwState & nid->dwStateMask);
+    }
+
+    if (nid->uFlags & NIF_ICON)
+    {
+        if (icon->image) DestroyIcon(icon->image);
+        icon->image = CopyIcon(nid->hIcon);
+        if (icon->window)
+        {
+            if (icon->display != -1) InvalidateRect( icon->window, NULL, TRUE );
+            else if (icon->layered) repaint_tray_icon( icon );
+        }
+    }
+
+    if (nid->uFlags & NIF_MESSAGE)
+    {
+        icon->callback_message = nid->uCallbackMessage;
+    }
+    if (nid->uFlags & NIF_TIP)
+    {
+        lstrcpynW(icon->tiptext, nid->szTip, ARRAY_SIZE( icon->tiptext ));
+        if (icon->tooltip) update_tooltip_text(icon);
+    }
+    if (nid->uFlags & NIF_INFO && nid->cbSize >= NOTIFYICONDATAA_V2_SIZE)
+    {
+        lstrcpynW( icon->info_text, nid->szInfo, ARRAY_SIZE( icon->info_text ));
+        lstrcpynW( icon->info_title, nid->szInfoTitle, ARRAY_SIZE( icon->info_title ));
+        icon->info_flags = nid->dwInfoFlags;
+        icon->info_timeout = max(min(nid->u.uTimeout, BALLOON_SHOW_MAX_TIMEOUT), BALLOON_SHOW_MIN_TIMEOUT);
+        icon->info_icon = nid->hBalloonIcon;
+        update_balloon( icon );
+    }
+    if (icon->state & NIS_HIDDEN) hide_icon( icon );
+    else show_icon( icon );
+    return TRUE;
+}
+
+/* Adds a new icon record to the list */
+static BOOL add_icon(NOTIFYICONDATAW *nid)
+{
+    struct tray_icon  *icon;
+
+    TRACE("id=0x%x, hwnd=%p\n", nid->uID, nid->hWnd);
+
+    if ((icon = get_icon(nid->hWnd, nid->uID)))
+    {
+        WARN("duplicate tray icon add, buggy app?\n");
+        return FALSE;
+    }
+
+    if (!(icon = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*icon))))
+    {
+        ERR("out of memory\n");
+        return FALSE;
+    }
+
+    icon->id     = nid->uID;
+    icon->owner  = nid->hWnd;
+    icon->display = -1;
+
+    list_add_tail(&icon_list, &icon->entry);
+
+    return modify_icon( icon, nid );
+}
+
+/* delete tray icon window and icon structure */
+static BOOL delete_icon( struct tray_icon *icon )
+{
+    hide_icon( icon );
+    list_remove( &icon->entry );
+    DestroyIcon( icon->image );
+    HeapFree( GetProcessHeap(), 0, icon );
+    return TRUE;
+}
+
+/* cleanup all icons for a given window */
+static void cleanup_icons( HWND owner )
+{
+    struct tray_icon *this, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( this, next, &icon_list, struct tray_icon, entry )
+        if (this->owner == owner) delete_icon( this );
+}
+
+
+/***********************************************************************
+ *              wine_notify_icon
+ *
+ * Driver-side implementation of Shell_NotifyIcon.
+ */
+int CDECL wine_notify_icon( DWORD msg, NOTIFYICONDATAW *data )
+{
+    BOOL ret = FALSE;
+    struct tray_icon *icon;
+
+    switch (msg)
+    {
+    case NIM_ADD:
+        if (!init_systray()) return -1;  /* fall back to default handling */
+        ret = add_icon( data );
+        break;
+    case NIM_DELETE:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = delete_icon( icon );
+        break;
+    case NIM_MODIFY:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = modify_icon( icon, data );
+        break;
+    case NIM_SETVERSION:
+        if ((icon = get_icon( data->hWnd, data->uID )))
+        {
+            icon->version = data->u.uVersion;
+            ret = TRUE;
+        }
+        break;
+    case 0xdead:  /* Wine extension: owner window has died */
+        cleanup_icons( data->hWnd );
+        break;
+    default:
+        FIXME( "unhandled tray message: %lu\n", msg );
+        break;
+    }
+    return ret;
+}
diff --git a/dlls/winewayland.drv/unicode.c b/dlls/winewayland.drv/unicode.c
new file mode 100644
index 00000000000..7cce78573a7
--- /dev/null
+++ b/dlls/winewayland.drv/unicode.c
@@ -0,0 +1,105 @@
+/*
+ * Wayland driver unicode helpers
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+/**********************************************************************
+ *          ascii_to_unicode_maybe_z
+ *
+ * Converts an ascii, possibly zero-terminated, string containing up to
+ * src_max_chars to a unicode string. Returns the number of characters
+ * (including any trailing zero) in the source ascii string. If the returned
+ * number of characters is greater than dst_max_chars the output will have been
+ * truncated.
+ */
+size_t ascii_to_unicode_maybe_z(WCHAR *dst, size_t dst_max_chars,
+                                const char *src, size_t src_max_chars)
+{
+    size_t src_len = 0;
+
+    while (src_max_chars--)
+    {
+        src_len++;
+        if (dst_max_chars)
+        {
+            *dst++ = *src;
+            dst_max_chars--;
+        }
+        if (!*src++) break;
+    }
+
+    return src_len;
+}
+
+/**********************************************************************
+ *          unicode_to_ascii_maybe_z
+ *
+ * Converts a unicode, possibly zero-terminated, string containing up to
+ * src_max_chars to an ascii string. Returns the number of characters
+ * (including any trailing zero) in the source unicode string. If the returned
+ * number of characters is greater than dst_max_chars the output will have been
+ * truncated.
+ */
+size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
+                                const WCHAR *src, size_t src_max_chars)
+{
+    size_t src_len = 0;
+
+    while (src_max_chars--)
+    {
+        src_len++;
+        if (dst_max_chars)
+        {
+            *dst++ = *src;
+            dst_max_chars--;
+        }
+        if (!*src++) break;
+    }
+
+    return src_len;
+}
+
+/**********************************************************************
+ *          ascii_to_unicode_z
+ *
+ * Converts an ascii, possibly zero-terminated, string containing up to
+ * src_max_chars to a zero-terminated unicode string. Returns the number of
+ * characters (including the trailing zero) written to the destination string.
+ * If there isn't enough space in the destination to hold all the characters
+ * and the trailing zero, the string is truncated enough so that a trailing
+ * zero can be placed.
+ */
+size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
+                          const char *src, size_t src_max_chars)
+{
+    size_t len;
+    if (src_max_chars == 0) return 0;
+    len = ascii_to_unicode_maybe_z(dst, dst_max_chars, src, src_max_chars);
+    if (len >= dst_max_chars) len = dst_max_chars - 1;
+    if (len > 0 && dst[len - 1] == 0) len--;
+    dst[len] = 0;
+    return len + 1;
+}
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
new file mode 100644
index 00000000000..394e42b6443
--- /dev/null
+++ b/dlls/winewayland.drv/unixlib.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_UNIXLIB_H
+#define __WINE_WAYLANDDRV_UNIXLIB_H
+
+#include "windef.h"
+#include "ntuser.h"
+#include "wine/unixlib.h"
+
+/* A pointer to memory that is guaranteed to be usable by both 32-bit and
+ * 64-bit processes. */
+typedef UINT PTR32;
+/* A handle value that is guaranteed to be usable by both 32-bit and 64-bit
+ * processes. */
+typedef UINT HANDLE32;
+
+enum waylanddrv_unix_func
+{
+    waylanddrv_unix_func_init,
+    waylanddrv_unix_func_read_events,
+    waylanddrv_unix_func_clipboard_message,
+    waylanddrv_unix_func_data_offer_accept_format,
+    waylanddrv_unix_func_data_offer_import_format,
+    waylanddrv_unix_func_data_offer_enum_formats,
+    waylanddrv_unix_func_count,
+};
+
+struct waylanddrv_unix_init_params
+{
+    BOOL option_show_systray;
+};
+
+struct waylanddrv_unix_clipboard_message_params
+{
+    HWND hwnd;
+    UINT msg;
+    WPARAM wparam;
+    LPARAM lparam;
+};
+
+struct waylanddrv_unix_data_offer_accept_format_params
+{
+    PTR32 data_offer;
+    UINT format;
+};
+
+struct waylanddrv_unix_data_offer_import_format_params
+{
+    PTR32 data_offer;
+    UINT format;
+    PTR32 data;
+    UINT size;
+};
+
+struct waylanddrv_unix_data_offer_enum_formats_params
+{
+    PTR32 data_offer;
+    UINT *formats;
+    UINT num_formats;
+};
+
+/* driver client callbacks exposed with KernelCallbackTable interface */
+enum waylanddrv_client_func
+{
+    waylanddrv_client_func_create_clipboard_window = NtUserDriverCallbackFirst,
+    waylanddrv_client_func_dnd,
+    waylanddrv_client_func_last
+};
+
+C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
+
+enum waylanddrv_client_dnd_event
+{
+    CLIENT_DND_EVENT_ENTER,
+    CLIENT_DND_EVENT_LEAVE,
+    CLIENT_DND_EVENT_MOTION,
+    CLIENT_DND_EVENT_DROP,
+};
+
+struct waylanddrv_client_dnd_params
+{
+    UINT event;
+    HANDLE32 hwnd;
+    POINT point;
+    DWORD drop_effect;
+    PTR32 data_object;
+};
+
+#endif /* __WINE_WAYLANDDRV_UNIXLIB_H */
diff --git a/dlls/winewayland.drv/version.rc b/dlls/winewayland.drv/version.rc
new file mode 100644
index 00000000000..2d99c24f99c
--- /dev/null
+++ b/dlls/winewayland.drv/version.rc
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine Wayland driver"
+#define WINE_FILENAME_STR "winewayland.drv"
+
+#include "wine/wine_common_ver.rc"
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
new file mode 100644
index 00000000000..c968842608f
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan.c
@@ -0,0 +1,1600 @@
+/* WAYLANDDRV Vulkan implementation
+ *
+ * Copyright 2017 Roderick Colenbrander
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+#include "vulkan_remote.h"
+
+#include <assert.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+#ifdef SONAME_LIBVULKAN
+
+#define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
+
+typedef struct VkWaylandSurfaceCreateInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkWaylandSurfaceCreateFlagsKHR flags;
+    struct wl_display *display;
+    struct wl_surface *surface;
+} VkWaylandSurfaceCreateInfoKHR;
+
+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
+static VkResult (*pvkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
+static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
+static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
+static void(*pvkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
+static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
+static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
+static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkEnumerateDeviceExtensionProperties)(VkPhysicalDevice, const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
+static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
+static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
+static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
+static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
+static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
+static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
+
+static void *vulkan_handle;
+
+static struct wayland_mutex wine_vk_object_mutex =
+{
+    PTHREAD_MUTEX_INITIALIZER, 0, 0, __FILE__ ": wine_vk_object_mutex"
+};
+
+static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
+static struct wl_list wine_vk_device_list = { &wine_vk_device_list, &wine_vk_device_list };
+
+static const struct vulkan_funcs vulkan_funcs;
+
+/* These instance extensions are required to support Vulkan remote. Some of them
+ * might not be supported by the device, so we must check. */
+const static char *instance_extensions_remote_vulkan[] =
+{
+    "VK_KHR_external_fence_capabilities",
+    "VK_KHR_external_memory_capabilities",
+    "VK_KHR_external_semaphore_capabilities",
+    "VK_KHR_get_physical_device_properties2",
+};
+
+/* These device extensions are required to support Vulkan remote. Some of them
+ * might not be supported by the device, so we must check. */
+const static char *device_extensions_remote_vulkan[] =
+{
+    "VK_KHR_external_fence",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory",
+    "VK_KHR_external_memory_fd",
+    "VK_KHR_external_semaphore",
+    "VK_KHR_external_semaphore_fd",
+};
+
+struct wine_vk_device
+{
+    struct wl_list link;
+    VkDevice dev;
+    VkPhysicalDevice phys_dev;
+    BOOL supports_remote_vulkan;
+};
+
+struct wine_vk_surface
+{
+    struct wl_list link;
+    HWND hwnd;
+    VkInstance instance;
+    struct wayland_surface *wayland_surface;
+    /* Used when we are rendering cross-process and we don't have the real
+     * wayland surface available. */
+    struct wl_surface *dummy_wl_surface;
+    VkSurfaceKHR native_vk_surface;
+    BOOL valid;
+};
+
+struct wine_vk_swapchain
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wine_vk_device *wine_vk_device;
+    struct wayland_surface *wayland_surface;
+    VkSwapchainKHR native_vk_swapchain;
+    VkExtent2D extent;
+    BOOL valid;
+    /* Only used for cross-process Vulkan rendering apps. */
+    struct wayland_remote_vk_swapchain *remote_vk_swapchain;
+    PFN_vkGetSemaphoreFdKHR p_vkGetSemaphoreFdKHR;
+};
+
+static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
+{
+    wayland_mutex_lock(&wine_vk_object_mutex);
+    wl_list_insert(list, link);
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+static inline void wine_vk_list_remove(struct wl_list *link)
+{
+    wayland_mutex_lock(&wine_vk_object_mutex);
+    wl_list_remove(link);
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
+{
+    wine_vk_list_remove(&wine_vk_surface->link);
+
+    if (wine_vk_surface->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_surface->wayland_surface);
+    if (wine_vk_surface->dummy_wl_surface)
+        wl_surface_destroy(wine_vk_surface->dummy_wl_surface);
+
+    free(wine_vk_surface);
+}
+
+static struct wine_vk_surface *wine_vk_surface_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *surf;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+        if (surf->native_vk_surface == handle) goto out;
+
+    surf = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return surf;
+}
+
+static BOOL wine_vk_surface_handle_is_valid(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(handle);
+    return wine_vk_surface && __atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST);
+}
+
+static BOOL wine_vk_surface_is_remote(struct wine_vk_surface *wine_vk_surface)
+{
+    return wine_vk_surface && wine_vk_surface->dummy_wl_surface;
+}
+
+static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    wine_vk_list_remove(&wine_vk_swapchain->link);
+
+    if (wine_vk_swapchain->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
+
+    if (wine_vk_swapchain->remote_vk_swapchain)
+        wayland_remote_vk_swapchain_destroy(wine_vk_swapchain->remote_vk_swapchain,
+                                            wine_vk_swapchain->wine_vk_device->dev);
+
+    free(wine_vk_swapchain);
+}
+
+static struct wine_vk_swapchain *wine_vk_swapchain_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_swapchain *swap;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+        if (swap->native_vk_swapchain == handle) goto out;
+
+    swap = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return swap;
+}
+
+static BOOL wine_vk_swapchain_is_remote(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    return wine_vk_swapchain && wine_vk_swapchain->remote_vk_swapchain;
+}
+
+static BOOL vk_extension_props_contain_all(uint32_t count_props,
+                                           VkExtensionProperties *props,
+                                           uint32_t count_required,
+                                           const char * const *required)
+{
+    BOOL supported;
+    unsigned int i, j;
+
+    for (i = 0; i < count_required; i++)
+    {
+        supported = FALSE;
+        for (j = 0; j < count_props; j++)
+        {
+            if (strcmp(props[j].extensionName, required[i]) == 0)
+            {
+                supported = TRUE;
+                break;
+            }
+        }
+        if (!supported)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL vulkan_instance_supports(size_t num_exts, const char **exts)
+{
+    VkExtensionProperties *props = NULL;
+    uint32_t count_props;
+    VkResult vk_res;
+    BOOL res = TRUE;
+
+    vk_res = pvkEnumerateInstanceExtensionProperties(NULL, &count_props, NULL);
+    if (vk_res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateInstanceExtensionProperties failed, res=%d\n", vk_res);
+        res = FALSE;
+        goto out;
+    }
+    props = calloc(count_props, sizeof(*props));
+    if (!props)
+    {
+        ERR("Failed to allocate memory\n");
+        res = FALSE;
+        goto out;
+    }
+    vk_res = pvkEnumerateInstanceExtensionProperties(NULL, &count_props, props);
+    if (vk_res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateInstanceExtensionProperties failed, res=%d\n", vk_res);
+        res = FALSE;
+        goto out;
+    }
+
+    /* These extensions are required to support the remote Vulkan, but may
+     * not be present. */
+    res = vk_extension_props_contain_all(count_props, props, num_exts, exts);
+
+out:
+    free(props);
+    return res;
+}
+
+/* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
+ * Caller is responsible for allocation and cleanup of 'dst'.
+ */
+static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
+                                                     VkInstanceCreateInfo *dst)
+{
+    BOOL supports_remote_vulkan =
+        vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                            instance_extensions_remote_vulkan);
+    unsigned int i, j;
+    uint32_t enabled_extensions_count;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pApplicationInfo = src->pApplicationInfo;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions_count = src->enabledExtensionCount;
+        if (supports_remote_vulkan)
+            enabled_extensions_count += ARRAY_SIZE(instance_extensions_remote_vulkan);
+
+        enabled_extensions = calloc(enabled_extensions_count, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            goto err;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+        {
+            /* Substitute extension with Wayland ones else copy. Long-term, when we
+             * support more extensions, we should store these in a list.
+             */
+            if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_surface"))
+                enabled_extensions[i] = "VK_KHR_wayland_surface";
+            else
+                enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+        }
+
+        if (supports_remote_vulkan)
+        {
+            /* Add the extensions required to support remote Vulkan */
+            for (j = 0; j < ARRAY_SIZE(instance_extensions_remote_vulkan); j++, i++)
+                enabled_extensions[i] = instance_extensions_remote_vulkan[j];
+        }
+
+         dst->ppEnabledExtensionNames = enabled_extensions;
+         dst->enabledExtensionCount = enabled_extensions_count;
+    }
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to convert instance create info\n");
+    free(enabled_extensions);
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
+
+#define RETURN_VK_ERROR_SURFACE_LOST_KHR { \
+    TRACE("VK_ERROR_SURFACE_LOST_KHR\n"); \
+    return VK_ERROR_SURFACE_LOST_KHR; \
+}
+
+static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
+                                         const VkAllocationCallbacks *allocator,
+                                         VkInstance *instance)
+{
+    VkInstanceCreateInfo create_info_host;
+    VkResult res;
+    TRACE("create_info %p, allocator %p, instance %p\n", create_info, allocator, instance);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Perform a second pass on converting VkInstanceCreateInfo. Winevulkan
+     * performed a first pass in which it handles everything except for WSI
+     * functionality such as VK_KHR_win32_surface. Handle this now.
+     */
+    res = wine_vk_instance_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to convert instance create info, res=%d\n", res);
+        return res;
+    }
+
+    res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
+static VkResult wine_vk_device_convert_create_info(struct wine_vk_device *wine_vk_device,
+                                                   const VkDeviceCreateInfo *src,
+                                                   VkDeviceCreateInfo *dst)
+{
+    unsigned int i, j;
+    uint32_t enabled_extensions_count;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+    dst->pEnabledFeatures = src->pEnabledFeatures;
+    dst->pQueueCreateInfos = src->pQueueCreateInfos;
+    dst->queueCreateInfoCount = src->queueCreateInfoCount;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions_count = src->enabledExtensionCount;
+        if (wine_vk_device->supports_remote_vulkan)
+            enabled_extensions_count += ARRAY_SIZE(device_extensions_remote_vulkan);
+
+        enabled_extensions = calloc(enabled_extensions_count, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            goto err;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+            enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+
+        if (wine_vk_device->supports_remote_vulkan)
+        {
+            /* Add the extensions required to support remote Vulkan */
+            for (j = 0; j < ARRAY_SIZE(device_extensions_remote_vulkan); j++, i++)
+                enabled_extensions[i] = device_extensions_remote_vulkan[j];
+        }
+
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = enabled_extensions_count;
+    }
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to convert device create info\n");
+    free(enabled_extensions);
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
+
+static struct wine_vk_device *wine_vk_device_from_handle(VkDevice handle)
+{
+    struct wine_vk_device *wine_vk_device;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(wine_vk_device, &wine_vk_device_list, link)
+        if (wine_vk_device->dev == handle) goto out;
+
+    wine_vk_device = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return wine_vk_device;
+}
+
+static void wine_vk_device_destroy(struct wine_vk_device *wine_vk_device)
+{
+    wine_vk_list_remove(&wine_vk_device->link);
+    free(wine_vk_device);
+}
+
+static VkResult wayland_vkCreateDevice(VkPhysicalDevice physical_device,
+                                       const VkDeviceCreateInfo *create_info,
+                                       const VkAllocationCallbacks *allocator,
+                                       VkDevice *device)
+{
+    VkDeviceCreateInfo create_info_host = {0};
+    VkResult res;
+    struct wine_vk_device *wine_vk_device;
+    VkExtensionProperties *props = NULL;
+    uint32_t count_props;
+
+    TRACE("%p %p %p %p\n", physical_device, create_info, allocator, device);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_device = calloc(1, sizeof(*wine_vk_device));
+    if (!wine_vk_device)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    res = pvkEnumerateDeviceExtensionProperties(physical_device, NULL, &count_props, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateDeviceExtensionProperties failed, res=%d\n", res);
+        goto err;
+    }
+    props = calloc(count_props, sizeof(*props));
+    if (!props)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+    res = pvkEnumerateDeviceExtensionProperties(physical_device, NULL, &count_props, props);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateDeviceExtensionProperties failed, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_device->supports_remote_vulkan =
+        vk_extension_props_contain_all(count_props, props,
+                                       ARRAY_SIZE(device_extensions_remote_vulkan),
+                                       device_extensions_remote_vulkan) &&
+        vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                 instance_extensions_remote_vulkan);
+
+    free(props);
+    props = NULL;
+
+    res = wine_vk_device_convert_create_info(wine_vk_device, create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    res = pvkCreateDevice(physical_device, &create_info_host, NULL /* allocator */, device);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create VkDevice, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_device->dev = *device;
+    wine_vk_device->phys_dev = physical_device;
+
+    wl_list_init(&wine_vk_device->link);
+
+    wine_vk_list_add(&wine_vk_device_list, &wine_vk_device->link);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+
+err:
+    ERR("Failed to create VkDevice\n");
+    free(wine_vk_device);
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
+static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
+                                             const VkSwapchainCreateInfoKHR *create_info,
+                                             const VkAllocationCallbacks *allocator,
+                                             VkSwapchainKHR *swapchain)
+{
+    VkResult res;
+    struct wine_vk_device *wine_vk_device;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    VkSwapchainCreateInfoKHR info = *create_info;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Wayland can't deal with 0x0 swapchains, use the minimum 1x1. */
+    if (info.imageExtent.width == 0)
+        info.imageExtent.width = 1;
+    if (info.imageExtent.height == 0)
+        info.imageExtent.height = 1;
+
+    wine_vk_device = wine_vk_device_from_handle(device);
+    if (!wine_vk_device)
+        return VK_ERROR_DEVICE_LOST;
+
+    wine_vk_surface = wine_vk_surface_from_handle(info.surface);
+    if (!wine_vk_surface || !__atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    wine_vk_swapchain = calloc(1, sizeof(*wine_vk_swapchain));
+    if (!wine_vk_swapchain)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_swapchain->link);
+
+    res = pvkCreateSwapchainKHR(device, &info, NULL /* allocator */, swapchain);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    wine_vk_swapchain->hwnd = wine_vk_surface->hwnd;
+    if (wine_vk_surface->wayland_surface)
+    {
+        if (!wayland_surface_create_or_ref_glvk(wine_vk_surface->wayland_surface))
+        {
+            ERR("Failed to create or ref vulkan surface owned by " \
+                "wine_vk_surface=%p\n", wine_vk_surface);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
+    }
+    else
+    {
+        if (!wine_vk_device->supports_remote_vulkan)
+        {
+            ERR("Failed to create remote Vulkan swapchain, required extensions " \
+                "not supported by VkDevice %p\n", wine_vk_device->dev);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->remote_vk_swapchain =
+            wayland_remote_vk_swapchain_create(wine_vk_swapchain->hwnd,
+                                               wine_vk_surface->instance,
+                                               wine_vk_device->phys_dev,
+                                               wine_vk_device->dev,
+                                               &vulkan_funcs,
+                                               &info);
+        if (!wine_vk_swapchain->remote_vk_swapchain)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->p_vkGetSemaphoreFdKHR =
+            pvkGetDeviceProcAddr(device, "vkGetSemaphoreFdKHR");
+        if (!wine_vk_swapchain->p_vkGetSemaphoreFdKHR)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+
+    wine_vk_swapchain->wine_vk_device = wine_vk_device;
+    wine_vk_swapchain->native_vk_swapchain = *swapchain;
+    wine_vk_swapchain->extent = info.imageExtent;
+    wine_vk_swapchain->valid = TRUE;
+
+    wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
+
+    return res;
+
+err:
+    wine_vk_swapchain_destroy(wine_vk_swapchain);
+    return res;
+}
+
+static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
+                                                const VkWin32SurfaceCreateInfoKHR *create_info,
+                                                const VkAllocationCallbacks *allocator,
+                                                VkSurfaceKHR *vk_surface)
+{
+    VkResult res;
+    VkWaylandSurfaceCreateInfoKHR create_info_host;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wayland_surface *wayland_surface;
+    BOOL ref_vk;
+
+    TRACE("%p %p %p %p\n", instance, create_info, allocator, vk_surface);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_surface = calloc(1, sizeof(*wine_vk_surface));
+    if (!wine_vk_surface)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_surface->link);
+
+    wayland_surface = wayland_surface_for_hwnd_lock(create_info->hwnd);
+    if (wayland_surface)
+    {
+        ref_vk = wayland_surface_create_or_ref_glvk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_vk)
+        {
+            ERR("Failed to create or ref vulkan surface for hwnd=%p\n", create_info->hwnd);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_surface->wayland_surface = wayland_surface;
+    }
+    else
+    {
+        struct wayland *wayland;
+        if (!vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                      instance_extensions_remote_vulkan))
+        {
+            ERR("Failed to create remote Vulkan surface, required extensions " \
+                "not supported by VkInstance %p\n", instance);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wayland = wayland_process_acquire();
+        wine_vk_surface->dummy_wl_surface =
+            wl_compositor_create_surface(wayland->wl_compositor);
+        wayland_process_release();
+        if (!wine_vk_surface->dummy_wl_surface)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+
+    create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
+    create_info_host.pNext = NULL;
+    create_info_host.flags = 0; /* reserved */
+    create_info_host.display = process_wl_display;
+    if (wine_vk_surface->wayland_surface)
+        create_info_host.surface = wine_vk_surface->wayland_surface->glvk->wl_surface;
+    else
+        create_info_host.surface = wine_vk_surface->dummy_wl_surface;
+
+    res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host, NULL /* allocator */, vk_surface);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create vulkan wayland surface, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_surface->hwnd = create_info->hwnd;
+    wine_vk_surface->instance = instance;
+    wine_vk_surface->native_vk_surface = *vk_surface;
+    wine_vk_surface->valid = TRUE;
+
+    wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
+
+    TRACE("Created surface=0x%s\n", wine_dbgstr_longlong(*vk_surface));
+    return VK_SUCCESS;
+
+err:
+    wine_vk_surface_destroy(wine_vk_surface);
+    return res;
+}
+
+static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
+{
+    TRACE("%p %p\n", instance, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    pvkDestroyInstance(instance, NULL /* allocator */);
+}
+
+static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
+                                        const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+
+    TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_surface)
+    {
+        pvkDestroySurfaceKHR(instance, wine_vk_surface->native_vk_surface,
+                             NULL /* allocator */);
+        wine_vk_surface_destroy(wine_vk_surface);
+    }
+}
+
+static void wayland_vkDestroySwapchainKHR(VkDevice device,
+                                          VkSwapchainKHR swapchain,
+                                          const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_swapchain)
+    {
+        pvkDestroySwapchainKHR(device, wine_vk_swapchain->native_vk_swapchain,
+                               NULL /* allocator */);
+        wine_vk_swapchain_destroy(wine_vk_swapchain);
+    }
+}
+
+static void wayland_vkDestroyDevice(VkDevice device,
+                                    const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_device *wine_vk_device = wine_vk_device_from_handle(device);
+
+    TRACE("%p %p\n", device, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_device)
+    {
+        pvkDestroyDevice(device, NULL /* allocator */);
+        wine_vk_device_destroy(wine_vk_device);
+    }
+}
+
+static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer_name,
+                                                               uint32_t *count,
+                                                               VkExtensionProperties* properties)
+{
+    unsigned int i;
+    VkResult res;
+
+    TRACE("layer_name %s, count %p, properties %p\n", debugstr_a(layer_name), count, properties);
+
+    /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
+    if (layer_name)
+    {
+        ERR("Layer enumeration not supported from ICD.\n");
+        return VK_ERROR_LAYER_NOT_PRESENT;
+    }
+
+    /* We will return the same number of instance extensions reported by the host back to
+     * winevulkan. Along the way we may replace xlib extensions with their win32 equivalents.
+     * Winevulkan will perform more detailed filtering as it knows whether it has thunks
+     * for a particular extension.
+     */
+    res = pvkEnumerateInstanceExtensionProperties(layer_name, count, properties);
+    if (!properties || res < 0)
+        return res;
+
+    for (i = 0; i < *count; i++)
+    {
+        /* For now the only wayland extension we need to fixup. Long-term we may need an array. */
+        if (!strcmp(properties[i].extensionName, "VK_KHR_wayland_surface"))
+        {
+            TRACE("Substituting VK_KHR_wayland_surface for VK_KHR_win32_surface\n");
+
+            snprintf(properties[i].extensionName, sizeof(properties[i].extensionName),
+                    VK_KHR_WIN32_SURFACE_EXTENSION_NAME);
+            properties[i].specVersion = VK_KHR_WIN32_SURFACE_SPEC_VERSION;
+        }
+    }
+
+    TRACE("Returning %u extensions.\n", *count);
+    return res;
+}
+
+static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
+                                                               VkSurfaceKHR surface,
+                                                               VkDeviceGroupPresentModeFlagsKHR *flags)
+{
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(surface), flags);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
+}
+
+static void *wayland_vkGetDeviceProcAddr(VkDevice device, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", device, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_device_proc_addr(&vulkan_funcs, name)))
+        return proc_addr;
+
+    return pvkGetDeviceProcAddr(device, name);
+}
+
+static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", instance, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_instance_proc_addr(&vulkan_funcs, instance, name)))
+        return proc_addr;
+
+    return pvkGetInstanceProcAddr(instance, name);
+}
+
+static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice phys_dev,
+                                                                VkSurfaceKHR surface,
+                                                                uint32_t *count, VkRect2D *rects)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, rects);
+
+    return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
+}
+
+/* Set the image extent in the capabilities to match what Windows expects. */
+static void set_image_extent(VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *caps)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    BOOL zero_extents = FALSE;
+
+    if (!wine_vk_surface)
+        return;
+
+    if (wine_vk_surface_is_remote(wine_vk_surface))
+    {
+        /* For cross-process surfaces, we don't have the information of
+         * drawing_allowed. So we set zero_extents to FALSE. That is safe to do
+         * because the process that will call wl_surface_commit() won't commit
+         * anything when drawing_allowed == FALSE. */
+        zero_extents = FALSE;
+    }
+    else
+    {
+        assert(wine_vk_surface->wayland_surface);
+        wayland_mutex_lock(&wine_vk_surface->wayland_surface->mutex);
+        if (!wine_vk_surface->wayland_surface->drawing_allowed)
+            zero_extents = TRUE;
+        wayland_mutex_unlock(&wine_vk_surface->wayland_surface->mutex);
+    }
+
+    if (NtUserGetWindowLongW(wine_vk_surface->hwnd, GWL_STYLE) & WS_MINIMIZE)
+        zero_extents = TRUE;
+
+    if (zero_extents)
+    {
+        caps->minImageExtent.width = 0;
+        caps->minImageExtent.height = 0;
+        caps->maxImageExtent.width = 0;
+        caps->maxImageExtent.height = 0;
+        caps->currentExtent.width = 0;
+        caps->currentExtent.height = 0;
+    }
+    else
+    {
+        RECT client;
+        NtUserGetClientRect(wine_vk_surface->hwnd, &client);
+
+        caps->minImageExtent.width = client.right;
+        caps->minImageExtent.height = client.bottom;
+        caps->maxImageExtent.width = client.right;
+        caps->maxImageExtent.height = client.bottom;
+        caps->currentExtent.width = client.right;
+        caps->currentExtent.height = client.bottom;
+    }
+
+    TRACE("vk_surface=%s hwnd=%p wayland_surface=%p dummy_wl_surface=%p extent=%dx%d\n",
+          wine_dbgstr_longlong(surface), wine_vk_surface->hwnd,
+          wine_vk_surface->wayland_surface, wine_vk_surface->dummy_wl_surface,
+          caps->currentExtent.width, caps->currentExtent.height);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice phys_dev,
+                                                                   const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                                   VkSurfaceCapabilities2KHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceCapabilities2KHR)
+    {
+        res = pvkGetPhysicalDeviceSurfaceCapabilities2KHR(phys_dev, surface_info,
+                                                          capabilities);
+        goto out;
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext || capabilities->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with "
+              "vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface_info->surface,
+                                                     &capabilities->surfaceCapabilities);
+
+out:
+    if (res == VK_SUCCESS)
+        set_image_extent(surface_info->surface, &capabilities->surfaceCapabilities);
+
+    return res;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  VkSurfaceCapabilitiesKHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
+
+    if (res == VK_SUCCESS)
+        set_image_extent(surface, capabilities);
+
+    return res;
+}
+
+static VkResult get_surface_formats2(VkPhysicalDevice phys_dev,
+                                     const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                     uint32_t *count, VkSurfaceFormat2KHR *formats)
+{
+    struct wine_vk_surface *wine_vk_surface =
+        wine_vk_surface_from_handle(surface_info->surface);
+    uint32_t count_host_formats;
+    VkSurfaceFormat2KHR *host_formats = NULL;
+    VkResult res = VK_SUCCESS;
+
+    if (!wine_vk_surface_is_remote(wine_vk_surface))
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+
+    res = pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                 &count_host_formats, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormats2KHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    host_formats = calloc(count_host_formats, sizeof(*host_formats));
+    if (!host_formats)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto out;
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                 &count_host_formats, host_formats);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormats2KHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    res = wayland_remote_vk_filter_supported_formats(count, formats,
+                                                     count_host_formats, host_formats,
+                                                     sizeof(VkSurfaceFormat2KHR),
+                                                     offsetof(VkSurfaceFormat2KHR,
+                                                              surfaceFormat));
+    if (*count == 0)
+    {
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        ERR("Failed to find formats supported by both host and remote Vulkan\n");
+    }
+
+out:
+    if (res != VK_SUCCESS && res != VK_INCOMPLETE)
+        ERR("Failed to get surface formats\n");
+    free(host_formats);
+    return res;
+}
+
+static VkResult get_surface_formats(VkPhysicalDevice phys_dev, VkSurfaceKHR surface,
+                                    uint32_t *count, VkSurfaceFormatKHR *formats)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    uint32_t count_host_formats;
+    VkSurfaceFormatKHR *host_formats = NULL;
+    VkResult res = VK_SUCCESS;
+
+    if (!wine_vk_surface_is_remote(wine_vk_surface))
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                     count, formats);
+
+    res = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                &count_host_formats, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormatsKHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    host_formats = calloc(count_host_formats, sizeof(*host_formats));
+    if (!host_formats)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto out;
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                &count_host_formats, host_formats);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormatsKHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    res = wayland_remote_vk_filter_supported_formats(count, formats,
+                                                     count_host_formats, host_formats,
+                                                     sizeof(VkSurfaceFormatKHR), 0);
+    if (*count == 0)
+    {
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        ERR("Failed to find formats supported by both host and remote Vulkan\n");
+    }
+
+out:
+    if (res != VK_SUCCESS && res != VK_INCOMPLETE)
+        ERR("Failed to get surface formats\n");
+    free(host_formats);
+    return res;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
+                                                              const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                              uint32_t *count,
+                                                              VkSurfaceFormat2KHR *formats)
+{
+    VkSurfaceFormatKHR *formats_host;
+    uint32_t i;
+    VkResult result;
+    TRACE("%p, %p, %p, %p\n", phys_dev, surface_info, count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
+        return get_surface_formats2(phys_dev, surface_info, count, formats);
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceFormats2KHR with "
+              "vkGetPhysicalDeviceSurfaceFormatsKHR, pNext is ignored.\n");
+    }
+
+    if (!formats)
+        return get_surface_formats(phys_dev, surface_info->surface, count, NULL);
+
+    formats_host = calloc(*count, sizeof(*formats_host));
+    if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    result = get_surface_formats(phys_dev, surface_info->surface, count, formats_host);
+    if (result == VK_SUCCESS || result == VK_INCOMPLETE)
+    {
+        for (i = 0; i < *count; i++)
+            formats[i].surfaceFormat = formats_host[i];
+    }
+
+    free(formats_host);
+    return result;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice phys_dev,
+                                                             VkSurfaceKHR surface,
+                                                             uint32_t *count,
+                                                             VkSurfaceFormatKHR *formats)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return get_surface_formats(phys_dev, surface, count, formats);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  uint32_t *count,
+                                                                  VkPresentModeKHR *modes)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, modes);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice phys_dev,
+                                                             uint32_t index,
+                                                             VkSurfaceKHR surface,
+                                                             VkBool32 *supported)
+{
+    TRACE("%p, %u, 0x%s, %p\n", phys_dev, index, wine_dbgstr_longlong(surface), supported);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
+}
+
+static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice phys_dev,
+                                                                       uint32_t index)
+{
+    TRACE("%p %u\n", phys_dev, index);
+
+    return pvkGetPhysicalDeviceWaylandPresentationSupportKHR(phys_dev, index,
+                                                             process_wl_display);
+}
+
+static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p %p\n", device, wine_dbgstr_longlong(swapchain), count, images);
+
+    if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        return wayland_remote_vk_swapchain_get_images(wine_vk_swapchain->remote_vk_swapchain,
+                                                      count, images);
+
+    return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
+}
+
+static VkResult wayland_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                              uint64_t timeout, VkSemaphore semaphore,
+                                              VkFence fence, uint32_t *image_index)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p 0x%s 0x%s 0x%s 0x%s %p\n",
+          device, wine_dbgstr_longlong(swapchain), wine_dbgstr_longlong(timeout),
+          wine_dbgstr_longlong(semaphore), wine_dbgstr_longlong(fence), image_index);
+
+    if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        return wayland_remote_vk_swapchain_acquire_next_image(wine_vk_swapchain->remote_vk_swapchain,
+                                                              wine_vk_swapchain->wine_vk_device->dev,
+                                                              timeout, semaphore, fence, image_index);
+
+    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+}
+
+static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
+{
+    uint32_t i;
+    VkResult res = VK_SUCCESS;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+        BOOL drawing_allowed;
+        RECT client;
+
+        if (!wine_vk_swapchain)
+        {
+            drawing_allowed = FALSE;
+        }
+        else
+        {
+            if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+            {
+                /* For cross-process swapchains, we don't have the information
+                 * of drawing_allowed. So we assume it is TRUE. That is safe to
+                 * do because the process that will call wl_surface_commit()
+                 * won't commit anything when drawing_allowed == FALSE. */
+                drawing_allowed = TRUE;
+            }
+            else
+            {
+                assert(wine_vk_swapchain->wayland_surface);
+                drawing_allowed = wine_vk_swapchain->wayland_surface->drawing_allowed;
+            }
+        }
+
+        TRACE("swapchain[%d] vk=0x%s wine=%p extent=%dx%d wayland_surface=%p "
+               "remote_swapchain=%p drawing_allowed=%d\n",
+               i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.width : 0,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.height : 0,
+               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
+               wine_vk_swapchain ? wine_vk_swapchain->remote_vk_swapchain : NULL,
+               drawing_allowed);
+
+        if (!wine_vk_swapchain ||
+            !__atomic_load_n(&wine_vk_swapchain->valid, __ATOMIC_SEQ_CST) ||
+            !NtUserGetClientRect(wine_vk_swapchain->hwnd, &client))
+        {
+            res = VK_ERROR_SURFACE_LOST_KHR;
+        }
+        else if (client.right != wine_vk_swapchain->extent.width ||
+                 client.bottom != wine_vk_swapchain->extent.height ||
+                 !drawing_allowed)
+        {
+            if (res == VK_SUCCESS) res = VK_ERROR_OUT_OF_DATE_KHR;
+        }
+
+        /* Since Vulkan content is presented on a Wayland subsurface, we need
+         * to ensure the parent Wayland surface is mapped for the Vulkan
+         * content to be visible. */
+        if (drawing_allowed && !wine_vk_swapchain_is_remote(wine_vk_swapchain))
+            wayland_surface_ensure_mapped(wine_vk_swapchain->wayland_surface);
+    }
+
+    /* In case of error in any swapchain, we are not going to present at all,
+     * so mark all swapchains as failures. */
+    if (res != VK_SUCCESS && present_info->pResults)
+    {
+        for (i = 0; i < present_info->swapchainCount; ++i)
+            present_info->pResults[i] = res;
+    }
+
+    return res;
+}
+
+static void lock_swapchain_wayland_surfaces(const VkPresentInfoKHR *present_info,
+                                            BOOL lock)
+{
+    uint32_t i;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+
+        if (wine_vk_swapchain && wine_vk_swapchain->wayland_surface)
+        {
+            if (lock)
+                wayland_mutex_lock(&wine_vk_swapchain->wayland_surface->mutex);
+            else
+                wayland_mutex_unlock(&wine_vk_swapchain->wayland_surface->mutex);
+        }
+    }
+}
+
+static int queue_present_wait_semaphores(struct wine_vk_swapchain *swapchain,
+                                         const VkPresentInfoKHR *present_info)
+{
+    struct pollfd pollfd;
+    int semaphore_fd = -1;
+    unsigned int i;
+    int ret;
+    VkSemaphoreGetFdInfoKHR get_fd_info = {0};
+    VkResult res;
+
+    if (present_info->waitSemaphoreCount == 0)
+        return 0;
+
+    get_fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    get_fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+
+    for (i = 0; i < present_info->waitSemaphoreCount; i++)
+    {
+        /* Current semaphore to wait for */
+        get_fd_info.semaphore = present_info->pWaitSemaphores[i];
+
+        res = swapchain->p_vkGetSemaphoreFdKHR(swapchain->wine_vk_device->dev,
+                                               &get_fd_info, &semaphore_fd);
+        if (res != VK_SUCCESS)
+        {
+            ERR("vkGetSemaphoreFdKHR failed, res=%d\n", res);
+            semaphore_fd = -1;
+            goto err;
+        }
+        if (semaphore_fd < 0)
+        {
+            ERR("Invalid semaphore fd\n");
+            goto err;
+        }
+
+        pollfd.fd = semaphore_fd;
+        pollfd.events = POLLIN;
+
+        while ((ret = poll(&pollfd, 1, -1)) == -1 && errno == EINTR)
+            continue;
+
+        if (ret < 0)
+        {
+            ERR("Poll fd failed errno=%d\n", errno);
+            goto err;
+        }
+        if (pollfd.revents & (POLLERR | POLLHUP | POLLNVAL))
+        {
+            ERR("Poll fd failed\n");
+            goto err;
+        }
+
+        close(semaphore_fd);
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to wait for semaphores before presenting queue\n");
+    if (semaphore_fd >= 0)
+        close(semaphore_fd);
+    return -1;
+}
+
+static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *present_info)
+{
+    VkResult res;
+    unsigned int i;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    int res_chain;
+    BOOL failed = FALSE;
+
+    TRACE("%p, %p\n", queue, present_info);
+
+    /* Lock the surfaces to ensure we don't present while reconfiguration is
+     * taking place, so we don't inadvertently commit an in-progress,
+     * incomplete configuration state. */
+    lock_swapchain_wayland_surfaces(present_info, TRUE);
+
+    if ((res = validate_present_info(present_info)) == VK_SUCCESS)
+    {
+        wine_vk_swapchain = wine_vk_swapchain_from_handle(present_info->pSwapchains[0]);
+        if (!wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        {
+            /* We are not dealing with cross-process swapchains, so we don't
+             * have to use our remote Vulkan implementation to present */
+            res = pvkQueuePresentKHR(queue, present_info);
+        }
+        else
+        {
+            /* We are dealing with cross-process swapchains, so use our remote
+             * Vulkan implementation to present */
+            if (present_info->swapchainCount == 0 || !present_info->pSwapchains)
+            {
+                ERR("Invalid number of swapchains to present: 0\n");
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                goto out;
+            }
+            for (i = 0; i < present_info->swapchainCount; i++)
+            {
+                wine_vk_swapchain = wine_vk_swapchain_from_handle(present_info->pSwapchains[i]);
+
+                /* Before presenting the 1st swapchain, wait for the semaphores */
+                if (i == 0 && queue_present_wait_semaphores(wine_vk_swapchain, present_info) < 0)
+                {
+                    res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                    goto out;
+                }
+
+                res_chain = wayland_remote_vk_swapchain_present(wine_vk_swapchain->remote_vk_swapchain,
+                                                                present_info->pImageIndices[i]);
+                if (res_chain < 0)
+                    failed = TRUE;
+
+                if (present_info->pResults)
+                    present_info->pResults[i] = failed ? VK_ERROR_OUT_OF_HOST_MEMORY : VK_SUCCESS;
+            }
+
+            /* If presenting any of the swapchains fails, this function fails */
+            if (failed)
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
+
+out:
+    lock_swapchain_wayland_surfaces(present_info, FALSE);
+    return res;
+}
+
+/* The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
+ * native surface. */
+static VkSurfaceKHR wayland_wine_get_native_surface(VkSurfaceKHR surface)
+{
+    TRACE("0x%s\n", wine_dbgstr_longlong(surface));
+    return surface;
+}
+
+static void wine_vk_init(void)
+{
+    if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    {
+        ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+#define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkAcquireNextImageKHR);
+    LOAD_FUNCPTR(vkCreateDevice);
+    LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateSwapchainKHR);
+    LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
+    LOAD_FUNCPTR(vkDestroyDevice);
+    LOAD_FUNCPTR(vkDestroyInstance);
+    LOAD_FUNCPTR(vkDestroySurfaceKHR);
+    LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkEnumerateDeviceExtensionProperties);
+    LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
+    LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetDeviceProcAddr);
+    LOAD_FUNCPTR(vkGetInstanceProcAddr);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
+    LOAD_FUNCPTR(vkGetSwapchainImagesKHR);
+    LOAD_FUNCPTR(vkQueuePresentKHR);
+#undef LOAD_FUNCPTR
+#undef LOAD_OPTIONAL_FUNCPTR
+
+    return;
+
+fail:
+    dlclose(vulkan_handle);
+    vulkan_handle = NULL;
+}
+
+static const struct vulkan_funcs vulkan_funcs =
+{
+    .p_vkAcquireNextImageKHR = wayland_vkAcquireNextImageKHR,
+    .p_vkCreateDevice = wayland_vkCreateDevice,
+    .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
+    .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
+    .p_vkDestroyDevice = wayland_vkDestroyDevice,
+    .p_vkDestroyInstance = wayland_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
+    .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
+    .p_wine_get_native_surface = wayland_wine_get_native_surface,
+};
+
+/**********************************************************************
+ *           WAYLAND_wine_get_vulkan_driver
+ */
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+
+    if (version != WINE_VULKAN_DRIVER_VERSION)
+    {
+        ERR("version mismatch, vulkan wants %u but driver has %u\n", version, WINE_VULKAN_DRIVER_VERSION);
+        return NULL;
+    }
+
+    pthread_once(&init_once, wine_vk_init);
+    if (vulkan_handle)
+        return &vulkan_funcs;
+
+    return NULL;
+}
+
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+    struct wine_vk_swapchain *swap;
+    struct wine_vk_surface *surf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+    {
+        if (swap->hwnd == hwnd)
+            __atomic_store_n(&swap->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+    {
+        if (surf->hwnd == hwnd)
+            __atomic_store_n(&surf->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+#else /* No vulkan */
+
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    ERR("Wine was built without Vulkan support.\n");
+    return NULL;
+}
+
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+}
+
+#endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
new file mode 100644
index 00000000000..726f064d1b1
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -0,0 +1,817 @@
+/* WAYLANDDRV Vulkan remote implementation
+ *
+ * Copyright 2022 Leandro Ribeiro
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+#include "vulkan_remote.h"
+
+#include <drm_fourcc.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+struct vk_funcs
+{
+    PFN_vkCreateImage p_vkCreateImage;
+    PFN_vkDestroyImage p_vkDestroyImage;
+    PFN_vkAllocateMemory p_vkAllocateMemory;
+    PFN_vkFreeMemory p_vkFreeMemory;
+    PFN_vkBindImageMemory p_vkBindImageMemory;
+    PFN_vkGetImageMemoryRequirements p_vkGetImageMemoryRequirements;
+    PFN_vkGetPhysicalDeviceMemoryProperties p_vkGetPhysicalDeviceMemoryProperties;
+    PFN_vkImportSemaphoreFdKHR p_vkImportSemaphoreFdKHR;
+    PFN_vkImportFenceFdKHR p_vkImportFenceFdKHR;
+    PFN_vkGetMemoryFdKHR p_vkGetMemoryFdKHR;
+    PFN_vkGetImageSubresourceLayout p_vkGetImageSubresourceLayout;
+};
+
+struct wayland_remote_vk_image
+{
+    VkImage native_vk_image;
+    VkDeviceMemory native_vk_image_memory;
+    VkFormat format;
+    uint32_t width, height;
+    BOOL busy;
+    struct wayland_native_buffer native_buffer;
+    HANDLE remote_buffer_released_event;
+};
+
+struct wayland_remote_vk_swapchain
+{
+    struct vk_funcs vk_funcs;
+    struct wayland_remote_surface_proxy *remote_surface_proxy;
+    uint32_t count_images;
+    struct wayland_remote_vk_image *images;
+    enum wayland_remote_buffer_commit buffer_commit;
+    HANDLE remote_throttle_event;
+};
+
+struct drm_vk_format
+{
+    VkFormat vk_format;
+    VkFormat vk_format_srgb;
+    uint32_t drm_format;
+    uint32_t drm_format_alpha;
+};
+
+/* List of Vulkan formats that we know, and the corresponding DRM formats */
+const static struct drm_vk_format format_table[] =
+{
+    {VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, DRM_FORMAT_XBGR8888, DRM_FORMAT_ABGR8888},
+    {VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_B8G8R8A8_SRGB, DRM_FORMAT_XRGB8888, DRM_FORMAT_ARGB8888},
+};
+
+/* Convert timeout in ms to the timeout format used by ntdll which is:
+ * 100ns units, negative for monotonic time. */
+static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
+{
+    if (timeout_ms == -1)
+        return NULL;
+
+    time->QuadPart = (ULONGLONG)timeout_ms * -10000;
+
+    return time;
+}
+
+static UINT get_tick_count_since(UINT start)
+{
+    UINT now = NtGetTickCount();
+    /* Handle tick count wrap around to zero. */
+    if (now < start)
+        return 0xffffffff - start + now + 1;
+    else
+        return now - start;
+}
+
+static uint32_t vulkan_format_to_drm_format(VkFormat format, BOOL ignore_alpha)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(format_table); i++)
+    {
+        const struct drm_vk_format *dvf = &format_table[i];
+        if (dvf->vk_format == format || dvf->vk_format_srgb == format)
+            return ignore_alpha ? dvf->drm_format : dvf->drm_format_alpha;
+    }
+
+    return DRM_FORMAT_INVALID;
+}
+
+static int wayland_native_buffer_init_vk(VkInstance instance, VkPhysicalDevice physical_device,
+                                         VkDevice device, struct vk_funcs *vk_funcs,
+                                         BOOL ignore_alpha, struct wayland_remote_vk_image *image)
+{
+    struct wayland_native_buffer *buffer = &image->native_buffer;
+    VkMemoryGetFdInfoKHR memory_get_fd_info = {0};
+    VkSubresourceLayout layout;
+    VkImageSubresource image_subresource = {0};
+    VkResult res;
+
+    buffer->modifier = DRM_FORMAT_MOD_LINEAR;
+    buffer->plane_count = 1;
+
+    memory_get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+    memory_get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+    memory_get_fd_info.memory = image->native_vk_image_memory;
+
+    res = vk_funcs->p_vkGetMemoryFdKHR(device, &memory_get_fd_info, &buffer->fds[0]);
+    if (res != VK_SUCCESS)
+    {
+        buffer->fds[0] = -1;
+        ERR("pfn_vkGetMemoryFdKHR failed, res=%d\n", res);
+        goto err;
+    }
+
+    image_subresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    vk_funcs->p_vkGetImageSubresourceLayout(device, image->native_vk_image,
+                                            &image_subresource, &layout);
+    buffer->offsets[0] = layout.offset;
+    buffer->strides[0] = layout.rowPitch;
+
+    buffer->format = vulkan_format_to_drm_format(image->format, ignore_alpha);
+    if (buffer->format == DRM_FORMAT_INVALID)
+    {
+        ERR("Failed to get corresponding DRM format for Vulkan format %d\n", image->format);
+        goto err;
+    }
+    buffer->width = image->width;
+    buffer->height = image->height;
+
+    return 0;
+
+err:
+    wayland_native_buffer_deinit(buffer);
+    ERR("Failed to init wayland_native_buffer for Vulkan image\n");
+    return -1;
+}
+
+static int get_image_create_flags(VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    uint32_t flags = 0;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_PROTECTED_BIT;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
+
+    return flags;
+}
+
+static VkImage create_vulkan_image(VkDevice device, struct vk_funcs *vk_funcs,
+                                   VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    VkExternalMemoryImageCreateInfo external_memory_create_info = {0};
+    VkImageCreateInfo image_create_info = {0};
+    VkResult res;
+    VkImage image;
+
+    external_memory_create_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+    external_memory_create_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+
+    image_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+    image_create_info.pNext = &external_memory_create_info;
+    image_create_info.imageType = VK_IMAGE_TYPE_2D;
+    image_create_info.format = chain_create_info->imageFormat;
+    image_create_info.extent.width = chain_create_info->imageExtent.width;
+    image_create_info.extent.height = chain_create_info->imageExtent.height;
+    image_create_info.extent.depth = 1;
+    image_create_info.arrayLayers = chain_create_info->imageArrayLayers;
+    image_create_info.sharingMode = chain_create_info->imageSharingMode;
+    image_create_info.usage = chain_create_info->imageUsage;
+    image_create_info.mipLevels = 1;
+    image_create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    image_create_info.samples = VK_SAMPLE_COUNT_1_BIT;
+    /* We'll create dma-buf buffers for these images, and so we'll need to know
+     * the layout of them on memory. When VK_EXT_image_drm_format_modifier is
+     * not supported, we can't use TILING_DRM_FORMAT_MODIFIER_EXT, so that
+     * leaves us with TILING_LINEAR or TILING_OPTIMAL available. If we choose
+     * TILING_OPTIMAL, we are not able to query the modifier chosen by the
+     * driver and the number of planes (because we don't have the extension to
+     * do so). So it'd be impossible to create dma-buf buffers. This leaves us
+     * with TILING_LINEAR, and that makes drivers decisions predictable and we
+     * can assume that they'll pick DRM_FORMAT_MOD_LINEAR and there'll be a
+     * single plane. This might fail for drivers that do not support modifiers
+     * at all, but we can't do better than that. */
+    image_create_info.tiling = VK_IMAGE_TILING_LINEAR;
+    image_create_info.flags = get_image_create_flags(chain_create_info);
+
+    res = vk_funcs->p_vkCreateImage(device, &image_create_info, NULL, &image);
+    if (res != VK_SUCCESS)
+    {
+        ERR("vkCreateImage failed, res=%d\n", res);
+        goto err;
+    }
+
+    return image;
+
+err:
+    ERR("Failed to create Vulkan image\n");
+    return VK_NULL_HANDLE;
+}
+
+static int get_memory_property_flags(VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    uint32_t flags = 0;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR)
+        flags |= VK_MEMORY_PROPERTY_PROTECTED_BIT;
+
+    return flags;
+}
+
+static VkDeviceMemory create_vulkan_image_memory(VkInstance instance, VkPhysicalDevice physical_device,
+                                                 VkDevice device, struct vk_funcs *vk_funcs,
+                                                 VkSwapchainCreateInfoKHR *chain_create_info,
+                                                 VkImage image)
+{
+    int32_t mem_type_index = -1;
+    uint32_t flags;
+    unsigned int i;
+    VkMemoryRequirements mem_reqs;
+    VkPhysicalDeviceMemoryProperties mem_props;
+    VkExportMemoryAllocateInfo export_alloc_info = {0};
+    VkMemoryAllocateInfo alloc_info = {0};
+    VkResult res;
+    VkDeviceMemory image_mem;
+
+    export_alloc_info.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
+    export_alloc_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+
+    alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+    alloc_info.pNext = &export_alloc_info;
+
+    vk_funcs->p_vkGetImageMemoryRequirements(device, image, &mem_reqs);
+    vk_funcs->p_vkGetPhysicalDeviceMemoryProperties(physical_device, &mem_props);
+
+    flags = get_memory_property_flags(chain_create_info);
+    for (i = 0; i < mem_props.memoryTypeCount; i++)
+        if ((mem_reqs.memoryTypeBits & (1 << i)) &&
+            (mem_props.memoryTypes[i].propertyFlags & flags) == flags)
+                mem_type_index = i;
+
+    if (mem_type_index == -1)
+    {
+        ERR("Failed to find memoryTypeIndex\n");
+        goto err;
+    }
+
+    alloc_info.memoryTypeIndex = mem_type_index;
+    alloc_info.allocationSize = mem_reqs.size;
+
+    res = vk_funcs->p_vkAllocateMemory(device, &alloc_info, NULL, &image_mem);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pfn_vkAllocateMemory failed, res=%d\n", res);
+        goto err;
+    }
+
+    return image_mem;
+
+err:
+    ERR("Failed to create Vulkan image memory\n");
+    return VK_NULL_HANDLE;
+}
+
+static void wayland_remote_vk_image_deinit(VkDevice device, struct vk_funcs *vk_funcs,
+                                           struct wayland_remote_vk_image *image)
+{
+    vk_funcs->p_vkDestroyImage(device, image->native_vk_image, NULL);
+    vk_funcs->p_vkFreeMemory(device, image->native_vk_image_memory, NULL);
+
+    if (image->remote_buffer_released_event)
+        NtClose(image->remote_buffer_released_event);
+
+    wayland_native_buffer_deinit(&image->native_buffer);
+}
+
+static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice physical_device,
+                                        VkDevice device, struct vk_funcs *vk_funcs,
+                                        VkSwapchainCreateInfoKHR *create_info,
+                                        struct wayland_remote_vk_image *image)
+{
+    VkResult res;
+    BOOL ignore_alpha;
+    unsigned int i;
+
+    image->native_vk_image = VK_NULL_HANDLE;
+    image->native_vk_image_memory = VK_NULL_HANDLE;
+    image->format = create_info->imageFormat;
+    image->width = create_info->imageExtent.width;
+    image->height = create_info->imageExtent.height;
+    image->busy = FALSE;
+    image->remote_buffer_released_event = 0;
+    for (i = 0; i < ARRAY_SIZE(image->native_buffer.fds); i++)
+        image->native_buffer.fds[i] = -1;
+
+    image->native_vk_image = create_vulkan_image(device, vk_funcs, create_info);
+    if (image->native_vk_image == VK_NULL_HANDLE)
+        goto err;
+
+    image->native_vk_image_memory =
+        create_vulkan_image_memory(instance, physical_device, device,
+                                   vk_funcs, create_info, image->native_vk_image);
+    if (image->native_vk_image_memory == VK_NULL_HANDLE)
+        goto err;
+
+    res = vk_funcs->p_vkBindImageMemory(device, image->native_vk_image,
+                                        image->native_vk_image_memory, 0);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pfn_vkBindImageMemory failed, res=%d\n", res);
+        goto err;
+    }
+
+    ignore_alpha = create_info->compositeAlpha & VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
+    if (wayland_native_buffer_init_vk(instance, physical_device, device, vk_funcs,
+                                      ignore_alpha, image) < 0)
+        goto err;
+
+    return 0;
+
+err:
+    ERR("Failed to create remote swapchain image\n");
+    wayland_remote_vk_image_deinit(device, vk_funcs, image);
+    return -1;
+}
+
+static void wayland_remote_vk_image_release(struct wayland_remote_vk_image *image)
+{
+    if (image->remote_buffer_released_event)
+    {
+        NtClose(image->remote_buffer_released_event);
+        image->remote_buffer_released_event = 0;
+    }
+
+    image->busy = FALSE;
+}
+
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
+                                         VkDevice device)
+{
+    if (swapchain->remote_surface_proxy)
+        wayland_remote_surface_proxy_destroy(swapchain->remote_surface_proxy);
+
+    if (swapchain->images)
+    {
+        unsigned int i;
+        for (i = 0; i < swapchain->count_images; i++)
+        {
+            wayland_remote_vk_image_deinit(device, &swapchain->vk_funcs,
+                                           &swapchain->images[i]);
+        }
+        free(swapchain->images);
+    }
+
+    if (swapchain->remote_throttle_event)
+        NtClose(swapchain->remote_throttle_event);
+
+    free(swapchain);
+}
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd, VkInstance instance,
+                                                                       VkPhysicalDevice physical_device,
+                                                                       VkDevice device,
+                                                                       const struct vulkan_funcs *vulkan_funcs,
+                                                                       VkSwapchainCreateInfoKHR *create_info)
+{
+    static const uint32_t min_number_images = 4;
+    struct wayland_remote_vk_swapchain *swapchain;
+    unsigned int i;
+    int res = 0;
+
+    swapchain = calloc(1, sizeof(*swapchain));
+    if (!swapchain)
+    {
+        ERR("Failed to allocate memory\n");
+        goto err;
+    }
+
+#define LOAD_DEVICE_FUNCPTR(f) \
+    if (!(swapchain->vk_funcs.p_##f = vulkan_funcs->p_vkGetDeviceProcAddr(device, #f))) \
+        goto err
+
+#define LOAD_INSTANCE_FUNCPTR(f) \
+    if (!(swapchain->vk_funcs.p_##f = vulkan_funcs->p_vkGetInstanceProcAddr(instance, #f))) \
+        goto err
+
+    LOAD_DEVICE_FUNCPTR(vkCreateImage);
+    LOAD_DEVICE_FUNCPTR(vkDestroyImage);
+    LOAD_DEVICE_FUNCPTR(vkAllocateMemory);
+    LOAD_DEVICE_FUNCPTR(vkFreeMemory);
+    LOAD_DEVICE_FUNCPTR(vkBindImageMemory);
+    LOAD_DEVICE_FUNCPTR(vkGetImageMemoryRequirements);
+    LOAD_INSTANCE_FUNCPTR(vkGetPhysicalDeviceMemoryProperties);
+    LOAD_DEVICE_FUNCPTR(vkImportSemaphoreFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkImportFenceFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkGetMemoryFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkGetImageSubresourceLayout);
+
+#undef LOAD_DEVICE_FUNCPTR
+#undef LOAD_INSTANCE_FUNCPTR
+
+    swapchain->remote_surface_proxy =
+        wayland_remote_surface_proxy_create(hwnd, WAYLAND_REMOTE_SURFACE_TYPE_GLVK);
+    if (!swapchain->remote_surface_proxy)
+    {
+        ERR("Failed to create remote surface proxy for remote swapchain\n");
+        goto err;
+    }
+
+    swapchain->count_images = max(create_info->minImageCount, min_number_images);
+    swapchain->images = calloc(swapchain->count_images, sizeof(*swapchain->images));
+    if (!swapchain->images)
+    {
+        ERR("Failed to allocate memory\n");
+        goto err;
+    }
+
+    for (i = 0; i < swapchain->count_images; i++)
+        res |= wayland_remote_vk_image_init(instance, physical_device, device,
+                                            &swapchain->vk_funcs, create_info,
+                                            &swapchain->images[i]);
+    if (res < 0)
+        goto err;
+
+    swapchain->buffer_commit =
+        (create_info->presentMode == VK_PRESENT_MODE_FIFO_KHR) ?
+            WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED :
+            WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL;
+
+    swapchain->remote_throttle_event = 0;
+
+    return swapchain;
+
+err:
+    ERR("Failed to create remote swapchain\n");
+    if (swapchain)
+        wayland_remote_vk_swapchain_destroy(swapchain, device);
+    return NULL;
+}
+
+VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    unsigned int i;
+    VkResult res = VK_SUCCESS;
+
+    if (!images)
+    {
+        *count = swapchain->count_images;
+        return VK_SUCCESS;
+    }
+
+    if (*count < swapchain->count_images)
+        res = VK_INCOMPLETE;
+
+    /* The client want us to fill images, but for some reason the size of the
+     * array is larger than the number of formats that we support. So we correct
+     * that size. */
+    if (*count > swapchain->count_images)
+        *count = swapchain->count_images;
+
+    for (i = 0; i < (*count); i++)
+        images[i] = swapchain->images[i].native_vk_image;
+
+    return res;
+}
+
+static DWORD wait_remote_release_buffer_events(struct wayland_remote_vk_swapchain *swapchain,
+                                               int timeout_ms)
+{
+    int count = 0;
+    HANDLE *handles;
+    struct wayland_remote_vk_image *image;
+    struct wayland_remote_vk_image **images;
+    unsigned int i;
+    LARGE_INTEGER timeout;
+    UINT ret = WAIT_OBJECT_0;
+
+    handles = calloc(swapchain->count_images, sizeof(*handles));
+    images = calloc(swapchain->count_images, sizeof(*images));
+    if (!handles || !images)
+    {
+        ERR("Failed to allocate memory\n");
+        ret = WAIT_FAILED;
+        goto out;
+    }
+
+    if (!wayland_remote_surface_proxy_dispatch_events(swapchain->remote_surface_proxy))
+    {
+        ret = WAIT_FAILED;
+        goto out;
+    }
+
+    for (i = 0; i < swapchain->count_images; i++)
+    {
+        image = &swapchain->images[i];
+        if (!image->remote_buffer_released_event)
+            continue;
+        images[count] = image;
+        handles[count] = image->remote_buffer_released_event;
+        count++;
+    }
+    TRACE("count handles=%d\n", count);
+    for (i = 0; i < count; i++)
+        TRACE("handle%d=%p\n", i, handles[i]);
+
+    /* Nothing to wait for, so just return */
+    if (count == 0)
+        goto out;
+
+    ret = NtWaitForMultipleObjects(count, handles, TRUE, FALSE,
+                                   get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_FAILED)
+    {
+        ERR("Failed on NtWaitForMultipleObjects() call, ret=%d\n", ret);
+        goto out;
+    }
+    TRACE("count=%d => ret=%d\n", count, ret);
+
+    i = ret - WAIT_OBJECT_0;
+    if (i < count)
+        wayland_remote_vk_image_release(images[i]);
+
+out:
+    if (ret == WAIT_FAILED)
+        ERR("Failed to wait for remote release buffer event\n");
+    free(handles);
+    free(images);
+    return ret;
+}
+
+VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk_swapchain *swapchain,
+                                                        VkDevice device, uint64_t timeout_ns,
+                                                        VkSemaphore semaphore, VkFence fence,
+                                                        uint32_t *image_index)
+{
+    struct vk_funcs *vk_funcs = &swapchain->vk_funcs;
+    unsigned int i;
+    BOOL free_image_found = FALSE;
+    VkImportSemaphoreFdInfoKHR import_semaphore_fd_info = {0};
+    VkImportFenceFdInfoKHR import_fence_fd_info = {0};
+    VkResult res;
+    static const UINT wait_timeout = 100;
+    UINT wait_start = NtGetTickCount();
+
+    /* As we are not the Vulkan driver, we don't have much information about the
+     * semaphore. But the spec of VkImportSemaphoreFdInfoKHR states the
+     * following:
+     *
+     * If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT, the
+     * special value -1 for fd is treated like a valid sync file descriptor
+     * referring to an object that has already signaled. The import operation
+     * will succeed and the VkSemaphore will have a temporarily imported payload
+     * as if a valid file descriptor had been provided.
+     *
+     * This special behavior allows us to signal the semaphore by setting
+     * import_semaphore_fd_info.fd to -1. Same thing applies to VkFence, so we
+     * set import_fence_fd_info.fd to -1 */
+
+    import_semaphore_fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    import_semaphore_fd_info.fd = -1;
+    import_semaphore_fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+    import_semaphore_fd_info.semaphore = semaphore;
+    import_semaphore_fd_info.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
+
+    import_fence_fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
+    import_fence_fd_info.fd = -1;
+    import_fence_fd_info.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
+    import_fence_fd_info.fence = fence;
+    import_fence_fd_info.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
+
+    /* Wait until we have a free image. If we don't get a free buffer within
+     * wait_timeout, drop the first buffer to ensure we can continue and avoid
+     * potential cross-process deadlocks (e.g., the render process waiting for
+     * the window process to dispatch buffer release messages, while the window
+     * process is waiting for the render process to finish rendering). */
+    while (!free_image_found)
+    {
+        for (i = 0; i < swapchain->count_images; i++)
+            if (!swapchain->images[i].busy)
+            {
+                free_image_found = TRUE;
+                break;
+            }
+
+        if (!free_image_found)
+        {
+            /* If timeout is 0, the spec says that we should return VK_NOT_READY
+             * when no images are available. */
+            if (timeout_ns == 0)
+                return VK_NOT_READY;
+
+            if (wait_remote_release_buffer_events(swapchain, 10) == WAIT_FAILED)
+                goto err;
+
+            /* Release image so that we can continue */
+            if (get_tick_count_since(wait_start) > wait_timeout)
+            {
+                i = 0;
+                free_image_found = TRUE;
+                wayland_remote_vk_image_release(&swapchain->images[i]);
+            }
+        }
+
+        /* If applications defined a timeout, we must respect it */
+        if (!free_image_found && timeout_ns > 0 &&
+            get_tick_count_since(wait_start) > (timeout_ns / 1000000))
+            return VK_TIMEOUT;
+    }
+
+    if (semaphore != VK_NULL_HANDLE)
+    {
+        res = vk_funcs->p_vkImportSemaphoreFdKHR(device, &import_semaphore_fd_info);
+        if (res != VK_SUCCESS)
+        {
+            ERR("pfn_vkImportSemaphoreFdKHR failed, res=%d\n", res);
+            goto err;
+        }
+    }
+    if (fence != VK_NULL_HANDLE)
+    {
+        res = vk_funcs->p_vkImportFenceFdKHR(device, &import_fence_fd_info);
+        if (res != VK_SUCCESS)
+        {
+            ERR("pfn_vkImportFenceFdKHR failed, res=%d\n", res);
+            goto err;
+        }
+    }
+
+    *image_index = i;
+    swapchain->images[*image_index].busy = TRUE;
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to acquire image from remote Vulkan swapchain");
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
+
+static DWORD wayland_remote_vk_swapchain_wait_throttle(struct wayland_remote_vk_swapchain *swapchain,
+                                                       int timeout_ms)
+{
+    UINT ret;
+    LARGE_INTEGER timeout;
+
+    TRACE("remote_throttle_event=%p timeout_ms=%d\n",
+          swapchain->remote_throttle_event, timeout_ms);
+
+    if (!wayland_remote_surface_proxy_dispatch_events(swapchain->remote_surface_proxy))
+    {
+        ERR("Failed to dispatch remote events\n");
+        return WAIT_FAILED;
+    }
+
+    ret = NtWaitForSingleObject(swapchain->remote_throttle_event, FALSE,
+                                get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_OBJECT_0)
+    {
+        NtClose(swapchain->remote_throttle_event);
+        swapchain->remote_throttle_event = 0;
+    }
+
+    TRACE("=> ret=%d\n", ret);
+    return ret;
+}
+
+static void wayland_remote_vk_swapchain_throttle(struct wayland_remote_vk_swapchain *swapchain)
+{
+    static const UINT timeout = 100;
+    UINT start, elapsed;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    TRACE("throttle_event=%p\n", swapchain->remote_throttle_event);
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (elapsed < timeout && swapchain->remote_throttle_event &&
+           wayland_remote_vk_swapchain_wait_throttle(swapchain, 10) != WAIT_FAILED)
+    {
+        elapsed = get_tick_count_since(start);
+    }
+
+    TRACE("throttle_event=%p => elapsed=%d\n",
+          swapchain->remote_throttle_event, elapsed);
+
+    if (swapchain->remote_throttle_event)
+    {
+        NtClose(swapchain->remote_throttle_event);
+        swapchain->remote_throttle_event = 0;
+    }
+}
+
+int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
+                                        uint32_t image_index)
+{
+    struct wayland_remote_vk_image *image;
+
+    image = &swapchain->images[image_index];
+    image->busy = TRUE;
+
+    if (swapchain->remote_throttle_event)
+        wayland_remote_vk_swapchain_throttle(swapchain);
+
+    if (!wayland_remote_surface_proxy_commit(swapchain->remote_surface_proxy,
+                                             &image->native_buffer,
+                                             WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+                                             swapchain->buffer_commit,
+                                             &image->remote_buffer_released_event,
+                                             &swapchain->remote_throttle_event))
+    {
+        wayland_remote_vk_image_release(image);
+        goto err;
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to present remote Vulkan swapchain\n");
+    return -1;
+}
+
+VkResult wayland_remote_vk_filter_supported_formats(uint32_t *count_filtered_formats,
+                                                    void *filtered_formats,
+                                                    uint32_t count_formats_to_filter,
+                                                    void *formats_to_filter,
+                                                    size_t format_size,
+                                                    size_t vk_surface_format_offset)
+{
+    VkFormat format;
+    VkResult res = VK_SUCCESS;
+    uint32_t count_intersect;
+    unsigned int i;
+
+    for (count_intersect = 0, i = 0; i < count_formats_to_filter; i++)
+    {
+        format = *(VkFormat *)((char *)formats_to_filter +
+                               (i * format_size) + vk_surface_format_offset);
+        if (vulkan_format_to_drm_format(format, FALSE) != DRM_FORMAT_INVALID)
+        {
+            if (filtered_formats)
+            {
+                if (count_intersect < *count_filtered_formats)
+                {
+                    /* There's room for a format on the array, so add it */
+                    memcpy((char *)filtered_formats + (count_intersect * format_size),
+                           (char *)formats_to_filter + (i * format_size),
+                           format_size);
+                }
+                else
+                {
+                    /* Array size is not enough to accommodate all the formats
+                     * we support, so we must return VK_INCOMPLETE */
+                    res = VK_INCOMPLETE;
+                    break;
+                }
+            }
+            count_intersect++;
+        }
+    }
+
+    /* We just set count_filtered_formats when the client want us to do that
+     * (i.e., filtered_formats == NULL) and when the client want us to fill
+     * filtered_formats but for some reason the size of the array is larger than
+     * the number of formats that we support. */
+    if (!filtered_formats || *count_filtered_formats > count_intersect)
+        *count_filtered_formats = count_intersect;
+
+    return res;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
new file mode 100644
index 00000000000..5be34f4e28a
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -0,0 +1,57 @@
+/* WAYLANDDRV Vulkan remote implementation
+ *
+ * Copyright 2022 Leandro Ribeiro
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_VULKAN_REMOTE_H
+#define __WINE_WAYLANDDRV_VULKAN_REMOTE_H
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+
+struct wayland_remote_vk_swapchain;
+struct vulkan_funcs;
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd, VkInstance instance,
+                                                                       VkPhysicalDevice physical_device,
+                                                                       VkDevice device,
+                                                                       const struct vulkan_funcs *vulkan_funcs,
+                                                                       VkSwapchainCreateInfoKHR *create_info) DECLSPEC_HIDDEN;
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
+                                         VkDevice device) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
+                                                uint32_t *count, VkImage *images) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk_swapchain *swapchain,
+                                                        VkDevice device, uint64_t timeout_ns,
+                                                        VkSemaphore semaphore, VkFence fence,
+                                                        uint32_t *image_index) DECLSPEC_HIDDEN;
+int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
+                                        uint32_t image_index) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_filter_supported_formats(uint32_t *count_filtered_formats,
+                                                    void *filtered_formats,
+                                                    uint32_t count_formats_to_filter,
+                                                    void *formats_to_filter,
+                                                    size_t format_size,
+                                                    size_t vk_surface_format_offset) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
new file mode 100644
index 00000000000..ab5328f8546
--- /dev/null
+++ b/dlls/winewayland.drv/wayland.c
@@ -0,0 +1,998 @@
+/*
+ * Wayland core handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <sys/timerfd.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct wl_display *process_wl_display = NULL;
+static struct wayland *process_wayland = NULL;
+static struct wayland_mutex process_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": process_wayland_mutex"
+};
+static struct wayland_mutex thread_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": thread_wayland_mutex"
+};
+
+static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
+
+struct wayland_callback
+{
+   struct wl_list link;
+   uintptr_t id;
+   wayland_callback_func func;
+   void *data;
+   uint64_t target_time_ms;
+};
+
+struct wayland_wakeup
+{
+    struct wl_list link;
+    uintptr_t id;
+    uint64_t target_time_ms;
+};
+static struct wl_list wayland_wakeup_list = {&wayland_wakeup_list, &wayland_wakeup_list};
+static int wayland_wakeup_timerfd = -1;
+
+/**********************************************************************
+ *          Wakeup handling
+ */
+
+static void wayland_add_wakeup_for_callback(struct wayland_callback *cb)
+{
+    struct wayland_wakeup *wakeup;
+
+    wakeup = calloc(1, sizeof(*wakeup));
+    wakeup->target_time_ms = cb->target_time_ms;
+    wakeup->id = cb->id;
+
+    wayland_mutex_lock(&process_wayland_mutex);
+    wl_list_insert(&wayland_wakeup_list, &wakeup->link);
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_remove_wakeup(uintptr_t id)
+{
+    struct wayland_wakeup *wakeup;
+
+    wayland_mutex_lock(&process_wayland_mutex);
+
+    wl_list_for_each(wakeup, &wayland_wakeup_list, link)
+    {
+        if (wakeup->id == id)
+        {
+            wl_list_remove(&wakeup->link);
+            free(wakeup);
+            break;
+        }
+    }
+
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_remove_past_wakeups(void)
+{
+    struct wayland_wakeup *wakeup, *tmp;
+    uint64_t time_now_ms;
+    struct timespec ts;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    time_now_ms = ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
+
+    wayland_mutex_lock(&process_wayland_mutex);
+
+    wl_list_for_each_safe(wakeup, tmp, &wayland_wakeup_list, link)
+    {
+        if (wakeup->target_time_ms <= time_now_ms)
+        {
+            wl_list_remove(&wakeup->link);
+            free(wakeup);
+        }
+    }
+
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_reschedule_wakeup_timerfd(void)
+{
+    uint64_t min = 0;
+    struct itimerspec its = {0};
+    struct wayland_wakeup *wakeup;
+
+    wayland_mutex_lock(&process_wayland_mutex);
+
+    wl_list_for_each(wakeup, &wayland_wakeup_list, link)
+    {
+        uint64_t wakeup_time = wakeup->target_time_ms;
+        if (min == 0 || wakeup_time < min)
+            min = wakeup_time;
+    }
+
+    TRACE("time=%llu\n", (long long unsigned)min);
+
+    its.it_value.tv_sec = min / 1000;
+    its.it_value.tv_nsec = (min % 1000) * 1000000;
+
+    timerfd_settime(wayland_wakeup_timerfd, TFD_TIMER_ABSTIME, &its, NULL);
+
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+/**********************************************************************
+ *          xdg_wm_base handling
+ */
+
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *shell, uint32_t serial)
+{
+    xdg_wm_base_pong(shell, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
+};
+
+/**********************************************************************
+ *          Seat handling
+ */
+
+static void seat_handle_capabilities(void *data, struct wl_seat *seat,
+                                     enum wl_seat_capability caps)
+{
+    struct wayland *wayland = data;
+
+    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_init(&wayland->pointer, wayland, wl_seat_get_pointer(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_deinit(&wayland->pointer);
+    }
+
+    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_init(&wayland->keyboard, wayland, wl_seat_get_keyboard(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_deinit(&wayland->keyboard);
+    }
+}
+
+static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
+{
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+    seat_handle_name,
+};
+
+/**********************************************************************
+ *          Registry handling
+ */
+
+static void registry_handle_global(void *data, struct wl_registry *registry,
+                                   uint32_t id, const char *interface,
+                                   uint32_t version)
+{
+    struct wayland *wayland = data;
+
+    TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
+
+    if (strcmp(interface, "wl_output") == 0)
+    {
+        if (!wayland_output_create(wayland, id, version))
+            ERR("Failed to create wayland_output for global id=%u\n", id);
+    }
+    else if (strcmp(interface, "zxdg_output_manager_v1") == 0)
+    {
+        struct wayland_output *output;
+
+        wayland->zxdg_output_manager_v1 =
+            wl_registry_bind(registry, id, &zxdg_output_manager_v1_interface,
+                             version < 3 ? version : 3);
+
+        /* Add zxdg_output_v1 to existing outputs. */
+        wl_list_for_each(output, &wayland->output_list, link)
+            wayland_output_use_xdg_extension(output);
+    }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
+    else if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0)
+    {
+        struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1 =
+            wl_registry_bind(registry, id, &zwp_linux_dmabuf_v1_interface,
+                             version < 4 ? version : 4);
+        wayland_dmabuf_init(&wayland->dmabuf, zwp_linux_dmabuf_v1);
+    }
+    else if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
+
+    /* The per-process wayland instance should not handle every global, as there
+     * is no point. Many globals are only needed by the per-thread instances. */
+    if (wayland_is_process(wayland)) return;
+
+    if (strcmp(interface, "wl_subcompositor") == 0)
+    {
+        wayland->wl_subcompositor =
+            wl_registry_bind(registry, id, &wl_subcompositor_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_wm_base") == 0)
+    {
+        /* Bind version 2 so that compositors (e.g., sway) can properly send tiled
+         * states, instead of falling back to (ab)using the maximized state. */
+        wayland->xdg_wm_base =
+            wl_registry_bind(registry, id, &xdg_wm_base_interface,
+                             version < 2 ? version : 2);
+        xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
+    }
+    else if (strcmp(interface, "wl_seat") == 0)
+    {
+        wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
+                                            version < 5 ? version : 5);
+        wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
+    }
+    else if (strcmp(interface, "wp_viewporter") == 0)
+    {
+        wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
+    }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        wayland->wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface,
+                             version < 3 ? version : 3);
+    }
+    else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
+    {
+        wayland->zwp_pointer_constraints_v1 =
+            wl_registry_bind(registry, id, &zwp_pointer_constraints_v1_interface, 1);
+    }
+    else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
+    {
+        wayland->zwp_relative_pointer_manager_v1 =
+            wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
+    }
+}
+
+static void registry_handle_global_remove(void *data, struct wl_registry *registry,
+                                          uint32_t id)
+{
+    struct wayland *wayland = data;
+    struct wayland_output *output, *tmp;
+
+    TRACE("id=%d\n", id);
+
+    wl_list_for_each_safe(output, tmp, &wayland->output_list, link)
+    {
+        if (output->global_id == id)
+        {
+            struct wayland_surface *surface;
+
+            TRACE("removing output->name=%s\n", output->name);
+
+            /* Remove the output from surfaces, as some compositors don't send
+             * a leave event if the output is disconnected. */
+            wl_list_for_each(surface, &wayland->surface_list, link)
+                wayland_surface_leave_output(surface, output);
+
+            wayland_output_destroy(output);
+            if (wayland_is_process(wayland))
+            {
+                /* Temporarily release the per-process instance lock, so that
+                 * wayland_init_display_devices can perform more fine grained
+                 * locking to avoid deadlocks. */
+                wayland_process_release();
+                wayland_init_display_devices();
+                wayland_process_acquire();
+            }
+            return;
+        }
+    }
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+
+/**********************************************************************
+ *          wayland_init
+ *
+ *  Initialise a wayland instance.
+ */
+BOOL wayland_init(struct wayland *wayland)
+{
+    struct wl_display *wl_display_wrapper;
+    int flags;
+
+    TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
+
+    wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
+
+    wayland->process_id = GetCurrentProcessId();
+    wayland->thread_id = GetCurrentThreadId();
+    wayland->wl_display = process_wl_display;
+
+    if (!wayland->wl_display)
+    {
+        ERR("Failed to connect to wayland compositor\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create event queue\n");
+        return FALSE;
+    }
+
+    if (!(wl_display_wrapper = wl_proxy_create_wrapper(wayland->wl_display)))
+    {
+        ERR("Failed to create proxy wrapper for wl_display\n");
+        return FALSE;
+    }
+    wl_proxy_set_queue((struct wl_proxy *) wl_display_wrapper, wayland->wl_event_queue);
+
+    wayland->wl_registry = wl_display_get_registry(wl_display_wrapper);
+    wl_proxy_wrapper_destroy(wl_display_wrapper);
+    if (!wayland->wl_registry)
+    {
+        ERR("Failed to get to wayland registry\n");
+        return FALSE;
+    }
+
+    wl_list_init(&wayland->output_list);
+    wl_list_init(&wayland->detached_shm_buffer_list);
+    wl_list_init(&wayland->callback_list);
+    wl_list_init(&wayland->surface_list);
+
+    SetRect(&wayland->cursor_clip, INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+
+    /* Populate registry */
+    wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
+
+    /* We need three roundtrips. One to get and bind globals, one to handle all
+     * initial events produced from registering the globals and one more to
+     * handle potential third-order registrations. */
+    if (wayland_is_process(wayland)) wayland_process_acquire();
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    if (wayland_is_process(wayland)) wayland_process_release();
+
+    if (wayland_is_process(wayland))
+    {
+        if (option_use_system_cursors)
+            wayland_cursor_theme_init(wayland);
+    }
+    else
+    {
+        if (wayland->wl_data_device_manager && wayland->wl_seat)
+            wayland_data_device_init(&wayland->data_device, wayland);
+
+        /* Thread wayland instances have notification pipes to inform them when
+         * there might be new events in their queues. The read part of the pipe
+         * is also used as the wine server queue fd. */
+        if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+            return FALSE;
+        /* Make just the read end non-blocking */
+        if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+            return FALSE;
+        if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+            return FALSE;
+        /* Keep a list of all thread wayland instances. */
+        wayland_mutex_lock(&thread_wayland_mutex);
+        wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+        wayland_mutex_unlock(&thread_wayland_mutex);
+    }
+
+    wayland->initialized = TRUE;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_deinit
+ *
+ *  Deinitialise a wayland instance, releasing all associated resources.
+ */
+void wayland_deinit(struct wayland *wayland)
+{
+    struct wayland_output *output, *output_tmp;
+    struct wayland_shm_buffer *shm_buffer, *shm_buffer_tmp;
+    struct wayland_callback *callback, *callback_tmp;
+
+    TRACE("%p\n", wayland);
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+    wl_list_remove(&wayland->thread_link);
+    wayland_mutex_unlock(&thread_wayland_mutex);
+
+    wl_list_for_each_safe(callback, callback_tmp, &wayland->callback_list, link)
+    {
+        wayland_remove_wakeup(callback->id);
+        wl_list_remove(&callback->link);
+        free(callback);
+    }
+    wayland_reschedule_wakeup_timerfd();
+
+    /* Keep getting the first surface in the list and destroy it, which also
+     * removes it from the list. We use this somewhat unusual iteration method
+     * because even wl_list_for_each_safe() is not safe against removals of
+     * arbitrary elements from the list during iteration. */
+    while (wayland->surface_list.next != &wayland->surface_list)
+    {
+        struct wayland_surface *surface =
+            wl_container_of(wayland->surface_list.next, surface, link);
+        wayland_surface_destroy(surface);
+    }
+
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
+    wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
+        wayland_output_destroy(output);
+
+    wl_list_for_each_safe(shm_buffer, shm_buffer_tmp,
+                          &wayland->detached_shm_buffer_list, link)
+        wayland_shm_buffer_destroy(shm_buffer);
+
+    if (wayland->pointer.wl_pointer)
+        wayland_pointer_deinit(&wayland->pointer);
+
+    if (wayland->keyboard.wl_keyboard)
+        wayland_keyboard_deinit(&wayland->keyboard);
+
+    if (wayland->data_device.wl_data_device)
+        wayland_data_device_deinit(&wayland->data_device);
+
+    if (wayland->wl_data_device_manager)
+        wl_data_device_manager_destroy(wayland->wl_data_device_manager);
+
+    if (wayland->wl_seat)
+        wl_seat_destroy(wayland->wl_seat);
+
+    if (wayland->dmabuf.zwp_linux_dmabuf_v1)
+        wayland_dmabuf_deinit(&wayland->dmabuf);
+
+    if (wayland->zwp_pointer_constraints_v1)
+        zwp_pointer_constraints_v1_destroy(wayland->zwp_pointer_constraints_v1);
+
+    if (wayland->zwp_relative_pointer_manager_v1)
+        zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
+
+    if (wayland->wp_viewporter)
+        wp_viewporter_destroy(wayland->wp_viewporter);
+
+    if (wayland->wl_shm)
+        wl_shm_destroy(wayland->wl_shm);
+
+    if (wayland->zxdg_output_manager_v1)
+        zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
+
+    if (wayland->xdg_wm_base)
+        xdg_wm_base_destroy(wayland->xdg_wm_base);
+
+    if (wayland->wl_subcompositor)
+        wl_subcompositor_destroy(wayland->wl_subcompositor);
+
+    if (wayland->wl_compositor)
+        wl_compositor_destroy(wayland->wl_compositor);
+
+    if (wayland->wl_registry)
+        wl_registry_destroy(wayland->wl_registry);
+
+    if (wayland->wl_event_queue)
+        wl_event_queue_destroy(wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    memset(wayland, 0, sizeof(*wayland));
+}
+
+/**********************************************************************
+ *          wayland_process_init
+ *
+ *  Initialise the per process wayland objects.
+ *
+ */
+BOOL wayland_process_init(void)
+{
+    process_wl_display = wl_display_connect(NULL);
+    if (!process_wl_display)
+        return FALSE;
+
+    process_wayland = calloc(1, sizeof(*process_wayland));
+    if (!process_wayland)
+        return FALSE;
+
+    wayland_wakeup_timerfd = timerfd_create(CLOCK_MONOTONIC, 0);
+    if (!wayland_wakeup_timerfd)
+        return FALSE;
+
+    return wayland_init(process_wayland);
+}
+
+/**********************************************************************
+ *          wayland_is_process
+ *
+ *  Checks whether a wayland instance is the per-process one.
+ */
+BOOL wayland_is_process(struct wayland *wayland)
+{
+    return wayland == process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_acquire
+ *
+ *  Acquires the per-process wayland instance.
+ */
+struct wayland *wayland_process_acquire(void)
+{
+    wayland_mutex_lock(&process_wayland_mutex);
+    return process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_release
+ *
+ *  Releases the per-process wayland instance.
+ */
+void wayland_process_release(void)
+{
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
+
+/**********************************************************************
+ *          wayland_notify_wine_monitor_change
+ *
+ * Notify all wayland instances about a change in the state of wine monitors.
+ * The notification is synchronous, this function returns after all wayland
+ * instances have handled the event, except if it a thread is slow to process
+ * the message, and thus likely to be blocked by this synchronous operation.
+ */
+void wayland_notify_wine_monitor_change(void)
+{
+    struct wayland *w;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    /* Each thread maintains its own output information, so we need to notify
+     * all threads about the change. We can't guarantee that all threads will
+     * have windows to which we could potentially send the notification message
+     * to, so we use the internal send function to target the threads directly.
+     * We can't use PostThreadMessage since we require synchronous message
+     * handling. */
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        LRESULT res;
+        TRACE("notifying thread %04x\n", (UINT)w->thread_id);
+        /* Use a timeout of 50ms to avoid blocking indefinitely if the
+         * target thread is not processing (and to avoid deadlocks). */
+        res = __wine_send_internal_message_timeout(w->process_id, w->thread_id,
+                                                   WM_WAYLAND_MONITOR_CHANGE,
+                                                   0, 0, 0, 50, NULL);
+        /* If we weren't able to synchronously send the message, post it. */
+        if (!res)
+            NtUserPostThreadMessage(w->thread_id, WM_WAYLAND_MONITOR_CHANGE, 0, 0);
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
+
+/**********************************************************************
+ *          wayland_dispatch_queue
+ *
+ * Dispatch events from the specified queue. If the queue is empty,
+ * wait for timeout_ms for events to arrive and then dispatch any events in
+ * the queue.
+ *
+ * Returns the number of events dispatched, -1 on error
+ */
+int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
+{
+    /* We need to poll up to two fds and notify threads of potential events:
+     * 1. wl_display fd: events from the compositor
+     * 2. wayland_wakeup_timerfd (per-process instance only): internally
+     *    scheduled callbacks */
+    struct pollfd pfd[2] = {0};
+    BOOL is_process_queue = queue == process_wayland->wl_event_queue;
+    int ret;
+
+    TRACE("waiting for events with timeout=%d ...\n", timeout_ms);
+
+    pfd[0].fd = wl_display_get_fd(process_wl_display);
+
+    if (wl_display_prepare_read_queue(process_wl_display, queue) == -1)
+    {
+        if (is_process_queue) wayland_process_acquire();
+        if ((ret = wl_display_dispatch_queue_pending(process_wl_display, queue)) == -1)
+            TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+        if (is_process_queue) wayland_process_release();
+        TRACE("... done early\n");
+        return ret;
+    }
+
+    while (TRUE)
+    {
+        ret = wl_display_flush(process_wl_display);
+
+        if (ret != -1 || errno != EAGAIN)
+            break;
+
+        pfd[0].events = POLLOUT;
+        while ((ret = poll(pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+
+        if (ret == -1)
+        {
+            TRACE("... failed poll out errno=%d\n", errno);
+            wl_display_cancel_read(process_wl_display);
+            return -1;
+        }
+    }
+
+    if (ret < 0 && errno != EPIPE)
+    {
+        wl_display_cancel_read(process_wl_display);
+        return -1;
+    }
+
+    if (is_process_queue)
+    {
+        pfd[1].events = POLLIN;
+        pfd[1].fd = wayland_wakeup_timerfd;
+    }
+
+    pfd[0].events = POLLIN;
+    pfd[0].revents = 0;
+    while ((ret = poll(pfd, pfd[1].events ? 2 : 1, timeout_ms)) == -1 && errno == EINTR)
+        continue;
+
+    if (!(pfd[0].revents & POLLIN))
+        wl_display_cancel_read(process_wl_display);
+
+    if (ret == 0)
+    {
+        TRACE("... done => 0 events (timeout)\n");
+        return 0;
+    }
+
+    if (ret == -1)
+    {
+        TRACE("... failed poll errno=%d\n", errno);
+        return -1;
+    }
+
+    /* Handle wl_display fd input. */
+    if (pfd[0].revents & POLLIN)
+    {
+        if (wl_display_read_events(process_wl_display) == -1)
+        {
+            TRACE("... failed wl_display_read_events errno=%d\n", errno);
+            return -1;
+        }
+        if (is_process_queue) wayland_process_acquire();
+        ret = wl_display_dispatch_queue_pending(process_wl_display, queue);
+        if (is_process_queue) wayland_process_release();
+        if (ret == -1)
+        {
+            TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+            return -1;
+        }
+    }
+
+    /* Handle timerfd input. */
+    if (pfd[1].revents & POLLIN)
+    {
+        uint64_t num_expirations;
+        int nread;
+        while ((nread = read(pfd[1].fd, &num_expirations, sizeof(uint64_t))) == -1 &&
+                errno == EINTR)
+        {
+            continue;
+        }
+        if (nread < sizeof(uint64_t))
+        {
+            TRACE("... failed reading timerfd errno=%d\n", errno);
+            return -1;
+        }
+        wayland_remove_past_wakeups();
+        wayland_reschedule_wakeup_timerfd();
+    }
+
+    /* We may have read and queued events in queues other than the specified
+     * one, so we need to notify threads (see wayland_read_events). */
+    wayland_notify_threads();
+
+    TRACE("... done => %d events\n", ret);
+
+    return ret;
+}
+
+/**********************************************************************
+ *          wayland_read_events_and_dispatch_process
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues, dispatch any events for the per-process wayland instance,
+ * and notify threads about the possibility of new per-thread wayland instance
+ * events (without dispatching them).
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events_and_dispatch_process(void)
+{
+    return (wayland_dispatch_queue(process_wayland->wl_event_queue, -1) != -1);
+}
+
+static void wayland_add_callback(struct wayland *wayland, struct wayland_callback *cb)
+{
+    struct wayland_callback *cb_iter;
+
+    /* Keep callbacks ordered by target time and previous scheduling order */
+    wl_list_for_each(cb_iter, &wayland->callback_list, link)
+    {
+        if (cb_iter->target_time_ms > cb->target_time_ms)
+        {
+            wl_list_insert(cb_iter->link.prev, &cb->link);
+            break;
+        }
+    }
+
+    if (wl_list_empty(&cb->link))
+        wl_list_insert(wayland->callback_list.prev, &cb->link);
+}
+
+/**********************************************************************
+ *          wayland_schedule_thread_callback
+ *
+ * Schedule a callback to be run in the context of the current thread after
+ * the specified delay. If there is an existing callback with the specified
+ * id, it is replaced with the new one.
+ */
+void wayland_schedule_thread_callback(uintptr_t id, int delay_ms,
+                                      void (*callback)(void *), void *data)
+{
+    struct wayland *wayland = thread_wayland();
+    struct timespec ts;
+    struct wayland_callback *cb_iter, *cb = NULL;
+    uint64_t target_ms;
+
+    if (!wayland) return;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    target_ms = ts.tv_sec * 1000 + (ts.tv_nsec / 1000000) + delay_ms;
+
+    TRACE("id=%p delay_ms=%d target_ms=%llu callback=%p data=%p\n",
+          (void*)id, delay_ms, (long long unsigned)target_ms, callback, data);
+
+    /* If we have a callback with the same id, we remove it from the list so
+     * that it can be re-added at the appropriate position later in this
+     * function. */
+    wl_list_for_each(cb_iter, &wayland->callback_list, link)
+    {
+        if (cb_iter->id == id)
+        {
+            wl_list_remove(&cb_iter->link);
+            cb = cb_iter;
+            break;
+        }
+    }
+
+    if (!cb) cb = calloc(1, sizeof(*cb));
+    cb->id = id;
+    cb->func = callback;
+    cb->data = data;
+    cb->target_time_ms = target_ms;
+    wl_list_init(&cb->link);
+
+    wayland_add_callback(wayland, cb);
+    wayland_add_wakeup_for_callback(cb);
+    wayland_reschedule_wakeup_timerfd();
+}
+
+/**********************************************************************
+ *          wayland_cancel_thread_callback
+ *
+ * Cancel a callback previously scheduled in this the current thread.
+ */
+void wayland_cancel_thread_callback(uintptr_t id)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_callback *cb;
+
+    if (!wayland) return;
+
+    TRACE("id=%p\n", (void*)id);
+
+    wl_list_for_each(cb, &wayland->callback_list, link)
+    {
+        if (cb->id == id)
+        {
+            wl_list_remove(&cb->link);
+            free(cb);
+            break;
+        }
+    }
+}
+
+static void wayland_dispatch_thread_callbacks(struct wayland *wayland)
+{
+    struct wayland_callback *cb, *tmp;
+    struct wl_list tmp_list;
+    uint64_t time_now_ms;
+    struct timespec ts;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    time_now_ms = ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
+
+    /* Invoking a callback may result in scheduling additional callbacks.
+     * This can corrupt our callback list iteration, so we first move
+     * the current callbacks to a separate list and iterate over that. */
+    wl_list_init(&tmp_list);
+    wl_list_insert_list(&tmp_list, &wayland->callback_list);
+    wl_list_init(&wayland->callback_list);
+
+    /* Call all triggered callbacks and free them. */
+    wl_list_for_each_safe(cb, tmp, &tmp_list, link)
+    {
+        if (time_now_ms < cb->target_time_ms) break;
+        TRACE("invoking callback id=%p func=%p target_time_ms=%llu\n",
+              (void*)cb->id, cb->func, (long long unsigned)cb->target_time_ms);
+        cb->func(cb->data);
+        wl_list_remove(&cb->link);
+        free(cb);
+    }
+
+    /* Add untriggered callbacks back to the main list (which may now
+     * have new callbacks added from a callback invocation above). */
+    wl_list_for_each_safe(cb, tmp, &tmp_list, link)
+    {
+        wl_list_remove(&cb->link);
+        wl_list_init(&cb->link);
+        wayland_add_callback(wayland, cb);
+    }
+}
+
+static int wayland_dispatch_thread_pending(struct wayland *wayland)
+{
+    char buf[64];
+
+    TRACE("wayland=%p queue=%p\n", wayland, wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    /* Consume notifications */
+    while (TRUE)
+    {
+        int ret = read(wayland->event_notification_pipe[0], buf, sizeof(buf));
+        if (ret > 0) continue;
+        if (ret == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EAGAIN) break; /* no data to read */
+            ERR("failed to read from notification pipe: %s\n", strerror(errno));
+            break;
+        }
+        if (ret == 0)
+        {
+            ERR("failed to read from notification pipe: pipe is closed\n");
+            break;
+        }
+    }
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->wl_event_queue);
+}
+
+static BOOL wayland_process_thread_events(struct wayland *wayland, DWORD mask)
+{
+    int dispatched;
+
+    wayland->last_dispatch_mask = 0;
+    wayland->processing_events = TRUE;
+
+    wayland_dispatch_thread_callbacks(wayland);
+
+    dispatched = wayland_dispatch_thread_pending(wayland);
+
+    wayland->processing_events = FALSE;
+
+    TRACE("dispatched=%d mask=%s%s%s%s%s%s%s\n",
+          dispatched,
+          (wayland->last_dispatch_mask & QS_KEY) ? "QS_KEY|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEMOVE) ? "QS_MOUSEMOVE|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEBUTTON) ? "QS_MOUSEBUTTON|" : "",
+          (wayland->last_dispatch_mask & QS_INPUT) ? "QS_INPUT|" : "",
+          (wayland->last_dispatch_mask & QS_PAINT) ? "QS_PAINT|" : "",
+          (wayland->last_dispatch_mask & QS_POSTMESSAGE) ? "QS_POSTMESSAGE|" : "",
+          (wayland->last_dispatch_mask & QS_SENDMESSAGE) ? "QS_SENDMESSAGE|" : "");
+
+    return wayland->last_dispatch_mask & mask;
+}
+
+/***********************************************************************
+ *           WAYLAND_ProcessEvents
+ */
+BOOL WAYLAND_ProcessEvents(DWORD mask)
+{
+    struct wayland *wayland = thread_wayland();
+
+    if (!wayland) return FALSE;
+
+    if (wayland->processing_events)
+    {
+        wl_display_flush(wayland->wl_display);
+        return FALSE;
+    }
+
+    return wayland_process_thread_events(wayland, mask);
+}
diff --git a/dlls/winewayland.drv/wayland_buffer_queue.c b/dlls/winewayland.drv/wayland_buffer_queue.c
new file mode 100644
index 00000000000..84a98f5c1dc
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_buffer_queue.c
@@ -0,0 +1,224 @@
+/*
+ * Wayland buffer queue
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "winuser.h"
+#include "ntgdi.h"
+
+#include <errno.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p destroy_on_release=%d\n",
+          shm_buffer, shm_buffer->destroy_on_release);
+
+    if (shm_buffer->destroy_on_release)
+        wayland_shm_buffer_destroy(shm_buffer);
+    else
+        shm_buffer->busy = FALSE;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+    buffer_release
+};
+
+/**********************************************************************
+ *          wayland_buffer_queue_create
+ *
+ * Creates a buffer queue containing buffers with the specified width, height
+ * and format.
+ */
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int height,
+                                                         enum wl_shm_format format)
+{
+    struct wayland_buffer_queue *queue;
+
+    queue = calloc(1, sizeof(*queue));
+    if (!queue) goto err;
+
+    queue->wayland = wayland;
+    queue->wl_event_queue = wl_display_create_queue(wayland->wl_display);
+    if (!queue->wl_event_queue) goto err;
+    queue->width = width;
+    queue->height = height;
+    queue->format = format;
+
+    wl_list_init(&queue->buffer_list);
+
+    return queue;
+
+err:
+    if (queue) wayland_buffer_queue_destroy(queue);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_destroy
+ *
+ * Destroys a buffer queue and any contained buffers.
+ */
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer, *next;
+
+    wl_list_for_each_safe(shm_buffer, next, &queue->buffer_list, link)
+    {
+        /* If the buffer is busy (committed but not yet released by the
+         * compositor), destroying it now may cause surface contents to become
+         * undefined and lead to visual artifacts. In such a case, we hand off
+         * handling of this buffer to the thread event queue and track it in
+         * the detatched_shm_buffer_list while we wait for the release event in
+         * order to destroy it (see buffer_release handler). */
+        if (shm_buffer->busy)
+            wayland_buffer_queue_detach_buffer(queue, shm_buffer, TRUE);
+        else
+            wayland_shm_buffer_destroy(shm_buffer);
+    }
+
+    if (queue->wl_event_queue)
+    {
+        wl_display_dispatch_queue_pending(queue->wayland->wl_display,
+                                          queue->wl_event_queue);
+        wl_event_queue_destroy(queue->wl_event_queue);
+    }
+
+    free(queue);
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_acquire_buffer
+ *
+ * Acquires a free buffer from the buffer queue. If no free buffers
+ * are available this function blocks until it can provide one.
+ *
+ * The returned buffer is marked as unavailable until committed to
+ * a surface and subsequently released by the compositor.
+ */
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    TRACE("queue=%p\n", queue);
+
+    while (TRUE)
+    {
+        int nbuffers = 0;
+
+        /* Search through our buffers to find an available one. */
+        wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        {
+            if (!shm_buffer->busy)
+            {
+                shm_buffer->busy = TRUE;
+                goto out;
+            }
+            nbuffers++;
+        }
+
+        /* Dynamically create up to 3 buffers. */
+        if (nbuffers < 3)
+        {
+            HRGN full_dmg = NtGdiCreateRectRgn(0, 0, queue->width, queue->height);
+            shm_buffer = wayland_shm_buffer_create(queue->wayland, queue->width,
+                                                   queue->height, queue->format);
+            if (shm_buffer)
+            {
+                /* Buffer events go to their own queue so that we can dispatch
+                 * them independently. */
+                wl_proxy_set_queue((struct wl_proxy *) shm_buffer->wl_buffer,
+                                   queue->wl_event_queue);
+                wl_buffer_add_listener(shm_buffer->wl_buffer, &buffer_listener,
+                                       shm_buffer);
+                wl_list_insert(&queue->buffer_list, &shm_buffer->link);
+                wayland_shm_buffer_add_damage(shm_buffer, full_dmg);
+                shm_buffer->busy = TRUE;
+            }
+            NtGdiDeleteObjectApp(full_dmg);
+            /* If we failed to allocate a new buffer, but we have at least two
+             * buffers busy, there is a good chance the compositor will
+             * eventually release one of them, so dispatch events and wait
+             * below. Otherwise, give up and return a NULL buffer. */
+            if (shm_buffer)
+            {
+                goto out;
+            }
+            else if (nbuffers < 2)
+            {
+                ERR(" => failed to acquire buffer\n");
+                return NULL;
+            }
+        }
+
+        if (wayland_dispatch_queue(queue->wl_event_queue, -1) == -1)
+            return NULL;
+    }
+
+out:
+    TRACE(" => %p %dx%d stride=%d map=[%p, %p)\n",
+          shm_buffer, shm_buffer->width, shm_buffer->height,
+          shm_buffer->stride, shm_buffer->map_data,
+          (unsigned char*)shm_buffer->map_data + shm_buffer->map_size);
+
+    return shm_buffer;
+}
+/**********************************************************************
+ *          wayland_buffer_queue_detach_buffer
+ *
+ * Detaches a buffer from the queue.
+ */
+void wayland_buffer_queue_detach_buffer(struct wayland_buffer_queue *queue,
+                                        struct wayland_shm_buffer *shm_buffer,
+                                        BOOL destroy_on_release)
+{
+    wl_list_remove(&shm_buffer->link);
+    wl_list_insert(&queue->wayland->detached_shm_buffer_list,
+                   &shm_buffer->link);
+    shm_buffer->destroy_on_release = destroy_on_release;
+    wl_proxy_set_queue((struct wl_proxy *)shm_buffer->wl_buffer,
+                        queue->wayland->wl_event_queue);
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_add_damage
+ *
+ * Adds damage to all buffers in this queue.
+ */
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        wayland_shm_buffer_add_damage(shm_buffer, damage);
+}
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
new file mode 100644
index 00000000000..11333132fff
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -0,0 +1,764 @@
+/*
+ * Wayland cursor handling
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "waylanddrv.h"
+
+#include "ntgdi.h"
+#include "ntuser.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <math.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static struct wl_cursor_theme *cursor_theme = NULL;
+
+static HCURSOR last_cursor;
+static HCURSOR invalid_cursor;
+
+/* Mapping between Windows cursors and native Wayland cursors
+ *
+ * Note that we have multiple possible names for each Wayland cursor. This
+ * happens because the names for each cursor may vary across different themes.
+ *
+ * This table was created based on the docs below.
+ *
+ * https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursora
+ * https://bugs.kde.org/attachment.cgi?id=67313
+ */
+static const char *idc_appstarting[] = {"half-busy", "progress", "left_ptr_watch",
+                                        "00000000000000020006000e7e9ffc3f",
+                                        "08e8e1c95fe2fc01f976f1e063a24ccd",
+                                        "3ecb610c1bf2410f44200f48c40d3599",
+                                        "9116a3ea924ed2162ecab71ba103b17f"};
+static const char *idc_arrow[] = {"default", "left_ptr",
+                                  "top_left_arrow", "left-arrow"};
+static const char *idc_cross[] = {"crosshair"};
+static const char *idc_hand[] = {"pointing_hand", "pointer", "hand", "hand2"};
+static const char *idc_help[] = {"help", "question_arrow", "whats_this",
+                                 "5c6cd98b3f3ebcb1f9c7f1c204630408",
+                                 "d9ce0ab605698f320427677b458ad60b"};
+static const char *idc_ibeam[] = {"text", "ibeam", "xterm"};
+static const char *idc_icon[] = {"icon"};
+static const char *idc_no[] = {"forbidden", "not-allowed"};
+static const char *idc_pen[] = {"pencil"};
+static const char *idc_sizeall[] = {"size_all"};
+static const char *idc_sizenesw[] = {"nesw-resize", "size_bdiag",
+                                     "50585d75b494802d0151028115016902",
+                                     "fcf1c3c7cd4491d801f1e1c78f100000"};
+static const char *idc_sizens[] = {"ns-resize", "size_ver", "v_double_arrow",
+                                   "00008160000006810000408080010102"};
+static const char *idc_sizenwse[] = {"nwse-resize", "size_fdiag",
+                                     "38c5dff7c7b8962045400281044508d2",
+                                     "c7088f0f3e6c8088236ef8e1e3e70000"};
+static const char *idc_sizewe[] = {"ew-resize", "size_hor", "h_double_arrow",
+                                   "028006030e0e7ebffc7f7070c0600140"};
+static const char *idc_uparrow[] = {"up_arrow"};
+static const char *idc_wait[] = {"wait", "watch",
+                                 "0426c94ea35c87780ff01dc239897213"};
+
+static struct wl_cursor *_wl_cursor_from_wine_cursor(struct wl_cursor_theme *wl_cursor_theme,
+                                                     unsigned long int wine_cursor_enum)
+{
+    unsigned int i, count;
+    static const char **cursors;
+    struct wl_cursor *cursor;
+
+    switch(wine_cursor_enum)
+    {
+        case IDC_APPSTARTING:
+            cursors = idc_appstarting;
+            count = ARRAY_SIZE(idc_appstarting);
+            break;
+        case IDC_ARROW:
+            cursors = idc_arrow;
+            count = ARRAY_SIZE(idc_arrow);
+            break;
+        case IDC_CROSS:
+            cursors = idc_cross;
+            count = ARRAY_SIZE(idc_cross);
+            break;
+        case IDC_HAND:
+            cursors = idc_hand;
+            count = ARRAY_SIZE(idc_hand);
+            break;
+        case IDC_HELP:
+            cursors = idc_help;
+            count = ARRAY_SIZE(idc_help);
+            break;
+        case IDC_IBEAM:
+            cursors = idc_ibeam;
+            count = ARRAY_SIZE(idc_ibeam);
+            break;
+        case IDC_ICON:
+            cursors = idc_icon;
+            count = ARRAY_SIZE(idc_icon);
+            break;
+        case IDC_NO:
+            cursors = idc_no;
+            count = ARRAY_SIZE(idc_no);
+            break;
+        case IDC_PEN:
+            cursors = idc_pen;
+            count = ARRAY_SIZE(idc_pen);
+            break;
+        case IDC_SIZE:
+        case IDC_SIZEALL:
+            cursors = idc_sizeall;
+            count = ARRAY_SIZE(idc_sizeall);
+            break;
+        case IDC_SIZENESW:
+            cursors = idc_sizenesw;
+            count = ARRAY_SIZE(idc_sizenesw);
+            break;
+        case IDC_SIZENS:
+            cursors = idc_sizens;
+            count = ARRAY_SIZE(idc_sizens);
+            break;
+        case IDC_SIZENWSE:
+            cursors = idc_sizenwse;
+            count = ARRAY_SIZE(idc_sizenwse);
+            break;
+        case IDC_SIZEWE:
+            cursors = idc_sizewe;
+            count = ARRAY_SIZE(idc_sizewe);
+            break;
+        case IDC_UPARROW:
+            cursors = idc_uparrow;
+            count = ARRAY_SIZE(idc_uparrow);
+            break;
+        case IDC_WAIT:
+            cursors = idc_wait;
+            count = ARRAY_SIZE(idc_wait);
+            break;
+        default:
+            return NULL;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        cursor = wl_cursor_theme_get_cursor(wl_cursor_theme, cursors[i]);
+        if (cursor)
+            return cursor;
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           get_icon_info
+ *
+ * Local GetIconInfoExW helper implementation.
+ */
+static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
+{
+    UNICODE_STRING module, res_name;
+    ICONINFO info;
+
+    module.Buffer = ret->szModName;
+    module.MaximumLength = sizeof(ret->szModName) - sizeof(WCHAR);
+    res_name.Buffer = ret->szResName;
+    res_name.MaximumLength = sizeof(ret->szResName) - sizeof(WCHAR);
+    if (!NtUserGetIconInfo(handle, &info, &module, &res_name, NULL, 0)) return FALSE;
+    ret->fIcon = info.fIcon;
+    ret->xHotspot = info.xHotspot;
+    ret->yHotspot = info.yHotspot;
+    ret->hbmColor = info.hbmColor;
+    ret->hbmMask = info.hbmMask;
+    ret->wResID = res_name.Length ? 0 : LOWORD(res_name.Buffer);
+    ret->szModName[module.Length] = 0;
+    ret->szResName[res_name.Length] = 0;
+    return TRUE;
+}
+
+/***********************************************************************
+ *           create_mono_cursor_buffer
+ *
+ * Return a monochrome icon/cursor wl_shm_buffer
+ */
+static struct wayland_shm_buffer *create_mono_cursor_buffer(struct wayland *wayland,
+                                                            HBITMAP bmp)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    BITMAP bm;
+    char *mask = NULL;
+    unsigned int i, j, stride, mask_size, *ptr;
+
+    if (!NtGdiExtGetObjectW(bmp, sizeof(bm), &bm)) return NULL;
+    stride = ((bm.bmWidth + 15) >> 3) & ~1;
+    mask_size = stride * bm.bmHeight;
+    if (!(mask = malloc(mask_size))) return NULL;
+    if (!NtGdiGetBitmapBits(bmp, mask_size, mask)) goto done;
+
+    bm.bmHeight /= 2;
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto done;
+
+    ptr = shm_buffer->map_data;
+    for (i = 0; i < bm.bmHeight; i++)
+    {
+        for (j = 0; j < bm.bmWidth; j++, ptr++)
+        {
+            int and = ((mask[i * stride + j / 8] << (j % 8)) & 0x80);
+            int xor = ((mask[(i + bm.bmHeight) * stride + j / 8] << (j % 8)) & 0x80);
+            if (!xor && and)
+                *ptr = 0;
+            else if (xor && !and)
+                *ptr = 0xffffffff;
+            else
+                /* we can't draw "invert" pixels, so render them as black instead */
+                *ptr = 0xff000000;
+        }
+    }
+
+done:
+    free(mask);
+    return shm_buffer;
+}
+
+/***********************************************************************
+ *           get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icons and cursors.
+ */
+static struct wayland_shm_buffer *create_color_cursor_buffer(struct wayland *wayland,
+                                                             HDC hdc, HBITMAP color,
+                                                             HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        free(mask_bits);
+    }
+
+    /* Wayland requires pre-multiplied alpha values */
+    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
+    {
+        unsigned char alpha = *ptr >> 24;
+        if (alpha == 0)
+        {
+            *ptr = 0;
+        }
+        else if (alpha != 255)
+        {
+            *ptr = (alpha << 24) |
+                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
+                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
+                   (((BYTE)*ptr * alpha / 255));
+        }
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
+/***********************************************************************
+ *           get_wine_cursor_size
+ *
+ * We use the Wine cursor IDC_ARROW to compute the size that we should use in
+ * the Wayland native cursors. The bitmap usually does not have the same
+ * dimensions of the icon, as it uses a margin. So we take the IDC_ARROW and
+ * compute its height.
+ */
+static int get_wine_cursor_size(struct wayland *wayland)
+{
+    HCURSOR handle = NULL;
+    ICONINFOEXW info = { 0 };
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    unsigned int *pixels, *row, p, x, y;
+    int first_non_empty_line = -1, last_non_empty_line = -1;
+
+    handle = LoadImageW(0, (const WCHAR *)IDC_ARROW, IMAGE_CURSOR, 0, 0,
+                        LR_SHARED | LR_DEFAULTSIZE);
+    if (!handle)
+        goto out;
+
+    if (!get_icon_info(handle, &info))
+        goto out;
+
+    if (info.hbmColor)
+    {
+        HDC hdc = NtGdiCreateCompatibleDC(0);
+        shm_buffer = create_color_cursor_buffer(wayland, hdc,
+                                                info.hbmColor, info.hbmMask);
+        NtGdiDeleteObjectApp(hdc);
+    }
+    else
+    {
+        shm_buffer = create_mono_cursor_buffer(wayland, info.hbmMask);
+    }
+
+    if (!shm_buffer)
+        goto out;
+
+    pixels = (unsigned int *) shm_buffer->map_data;
+
+    /* Compute the height of the IDC_ARROW */
+    for (y = 0; y < shm_buffer->height; y++)
+    {
+        row = (unsigned int *)((unsigned char *)pixels + y * shm_buffer->stride);
+        for (x = 0; x < shm_buffer->width; x++)
+        {
+            p = row[x];
+            /* alpha 0 means fully transparent, so no content in the
+             * pixel - any other pixel we consider content */
+            if ((p & 0xff000000) == 0)
+                continue;
+            /* it's the first time that we find a content pixel, so we set
+             * the first non empty line variable accordingly */
+            if (first_non_empty_line == -1)
+                first_non_empty_line = y;
+            /* we found a content pixel in a line, so update the latest line
+             * that does have content */
+            last_non_empty_line = y;
+            /* we don't care about the other pixels of the line if we have
+             * already found a content pixel on it */
+            break;
+        }
+    }
+
+out:
+    if (handle) NtUserDestroyCursor(handle, 0);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (shm_buffer) wayland_shm_buffer_destroy(shm_buffer);
+
+    if (first_non_empty_line == -1 || last_non_empty_line == -1)
+        return -1;
+
+    return (last_non_empty_line - first_non_empty_line + 1);
+}
+
+void wayland_cursor_theme_init(struct wayland *wayland)
+{
+    char *theme;
+    int size;
+
+    if (!wayland->wl_shm)
+        return;
+
+    size = get_wine_cursor_size(wayland);
+    if (size <= 0)
+       return;
+
+    /* Some compositors set this env var, others don't. But that's fine, if we
+     * call wl_cursor_theme_load() with theme == NULL it will fallback and try
+     * to load the default system theme. */
+    theme = getenv("XCURSOR_THEME");
+
+    cursor_theme = wl_cursor_theme_load(theme, size, wayland->wl_shm);
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info = { 0 };
+    struct wayland_cursor *wayland_cursor = NULL;
+    struct wayland_shm_buffer *shm_buffer = NULL;
+
+    if (!handle) return NULL;
+
+    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto out;
+
+    if (!get_icon_info(handle, &info)) goto out;
+
+    /* First try to get the native Wayland cursor (if the config option is set
+     * and the per-process Wayland instance was able to load the theme) */
+    if (option_use_system_cursors && cursor_theme)
+    {
+        struct wl_cursor_image *wl_cursor_image;
+        struct wl_cursor *wl_cursor;
+
+        wayland_cursor->owns_wl_buffer = FALSE;
+        wl_cursor = _wl_cursor_from_wine_cursor(cursor_theme, MAKEINTRESOURCE(info.wResID));
+        if (wl_cursor && wl_cursor->image_count > 0)
+        {
+            /* TODO: add animated cursor support
+             * cursor->images[i] for i > 0 is only used by animations. */
+            wl_cursor_image = wl_cursor->images[0];
+            wayland_cursor->wl_buffer = wl_cursor_image_get_buffer(wl_cursor_image);
+            if (wayland_cursor->wl_buffer)
+            {
+                wayland_cursor->width = wl_cursor_image->width;
+                wayland_cursor->height = wl_cursor_image->height;
+
+                if (pointer->focused_surface)
+                {
+                    wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                             wl_cursor_image->hotspot_x,
+                                                             wl_cursor_image->hotspot_y,
+                                                             &wayland_cursor->hotspot_x,
+                                                             &wayland_cursor->hotspot_y);
+                }
+                else
+                {
+                    wayland_cursor->hotspot_x = wl_cursor_image->hotspot_x;
+                    wayland_cursor->hotspot_y = wl_cursor_image->hotspot_y;
+                }
+            }
+        }
+    }
+
+    /* If we couldn't get native Wayland cursor (or we didn't even try,
+     * because the config to use it was not set), we copy the Wine cursor
+     * content to a wl_buffer */
+    if (!wayland_cursor->wl_buffer)
+    {
+        wayland_cursor->owns_wl_buffer = TRUE;
+        if (info.hbmColor)
+        {
+            HDC hdc = NtGdiCreateCompatibleDC(0);
+            shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+                                                    info.hbmColor, info.hbmMask);
+            NtGdiDeleteObjectApp(hdc);
+        }
+        else
+        {
+            shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+        }
+
+        if (!shm_buffer) goto out;
+
+        wayland_cursor->width = shm_buffer->width;
+        wayland_cursor->height = shm_buffer->height;
+        wayland_cursor->wl_buffer =
+            wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+
+        /* make sure hotspot is valid */
+        if (info.xHotspot >= wayland_cursor->width ||
+            info.yHotspot >= wayland_cursor->height)
+        {
+            info.xHotspot = wayland_cursor->width / 2;
+            info.yHotspot = wayland_cursor->height / 2;
+        }
+
+        if (pointer->focused_surface)
+        {
+            wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                    info.xHotspot, info.yHotspot,
+                                                    &wayland_cursor->hotspot_x,
+                                                    &wayland_cursor->hotspot_y);
+        }
+        else
+        {
+            wayland_cursor->hotspot_x = info.xHotspot;
+            wayland_cursor->hotspot_y = info.yHotspot;
+        }
+    }
+
+out:
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (wayland_cursor && !wayland_cursor->wl_buffer)
+    {
+        wayland_cursor_destroy(wayland_cursor);
+        wayland_cursor = NULL;
+    }
+    return wayland_cursor;
+}
+
+/***********************************************************************
+ *           wayland_cursor_destroy
+ *
+ *  Destroy a Wayland cursor and its associated resources.
+ */
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
+{
+    if (!wayland_cursor)
+        return;
+
+    if (wayland_cursor->wl_buffer)
+    {
+        /* When using Wayland native cursors, we get the cursor wl_buffer from
+         * using wl_cursor_image_get_buffer(). In such case, the compositor owns
+         * the wl_buffer instead of us. So we should not destroy it. */
+        if (wayland_cursor->owns_wl_buffer)
+            wl_buffer_destroy(wayland_cursor->wl_buffer);
+    }
+
+    free(wayland_cursor);
+}
+
+/***********************************************************************
+ *           wayland_pointer_update_cursor_from_win32
+ *
+ *  Update a Wayland pointer to use the specified cursor, or NULL
+ *  to hide the cursor.
+ */
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle)
+{
+    struct wayland_cursor *wayland_cursor = pointer->cursor;
+
+    TRACE("pointer=%p pointer->hcursor=%p handle=%p\n",
+          pointer, pointer ? pointer->hcursor : 0, handle);
+
+    if (!pointer->wl_pointer)
+        return;
+
+    if (pointer->hcursor != handle)
+    {
+        wayland_cursor = wayland_cursor_from_win32(pointer, handle);
+        /* If we can't create a cursor from a valid handle, better to keep the
+         * previous cursor than make it disappear completely. */
+        if (!wayland_cursor && handle)
+            return;
+
+        if (pointer->cursor)
+            wayland_cursor_destroy(pointer->cursor);
+    }
+
+    pointer->cursor = wayland_cursor;
+    pointer->hcursor = handle;
+
+    if (!pointer->cursor)
+    {
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  NULL, 0, 0);
+            return;
+    }
+
+    wl_surface_attach(pointer->cursor_wl_surface, pointer->cursor->wl_buffer, 0, 0);
+    wl_surface_damage_buffer(pointer->cursor_wl_surface, 0, 0,
+                             wayland_cursor->width, wayland_cursor->height);
+
+    /* Scale the cursor */
+    if (pointer->focused_surface)
+    {
+        double scale = wayland_surface_get_buffer_scale(pointer->focused_surface);
+
+        /* Setting only the viewport is enough, but some compositors don't
+         * support wp_viewport for cursor surfaces, so also set the buffer
+         * scale. Note that setting viewport destination overrides
+         * the buffer scale, so it's fine to set both. */
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface, round(scale));
+
+        if (pointer->cursor_wp_viewport)
+        {
+            int width, height;
+
+            wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                    pointer->cursor->width,
+                    pointer->cursor->height,
+                    &width, &height);
+            wp_viewport_set_destination(pointer->cursor_wp_viewport, width, height);
+        }
+    }
+    else
+    {
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface, 1);
+
+        if (pointer->cursor_wp_viewport)
+            wp_viewport_set_destination(pointer->cursor_wp_viewport, -1, -1);
+    }
+
+
+    wl_surface_commit(pointer->cursor_wl_surface);
+
+    wl_pointer_set_cursor(pointer->wl_pointer,
+                          pointer->enter_serial,
+                          pointer->cursor_wl_surface,
+                          pointer->cursor->hotspot_x,
+                          pointer->cursor->hotspot_y);
+}
+
+/***********************************************************************
+ *           wayland_init_set_cursor
+ *
+ *  Initalize internal information, so that we can track the last set
+ *  cursor properly.
+ */
+BOOL wayland_init_set_cursor(void)
+{
+    /* Allocate a handle that we are going to treat as invalid. */
+    SERVER_START_REQ(alloc_user_handle)
+    {
+        if (!wine_server_call_err(req))
+            invalid_cursor = wine_server_ptr_handle(reply->handle);
+    }
+    SERVER_END_REQ;
+
+    TRACE("invalid_cursor=%p\n", invalid_cursor);
+
+    last_cursor = invalid_cursor;
+
+    return invalid_cursor != NULL;
+}
+
+static HWND wayland_get_thread_cursor_hwnd(void)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND cursor_hwnd;
+
+    if (wayland && wayland->pointer.focused_surface)
+        cursor_hwnd = wayland->pointer.focused_surface->hwnd;
+    else
+        cursor_hwnd = NULL;
+
+    return cursor_hwnd;
+}
+
+/***********************************************************************
+ *           wayland_reapply_thread_cursor
+ *
+ *  Reapply the cursor settings in the current thread.
+ */
+void wayland_reapply_thread_cursor(void)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+    RECT clip;
+
+    TRACE("cursor_hwnd=%p\n", cursor_hwnd);
+
+    if (!cursor_hwnd) return;
+
+    /* Invalidate the set cursor cache, so that next update is
+     * unconditionally applied. */
+    __atomic_store_n(&last_cursor, invalid_cursor, __ATOMIC_SEQ_CST);
+    /* Reapply the current cursor, using NtUserSetCursor() instead of
+     * directly calling our driver function, so that the per-thread cursor
+     * visibility state (i.e., ShowCursor()), which is difficult to access
+     * otherwise, is taken into account. */
+    NtUserSetCursor(NtUserGetCursor());
+    /* Reapply the current cursor clip, so that the wayland pointer
+     * constraint is updated for the newly entered window. */
+    NtUserClipCursor(NtUserGetClipCursor(&clip) ? &clip : NULL);
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursor
+ */
+void WAYLAND_SetCursor(HCURSOR hcursor)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+
+    TRACE("hcursor=%p last_cursor=%p cursor_hwnd=%p\n",
+          hcursor, last_cursor, cursor_hwnd);
+
+    if (!cursor_hwnd) return;
+
+    if (__atomic_exchange_n(&last_cursor, hcursor, __ATOMIC_SEQ_CST) != hcursor)
+    {
+        send_message(cursor_hwnd, WM_WAYLAND_SET_CURSOR, GetCurrentThreadId(),
+                     (LPARAM)hcursor);
+        /* Cursor visibility affects pointer confinement mode. */
+        send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+                     WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP, 0);
+    }
+}
+
+/***********************************************************************
+ *           WAYLAND_ClipCursor
+ */
+BOOL WAYLAND_ClipCursor(const RECT *clip)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+    WPARAM constrain;
+
+    if (!cursor_hwnd) return TRUE;
+
+    constrain = clip ? WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP :
+                       WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP;
+
+    send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE, constrain, 0);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursorPos
+ */
+BOOL WAYLAND_SetCursorPos(int x, int y)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+
+    TRACE("cursor_hwnd=%p, x=%d, y=%d\n", cursor_hwnd, x, y);
+
+    if (!cursor_hwnd) return TRUE;
+
+    send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+                 WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS, 0);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..9a1455d5857
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,921 @@
+/*
+ * Wayland data device (clipboard and DnD) handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "objidl.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
+struct wayland_data_offer
+{
+    IDataObject data_object;
+    struct wayland *wayland;
+    struct wl_data_offer *wl_data_offer;
+    struct wl_array types;
+    uint32_t source_actions;
+    uint32_t action;
+    const char *accepted_mime_type;
+};
+
+/* Normalize the mime type by skipping inconsequential characters, such as
+ * spaces and double quotes, and converting to lower case. */
+static char *normalize_mime_type(const char *mime)
+{
+    char *new_mime;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    cur_read = mime;
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime = malloc(new_mime_len + 1);
+    if (!new_mime) return NULL;
+    cur_read = mime;
+    cur_write = new_mime;
+
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime;
+}
+
+static DWORD dnd_actions_to_drop_effect(uint32_t actions)
+{
+    DWORD drop_effect = 0;
+
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+        drop_effect |= DROPEFFECT_COPY;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+        drop_effect |= DROPEFFECT_MOVE;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+        drop_effect |= DROPEFFECT_COPY | DROPEFFECT_MOVE;
+
+    return drop_effect;
+}
+
+/**********************************************************************
+ *          wl_data_offer handling
+ */
+
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer,
+                             const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    char **p;
+
+    p = wl_array_add(&data_offer->types, sizeof *p);
+    *p = normalize_mime_type(type);
+}
+
+static void data_offer_source_actions(void *data,
+                                      struct wl_data_offer *wl_data_offer,
+                                      uint32_t source_actions)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->source_actions = source_actions;
+}
+
+static void data_offer_action(void *data, struct wl_data_offer *wl_data_offer,
+                              uint32_t dnd_action)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->action = dnd_action;
+}
+
+static const struct wl_data_offer_listener data_offer_listener = {
+    data_offer_offer,
+    data_offer_source_actions,
+    data_offer_action
+};
+
+static ULONG_PTR zero_bits(void)
+{
+#ifdef _WIN64
+    return !NtCurrentTeb()->WowTebOffset ? 0 : 0x7fffffff;
+#else
+    return 0;
+#endif
+}
+
+static void wayland_data_offer_create(struct wayland *wayland,
+                                      struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_offer *data_offer = NULL;
+    SIZE_T size = sizeof(*data_offer);
+
+    /* Ensure that the PE side can access the 'data_object' member, by
+     * allocating wayland_data_offer in Windows virtual memory. */
+    if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&data_offer,
+                                zero_bits(), &size, MEM_COMMIT, PAGE_READWRITE) ||
+        !data_offer)
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->wayland = wayland;
+    data_offer->wl_data_offer = wl_data_offer;
+    wl_array_init(&data_offer->types);
+    wl_data_offer_add_listener(data_offer->wl_data_offer,
+                               &data_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+    SIZE_T size = 0;
+
+    wl_data_offer_destroy(data_offer->wl_data_offer);
+    wl_array_for_each(p, &data_offer->types)
+        free(*p);
+    wl_array_release(&data_offer->types);
+
+    NtFreeVirtualMemory(GetCurrentProcess(), (void **)&data_offer, &size, MEM_RELEASE);
+}
+
+static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
+                                             const char *mime_type,
+                                             size_t *size_out)
+{
+    int data_pipe[2] = {-1, -1};
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    buffer = malloc(buffer_size);
+    if (buffer == NULL)
+    {
+        ERR("failed to allocate read buffer for data offer\n");
+        goto out;
+    }
+
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+        goto out;
+
+    TRACE("mime_type=%s\n", mime_type);
+
+    wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(data_offer->wayland->wl_display);
+
+    do
+    {
+        struct pollfd pfd = { .fd = data_pipe[0], .events = POLLIN };
+        int ret;
+
+        /* Wait a limited amount of time for the data to arrive, since otherwise
+         * a misbehaving data source could block us indefinitely. */
+        while ((ret = poll(&pfd, 1, 3000)) == -1 && errno == EINTR) continue;
+        if (ret <= 0 || !(pfd.revents & (POLLIN | POLLHUP)))
+        {
+            TRACE("failed polling data offer pipe ret=%d errno=%d revents=0x%x\n",
+                  ret, ret == -1 ? errno : 0, pfd.revents);
+            total = 0;
+            goto out;
+        }
+
+        nread = read(data_pipe[0], buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            ERR("failed to read data offer pipe\n");
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                unsigned char *new_buffer;
+                buffer_size += 4096;
+                new_buffer = realloc(buffer, buffer_size);
+                if (!new_buffer)
+                {
+                    ERR("failed to reallocate read buffer for data offer\n");
+                    total = 0;
+                    goto out;
+                }
+                buffer = new_buffer;
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("received %d bytes\n", total);
+
+out:
+    if (data_pipe[0] >= 0)
+        close(data_pipe[0]);
+
+    if (total == 0 && buffer != NULL)
+    {
+        free(buffer);
+        buffer = NULL;
+    }
+
+    *size_out = total;
+
+    return buffer;
+}
+
+static void *wayland_data_offer_import_format(struct wayland_data_offer *data_offer,
+                                              struct wayland_data_device_format *format,
+                                              size_t *ret_size)
+{
+    size_t data_size;
+    void *data, *ret;
+
+    data = wayland_data_offer_receive_data(data_offer, format->mime_type, &data_size);
+    if (!data)
+        return NULL;
+
+    ret = format->import(format, data, data_size, ret_size);
+
+    free(data);
+
+    return ret;
+}
+
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+}
+
+static void wayland_data_device_destroy_dnd_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->dnd_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->dnd_wl_data_offer = NULL;
+    }
+}
+
+static void data_device_data_offer(void *data,
+                                   struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_offer_create(data_device->wayland, wl_data_offer);
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    struct wayland_surface *wayland_surface;
+    POINT point;
+
+    /* Any previous dnd offer should have been freed by a drop or leave event. */
+    assert(data_device->dnd_wl_data_offer == NULL);
+
+    data_device->dnd_wl_data_offer = wl_data_offer;
+
+    if (!wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    wayland_surface = wl_surface_get_user_data(wl_surface);
+
+    if (!wayland_surface || !wayland_surface->hwnd)
+        return;
+
+    data_device->dnd_enter_serial = serial;
+    data_device->dnd_surface = wayland_surface;
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    /* Clear accepted_mime_type here. It should be eventually set by
+     * the DnD client call below. */
+    data_offer->accepted_mime_type = NULL;
+
+    params.event = CLIENT_DND_EVENT_ENTER;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) != 0)
+        return;
+
+    wl_data_offer_set_actions(wl_data_offer, data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    POINT point;
+
+    TRACE("surface=%p hwnd=%p\n",
+          data_device->dnd_surface,
+          data_device->dnd_surface ? data_device->dnd_surface->hwnd : 0);
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
+
+    params.event = CLIENT_DND_EVENT_LEAVE;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = 0;
+    params.data_object = 0;
+
+    WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params));
+
+out:
+    wayland_data_device_destroy_dnd_data_offer(data_device);
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    POINT point;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    params.event = CLIENT_DND_EVENT_MOTION;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) != 0)
+        return;
+
+    wl_data_offer_set_actions(data_device->dnd_wl_data_offer,
+                              data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(data_device->dnd_wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    POINT point;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    params.event = CLIENT_DND_EVENT_DROP;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) == 0)
+        wl_data_offer_finish(data_device->dnd_wl_data_offer);
+
+out:
+    wayland_data_device_destroy_dnd_data_offer(data_device);
+}
+
+static void data_device_selection(void *data,
+                                  struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_device *data_device = data;
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    TRACE("wl_data_offer=%u\n",
+          wl_data_offer ? wl_proxy_get_id((struct wl_proxy*)wl_data_offer) : 0);
+
+    /* We may get a selection event before we have had a chance to create the
+     * clipboard window after thread init (see wayland_init_thread_data), so
+     * we need to ensure we have a valid window here. */
+    wayland_data_device_ensure_clipboard_window(wayland);
+
+    /* Destroy any previous data offer. */
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+
+    /* If we didn't get an offer and we are the clipboard owner, empty the
+     * clipboard. Otherwise ignore the empty offer completely. */
+    if (!wl_data_offer)
+    {
+        if (NtUserGetClipboardOwner() == wayland->clipboard_hwnd)
+        {
+            NtUserOpenClipboard(NULL, 0);
+            NtUserEmptyClipboard();
+            NtUserCloseClipboard();
+        }
+        return;
+    }
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * from us to notify external wayland clients about a wine clipboard update.
+     * The clipboard already contains all the required data, plus we need to ignore
+     * this in order to avoid an endless notification loop. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("ignoring offer produced by winewayland\n");
+            goto ignore_selection;
+        }
+    }
+
+    if (!NtUserOpenClipboard(data_offer->wayland->clipboard_hwnd, 0))
+    {
+        WARN("failed to open clipboard for selection\n");
+        goto ignore_selection;
+    }
+
+    NtUserEmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            struct set_clipboard_params params = { .data = NULL };
+            TRACE("Avalaible clipboard format for %s => %u\n", *p, format->clipboard_format);
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+    data_device->clipboard_wl_data_offer = wl_data_offer;
+
+    return;
+
+ignore_selection:
+    wayland_data_offer_destroy(data_offer);
+}
+
+static const struct wl_data_device_listener data_device_listener = {
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection
+};
+
+/**********************************************************************
+ *          wayland_data_device_init
+ *
+ * Initializes the data_device extension in order to support clipboard
+ * operations.
+ */
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland)
+{
+    data_device->wayland = wayland;
+    data_device->wl_data_device =
+        wl_data_device_manager_get_data_device(wayland->wl_data_device_manager,
+                                               wayland->wl_seat);
+
+    wl_data_device_add_listener(data_device->wl_data_device, &data_device_listener,
+                                data_device);
+}
+
+/**********************************************************************
+ *          wayland_data_device_deinit
+ */
+void wayland_data_device_deinit(struct wayland_data_device *data_device)
+{
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    wayland_data_device_destroy_dnd_data_offer(data_device);
+
+    if (data_device->wl_data_source)
+        wl_data_source_destroy(data_device->wl_data_source);
+    if (data_device->wl_data_device)
+        wl_data_device_destroy(data_device->wl_data_device);
+
+    memset(data_device, 0, sizeof(*data_device));
+}
+
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void wayland_data_source_export(struct wayland_data_device_format *format, int32_t fd)
+{
+    struct get_clipboard_params params = { .data_only = TRUE, .data_size = 0 };
+    static const size_t buffer_size = 1024;
+
+    if (!(params.data = malloc(buffer_size))) return;
+
+    if (!NtUserOpenClipboard(thread_wayland()->clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for export\n");
+        goto out;
+    }
+
+    params.size = buffer_size;
+    if (NtUserGetClipboardData(format->clipboard_format, &params))
+    {
+        format->export(format, fd, params.data, params.size);
+    }
+    else if (params.data_size)
+    {
+        /* If 'buffer_size' is too small, NtUserGetClipboardData writes the
+         * minimum size in 'params.data_size', so we retry with that. */
+        free(params.data);
+        params.data = malloc(params.data_size);
+        if (params.data)
+        {
+            params.size = params.data_size;
+            if (NtUserGetClipboardData(format->clipboard_format, &params))
+                format->export(format, fd, params.data, params.size);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+out:
+    free(params.data);
+}
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct wayland_data_device_format *format =
+        wayland_data_device_format_for_mime_type(mime_type);
+
+    TRACE("source=%p mime_type=%s\n", source, mime_type);
+
+    if (format) wayland_data_source_export(format, fd);
+
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    TRACE("source=%p\n", source);
+    wl_data_source_destroy(source);
+    data_device->wl_data_source = NULL;
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener = {
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
+/**********************************************************************
+ *          clipboard window handling
+ */
+
+static void clipboard_update(void)
+{
+    struct wayland *wayland = thread_wayland();
+    uint32_t enter_serial;
+    struct wl_data_source *source;
+    UINT clipboard_format = 0;
+
+    TRACE("WM_CLIPBOARDUPDATE wayland %p enter_serial=%d/%d\n",
+          wayland,
+          wayland ? wayland->keyboard.enter_serial : -1,
+          wayland ? wayland->pointer.enter_serial : -1);
+
+    if (!wayland)
+        return;
+
+    enter_serial = wayland->keyboard.enter_serial ? wayland->keyboard.enter_serial
+                                                  : wayland->pointer.enter_serial;
+
+    if (!enter_serial)
+        return;
+
+    if (!NtUserOpenClipboard(wayland->clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard\n");
+        return;
+    }
+
+    source = wl_data_device_manager_create_data_source(wayland->wl_data_device_manager);
+    /* Track the current wl_data_source, so we can properly destroy it during thread
+     * deinitilization, in case it has not been cancelled before that. */
+    if (wayland->data_device.wl_data_source)
+        wl_data_source_destroy(wayland->data_device.wl_data_source);
+    wayland->data_device.wl_data_source = source;
+
+    while ((clipboard_format = NtUserEnumClipboardFormats(clipboard_format)))
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_clipboard_format(clipboard_format, NULL);
+        if (format)
+        {
+            TRACE("Offering source=%p mime=%s\n", source, format->mime_type);
+            wl_data_source_offer(source, format->mime_type);
+        }
+    }
+
+    /* Add a special entry so that we can detect when an offer is coming from us. */
+    wl_data_source_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
+
+    wl_data_source_add_listener(source, &data_source_listener, &wayland->data_device);
+    wl_data_device_set_selection(wayland->data_device.wl_data_device, source,
+                                 enter_serial);
+
+    NtUserCloseClipboard();
+}
+
+static void clipboard_render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device;
+    struct wayland_data_offer *data_offer;
+    struct wayland_data_device_format *format;
+
+    data_device = wl_data_device_get_user_data(thread_wayland()->data_device.wl_data_device);
+    if (!data_device->clipboard_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    if (!data_offer)
+        return;
+
+    format = wayland_data_device_format_for_clipboard_format(clipboard_format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        struct set_clipboard_params params = { 0 };
+        if ((params.data = wayland_data_offer_import_format(data_offer, format, &params.size)))
+        {
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+            free(params.data);
+        }
+    }
+}
+
+static void clipboard_destroy(void)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_device *data_device =
+        wl_data_device_get_user_data(wayland->data_device.wl_data_device);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+}
+
+/**********************************************************************
+ *          waylanddrv_unix_clipboard_message
+ */
+NTSTATUS waylanddrv_unix_clipboard_message(void *arg)
+{
+    struct waylanddrv_unix_clipboard_message_params *params = arg;
+
+    switch (params->msg)
+    {
+    case WM_NCCREATE:
+        return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        TRACE("WM_CLIPBOARDUPDATE\n");
+        /* Ignore our own updates */
+        if (NtUserGetClipboardOwner() != params->hwnd) clipboard_update();
+        break;
+    case WM_RENDERFORMAT:
+        TRACE("WM_RENDERFORMAT: %ld\n", (long)params->wparam);
+        clipboard_render_format(params->wparam);
+        break;
+    case WM_DESTROYCLIPBOARD:
+        TRACE("WM_DESTROYCLIPBOARD: clipboard_hwnd=%p\n", params->hwnd);
+        clipboard_destroy();
+        break;
+    }
+
+    return NtUserMessageCall(params->hwnd, params->msg, params->wparam,
+                             params->lparam, NULL, NtUserDefWindowProc, FALSE);
+}
+
+/**********************************************************************
+ *          wayland_data_device_ensure_clipboard_window
+ *
+ * Creates (if not already created) the window which handles clipboard
+ * messages for the specified wayland instance.
+ */
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
+{
+    if (!wayland->clipboard_hwnd)
+    {
+        wayland->clipboard_hwnd =
+            ULongToHandle(WAYLANDDRV_CLIENT_CALL(create_clipboard_window, NULL, 0));
+    }
+}
+
+NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg)
+{
+    struct waylanddrv_unix_data_offer_accept_format_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    struct wayland_data_device_format *format;
+
+    TRACE("data_offer=%p clipboard_format=%d\n", data_offer, p->format);
+
+    format = wayland_data_device_format_for_clipboard_format(p->format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        TRACE("found offer %s for clipboard format %u\n",
+              format->mime_type, format->clipboard_format);
+        data_offer->accepted_mime_type = format->mime_type;
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+NTSTATUS waylanddrv_unix_data_offer_enum_formats(void *arg)
+{
+    struct waylanddrv_unix_data_offer_enum_formats_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    char **mime;
+    UINT count = 0;
+
+    wl_array_for_each(mime, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*mime);
+        if (format)
+        {
+            if (p->formats && count < p->num_formats)
+                p->formats[count] = format->clipboard_format;
+            count++;
+        }
+    }
+
+    p->num_formats = count;
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg)
+{
+    struct waylanddrv_unix_data_offer_import_format_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    struct wayland_data_device_format *format;
+
+    TRACE("data_offer=%p clipboard_format=%d\n", data_offer, p->format);
+
+    format = wayland_data_device_format_for_clipboard_format(p->format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        void *data, *vdata = NULL;
+        size_t size;
+        SIZE_T vsize;
+
+        if (!(data = wayland_data_offer_import_format(data_offer, format, &size)))
+            return STATUS_UNSUCCESSFUL;
+        vsize = size;
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&vdata,
+                                    zero_bits(), &vsize, MEM_COMMIT, PAGE_READWRITE) ||
+            !vdata)
+        {
+            free(data);
+            return STATUS_UNSUCCESSFUL;
+        }
+        memcpy(vdata, data, size);
+        p->data = PtrToUint(vdata);
+        p->size = size;
+        free(data);
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
new file mode 100644
index 00000000000..7f5019fe4b7
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -0,0 +1,526 @@
+/*
+ * Wayland data device (clipboard and DnD) handling (DLL code)
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv_dll.h"
+
+#define COBJMACROS
+#include "objidl.h"
+#include "shlobj.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static IDataObjectVtbl dataOfferDataObjectVtbl;
+
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    struct waylanddrv_unix_clipboard_message_params params;
+
+    switch (msg)
+    {
+    case WM_NCCREATE:
+    case WM_CLIPBOARDUPDATE:
+    case WM_RENDERFORMAT:
+    case WM_DESTROYCLIPBOARD:
+        params.hwnd = hwnd;
+        params.msg = msg;
+        params.wparam = wp;
+        params.lparam = lp;
+        return WAYLANDDRV_UNIX_CALL(clipboard_message, &params);
+    }
+
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size)
+{
+    static const WCHAR clipboard_classname[] = {
+        '_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d',
+        '_','m','a','n','a','g','e','r',0
+    };
+    WNDCLASSW class;
+    HWND clipboard_hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW(&class) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %lu\n", GetLastError());
+        return 0;
+    }
+
+    if (!(clipboard_hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                         HWND_MESSAGE, 0, 0, NULL)))
+    {
+        ERR("failed to create clipboard window err %lu\n", GetLastError());
+        return 0;
+    }
+
+    if (!AddClipboardFormatListener(clipboard_hwnd))
+        ERR("failed to set clipboard listener %lu\n", GetLastError());
+
+    TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
+    return HandleToUlong(clipboard_hwnd);
+}
+
+/**********************************************************************
+ *          IDropTarget discovery
+ *
+ * Based on functions in dlls/ole32/ole2.c
+ */
+
+static HANDLE get_drop_target_local_handle(HWND hwnd)
+{
+    static const WCHAR prop_marshalleddrop_target[] =
+        {'W','i','n','e','M','a','r','s','h','a','l','l','e','d',
+         'D','r','o','p','T','a','r','g','e','t',0};
+    HANDLE handle;
+    HANDLE local_handle = 0;
+
+    handle = GetPropW(hwnd, prop_marshalleddrop_target);
+    if (handle)
+    {
+        DWORD pid;
+        HANDLE process;
+
+        GetWindowThreadProcessId(hwnd, &pid);
+        process = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid);
+        if (process)
+        {
+            DuplicateHandle(process, handle, GetCurrentProcess(), &local_handle,
+                            0, FALSE, DUPLICATE_SAME_ACCESS);
+            CloseHandle(process);
+        }
+    }
+    return local_handle;
+}
+
+static HRESULT create_stream_from_map(HANDLE map, IStream **stream)
+{
+    HRESULT hr = E_OUTOFMEMORY;
+    HGLOBAL hmem;
+    void *data;
+    MEMORY_BASIC_INFORMATION info;
+
+    data = MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
+    if(!data) return hr;
+
+    VirtualQuery(data, &info, sizeof(info));
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, info.RegionSize);
+    if(hmem)
+    {
+        memcpy(GlobalLock(hmem), data, info.RegionSize);
+        GlobalUnlock(hmem);
+        hr = CreateStreamOnHGlobal(hmem, TRUE, stream);
+    }
+    UnmapViewOfFile(data);
+    return hr;
+}
+
+static IDropTarget* get_drop_target_pointer(HWND hwnd)
+{
+    IDropTarget *drop_target = NULL;
+    HANDLE map;
+    IStream *stream;
+
+    map = get_drop_target_local_handle(hwnd);
+    if(!map) return NULL;
+
+    if(SUCCEEDED(create_stream_from_map(map, &stream)))
+    {
+        CoUnmarshalInterface(stream, &IID_IDropTarget, (void**)&drop_target);
+        IStream_Release(stream);
+    }
+    CloseHandle(map);
+    return drop_target;
+}
+
+static IDropTarget *drop_target_from_window_point(HWND hwnd, POINT point)
+{
+    HWND child;
+    IDropTarget *drop_target;
+    HWND orig_hwnd = hwnd;
+    POINT orig_point = point;
+
+    /* Find the deepest child window. */
+    ScreenToClient(hwnd, &point);
+    while ((child = ChildWindowFromPointEx(hwnd, point, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE)) &&
+            child != hwnd)
+    {
+        MapWindowPoints(hwnd, child, &point, 1);
+        hwnd = child;
+    }
+
+    /* Ascend the children hierarchy until we find one that accepts drops. */
+    do
+    {
+        drop_target = get_drop_target_pointer(hwnd);
+    } while (drop_target == NULL && (hwnd = GetParent(hwnd)) != NULL);
+
+    TRACE("hwnd=%p point=(%ld,%ld) => dnd_hwnd=%p drop_target=%p\n",
+          orig_hwnd, orig_point.x, orig_point.y, hwnd, drop_target);
+    return drop_target;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_enter(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    IDataObject *data_object = UIntToPtr(p->data_object);
+    HRESULT hr;
+
+    /* If unixlib is 64 bits and PE is 32 bits, this will write a 32 bit
+     * pointer value to the bottom of 64 bit pointer variable, which works out
+     * fine due to little-endianness and the fact that lpVtbl has been zero
+     * initialized. */
+    data_object->lpVtbl = &dataOfferDataObjectVtbl;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragEnter(drop_target, data_object, MK_LBUTTON,
+                               *(POINTL*)&p->point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_leave(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragLeave(drop_target);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_motion(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragOver(drop_target, MK_LBUTTON, *(POINTL*)&p->point,
+                              &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_drop(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    IDataObject *data_object = UIntToPtr(p->data_object);
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (drop_target)
+    {
+        hr = IDropTarget_Drop(drop_target, data_object, MK_LBUTTON,
+                              *(POINTL*)&p->point, &drop_effect);
+        IDropTarget_Release(drop_target);
+        if (SUCCEEDED(hr) && drop_effect != DROPEFFECT_NONE)
+            return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+
+    switch (p->event) {
+    case CLIENT_DND_EVENT_ENTER:
+        return waylanddrv_client_dnd_enter(params, size);
+    case CLIENT_DND_EVENT_LEAVE:
+        return waylanddrv_client_dnd_leave(params, size);
+    case CLIENT_DND_EVENT_MOTION:
+        return waylanddrv_client_dnd_motion(params, size);
+    case CLIENT_DND_EVENT_DROP:
+        return waylanddrv_client_dnd_drop(params, size);
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+/*********************************************************
+ * Implementation of IDataObject for wayland data offers *
+ *********************************************************/
+
+static HRESULT WINAPI dataOfferDataObject_QueryInterface(IDataObject *data_object,
+                                                         REFIID riid, void **object)
+{
+    TRACE("(%p, %s, %p)\n", data_object, debugstr_guid(riid), object);
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDataObject))
+    {
+        *object = data_object;
+        IDataObject_AddRef(data_object);
+        return S_OK;
+    }
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI dataOfferDataObject_AddRef(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when the data_offer is destroyed, so we don't care about proper
+     * reference tracking. */
+    return 2;
+}
+
+static ULONG WINAPI dataOfferDataObject_Release(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when, so we don't care about proper reference tracking. */
+    return 1;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium)
+{
+    HRESULT hr;
+    struct waylanddrv_unix_data_offer_import_format_params params;
+    void *data;
+
+    TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
+
+    hr = IDataObject_QueryGetData(data_object, format_etc);
+    if (!SUCCEEDED(hr))
+        return hr;
+
+    params.data_offer = PtrToUint(data_object);
+    params.format = format_etc->cfFormat;
+    params.data = 0;
+    params.size = 0;
+
+    if (WAYLANDDRV_UNIX_CALL(data_offer_import_format, &params) != 0 || !params.data)
+        return E_UNEXPECTED;
+
+    data = UIntToPtr(params.data);
+
+    medium->hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, params.size);
+    if (medium->hGlobal == NULL)
+        return E_OUTOFMEMORY;
+    memcpy(GlobalLock(medium->hGlobal), data, params.size);
+    GlobalUnlock(medium->hGlobal);
+
+    medium->tymed = TYMED_HGLOBAL;
+    medium->pUnkForRelease = 0;
+
+    VirtualFree(data, params.size, MEM_RELEASE);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
+                                                      FORMATETC *format_etc,
+                                                      STGMEDIUM *medium)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, medium);
+    return DATA_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
+                                                       FORMATETC *format_etc)
+{
+    struct waylanddrv_unix_data_offer_accept_format_params params;
+
+    TRACE("(%p, %p={.tymed=0x%lx, .dwAspect=%ld, .cfFormat=%d}\n",
+          data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
+          format_etc->cfFormat);
+
+    if (format_etc->tymed && !(format_etc->tymed & TYMED_HGLOBAL))
+    {
+        FIXME("only HGLOBAL medium types supported right now\n");
+        return DV_E_TYMED;
+    }
+
+    params.data_offer = PtrToUint(data_object);
+    params.format = format_etc->cfFormat;
+
+    if (WAYLANDDRV_UNIX_CALL(data_offer_accept_format, &params) == 0)
+        return S_OK;
+
+    TRACE("didn't find offer for clipboard format %u\n", format_etc->cfFormat);
+    return DV_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetCanonicalFormatEtc(IDataObject *data_object,
+                                                                FORMATETC *format_etc,
+                                                                FORMATETC *format_etc_out)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, format_etc_out);
+    format_etc_out->ptd = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium, BOOL release)
+{
+    FIXME("(%p, %p, %p, %s): stub\n", data_object, format_etc,
+          medium, release ? "TRUE" : "FALSE");
+    return E_NOTIMPL;
+}
+
+static BOOL formats_etc_contains_clipboard_format(FORMATETC *formats_etc,
+                                                  size_t formats_etc_count,
+                                                  UINT clipboard_format)
+{
+    size_t i;
+
+    for (i = 0; i < formats_etc_count; i++)
+        if (formats_etc[i].cfFormat == clipboard_format) return TRUE;
+
+    return FALSE;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
+                                                        DWORD direction,
+                                                        IEnumFORMATETC **enum_format_etc)
+{
+    HRESULT hr;
+    FORMATETC *formats_etc;
+    size_t formats_etc_count = 0;
+    struct waylanddrv_unix_data_offer_enum_formats_params params;
+
+    TRACE("(%p, %lu, %p)\n", data_object, direction, enum_format_etc);
+
+    if (direction != DATADIR_GET)
+    {
+        FIXME("only the get direction is implemented\n");
+        return E_NOTIMPL;
+    }
+
+    params.data_offer = PtrToUint(data_object);
+    params.formats = NULL;
+    params.num_formats = 0;
+
+    WAYLANDDRV_UNIX_CALL(data_offer_enum_formats, &params);
+    params.formats = HeapAlloc(GetProcessHeap(), 0, params.num_formats * sizeof(UINT));
+    WAYLANDDRV_UNIX_CALL(data_offer_enum_formats, &params);
+    if (!params.formats)
+        return E_OUTOFMEMORY;
+
+    /* Allocate space for all offered mime types, although we may not use them all */
+    formats_etc = HeapAlloc(GetProcessHeap(), 0, params.num_formats * sizeof(FORMATETC));
+    if (!formats_etc)
+    {
+        HeapFree(GetProcessHeap(), 0, params.formats);
+        return E_OUTOFMEMORY;
+    }
+
+    for (int i = 0; i < params.num_formats; i++)
+    {
+        if (!formats_etc_contains_clipboard_format(formats_etc, formats_etc_count,
+                                                   params.formats[i]))
+        {
+            FORMATETC *current= &formats_etc[formats_etc_count];
+
+            current->cfFormat = params.formats[i];
+            current->ptd = NULL;
+            current->dwAspect = DVASPECT_CONTENT;
+            current->lindex = -1;
+            current->tymed = TYMED_HGLOBAL;
+
+            formats_etc_count += 1;
+        }
+    }
+
+    hr = SHCreateStdEnumFmtEtc(formats_etc_count, formats_etc, enum_format_etc);
+    HeapFree(GetProcessHeap(), 0, params.formats);
+    HeapFree(GetProcessHeap(), 0, formats_etc);
+
+    return hr;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
+                                                  FORMATETC *format_etc, DWORD advf,
+                                                  IAdviseSink *advise_sink,
+                                                  DWORD *connection)
+{
+    FIXME("(%p, %p, %lu, %p, %p): stub\n", data_object, format_etc, advf,
+          advise_sink, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DUnadvise(IDataObject *data_object,
+                                                    DWORD connection)
+{
+    FIXME("(%p, %lu): stub\n", data_object, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumDAdvise(IDataObject *data_object,
+                                                      IEnumSTATDATA **enum_advise)
+{
+    FIXME("(%p, %p): stub\n", data_object, enum_advise);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static IDataObjectVtbl dataOfferDataObjectVtbl =
+{
+    dataOfferDataObject_QueryInterface,
+    dataOfferDataObject_AddRef,
+    dataOfferDataObject_Release,
+    dataOfferDataObject_GetData,
+    dataOfferDataObject_GetDataHere,
+    dataOfferDataObject_QueryGetData,
+    dataOfferDataObject_GetCanonicalFormatEtc,
+    dataOfferDataObject_SetData,
+    dataOfferDataObject_EnumFormatEtc,
+    dataOfferDataObject_DAdvise,
+    dataOfferDataObject_DUnadvise,
+    dataOfferDataObject_EnumDAdvise
+};
diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
new file mode 100644
index 00000000000..069a4157cbe
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -0,0 +1,599 @@
+/*
+ * Wayland data device format handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "shlobj.h"
+#include "winternl.h"
+#include "winnls.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+
+    while (nwritten < count)
+    {
+        ssize_t ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR)
+        {
+            WARN("Failed to write all data, had %zu bytes, wrote %zu bytes (errno: %d)\n",
+                 count, nwritten, errno);
+            break;
+        }
+        else if (ret > 0)
+        {
+            nwritten += ret;
+        }
+    }
+}
+
+#define NLS_SECTION_CODEPAGE 11
+
+static BOOL get_cp_tableinfo(ULONG cp, CPTABLEINFO *cptable)
+{
+    USHORT *ptr;
+    SIZE_T nls_size;
+
+    if (!NtGetNlsSectionPtr(NLS_SECTION_CODEPAGE, cp, NULL, (void **)&ptr, &nls_size))
+    {
+        RtlInitCodePageTable(ptr, cptable);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void *import_text_as_unicode(struct wayland_data_device_format *format,
+                                    const void *data, size_t data_size, size_t *ret_size)
+{
+    DWORD wsize;
+    void *ret;
+
+    if (format->extra == CP_UTF8)
+    {
+        RtlUTF8ToUnicodeN(NULL, 0, &wsize, data, data_size);
+        if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+        RtlUTF8ToUnicodeN(ret, wsize, &wsize, data, data_size);
+    }
+    else
+    {
+        CPTABLEINFO cptable;
+        /* In the worst case, each byte of the input text data corresponds
+         * to a single character, which may need up to two WCHAR for UTF-16
+         * encoding. */
+        wsize = data_size * sizeof(WCHAR) * 2;
+        if (!get_cp_tableinfo(format->extra, &cptable)) return NULL;
+        if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+        RtlCustomCPToUnicodeN(&cptable, ret, wsize, &wsize, data, data_size);
+    }
+    ((WCHAR *)ret)[wsize / sizeof(WCHAR)] = 0;
+
+    if (ret_size) *ret_size = wsize + sizeof(WCHAR);
+
+    return ret;
+}
+
+static void export_text(struct wayland_data_device_format *format, int fd, void *data, size_t size)
+{
+    DWORD byte_count;
+    char *bytes;
+
+    /* Wayland apps expect strings to not be zero-terminated, so avoid
+     * zero-terminating the resulting converted string. */
+    if (((WCHAR *)data)[size / sizeof(WCHAR) - 1] == 0) size -= sizeof(WCHAR);
+
+    if (format->extra == CP_UTF8)
+    {
+        RtlUnicodeToUTF8N(NULL, 0, &byte_count, data, size);
+        if (!(bytes = malloc(byte_count))) return;
+        RtlUnicodeToUTF8N(bytes, byte_count, &byte_count, data, size);
+    }
+    else
+    {
+        CPTABLEINFO cptable;
+        if (!get_cp_tableinfo(format->extra, &cptable)) return;
+        byte_count = size / sizeof(WCHAR) * cptable.MaximumCharacterSize;
+        if (!(bytes = malloc(byte_count))) return;
+        RtlUnicodeToCustomCPN(&cptable, bytes, byte_count, &byte_count, data, size);
+    }
+
+    write_all(fd, bytes, byte_count);
+
+    free(bytes);
+}
+
+static void *import_data(struct wayland_data_device_format *format,
+                         const void *data, size_t data_size, size_t *ret_size)
+{
+    void *ret;
+
+    ret = malloc(data_size);
+    if (ret)
+    {
+        memcpy(ret, data, data_size);
+        if (ret_size) *ret_size = data_size;
+    }
+
+    return ret;
+}
+
+static void export_data(struct wayland_data_device_format *format, int fd, void *data, size_t size)
+{
+    write_all(fd, data, size);
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static char *decode_uri(const char *uri, size_t uri_length)
+{
+    char *decoded = malloc(uri_length + 1);
+    size_t uri_i = 0;
+    size_t decoded_i = 0;
+
+    if (decoded == NULL)
+        goto err;
+
+    while (uri_i < uri_length)
+    {
+        if (uri[uri_i] == '%')
+        {
+            unsigned long number;
+            char buffer[3];
+
+            if (uri_i + 1 == uri_length || uri_i + 2 == uri_length)
+                goto err;
+
+            buffer[0] = uri[uri_i + 1];
+            buffer[1] = uri[uri_i + 2];
+            buffer[2] = '\0';
+            errno = 0;
+            number = strtoul(buffer, NULL, 16);
+            if (errno != 0) goto err;
+            decoded[decoded_i] = number;
+
+            uri_i += 3;
+            decoded_i++;
+        }
+        else
+        {
+            decoded[decoded_i++] = uri[uri_i++];
+        }
+    }
+
+    decoded[decoded_i] = '\0';
+
+    return decoded;
+
+err:
+    free(decoded);
+    return NULL;
+}
+
+/* based on wine_get_dos_file_name */
+static WCHAR *get_dos_file_name(const char *path)
+{
+    ULONG len = strlen(path) + 9; /* \??\unix prefix */
+    WCHAR *ret;
+
+    if (!(ret = malloc(len * sizeof(WCHAR)))) return NULL;
+    if (wine_unix_to_nt_file_name(path, ret, &len))
+    {
+        free(ret);
+        return NULL;
+    }
+
+    if (ret[5] == ':')
+    {
+        /* get rid of the \??\ prefix */
+        memmove(ret, ret + 4, (len - 4) * sizeof(WCHAR));
+    }
+    else
+    {
+        ret[1] = '\\';
+    }
+    return ret;
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static WCHAR* decoded_uri_to_dos(const char *uri)
+{
+    WCHAR *ret = NULL;
+
+    if (strncmp(uri, "file:/", 6))
+        return NULL;
+
+    if (uri[6] == '/')
+    {
+        if (uri[7] == '/')
+        {
+            /* file:///path/to/file (nautilus, thunar) */
+            ret = get_dos_file_name(&uri[7]);
+        }
+        else if (uri[7])
+        {
+            /* file://hostname/path/to/file (X file drag spec) */
+            char hostname[256];
+            char *path = strchr(&uri[7], '/');
+            if (path)
+            {
+                *path = '\0';
+                if (strcmp(&uri[7], "localhost") == 0)
+                {
+                    *path = '/';
+                    ret = get_dos_file_name(path);
+                }
+                else if (gethostname(hostname, sizeof(hostname)) == 0)
+                {
+                    if (strcmp(hostname, &uri[7]) == 0)
+                    {
+                        *path = '/';
+                        ret = get_dos_file_name(path);
+                    }
+                }
+            }
+        }
+    }
+    else if (uri[6])
+    {
+        /* file:/path/to/file (konqueror) */
+        ret = get_dos_file_name(&uri[5]);
+    }
+
+    return ret;
+}
+
+static void *import_uri_list(struct wayland_data_device_format *format,
+                             const void *data, size_t data_size, size_t *ret_size)
+{
+    DROPFILES *drop_files = NULL;
+    size_t drop_size;
+    const char *data_end = (const char *) data + data_size;
+    const char *line_start = data;
+    const char *line_end;
+    WCHAR **path;
+    struct wl_array paths;
+    size_t total_chars = 0;
+    WCHAR *dst;
+
+    TRACE("data=%p size=%lu\n", data, (unsigned long)data_size);
+
+    wl_array_init(&paths);
+
+    while (line_start < data_end)
+    {
+        /* RFC 2483 requires CRLF for text/uri-list line termination, but
+         * some applications send LF. Accept both line terminators. */
+        line_end = strchr(line_start, '\n');
+        if (line_end == NULL)
+        {
+            WARN("URI list line doesn't end in (\\r)\\n\n");
+            break;
+        }
+
+        if (line_end > line_start && line_end[-1] == '\r') line_end--;
+
+        if (line_start[0] != '#')
+        {
+            char *decoded_uri = decode_uri(line_start, line_end - line_start);
+            TRACE("decoded_uri=%s\n", decoded_uri);
+            path = wl_array_add(&paths, sizeof *path);
+            if (!path) goto out;
+            *path = decoded_uri_to_dos(decoded_uri);
+            total_chars += lstrlenW(*path) + 1;
+            free(decoded_uri);
+        }
+
+        line_start = line_end + (*line_end == '\r' ? 2 : 1);
+    }
+
+    /* DROPFILES points to an array of consecutive null terminated WCHAR strings,
+     * followed by a final 0 WCHAR to denote the end of the array. We place that
+     * array just after the DROPFILE struct itself. */
+    drop_size = sizeof(DROPFILES) + (total_chars + 1) * sizeof(WCHAR);
+    if (!(drop_files = malloc(drop_size)))
+        goto out;
+
+    drop_files->pFiles = sizeof(*drop_files);
+    drop_files->pt.x = 0;
+    drop_files->pt.y = 0;
+    drop_files->fNC = FALSE;
+    drop_files->fWide = TRUE;
+
+    dst = (WCHAR *)(drop_files + 1);
+    wl_array_for_each(path, &paths)
+    {
+        lstrcpyW(dst, *path);
+        dst += lstrlenW(*path) + 1;
+    }
+    *dst = 0;
+
+    if (ret_size) *ret_size = drop_size;
+
+out:
+    wl_array_for_each(path, &paths)
+        free(*path);
+
+    wl_array_release(&paths);
+
+    return drop_files;
+}
+
+static CPTABLEINFO *get_ansi_cp(void)
+{
+    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
+    static CPTABLEINFO cp;
+    if (!cp.CodePage)
+    {
+        if (NtCurrentTeb()->Peb->AnsiCodePageData)
+            RtlInitCodePageTable(NtCurrentTeb()->Peb->AnsiCodePageData, &cp);
+        else
+            RtlInitCodePageTable(utf8_hdr, &cp);
+    }
+    return &cp;
+}
+
+/* Helper functions to implement export_hdrop, adapted from winex11.drv */
+
+static BOOL get_nt_pathname(const WCHAR *name, UNICODE_STRING *nt_name)
+{
+    static const WCHAR ntprefixW[] = {'\\','?','?','\\'};
+    static const WCHAR uncprefixW[] = {'U','N','C','\\'};
+    size_t len = lstrlenW(name);
+    WCHAR *ptr;
+
+    nt_name->MaximumLength = (len + 8) * sizeof(WCHAR);
+    if (!(ptr = malloc(nt_name->MaximumLength))) return FALSE;
+    nt_name->Buffer = ptr;
+
+    memcpy(ptr, ntprefixW, sizeof(ntprefixW));
+    ptr += ARRAYSIZE(ntprefixW);
+    if (name[0] == '\\' && name[1] == '\\')
+    {
+        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
+        {
+            name += 4;
+            len -= 4;
+        }
+        else
+        {
+            memcpy(ptr, uncprefixW, sizeof(uncprefixW));
+            ptr += ARRAYSIZE(uncprefixW);
+            name += 2;
+            len -= 2;
+        }
+    }
+    memcpy(ptr, name, (len + 1) * sizeof(WCHAR));
+    ptr += len;
+    nt_name->Length = (ptr - nt_name->Buffer) * sizeof(WCHAR);
+    return TRUE;
+}
+
+static char *get_unix_file_name(const WCHAR *dosW)
+{
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    ULONG size = 256;
+    char *buffer;
+
+    if (!get_nt_pathname(dosW, &nt_name)) return NULL;
+    InitializeObjectAttributes(&attr, &nt_name, 0, 0, NULL);
+    for (;;)
+    {
+        if (!(buffer = malloc(size)))
+        {
+            free(nt_name.Buffer);
+            return NULL;
+        }
+        status = wine_nt_to_unix_file_name(&attr, buffer, &size, FILE_OPEN_IF);
+        if (status != STATUS_BUFFER_TOO_SMALL) break;
+        free(buffer);
+    }
+    free(nt_name.Buffer);
+    if (status)
+    {
+        free(buffer);
+        return NULL;
+    }
+    return buffer;
+}
+
+/* Export text/uri-list to CF_HDROP, adapted from winex11.drv */
+static void export_hdrop(struct wayland_data_device_format *format, int fd,
+                         void *data, size_t size)
+{
+    char *textUriList = NULL;
+    UINT textUriListSize = 32;
+    UINT next = 0;
+    const WCHAR *ptr;
+    WCHAR *unicode_data = NULL;
+    DROPFILES *drop_files = data;
+
+    if (!drop_files->fWide)
+    {
+        char *files = (char *)data + drop_files->pFiles;
+        CPTABLEINFO *cp = get_ansi_cp();
+        DWORD len = 0;
+
+        while (files[len]) len += strlen(files + len) + 1;
+        len++;
+
+        if (!(ptr = unicode_data = malloc(len * sizeof(WCHAR)))) goto out;
+
+        if (cp->CodePage == CP_UTF8)
+            RtlUTF8ToUnicodeN(unicode_data, len * sizeof(WCHAR), &len, files, len);
+        else
+            RtlCustomCPToUnicodeN(cp, unicode_data, len * sizeof(WCHAR), &len, files, len);
+    }
+    else ptr = (const WCHAR *)((char *)data + drop_files->pFiles);
+
+    if (!(textUriList = malloc(textUriListSize))) goto out;
+
+    while (*ptr)
+    {
+        char *unixFilename = NULL;
+        UINT uriSize;
+        UINT u;
+
+        unixFilename = get_unix_file_name(ptr);
+        if (unixFilename == NULL) goto out;
+        ptr += lstrlenW(ptr) + 1;
+
+        uriSize = 8 + /* file:/// */
+                  3 * (lstrlenA(unixFilename) - 1) + /* "%xy" per char except first '/' */
+                  2; /* \r\n */
+        if ((next + uriSize) > textUriListSize)
+        {
+            UINT biggerSize = max(2 * textUriListSize, next + uriSize);
+            void *bigger = realloc(textUriList, biggerSize);
+            if (bigger)
+            {
+                textUriList = bigger;
+                textUriListSize = biggerSize;
+            }
+            else
+            {
+                free(unixFilename);
+                goto out;
+            }
+        }
+        lstrcpyA(&textUriList[next], "file:///");
+        next += 8;
+        /* URL encode everything - unnecessary, but easier/lighter than
+         * linking in shlwapi, and can't hurt */
+        for (u = 1; unixFilename[u]; u++)
+        {
+            static const char hex_table[] = "0123456789abcdef";
+            textUriList[next++] = '%';
+            textUriList[next++] = hex_table[unixFilename[u] >> 4];
+            textUriList[next++] = hex_table[unixFilename[u] & 0xf];
+        }
+        textUriList[next++] = '\r';
+        textUriList[next++] = '\n';
+        free(unixFilename);
+    }
+
+    write_all(fd, textUriList, next);
+
+out:
+    free(unicode_data);
+    free(textUriList);
+}
+
+#define CP_ASCII 20127
+
+static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+static const WCHAR pngW[] = {'P','N','G',0};
+static const WCHAR jfifW[] = {'J','F','I','F',0};
+static const WCHAR gifW[] = {'G','I','F',0};
+
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct wayland_data_device_format supported_formats[] =
+{
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
+    {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/rtf", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/richtext", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_hdrop, 0},
+    {"image/tiff", CF_TIFF, NULL, import_data, export_data, 0},
+    {"image/png", 0, pngW, import_data, export_data, 0},
+    {"image/jpeg", 0, jfifW, import_data, export_data, 0},
+    {"image/gif", 0, gifW, import_data, export_data, 0},
+    {NULL, 0, NULL, NULL, NULL, 0},
+};
+
+static ATOM register_clipboard_format(const WCHAR *name)
+{
+    ATOM atom;
+    if (NtAddAtom(name, lstrlenW(name) * sizeof(WCHAR), &atom)) return 0;
+    return atom;
+}
+
+void wayland_data_device_init_formats(void)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = register_clipboard_format(format->register_name);
+        format++;
+    }
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (!strcmp(mime, format->mime_type))
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
+
+static BOOL string_array_contains(struct wl_array *array, const char *str)
+{
+    char **p;
+
+    wl_array_for_each(p, array)
+        if (!strcmp(*p, str)) return TRUE;
+
+    return FALSE;
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                                   struct wl_array *mimes)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == clipboard_format &&
+            (!mimes || string_array_contains(mimes, format->mime_type)))
+        {
+             return format;
+        }
+        format++;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
new file mode 100644
index 00000000000..78c5185d5bf
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -0,0 +1,702 @@
+/*
+ * Wayland dmabuf buffers
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <drm_fourcc.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+enum dmabuf_dev_prio {
+    DMABUF_DEV_NODEV,
+    DMABUF_DEV_SCANOUT,
+    DMABUF_DEV_RENDER,
+    DMABUF_DEV_MAIN
+};
+
+/**********************************************************************
+ *          dmabuf private helpers
+ */
+
+static BOOL dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
+{
+    return dmabuf->version >= ZWP_LINUX_DMABUF_V1_GET_DEFAULT_FEEDBACK_SINCE_VERSION;
+}
+
+static int dmabuf_feedback_get_tranche_priority(struct wayland_dmabuf_feedback *feedback,
+                                                struct wayland_dmabuf_feedback_tranche *tranche,
+                                                dev_t render_dev)
+{
+    if (tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT)
+        return DMABUF_DEV_SCANOUT;
+    else if (tranche->device == render_dev)
+        return DMABUF_DEV_RENDER;
+    else if (tranche->device == feedback->main_device)
+        return DMABUF_DEV_MAIN;
+
+    return DMABUF_DEV_NODEV;
+}
+
+static BOOL dmabuf_format_has_modifier(struct wayland_dmabuf_format *format, uint64_t modifier)
+{
+    uint64_t *mod;
+
+    wl_array_for_each(mod, &format->modifiers)
+        if (*mod == modifier) return TRUE;
+
+    return FALSE;
+}
+
+static struct wayland_dmabuf_format *dmabuf_format_array_find_format(struct wl_array *formats,
+                                                                     uint32_t format)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+    BOOL format_found = FALSE;
+
+    wl_array_for_each(dmabuf_format, formats)
+    {
+        if (dmabuf_format->format == format)
+        {
+            format_found = TRUE;
+            break;
+        }
+    }
+
+    if (!format_found) dmabuf_format = NULL;
+
+    return dmabuf_format;
+}
+
+static struct wayland_dmabuf_format *dmabuf_feedback_get_format_from_optimal_tranche(struct wayland_dmabuf_feedback *feedback,
+                                                                                     uint32_t format,
+                                                                                     dev_t render_dev,
+                                                                                     struct wayland_dmabuf_feedback_tranche **out_tranche)
+{
+    struct wayland_dmabuf_format *dmabuf_format = NULL;
+    struct wayland_dmabuf_feedback_tranche *tranche;
+    int prio;
+
+    for (prio = DMABUF_DEV_SCANOUT; prio <= DMABUF_DEV_MAIN; prio++)
+    {
+        wl_array_for_each(tranche, &feedback->tranches)
+        {
+            if (prio == dmabuf_feedback_get_tranche_priority(feedback, tranche, render_dev) &&
+                (dmabuf_format = dmabuf_format_array_find_format(&tranche->formats, format)))
+                break;
+        }
+        if (dmabuf_format) break;
+    }
+
+    if (dmabuf_format && out_tranche) *out_tranche = tranche;
+
+    return dmabuf_format;
+}
+
+static size_t dmabuf_format_get_modifiers(struct wayland_dmabuf_format *dmabuf_format, uint64_t **modifiers)
+{
+    uint32_t num_modifiers = dmabuf_format->modifiers.size / sizeof(uint64_t);
+
+    if (num_modifiers == 1)
+    {
+        uint64_t *mod = (uint64_t *) dmabuf_format->modifiers.data;
+        if (*mod == DRM_FORMAT_MOD_INVALID) num_modifiers = 0;
+    }
+
+    if (num_modifiers > 0)
+        *modifiers = dmabuf_format->modifiers.data;
+    else
+        *modifiers = NULL;
+
+    return num_modifiers;
+}
+
+static BOOL dmabuf_format_array_add_format_modifier(struct wl_array *formats,
+                                                    uint32_t format,
+                                                    uint64_t modifier)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+    uint64_t *mod;
+
+    if ((dmabuf_format = dmabuf_format_array_find_format(formats, format)))
+    {
+        /* Avoid a possible duplicate, e.g., if compositor sends both format and
+         * modifier event with a DRM_FORMAT_MOD_INVALID. */
+        if (dmabuf_format_has_modifier(dmabuf_format, modifier))
+            goto out;
+    }
+    else
+    {
+        if (!(dmabuf_format = wl_array_add(formats, sizeof(*dmabuf_format))))
+            goto out;
+        dmabuf_format->format = format;
+        wl_array_init(&dmabuf_format->modifiers);
+    }
+
+    if (!(mod = wl_array_add(&dmabuf_format->modifiers, sizeof(uint64_t))))
+    {
+        dmabuf_format = NULL;
+        goto out;
+    }
+
+    *mod = modifier;
+
+out:
+    return dmabuf_format != NULL;
+}
+
+static void dmabuf_format_array_release(struct wl_array *formats)
+{
+    struct wayland_dmabuf_format *format;
+
+    wl_array_for_each(format, formats)
+        wl_array_release(&format->modifiers);
+
+    wl_array_release(formats);
+}
+
+static void dmabuf_feedback_tranche_init(struct wayland_dmabuf_feedback_tranche *tranche)
+{
+    memset(tranche, 0, sizeof(*tranche));
+    wl_array_init(&tranche->formats);
+}
+
+/* Moves src tranche to dst, and resets src. */
+static void dmabuf_feedback_tranche_move(struct wayland_dmabuf_feedback_tranche *dst,
+                                         struct wayland_dmabuf_feedback_tranche *src)
+{
+    memcpy(dst, src, sizeof(*dst));
+    dmabuf_feedback_tranche_init(src);
+}
+
+/**********************************************************************
+ *          zwp_linux_dmabuf_v1 handling
+ */
+
+static void dmabuf_format(void *data, struct zwp_linux_dmabuf_v1 *zwp_dmabuf, uint32_t format)
+{
+    struct wayland_dmabuf *dmabuf = data;
+
+    if (!dmabuf_format_array_add_format_modifier(&dmabuf->formats, format, DRM_FORMAT_MOD_INVALID))
+        WARN("Could not add format 0x%08x\n", format);
+}
+
+static void dmabuf_modifiers(void *data, struct zwp_linux_dmabuf_v1 *zwp_dmabuf, uint32_t format,
+                             uint32_t mod_hi, uint32_t mod_lo)
+{
+    struct wayland_dmabuf *dmabuf = data;
+    const uint64_t modifier = (uint64_t)mod_hi << 32 | mod_lo;
+
+    if (!dmabuf_format_array_add_format_modifier(&dmabuf->formats, format, modifier))
+        WARN("Could not add format/modifier 0x%08x/0x%" PRIx64 "\n", format, modifier);
+}
+
+static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
+    dmabuf_format,
+    dmabuf_modifiers
+};
+
+/**********************************************************************
+ *          default feedback handling
+ */
+
+static void dmabuf_feedback_main_device(void *data,
+                                        struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                        struct wl_array *device)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    if (device->size != sizeof(feedback->main_device))
+        return;
+
+    memcpy(&feedback->main_device, device->data, device->size);
+}
+
+static void dmabuf_feedback_format_table(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                         int32_t fd, uint32_t size)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    feedback->format_table_entries = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (feedback->format_table_entries == MAP_FAILED)
+    {
+        WARN("Failed to mmap format table entries. fd %d size %u.\n", fd, size);
+        feedback->format_table_entries = NULL;
+        close(fd);
+        return;
+    }
+
+    feedback->format_table_size = size;
+    close(fd);
+}
+
+static void dmabuf_feedback_tranche_target_device(void *data,
+                                                  struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                  struct wl_array *device)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    memcpy(&feedback->pending_tranche.device, device->data, sizeof(dev_t));
+}
+
+static void dmabuf_feedback_tranche_formats(void *data,
+                                            struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                            struct wl_array *indices)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+    struct wayland_dmabuf_feedback_format_table_entry *table_entries = feedback->format_table_entries;
+    uint16_t *index;
+
+    if (!table_entries)
+    {
+        WARN("Could not add formats/modifiers to tranche due to missing format table\n");
+        return;
+    }
+
+    wl_array_for_each(index, indices)
+    {
+        if (!dmabuf_format_array_add_format_modifier(&feedback->pending_tranche.formats,
+                                                     table_entries[*index].format,
+                                                     table_entries[*index].modifier))
+        {
+            WARN("Could not add format/modifier 0x%08x/0x%" PRIx64 "\n",
+                 table_entries[*index].format,
+                 table_entries[*index].modifier);
+        }
+    }
+}
+
+static void dmabuf_feedback_tranche_flags(void *data,
+                                          struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                          uint32_t flags)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    feedback->pending_tranche.flags = flags;
+}
+
+static void dmabuf_feedback_tranche_done(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+    struct wayland_dmabuf_feedback_tranche *tranche;
+
+    if (feedback->pending_tranche.formats.size == 0 ||
+        !(tranche = wl_array_add(&feedback->tranches, sizeof(*tranche))))
+    {
+        WARN("Failed to add tranche with target device %ju\n",
+             (uintmax_t)feedback->pending_tranche.device);
+        dmabuf_format_array_release(&feedback->pending_tranche.formats);
+        dmabuf_feedback_tranche_init(&feedback->pending_tranche);
+        return;
+    }
+    dmabuf_feedback_tranche_move(tranche, &feedback->pending_tranche);
+}
+
+static void dmabuf_feedback_done(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    /* ignore event */
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener dmabuf_feedback_listener =
+{
+    .main_device = dmabuf_feedback_main_device,
+    .format_table = dmabuf_feedback_format_table,
+    .tranche_target_device = dmabuf_feedback_tranche_target_device,
+    .tranche_formats = dmabuf_feedback_tranche_formats,
+    .tranche_flags = dmabuf_feedback_tranche_flags,
+    .tranche_done = dmabuf_feedback_tranche_done,
+    .done = dmabuf_feedback_done,
+};
+
+static void dmabuf_feedback_destroy(struct wayland_dmabuf_feedback *feedback)
+{
+    struct wayland_dmabuf_feedback_tranche *tranche;
+
+    dmabuf_format_array_release(&feedback->pending_tranche.formats);
+
+    wl_array_for_each(tranche, &feedback->tranches)
+        dmabuf_format_array_release(&tranche->formats);
+    wl_array_release(&feedback->tranches);
+
+    free(feedback);
+}
+
+static struct wayland_dmabuf_feedback *dmabuf_feedback_create(void)
+{
+    struct wayland_dmabuf_feedback *feedback;
+
+    feedback = calloc(1, sizeof(*feedback));
+    if (!feedback) return NULL;
+
+    wl_array_init(&feedback->tranches);
+    dmabuf_feedback_tranche_init(&feedback->pending_tranche);
+
+    return feedback;
+}
+
+/**********************************************************************
+ *          per-surface feedback handling
+ */
+
+static void surface_dmabuf_feedback_main_device(void *data,
+                                                struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                struct wl_array *device)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_main_device(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, device);
+}
+
+static void surface_dmabuf_feedback_format_table(void *data,
+                                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                 int32_t fd, uint32_t size)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_format_table(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, fd, size);
+}
+
+static void surface_dmabuf_feedback_tranche_target_device(void *data,
+                                                          struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                          struct wl_array *device)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_tranche_target_device(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, device);
+}
+
+static void surface_dmabuf_feedback_tranche_formats(void *data,
+                                                    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                    struct wl_array *indices)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    if (!surface_feedback->pending_feedback->format_table_entries &&
+        (!(surface_feedback->pending_feedback->format_table_entries = surface_feedback->feedback->format_table_entries)))
+    {
+        WARN("Could not add formats/modifiers to tranche due to missing format table\n");
+        return;
+    }
+    dmabuf_feedback_tranche_formats(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, indices);
+}
+
+static void surface_dmabuf_feedback_tranche_flags(void *data,
+                                                  struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                  uint32_t flags)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    surface_feedback->pending_feedback->pending_tranche.flags = flags;
+}
+
+static void surface_dmabuf_feedback_tranche_done(void *data,
+                                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_tranche_done(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1);
+}
+
+static void surface_dmabuf_feedback_done(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    if (!surface_feedback->pending_feedback->format_table_entries)
+    {
+        WARN("Invalid format table: Ignoring feedback events.\n");
+        dmabuf_feedback_destroy(surface_feedback->pending_feedback);
+        goto out;
+    }
+
+    wayland_dmabuf_surface_feedback_lock(surface_feedback);
+
+    if (surface_feedback->feedback)
+        dmabuf_feedback_destroy(surface_feedback->feedback);
+
+    surface_feedback->feedback = surface_feedback->pending_feedback;
+    surface_feedback->surface_needs_update = TRUE;
+
+    wayland_dmabuf_surface_feedback_unlock(surface_feedback);
+
+out:
+    surface_feedback->pending_feedback = dmabuf_feedback_create();
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener surface_dmabuf_feedback_listener =
+{
+    .main_device = surface_dmabuf_feedback_main_device,
+    .format_table = surface_dmabuf_feedback_format_table,
+    .tranche_target_device = surface_dmabuf_feedback_tranche_target_device,
+    .tranche_formats = surface_dmabuf_feedback_tranche_formats,
+    .tranche_flags = surface_dmabuf_feedback_tranche_flags,
+    .tranche_done = surface_dmabuf_feedback_tranche_done,
+    .done = surface_dmabuf_feedback_done,
+};
+
+/***********************************************************************
+ *           wayland_dmabuf_init
+ */
+void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
+                         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+    dmabuf->version = wl_proxy_get_version((struct wl_proxy *)zwp_linux_dmabuf_v1);
+    dmabuf->zwp_linux_dmabuf_v1 = zwp_linux_dmabuf_v1;
+    wl_array_init(&dmabuf->formats);
+
+    /* linux-dmabuf feedback events deprecate format/modifier events from
+     * previous versions. Listen to pre-v4 events only if v4 is not supported. */
+    if (dmabuf_has_feedback_support(dmabuf))
+    {
+        if (!(dmabuf->default_feedback = dmabuf_feedback_create()))
+        {
+            WARN("Could not create default dmabuf feedback: Memory allocation failure.\n");
+            return;
+        }
+        dmabuf->zwp_linux_dmabuf_feedback_v1 =
+            zwp_linux_dmabuf_v1_get_default_feedback(dmabuf->zwp_linux_dmabuf_v1);
+        zwp_linux_dmabuf_feedback_v1_add_listener(dmabuf->zwp_linux_dmabuf_feedback_v1,
+                                                  &dmabuf_feedback_listener,
+                                                  dmabuf->default_feedback);
+    }
+    else
+        zwp_linux_dmabuf_v1_add_listener(zwp_linux_dmabuf_v1, &dmabuf_listener, dmabuf);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_deinit
+ */
+void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
+{
+    if (dmabuf->zwp_linux_dmabuf_feedback_v1)
+    {
+        dmabuf_feedback_destroy(dmabuf->default_feedback);
+        zwp_linux_dmabuf_feedback_v1_destroy(dmabuf->zwp_linux_dmabuf_feedback_v1);
+    }
+
+    dmabuf_format_array_release(&dmabuf->formats);
+
+    if (dmabuf->zwp_linux_dmabuf_v1)
+        zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_feedback_get_format_info
+ */
+BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+{
+    struct wayland_dmabuf_feedback_tranche *tranche;
+    struct wayland_dmabuf_format *dmabuf_format =
+        dmabuf_feedback_get_format_from_optimal_tranche(feedback, drm_format, render_dev, &tranche);
+
+    if (!dmabuf_format) return FALSE;
+
+    format_info->scanoutable = tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT;
+    format_info->count_modifiers = dmabuf_format_get_modifiers(dmabuf_format, &format_info->modifiers);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_get_default_format_info
+ */
+BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
+                                            dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+
+    if (dmabuf_has_feedback_support(dmabuf))
+        return wayland_dmabuf_feedback_get_format_info(dmabuf->default_feedback, drm_format, render_dev, format_info);
+
+    dmabuf_format = dmabuf_format_array_find_format(&dmabuf->formats, drm_format);
+    if (!dmabuf_format) return FALSE;
+
+    format_info->scanoutable = FALSE;
+    format_info->count_modifiers = dmabuf_format_get_modifiers(dmabuf_format, &format_info->modifiers);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_has_feedback_support
+ */
+BOOL wayland_dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
+{
+    return dmabuf_has_feedback_support(dmabuf);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_is_format_supported
+ */
+BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev)
+{
+    if (dmabuf_has_feedback_support(dmabuf))
+        return dmabuf_feedback_get_format_from_optimal_tranche(dmabuf->default_feedback, format, render_dev, NULL) != NULL;
+
+    return dmabuf_format_array_find_format(&dmabuf->formats, format) != NULL;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_create
+ */
+struct wayland_dmabuf_surface_feedback *wayland_dmabuf_surface_feedback_create(struct wayland_dmabuf *dmabuf,
+                                                                               struct wl_surface *wl_surface)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = NULL;
+
+    if (!(surface_feedback = calloc(1, sizeof(*surface_feedback))) ||
+        !(surface_feedback->pending_feedback = dmabuf_feedback_create()))
+    {
+        WARN("Failed to create surface feedback: Memory allocation error.");
+        free(surface_feedback);
+        return NULL;
+    }
+
+    wayland_mutex_init(&surface_feedback->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_dmabuf_surface_feedback");
+
+    surface_feedback->zwp_linux_dmabuf_feedback_v1 =
+        zwp_linux_dmabuf_v1_get_surface_feedback(dmabuf->zwp_linux_dmabuf_v1, wl_surface);
+    zwp_linux_dmabuf_feedback_v1_add_listener(surface_feedback->zwp_linux_dmabuf_feedback_v1,
+                                              &surface_dmabuf_feedback_listener,
+                                              surface_feedback);
+
+    return surface_feedback;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_destroy
+ */
+void wayland_dmabuf_surface_feedback_destroy(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    if (surface_feedback->feedback)
+        dmabuf_feedback_destroy(surface_feedback->feedback);
+
+    dmabuf_feedback_destroy(surface_feedback->pending_feedback);
+    zwp_linux_dmabuf_feedback_v1_destroy(surface_feedback->zwp_linux_dmabuf_feedback_v1);
+    wayland_mutex_destroy(&surface_feedback->mutex);
+    free(surface_feedback);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_lock
+ */
+void wayland_dmabuf_surface_feedback_lock(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    if (surface_feedback) wayland_mutex_lock(&surface_feedback->mutex);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_unlock
+ */
+void wayland_dmabuf_surface_feedback_unlock(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    wayland_mutex_unlock(&surface_feedback->mutex);
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_from_native
+ *
+ * Creates a wayland dmabuf buffer from the specified native buffer.
+ */
+struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
+                                                                       struct wayland_native_buffer *native)
+{
+    struct wayland_dmabuf_buffer *dmabuf_buffer;
+    struct zwp_linux_buffer_params_v1 *params;
+    int i;
+
+    dmabuf_buffer = calloc(1, sizeof(*dmabuf_buffer));
+    if (!dmabuf_buffer)
+        goto err;
+
+    params = zwp_linux_dmabuf_v1_create_params(wayland->dmabuf.zwp_linux_dmabuf_v1);
+    for (i = 0; i < native->plane_count; i++)
+    {
+        zwp_linux_buffer_params_v1_add(params,
+                                       native->fds[i],
+                                       i,
+                                       native->offsets[i],
+                                       native->strides[i],
+                                       native->modifier >> 32,
+                                       native->modifier & 0xffffffff);
+    }
+
+    dmabuf_buffer->wl_buffer =
+        zwp_linux_buffer_params_v1_create_immed(params,
+                                                native->width,
+                                                native->height,
+                                                native->format,
+                                                0);
+
+    zwp_linux_buffer_params_v1_destroy(params);
+
+    return dmabuf_buffer;
+
+err:
+    if (dmabuf_buffer)
+        wayland_dmabuf_buffer_destroy(dmabuf_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_destroy
+ *
+ * Destroys a dmabuf buffer.
+ */
+void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer)
+{
+    TRACE("%p\n", dmabuf_buffer);
+
+    if (dmabuf_buffer->wl_buffer)
+        wl_buffer_destroy(dmabuf_buffer->wl_buffer);
+
+    free(dmabuf_buffer);
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a dmabuf buffer and destroy the dmabuf buffer.
+ */
+struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = dmabuf_buffer->wl_buffer;
+    dmabuf_buffer->wl_buffer = NULL;
+
+    wayland_dmabuf_buffer_destroy(dmabuf_buffer);
+
+    return wl_buffer;
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
new file mode 100644
index 00000000000..9ad0fce0052
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -0,0 +1,1387 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013 Alexandre Julliard
+ * Copyright 2015 Josh DuBois for CodeWeavers Inc.
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include "ntuser.h"
+
+#include <linux/input.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+/* xkb_keysym_t fixed maps from wayland_keyboard_layout.h. */
+extern const WORD xkb_keysym_0xff00_to_vkey[256];
+extern const WORD xkb_keysym_0xff00_to_scan[256];
+extern const WORD xkb_keysym_xfree86_to_vkey[256];
+extern const WORD xkb_keysym_xfree86_to_scan[256];
+
+static const struct
+{
+    DWORD       vkey;
+    const char *name;
+} vkey_names[] = {
+    { VK_ADD,                   "Num +" },
+    { VK_BACK,                  "Backspace" },
+    { VK_CAPITAL,               "Caps Lock" },
+    { VK_CONTROL,               "Ctrl" },
+    { VK_DECIMAL,               "Num Del" },
+    { VK_DELETE,                "Delete" },
+    { VK_DIVIDE,                "Num /" },
+    { VK_DOWN,                  "Down" },
+    { VK_END,                   "End" },
+    { VK_ESCAPE,                "Esc" },
+    { VK_F1,                    "F1" },
+    { VK_F2,                    "F2" },
+    { VK_F3,                    "F3" },
+    { VK_F4,                    "F4" },
+    { VK_F5,                    "F5" },
+    { VK_F6,                    "F6" },
+    { VK_F7,                    "F7" },
+    { VK_F8,                    "F8" },
+    { VK_F9,                    "F9" },
+    { VK_F10,                   "F10" },
+    { VK_F11,                   "F11" },
+    { VK_F12,                   "F12" },
+    { VK_F13,                   "F13" },
+    { VK_F14,                   "F14" },
+    { VK_F15,                   "F15" },
+    { VK_F16,                   "F16" },
+    { VK_F17,                   "F17" },
+    { VK_F18,                   "F18" },
+    { VK_F19,                   "F19" },
+    { VK_F20,                   "F20" },
+    { VK_F21,                   "F21" },
+    { VK_F22,                   "F22" },
+    { VK_F23,                   "F23" },
+    { VK_F24,                   "F24" },
+    { VK_HELP,                  "Help" },
+    { VK_HOME,                  "Home" },
+    { VK_INSERT,                "Insert" },
+    { VK_LCONTROL,              "Ctrl" },
+    { VK_LEFT,                  "Left" },
+    { VK_LMENU,                 "Alt" },
+    { VK_LSHIFT,                "Shift" },
+    { VK_LWIN,                  "Win" },
+    { VK_MENU,                  "Alt" },
+    { VK_MULTIPLY,              "Num *" },
+    { VK_NEXT,                  "Page Down" },
+    { VK_NUMLOCK,               "Num Lock" },
+    { VK_NUMPAD0,               "Num 0" },
+    { VK_NUMPAD1,               "Num 1" },
+    { VK_NUMPAD2,               "Num 2" },
+    { VK_NUMPAD3,               "Num 3" },
+    { VK_NUMPAD4,               "Num 4" },
+    { VK_NUMPAD5,               "Num 5" },
+    { VK_NUMPAD6,               "Num 6" },
+    { VK_NUMPAD7,               "Num 7" },
+    { VK_NUMPAD8,               "Num 8" },
+    { VK_NUMPAD9,               "Num 9" },
+    { VK_OEM_CLEAR,             "Num Clear" },
+    { VK_OEM_NEC_EQUAL,         "Num =" },
+    { VK_PRIOR,                 "Page Up" },
+    { VK_RCONTROL,              "Right Ctrl" },
+    { VK_RETURN,                "Return" },
+    { VK_RETURN,                "Num Enter" },
+    { VK_RIGHT,                 "Right" },
+    { VK_RMENU,                 "Right Alt" },
+    { VK_RSHIFT,                "Right Shift" },
+    { VK_RWIN,                  "Right Win" },
+    { VK_SEPARATOR,             "Num ," },
+    { VK_SHIFT,                 "Shift" },
+    { VK_SPACE,                 "Space" },
+    { VK_SUBTRACT,              "Num -" },
+    { VK_TAB,                   "Tab" },
+    { VK_UP,                    "Up" },
+    { VK_VOLUME_DOWN,           "Volume Down" },
+    { VK_VOLUME_MUTE,           "Mute" },
+    { VK_VOLUME_UP,             "Volume Up" },
+    { VK_OEM_MINUS,             "-" },
+    { VK_OEM_PLUS,              "=" },
+    { VK_OEM_1,                 ";" },
+    { VK_OEM_2,                 "/" },
+    { VK_OEM_3,                 "`" },
+    { VK_OEM_4,                 "[" },
+    { VK_OEM_5,                 "\\" },
+    { VK_OEM_6,                 "]" },
+    { VK_OEM_7,                 "'" },
+    { VK_OEM_COMMA,             "," },
+    { VK_OEM_PERIOD,            "." },
+};
+
+static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
+                                      xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode) ?
+           keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
+}
+
+static xkb_keycode_t scancode_to_xkb_keycode(struct wayland_keyboard *keyboard, WORD scan)
+{
+    UINT j;
+
+    if (scan == 0) return 0;
+
+    for (j = 0; j < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode); j++)
+        if (keyboard->xkb_keycode_to_scancode[j] == scan) return j;
+
+    return 0;
+}
+
+static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                 xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey) ?
+           keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
+}
+
+static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    xkb_keycode_t i, candidate = 0;
+
+    if (vkey == 0) return 0;
+
+    switch (vkey)
+    {
+    case VK_NUMPAD0: vkey = VK_INSERT; break;
+    case VK_NUMPAD1: vkey = VK_END; break;
+    case VK_NUMPAD2: vkey = VK_DOWN; break;
+    case VK_NUMPAD3: vkey = VK_NEXT; break;
+    case VK_NUMPAD4: vkey = VK_LEFT; break;
+    case VK_NUMPAD5: vkey = VK_CLEAR; break;
+    case VK_NUMPAD6: vkey = VK_RIGHT; break;
+    case VK_NUMPAD7: vkey = VK_HOME; break;
+    case VK_NUMPAD8: vkey = VK_UP; break;
+    case VK_NUMPAD9: vkey = VK_PRIOR; break;
+    case VK_DECIMAL: vkey = VK_DELETE; break;
+
+    case VK_INSERT: case VK_END: case VK_DOWN: case VK_NEXT:
+    case VK_LEFT: case VK_RIGHT: case VK_HOME: case VK_UP:
+    case VK_PRIOR: case VK_DELETE:
+        vkey |= 0xe000;
+        break;
+    default: break;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey); i++)
+    {
+        if (keyboard->xkb_keycode_to_vkey[i] == (vkey & 0xff))
+        {
+            candidate = i;
+            if ((keyboard->xkb_keycode_to_scancode[i] & 0xff00) == (vkey & 0xff00))
+                break;
+        }
+    }
+
+    return candidate;
+}
+
+static WORD vkey_to_scancode_fixed(UINT vkey)
+{
+    int i;
+    WORD scan = 0;
+
+    if (vkey == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_vkey[i] == vkey &&
+            xkb_keysym_0xff00_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_0xff00_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_vkey[i] == vkey &&
+            xkb_keysym_xfree86_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_xfree86_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+out:
+    return scan;
+}
+
+static WORD vkey_to_scancode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WORD scan = _xkb_keycode_to_scancode(keyboard, vkey_to_xkb_keycode(keyboard, vkey));
+    if (!scan || ((scan & 0xff00) != (vkey & 0xff00))) scan = vkey_to_scancode_fixed(vkey);
+    return scan;
+}
+
+static WORD scancode_to_vkey_fixed(UINT scan)
+{
+    int i;
+
+    if (scan == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_scan[i] == scan &&
+            xkb_keysym_0xff00_to_vkey[i] != 0)
+        {
+            return xkb_keysym_0xff00_to_vkey[i];
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_scan[i] == scan &&
+            xkb_keysym_xfree86_to_vkey[i] != 0)
+        {
+            return xkb_keysym_xfree86_to_vkey[i];
+        }
+    }
+
+    return 0;
+}
+
+static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
+    if (!vkey) vkey = scancode_to_vkey_fixed(scan);
+    return vkey;
+}
+
+static const char* vkey_to_name(UINT vkey)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(vkey_names); j++)
+        if (vkey_names[j].vkey == vkey)
+            return vkey_names[j].name;
+
+    return NULL;
+}
+
+/* xkb keycodes are offset by 8 from linux input keycodes. */
+static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
+{
+    return key + 8;
+}
+
+static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
+{
+    INPUT input;
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input(hwnd, &input, NULL);
+}
+
+static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
+{
+    switch (xkb_keysym)
+    {
+    case XKB_KEY_dead_grave: return 0x0060;
+    case XKB_KEY_dead_acute: return 0x00B4;
+    case XKB_KEY_dead_circumflex: return 0x005E;
+    case XKB_KEY_dead_tilde: return 0x007E;
+    case XKB_KEY_dead_macron: return 0x00AF;
+    case XKB_KEY_dead_breve: return 0x02D8;
+    case XKB_KEY_dead_abovedot: return 0x02D9;
+    case XKB_KEY_dead_diaeresis: return 0x00A8;
+    case XKB_KEY_dead_abovering: return 0x02DA;
+    case XKB_KEY_dead_doubleacute: return 0x02DD;
+    case XKB_KEY_dead_caron: return 0x02C7;
+    case XKB_KEY_dead_cedilla: return 0x00B8;
+    case XKB_KEY_dead_ogonek: return 0x02DB;
+    case XKB_KEY_dead_iota: return 0x037A;
+    case XKB_KEY_dead_voiced_sound: return 0x309B;
+    case XKB_KEY_dead_semivoiced_sound: return 0x309C;
+    case XKB_KEY_dead_belowdot: return 0x002E;
+    case XKB_KEY_dead_stroke: return 0x002D;
+    case XKB_KEY_dead_abovecomma: return 0x1FBF;
+    case XKB_KEY_dead_abovereversedcomma: return 0x1FFE;
+    case XKB_KEY_dead_doublegrave: return 0x02F5;
+    case XKB_KEY_dead_belowring: return 0x02F3;
+    case XKB_KEY_dead_belowmacron: return 0x02CD;
+    case XKB_KEY_dead_belowtilde: return 0x02F7;
+    case XKB_KEY_dead_currency: return 0x00A4;
+    case XKB_KEY_dead_lowline: return 0x005F;
+    case XKB_KEY_dead_aboveverticalline: return 0x02C8;
+    case XKB_KEY_dead_belowverticalline: return 0x02CC;
+    case XKB_KEY_dead_longsolidusoverlay: return 0x002F;
+    case XKB_KEY_dead_a: return 0x0061;
+    case XKB_KEY_dead_A: return 0x0041;
+    case XKB_KEY_dead_e: return 0x0065;
+    case XKB_KEY_dead_E: return 0x0045;
+    case XKB_KEY_dead_i: return 0x0069;
+    case XKB_KEY_dead_I: return 0x0049;
+    case XKB_KEY_dead_o: return 0x006F;
+    case XKB_KEY_dead_O: return 0x004F;
+    case XKB_KEY_dead_u: return 0x0075;
+    case XKB_KEY_dead_U: return 0x0055;
+    case XKB_KEY_dead_small_schwa: return 0x0259;
+    case XKB_KEY_dead_capital_schwa: return 0x018F;
+    /* The following are non-spacing characters, couldn't find good
+     * spacing alternatives. */
+    case XKB_KEY_dead_hook: return 0x0309;
+    case XKB_KEY_dead_horn: return 0x031B;
+    case XKB_KEY_dead_belowcircumflex: return 0x032D;
+    case XKB_KEY_dead_belowbreve: return 0x032E;
+    case XKB_KEY_dead_belowdiaeresis: return 0x0324;
+    case XKB_KEY_dead_invertedbreve: return 0x0311;
+    case XKB_KEY_dead_belowcomma: return 0x0326;
+    default: return 0;
+    }
+}
+
+static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
+{
+    char utf8[64];
+    int utf8_len;
+    WCHAR wchars[8];
+    DWORD wbytes;
+
+    /* Windows doesn't emit a character for Delete. */
+    if (nsyms == 1 && syms[0] == XKB_KEY_Delete) return 0;
+
+    utf8_len = _xkb_keysyms_to_utf8(syms, nsyms, utf8, sizeof(utf8));
+
+    if (RtlUTF8ToUnicodeN(wchars, sizeof(wchars), &wbytes, utf8, utf8_len))
+        return 0;
+
+    /* TODO: normalize the keysym unicode representation. */
+
+    return wbytes >= 2 ? wchars[0] : 0;
+}
+
+static SHORT _xkb_mod_mask_to_win32(struct xkb_keymap *xkb_keymap,
+                                    xkb_mod_mask_t mod_mask)
+{
+    xkb_mod_index_t num_mods, i;
+    SHORT ret = 0;
+
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (mod_mask & (1 << i))
+        {
+            const char *mod_name = xkb_keymap_mod_get_name(xkb_keymap, i);
+
+            if (!strcmp(mod_name, XKB_MOD_NAME_SHIFT))
+                ret |= 0x0100;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_CTRL))
+                ret |= 0x0200;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_ALT))
+                ret |= 0x0400;
+        }
+    }
+
+    return ret;
+}
+
+static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
+{
+    switch (xkb_keycode - 8)
+    {
+    case KEY_KP0: case KEY_KP1: case KEY_KP2: case KEY_KP3:
+    case KEY_KP4: case KEY_KP5: case KEY_KP6: case KEY_KP7:
+    case KEY_KP8: case KEY_KP9: case KEY_KPDOT:
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
+/* Get the vkey corresponding to an xkb keycode, potentially translating it to
+ * take into account the current keyboard state. */
+static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                          xkb_keycode_t xkb_keycode)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    if (_xkb_keycode_is_keypad_num(xkb_keycode) &&
+        xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                     XKB_STATE_MODS_EFFECTIVE))
+    {
+        switch (vkey)
+        {
+        case VK_INSERT: vkey = VK_NUMPAD0; break;
+        case VK_END: vkey = VK_NUMPAD1; break;
+        case VK_DOWN: vkey = VK_NUMPAD2; break;
+        case VK_NEXT: vkey = VK_NUMPAD3; break;
+        case VK_LEFT: vkey = VK_NUMPAD4; break;
+        case VK_CLEAR: vkey = VK_NUMPAD5; break;
+        case VK_RIGHT: vkey = VK_NUMPAD6; break;
+        case VK_HOME: vkey = VK_NUMPAD7; break;
+        case VK_UP: vkey = VK_NUMPAD8; break;
+        case VK_PRIOR: vkey = VK_NUMPAD9; break;
+        case VK_DELETE: vkey = VK_DECIMAL; break;
+        default: break;
+        }
+    }
+    else if (vkey == VK_PAUSE &&
+             xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                          XKB_MOD_NAME_CTRL,
+                                          XKB_STATE_MODS_EFFECTIVE))
+    {
+        vkey = VK_CANCEL;
+    }
+
+    return vkey;
+}
+
+static UINT map_vkey_to_wchar_with_deadchar_bit(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    UINT wchar;
+    xkb_keycode_t xkb_keycode;
+    struct xkb_keymap *xkb_keymap;
+    xkb_layout_index_t layout;
+    const xkb_keysym_t *syms;
+    int nsyms;
+    int level;
+
+    if (!keyboard->xkb_state) return 0;
+
+    /* Windows seems to handle alphabetical vkeys codes specially, not taking
+     * the layout into account. */
+    if (vkey >= 'A' && vkey <= 'Z') return vkey;
+
+    layout = _xkb_state_get_active_layout(keyboard->xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("no active layout, returning wchar 0\n");
+        return 0;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(keyboard->xkb_state);
+    xkb_keycode = vkey_to_xkb_keycode(keyboard, vkey);
+
+    /* Use level 1 (i.e., numlock) for numpad keys. */
+    level = ((vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9) || vkey == VK_DECIMAL) ? 1 : 0;
+
+    nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                             layout, level, &syms);
+    if (nsyms > 0)
+    {
+        /* Set the high bit to 1 if this is dead char. */
+        if ((wchar = dead_xkb_keysym_to_wchar(syms[0])))
+            wchar |= 0x80000000;
+        else
+            wchar = _xkb_keysyms_to_wchar(syms, nsyms);
+    }
+    else
+    {
+        wchar = 0;
+    }
+
+    TRACE_(key)("vkey=0x%x xkb_keycode=%d nsyms=%d xkb_keysym[0]=0x%x => wchar=0x%x\n",
+                vkey, xkb_keycode, nsyms, nsyms ? syms[0] : 0, wchar);
+
+    return wchar;
+}
+
+static BOOL wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
+                                  uint32_t state, HWND hwnd)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+    UINT scan = _xkb_keycode_to_scancode(keyboard, xkb_keycode);
+    DWORD flags;
+
+    TRACE_(key)("xkb_keycode=%u vkey=0x%x scan=0x%x state=%d hwnd=%p\n",
+                xkb_keycode, vkey, scan, state, hwnd);
+
+    if (vkey == 0) return FALSE;
+
+    flags = 0;
+    if (state == WL_KEYBOARD_KEY_STATE_RELEASED) flags |= KEYEVENTF_KEYUP;
+    if (scan & 0xff00) flags |= KEYEVENTF_EXTENDEDKEY;
+
+    send_keyboard_input(hwnd, vkey, scan & 0xff, flags);
+
+    return TRUE;
+}
+
+static struct xkb_state *_xkb_state_new_from_wine(struct wayland_keyboard *keyboard,
+                                                  const BYTE *keystate)
+{
+    struct xkb_state *xkb_state;
+    UINT mods[] = {VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU};
+    UINT toggles[] = {VK_CAPITAL, VK_NUMLOCK, VK_SCROLL};
+    xkb_mod_mask_t depressed_mods, latched_mods, locked_mods;
+    int i;
+
+    /* Create a new xkb_state using the currently active layout and the state
+     * of Mod5 (AltGr) only. */
+    xkb_state = xkb_state_new(xkb_state_get_keymap(keyboard->xkb_state));
+    if (!xkb_state) return NULL;
+    depressed_mods = xkb_state_serialize_mods(keyboard->xkb_state,
+                                             XKB_STATE_MODS_DEPRESSED) &
+                     keyboard->xkb_mod5_mask;
+    latched_mods = xkb_state_serialize_mods(keyboard->xkb_state,
+                                           XKB_STATE_MODS_LATCHED) &
+                   keyboard->xkb_mod5_mask;
+    locked_mods = xkb_state_serialize_mods(keyboard->xkb_state,
+                                          XKB_STATE_MODS_LOCKED) &
+                  keyboard->xkb_mod5_mask;
+    xkb_state_update_mask(xkb_state, depressed_mods, latched_mods, locked_mods,
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_DEPRESSED),
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_LATCHED),
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_LOCKED));
+
+    /* Update the xkb_state from the windows keyboard state by simulating
+     * keypresses. */
+    for (i = 0 ; i < ARRAY_SIZE(mods); i++)
+    {
+        if ((keystate[mods[i]] & 0x80))
+        {
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, mods[i]),
+                                 XKB_KEY_DOWN);
+        }
+    }
+
+    for (i = 0 ; i < ARRAY_SIZE(toggles); i++)
+    {
+        if ((keystate[toggles[i]] & 0x01))
+        {
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, toggles[i]),
+                                 XKB_KEY_DOWN);
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, toggles[i]),
+                                 XKB_KEY_UP);
+
+        }
+    }
+
+    return xkb_state;
+}
+
+static BOOL get_wine_async_key_state(BYTE state[256])
+{
+    BOOL ret;
+
+    SERVER_START_REQ(get_key_state)
+    {
+        req->async = 1;
+        req->key = -1;
+        wine_server_set_reply(req, state, 256);
+        ret = !wine_server_call(req);
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+static void set_wine_async_key_state(const BYTE state[256])
+{
+    SERVER_START_REQ(set_key_state)
+    {
+        req->async = 1;
+        wine_server_add_data(req, state, 256);
+        wine_server_call(req);
+    }
+    SERVER_END_REQ;
+}
+
+static void update_wine_key_state(BYTE *keystate, WORD vkey, int down, int lock)
+{
+    BYTE old_state = keystate[vkey];
+
+    if (down == 1) keystate[vkey] |= 0x80;
+    else if (down == 0) keystate[vkey] &= ~0x80;
+
+    if (lock == 1) keystate[vkey] |= 0x01;
+    else if (lock == 0) keystate[vkey] &= ~0x01;
+
+    if (TRACE_ON(keyboard) && keystate[vkey] != old_state)
+    {
+        TRACE("vkey=%s down=%d lock=%d state=0x%02x=>0x%02x\n",
+              vkey_to_name(vkey), down, lock, old_state, keystate[vkey]);
+    }
+}
+
+static void update_wine_lock_state(struct wayland_keyboard *keyboard)
+{
+    BYTE keystate[256];
+    struct { const char *modname; WORD vkeys[3]; } mods[] = {
+        { XKB_MOD_NAME_ALT,   { VK_MENU, VK_LMENU, VK_RMENU } },
+        { XKB_MOD_NAME_CTRL,  { VK_CONTROL, VK_LCONTROL, VK_RCONTROL } },
+        { XKB_MOD_NAME_SHIFT, { VK_SHIFT, VK_LSHIFT, VK_RSHIFT } },
+        { XKB_MOD_NAME_CAPS,  { VK_CAPITAL } },
+        { XKB_MOD_NAME_NUM,   { VK_NUMLOCK } },
+    };
+
+    if (!get_wine_async_key_state(keystate)) return;
+
+    for (int i = 0; i < ARRAY_SIZE(mods); i++)
+    {
+        WORD *vkey;
+        BOOL locked = xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                                   mods[i].modname,
+                                                   XKB_STATE_MODS_LOCKED);
+
+        for (vkey = mods[i].vkeys; *vkey; vkey++)
+            update_wine_key_state(keystate, *vkey, -1, locked);
+    }
+
+    update_wine_key_state(keystate, VK_SCROLL, -1,
+                          xkb_state_led_name_is_active(keyboard->xkb_state,
+                                                       XKB_LED_NAME_SCROLL));
+
+    set_wine_async_key_state(keystate);
+}
+
+static void update_wine_pressed_state(struct wayland_keyboard *keyboard,
+                                      struct wl_array *pressed_keys)
+{
+    uint32_t *key;
+    BYTE keystate[256];
+    int pressed[256] = { 0 };
+
+    if (!get_wine_async_key_state(keystate)) return;
+
+    wl_array_for_each(key, pressed_keys)					\
+    {
+        xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(*key);
+        UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+        pressed[vkey & 0xff] = 1;
+    }
+
+    for (WORD vkey = 0; vkey < 256; vkey++)
+        update_wine_key_state(keystate, vkey, pressed[vkey], -1);
+
+    /* Update special left/right-agnostic vkeys */
+    update_wine_key_state(keystate, VK_CONTROL,
+                          (keystate[VK_LCONTROL] | keystate[VK_RCONTROL]) & 0x80, -1);
+    update_wine_key_state(keystate, VK_MENU,
+                          (keystate[VK_LMENU] | keystate[VK_RMENU]) & 0x80, -1);
+    update_wine_key_state(keystate, VK_SHIFT,
+                          (keystate[VK_LSHIFT] | keystate[VK_RSHIFT]) & 0x80, -1);
+
+    set_wine_async_key_state(keystate);
+}
+
+/**********************************************************************
+ *          Keyboard handling
+ */
+
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                                   uint32_t format, int fd, uint32_t size)
+{
+    struct wayland *wayland = data;
+    struct xkb_keymap *xkb_keymap = NULL;
+    struct xkb_state *xkb_state = NULL;
+    char *keymap_str;
+    xkb_mod_index_t i, num_mods;
+
+    TRACE("format=%d fd=%d size=%d\n", format, fd, size);
+
+    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 ||
+        !wayland->keyboard.xkb_context)
+        goto out;
+
+    keymap_str = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (keymap_str == MAP_FAILED)
+        goto out;
+
+    xkb_keymap = xkb_keymap_new_from_string(wayland->keyboard.xkb_context,
+                                            keymap_str,
+                                            XKB_KEYMAP_FORMAT_TEXT_V1,
+                                            0);
+    munmap(keymap_str, size);
+    if (!xkb_keymap)
+        goto out;
+
+    /* Find the Mod5 (i.e., AltGr) mask */
+    wayland->keyboard.xkb_mod5_mask = 0;
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (!strcmp(xkb_keymap_mod_get_name(xkb_keymap, i), "Mod5"))
+        {
+            wayland->keyboard.xkb_mod5_mask = (1 << i);
+            break;
+        }
+    }
+
+    xkb_state = xkb_state_new(xkb_keymap);
+    xkb_keymap_unref(xkb_keymap);
+    if (!xkb_state)
+        goto out;
+
+    xkb_state_unref(wayland->keyboard.xkb_state);
+    wayland->keyboard.xkb_state = xkb_state;
+    if (wayland->keyboard.xkb_compose_state)
+        xkb_compose_state_reset(wayland->keyboard.xkb_compose_state);
+
+    wayland_keyboard_update_layout(&wayland->keyboard);
+
+out:
+    close(fd);
+}
+
+static BOOL wayland_surface_for_window_is_mapped(HWND hwnd)
+{
+    DWORD_PTR res;
+
+    if (!send_message_timeout(hwnd, WM_WAYLAND_QUERY_SURFACE_MAPPED,
+                              0, 0, SMTO_BLOCK, 50, &res))
+    {
+        return FALSE;
+    }
+
+    return res;
+}
+
+static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                                  uint32_t serial, struct wl_surface *surface,
+                                  struct wl_array *keys)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since keyboard events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        HWND foreground = NtUserGetForegroundWindow();
+        BOOL foreground_is_visible;
+        BOOL foreground_is_mapped;
+
+        if (foreground == NtUserGetDesktopWindow()) foreground = NULL;
+        if (foreground)
+        {
+            foreground_is_visible =
+                !!(NtUserGetWindowLongW(foreground, GWL_STYLE) & WS_VISIBLE);
+            foreground_is_mapped = wayland_surface_for_window_is_mapped(foreground);
+        }
+        else
+        {
+            foreground_is_visible = FALSE;
+            foreground_is_mapped = FALSE;
+        }
+
+        TRACE("surface=%p hwnd=%p foreground=%p visible=%d mapped=%d\n",
+              wayland_surface, wayland_surface->hwnd, foreground,
+              foreground_is_visible, foreground_is_mapped);
+
+        wayland->keyboard.focused_surface = wayland_surface;
+        wayland->keyboard.enter_serial = serial;
+
+        /* Promote the just entered window to the foreground unless we have a
+         * existing visible foreground window that is not mapped from the
+         * Wayland perspective. In that case the surface may not have had the
+         * chance to acquire the keyboard focus and if we change the foreground
+         * window now, we may cause side effects, e.g., some fullscreen games
+         * minimize if they lose focus. To avoid such side effects, err on the
+         * side of maintaining the Wine foreground state, with the expectation
+         * that the current foreground window will eventually also gain the
+         * Wayland keyboard focus. */
+        if (!foreground || !foreground_is_visible || foreground_is_mapped)
+        {
+            struct wayland_surface *toplevel = wayland_surface;
+            while (toplevel->parent) toplevel = toplevel->parent;
+
+            if (NtUserGetWindowLongW(toplevel->hwnd, GWL_STYLE) & WS_MINIMIZE)
+            {
+                /* If a minimized window is already activated from Wine's
+                 * perspective, reactivating it is a null operation, and thus
+                 * won't trigger any activation side-effects (e.g., many games
+                 * change the display mode when they are activated). In order
+                 * to get those effects properly applied, deactivate the window
+                 * now, so it can be properly reactivated after restoration. */
+                if (foreground == toplevel->hwnd)
+                    NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+                NtUserShowWindow(toplevel->hwnd, SW_RESTORE);
+                NtUserShowOwnedPopups(toplevel->hwnd, TRUE);
+            }
+
+            NtUserSetForegroundWindow(toplevel->hwnd);
+        }
+
+        update_wine_pressed_state(&wayland->keyboard, keys);
+    }
+}
+
+static void maybe_unset_from_foreground(void *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND hwnd = (HWND)data;
+
+    TRACE("wayland=%p hwnd=%p\n", wayland, hwnd);
+
+    /* If no enter events have arrived since the previous leave event,
+     * the loss of focus was likely not transient, so drop the foreground state.
+     * We only drop the foreground state if it's ours to drop, i.e., some
+     * other window hasn't become foreground in the meantime. */
+    if (!wayland->keyboard.focused_surface && NtUserGetForegroundWindow() == hwnd)
+        NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+}
+
+static void keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+        uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *focused_surface = wayland->keyboard.focused_surface;
+
+    if (focused_surface && focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n", focused_surface, focused_surface->hwnd);
+        wayland_cancel_thread_callback((uintptr_t)keyboard);
+        /* This leave event may not signify a real loss of focus for the
+         * window. Such a case occurs when the focus changes from the main
+         * surface to a subsurface. Don't be too eager to lose the foreground
+         * state in such cases, as some fullscreen applications may become
+         * minimized. Instead wait a bit in case other enter events targeting a
+         * (sub)surface of the same HWND arrive soon after. */
+        wayland_schedule_thread_callback((uintptr_t)&wayland->keyboard.focused_surface,
+                                         50, maybe_unset_from_foreground,
+                                         focused_surface->hwnd);
+        wayland->keyboard.focused_surface = NULL;
+        wayland->keyboard.enter_serial = 0;
+    }
+}
+
+static void repeat_key(void *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND hwnd = data;
+
+    if (wayland->keyboard.repeat_interval_ms > 0)
+    {
+        wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+        wayland->last_event_type = INPUT_KEYBOARD;
+
+        wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.last_pressed_key,
+                              WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
+
+        wayland_schedule_thread_callback((uintptr_t)wayland->keyboard.wl_keyboard,
+                                         wayland->keyboard.repeat_interval_ms,
+                                         repeat_key, hwnd);
+    }
+}
+
+static BOOL wayland_keyboard_is_modifier_key(struct wayland_keyboard *keyboard,
+                                             uint32_t key)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    return vkey == VK_CAPITAL || vkey == VK_LWIN || vkey == VK_RWIN ||
+           vkey == VK_NUMLOCK || vkey == VK_SCROLL ||
+           vkey == VK_LSHIFT || vkey == VK_RSHIFT ||
+           vkey == VK_LCONTROL || vkey == VK_RCONTROL ||
+           vkey == VK_LMENU || vkey == VK_RMENU;
+}
+
+static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->keyboard.focused_surface ?
+                        wayland->keyboard.focused_surface->hwnd : 0;
+    uintptr_t repeat_key_timer_id = (uintptr_t)keyboard;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
+
+    wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+    wayland->last_event_type = INPUT_KEYBOARD;
+
+    if (!wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd))
+        return;
+
+    /* Do not repeat modifier keys. */
+    if (wayland_keyboard_is_modifier_key(&wayland->keyboard, key))
+        return;
+
+    if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+    {
+        wayland->keyboard.last_pressed_key = key;
+        if (wayland->keyboard.repeat_interval_ms > 0)
+        {
+            wayland_schedule_thread_callback(repeat_key_timer_id,
+                                             wayland->keyboard.repeat_delay_ms,
+                                             repeat_key, focused_hwnd);
+        }
+    }
+    else if (key == wayland->keyboard.last_pressed_key)
+    {
+        wayland->keyboard.last_pressed_key = 0;
+        wayland_cancel_thread_callback(repeat_key_timer_id);
+    }
+}
+
+static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched, uint32_t mods_locked,
+                                      uint32_t group)
+{
+    struct wayland *wayland = data;
+    uint32_t last_group;
+
+    TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
+          mods_depressed, mods_latched, mods_locked, group);
+
+    if (!wayland->keyboard.xkb_state) return;
+
+    last_group = _xkb_state_get_active_layout(wayland->keyboard.xkb_state);
+
+    xkb_state_update_mask(wayland->keyboard.xkb_state,
+                          mods_depressed, mods_latched, mods_locked, 0, 0, group);
+
+    if (group != last_group)
+        wayland_keyboard_update_layout(&wayland->keyboard);
+
+    /* Update the wine lock key state, in case the XKB modifier state is set
+     * without previously sending the associated key events (e.g., while another
+     * window has the focus). */
+    update_wine_lock_state(&wayland->keyboard);
+}
+
+static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
+                                        int rate, int delay)
+{
+    struct wayland *wayland = data;
+
+    TRACE("rate=%d delay=%d\n", rate, delay);
+
+    /* Handle non-negative rate values, ignore invalid (negative) values.  A
+     * rate of 0 disables repeat. */
+    if (rate > 1000)
+        wayland->keyboard.repeat_interval_ms = 1;
+    else if (rate > 0)
+        wayland->keyboard.repeat_interval_ms = 1000 / rate;
+    else if (rate == 0)
+        wayland->keyboard.repeat_interval_ms = 0;
+
+    wayland->keyboard.repeat_delay_ms = delay;
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+/***********************************************************************
+ *           wayland_keyboard_init
+ */
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard)
+{
+    struct xkb_compose_table *compose_table;
+    const char *locale;
+
+    locale = getenv("LC_ALL");
+    if (!locale || !*locale)
+        locale = getenv("LC_CTYPE");
+    if (!locale || !*locale)
+        locale = getenv("LANG");
+    if (!locale || !*locale)
+        locale = "C";
+
+    keyboard->wl_keyboard = wl_keyboard;
+    /* Some sensible default values for the repeat rate and delay. */
+    keyboard->repeat_interval_ms = 40;
+    keyboard->repeat_delay_ms = 400;
+    keyboard->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (!keyboard->xkb_context)
+    {
+        ERR("Failed to create XKB context\n");
+        return;
+    }
+    compose_table =
+        xkb_compose_table_new_from_locale(keyboard->xkb_context, locale,
+                                          XKB_COMPOSE_COMPILE_NO_FLAGS);
+    if (!compose_table)
+    {
+        ERR("Failed to create XKB compose table\n");
+        return;
+    }
+
+    keyboard->xkb_compose_state =
+        xkb_compose_state_new(compose_table, XKB_COMPOSE_STATE_NO_FLAGS);
+    xkb_compose_table_unref(compose_table);
+    if (!keyboard->xkb_compose_state)
+        ERR("Failed to create XKB compose table\n");
+
+    wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
+}
+
+/***********************************************************************
+ *           wayland_keyboard_deinit
+ */
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
+{
+    if (keyboard->wl_keyboard)
+        wl_keyboard_destroy(keyboard->wl_keyboard);
+
+    xkb_compose_state_unref(keyboard->xkb_compose_state);
+    xkb_state_unref(keyboard->xkb_state);
+    xkb_context_unref(keyboard->xkb_context);
+
+    memset(keyboard, 0, sizeof(*keyboard));
+}
+
+/***********************************************************************
+ *           WAYLAND_ToUnicodeEx
+ */
+INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                        LPWSTR buf, int nchars, UINT flags, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    char utf8[64];
+    int utf8_len = 0;
+    struct xkb_compose_state *compose_state = wayland->keyboard.xkb_compose_state;
+    enum xkb_compose_status compose_status = XKB_COMPOSE_NOTHING;
+    xkb_keycode_t xkb_keycode;
+    xkb_keysym_t xkb_keysym;
+    struct xkb_state *xkb_state;
+    INT ret;
+
+    if (!wayland->keyboard.xkb_state) return 0;
+
+    if (scan & 0x8000) return 0;  /* key up */
+
+    xkb_keycode = vkey_to_xkb_keycode(&wayland->keyboard, virt);
+    xkb_state = _xkb_state_new_from_wine(&wayland->keyboard, state);
+    if (!xkb_state) return 0;
+
+    /* Try to compose */
+    xkb_keysym = xkb_state_key_get_one_sym(xkb_state, xkb_keycode);
+    if (xkb_keysym != XKB_KEY_NoSymbol && compose_state &&
+        xkb_compose_state_feed(compose_state, xkb_keysym) == XKB_COMPOSE_FEED_ACCEPTED)
+    {
+        compose_status = xkb_compose_state_get_status(compose_state);
+    }
+
+    TRACE_(key)("vkey=0x%x scan=0x%x xkb_keycode=%d xkb_keysym=0x%x compose_status=%d\n",
+                virt, scan, xkb_keycode, xkb_keysym, compose_status);
+
+    if (compose_status == XKB_COMPOSE_NOTHING)
+    {
+        /* Windows converts some Ctrl modified key combinations to strings in a
+         * way different from Linux/xkbcommon (or doesn't convert them at all).
+         * Handle such combinations manually here. */
+        if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_CTRL,
+                                         XKB_STATE_MODS_EFFECTIVE))
+        {
+            if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_ALT,
+                                             XKB_STATE_MODS_EFFECTIVE))
+            {
+                ret = 0;
+                goto out;
+            }
+            if (((xkb_keysym >= XKB_KEY_exclam) && (xkb_keysym < XKB_KEY_at)) ||
+                (xkb_keysym == XKB_KEY_grave) || (xkb_keysym == XKB_KEY_Tab))
+            {
+                ret = 0;
+                goto out;
+            }
+            if (xkb_keysym == XKB_KEY_Return)
+            {
+                if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_SHIFT,
+                                                 XKB_STATE_MODS_EFFECTIVE))
+                {
+                    ret = 0;
+                }
+                else
+                {
+                    buf[0] = '\n';
+                    ret = 1;
+                }
+                goto out;
+            }
+            if (xkb_keysym == XKB_KEY_space)
+            {
+                buf[0] = ' ';
+                ret = 1;
+                goto out;
+            }
+        }
+
+        utf8_len = xkb_state_key_get_utf8(xkb_state, xkb_keycode, utf8, sizeof(utf8));
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSED)
+    {
+        utf8_len = xkb_compose_state_get_utf8(compose_state, utf8, sizeof(utf8));
+        TRACE_(key)("composed\n");
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSING && nchars > 0)
+    {
+        if ((buf[0] = dead_xkb_keysym_to_wchar(xkb_keysym)))
+        {
+            TRACE_(key)("returning dead char 0x%04x\n", buf[0]);
+            buf[1] = 0;
+            ret = -1;
+            goto out;
+        }
+    }
+
+    TRACE_(key)("utf8 len=%d '%s'\n", utf8_len, utf8_len ? utf8 : "");
+
+    if (RtlUTF8ToUnicodeN(buf, nchars, (DWORD *)&ret, utf8, utf8_len)) ret = 0;
+    else ret /= sizeof(WCHAR);
+
+out:
+    /* Zero terminate the returned string. */
+    if (ret >= 0 && ret < nchars) buf[ret] = 0;
+    xkb_state_unref(xkb_state);
+    return ret;
+}
+
+/***********************************************************************
+ *           GetKeyNameText
+ */
+INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+{
+    struct wayland *wayland = thread_init_wayland();
+    int scan, vkey, len;
+    const char *name;
+    char key[2];
+
+    scan = (lparam >> 16) & 0x1FF;
+    vkey = scancode_to_vkey(&wayland->keyboard, scan);
+
+    if (lparam & (1 << 25))
+    {
+        /* Caller doesn't care about distinctions between left and
+           right keys. */
+        switch (vkey)
+        {
+        case VK_LSHIFT:
+        case VK_RSHIFT:
+            vkey = VK_SHIFT; break;
+        case VK_LCONTROL:
+        case VK_RCONTROL:
+            vkey = VK_CONTROL; break;
+        case VK_LMENU:
+        case VK_RMENU:
+            vkey = VK_MENU; break;
+        }
+    }
+
+    if ((vkey >= 0x30 && vkey <= 0x39) || (vkey >= 0x41 && vkey <= 0x5a))
+    {
+        key[0] = vkey;
+        if (vkey >= 0x41)
+            key[0] += 0x20;
+        key[1] = 0;
+        name = key;
+    }
+    else
+    {
+        name = vkey_to_name(vkey);
+    }
+
+    if (!name || RtlUTF8ToUnicodeN(buffer, size, (DWORD *)&len, name, strlen(name) + 1)) len = 0;
+    else len = len / sizeof(WCHAR) - 1;
+
+    if (!len)
+    {
+        char buf[16];
+        len = snprintf(buf, sizeof(buf), "Key 0x%02x", vkey);
+        if (len > sizeof(buf)) len = sizeof(buf);
+        len = ascii_to_unicode_z(buffer, size, buf, len);
+        if (len > 0) len--;
+    }
+
+    TRACE_(key)("lparam 0x%08x -> %s\n", (int)lparam, debugstr_w(buffer));
+    return len;
+}
+
+/***********************************************************************
+ *           WAYLAND_MapVirtualKeyEx
+ */
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    UINT ret = 0;
+
+    TRACE_(key)("code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl);
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+
+        if (maptype == MAPVK_VK_TO_VSC) code &= 0xff;
+        ret = vkey_to_scancode(&wayland->keyboard, code);
+        if (maptype == MAPVK_VK_TO_VSC)
+        {
+            UINT scan_prefix = (ret >> 8) & 0xff;
+            if (scan_prefix == 0xe1)
+                ret = 0;
+            else
+                ret &= 0xff;
+        }
+        break;
+    case MAPVK_VSC_TO_VK:
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey(&wayland->keyboard, code);
+        if (maptype == MAPVK_VSC_TO_VK)
+        {
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        ret = map_vkey_to_wchar_with_deadchar_bit(&wayland->keyboard, code);
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);
+    return ret;
+}
+
+/***********************************************************************
+ *           WAYLAND_VkKeyScanEx
+ */
+SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = wayland->keyboard.xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    TRACE_(key)("ch %04x hkl %p ...\n", ch, hkl);
+
+    if (!xkb_state)
+    {
+        TRACE_(key)("... no xkb state , returning -1\n");
+        return -1;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("... no active layout, returning -1\n");
+        return -1;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+
+    /* Search through all keycodes and their shift levels for one that
+     * produces a keysym that matches the requested character. */
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+
+            if (_xkb_keysyms_to_wchar(syms, nsyms) == ch)
+            {
+                UINT vkey;
+                xkb_mod_mask_t mod_mask;
+                SHORT ret;
+
+                vkey = _xkb_keycode_to_vkey(&wayland->keyboard, xkb_keycode);
+                if (vkey == 0)
+                    continue;
+
+                xkb_keymap_key_get_mods_for_level(xkb_keymap, xkb_keycode,
+                                                  layout, level, &mod_mask, 1);
+                ret = _xkb_mod_mask_to_win32(xkb_keymap, mod_mask) | vkey;
+
+                TRACE_(key)("... returning %04x\n", ret);
+                return ret;
+            }
+        }
+    }
+
+    TRACE_(key)("... matching vkey not found, returning -1\n");
+    return -1;
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
new file mode 100644
index 00000000000..6d192b23ed6
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -0,0 +1,292 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ime.h"
+#include "winuser.h"
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
+                         const xkb_keysym_t ref[MAIN_KEY_SYMBOLS_LEN])
+{
+    int score = 0, i;
+
+    for (i = 0; i < MAIN_KEY_SYMBOLS_LEN && ref[i]; i++)
+    {
+        if (ref[i] != sym[i]) return 0;
+        score++;
+    }
+
+    return score;
+}
+
+static int score_layout(int layout,
+                        const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    int score = 0;
+    int prev_key = 1000;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int key, key_score = 0;
+        const xkb_keysym_t *symbols = symbols_for_keycode[xkb_keycode];
+
+        if (*symbols == 0)
+            continue;
+
+        for (key = 0; key < MAIN_KEY_LEN; key++)
+        {
+            if (key_used[key]) continue;
+            key_score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                      (*main_key_tab[layout].symbols)[key]);
+            if (key_score)
+                break;
+        }
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols, MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' key=%d score=%d order=%d\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, key, key_score, key_score && (key > prev_key));
+        }
+
+        if (key_score)
+        {
+            /* Multiply score by 100 to allow the key order bonus to break ties,
+             * while not being a primary decision factor. */
+            score += key_score * 100;
+
+            /* xkb keycodes roughly follow a top left to bottom right direction
+             * on the keyboard as they increase, similarly to the keys in
+             * main_key_tab. Give a bonus to layouts that more closely match
+             * the expected ordering. We compare with the last key to get
+             * some reasonable (although local) measure of the order. */
+            score += (key > prev_key);
+            prev_key = key;
+            key_used[key] = 1;
+        }
+    }
+
+    return score;
+}
+
+static void _xkb_keymap_populate_symbols_for_keycode(
+    struct xkb_keymap *xkb_keymap,
+    xkb_layout_index_t layout,
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+    if (max_xkb_keycode > 255) max_xkb_keycode = 255;
+
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        if (num_levels > MAIN_KEY_SYMBOLS_LEN) num_levels = MAIN_KEY_SYMBOLS_LEN;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+            if (nsyms)
+                symbols_for_keycode[xkb_keycode][level] = syms[0];
+        }
+    }
+}
+
+static int detect_main_key_layout(struct wayland_keyboard *keyboard,
+                                  const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    int max_score = 0;
+    int max_i = 0;
+
+    for (int i = 0; i < ARRAY_SIZE(main_key_tab); i++)
+    {
+        int score = score_layout(i, symbols_for_keycode);
+        if (score > max_score)
+        {
+            max_i = i;
+            max_score = score;
+        }
+        TRACE("evaluated layout '%s' score %d\n", main_key_tab[i].name, score);
+    }
+
+    if (max_score == 0)
+    {
+        max_i = 0;
+        while (strcmp(main_key_tab[max_i].name, "us")) max_i++;
+        TRACE("failed to detect layout, falling back to layout 'us'\n");
+    }
+    else
+    {
+        TRACE("detected layout '%s' (score %d)\n", main_key_tab[max_i].name, max_score);
+    }
+
+    return max_i;
+}
+
+/* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
+ * the specified main_key layout (see wayland_keyboard_layout.h) and the
+ * xkb_keycode to xkb_keysym_t mappings which have been created from the
+ * currently active Wayland keymap. */
+static void populate_xkb_keycode_maps(struct wayland_keyboard *keyboard, int main_key_layout,
+                                      const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+    const xkb_keysym_t (*lsymbols)[MAIN_KEY_SYMBOLS_LEN] =
+        (*main_key_tab[main_key_layout].symbols);
+    const WORD *lvkey = (*main_key_tab[main_key_layout].vkey);
+    const WORD *lscan = (*main_key_tab[main_key_layout].scan);
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int max_key = -1;
+        int max_score = 0;
+        xkb_keysym_t xkb_keysym = symbols_for_keycode[xkb_keycode][0];
+        UINT vkey = 0;
+        WORD scan = 0;
+
+        if ((xkb_keysym >> 8) == 0xFF)
+        {
+            vkey = xkb_keysym_0xff00_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_0xff00_to_scan[xkb_keysym & 0xff];
+        }
+        else if ((xkb_keysym >> 8) == 0x1008FF)
+        {
+            vkey = xkb_keysym_xfree86_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_xfree86_to_scan[xkb_keysym & 0xff];
+        }
+        else if (xkb_keysym == 0x20)
+        {
+            vkey = VK_SPACE;
+            scan = 0x39;
+        }
+        else
+        {
+            int key;
+
+            for (key = 0; key < MAIN_KEY_LEN; key++)
+            {
+                int score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                          lsymbols[key]);
+                /* Consider this key if it has a better score, or the same
+                 * score as a previous match that is already in use (in order
+                 * to prefer unused keys). */
+                if (score > max_score ||
+                    (max_key >= 0 && score == max_score && key_used[max_key]))
+                {
+                    max_key = key;
+                    max_score = score;
+                }
+            }
+
+            if (max_key >= 0)
+            {
+                vkey = lvkey[max_key];
+                scan = lscan[max_key];
+                key_used[max_key] = 1;
+            }
+        }
+
+        keyboard->xkb_keycode_to_vkey[xkb_keycode] = vkey;
+        keyboard->xkb_keycode_to_scancode[xkb_keycode] = scan;
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols_for_keycode[xkb_keycode],
+                                 MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("Mapped xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' => "
+                        "vkey=0x%x scan=0x%x\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, vkey, scan);
+        }
+    }
+}
+
+/***********************************************************************
+ *           wayland_keyboard_update_layout
+ *
+ * Updates the internal weston_keyboard layout information (xkb keycode
+ * mappings etc) based on the current XKB layout.
+ */
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
+{
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = keyboard->xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+    int main_key_layout;
+
+    if (!xkb_state)
+    {
+        TRACE("no xkb state, returning\n");
+        return;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE("no active layout, returning\n");
+        return;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+
+    _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
+
+    main_key_layout = detect_main_key_layout(keyboard, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, main_key_layout, symbols_for_keycode);
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
new file mode 100644
index 00000000000..f6ee87dc040
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -0,0 +1,966 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * This header file contains the tables used by keyboard_layout.c
+ * to perform layout mapping.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+#define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+
+#define MAIN_KEY_LEN 50
+/* We currently use two symbols (levels) per key to differentiate layouts. */
+#define MAIN_KEY_SYMBOLS_LEN 2
+
+/* Windows uses PS/2 scan code set 1 for the scan codes sent to applications. */
+static const WORD main_key_scan_ps2_set1[MAIN_KEY_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x7D,
+    /* Row D: AD01-AD12 */
+    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,
+    /* Row C: AC01-AC12 */
+    0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2B,
+    /* Row B: LSGT, AB01-AB11 */
+    0x56,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x73
+};
+
+static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_jp106[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    0,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_7,VK_OEM_5,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_3,VK_OEM_4,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_PLUS,VK_OEM_1,VK_OEM_6,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_v2[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_5,'1','2','3','4','5','6','7','8','9','0',VK_OEM_PLUS,VK_OEM_4,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_3,VK_OEM_7,VK_OEM_2,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_MINUS,
+};
+
+static const WORD main_key_vkey_qwertz[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Z','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Y','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_abnt_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_8,VK_OEM_5,
+    VK_OEM_7,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_102,
+};
+
+static const WORD main_key_vkey_colemak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','F','P','G','J','L','U','Y',VK_OEM_1,VK_OEM_4,VK_OEM_6,
+    'A','R','S','T','D','H','N','E','I','O',VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','K','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_azerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_7,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_PLUS,0,
+    'A','Z','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'Q','S','D','F','G','H','J','K','L','M',VK_OEM_3,VK_OEM_5,
+    VK_OEM_102,'W','X','C','V','B','N',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_8,
+};
+
+static const WORD main_key_vkey_dvorak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_6,0,
+    VK_OEM_7,VK_OEM_COMMA,VK_OEM_PERIOD,'P','Y','F','G','C','R','L',VK_OEM_2,VK_OEM_PLUS,
+    'A','O','E','U','I','D','H','T','N','S',VK_OEM_MINUS,VK_OEM_5,
+    VK_OEM_102,VK_OEM_1,'Q','J','K','X','B','M','W','V','Z',
+};
+
+#define K(x) XKB_KEY_##x
+
+static const xkb_keysym_t main_key_symbols_be[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+   {K(twosuperior), K(threesuperior)}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {K(section), '6'}, {K(egrave), '7'}, {'!', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+   {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', '*'},
+    /* Row C: AC01-AC12 */
+   {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {K(mu), K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+   {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'=', '+'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_bds[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'(', ')'}, {'1', '!'}, {'2', '?'}, {'3', '+'}, {'4', '"'}, {'5', '%'}, {'6', '='}, {'7', ':'}, {'8', '/'}, {'9', K(endash)}, {'0', K(numerosign)}, {'-', '$'}, {'.', K(EuroSign)}, {},
+    /* Row D: AD01-AD12 */
+    {',', K(Cyrillic_yeru)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {';', K(section)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(doublelowquotemark), K(leftdoublequotemark)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_e), K(Cyrillic_E)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_che), K(Cyrillic_CHE)}, {'1', '!'}, {'2', '@'}, {'3', K(numerosign)}, {'4', '$'}, {'5', '%'}, {'6', K(EuroSign)}, {'7', K(section)}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', K(endash)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_yu), K(Cyrillic_YU)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', K(doublelowquotemark)}, {'.', K(leftdoublequotemark)}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_br_abnt2[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', '"'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_diaeresis)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_acute), K(dead_grave)}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(dead_tilde), K(dead_circumflex)}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+   {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {';', ':'}, {'/', '?'},
+};
+
+static const xkb_keysym_t main_key_symbols_by[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Byelorussian_shortu), K(Byelorussian_SHORTU)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {'\'', '\''},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ca[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'#', '|'}, {'1', '!'}, {'2', '"'}, {'3', '/'}, {'4', '$'}, {'5', '%'}, {'6', '?'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_circumflex)}, {K(dead_cedilla), K(dead_diaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_grave), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '\''}, {'.', '.'}, {K(eacute), K(Eacute)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(egrave)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(eacute)}, {K(adiaeresis), K(agrave)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(udiaeresis)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(odiaeresis)}, {K(agrave), K(adiaeresis)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz_qwerty[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_circumflex), K(degree)}, {'1', '!'}, {'2', '"'}, {'3', K(section)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(ssharp), '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'#', '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_dk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(onehalf), K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(oslash), K(Oslash)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ee[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_caron), K(dead_tilde)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {K(otilde), K(Otilde)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_es[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(masculine), K(ordfeminine)}, {'1', '!'}, {'2', '"'}, {'3', K(periodcentered)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(exclamdown), K(questiondown)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_grave), K(dead_circumflex)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ntilde), K(Ntilde)}, {K(dead_acute), K(dead_diaeresis)}, {K(ccedilla), K(Ccedilla)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fi[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(twosuperior), '~'}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {'-', '6'}, {K(egrave), '7'}, {'_', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', K(sterling)},
+    /* Row C: AC01-AC12 */
+    {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {'*', K(mu)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'!', K(section)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gb[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', K(notsign)}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '@'}, {'#', '~'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {K(Greek_finalsmallsigma), K(Greek_SIGMA)}, {K(Greek_epsilon), K(Greek_EPSILON)}, {K(Greek_rho), K(Greek_RHO)}, {K(Greek_tau), K(Greek_TAU)}, {K(Greek_upsilon), K(Greek_UPSILON)}, {K(Greek_theta), K(Greek_THETA)}, {K(Greek_iota), K(Greek_IOTA)}, {K(Greek_omicron), K(Greek_OMICRON)}, {K(Greek_pi), K(Greek_PI)}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {K(Greek_alpha), K(Greek_ALPHA)}, {K(Greek_sigma), K(Greek_SIGMA)}, {K(Greek_delta), K(Greek_DELTA)}, {K(Greek_phi), K(Greek_PHI)}, {K(Greek_gamma), K(Greek_GAMMA)}, {K(Greek_eta), K(Greek_ETA)}, {K(Greek_xi), K(Greek_XI)}, {K(Greek_kappa), K(Greek_KAPPA)}, {K(Greek_lamda), K(Greek_LAMDA)}, {K(dead_acute), K(dead_diaeresis)}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {K(Greek_zeta), K(Greek_ZETA)}, {K(Greek_chi), K(Greek_CHI)}, {K(Greek_psi), K(Greek_PSI)}, {K(Greek_omega), K(Greek_OMEGA)}, {K(Greek_beta), K(Greek_BETA)}, {K(Greek_nu), K(Greek_NU)}, {K(Greek_mu), K(Greek_MU)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hu[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'0', K(section)}, {'1', '\''}, {'2', '"'}, {'3', '+'}, {'4', '!'}, {'5', '%'}, {'6', '/'}, {'7', '='}, {'8', '('}, {'9', ')'}, {K(odiaeresis), K(Odiaeresis)}, {K(udiaeresis), K(Udiaeresis)}, {K(oacute), K(Oacute)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(odoubleacute), K(Odoubleacute)}, {K(uacute), K(Uacute)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(Eacute)}, {K(aacute), K(Aacute)}, {K(udoubleacute), K(Udoubleacute)},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(iacute), K(Iacute)}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', ')'}, {'0', '('}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'/', 'Q'}, {'\'', 'W'}, {K(hebrew_qoph), 'E'}, {K(hebrew_resh), 'R'}, {K(hebrew_aleph), 'T'}, {K(hebrew_tet), 'Y'}, {K(hebrew_waw), 'U'}, {K(hebrew_finalnun), 'I'}, {K(hebrew_finalmem), 'O'}, {K(hebrew_pe), 'P'}, {']', '}'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_shin), 'A'}, {K(hebrew_dalet), 'S'}, {K(hebrew_gimel), 'D'}, {K(hebrew_kaph), 'F'}, {K(hebrew_ayin), 'G'}, {K(hebrew_yod), 'H'}, {K(hebrew_chet), 'J'}, {K(hebrew_lamed), 'K'}, {K(hebrew_finalkaph), 'L'}, {K(hebrew_finalpe), ':'}, {',', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), 'Z'}, {K(hebrew_samech), 'X'}, {K(hebrew_bet), 'C'}, {K(hebrew_he), 'V'}, {K(hebrew_nun), 'B'}, {K(hebrew_mem), 'N'}, {K(hebrew_zade), 'M'}, {K(hebrew_taw), '>'}, {K(hebrew_finalzade), '<'}, {'.', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(hebrew_qoph), K(hebrew_qoph)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_resh), K(hebrew_resh)}, {K(hebrew_taw), K(hebrew_tet)}, {K(hebrew_ayin), K(hebrew_ayin)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_samech), K(hebrew_samech)}, {K(hebrew_pe), K(hebrew_finalpe)}, {}, {},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_shin), K(hebrew_shin)}, {K(hebrew_dalet), K(hebrew_dalet)}, {K(hebrew_pe), K(hebrew_finalpe)}, {K(hebrew_gimel), K(hebrew_gimel)}, {K(hebrew_he), K(hebrew_he)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_kaph), K(hebrew_finalkaph)}, {K(hebrew_lamed), K(hebrew_lamed)}, {}, {}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), K(hebrew_zain)}, {K(hebrew_chet), K(hebrew_chet)}, {K(hebrew_zade), K(hebrew_finalzade)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_bet), K(hebrew_bet)}, {K(hebrew_nun), K(hebrew_finalnun)}, {K(hebrew_mem), K(hebrew_finalmem)}, {}, {}, {}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_is[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_abovering), K(dead_diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(odiaeresis), K(Odiaeresis)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(eth), K(ETH)}, {'\'', '?'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(dead_acute), K(dead_acute)}, {'+', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {K(thorn), K(THORN)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_it[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(igrave), '^'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(eacute)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ograve), K(ccedilla)}, {K(agrave), K(degree)}, {K(ugrave), K(section)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_106[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '~'}, {'-', '='}, {'^', '~'}, {'\\', '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_kana86[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', K(kana_WO)}, {'-', '='}, {'^', '~'}, {K(yen), '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_mac[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {K(kana_NU)}, {K(kana_FU)}, {K(kana_A), K(kana_a)}, {K(kana_U), K(kana_u)}, {K(kana_E), K(kana_e)}, {K(kana_O), K(kana_o)}, {K(kana_YA), K(kana_ya)}, {K(kana_YU), K(kana_yu)}, {K(kana_YO), K(kana_yo)}, {K(kana_WA), K(kana_WO)}, {K(kana_HO)}, {K(kana_HE)}, {K(prolongedsound)},
+    /* Row D: AD01-AD12 */
+    {K(kana_TA)}, {K(kana_TE)}, {K(kana_I), K(kana_i)}, {K(kana_SU)}, {K(kana_KA)}, {K(kana_N)}, {K(kana_NA)}, {K(kana_NI)}, {K(kana_RA)}, {K(kana_SE)}, {K(voicedsound)}, {K(semivoicedsound), K(kana_openingbracket)},
+    /* Row C: AC01-AC12 */
+    {K(kana_CHI)}, {K(kana_TO)}, {K(kana_SHI)}, {K(kana_HA)}, {K(kana_KI)}, {K(kana_KU)}, {K(kana_MA)}, {K(kana_NO)}, {K(kana_RI)}, {K(kana_RE)}, {K(kana_KE)}, {K(kana_MU), K(kana_closingbracket)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(kana_TSU), K(kana_tsu)}, {K(kana_SA)}, {K(kana_SO)}, {K(kana_HI)}, {K(kana_KO)}, {K(kana_MI)}, {K(kana_MO)}, {K(kana_NE), K(kana_comma)}, {K(kana_RU), K(kana_fullstop)}, {K(kana_ME), K(kana_conjunctive)}, {K(kana_RO)},
+};
+
+static const xkb_keysym_t main_key_symbols_lt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {K(aogonek), K(Aogonek)}, {K(ccaron), K(Ccaron)}, {K(eogonek), K(Eogonek)}, {K(eabovedot), K(Eabovedot)}, {K(iogonek), K(Iogonek)}, {K(scaron), K(Scaron)}, {K(uogonek), K(Uogonek)}, {K(umacron), K(Umacron)}, {K(doublelowquotemark), '('}, {K(leftdoublequotemark), ')'}, {'-', '_'}, {K(zcaron), K(Zcaron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(endash), K(EuroSign)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_nl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'@', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '_'}, {'8', '('}, {'9', ')'}, {'0', '\''}, {'/', '?'}, {K(degree), K(dead_tilde)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_diaeresis), K(dead_circumflex)}, {'*', '|'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'+', K(plusminus)}, {K(dead_acute), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {']', '['}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '='}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_no[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'|', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {'\\', K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(oslash), K(Oslash)}, {K(ae), K(AE)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl_dvp[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'$', '~'}, {'&', '%'}, {'[', '7'}, {'{', '5'}, {'}', '3'}, {'(', '1'}, {'=', '9'}, {'*', '0'}, {')', '2'}, {'+', '4'}, {']', '6'}, {'!', '8'}, {'#', '`'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'@', '^'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'\'', '"'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(guillemotleft), K(guillemotright)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'+', '*'}, {K(dead_acute), K(dead_grave)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(masculine), K(ordfeminine)}, {K(dead_tilde), K(dead_circumflex)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_yu), K(Cyrillic_YU)}, {'1', '!'}, {'2', '@'}, {'3', K(Cyrillic_io)}, {'4', K(Cyrillic_IO)}, {'5', K(Cyrillic_hardsign)}, {'6', K(Cyrillic_HARDSIGN)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_e), K(Cyrillic_E)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'|', K(brokenbar)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_rs[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] = {
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_lje), K(Cyrillic_LJE)}, {K(Cyrillic_nje), K(Cyrillic_NJE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Serbian_dje), K(Serbian_DJE)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_je), K(Cyrillic_JE)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Serbian_tshe), K(Serbian_TSHE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_dzhe), K(Cyrillic_DZHE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_se[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_si[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(cedilla), K(diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_sk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(lcaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(tcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {K(adiaeresis), '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ocircumflex), '"'}, {K(section), '!'}, {K(ncaron), ')'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_th[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'_', '%'}, {K(Thai_lakkhangyao), '+'}, {'/', K(Thai_leknung)}, {'-', K(Thai_leksong)}, {K(Thai_phosamphao), K(Thai_leksam)}, {K(Thai_thothung), K(Thai_leksi)}, {K(Thai_sarau), K(Thai_sarauu)}, {K(Thai_saraue), K(Thai_baht)}, {K(Thai_khokhwai), K(Thai_lekha)}, {K(Thai_totao), K(Thai_lekhok)}, {K(Thai_chochan), K(Thai_lekchet)}, {K(Thai_khokhai), K(Thai_lekpaet)}, {K(Thai_chochang), K(Thai_lekkao)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Thai_maiyamok), K(Thai_leksun)}, {K(Thai_saraaimaimalai), '"'}, {K(Thai_saraam), K(Thai_dochada)}, {K(Thai_phophan), K(Thai_thonangmontho)}, {K(Thai_saraa), K(Thai_thothong)}, {K(Thai_maihanakat), K(Thai_nikhahit)}, {K(Thai_saraii), K(Thai_maitri)}, {K(Thai_rorua), K(Thai_nonen)}, {K(Thai_nonu), K(Thai_paiyannoi)}, {K(Thai_yoyak), K(Thai_yoying)}, {K(Thai_bobaimai), K(Thai_thothan)}, {K(Thai_loling), ','},
+    /* Row C: AC01-AC12 */
+    {K(Thai_fofan), K(Thai_ru)}, {K(Thai_hohip), K(Thai_khorakhang)}, {K(Thai_kokai), K(Thai_topatak)}, {K(Thai_dodek), K(Thai_sarao)}, {K(Thai_sarae), K(Thai_chochoe)}, {K(Thai_maitho), K(Thai_maitaikhu)}, {K(Thai_maiek), K(Thai_maichattawa)}, {K(Thai_saraaa), K(Thai_sorusi)}, {K(Thai_sosua), K(Thai_sosala)}, {K(Thai_wowaen), K(Thai_soso)}, {K(Thai_ngongu), '.'}, {K(Thai_khokhuat), K(Thai_khokhon)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Thai_phophung), '('}, {K(Thai_popla), ')'}, {K(Thai_saraae), K(Thai_choching)}, {K(Thai_oang), K(Thai_honokhuk)}, {K(Thai_sarai), K(Thai_phinthu)}, {K(Thai_sarauee), K(Thai_thanthakhat)}, {K(Thai_thothahan), '?'}, {K(Thai_moma), K(Thai_thophuthao)}, {K(Thai_saraaimaimuan), K(Thai_lochula)}, {K(Thai_fofa), K(Thai_lu)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'"', K(eacute)}, {'1', '!'}, {'2', '\''}, {'3', '^'}, {'4', '+'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'*', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {K(idotless), 'I'}, {'o', 'O'}, {'p', 'P'}, {K(gbreve), K(Gbreve)}, {K(udiaeresis), K(Udiaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(scedilla), K(Scedilla)}, {'i', K(Iabovedot)}, {',', ';'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {K(odiaeresis), K(Odiaeresis)}, {K(ccedilla), K(Ccedilla)}, {'.', ':'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr_f[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'+', '*'}, {'1', '!'}, {'2', '"'}, {'3', '^'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '='}, {'/', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'f', 'F'}, {'g', 'G'}, {K(gbreve), K(Gbreve)}, {K(idotless), 'I'}, {'o', 'O'}, {'d', 'D'}, {'r', 'R'}, {'n', 'N'}, {'h', 'H'}, {'p', 'P'}, {'q', 'Q'}, {'w', 'W'},
+    /* Row C: AC01-AC12 */
+    {'u', 'U'}, {'i', K(Iabovedot)}, {'e', 'E'}, {'a', 'A'}, {K(udiaeresis), K(Udiaeresis)}, {'t', 'T'}, {'k', 'K'}, {'m', 'M'}, {'l', 'L'}, {'y', 'Y'}, {K(scedilla), K(Scedilla)}, {'x', 'X'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'j', 'J'}, {K(odiaeresis), K(Odiaeresis)}, {'v', 'V'}, {'c', 'C'}, {K(ccedilla), K(Ccedilla)}, {'z', 'Z'}, {'s', 'S'}, {'b', 'B'}, {'.', ':'}, {',', ';'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ua[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', 0x10002bc}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Ukrainian_yi), K(Ukrainian_YI)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Ukrainian_ie), K(Ukrainian_IE)}, {K(Ukrainian_ghe_with_upturn), K(Ukrainian_GHE_WITH_UPTURN)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+
+static const xkb_keysym_t main_key_symbols_us_colemak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'f', 'F'}, {'p', 'P'}, {'g', 'G'}, {'j', 'J'}, {'l', 'L'}, {'u', 'U'}, {'y', 'Y'}, {';', ':'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'d', 'D'}, {'h', 'H'}, {'n', 'N'}, {'e', 'E'}, {'i', 'I'}, {'o', 'O'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'-', '_'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'k', 'K'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_dvorak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'[', '{'}, {']', '}'}, {},
+    /* Row D: AD01-AD12 */
+    {'\'', '"'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'=', '+'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {';', ':'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_intl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_grave), K(dead_tilde)}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_circumflex)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_acute), K(dead_diaeresis)}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+#undef K
+
+/*** The VNC keyboard layout is a special case */
+
+static const WORD main_key_scan_vnc[MAIN_KEY_LEN] =
+{
+    0x02,0x03,0x04,0x05,0x06,0x07,
+    0x08,0x09,0x0A,0x0B,0x0C,0x0D,
+    0x1A,0x1B,0x27,0x28,0x29,0x33,
+    0x34,0x35,0x2B,0x1E,0x30,0x2E,
+    0x20,0x12,0x21,0x22,0x23,0x17,
+    0x24,0x25,0x26,0x32,0x31,0x18,
+    0x19,0x10,0x13,0x1F,0x14,0x16,
+    0x2F,0x11,0x2D,0x15,0x2C,0x56
+};
+
+static const WORD main_key_vkey_vnc[MAIN_KEY_LEN] =
+{
+    '1','2','3','4','5','6',
+    '7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,
+    VK_OEM_4,VK_OEM_6,VK_OEM_1,VK_OEM_7,VK_OEM_3,VK_OEM_COMMA,
+    VK_OEM_PERIOD,VK_OEM_2,VK_OEM_5, 'A','B','C',
+    'D','E','F','G','H','I',
+    'J','K','L','M','N','O',
+    'P','Q','R','S','T','U',
+    'V','W','X','Y','Z', VK_OEM_102
+};
+
+static const xkb_keysym_t main_key_symbols_vnc[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'},
+    {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'},
+    {'[', '{'}, {']', '}'}, {';', ':'}, {'\'', '"'}, {'`', '~'}, {',', '<'},
+    {'.', '>'}, {'/', '?'}, {'\\', '|'}, {'a', 'A'}, {'b', 'B'}, {'c', 'C'},
+    {'d', 'D'}, {'e', 'E'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'i', 'I'},
+    {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {'n', 'N'}, {'o', 'O'},
+    {'p', 'P'}, {'q', 'Q'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'u', 'U'},
+    {'v', 'V'}, {'w', 'W'}, {'x', 'X'}, {'y', 'Y'}, {'z', 'Z'}
+};
+
+/*** Layout table. Add your keyboard mappings to this list */
+static struct {
+    LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
+                 in the appropriate dlls/kernel/nls/.nls file */
+    const char *name;
+    const xkb_keysym_t (*symbols)[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN];
+    const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
+    const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
+} main_key_tab[]={
+    {0x0402, "bg_bds", &main_key_symbols_bg_bds, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0402, "bg_phonetic", &main_key_symbols_bg_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz", &main_key_symbols_cz, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz_qwerty", &main_key_symbols_cz_qwerty, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0406, "dk", &main_key_symbols_dk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0407, "de", &main_key_symbols_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0408, "gr", &main_key_symbols_gr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us_colemak", &main_key_symbols_us_colemak, &main_key_scan_ps2_set1, &main_key_vkey_colemak},
+    {0x0409, "us_dvorak", &main_key_symbols_us_dvorak, &main_key_scan_ps2_set1, &main_key_vkey_dvorak},
+    {0x0409, "us_intl", &main_key_symbols_us_intl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "vnc", &main_key_symbols_vnc, &main_key_scan_vnc, &main_key_vkey_vnc},
+    {0x040a, "es", &main_key_symbols_es, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040b, "fi", &main_key_symbols_fi, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040c, "fr", &main_key_symbols_fr, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x040d, "il", &main_key_symbols_il, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040d, "il_phonetic", &main_key_symbols_il_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040e, "hu", &main_key_symbols_hu, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x040f, "is", &main_key_symbols_is, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0410, "it", &main_key_symbols_it, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_106", &main_key_symbols_jp_106, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0411, "jp_kana86", &main_key_symbols_jp_kana86, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_mac", &main_key_symbols_jp_mac, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0413, "nl", &main_key_symbols_nl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0414, "no", &main_key_symbols_no, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0415, "pl_dvp", &main_key_symbols_pl_dvp, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0416, "br_abnt2", &main_key_symbols_br_abnt2, &main_key_scan_ps2_set1, &main_key_vkey_abnt_qwerty},
+    {0x0419, "ru", &main_key_symbols_ru, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0419, "ru_phonetic", &main_key_symbols_ru_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041a, "hr", &main_key_symbols_hr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x041b, "sk", &main_key_symbols_sk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041d, "se", &main_key_symbols_se, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_v2},
+    {0x041e, "th", &main_key_symbols_th, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr_f", &main_key_symbols_tr_f, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr", &main_key_symbols_tr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0422, "ua", &main_key_symbols_ua, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0423, "by", &main_key_symbols_by, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0424, "si", &main_key_symbols_si, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0425, "ee", &main_key_symbols_ee, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0427, "lt", &main_key_symbols_lt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0807, "ch_de", &main_key_symbols_ch_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0809, "gb", &main_key_symbols_gb, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x080c, "be", &main_key_symbols_be, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x0816, "pt", &main_key_symbols_pt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c0c, "ca", &main_key_symbols_ca, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c1a, "rs", &main_key_symbols_rs, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x100c, "ch_fr", &main_key_symbols_ch_fr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+};
+
+const WORD xkb_keysym_0xff00_to_vkey[256] DECLSPEC_HIDDEN =
+{
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF00 */
+    /* special keys */
+    VK_BACK, VK_TAB, 0, VK_CLEAR, 0, VK_RETURN, 0, 0,           /* FF08 */
+    0, 0, 0, VK_PAUSE, VK_SCROLL, VK_SNAPSHOT, 0, 0,            /* FF10 */
+    0, 0, 0, VK_ESCAPE, 0, 0, 0, 0,                             /* FF18 */
+    /* Japanese special keys */
+    0, VK_KANJI, VK_NONCONVERT, VK_CONVERT,                     /* FF20 */
+    VK_DBE_ROMAN, 0, 0, VK_DBE_HIRAGANA,
+    0, 0, VK_DBE_SBCSCHAR, 0, 0, 0, 0, 0,                       /* FF28 */
+    /* Korean special keys (FF31-) */
+    VK_DBE_ALPHANUMERIC, VK_HANGUL, 0, 0, VK_HANJA, 0, 0, 0,    /* FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF38 */
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF48 */
+    /* cursor keys */
+    VK_HOME, VK_LEFT, VK_UP, VK_RIGHT,                          /* FF50 */
+    VK_DOWN, VK_PRIOR, VK_NEXT, VK_END,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF58 */
+    /* misc keys */
+    VK_SELECT, VK_SNAPSHOT, VK_EXECUTE, VK_INSERT, 0,0,0, VK_APPS, /* FF60 */
+    0, VK_CANCEL, VK_HELP, VK_CANCEL, 0, 0, 0, 0,               /* FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF70 */
+    /* keypad keys */
+    0, 0, 0, 0, 0, 0, 0, VK_NUMLOCK,                            /* FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF80 */
+    0, 0, 0, 0, 0, VK_RETURN, 0, 0,                             /* FF88 */
+    0, 0, 0, 0, 0, VK_HOME, VK_LEFT, VK_UP,                     /* FF90 */
+    VK_RIGHT, VK_DOWN, VK_PRIOR, VK_NEXT,                       /* FF98 */
+    VK_END, VK_CLEAR, VK_INSERT, VK_DELETE,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFA0 */
+    0, 0, VK_MULTIPLY, VK_ADD,                                  /* FFA8 */
+    /* Windows always generates VK_DECIMAL for Del/. on keypad while some
+     * X11 keyboard layouts generate XK_KP_Separator instead of XK_KP_Decimal
+     * in order to produce a locale dependent numeric separator.
+     */
+    VK_DECIMAL, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
+    VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3,             /* FFB0 */
+    VK_NUMPAD4, VK_NUMPAD5, VK_NUMPAD6, VK_NUMPAD7,
+    VK_NUMPAD8, VK_NUMPAD9, 0, 0, 0, VK_OEM_NEC_EQUAL,          /* FFB8 */
+    /* function keys */
+    VK_F1, VK_F2,
+    VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10,    /* FFC0 */
+    VK_F11, VK_F12, VK_F13, VK_F14, VK_F15, VK_F16, VK_F17, VK_F18, /* FFC8 */
+    VK_F19, VK_F20, VK_F21, VK_F22, VK_F23, VK_F24, 0, 0,       /* FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFD8 */
+    /* modifier keys */
+    0, VK_LSHIFT, VK_RSHIFT, VK_LCONTROL,                       /* FFE0 */
+    VK_RCONTROL, VK_CAPITAL, 0, VK_LMENU,
+    VK_RMENU, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN, 0, 0, 0,    /* FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFF0 */
+    0, 0, 0, 0, 0, 0, 0, VK_DELETE                              /* FFF8 */
+};
+
+const WORD xkb_keysym_0xff00_to_scan[256] DECLSPEC_HIDDEN =
+{
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF00 */
+    /* special keys */
+    0x0E, 0x0F, 0x00, /*?*/ 0, 0x00, 0x1C, 0x00, 0x00,           /* FF08 */
+    0x00, 0x00, 0x00, 0xE11D, 0x46, 0x54, 0x00, 0x00,            /* FF10 */
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,              /* FF18 */
+    /* Japanese special keys */
+    0x00, 0x29, 0x7B, 0x79, 0x70, 0x00, 0x00, 0x70,              /* FF20 */
+    0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF28 */
+    /* Korean special keys (FF31-) */
+    0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF30 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF38 */
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF40 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF48 */
+    /* cursor keys */
+    0xE047, 0xE04B, 0xE048, 0xE04D, 0xE050, 0xE049, 0xE051, 0xE04F, /* FF50 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF58 */
+    /* misc keys */
+    /*?*/ 0, 0xE037, /*?*/ 0, 0xE052, 0x00, 0x00, 0x00, 0xE05D,  /* FF60 */
+    /*?*/ 0, /*?*/ 0, 0x63, 0xE046, 0x00, 0x00, 0x00, 0x00,      /* FF68 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF70 */
+    /* keypad keys */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45,              /* FF78 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF80 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0xE01C, 0x00, 0x00,            /* FF88 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4B, 0x48,              /* FF90 */
+    0x4D, 0x50, 0x49, 0x51, 0x4F, 0x4C, 0x52, 0x53,              /* FF98 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFA0 */
+    0x00, 0x00, 0x37, 0x4E, 0x53, 0x4A, 0x53, 0xE035,            /* FFA8 */
+    0x52, 0x4F, 0x50, 0x51, 0x4B, 0x4C, 0x4D, 0x47,              /* FFB0 */
+    0x48, 0x49, 0x00, 0x00, 0x00, 0x00,                          /* FFB8 */
+    /* function keys */
+    0x3B, 0x3C,
+    0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44,              /* FFC0 */
+    0x57, 0x58, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,              /* FFC8 */
+    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x76, 0x00, 0x00,              /* FFD0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD8 */
+    /* modifier keys */
+    0x00, 0x2A, 0x36, 0x1D, 0xE01D, 0x3A, 0x00, 0x38,            /* FFE0 */
+    0xE038, 0x38, 0xE038, 0xE05B, 0xE05C, 0x00, 0x00, 0x00,      /* FFE8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFF0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE053             /* FFF8 */
+};
+
+const WORD xkb_keysym_xfree86_to_vkey[256] DECLSPEC_HIDDEN =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, VK_VOLUME_DOWN, VK_VOLUME_MUTE, VK_VOLUME_UP,            /* 1008FF10 */
+    VK_MEDIA_PLAY_PAUSE, VK_MEDIA_STOP,
+    VK_MEDIA_PREV_TRACK, VK_MEDIA_NEXT_TRACK,
+    0, VK_LAUNCH_MAIL, 0, VK_BROWSER_SEARCH,                    /* 1008FF18 */
+    0, 0, 0, VK_BROWSER_HOME,
+    0, 0, 0, 0, 0, 0, VK_BROWSER_BACK, VK_BROWSER_FORWARD,      /* 1008FF20 */
+    VK_BROWSER_STOP, VK_BROWSER_REFRESH, 0, 0, 0, 0, 0, VK_SLEEP, /* 1008FF28 */
+    VK_BROWSER_FAVORITES, 0, VK_LAUNCH_MEDIA_SELECT, 0,         /* 1008FF30 */
+    0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    VK_LAUNCH_APP1, VK_LAUNCH_APP2, 0, 0, 0, 0, 0, 0,           /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
+};
+
+const WORD xkb_keysym_xfree86_to_scan[256] DECLSPEC_HIDDEN =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, 0xE02E, 0xE020, 0xE030, 0xE022, 0xE024, 0xE010, 0xE019,  /* 1008FF10 */
+    0, 0xE06C, 0, 0xE065, 0, 0, 0, 0xE032,                      /* 1008FF18 */
+    0, 0, 0, 0, 0, 0, 0xE06A, 0xE069,                           /* 1008FF20 */
+    0xE068, 0xE067, 0, 0, 0, 0, 0, 0xE05F,                      /* 1008FF28 */
+    0xE066, 0, 0xE06D, 0, 0, 0, 0, 0,                           /* 1008FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    0xE06B, 0xE021, 0, 0, 0, 0, 0, 0,                           /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
+};
+
+#endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/wayland_mutex.c b/dlls/winewayland.drv/wayland_mutex.c
new file mode 100644
index 00000000000..a32cbbbd519
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_mutex.c
@@ -0,0 +1,137 @@
+/*
+ * Wayland mutex
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <errno.h>
+#include <time.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_mutex_init
+ *
+ * Initialize a wayland_mutex.
+ */
+void wayland_mutex_init(struct wayland_mutex *wayland_mutex, int kind,
+                        const char *name)
+{
+    pthread_mutexattr_t mutexattr;
+
+    pthread_mutexattr_init(&mutexattr);
+    pthread_mutexattr_settype(&mutexattr, kind);
+    pthread_mutex_init(&wayland_mutex->mutex, &mutexattr);
+    pthread_mutexattr_destroy(&mutexattr);
+
+    wayland_mutex->owner_tid = 0;
+    wayland_mutex->lock_count = 0;
+    wayland_mutex->name = name;
+}
+
+/**********************************************************************
+ *          wayland_mutex_destroy
+ *
+ * Destroys a wayland_mutex.
+ */
+void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex)
+{
+    pthread_mutex_destroy(&wayland_mutex->mutex);
+    wayland_mutex->owner_tid = 0;
+    wayland_mutex->lock_count = 0;
+    wayland_mutex->name = NULL;
+}
+
+/**********************************************************************
+ *          wayland_mutex_lock
+ *
+ *  Lock a mutex, emitting error messages in cases of suspected deadlock.
+ *  In case of an unrecoverable error abort to ensure the program doesn't
+ *  continue with an inconsistent state.
+ */
+void wayland_mutex_lock(struct wayland_mutex *wayland_mutex)
+{
+    UINT tid = GetCurrentThreadId();
+    struct timespec timeout;
+    int err;
+
+    clock_gettime(CLOCK_REALTIME, &timeout);
+    timeout.tv_sec += 5;
+
+    while (TRUE)
+    {
+        err = pthread_mutex_timedlock(&wayland_mutex->mutex, &timeout);
+        if (!err) break;
+
+        if (err == ETIMEDOUT)
+        {
+            ERR("mutex %p %s lock timed out in thread %04x, blocked by %04x, retrying (60 sec)\n",
+                wayland_mutex, wayland_mutex->name, tid, wayland_mutex->owner_tid);
+            clock_gettime(CLOCK_REALTIME, &timeout);
+            timeout.tv_sec += 60;
+        }
+        else
+        {
+            ERR("error locking mutex %p %s errno=%d, aborting\n",
+                wayland_mutex, wayland_mutex->name, errno);
+            abort();
+        }
+    }
+
+    wayland_mutex->owner_tid = tid;
+    wayland_mutex->lock_count++;
+}
+
+/**********************************************************************
+ *          wayland_mutex_unlock
+ *
+ *  Unlock a mutex.
+ */
+void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex)
+{
+    int err;
+
+    wayland_mutex->lock_count--;
+
+    if (wayland_mutex->lock_count == 0)
+    {
+        wayland_mutex->owner_tid = 0;
+    }
+    else if (wayland_mutex->lock_count < 0)
+    {
+        ERR("mutex %p %s lock_count is %d < 0\n",
+             wayland_mutex, wayland_mutex->name, wayland_mutex->lock_count);
+    }
+
+    if ((err = pthread_mutex_unlock(&wayland_mutex->mutex)))
+    {
+        ERR("failed to unlock mutex %p %s errno=%d\n",
+            wayland_mutex, wayland_mutex->name, err);
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
new file mode 100644
index 00000000000..34277d5f9c5
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <assert.h>
+#include <unistd.h>
+#include <xf86drm.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_native_buffer_init_shm
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format)
+{
+    int stride;
+    off_t size;
+    int fd;
+
+    assert(format == WL_SHM_FORMAT_ARGB8888 || format == WL_SHM_FORMAT_XRGB8888);
+
+    stride = width * 4;
+    size = stride * height;
+
+    fd = wayland_shmfd_create("wayland-shm", size);
+    if (fd < 0) return FALSE;
+
+    native->plane_count = 1;
+    native->fds[0] = fd;
+    native->strides[0] = stride;
+    native->offsets[0] = 0;
+    native->width = width;
+    native->height = height;
+    native->format = format;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_native_buffer_init_gbm
+ *
+ * Initializes a native buffer from a gbm_bo.
+ */
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo)
+{
+    int i;
+
+    native->plane_count = gbm_bo_get_plane_count(bo);
+    native->width = gbm_bo_get_width(bo);
+    native->height = gbm_bo_get_height(bo);
+    native->format = gbm_bo_get_format(bo);
+    native->modifier = gbm_bo_get_modifier(bo);
+    for (i = 0; i < ARRAY_SIZE(native->fds); i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        int ret;
+        union gbm_bo_handle handle;
+
+        handle = gbm_bo_get_handle_for_plane(bo, i);
+        if (handle.s32 == -1)
+        {
+            ERR("error: failed to get gbm_bo_handle\n");
+            goto err;
+        }
+
+        ret = drmPrimeHandleToFD(gbm_device_get_fd(gbm_bo_get_device(bo)),
+                                 handle.u32, 0, &native->fds[i]);
+        if (ret < 0 || native->fds[i] < 0)
+        {
+            ERR("error: failed to get dmabuf_fd\n");
+            goto err;
+        }
+        native->strides[i] = gbm_bo_get_stride_for_plane(bo, i);
+        native->offsets[i] = gbm_bo_get_offset(bo, i);
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_native_buffer_deinit
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+void wayland_native_buffer_deinit(struct wayland_native_buffer *native)
+{
+    int i;
+
+    for (i = 0; i < native->plane_count; i++)
+        if (native->fds[i] >= 0) close(native->fds[i]);
+
+    native->plane_count = 0;
+}
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
new file mode 100644
index 00000000000..f6df6cd73c7
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -0,0 +1,719 @@
+/*
+ * Wayland output handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <math.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct default_mode { int32_t width; int32_t height; };
+static const struct default_mode default_modes[] = {
+    { 320,  200}, /* CGA 16:10 */
+    { 320,  240}, /* QVGA 4:3 */
+    { 400,  300}, /* qSVGA 4:3 */
+    { 480,  320}, /* HVGA 3:2 */
+    { 512,  384}, /* MAC 4:3 */
+    { 640,  360}, /* nHD 16:9 */
+    { 640,  400}, /* VESA-0100h 16:10 */
+    { 640,  480}, /* VGA 4:3 */
+    { 720,  480}, /* WVGA 3:2 */
+    { 720,  576}, /* PAL 5:4 */
+    { 768,  480}, /* WVGA 16:10 */
+    { 768,  576}, /* PAL* 4:3 */
+    { 800,  600}, /* SVGA 4:3 */
+    { 854,  480}, /* FWVGA 16:9 */
+    { 960,  540}, /* qHD 16:9 */
+    { 960,  640}, /* DVGA 3:2 */
+    {1024,  576}, /* WSVGA 16:9 */
+    {1024,  640}, /* WSVGA 16:10 */
+    {1024,  768}, /* XGA 4:3 */
+    {1152,  864}, /* XGA+ 4:3 */
+    {1280,  720}, /* HD 16:9 */
+    {1280,  768}, /* WXGA 5:3 */
+    {1280,  800}, /* WXGA 16:10 */
+    {1280,  960}, /* SXGA- 4:3 */
+    {1280, 1024}, /* SXGA 5:4 */
+    {1366,  768}, /* FWXGA 16:9 */
+    {1400, 1050}, /* SXGA+ 4:3 */
+    {1440,  900}, /* WSXGA 16:10 */
+    {1600,  900}, /* HD+ 16:9 */
+    {1600, 1200}, /* UXGA 4:3 */
+    {1680, 1050}, /* WSXGA+ 16:10 */
+    {1920, 1080}, /* FHD 16:9 */
+    {1920, 1200}, /* WUXGA 16:10 */
+    {2048, 1152}, /* QWXGA 16:9 */
+    {2048, 1536}, /* QXGA 4:3 */
+    {2560, 1440}, /* QHD 16:9 */
+    {2560, 1600}, /* WQXGA 16:10 */
+    {2560, 2048}, /* QSXGA 5:4 */
+    {2880, 1620}, /* 3K 16:9 */
+    {3200, 1800}, /* QHD+ 16:9 */
+    {3200, 2400}, /* QUXGA 4:3 */
+    {3840, 2160}, /* 4K 16:9 */
+    {3840, 2400}, /* WQUXGA 16:10 */
+    {5120, 2880}, /* 5K 16:9 */
+    {7680, 4320}, /* 8K 16:9 */
+};
+
+static const int32_t default_refresh = 60000;
+
+/**********************************************************************
+ *          Output handling
+ */
+
+/* Compare mode with the set of provided mode parameters and return -1 if the
+ * mode compares less than the parameters, 0 if the mode compares equal to the
+ * parameters, and 1 if the mode compares greater than the parameters.
+ *
+ * The comparison is based on comparing the width, height, bpp and refresh
+ * in that order.
+ */
+static int wayland_output_mode_cmp(struct wayland_output_mode *mode,
+                                   int32_t width, int32_t height,
+                                   int32_t refresh, int bpp)
+{
+    if (mode->width < width) return -1;
+    if (mode->width > width) return 1;
+    if (mode->height < height) return -1;
+    if (mode->height > height) return 1;
+    if (mode->bpp < bpp) return -1;
+    if (mode->bpp > bpp) return 1;
+    if (mode->refresh < refresh) return -1;
+    if (mode->refresh > refresh) return 1;
+    return 0;
+}
+
+static void wayland_output_add_mode(struct wayland_output *output,
+                                    int32_t width, int32_t height,
+                                    int32_t refresh, int bpp,
+                                    BOOL current, BOOL native)
+{
+    struct wayland_output_mode *mode;
+    struct wl_list *insert_after_link = output->mode_list.prev;
+
+    /* Update mode if it's already in list, otherwise find the insertion point
+     * to maintain the sorted order. */
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        int cmp = wayland_output_mode_cmp(mode, width, height, refresh, bpp);
+        if (cmp == 0) /* mode == new */
+        {
+            /* Upgrade modes from virtual to native, never the reverse. */
+            if (native) mode->native = TRUE;
+            if (current)
+            {
+                output->current_mode = mode;
+                output->current_wine_mode = mode;
+            }
+            return;
+        }
+        else if (cmp == 1) /* mode > new */
+        {
+            insert_after_link = mode->link.prev;
+            break;
+        }
+    }
+
+    mode = calloc(1, sizeof(*mode));
+
+    mode->width = width;
+    mode->height = height;
+    mode->refresh = refresh;
+    mode->bpp = bpp;
+    mode->native = native;
+
+    if (current)
+    {
+        output->current_mode = mode;
+        output->current_wine_mode = mode;
+    }
+
+    wl_list_insert(insert_after_link, &mode->link);
+}
+
+static void wayland_output_add_mode_all_bpp(struct wayland_output *output,
+                                            int32_t width, int32_t height,
+                                            int32_t refresh, BOOL current,
+                                            BOOL native)
+{
+    wayland_output_add_mode(output, width, height, refresh, 32, current, native);
+    wayland_output_add_mode(output, width, height, refresh, 16, FALSE, native);
+    wayland_output_add_mode(output, width, height, refresh, 8, FALSE, native);
+}
+
+static void wayland_output_add_default_modes(struct wayland_output *output)
+{
+    int i;
+    struct wayland_output_mode *mode, *tmp;
+    int32_t max_width = 0;
+    int32_t max_height = 0;
+    int32_t current_refresh =
+        output->current_mode ? output->current_mode->refresh : default_refresh;
+
+    /* Remove all existing virtual modes and get the maximum native
+     * mode size. */
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        if (!mode->native)
+        {
+            wl_list_remove(&mode->link);
+            free(mode);
+        }
+        else
+        {
+            max_width = mode->width > max_width ? mode->width : max_width;
+            max_height = mode->height > max_height ? mode->height : max_height;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(default_modes); i++)
+    {
+        int32_t width = default_modes[i].width;
+        int32_t height = default_modes[i].height;
+
+        /* Skip if this mode is larger than the largest native mode. */
+        if (width > max_width || height > max_height)
+        {
+            TRACE("Skipping mode %dx%d (max: %dx%d)\n",
+                    width, height, max_width, max_height);
+            continue;
+        }
+
+        wayland_output_add_mode_all_bpp(output, width, height, current_refresh,
+                                        FALSE, FALSE);
+    }
+}
+
+static int wayland_output_cmp_x(struct wayland_output *a, struct wayland_output *b)
+{
+    if (a->logical_x < b->logical_x) return -1;
+    if (a->logical_x > b->logical_x) return 1;
+    if (a->logical_y < b->logical_y) return -1;
+    if (a->logical_y > b->logical_y) return 1;
+    return 0;
+}
+
+static int wayland_output_cmp_y(struct wayland_output *a, struct wayland_output *b)
+{
+    if (a->logical_y < b->logical_y) return -1;
+    if (a->logical_y > b->logical_y) return 1;
+    if (a->logical_x < b->logical_x) return -1;
+    if (a->logical_x > b->logical_x) return 1;
+    return 0;
+}
+
+static struct wayland_output** wayland_output_list_sorted(struct wl_list *output_list,
+                                                          int (*cmp)(struct wayland_output *,
+                                                                     struct wayland_output *))
+{
+    int num_outputs = wl_list_length(output_list);
+    int num_sorted = 0;
+    struct wayland_output **sorted;
+    struct wayland_output *o;
+
+    sorted = malloc(sizeof(*sorted) * (num_outputs + 1));
+    if (!sorted)
+    {
+        ERR("Couldn't allocate space for sorted outputs\n");
+        return NULL;
+    }
+
+    wl_list_for_each(o, output_list, link)
+    {
+        int j = num_sorted;
+        while (j > 0 && cmp(o, sorted[j - 1]) < 0)
+        {
+            sorted[j] = sorted[j - 1];
+            j--;
+        }
+        sorted[j] = o;
+        num_sorted++;
+    }
+
+    sorted[num_outputs] = NULL;
+    return sorted;
+}
+
+static void wayland_output_list_update_physical_coords(struct wl_list *output_list)
+{
+    struct wayland_output **sorted_x, **sorted_y;
+    struct wayland_output **cur_p, **prev_p;
+    struct wayland_output *cur, *prev;
+
+    /* Set default physical coordinates. */
+    wl_list_for_each(cur, output_list, link)
+    {
+        cur->x = cur->logical_x;
+        cur->y = cur->logical_y;
+    }
+
+    /* When compositor scaling is used, we treat logical coordinates as
+     * physical. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
+    /* Sort and process the outputs from left to right. */
+    cur_p = sorted_x = wayland_output_list_sorted(output_list, wayland_output_cmp_x);
+    if (!sorted_x) return;
+
+    while ((cur = *cur_p))
+    {
+        /* Update output->x based on other outputs that are to to the left. */
+        prev_p = sorted_x;
+        while ((prev = *prev_p) != cur)
+        {
+            if (cur->logical_x == prev->logical_x + prev->logical_w &&
+                prev->current_mode)
+            {
+                int new_x = prev->x + prev->current_mode->width;
+                if (new_x > cur->x) cur->x = new_x;
+            }
+            prev_p++;
+        }
+
+        cur_p++;
+    }
+
+    free(sorted_x);
+
+    /* Now sort and process the outputs from top to bottom. */
+    cur_p = sorted_y = wayland_output_list_sorted(output_list, wayland_output_cmp_y);
+    if (!sorted_y) return;
+
+    while ((cur = *cur_p))
+    {
+        /* Update output->y based on other outputs that are above. */
+        prev_p = sorted_y;
+        while ((prev = *prev_p) != cur)
+        {
+            if (cur->logical_y == prev->logical_y + prev->logical_h &&
+                prev->current_mode)
+            {
+                int new_y = prev->y + prev->current_mode->height;
+                if (new_y > cur->y) cur->y = new_y;
+            }
+            prev_p++;
+        }
+
+        cur_p++;
+    }
+
+    free(sorted_y);
+}
+
+static void wayland_output_clear_modes(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode, *tmp;
+
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        wl_list_remove(&mode->link);
+        free(mode);
+    }
+}
+
+static void wayland_output_update_scale(struct wayland_output *output)
+{
+    double inferred_scale = 0.0;
+
+    /* When compositor scaling is used, we ignore the output scale, to
+     * allow the the compositor to scale us. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+    {
+        output->scale = 1.0;
+        TRACE("using scale=%.2f to enable compositor scaling\n", output->scale);
+        return;
+    }
+
+    if (output->logical_w != 0 && output->logical_h != 0 &&
+        output->current_mode)
+    {
+        double scale_x = (double)output->current_mode->width / output->logical_w;
+        double scale_y = (double)output->current_mode->height / output->logical_h;
+        if (fabs(scale_x - scale_y) > 0.01)
+            WARN("different scale_x=%f scale_y=%f", scale_x, scale_y);
+        inferred_scale = max(scale_x, scale_y);
+    }
+
+    if (inferred_scale == 0.0 ||
+        (inferred_scale == 1.0 && output->compositor_scale != 1.0))
+    {
+        output->scale = output->compositor_scale;
+        TRACE("using scale=%.2f reported by compositor\n", output->scale);
+    }
+    else
+    {
+        output->scale = inferred_scale;
+        TRACE("using scale=%.2f inferred from physical and logical sizes\n",
+              output->scale);
+    }
+}
+
+static void wayland_output_done(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode;
+    struct wayland_output *o;
+
+    TRACE("output->name=%s\n", output->name);
+
+    /* When compositor scaling is used, the current and only native mode
+     * corresponds to the logical width and height. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+    {
+        int32_t current_refresh =
+            output->current_mode ? output->current_mode->refresh : default_refresh;
+        wayland_output_clear_modes(output);
+        wayland_output_add_mode_all_bpp(output, output->logical_w, output->logical_h,
+                                        current_refresh, TRUE, TRUE);
+    }
+
+    wayland_output_add_default_modes(output);
+    wayland_output_list_update_physical_coords(&output->wayland->output_list);
+    wayland_output_update_scale(output);
+
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        TRACE("mode %dx%d @ %d %s\n",
+              mode->width, mode->height, mode->refresh,
+              output->current_mode == mode ? "*" : "");
+    }
+
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (!o->current_mode) continue;
+        TRACE("output->name=%s scale=%.2f logical=%d,%d+%dx%d physical=%d,%d+%dx%d\n",
+              o->name, o->scale,
+              o->logical_x, output->logical_y, o->logical_w, o->logical_h,
+              o->x, o->y, o->current_mode->width, o->current_mode->height);
+    }
+
+    if (wayland_is_process(output->wayland))
+    {
+        /* Temporarily release the per-process instance lock, so that
+         * wayland_init_display_devices can perform more fine grained locking
+         * to avoid deadlocks. */
+        wayland_process_release();
+        wayland_init_display_devices();
+        wayland_process_acquire();
+    }
+    else
+    {
+        wayland_update_outputs_from_process(output->wayland);
+    }
+}
+
+static void output_handle_geometry(void *data, struct wl_output *wl_output,
+                                   int32_t x, int32_t y,
+                                   int32_t physical_width, int32_t physical_height,
+                                   int32_t subpixel,
+                                   const char *make, const char *model,
+                                   int32_t output_transform)
+{
+}
+
+static void output_handle_mode(void *data, struct wl_output *wl_output,
+                               uint32_t flags, int32_t width, int32_t height,
+                               int32_t refresh)
+{
+    struct wayland_output *output = data;
+
+    /* When compositor scaling is used, we don't use physical width/height
+     * for modes and the current mode will be set based on logical width
+     * and height (see wayland_output_done()). */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
+    /* Windows apps don't expect a zero refresh rate, so use a default value. */
+    if (refresh == 0) refresh = default_refresh;
+
+    wayland_output_add_mode_all_bpp(output, width, height, refresh,
+                                    (flags & WL_OUTPUT_MODE_CURRENT),
+                                    TRUE);
+}
+
+static void output_handle_done(void *data, struct wl_output *wl_output)
+{
+    struct wayland_output *output = data;
+    if (!output->zxdg_output_v1 ||
+        zxdg_output_v1_get_version(output->zxdg_output_v1) >= 3)
+    {
+        wayland_output_done(output);
+    }
+}
+
+static void output_handle_scale(void *data, struct wl_output *wl_output,
+                                int32_t scale)
+{
+    struct wayland_output *output = data;
+    TRACE("output=%p scale=%d\n", output, scale);
+    output->compositor_scale = scale;
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale
+};
+
+static void zxdg_output_v1_handle_logical_position(void *data,
+                                                   struct zxdg_output_v1 *zxdg_output_v1,
+                                                   int32_t x,
+                                                   int32_t y)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_x=%d logical_y=%d\n", x, y);
+    output->logical_x = x;
+    output->logical_y = y;
+}
+
+static void zxdg_output_v1_handle_logical_size(void *data,
+                                               struct zxdg_output_v1 *zxdg_output_v1,
+                                               int32_t width,
+                                               int32_t height)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_w=%d logical_h=%d\n", width, height);
+    output->logical_w = width;
+    output->logical_h = height;
+}
+
+static void zxdg_output_v1_handle_done(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1)
+{
+    if (zxdg_output_v1_get_version(zxdg_output_v1) < 3)
+    {
+        struct wayland_output *output = data;
+        wayland_output_done(output);
+    }
+}
+
+static void zxdg_output_v1_handle_name(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1,
+                                       const char *name)
+{
+    struct wayland_output *output = data;
+
+    free(output->name);
+    output->name = strdup(name);
+}
+
+static void zxdg_output_v1_handle_description(void *data,
+                                              struct zxdg_output_v1 *zxdg_output_v1,
+                                              const char *description)
+{
+}
+
+static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
+    zxdg_output_v1_handle_logical_position,
+    zxdg_output_v1_handle_logical_size,
+    zxdg_output_v1_handle_done,
+    zxdg_output_v1_handle_name,
+    zxdg_output_v1_handle_description,
+};
+
+/**********************************************************************
+ *          wayland_output_create
+ *
+ *  Creates a wayland_output and adds it to the output list.
+ */
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version)
+{
+    struct wayland_output *output = calloc(1, sizeof(*output));
+
+    if (!output)
+    {
+        ERR("Couldn't allocate space for wayland_output\n");
+        goto err;
+    }
+
+    output->wayland = wayland;
+    output->wl_output = wl_registry_bind(wayland->wl_registry, id,
+                                         &wl_output_interface,
+                                         version < 2 ? version : 2);
+    output->global_id = id;
+    wl_output_add_listener(output->wl_output, &output_listener, output);
+
+    wl_list_init(&output->mode_list);
+    wl_list_init(&output->link);
+
+    output->compositor_scale = 1.0;
+    output->scale = 1.0;
+    output->wine_scale = 1.0;
+
+    /* Have a fallback in case xdg_output is not supported or name is not sent. */
+    output->name = malloc(20);
+    if (output->name)
+    {
+        snprintf(output->name, 20, "WaylandOutput%d",
+                 wayland->next_fallback_output_id++);
+    }
+    else
+    {
+        ERR("Couldn't allocate space for output name\n");
+        goto err;
+    }
+
+    if (wayland->zxdg_output_manager_v1)
+        wayland_output_use_xdg_extension(output);
+
+    wl_list_insert(output->wayland->output_list.prev, &output->link);
+
+    return TRUE;
+
+err:
+    if (output) wayland_output_destroy(output);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_output_destroy
+ *
+ *  Destroys a wayland_output.
+ */
+void wayland_output_destroy(struct wayland_output *output)
+{
+    wayland_output_clear_modes(output);
+    wl_list_remove(&output->link);
+    free(output->name);
+    if (output->zxdg_output_v1)
+        zxdg_output_v1_destroy(output->zxdg_output_v1);
+    wl_output_destroy(output->wl_output);
+
+    free(output);
+}
+
+/**********************************************************************
+ *          wayland_output_use_xdg_extension
+ *
+ *  Use the zxdg_output_v1 extension to get output information.
+ */
+void wayland_output_use_xdg_extension(struct wayland_output *output)
+{
+    output->zxdg_output_v1 =
+        zxdg_output_manager_v1_get_xdg_output(output->wayland->zxdg_output_manager_v1,
+                                              output->wl_output);
+    zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
+                                output);
+}
+
+/**********************************************************************
+ *          wayland_update_outputs_from_process
+ *
+ * Update the information in the outputs of this instance, using the
+ * information in the process wayland instance.
+ */
+void wayland_update_outputs_from_process(struct wayland *wayland)
+{
+    struct wayland_output *output;
+    struct wayland_output *process_output;
+    struct wayland *process_wayland = wayland_process_acquire();
+
+    TRACE("wayland=%p process_wayland=%p\n", wayland, process_wayland);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        wl_list_for_each(process_output, &process_wayland->output_list, link)
+        {
+            if (!strcmp(output->name, process_output->name))
+            {
+                lstrcpyW(output->wine_name, process_output->wine_name);
+                wayland_output_set_wine_mode(output,
+                                             process_output->current_wine_mode);
+                break;
+            }
+        }
+    }
+
+    wayland_process_release();
+}
+
+/**********************************************************************
+ *          wayland_output_get_by_wine_name
+ *
+ *  Returns the wayland_output with the specified Wine name (or NULL
+ *  if not present).
+ */
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!wcsicmp(wine_name, output->wine_name))
+            return output;
+    }
+
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_output_set_wine_mode
+ *
+ * Set the current wine mode for the specified output. Note that
+ * the provided mode struct argument is used only as a reference to get
+ * mode information from.
+ */
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  struct wayland_output_mode *ref_mode)
+{
+    struct wayland_output_mode *output_mode;
+
+    TRACE("output->name=%s %dx%d@%d %dbpp\n",
+          output->name, ref_mode->width, ref_mode->height,
+          ref_mode->refresh, ref_mode->bpp);
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (output_mode->width == ref_mode->width &&
+            output_mode->height == ref_mode->height &&
+            output_mode->bpp == ref_mode->bpp &&
+            output_mode->refresh == ref_mode->refresh)
+        {
+            output->current_wine_mode = output_mode;
+            break;
+        }
+    }
+
+    if (!output->current_wine_mode || !output->current_mode)
+    {
+        output->wine_scale = 1.0;
+    }
+    else
+    {
+        double scale_x = ((double)output->current_mode->width) /
+                         output->current_wine_mode->width;
+        double scale_y = ((double)output->current_mode->height) /
+                         output->current_wine_mode->height;
+        /* We want to keep the aspect ratio of the target mode. */
+        output->wine_scale = fmin(scale_x, scale_y);
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
new file mode 100644
index 00000000000..de6544ae91b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -0,0 +1,350 @@
+/*
+ * Wayland input handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <linux/input.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          Pointer handling
+ */
+
+static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointer,
+                                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    int screen_x, screen_y;
+    RECT screen_rect;
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_screen(wayland->pointer.focused_surface,
+                                     wl_fixed_to_double(sx),
+                                     wl_fixed_to_double(sy),
+                                     &screen_x, &screen_y);
+
+    /* Sometimes, due to rounding, we may end up with pointer coordinates
+     * slightly outside the target window, so bring them within bounds. */
+    if (NtUserGetWindowRect(focused_hwnd, &screen_rect))
+    {
+        if (screen_x >= screen_rect.right) screen_x = screen_rect.right - 1;
+        else if (screen_x < screen_rect.left) screen_x = screen_rect.left;
+        if (screen_y >= screen_rect.bottom) screen_y = screen_rect.bottom - 1;
+        else if (screen_y < screen_rect.top) screen_y = screen_rect.top;
+    }
+
+    TRACE("surface=%p hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_double(sx), wl_fixed_to_double(sy),
+          screen_x, screen_y);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = screen_x;
+    input.mi.dy          = screen_y;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
+                                  uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+
+    /* Don't handle absolute motion events if we are in relative mode. */
+    if (wayland->pointer.zwp_relative_pointer_v1)
+        return;
+
+    pointer_handle_motion_internal(data, pointer, time, sx, sy);
+}
+
+static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface,
+                                 wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since pointer events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
+        wayland->pointer.focused_surface = wayland_surface;
+        wayland->pointer.enter_serial = serial;
+        wayland_reapply_thread_cursor();
+        /* Handle the enter as a motion, to account for cases where the
+         * window first appears beneath the pointer and won't get a separate
+         * motion event. */
+        pointer_handle_motion_internal(data, pointer, 0, sx, sy);
+    }
+}
+
+static void pointer_handle_leave(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+
+    if (wayland->pointer.focused_surface &&
+        wayland->pointer.focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n",
+              wayland->pointer.focused_surface,
+              wayland->pointer.focused_surface->hwnd);
+        wayland->pointer.focused_surface = NULL;
+        wayland->pointer.enter_serial = 0;
+    }
+}
+
+static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+                                  uint32_t serial, uint32_t time, uint32_t button,
+                                  uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("button=%#x state=%#x hwnd=%p\n", button, state, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (button)
+    {
+    case BTN_LEFT: input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN; break;
+    case BTN_RIGHT: input.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN; break;
+    case BTN_MIDDLE: input.mi.dwFlags = MOUSEEVENTF_MIDDLEDOWN; break;
+    default: break;
+    }
+
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+        input.mi.dwFlags <<= 1;
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+        wayland->last_button_serial = serial;
+    else
+        wayland->last_button_serial = 0;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+                                uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
+{
+}
+
+static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
+                                       uint32_t axis_source)
+{
+}
+
+static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
+                                     uint32_t time, uint32_t axis)
+{
+}
+
+static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+                                         uint32_t axis, int32_t discrete)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("axis=%#x discrete=%d hwnd=%p\n", axis, discrete, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+        input.mi.mouseData = -WHEEL_DELTA * discrete;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+        input.mi.mouseData = WHEEL_DELTA * discrete;
+        break;
+    default: break;
+    }
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,
+    pointer_handle_leave,
+    pointer_handle_motion,
+    pointer_handle_button,
+    pointer_handle_axis,
+    pointer_handle_frame,
+    pointer_handle_axis_source,
+    pointer_handle_axis_stop,
+    pointer_handle_axis_discrete,
+};
+
+static void relative_pointer_handle_motion(void *data,
+                                           struct zwp_relative_pointer_v1 *rpointer,
+                                           uint32_t utime_hi,
+                                           uint32_t utime_lo,
+                                           wl_fixed_t dx,
+                                           wl_fixed_t dy,
+                                           wl_fixed_t dx_unaccel,
+                                           wl_fixed_t dy_unaccel)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    int wine_dx, wine_dy;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_wine(wayland->pointer.focused_surface,
+                                   wl_fixed_to_int(dx), wl_fixed_to_int(dy),
+                                   &wine_dx, &wine_dy);
+
+    TRACE("surface=%p hwnd=%p wayland_dxdy=%d,%d wine_dxdy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_int(dx), wl_fixed_to_int(dy), wine_dx, wine_dy);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = wine_dx;
+    input.mi.dy          = wine_dy;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
+    relative_pointer_handle_motion,
+};
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer)
+{
+    wayland->pointer.wayland = wayland;
+    wayland->pointer.wl_pointer = wl_pointer;
+    wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+    wayland->pointer.cursor_wl_surface =
+        wl_compositor_create_surface(wayland->wl_compositor);
+    if (wayland->wp_viewporter)
+    {
+        wayland->pointer.cursor_wp_viewport =
+            wp_viewporter_get_viewport(wayland->wp_viewporter,
+                                       wayland->pointer.cursor_wl_surface);
+    }
+    else
+    {
+        wayland->pointer.cursor_wp_viewport = NULL;
+    }
+    pointer->zwp_relative_pointer_v1 = NULL;
+}
+
+void wayland_pointer_deinit(struct wayland_pointer *pointer)
+{
+    if (pointer->zwp_relative_pointer_v1)
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+
+    if (pointer->wl_pointer)
+        wl_pointer_destroy(pointer->wl_pointer);
+
+    if (pointer->cursor_wp_viewport)
+        wp_viewport_destroy(pointer->cursor_wp_viewport);
+
+    if (pointer->cursor_wl_surface)
+        wl_surface_destroy(pointer->cursor_wl_surface);
+
+    if (pointer->cursor)
+        wayland_cursor_destroy(pointer->cursor);
+
+    memset(pointer, 0, sizeof(*pointer));
+}
+
+/**********************************************************************
+ *          wayland_pointer_set_relative
+ *
+ * Set whether the pointer emits relative (if able) or absolute motion events.
+ * The default is to emit absolute motion events.
+ */
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative)
+{
+    if (!pointer->wayland->zwp_relative_pointer_manager_v1)
+        return;
+
+    if (!pointer->zwp_relative_pointer_v1 && relative)
+    {
+        pointer->zwp_relative_pointer_v1 =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+                pointer->wayland->zwp_relative_pointer_manager_v1,
+                pointer->wl_pointer);
+
+        zwp_relative_pointer_v1_add_listener(pointer->zwp_relative_pointer_v1,
+                                             &zwp_relative_pointer_v1_listener,
+                                             pointer->wayland);
+    }
+    else if (pointer->zwp_relative_pointer_v1 && !relative)
+    {
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+        pointer->zwp_relative_pointer_v1 = NULL;
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_remote.c b/dlls/winewayland.drv/wayland_remote.c
new file mode 100644
index 00000000000..306368efc9b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_remote.c
@@ -0,0 +1,990 @@
+/*
+ * Wayland remote (cross-process) rendering
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <inttypes.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+enum wayland_remote_surface_message
+{
+    WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS,
+};
+
+struct wayland_remote_surface
+{
+    struct wl_list link;
+    int ref;
+    enum wayland_remote_surface_type type;
+    struct wl_event_queue *wl_event_queue;
+    struct wayland_surface *wayland_surface;
+    struct wl_list buffer_list;
+    struct wl_list throttle_list;
+};
+
+struct wayland_remote_buffer
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wl_buffer *wl_buffer;
+    HANDLE released_event;
+};
+
+struct wayland_remote_throttle
+{
+    struct wl_list link;
+    struct wl_callback *wl_callback;
+    HANDLE event;
+};
+
+struct params_type
+{
+    enum wayland_remote_surface_type type;
+};
+
+struct params_buffer
+{
+    struct params_type params_type;
+    enum wayland_remote_buffer_type buffer_type;
+    int plane_count;
+    HANDLE fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    int width, height;
+    int format;
+    uint64_t modifier;
+    HANDLE released_event;
+    HANDLE throttle_event;
+};
+
+struct wayland_remote_surface_proxy
+{
+    HWND hwnd;
+    enum wayland_remote_surface_type type;
+};
+
+static struct wayland_mutex wayland_remote_surface_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": wayland_remote_surface_mutex"
+};
+
+static struct wl_list wayland_remote_surfaces = { &wayland_remote_surfaces, &wayland_remote_surfaces };
+static struct wl_list wayland_remote_buffers = { &wayland_remote_buffers, &wayland_remote_buffers};
+
+static void wayland_remote_buffer_destroy(struct wayland_remote_buffer *remote_buffer)
+{
+    TRACE("remote_buffer=%p released_event=%p\n",
+          remote_buffer, remote_buffer->released_event);
+    if (remote_buffer->released_event)
+    {
+        wl_list_remove(&remote_buffer->link);
+        NtSetEvent(remote_buffer->released_event, NULL);
+        NtClose(remote_buffer->released_event);
+    }
+    else
+    {
+        /* Detached remote buffers are stored in the global
+         * wayland_remote_buffers list, and require locking. */
+        wayland_mutex_lock(&wayland_remote_surface_mutex);
+        wl_list_remove(&remote_buffer->link);
+        wayland_mutex_unlock(&wayland_remote_surface_mutex);
+    }
+    wl_buffer_destroy(remote_buffer->wl_buffer);
+    free(remote_buffer);
+}
+
+static void remote_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_remote_buffer *remote_buffer =
+        (struct wayland_remote_buffer *) data;
+
+    TRACE("released_event=%p\n", remote_buffer->released_event);
+    wayland_remote_buffer_destroy(remote_buffer);
+}
+
+static const struct wl_buffer_listener remote_buffer_listener = {
+    remote_buffer_release
+};
+
+static struct wayland_remote_buffer *wayland_remote_buffer_create(struct wayland_remote_surface *remote,
+                                                                  struct wl_buffer *wl_buffer,
+                                                                  HANDLE released_event)
+{
+    struct wayland_remote_buffer *remote_buffer = calloc(1, sizeof(*remote_buffer));
+    if (!remote_buffer)
+    {
+        ERR("Failed to allocate memory for remote buffer\n");
+        return NULL;
+    }
+
+    remote_buffer->hwnd = remote->wayland_surface->hwnd;
+    remote_buffer->wl_buffer = wl_buffer;
+
+    if (released_event)
+    {
+        /* Non-detached buffers are dispatched from remote surface event queue
+         * so that we can dispatch events on demand (see
+         * WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS). */
+        wl_proxy_set_queue((struct wl_proxy *) remote_buffer->wl_buffer,
+                           remote->wl_event_queue);
+        wl_list_insert(&remote->buffer_list, &remote_buffer->link);
+        remote_buffer->released_event = released_event;
+    }
+    else
+    {
+        /* Detached buffers are dispatched from the default thread queue and
+         * are stored in wayland_remote_buffers, in order to not be destroyed
+         * along with their remote surface. We don't need to explicitly lock to
+         * insert to this list at this point, since having a remote surface
+         * implies a locked wayland_remote_surface_mutex. */
+        wl_list_insert(&wayland_remote_buffers, &remote_buffer->link);
+    }
+
+    wl_buffer_add_listener(remote_buffer->wl_buffer,
+                           &remote_buffer_listener, remote_buffer);
+
+    return remote_buffer;
+}
+
+static void wayland_remote_throttle_destroy(struct wayland_remote_throttle *remote_throttle)
+{
+    wl_list_remove(&remote_throttle->link);
+
+    wl_callback_destroy(remote_throttle->wl_callback);
+
+    if (remote_throttle->event)
+    {
+        NtSetEvent(remote_throttle->event, NULL);
+        NtClose(remote_throttle->event);
+    }
+
+    free(remote_throttle);
+}
+
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_remote_throttle *remote_throttle = data;
+
+    TRACE("throttle_event=%p\n", remote_throttle->event);
+
+    wayland_remote_throttle_destroy(remote_throttle);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
+static struct wayland_remote_throttle *wayland_remote_throttle_create(struct wayland_remote_surface *remote,
+                                                                      struct wl_callback *wl_callback,
+                                                                      HANDLE throttle_event)
+{
+    struct wayland_remote_throttle *remote_throttle = calloc(1, sizeof(*remote_throttle));
+    if (!remote_throttle)
+    {
+        ERR("Failed to allocate memory for remote throttle\n");
+        return NULL;
+    }
+    remote_throttle->wl_callback = wl_callback;
+    remote_throttle->event = throttle_event;
+
+    wl_proxy_set_queue((struct wl_proxy *) remote_throttle->wl_callback,
+                        remote->wl_event_queue);
+    wl_callback_add_listener(remote_throttle->wl_callback, &throttle_listener,
+                             remote_throttle);
+    wl_list_insert(&remote->throttle_list, &remote_throttle->link);
+
+    return remote_throttle;
+}
+
+static void wayland_remote_surface_destroy(struct wayland_remote_surface *remote)
+{
+    struct wayland_remote_buffer *buffer, *buffer_tmp;
+    struct wayland_remote_throttle *throttle, *throttle_tmp;
+
+    TRACE("remote=%p\n", remote);
+
+    wl_list_remove(&remote->link);
+
+    wl_list_for_each_safe(buffer, buffer_tmp, &remote->buffer_list, link)
+        wayland_remote_buffer_destroy(buffer);
+
+    wl_list_for_each_safe(throttle, throttle_tmp, &remote->throttle_list, link)
+        wayland_remote_throttle_destroy(throttle);
+
+    if (remote->wl_event_queue) wl_event_queue_destroy(remote->wl_event_queue);
+    if (remote->wayland_surface)
+    {
+        switch (remote->type)
+        {
+        case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+            wayland_surface_unref(remote->wayland_surface);
+            break;
+        case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+            wayland_surface_unref_glvk(remote->wayland_surface);
+            break;
+        default:
+            ERR("Invalid surface type %d\n", remote->type);
+            break;
+        }
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+    free(remote);
+}
+
+static struct wayland_remote_surface *wayland_remote_surface_create(struct wayland_surface *wayland_surface,
+                                                                    enum wayland_remote_surface_type type)
+{
+    struct wayland_remote_surface *remote;
+
+    remote = calloc(1, sizeof(*remote));
+    if (!remote)
+    {
+        ERR("Failed to allocate memory for remote surface hwnd=%p type=%d\n",
+            wayland_surface->hwnd, type);
+        goto err;
+    }
+
+    remote->ref = 1;
+    remote->type = type;
+    wl_list_init(&remote->buffer_list);
+    wl_list_init(&remote->throttle_list);
+
+    remote->wl_event_queue = wl_display_create_queue(wayland_surface->wayland->wl_display);
+    if (!remote->wl_event_queue)
+    {
+        ERR("Failed to create wl_event_queue for remote surface hwnd=%p type=%d\n",
+            wayland_surface->hwnd, type);
+        goto err;
+    }
+
+    switch (type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wayland_surface_ref(wayland_surface);
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        if (!wayland_surface_create_or_ref_glvk(wayland_surface))
+        {
+            ERR("Failed to create GL/VK for remote surface hwnd=%p type=%d\n",
+                wayland_surface->hwnd, type);
+            goto err;
+        }
+        break;
+    default:
+        ERR("Invalid surface type %d\n", type);
+        goto err;
+    }
+
+    remote->wayland_surface = wayland_surface;
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    wl_list_insert(&wayland_remote_surfaces, &remote->link);
+
+    return remote;
+
+err:
+    if (remote) wayland_remote_surface_destroy(remote);
+    return NULL;
+}
+
+static struct wayland_remote_surface *wayland_remote_surface_get(HWND hwnd,
+                                                                 enum wayland_remote_surface_type type)
+{
+    struct wayland_remote_surface *remote;
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    wl_list_for_each(remote, &wayland_remote_surfaces, link)
+    {
+        if (remote->wayland_surface->hwnd == hwnd && remote->type == type)
+            return remote;
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+
+    return NULL;
+}
+
+static void wayland_remote_surface_release(struct wayland_remote_surface *remote)
+{
+    if (remote) wayland_mutex_unlock(&wayland_remote_surface_mutex);
+}
+
+static void wayland_remote_surface_ref(struct wayland_remote_surface *remote)
+{
+    remote->ref++;
+}
+
+static void wayland_remote_surface_unref(struct wayland_remote_surface *remote)
+{
+    remote->ref--;
+    if (remote->ref == 0)
+        wayland_remote_surface_destroy(remote);
+    else
+        wayland_remote_surface_release(remote);
+}
+
+static BOOL wayland_remote_surface_commit(struct wayland_remote_surface *remote,
+                                          struct wayland_remote_buffer *remote_buffer,
+                                          HANDLE throttle_event)
+{
+    BOOL ret = FALSE;
+    struct wl_surface *wl_surface;
+
+    wayland_mutex_lock(&remote->wayland_surface->mutex);
+
+    TRACE("remote=%p wayland_surface=%p glvk=%p drawing_allowed=%d\n",
+          remote, remote->wayland_surface, remote->wayland_surface->glvk,
+          remote->wayland_surface->drawing_allowed);
+
+    switch (remote->type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wl_surface = remote->wayland_surface->wl_surface;
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        wl_surface = remote->wayland_surface->glvk ?
+                     remote->wayland_surface->glvk->wl_surface : NULL;
+        break;
+    default:
+        ERR("Invalid surface type %d\n", remote->type);
+        goto out;
+    }
+
+    if (remote->wayland_surface->drawing_allowed && wl_surface)
+    {
+        wayland_surface_ensure_mapped(remote->wayland_surface);
+        wl_surface_attach(wl_surface, remote_buffer->wl_buffer, 0, 0);
+        wl_surface_damage_buffer(wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (throttle_event &&
+            !wayland_remote_throttle_create(remote, wl_surface_frame(wl_surface),
+                                            throttle_event))
+        {
+            NtSetEvent(throttle_event, NULL);
+            NtClose(throttle_event);
+        }
+        wl_surface_commit(wl_surface);
+        ret = TRUE;
+    }
+
+out:
+    wayland_mutex_unlock(&remote->wayland_surface->mutex);
+
+    return ret;
+}
+
+static void *map_shm_from_handle(HANDLE params, size_t size)
+{
+    int shm_fd = -1;
+    void *data = NULL;
+
+    if (wine_server_handle_to_fd(params, FILE_READ_DATA, &shm_fd, NULL) != STATUS_SUCCESS)
+    {
+        ERR("Failed to get SHM fd from Wine handle.\n");
+        goto out;
+    }
+
+    data = mmap(NULL, size, PROT_READ, MAP_SHARED, shm_fd, 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("Failed to map SHM fd.\n");
+        data = NULL;
+    }
+
+out:
+    if (shm_fd >= 0) close(shm_fd);
+
+    return data;
+}
+
+static void wayland_remote_surface_update_wayland_surface(struct wayland_remote_surface *remote,
+                                                          struct wayland_surface *wayland_surface)
+{
+    switch (remote->type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wayland_surface_ref(wayland_surface);
+        wayland_surface_unref(remote->wayland_surface);
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        if (!wayland_surface_create_or_ref_glvk(wayland_surface)) return;
+        wayland_surface_unref_glvk(remote->wayland_surface);
+        break;
+    default:
+        ERR("Invalid surface type %d\n", remote->type);
+        return;
+    }
+    remote->wayland_surface = wayland_surface;
+}
+
+static void wayland_remote_surface_handle_create(struct wayland_remote_surface *remote,
+                                                 struct wayland_surface *wayland_surface,
+                                                 struct params_type *params)
+{
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (remote)
+    {
+        wayland_remote_surface_ref(remote);
+        return;
+    }
+
+    remote = wayland_remote_surface_create(wayland_surface, params->type);
+    if (!remote)
+    {
+        ERR("Failed to create remote surface for hwnd=%p type=%d\n",
+            wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_remote_surface_release(remote);
+}
+
+static void wayland_remote_surface_handle_destroy(struct wayland_remote_surface *remote,
+                                                  struct wayland_surface *wayland_surface,
+                                                  struct params_type *params)
+{
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_remote_surface_unref(remote);
+}
+
+static BOOL _wayland_native_buffer_init_params(struct wayland_native_buffer *native,
+                                               struct params_buffer *params)
+{
+    int i;
+
+    native->plane_count = params->plane_count;
+    native->width = params->width;
+    native->height = params->height;
+    native->format = params->format;
+    native->modifier = params->modifier;
+
+    for (i = 0; i < native->plane_count; i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        NTSTATUS ret;
+
+        ret = wine_server_handle_to_fd(params->fds[i], GENERIC_READ | SYNCHRONIZE,
+                                       &native->fds[i], NULL);
+        if (ret != STATUS_SUCCESS)
+        {
+            ERR("Failed to get fd from handle ret=%#x\n", (int)ret);
+            goto err;
+        }
+
+        native->strides[i] = params->strides[i];
+        native->offsets[i] = params->offsets[i];
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
+static void wayland_remote_surface_handle_commit(struct wayland_remote_surface *remote,
+                                                 struct wayland_surface *wayland_surface,
+                                                 struct params_buffer *params)
+{
+    struct wayland_native_buffer native;
+    struct wl_buffer *wl_buffer = NULL;
+    struct wayland_remote_buffer *remote_buffer = NULL;
+
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->params_type.type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->params_type.type);
+        goto err;
+    }
+
+    if (!_wayland_native_buffer_init_params(&native, params))
+    {
+        ERR("Failed to initialize native buffer\n");
+        goto err;
+    }
+
+    switch (params->buffer_type)
+    {
+    case WAYLAND_REMOTE_BUFFER_TYPE_SHM:
+        {
+            struct wayland_shm_buffer *shm_buffer =
+                wayland_shm_buffer_create_from_native(remote->wayland_surface->wayland,
+                                                      &native);
+            if (shm_buffer)
+                wl_buffer = wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+        }
+        break;
+    case WAYLAND_REMOTE_BUFFER_TYPE_DMABUF:
+        {
+            struct wayland_dmabuf_buffer *dmabuf_buffer =
+                wayland_dmabuf_buffer_create_from_native(remote->wayland_surface->wayland,
+                                                         &native);
+            if (dmabuf_buffer)
+                wl_buffer = wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(dmabuf_buffer);
+        }
+        break;
+    default:
+        ERR("Invalid buffer type %d\n", params->buffer_type);
+        goto err;
+    }
+
+    wayland_native_buffer_deinit(&native);
+    if (!wl_buffer)
+    {
+        ERR("Failed to create wl_buffer\n");
+        goto err;
+    }
+
+    remote_buffer = wayland_remote_buffer_create(remote, wl_buffer, params->released_event);
+
+    if (!wayland_remote_surface_commit(remote, remote_buffer, params->throttle_event))
+        goto err;
+
+    return;
+
+err:
+    if (params->released_event)
+    {
+        NtSetEvent(params->released_event, NULL);
+        NtClose(params->released_event);
+    }
+    if (params->throttle_event)
+    {
+        NtSetEvent(params->throttle_event, NULL);
+        NtClose(params->throttle_event);
+    }
+    if (remote_buffer) wayland_remote_buffer_destroy(remote_buffer);
+}
+
+static void wayland_remote_surface_handle_dispatch_events(struct wayland_remote_surface *remote,
+                                                          struct wayland_surface *wayland_surface,
+                                                          struct params_type *params)
+{
+
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_dispatch_queue(remote->wl_event_queue, 0);
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_handle_message
+ *
+ *  Handles a message sent to our remote surface infrastructure.
+ */
+void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
+                                           WPARAM message, LPARAM params_long)
+{
+    HANDLE params_handle = LongToHandle(params_long);
+    void *params = NULL;
+    size_t params_size;
+    struct wayland_remote_surface *remote = NULL;
+
+    TRACE("message=%ld params=%p\n", (long)message, params_handle);
+
+    switch (message)
+    {
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE:
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY:
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS:
+        params_size = sizeof(struct params_type);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT:
+        params_size = sizeof(struct params_buffer);
+        break;
+    default:
+        goto out;
+    }
+
+    params = map_shm_from_handle(params_handle, sizeof(struct params_type));
+    if (!params) goto out;
+
+    remote = wayland_remote_surface_get(wayland_surface->hwnd,
+                                        ((struct params_type *) params)->type);
+    if (remote)
+        wayland_remote_surface_update_wayland_surface(remote, wayland_surface);
+
+    switch (message)
+    {
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE:
+        wayland_remote_surface_handle_create(remote, wayland_surface, params);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY:
+        wayland_remote_surface_handle_destroy(remote, wayland_surface, params);
+        remote = NULL;
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT:
+        wayland_remote_surface_handle_commit(remote, wayland_surface, params);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS:
+        wayland_remote_surface_handle_dispatch_events(remote, wayland_surface, params);
+        break;
+    }
+
+out:
+    if (remote) wayland_remote_surface_release(remote);
+    if (params) munmap(params, params_size);
+    if (params_handle) NtClose(params_handle);
+}
+
+/**********************************************************************
+ *          wayland_destroy_remote_surfaces
+ *
+ *  Destroys remote surfaces targeting a window.
+ */
+void wayland_destroy_remote_surfaces(HWND hwnd)
+{
+    struct wayland_remote_surface *remote, *tmp;
+    struct wayland_remote_buffer *remote_buf, *tmp_buf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    /* Destroy any detached remote buffers for the window. */
+    wl_list_for_each_safe(remote_buf, tmp_buf, &wayland_remote_buffers, link)
+    {
+        if (remote_buf->hwnd == hwnd)
+            wayland_remote_buffer_destroy(remote_buf);
+    }
+    /* Destroy any remote surfaces for the window. */
+    wl_list_for_each_safe(remote, tmp, &wayland_remote_surfaces, link)
+    {
+        if (remote->wayland_surface->hwnd == hwnd)
+        {
+            /* wayland_remote_surface_destroy() unlocks the surface mutex,
+             * since it assumes that that the passed remote was acquired
+             * with wayland_remote_surface_get(). Lock the mutex manually
+             * to maintain the proper lock count. */
+            wayland_mutex_lock(&wayland_remote_surface_mutex);
+            wayland_remote_surface_destroy(remote);
+        }
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+}
+
+static HANDLE remote_handle_from_local(HANDLE local_handle, HWND remote_hwnd)
+{
+    HANDLE remote_handle = 0;
+    HANDLE remote_process = 0;
+    DWORD remote_process_id;
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(OBJECT_ATTRIBUTES) };
+    CLIENT_ID cid;
+
+    if (!NtUserGetWindowThread(remote_hwnd, &remote_process_id)) return 0;
+
+    cid.UniqueProcess = ULongToHandle(remote_process_id);
+
+    if (NtOpenProcess(&remote_process, PROCESS_DUP_HANDLE, &attr, &cid) ||
+        !remote_process)
+    {
+        ERR("Failed to open process with id %#x\n", (UINT)remote_process_id);
+        return 0;
+    }
+
+    if (NtDuplicateObject(GetCurrentProcess(), local_handle, remote_process,
+                          &remote_handle, 0, 0, DUPLICATE_SAME_ACCESS))
+    {
+        ERR("Failed to duplicate handle in remote process\n");
+    }
+
+    NtClose(remote_process);
+
+    return remote_handle;
+}
+
+static HANDLE remote_handle_from_fd(int fd, HWND remote_hwnd)
+{
+    HANDLE local_fd_handle = 0;
+    HANDLE remote_fd_handle = 0;
+
+    if (wine_server_fd_to_handle(fd, GENERIC_READ | SYNCHRONIZE, 0,
+                                 &local_fd_handle) != STATUS_SUCCESS)
+    {
+        ERR("Failed to get handle from fd\n");
+        goto out;
+    }
+
+    remote_fd_handle = remote_handle_from_local(local_fd_handle, remote_hwnd);
+
+out:
+    if (local_fd_handle) NtClose(local_fd_handle);
+
+    return remote_fd_handle;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_create
+ *
+ *  Creates a proxy for rendering to a remote surface.
+ */
+struct wayland_remote_surface_proxy *wayland_remote_surface_proxy_create(HWND hwnd,
+                                                                         enum wayland_remote_surface_type type)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+    struct wayland_remote_surface_proxy *proxy;
+
+    TRACE("hwnd=%p type=%d\n", hwnd, type);
+
+    proxy = calloc(1, sizeof(*proxy));
+    if (!proxy) return NULL;
+
+    proxy->hwnd = hwnd;
+    proxy->type = type;
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-create-glvk", sizeof(*params));
+    if (params_fd < 0) goto err;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto err;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, hwnd);
+    if (!remote_params_handle) goto err;
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE,
+                      HandleToLong(remote_params_handle));
+
+    close(params_fd);
+
+    TRACE("hwnd=%p type=%d => proxy=%p\n", hwnd, type, proxy);
+
+    return proxy;
+
+err:
+    if (params_fd >= 0) close(params_fd);
+    if (proxy) free(proxy);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_destroy
+ *
+ *  Destroys a proxy to a remote surface.
+ */
+void wayland_remote_surface_proxy_destroy(struct wayland_remote_surface_proxy *proxy)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+
+    TRACE("proxy=%p hwnd=%p type=%d\n", proxy, proxy->hwnd, proxy->type);
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-destroy", sizeof(*params));
+    if (params_fd < 0) goto out;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto out;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto out;
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY,
+                      HandleToLong(remote_params_handle));
+
+out:
+    if (params_fd >= 0) close(params_fd);
+    free(proxy);
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_commit
+ *
+ *  Commits a dmabuf to the surface targeted by the remote surface proxy.
+ *
+ *  Returns a handle to an Event that will be set when the committed buffer
+ *  can be reused.
+ */
+BOOL wayland_remote_surface_proxy_commit(struct wayland_remote_surface_proxy *proxy,
+                                         struct wayland_native_buffer *native,
+                                         enum wayland_remote_buffer_type buffer_type,
+                                         enum wayland_remote_buffer_commit commit,
+                                         HANDLE *buffer_released_event_out,
+                                         HANDLE *throttle_event_out)
+{
+    int params_fd;
+    struct params_buffer *params = MAP_FAILED;
+    HANDLE local_released_event = 0;
+    HANDLE local_throttle_event = 0;
+    HANDLE remote_params_handle;
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(attr), .Attributes = OBJ_OPENIF };
+    int i;
+
+    TRACE("proxy=%p hwnd=%p type=%d commit=%d\n",
+          proxy, proxy->hwnd, proxy->type, commit);
+
+    /* Create buffer params */
+    params_fd = wayland_shmfd_create("wayland-remote-surface-commit", sizeof(*params));
+    if (params_fd < 0) goto err;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto err;
+
+    /* Populate buffer params */
+    params->params_type.type = proxy->type;
+    params->buffer_type = buffer_type;
+    params->plane_count = native->plane_count;
+    for (i = 0; i < native->plane_count; i++)
+    {
+        params->fds[i] = remote_handle_from_fd(native->fds[i], proxy->hwnd);
+        if (!params->fds[i]) goto err;
+        params->strides[i] = native->strides[i];
+        params->offsets[i] = native->offsets[i];
+    }
+    params->width = native->width;
+    params->height = native->height;
+    params->format = native->format;
+    params->modifier = native->modifier;
+
+    if (commit != WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED)
+    {
+        if (NtCreateEvent(&local_released_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE) ||
+            !local_released_event)
+        {
+            goto err;
+        }
+        params->released_event = remote_handle_from_local(local_released_event, proxy->hwnd);
+        if (!params->released_event) goto err;
+    }
+
+    if (commit == WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED)
+    {
+        if (NtCreateEvent(&local_throttle_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE) ||
+            !local_throttle_event)
+        {
+            goto err;
+        }
+        params->throttle_event = remote_handle_from_local(local_throttle_event, proxy->hwnd);
+        if (!params->throttle_event) goto err;
+    }
+
+    /* Create remote handle for params and post message. */
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto err;
+
+    TRACE("proxy=%p hwnd=%p type=%d commit=%d => local_released=%p "
+          "remote_released=%p, local_throttle=%p remote_throttle=%p\n",
+          proxy, proxy->hwnd, proxy->type, commit, local_released_event,
+          params->released_event, local_throttle_event, params->throttle_event);
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT,
+                      HandleToLong(remote_params_handle));
+
+    munmap(params, sizeof(*params));
+    close(params_fd);
+
+    if (buffer_released_event_out)
+        *buffer_released_event_out = local_released_event;
+    else if (local_released_event)
+        NtClose(local_released_event);
+
+    if (throttle_event_out)
+        *throttle_event_out = local_throttle_event;
+    else if (local_throttle_event)
+        NtClose(local_throttle_event);
+
+    return TRUE;
+
+err:
+    if (params != MAP_FAILED)
+    {
+        for (i = 0; i < native->plane_count; i++)
+            if (params->fds[i]) NtClose(params->fds[i]);
+        if (params->released_event) NtClose(params->released_event);
+        munmap(params, sizeof(*params));
+    }
+    if (params_fd >= 0) close(params_fd);
+    if (local_released_event) NtClose(local_released_event);
+    if (local_throttle_event) NtClose(local_throttle_event);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_dispatch_events
+ *
+ *  Dispatches events (e.g., buffer release events) from the remote surface.
+ */
+BOOL wayland_remote_surface_proxy_dispatch_events(struct wayland_remote_surface_proxy *proxy)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+    BOOL ret = FALSE;
+
+    TRACE("proxy=%p hwnd=%p type=%d\n", proxy, proxy->hwnd, proxy->type);
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-dispatch", sizeof(*params));
+    if (params_fd < 0) goto out;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto out;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto out;
+
+    ret = NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                            WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS,
+                            HandleToLong(remote_params_handle));
+
+out:
+    if (params_fd >= 0) close(params_fd);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
new file mode 100644
index 00000000000..9759c4dff89
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -0,0 +1,242 @@
+/*
+ * Wayland SHM buffers
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_shm_buffer_create_from_native
+ *
+ * Creates a wayland SHM buffer from the specified native buffer.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                 struct wayland_native_buffer *native)
+{
+    struct wayland_shm_buffer *shm_buffer;
+    struct wl_shm_pool *pool;
+    int size;
+    void *data;
+
+    shm_buffer = calloc(1, sizeof(*shm_buffer));
+    if (!shm_buffer)
+        goto err;
+
+    wl_list_init(&shm_buffer->link);
+
+    size = native->strides[0] * native->height;
+
+    TRACE("%p %dx%d format=%d size=%d\n",
+          shm_buffer, native->width, native->height, native->format, size);
+
+    if (size == 0)
+        goto err;
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, native->fds[0], 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("mmap failed: %s size=%d\n", strerror(errno), size);
+        goto err;
+    }
+
+    pool = wl_shm_create_pool(wayland->wl_shm, native->fds[0], size);
+    shm_buffer->wl_buffer = wl_shm_pool_create_buffer(pool, 0, native->width, native->height,
+                                                      native->strides[0], native->format);
+    wl_shm_pool_destroy(pool);
+
+    shm_buffer->width = native->width;
+    shm_buffer->height = native->height;
+    shm_buffer->stride = native->strides[0];
+    shm_buffer->format = native->format;
+    shm_buffer->map_data = data;
+    shm_buffer->map_size = size;
+    shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+    if (!shm_buffer->damage_region)
+    {
+        ERR("failed to create buffer damage region\n");
+        goto err;
+    }
+
+    TRACE("%p %dx%d size=%d => map=%p\n",
+          shm_buffer, native->width, native->height, size, data);
+
+    return shm_buffer;
+
+err:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_create
+ *
+ * Creates a SHM buffer with the specified width, height and format.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format)
+{
+    struct wayland_native_buffer native;
+    struct wayland_shm_buffer *shm_buffer;
+
+    if (wayland_native_buffer_init_shm(&native, width, height, format))
+    {
+        shm_buffer = wayland_shm_buffer_create_from_native(wayland, &native);
+        wayland_native_buffer_deinit(&native);
+    }
+    else
+    {
+        shm_buffer = NULL;
+    }
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_destroy
+ *
+ * Destroys a SHM buffer.
+ */
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    TRACE("%p map=%p\n", shm_buffer, shm_buffer->map_data);
+
+    wl_list_remove(&shm_buffer->link);
+
+    if (shm_buffer->wl_buffer)
+        wl_buffer_destroy(shm_buffer->wl_buffer);
+    if (shm_buffer->map_data)
+        munmap(shm_buffer->map_data, shm_buffer->map_size);
+    if (shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(shm_buffer->damage_region);
+
+    free(shm_buffer);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a SHM buffer and destroy the SHM buffer.
+ */
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = shm_buffer->wl_buffer;
+    shm_buffer->wl_buffer = NULL;
+
+    wayland_shm_buffer_destroy(shm_buffer);
+
+    return wl_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_clear_damage
+ *
+ *  Clears all damage accumulated by a SHM buffer.
+ */
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer)
+{
+    NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_add_damage
+ *
+ *  Adds damage (i.e., a region which needs update) to a SHM buffer.
+ */
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage)
+{
+    NtGdiCombineRgn(shm_buffer->damage_region, shm_buffer->damage_region, damage, RGN_OR);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_copy
+ *
+ *  Copies a region from one SHM buffer to another. The region is clipped
+ *  within the source and destination rectangles.
+ */
+void wayland_shm_buffer_copy(struct wayland_shm_buffer *dst_buffer,
+                             struct wayland_shm_buffer *src_buffer,
+                             HRGN region)
+{
+    static const int bpp = 4; /* All buffers we use have 4 bytes per pixel */
+    RGNDATA *rgndata = get_region_data(region);
+    RECT *rgn_rect;
+    RECT *rgn_rect_end;
+    RECT src_rect, dst_rect;
+
+    if (!rgndata) return;
+
+    rgn_rect = (RECT *)rgndata->Buffer;
+    rgn_rect_end = rgn_rect + rgndata->rdh.nCount;
+
+    SetRect(&src_rect, 0, 0, src_buffer->width, src_buffer->height);
+    SetRect(&dst_rect, 0, 0, dst_buffer->width, dst_buffer->height);
+
+    for (;rgn_rect < rgn_rect_end; rgn_rect++)
+    {
+        unsigned int *src, *dst;
+        int y, width, height;
+        RECT rc;
+
+        if (!intersect_rect(&rc, rgn_rect, &src_rect)) continue;
+        if (!intersect_rect(&rc, &rc, &dst_rect)) continue;
+
+        TRACE("rect %s => %s\n", wine_dbgstr_rect(rgn_rect),
+              wine_dbgstr_rect(&rc));
+
+        src = (unsigned int *)((unsigned char *)src_buffer->map_data +
+              rc.top * src_buffer->stride + rc.left * bpp);
+        dst = (unsigned int *)((unsigned char *)dst_buffer->map_data +
+              rc.top * dst_buffer->stride + rc.left * bpp);
+        width = rc.right - rc.left;
+        height = rc.bottom - rc.top;
+
+        /* Fast path for full width rectangles. */
+        if (width == dst_buffer->width && width == src_buffer->width &&
+            src_buffer->stride == dst_buffer->stride)
+        {
+            memcpy(dst, src, height * src_buffer->stride);
+            continue;
+        }
+
+        for (y = 0; y < height; y++)
+        {
+            memcpy(dst, src, width * 4);
+            src = (unsigned int*)((unsigned char*)src + src_buffer->stride);
+            dst = (unsigned int*)((unsigned char*)dst + dst_buffer->stride);
+        }
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_shmfd.c b/dlls/winewayland.drv/wayland_shmfd.c
new file mode 100644
index 00000000000..b2e69be33e4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shmfd.c
@@ -0,0 +1,86 @@
+/*
+ * Wayland SHM fd
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+/* For memfd_create */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+
+static int fd_resize(int fd, off_t size)
+{
+    /*
+     * Filesystems that do support fallocate will return EINVAL or
+     * EOPNOTSUPP. In this case we need to fall back to ftruncate
+     */
+    errno = posix_fallocate(fd, 0, size);
+    if (errno == 0)
+        return 0;
+    else if (errno != EINVAL && errno != EOPNOTSUPP)
+        return -1;
+    if (ftruncate(fd, size) < 0)
+        return -1;
+
+    return 0;
+}
+
+/**********************************************************************
+ *          wayland_shmfd_create
+ *
+ * Creates a file descriptor representing an anonymous SHM region.
+ */
+int wayland_shmfd_create(const char *name, int size)
+{
+    int fd = memfd_create(name, MFD_CLOEXEC | MFD_ALLOW_SEALING);
+
+    if (fd >= 0)
+    {
+        /* We can add this seal before calling posix_fallocate(), as
+         * the file is currently zero-sized anyway.
+         *
+         * There is also no need to check for the return value, we
+         * couldn't do anything with it anyway.
+         */
+        fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_SEAL);
+    }
+
+    while (TRUE)
+    {
+        int ret = fd_resize(fd, size);
+        if (ret == 0) break;
+        if (ret < 0 && errno == EINTR) continue;
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
new file mode 100644
index 00000000000..3ea8728d423
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -0,0 +1,1620 @@
+/*
+ * Wayland surfaces
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+#include "ntuser.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* Change to 1 to dump committed buffer contents to disk */
+#define DEBUG_DUMP_COMMIT_BUFFER 0
+
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output);
+
+static void post_configure(void *data)
+{
+    HWND hwnd = (HWND)data;
+    TRACE("hwnd=%p\n", hwnd);
+    thread_wayland()->last_dispatch_mask |= QS_POSTMESSAGE;
+    NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+}
+
+static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
+                                         uint32_t serial)
+{
+    struct wayland_surface *surface = data;
+    uint32_t last_serial = surface->pending.serial;
+    BOOL last_processed = surface->pending.processed;
+
+    TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
+
+    surface->pending.serial = serial;
+    surface->pending.processed = FALSE;
+
+    /* If we have an unprocessed WM_WAYLAND_CONFIGURE message, no need to
+     * repost. Note that checking only for a valid serial is not enough to
+     * guarantee that there is a pending WM_WAYLAND_CONFIGURE message: we may
+     * have processed the message but not acked the configure request due to
+     * surface size incompatibilities (see window.c:
+     * wayland_win_data_update_wayland_surface_state()). */
+    if (last_serial && !last_processed)
+    {
+        TRACE("not reposting, last_serial=%u\n", last_serial);
+        return;
+    }
+
+    /* We are handling the xdg configure event in the context of a driver
+     * MsgWaitForMultipleObjectsEx invocation, which may have blocked for some
+     * time before the event arrived. Since the last time the message loop was
+     * marked as idle (in terms of window_surface flushing) was before such
+     * wait, if we post the configure message we will continue without allowing
+     * the loop to be considered idle. This may lead Wine core to think that the
+     * app never goes idle (see flush_window_surfaces in win32u), and thus start
+     * flushing at unfortunate times (e.g., in between partial window paints),
+     * causing visual artifacts.
+     *
+     * To mitigate this, we post the configure with a small delay to give the
+     * loop some breathing space to be considered idle again.
+     *
+     * TODO: We effectively want to schedule the message for when the message
+     * queue is idle, find a better way to achieve this.
+     */
+    wayland_surface_schedule_wm_configure(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ack_pending_configure
+ *
+ * Acks the pending configure event, making it current.
+ */
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
+{
+    if (!surface->xdg_surface || !surface->pending.serial)
+        return;
+
+    TRACE("Setting current serial=%u size=%dx%d flags=%#x\n",
+          surface->pending.serial, surface->pending.width,
+          surface->pending.height, surface->pending.configure_flags);
+
+    surface->current = surface->pending;
+    xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_xdg_surface_configure,
+};
+
+static void handle_xdg_toplevel_configure(void *data,
+                                          struct xdg_toplevel *xdg_toplevel,
+                                          int32_t width, int32_t height,
+                                          struct wl_array *states)
+{
+    struct wayland_surface *surface = data;
+    uint32_t *state;
+    int flags = 0;
+
+    wl_array_for_each(state, states)
+    {
+        switch(*state)
+        {
+        case XDG_TOPLEVEL_STATE_MAXIMIZED:
+            flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+            break;
+        case XDG_TOPLEVEL_STATE_ACTIVATED:
+            flags |= WAYLAND_CONFIGURE_FLAG_ACTIVATED;
+            break;
+        case XDG_TOPLEVEL_STATE_RESIZING:
+            flags |= WAYLAND_CONFIGURE_FLAG_RESIZING;
+            break;
+        case XDG_TOPLEVEL_STATE_FULLSCREEN:
+            flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+            break;
+        default:
+            break;
+        }
+    }
+
+    surface->pending.width = width;
+    surface->pending.height = height;
+    surface->pending.configure_flags = flags;
+
+    TRACE("%dx%d flags=%#x\n", width, height, flags);
+}
+
+static void handle_xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    TRACE("\n");
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    handle_xdg_toplevel_configure,
+    handle_xdg_toplevel_close,
+};
+
+/* Gets the output we consider to be the origin of this surface.
+ * If the surface can be fullscreen this is the topleft-most output that
+ * fully contains this surface, otherwise it's the topleft-most output
+ * that partially contains this surface. */
+static struct wayland_output *wayland_surface_get_origin_output(
+        struct wayland_surface *surface)
+{
+    struct wayland_output_ref *ref;
+    struct wayland_output *topleft = NULL;
+    struct wayland_output *containing = NULL;
+    RECT window_rect;
+
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+
+    wl_list_for_each(ref, &surface->output_ref_list, link)
+    {
+        if (surface->window_fullscreen)
+        {
+            RECT monitor_rect;
+            struct wayland_output_mode *mode = ref->output->current_wine_mode;
+
+            SetRect(&monitor_rect, ref->output->x, ref->output->y,
+                    ref->output->x + (mode ? mode->width : 0),
+                    ref->output->y + (mode ? mode->height : 0));
+
+            if ((!containing || ref->output->x < containing->x ||
+                 (ref->output->x == containing->x && ref->output->y < containing->y)) &&
+                contains_rect(&window_rect, &monitor_rect))
+            {
+                containing = ref->output;
+            }
+        }
+
+        if (!topleft || ref->output->x < topleft->x ||
+            (ref->output->x == topleft->x && ref->output->y < topleft->y))
+            topleft = ref->output;
+    }
+
+    return containing ? containing : topleft;
+}
+
+static void handle_wl_surface_enter(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+    struct wayland_output_ref *ref;
+    struct wayland_output *origin;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    ref = calloc(1, sizeof(*ref));
+    if (!ref) { ERR("memory allocation failed"); return; }
+    ref->output = output;
+    wl_list_insert(&surface->output_ref_list, &ref->link);
+
+    origin = wayland_surface_get_origin_output(surface);
+    wayland_surface_set_main_output(surface, origin);
+}
+
+static void handle_wl_surface_leave(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    wayland_surface_leave_output(surface, output);
+}
+
+static const struct wl_surface_listener wl_surface_listener = {
+    handle_wl_surface_enter,
+    handle_wl_surface_leave,
+};
+
+/**********************************************************************
+ *          wayland_surface_create_plain
+ *
+ * Creates a plain, role-less wayland surface.
+ */
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    surface = calloc(1, sizeof(*surface));
+    if (!surface)
+        goto err;
+
+    TRACE("surface=%p\n", surface);
+
+    wayland_mutex_init(&surface->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_surface");
+
+    surface->wayland = wayland;
+
+    surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
+    if (!surface->wl_surface)
+        goto err;
+
+    if (surface->wayland->wp_viewporter)
+    {
+        surface->wp_viewport =
+            wp_viewporter_get_viewport(surface->wayland->wp_viewporter,
+                                       surface->wl_surface);
+    }
+
+    wl_list_init(&surface->output_ref_list);
+    wl_list_init(&surface->link);
+    wl_list_init(&surface->parent_link);
+    wl_list_init(&surface->child_list);
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, surface);
+    /* Plain surfaces are unmappable, so don't draw on them. */
+    surface->drawing_allowed = FALSE;
+
+    surface->ref = 1;
+    surface->role = WAYLAND_SURFACE_ROLE_NONE;
+
+    wl_list_insert(&wayland->surface_list, &surface->link);
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_make_toplevel
+ *
+ * Gives the toplevel role to a plain wayland surface, optionally associated
+ * with a parent surface.
+ */
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->drawing_allowed = TRUE;
+
+    surface->xdg_surface =
+        xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
+    if (!surface->xdg_surface)
+        goto err;
+    xdg_surface_add_listener(surface->xdg_surface, &xdg_surface_listener, surface);
+
+    surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
+    if (!surface->xdg_toplevel)
+        goto err;
+    xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface);
+
+    if (parent && parent->xdg_toplevel)
+        xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
+
+    if (process_name)
+        xdg_toplevel_set_app_id(surface->xdg_toplevel, process_name);
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
+
+    /* Wait for the first configure event. */
+    while (!surface->pending.serial)
+        wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
+    return;
+
+err:
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+    ERR("Failed to assign toplevel role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_create_subsurface
+ *
+ * Assigns the subsurface role to a plain wayland surface, with the specified
+ * parent.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->drawing_allowed = TRUE;
+
+    surface->parent = wayland_surface_ref(parent);
+
+    wayland_mutex_lock(&parent->mutex);
+    wl_list_insert(&parent->child_list, &surface->parent_link);
+    wayland_mutex_unlock(&parent->mutex);
+
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    surface->main_output = parent->main_output;
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return;
+
+err:
+    wayland_surface_unref(surface->parent);
+    surface->parent = NULL;
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_clear_role
+ *
+ * Clears the role related Wayland objects of a Wayland surface, making it a
+ * plain surface again. We can later assign the same role (but not a
+ * different one!) to the surface.
+ */
+void wayland_surface_clear_role(struct wayland_surface *surface)
+{
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    surface->drawing_allowed = FALSE;
+
+    if (surface->parent)
+    {
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->parent_link);
+        wl_list_init(&surface->parent_link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
+    if (surface->xdg_toplevel)
+    {
+        wayland_cancel_thread_callback((uintptr_t)surface->xdg_toplevel);
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+    memset(&surface->current, 0, sizeof(surface->current));
+
+    /* We need to unmap, otherwise future role assignments may fail. */
+    wayland_surface_unmap(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_position
+ *
+ * Configures the position of a wayland surface relative to its parent.
+ * This only applies to surfaces having the subsurface role.
+ *
+ * The coordinates should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int wine_x, int wine_y)
+{
+    int x, y;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d wayland=%d,%d\n",
+          surface, surface->hwnd, wine_x, wine_y, x, y);
+
+    if (surface->wl_subsurface)
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_geometry
+ *
+ * Configures the geometry of a wayland surface, i.e., the rectangle
+ * within that surface that contains the surface's visible bounds.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * Note that this doesn't configure any associated GL/VK subsurface,
+ * wayland_surface_reconfigure_glvk() needs to be called separately.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int wine_x, int wine_y,
+                                          int wine_width, int wine_height)
+{
+    int x, y, width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d+%dx%d wayland=%d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    if (surface->xdg_surface && width != 0 && height != 0)
+    {
+        enum wayland_configure_flags flags = surface->current.configure_flags;
+
+        /* Sometimes rounding errors in our coordinate space transformations
+         * can lead to invalid geometry values, so enforce acceptable geometry
+         * values to avoid causing a protocol error. */
+        if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+        {
+            width = surface->current.width;
+            height = surface->current.height;
+        }
+        else if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+        {
+            if (width > surface->current.width)
+                width = surface->current.width;
+            if (height > surface->current.height)
+                height = surface->current.height;
+        }
+
+        xdg_surface_set_window_geometry(surface->xdg_surface, x, y, width, height);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_size
+ *
+ * Configures the size of a wayland surface.
+ *
+ * The sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int wine_width, int wine_height)
+{
+    int width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%dx%d wayland=%dx%d\n",
+          surface, surface->hwnd, wine_width, wine_height, width, height);
+
+    if (surface->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(surface->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(surface->wp_viewport, -1, -1);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_configure_is_compatible
+ *
+ * Checks whether a wayland_surface_configure object is compatible with the
+ * the provided arguments.
+ */
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags)
+{
+    static int mask = WAYLAND_CONFIGURE_FLAG_MAXIMIZED |
+                      WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+
+    /* We require the same state. */
+    if ((flags & mask) != (conf->configure_flags & mask))
+        return FALSE;
+
+    /* The maximized state requires the configured size. During surface
+     * reconfiguration we can use surface geometry to provide smaller areas
+     * from larger sizes, so only smaller sizes are incompatible. */
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        (width < conf->width || height < conf->height))
+    {
+        return FALSE;
+    }
+
+    /* The fullscreen state requires sizes smaller or equal to the configured
+     * size. We can provide this during surface reconfiguration using surface
+     * geometry, so we are always compatible with a fullscreen state. */
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_surface_commit_buffer
+ *
+ * Commits a SHM buffer on a wayland surface. Returns whether the
+ * buffer was actually committed.
+ */
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region)
+{
+    RGNDATA *surface_damage;
+    int wayland_width, wayland_height;
+
+    /* Since multiple threads can commit a buffer to a wayland surface
+     * (e.g., child windows in different threads), we guard this function
+     * to ensure we get complete and atomic buffer commits. */
+    wayland_mutex_lock(&surface->mutex);
+
+    TRACE("surface=%p (%dx%d) flags=%#x buffer=%p (%dx%d)\n",
+          surface, surface->current.width, surface->current.height,
+          surface->current.configure_flags, shm_buffer,
+          shm_buffer->width, shm_buffer->height);
+
+    wayland_surface_coords_rounded_from_wine(surface,
+                                             shm_buffer->width, shm_buffer->height,
+                                             &wayland_width, &wayland_height);
+
+    /* Certain surface states are very strict about the dimensions of buffers
+     * they accept. To avoid wayland protocol errors, drop buffers not matching
+     * the expected dimensions of such surfaces. This typically happens
+     * transiently during resizing operations. */
+    if (!surface->drawing_allowed ||
+        !wayland_surface_configure_is_compatible(&surface->current,
+                                             wayland_width,
+                                             wayland_height,
+                                             surface->current.configure_flags))
+    {
+        wayland_mutex_unlock(&surface->mutex);
+        TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
+        shm_buffer->busy = FALSE;
+        return FALSE;
+    }
+
+    if (DEBUG_DUMP_COMMIT_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/commit-%.4d.pam", dbgid++, shm_buffer->map_data,
+                    shm_buffer->width, shm_buffer->height,
+                    shm_buffer->format == WL_SHM_FORMAT_ARGB8888,
+                    shm_buffer->damage_region, NULL);
+    }
+
+    wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
+
+    /* Add surface damage, i.e., which parts of the surface have changed since
+     * the last surface commit. Note that this is different from the buffer
+     * damage returned by wayland_shm_buffer_get_damage(). */
+    surface_damage = get_region_data(surface_damage_region);
+    if (surface_damage)
+    {
+        RECT *rgn_rect = (RECT *)surface_damage->Buffer;
+        RECT *rgn_rect_end = rgn_rect + surface_damage->rdh.nCount;
+
+        for (;rgn_rect < rgn_rect_end; rgn_rect++)
+        {
+            wl_surface_damage_buffer(surface->wl_surface,
+                                     rgn_rect->left, rgn_rect->top,
+                                     rgn_rect->right - rgn_rect->left,
+                                     rgn_rect->bottom - rgn_rect->top);
+        }
+        free(surface_damage);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = TRUE;
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_surface_destroy
+ *
+ * Destroys a wayland surface.
+ */
+void wayland_surface_destroy(struct wayland_surface *surface)
+{
+    struct wayland_pointer *pointer = &surface->wayland->pointer;
+    struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_data_device *data_device = &surface->wayland->data_device;
+    struct wayland_surface *child, *child_tmp;
+    struct wayland_output_ref *ref, *ref_tmp;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (pointer->focused_surface == surface)
+        pointer->focused_surface = NULL;
+
+    if (keyboard->focused_surface == surface)
+        keyboard->focused_surface = NULL;
+
+    if (data_device->dnd_surface == surface)
+        data_device->dnd_surface = NULL;
+
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    wayland_mutex_lock(&surface->mutex);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, parent_link)
+    {
+        child->parent = NULL;
+        wl_list_remove(&child->parent_link);
+        wl_list_init(&child->parent_link);
+    }
+    wayland_mutex_unlock(&surface->mutex);
+
+    wl_list_for_each_safe(ref, ref_tmp, &surface->output_ref_list, link)
+    {
+        wl_list_remove(&ref->link);
+        free(ref);
+    }
+
+    if (surface->surface_feedback)
+        wayland_dmabuf_surface_feedback_destroy(surface->surface_feedback);
+
+    if (surface->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    if (surface->wp_viewport)
+    {
+        wp_viewport_destroy(surface->wp_viewport);
+        surface->wp_viewport = NULL;
+    }
+
+    if (surface->xdg_toplevel)
+    {
+        wayland_cancel_thread_callback((uintptr_t)surface->xdg_toplevel);
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    if (surface->wl_surface)
+    {
+        wl_surface_destroy(surface->wl_surface);
+        surface->wl_surface = NULL;
+    }
+
+    if (surface->parent)
+    {
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->parent_link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
+    wl_list_remove(&surface->link);
+
+    wayland_mutex_destroy(&surface->mutex);
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    free(surface);
+}
+
+static struct wayland_surface *wayland_surface_create_glvk_common(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    glvk = wayland_surface_create_plain(surface->wayland);
+    if (!glvk)
+        goto err;
+
+    glvk->parent = wayland_surface_ref(surface);
+
+    wayland_mutex_lock(&glvk->parent->mutex);
+    wl_list_insert(&glvk->parent->child_list, &glvk->parent_link);
+    wayland_mutex_unlock(&glvk->parent->mutex);
+
+    glvk->wl_subsurface =
+        wl_subcompositor_get_subsurface(glvk->wayland->wl_subcompositor,
+                                        glvk->wl_surface,
+                                        surface->wl_surface);
+    if (!glvk->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(glvk->wl_subsurface);
+    /* Place the glvk subsurface just above the parent surface, so that it
+     * doesn't end up obscuring any other subsurfaces. */
+    wl_subsurface_place_above(glvk->wl_subsurface, surface->wl_surface);
+
+    glvk->hwnd = surface->hwnd;
+    glvk->main_output = surface->main_output;
+    glvk->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return glvk;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return NULL;
+}
+
+static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = NULL;
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk)
+        glvk = wayland_surface_ref(surface->glvk);
+    wayland_mutex_unlock(&surface->mutex);
+    return glvk;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_glvk
+ *
+ * Creates a GL/VK subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+    RECT client_rect;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (wayland_surface_ref_glvk(surface))
+        return TRUE;
+
+    glvk = wayland_surface_create_glvk_common(surface);
+    if (!glvk)
+        goto err;
+
+    wayland_mutex_lock(&surface->mutex);
+    surface->glvk = glvk;
+    wayland_mutex_unlock(&surface->mutex);
+
+    /* Set initial position in the client area. */
+    wayland_get_client_rect_in_win_top_left_coords(surface->hwnd, &client_rect);
+
+    wayland_surface_reconfigure_glvk(surface,
+                                     client_rect.left, client_rect.top,
+                                     client_rect.right - client_rect.left,
+                                     client_rect.bottom - client_rect.top);
+
+    wayland_surface_reconfigure_apply(surface);
+
+    if (wayland_dmabuf_has_feedback_support(&surface->wayland->dmabuf))
+        glvk->surface_feedback = wayland_dmabuf_surface_feedback_create(&surface->wayland->dmabuf,
+                                                                        glvk->wl_surface);
+
+    return TRUE;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref_glvk
+ *
+ * Unreferences the associated GL/VK subsurface for this wayland surface.
+ */
+void wayland_surface_unref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk_to_destroy = NULL;
+    int ref = -12345;
+
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk && (ref = InterlockedDecrement(&surface->glvk->ref)) == 0)
+    {
+        glvk_to_destroy = surface->glvk;
+        surface->glvk = NULL;
+    }
+    TRACE("surface=%p glvk=%p ref=%d->%d\n",
+          surface, glvk_to_destroy ? glvk_to_destroy : surface->glvk, ref + 1, ref);
+    wayland_mutex_unlock(&surface->mutex);
+
+    if (glvk_to_destroy)
+        wayland_surface_destroy(glvk_to_destroy);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_glvk
+ *
+ * Configures the position and size of the GL/VK subsurface associated with
+ * a wayland surface.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      int wine_width, int wine_height)
+{
+    int x, y, width, height;
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (!glvk)
+        return;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    glvk->offset_x = wine_x;
+    glvk->offset_y = wine_y;
+
+    wl_subsurface_set_position(glvk->wl_subsurface, x, y);
+
+    /* Use a viewport, if supported, to ensure GL surfaces remain inside their
+     * parent's boundaries when resizing and also to handle display mode
+     * changes. If the size is invalid use a 1x1 destination (instead of
+     * unsetting with -1x-1) since many apps don't respect a GL/VK 0x0 size
+     * which can happen, e.g., when an app is minimized. */
+    if (glvk->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(glvk->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(glvk->wp_viewport, 1, 1);
+    }
+
+    wayland_surface_unref_glvk(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (glvk)
+    {
+        wl_surface_commit(glvk->wl_surface);
+        wayland_surface_unref_glvk(surface);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_unmap
+ *
+ * Unmaps (i.e., hides) this surface.
+ */
+void wayland_surface_unmap(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_surface_attach(surface->wl_surface, NULL, 0, 0);
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = FALSE;
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_to_screen
+ *
+ * Converts the surface-local coordinates to Windows screen coordinates.
+ */
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y)
+{
+    RECT window_rect = {0};
+    int wine_x, wine_y;
+
+    wayland_surface_coords_to_wine(surface, wayland_x, wayland_y,
+                                   &wine_x, &wine_y);
+
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+
+    /* Some wayland surfaces are offset relative to their window rect,
+     * e.g., GL subsurfaces. */
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    *screen_x = wine_x + window_rect.left;
+    *screen_y = wine_y + window_rect.top;
+
+    TRACE("hwnd=%p wayland=%.2f,%.2f rect=%s => screen=%d,%d\n",
+          surface->hwnd, wayland_x, wayland_y, wine_dbgstr_rect(&window_rect),
+          *screen_x, *screen_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_from_screen
+ *
+ * Converts the Windows screen coordinates to surface-local coordinates.
+ */
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y)
+{
+    int wine_x, wine_y;
+    RECT window_rect = {0};
+
+    /* Screen to window */
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    wine_x = screen_x - window_rect.left;
+    wine_y = screen_y - window_rect.top;
+
+    /* Window to wayland surface */
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y,
+                                     wayland_x, wayland_y);
+
+    TRACE("hwnd=%p screen=%d,%d rect=%s => wayland=%.2f,%.2f\n",
+          surface->hwnd, screen_x, screen_y, wine_dbgstr_rect(&window_rect),
+          *wayland_x, *wayland_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates.
+ */
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y)
+{
+    struct wayland_output *output = surface->main_output;
+    double scale = wayland_surface_get_buffer_scale(surface);
+
+    if (output)
+    {
+        *wayland_x = wine_x * output->wine_scale / scale;
+        *wayland_y = wine_y * output->wine_scale / scale;
+    }
+    else
+    {
+        *wayland_x = wine_x / scale;
+        *wayland_y = wine_y / scale;
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wine=%d,%d => wayland=%.2f,%.2f\n",
+          surface->hwnd, output ? output->wine_scale : -1.0, wine_x, wine_y,
+          *wayland_x, *wayland_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_rounded_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates
+ * rounding to the closest integer value.
+ */
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y)
+{
+    double w_x, w_y;
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y, &w_x, &w_y);
+    *wayland_x = round(w_x);
+    *wayland_y = round(w_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_to_wine
+ *
+ * Converts the surface-local coordinates to wine windows-local coordinates.
+ */
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y)
+{
+    struct wayland_output *output = surface->main_output;
+    double scale = wayland_surface_get_buffer_scale(surface);
+
+    if (output)
+    {
+        *wine_x = round(wayland_x * scale / output->wine_scale);
+        *wine_y = round(wayland_y * scale / output->wine_scale);
+    }
+    else
+    {
+        *wine_x = round(wayland_x * scale);
+        *wine_y = round(wayland_y * scale);
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wayland=%.2f,%.2f => wine=%d,%d\n",
+          surface->hwnd, output ? output->wine_scale : -1.0,
+          wayland_x, wayland_y, *wine_x, *wine_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_find_wine_fullscreen_fit
+ *
+ * Finds the size of a fullscreen Wine window that when scaled best fits into a
+ * wayland surface with the provided size, while maintaining the aspect
+ * ratio of the current Wine display mode.
+ */
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height)
+{
+    struct wayland_output *output = surface->main_output;
+    double subarea_width, subarea_height;
+
+    TRACE("hwnd=%p wayland_width=%d wayland_height=%d\n",
+          surface->hwnd, wayland_width, wayland_height);
+
+    /* If the wine mode doesn't match the wayland mode, Find the largest subarea
+     * within wayland_width x wayland_height that has an aspect ratio equal to
+     * the wine display mode aspect ratio. */
+    if (output)
+    {
+        double aspect = ((double)wayland_width) / wayland_height;
+        double wine_aspect = ((double)output->current_wine_mode->width) /
+                             output->current_wine_mode->height;
+        if (aspect > wine_aspect)
+        {
+            subarea_width = wayland_height * wine_aspect;
+            subarea_height = wayland_height;
+        }
+        else
+        {
+            subarea_width = wayland_width;
+            subarea_height = wayland_width / wine_aspect;
+        }
+    }
+    else
+    {
+        subarea_width = wayland_width;
+        subarea_height = wayland_height;
+    }
+
+    /* Transform the calculated subarea to wine coordinates. */
+    wayland_surface_coords_to_wine(surface,
+                                   subarea_width, subarea_height,
+                                   wine_width, wine_height);
+}
+
+static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    wayland_shm_buffer_destroy(shm_buffer);
+}
+
+static const struct wl_buffer_listener dummy_buffer_listener = {
+    dummy_buffer_release
+};
+
+/**********************************************************************
+ *          wayland_surface_ensure_mapped
+ *
+ * Ensure that the wayland surface is mapped, by committing a dummy
+ * buffer if necessary.
+ */
+void wayland_surface_ensure_mapped(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    /* If this is a subsurface, ensure its parent is also mapped. */
+    if (surface->parent)
+        wayland_surface_ensure_mapped(surface->parent);
+
+    TRACE("surface=%p hwnd=%p mapped=%d\n",
+          surface, surface->hwnd, surface->mapped);
+
+    if (!surface->mapped)
+    {
+        int width = surface->current.width;
+        int height = surface->current.height;
+        int flags = surface->current.configure_flags;
+        int wine_width, wine_height;
+        struct wayland_shm_buffer *dummy_shm_buffer;
+        HRGN damage;
+
+        /* Use a large enough width/height, so even when the target
+         * surface is scaled by the compositor, this will not end up
+         * being 0x0. */
+        if (width == 0) width = 32;
+        if (height == 0) height = 32;
+
+        if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+            !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        {
+            wayland_surface_find_wine_fullscreen_fit(surface, width, height,
+                                                     &wine_width, &wine_height);
+        }
+        else
+        {
+            wayland_surface_coords_to_wine(surface, width, height,
+                                           &wine_width, &wine_height);
+        }
+
+        dummy_shm_buffer = wayland_shm_buffer_create(surface->wayland,
+                                                     wine_width, wine_height,
+                                                     WL_SHM_FORMAT_ARGB8888);
+        wl_buffer_add_listener(dummy_shm_buffer->wl_buffer,
+                               &dummy_buffer_listener, dummy_shm_buffer);
+
+        damage = NtGdiCreateRectRgn(0, 0, wine_width, wine_height);
+        if (!wayland_surface_commit_buffer(surface, dummy_shm_buffer, damage))
+            wayland_shm_buffer_destroy(dummy_shm_buffer);
+        NtGdiDeleteObjectApp(damage);
+    }
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_schedule_wm_configure
+ *
+ * Schedule the posting of a WM_WAYLAND_CONFIGURE event.
+ */
+void wayland_surface_schedule_wm_configure(struct wayland_surface *surface)
+{
+    if (surface->xdg_toplevel)
+    {
+        wayland_schedule_thread_callback((uintptr_t)surface->xdg_toplevel, 1,
+                                         post_configure, surface->hwnd);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_ref
+ *
+ * Add a reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface)
+{
+    int ref = InterlockedIncrement(&surface->ref);
+    TRACE("surface=%p ref=%d->%d\n", surface, ref - 1, ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref
+ *
+ * Remove a reference to wayland_surface, potentially destroying it.
+ */
+void wayland_surface_unref(struct wayland_surface *surface)
+{
+    int ref = InterlockedDecrement(&surface->ref);
+
+    TRACE("surface=%p ref=%d->%d\n", surface, ref + 1, ref);
+
+    if (ref == 0)
+        wayland_surface_destroy(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_update_pointer_constraint
+ *
+ * Update the pointer constraint on the surface. Constraint mode depends
+ * on the current Windows cursor clip and cursor visibility.
+ */
+void wayland_surface_update_pointer_constraint(struct wayland_surface *surface)
+{
+    struct wayland *wayland = surface->wayland;
+    struct wayland_surface *glvk;
+    struct wl_region *region;
+    RECT vscreen_rect;
+    RECT clip_rect = wayland->cursor_clip;
+    RECT client_rect = {0};
+    RECT client_clip_rect;
+    BOOL needs_lock = FALSE;
+    BOOL needs_confine = FALSE;
+    BOOL set_cursor_pos = surface->set_cursor_pos;
+
+    /* Treat constraint updates triggered by SetCursorPos as single-shot. */
+    surface->set_cursor_pos = FALSE;
+
+    if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
+        return;
+
+    wayland_get_client_rect_in_screen_coords(surface->hwnd, &client_rect);
+
+    vscreen_rect.top = NtUserGetSystemMetrics(SM_YVIRTUALSCREEN);
+    vscreen_rect.left = NtUserGetSystemMetrics(SM_XVIRTUALSCREEN);
+    vscreen_rect.bottom = vscreen_rect.top + NtUserGetSystemMetrics(SM_CYVIRTUALSCREEN);
+    vscreen_rect.right = vscreen_rect.left + NtUserGetSystemMetrics(SM_CXVIRTUALSCREEN);
+
+    /* Get the effective clip area, if any. */
+    intersect_rect(&clip_rect, &clip_rect, &vscreen_rect);
+    intersect_rect(&client_clip_rect, &clip_rect, &client_rect);
+
+    TRACE("wayland=%p surface=%p (glvk=%p) clip_rect=%s client_clip_rect=%s "
+          "client=%s vscreen=%s hcursor=%p\n",
+          wayland, surface, surface->glvk,
+          wine_dbgstr_rect(&clip_rect), wine_dbgstr_rect(&client_clip_rect),
+          wine_dbgstr_rect(&client_rect),
+          wine_dbgstr_rect(&vscreen_rect),
+          wayland->pointer.hcursor);
+
+    /* If there is a GL/VK subsurface use that to apply the pointer constaints,
+     * since it's covering the whole client area. */
+    glvk = wayland_surface_ref_glvk(surface);
+    if (glvk)
+    {
+        if (surface->zwp_locked_pointer_v1)
+        {
+            zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+            surface->zwp_locked_pointer_v1 = NULL;
+        }
+        if (surface->zwp_confined_pointer_v1)
+        {
+            zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+            surface->zwp_confined_pointer_v1 = NULL;
+        }
+        surface = glvk;
+    }
+
+    /* Only handle confinement or locking if the cursor is actually clipped
+     * within this window, or if the clip rect is empty. */
+    if (!IsRectEmpty(&client_clip_rect) || IsRectEmpty(&clip_rect))
+    {
+        /* Having an effective clip (i.e., clip is not the whole screen) is
+         * a prerequisite for locking the pointer. If the client rect is
+         * the whole screen (i.e., application is fullscreen), we can't
+         * differentiate between an explicit fullscreen clip and no effective
+         * clip (i.e., clip is the whole screen), so also consider locking. */
+        BOOL lock_clip = !EqualRect(&clip_rect, &vscreen_rect) ||
+                         EqualRect(&client_rect, &vscreen_rect);
+        /* To consider confining the pointer we must have an effective clip,
+         * otherwise confininement makes no difference. */
+        BOOL confine_clip = !EqualRect(&clip_rect, &vscreen_rect);
+        /* We may need to unlock the cursor if it is visible or we locked
+         * because it was clipped but now the clip is gone. */
+        BOOL needs_unlock =
+            wayland->pointer.locked_reason != WAYLAND_POINTER_LOCKED_REASON_NONE &&
+            (wayland->pointer.hcursor ||
+             ((wayland->pointer.locked_reason & WAYLAND_POINTER_LOCKED_REASON_CLIP) && !lock_clip));
+
+        /* If the cursor is not visible, and we have an lock clip, lock.
+         * Otherwise if the cursor is visible check if we need to confine. */
+        if (!needs_unlock && !wayland->pointer.hcursor && (lock_clip || set_cursor_pos))
+        {
+            if (lock_clip)
+                wayland->pointer.locked_reason |= WAYLAND_POINTER_LOCKED_REASON_CLIP;
+            if (set_cursor_pos)
+                wayland->pointer.locked_reason |= WAYLAND_POINTER_LOCKED_REASON_SET_CURSOR_POS;
+            needs_lock = TRUE;
+        }
+        else if (wayland->pointer.hcursor && confine_clip)
+        {
+            needs_confine = TRUE;
+        }
+    }
+
+    if (!needs_lock) wayland->pointer.locked_reason = WAYLAND_POINTER_LOCKED_REASON_NONE;
+
+    /* Destroy unneeded interface objects. */
+    if (!needs_lock && surface->zwp_locked_pointer_v1)
+    {
+        POINT cursor_pos;
+
+        if (NtUserGetCursorPos(&cursor_pos) && PtInRect(&client_rect, cursor_pos))
+        {
+            double wayland_x, wayland_y;
+            wayland_surface_coords_from_screen(surface,
+                                               cursor_pos.x, cursor_pos.y,
+                                               &wayland_x, &wayland_y);
+
+            zwp_locked_pointer_v1_set_cursor_position_hint(
+                    surface->zwp_locked_pointer_v1,
+                    wl_fixed_from_double(wayland_x),
+                    wl_fixed_from_double(wayland_y));
+
+            wl_surface_commit(surface->wl_surface);
+        }
+
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (!needs_confine && surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    /* Set up (or update) pointer confinement or lock. */
+    if (needs_confine)
+    {
+        double top, left, bottom, right;
+
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.left,
+                                           client_clip_rect.top,
+                                           &left, &top);
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.right,
+                                           client_clip_rect.bottom,
+                                           &right, &bottom);
+
+        region = wl_compositor_create_region(wayland->wl_compositor);
+        wl_region_add(region, round(left), round(top),
+                      round(right - left), round(bottom - top));
+
+        if (!surface->zwp_confined_pointer_v1)
+        {
+            surface->zwp_confined_pointer_v1 =
+                zwp_pointer_constraints_v1_confine_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    region,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_confined_pointer_v1_set_region(surface->zwp_confined_pointer_v1,
+                                               region);
+        }
+
+        wl_region_destroy(region);
+    }
+    else if (needs_lock)
+    {
+        if (!surface->zwp_locked_pointer_v1)
+        {
+            surface->zwp_locked_pointer_v1 =
+                zwp_pointer_constraints_v1_lock_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    NULL,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_locked_pointer_v1_set_region(surface->zwp_locked_pointer_v1,
+                                             NULL);
+        }
+    }
+
+    if (wayland->pointer.focused_surface == surface)
+        wayland_pointer_set_relative(&wayland->pointer, needs_lock);
+
+    if (needs_confine || needs_lock)
+        wl_surface_commit(surface->wl_surface);
+
+    if (glvk)
+        wayland_surface_unref_glvk(glvk->parent);
+}
+
+static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->main_output = output;
+
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_list_for_each(child, &surface->child_list, parent_link)
+        wayland_surface_tree_set_main_output(child, output);
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_main_output
+ *
+ * Sets the main output for a surface, i.e., the output whose scale will be
+ * used for surface scaling.
+ */
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->main_output != output)
+    {
+        wayland_surface_tree_set_main_output(surface, output);
+        if (surface->hwnd)
+            send_message(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 1);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_leave_output
+ *
+ * Removes an output from the set of outputs a surface is presented on.
+ *
+ * It is OK to call this function even if the surface is not presented
+ * on the specified output, in which case this function is a NOP.
+ */
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output)
+{
+    struct wayland_output_ref *ref, *tmp;
+
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    wl_list_for_each_safe(ref, tmp, &surface->output_ref_list, link)
+    {
+        if (ref->output == output)
+        {
+            wl_list_remove(&ref->link);
+            free(ref);
+            break;
+        }
+    }
+
+    if (surface->main_output == output)
+    {
+        struct wayland_output *origin =
+            wayland_surface_get_origin_output(surface);
+
+        wayland_surface_set_main_output(surface, origin);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_set_wine_output
+ *
+ * Sets the output which Wine considers to contain the window backed by this
+ * surface. Transiently, this may be different from the output Wayland
+ * considers to be the "main" one for this surface.
+ */
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output)
+{
+    /* Don't update non-toplevels or surfaces that already have a main output. */
+    if (!output || surface->parent || surface->main_output) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    wayland_surface_tree_set_main_output(surface, output);
+}
+
+/**********************************************************************
+ *          wayland_surface_get_buffer_scale
+ *
+ */
+double wayland_surface_get_buffer_scale(struct wayland_surface *surface)
+{
+    /* Use the toplevel surface to get the scale */
+    struct wayland_surface *toplevel = surface;
+    double scale = 1.0;
+
+    while (toplevel->parent) toplevel = toplevel->parent;
+
+    if (surface->main_output) scale = surface->main_output->scale;
+
+    TRACE("hwnd=%p (toplevel=%p) => scale=%.2f\n", surface->hwnd, toplevel->hwnd, scale);
+    return scale;
+}
+
+/**********************************************************************
+ *          wayland_surface_set_title
+ */
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
+{
+    DWORD text_len;
+    DWORD utf8_count;
+    char *utf8 = NULL;
+
+    if (!surface->xdg_toplevel)
+        return;
+
+    TRACE("surface=%p hwnd=%p text='%s'\n",
+          surface, surface->hwnd, wine_dbgstr_w(text));
+
+    text_len = (lstrlenW(text) + 1) * sizeof(WCHAR);
+
+    if (!RtlUnicodeToUTF8N(NULL, 0, &utf8_count, text, text_len) &&
+        (utf8 = malloc(utf8_count)))
+    {
+        RtlUnicodeToUTF8N(utf8, utf8_count, &utf8_count, text, text_len);
+        xdg_toplevel_set_title(surface->xdg_toplevel, utf8);
+    }
+
+    free(utf8);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
new file mode 100644
index 00000000000..38a5616598a
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -0,0 +1,900 @@
+/*
+ * Wayland driver
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_H
+#define __WINE_WAYLANDDRV_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <gbm.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <wayland-client.h>
+#include <wayland-cursor.h>
+#include <xkbcommon/xkbcommon.h>
+#include <xkbcommon/xkbcommon-compose.h>
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "pointer-constraints-unstable-v1-client-protocol.h"
+#include "relative-pointer-unstable-v1-client-protocol.h"
+#include "viewporter-client-protocol.h"
+#include "xdg-output-unstable-v1-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "ntuser.h"
+
+#include "unixlib.h"
+#include "wine/gdi_driver.h"
+
+#define WAYLANDDRV_CLIENT_CALL(func, params, size) waylanddrv_client_call(waylanddrv_client_func_ ## func, params, size)
+
+/**********************************************************************
+ *          Globals
+ */
+
+extern char *process_name DECLSPEC_HIDDEN;
+extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
+extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
+extern const struct user_driver_funcs waylanddrv_funcs DECLSPEC_HIDDEN;
+extern char *option_drm_device DECLSPEC_HIDDEN;
+extern enum wayland_hidpi_scaling option_hidpi_scaling DECLSPEC_HIDDEN;
+extern BOOL option_show_systray DECLSPEC_HIDDEN;
+extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
+
+/**********************************************************************
+  *          Internal messages and data
+  */
+
+enum wayland_window_message
+{
+    WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
+    WM_WAYLAND_SET_CURSOR,
+    WM_WAYLAND_QUERY_SURFACE_MAPPED,
+    WM_WAYLAND_CONFIGURE,
+    WM_WAYLAND_STATE_UPDATE,
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+    WM_WAYLAND_REAPPLY_CURSOR,
+    WM_WAYLAND_WINDOW_SURFACE_FLUSH,
+    WM_WAYLAND_REMOTE_SURFACE,
+    WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+    WM_WAYLAND_CLIPBOARD_WINDOW_CREATE,
+};
+
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+};
+
+enum wayland_configure_flags
+{
+    WAYLAND_CONFIGURE_FLAG_RESIZING   = (1 << 0),
+    WAYLAND_CONFIGURE_FLAG_ACTIVATED  = (1 << 1),
+    WAYLAND_CONFIGURE_FLAG_MAXIMIZED  = (1 << 2),
+    WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
+};
+
+enum wayland_remote_surface_type
+{
+    WAYLAND_REMOTE_SURFACE_TYPE_NORMAL,
+    WAYLAND_REMOTE_SURFACE_TYPE_GLVK,
+};
+
+enum wayland_remote_buffer_type
+{
+    WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+    WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+};
+
+enum wayland_remote_buffer_commit
+{
+    WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL,
+    WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED,
+    WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+};
+
+enum wayland_pointer_constraint
+{
+    WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS,
+};
+
+enum wayland_pointer_locked_reason
+{
+    WAYLAND_POINTER_LOCKED_REASON_NONE = 0,
+    WAYLAND_POINTER_LOCKED_REASON_SET_CURSOR_POS = (1 << 0),
+    WAYLAND_POINTER_LOCKED_REASON_CLIP = (1 << 1),
+};
+
+enum wayland_hidpi_scaling
+{
+    WAYLAND_HIDPI_SCALING_APPLICATION,
+    WAYLAND_HIDPI_SCALING_COMPOSITOR,
+};
+
+/**********************************************************************
+ *          Definitions for wayland types
+ */
+
+struct wayland_surface;
+struct wayland_shm_buffer;
+
+struct wayland_mutex
+{
+    pthread_mutex_t mutex;
+    UINT owner_tid;
+    int lock_count;
+    const char *name;
+};
+
+struct wayland_keyboard
+{
+    struct wl_keyboard *wl_keyboard;
+    struct wayland_surface *focused_surface;
+    int repeat_interval_ms;
+    int repeat_delay_ms;
+    uint32_t last_pressed_key;
+    uint32_t enter_serial;
+    struct xkb_context *xkb_context;
+    struct xkb_state *xkb_state;
+    struct xkb_compose_state *xkb_compose_state;
+    UINT xkb_keycode_to_vkey[256];
+    WORD xkb_keycode_to_scancode[256];
+    xkb_mod_mask_t xkb_mod5_mask;
+};
+
+struct wayland_cursor
+{
+    BOOL owns_wl_buffer;
+    struct wl_buffer *wl_buffer;
+    int width;
+    int height;
+    int hotspot_x;
+    int hotspot_y;
+};
+
+struct wayland_pointer
+{
+    struct wayland *wayland;
+    struct wl_pointer *wl_pointer;
+    struct wayland_surface *focused_surface;
+    struct wl_surface *cursor_wl_surface;
+    struct wp_viewport *cursor_wp_viewport;
+    uint32_t enter_serial;
+    struct wayland_cursor *cursor;
+    enum wayland_pointer_locked_reason locked_reason;
+    HCURSOR hcursor;
+    struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
+};
+
+struct wayland_dmabuf_format_info
+{
+    uint64_t *modifiers;
+    size_t count_modifiers;
+    BOOL scanoutable;
+};
+
+struct wayland_dmabuf_format
+{
+    uint32_t format;
+    struct wl_array modifiers;
+};
+
+struct wayland_dmabuf_feedback_tranche
+{
+    struct wl_array formats;
+    uint32_t flags;
+    dev_t device;
+};
+
+struct wayland_dmabuf_feedback_format_table_entry
+{
+    uint32_t format;
+    uint32_t padding; /* unused */
+    uint64_t modifier;
+};
+
+struct wayland_dmabuf_feedback
+{
+    dev_t main_device;
+    uint32_t format_table_size;
+    struct wayland_dmabuf_feedback_format_table_entry *format_table_entries;
+    struct wayland_dmabuf_feedback_tranche pending_tranche;
+    struct wl_array tranches;
+};
+
+struct wayland_dmabuf_surface_feedback
+{
+    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
+    struct wayland_dmabuf_feedback *feedback;
+    struct wayland_dmabuf_feedback *pending_feedback;
+    struct wayland_mutex mutex;
+    BOOL surface_needs_update;
+};
+
+struct wayland_dmabuf
+{
+    struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1;
+    uint32_t version;
+    struct wl_array formats;
+    struct wayland_dmabuf_feedback *default_feedback;
+    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
+};
+
+struct wayland_data_device
+{
+    struct wayland *wayland;
+    struct wl_data_device *wl_data_device;
+    struct wl_data_offer *clipboard_wl_data_offer;
+    struct wl_data_offer *dnd_wl_data_offer;
+    struct wl_data_source *wl_data_source;
+    uint32_t dnd_enter_serial;
+    struct wayland_surface *dnd_surface;
+    int dnd_x;
+    int dnd_y;
+};
+
+struct wayland_data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    const WCHAR *register_name;
+    /* In case of failure, 'ret_size' is left unchanged. */
+    void *(*import)(struct wayland_data_device_format *format,
+                    const void *data, size_t data_size, size_t *ret_size);
+    void (*export)(struct wayland_data_device_format *format, int fd,
+                   void *data, size_t size);
+    UINT_PTR extra;
+};
+
+struct wayland
+{
+    struct wl_list thread_link;
+    BOOL initialized;
+    DWORD process_id;
+    DWORD thread_id;
+    struct wl_display *wl_display;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_registry *wl_registry;
+    struct wl_compositor *wl_compositor;
+    struct wl_subcompositor *wl_subcompositor;
+    struct xdg_wm_base *xdg_wm_base;
+    struct wl_shm *wl_shm;
+    struct wl_seat *wl_seat;
+    struct wp_viewporter *wp_viewporter;
+    struct wl_data_device_manager *wl_data_device_manager;
+    struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
+    struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
+    struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
+    uint32_t next_fallback_output_id;
+    struct wl_list output_list;
+    struct wl_list detached_shm_buffer_list;
+    struct wl_list callback_list;
+    struct wl_list surface_list;
+    struct wayland_keyboard keyboard;
+    struct wayland_pointer pointer;
+    struct wayland_dmabuf dmabuf;
+    struct wayland_data_device data_device;
+    DWORD last_dispatch_mask;
+    BOOL processing_events;
+    uint32_t last_button_serial;
+    int last_event_type;
+    int event_notification_pipe[2];
+    HWND clipboard_hwnd;
+    RECT cursor_clip;
+};
+
+struct wayland_output_mode
+{
+    struct wl_list link;
+    int32_t width;
+    int32_t height;
+    int32_t refresh;
+    int bpp;
+    BOOL native;
+};
+
+struct wayland_output
+{
+    struct wl_list link;
+    struct wayland *wayland;
+    struct wl_output *wl_output;
+    struct zxdg_output_v1 *zxdg_output_v1;
+    struct wl_list mode_list;
+    struct wayland_output_mode *current_mode;
+    struct wayland_output_mode *current_wine_mode;
+    int logical_x, logical_y;  /* logical position */
+    int logical_w, logical_h;  /* logical size */
+    int x, y;  /* position in native pixel coordinate space */
+    double compositor_scale; /* scale factor reported by compositor */
+    double scale; /* effective wayland output scale factor for hidpi */
+    /* Scale factor by which we need to multiply values in the wine coordinate
+     * space to get values in the wayland coordinate space for this output. Used
+     * when emulating a display mode change. */
+    double wine_scale;
+    char *name;
+    WCHAR wine_name[128];
+    uint32_t global_id;
+};
+
+struct wayland_surface_configure
+{
+    int width;
+    int height;
+    enum wayland_configure_flags configure_flags;
+    uint32_t serial;
+    BOOL processed;
+};
+
+struct wayland_output_ref
+{
+    struct wl_list link;
+    struct wayland_output *output;
+};
+
+struct wayland_surface
+{
+    struct wl_list link; /* wayland::surface_list */
+    struct wl_list parent_link; /* wayland_surface::child_list */
+    struct wayland *wayland;
+    struct wl_surface *wl_surface;
+    struct wl_subsurface *wl_subsurface;
+    struct xdg_surface *xdg_surface;
+    struct xdg_toplevel *xdg_toplevel;
+    struct wp_viewport *wp_viewport;
+    struct wayland_surface *parent;
+    struct wayland_surface *glvk;
+    struct wayland_dmabuf_surface_feedback *surface_feedback;
+    struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
+    struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
+    /* The offset of this surface relative to its owning win32 window */
+    int offset_x, offset_y;
+    HWND hwnd;
+    struct wayland_mutex mutex;
+    struct wayland_surface_configure pending;
+    struct wayland_surface_configure current;
+    BOOL mapped;
+    LONG ref;
+    enum wayland_surface_role role;
+    struct wl_list output_ref_list;
+    struct wayland_output *main_output;
+    BOOL drawing_allowed;
+    struct wl_list child_list;
+    BOOL window_fullscreen;
+    BOOL set_cursor_pos;
+};
+
+struct wayland_native_buffer
+{
+    int plane_count;
+    int fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    uint32_t width, height;
+    uint32_t format;
+    uint64_t modifier;
+};
+
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height, stride;
+    enum wl_shm_format format;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    HRGN damage_region;
+    BOOL destroy_on_release;
+};
+
+struct wayland_dmabuf_buffer
+{
+   struct wl_list link;
+   struct wl_buffer *wl_buffer;
+   int width, height, stride;
+   uint32_t format;
+};
+
+struct wayland_buffer_queue
+{
+    struct wayland *wayland;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_list buffer_list;
+    int width;
+    int height;
+    enum wl_shm_format format;
+    HRGN damage_region;
+};
+
+typedef void (*wayland_callback_func)(void *data);
+
+struct wayland_remote_surface_proxy;
+
+/**********************************************************************
+ *          Wayland thread data
+ */
+
+struct wayland_thread_data
+{
+    struct wayland wayland;
+};
+
+extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
+
+static inline struct wayland_thread_data *wayland_thread_data(void)
+{
+    return (struct wayland_thread_data *)(UINT_PTR)NtUserGetThreadInfo()->driver_data;
+}
+
+static inline struct wayland *thread_init_wayland(void)
+{
+    return &wayland_init_thread_data()->wayland;
+}
+
+static inline struct wayland *thread_wayland(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+    if (!data) return NULL;
+    return &data->wayland;
+}
+
+/**********************************************************************
+ *          Wayland initialization
+ */
+
+BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
+BOOL wayland_init(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
+BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
+void wayland_process_release(void) DECLSPEC_HIDDEN;
+void wayland_init_display_devices(void) DECLSPEC_HIDDEN;
+void wayland_read_options_from_registry(void) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland mutex
+ */
+
+void wayland_mutex_init(struct wayland_mutex *wayland_mutex, int kind,
+                        const char *name) DECLSPEC_HIDDEN;
+void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+void wayland_mutex_lock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland output
+ */
+
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version) DECLSPEC_HIDDEN;
+void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_notify_wine_monitor_change(void) DECLSPEC_HIDDEN;
+void wayland_update_outputs_from_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name) DECLSPEC_HIDDEN;
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland, uint32_t id) DECLSPEC_HIDDEN;
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  struct wayland_output_mode *ref_mode) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland event dispatch
+ */
+
+int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
+BOOL wayland_read_events_and_dispatch_process(void) DECLSPEC_HIDDEN;
+void wayland_schedule_thread_callback(uintptr_t id, int delay_ms,
+                                      wayland_callback_func func, void *data) DECLSPEC_HIDDEN;
+void wayland_cancel_thread_callback(uintptr_t id) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland surface
+ */
+
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_clear_role(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags) DECLSPEC_HIDDEN;
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region) DECLSPEC_HIDDEN;
+void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int x, int y) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int x, int y, int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
+                                      int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y) DECLSPEC_HIDDEN;
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height) DECLSPEC_HIDDEN;
+void wayland_surface_ensure_mapped(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_schedule_wm_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_update_pointer_constraint(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output) DECLSPEC_HIDDEN;
+double wayland_surface_get_buffer_scale(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland native buffer
+ */
+
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format) DECLSPEC_HIDDEN;
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo) DECLSPEC_HIDDEN;
+void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland SHM buffer
+ */
+
+struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                 struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_copy(struct wayland_shm_buffer *dst_buffer,
+                             struct wayland_shm_buffer *src_buffer,
+                             HRGN region) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland dmabuf
+ */
+
+void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
+                         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1) DECLSPEC_HIDDEN;
+void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
+                                            dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
+                                                                       struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_surface_feedback *wayland_dmabuf_surface_feedback_create(struct wayland_dmabuf *dmabuf,
+                                                                               struct wl_surface *wl_surface) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_destroy(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_lock(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_unlock(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland buffer queue
+ */
+
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int heigh,
+                                                         enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_detach_buffer(struct wayland_buffer_queue *queue,
+                                        struct wayland_shm_buffer *shm_buffer,
+                                        BOOL destroy_on_release) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland window surface
+ */
+
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha) DECLSPEC_HIDDEN;
+void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPEC_HIDDEN;
+BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
+                                                   struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height)) DECLSPEC_HIDDEN;
+void wayland_clear_window_surface_last_flushed(HWND hwnd) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland Keyboard
+ */
+
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland Pointer/Cursor
+ */
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
+void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative) DECLSPEC_HIDDEN;
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
+void wayland_cursor_theme_init(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle) DECLSPEC_HIDDEN;
+BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
+void wayland_reapply_thread_cursor(void) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          GBM support
+ */
+
+BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
+dev_t wayland_gbm_get_render_dev(void) DECLSPEC_HIDDEN;
+struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, int height,
+                                               size_t count_modifiers, uint64_t *modifiers,
+                                               BOOL format_is_scanoutable) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          OpenGL support
+ */
+
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_destroy_gl_drawable(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height)) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Vulkan support
+ */
+
+void wayland_invalidate_vulkan_objects(HWND hwnd) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_data_device_deinit(struct wayland_data_device *data_device) DECLSPEC_HIDDEN;
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_data_device_init_formats(void) DECLSPEC_HIDDEN;
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime) DECLSPEC_HIDDEN;
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                                   struct wl_array *mimes) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Registry helpers
+ */
+
+HKEY reg_open_key_a(HKEY root, const char *name) DECLSPEC_HIDDEN;
+HKEY reg_open_key_w(HKEY root, const WCHAR *nameW) DECLSPEC_HIDDEN;
+HKEY reg_open_hkcu_key_a(const char *name) DECLSPEC_HIDDEN;
+DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
+                      DWORD *buffer_len) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          XKB helpers
+ */
+
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state) DECLSPEC_HIDDEN;
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland remote (cross-process) rendering
+ */
+
+void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
+                                           WPARAM message, LPARAM params) DECLSPEC_HIDDEN;
+void wayland_destroy_remote_surfaces(HWND hwnd) DECLSPEC_HIDDEN;
+struct wayland_remote_surface_proxy *wayland_remote_surface_proxy_create(HWND hwnd,
+                                                                         enum wayland_remote_surface_type type) DECLSPEC_HIDDEN;
+void wayland_remote_surface_proxy_destroy(struct wayland_remote_surface_proxy *proxy) DECLSPEC_HIDDEN;
+BOOL wayland_remote_surface_proxy_commit(struct wayland_remote_surface_proxy *proxy,
+                                         struct wayland_native_buffer *native,
+                                         enum wayland_remote_buffer_type buffer_type,
+                                         enum wayland_remote_buffer_commit commit,
+                                         HANDLE *buffer_released_event,
+                                         HANDLE *throttle_event) DECLSPEC_HIDDEN;
+BOOL wayland_remote_surface_proxy_dispatch_events(struct wayland_remote_surface_proxy *proxy) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Misc. helpers
+ */
+
+size_t ascii_to_unicode_maybe_z(WCHAR *dst, size_t dst_max_chars,
+                                const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
+                                const WCHAR *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
+                          const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+int wayland_shmfd_create(const char *name, int size) DECLSPEC_HIDDEN;
+RGNDATA *get_region_data(HRGN region) DECLSPEC_HIDDEN;
+void wayland_get_client_rect_in_screen_coords(HWND hwnd, RECT *client_rect) DECLSPEC_HIDDEN;
+void wayland_get_client_rect_in_win_top_left_coords(HWND hwnd, RECT *client_rect) DECLSPEC_HIDDEN;
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels, int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          USER32 helpers
+ */
+
+static inline LRESULT send_message(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserSendDriverMessage, FALSE);
+}
+
+static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+                                           UINT flags, UINT timeout, PDWORD_PTR res_ptr)
+{
+    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
+    LRESULT res = NtUserMessageCall(hwnd, msg, wparam, lparam, &params,
+                                    NtUserSendMessageTimeout, FALSE);
+    if (res_ptr) *res_ptr = res;
+    return params.result;
+}
+
+static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
+{
+    dst->left = max(src1->left, src2->left);
+    dst->top = max(src1->top, src2->top);
+    dst->right = min(src1->right, src2->right);
+    dst->bottom = min(src1->bottom, src2->bottom);
+    return !IsRectEmpty(dst);
+}
+
+static inline BOOL contains_rect(RECT *outer, const RECT *inner)
+{
+    POINT tl = {inner->left, inner->top};
+    POINT br = {inner->right - 1, inner->bottom - 1};
+    return PtInRect(outer, tl) && PtInRect(outer, br);
+}
+
+static inline BOOL union_rect(RECT *dst, const RECT *src1, const RECT *src2)
+{
+    if (IsRectEmpty(src1)) *dst = *src2;
+    else if (IsRectEmpty(src2)) *dst = *src1;
+    else
+    {
+        dst->left = min(src1->left, src2->left);
+        dst->top = min(src1->top, src2->top);
+        dst->right = max(src1->right, src2->right);
+        dst->bottom = max(src1->bottom, src2->bottom);
+    }
+    return !IsRectEmpty(dst);
+}
+
+static inline HWND get_focus(void)
+{
+    GUITHREADINFO info;
+    info.cbSize = sizeof(info);
+    return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndFocus : 0;
+}
+
+/**********************************************************************
+ *          PE/unixlib support
+ */
+
+NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
+                                ULONG size) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_clipboard_message(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_enum_formats(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          USER driver functions
+ */
+
+LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW displays, LPCWSTR primary_name,
+                                   HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
+BOOL WAYLAND_ClipCursor(const RECT *clip) DECLSPEC_HIDDEN;
+BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
+BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
+                                       LPDEVMODEW devmode) DECLSPEC_HIDDEN;
+INT WAYLAND_GetDisplayDepth(LPCWSTR name, BOOL is_primary) DECLSPEC_HIDDEN;
+INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECLSPEC_HIDDEN;
+BOOL WAYLAND_ProcessEvents(DWORD mask) DECLSPEC_HIDDEN;
+void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+BOOL WAYLAND_SetCursorPos(int x, int y) DECLSPEC_HIDDEN;
+void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
+INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                        LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect) DECLSPEC_HIDDEN;
+SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface) DECLSPEC_HIDDEN;
+BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                               const RECT *window_rect, const RECT *client_rect,
+                               RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version) DECLSPEC_HIDDEN;
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          GDI driver functions
+ */
+
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData) DECLSPEC_HIDDEN;
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
new file mode 100644
index 00000000000..cb9b695a62b
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -0,0 +1,36 @@
+/*
+ * Wayland driver DLL definitions
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_DLL_H
+#define __WINE_WAYLANDDRV_DLL_H
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+
+#include "unixlib.h"
+
+#define WAYLANDDRV_UNIX_CALL(func, params) WINE_UNIX_CALL(waylanddrv_unix_func_ ## func, params)
+extern BOOL option_show_systray DECLSPEC_HIDDEN;
+
+NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size);
+NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size);
+
+#endif /* __WINE_WAYLANDDRV_DLL_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
new file mode 100644
index 00000000000..99cd74be793
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -0,0 +1,297 @@
+/*
+ * WAYLANDDRV initialization code
+ *
+ * Copyright 2020 Alexandre Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+
+char *process_name = NULL;
+
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        NtTerminateProcess(0, 1);
+    }
+
+    NtClose(handle);
+}
+
+/***********************************************************************
+ *           Initialize per thread data
+ */
+struct wayland_thread_data *wayland_init_thread_data(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data) return data;
+
+    if (!(data = calloc(1, sizeof(*data))))
+    {
+        ERR("could not create data\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    if (!wayland_init(&data->wayland))
+    {
+        ERR_(winediag)("waylanddrv: Can't open wayland display. Please ensure "
+                       "that your wayland server is running and that "
+                       "$WAYLAND_DISPLAY is set correctly.\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    set_queue_fd(&data->wayland);
+    NtUserGetThreadInfo()->driver_data = (UINT_PTR)data;
+
+    /* Create the clipboard window outside of thread init. We delay window
+     * creation since the thread init function may be invoked from within the
+     * context of a user32 function which holds the internal Wine user32 lock.
+     * In such a case creating the clipboard window would cause an internal
+     * user32 lock error. */
+    NtUserPostThreadMessage(data->wayland.thread_id,
+                            WM_WAYLAND_CLIPBOARD_WINDOW_CREATE, 0, 0);
+
+    return data;
+}
+
+/***********************************************************************
+ *           ThreadDetach (WAYLAND.@)
+ */
+static void WAYLAND_ThreadDetach(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data)
+    {
+        wayland_deinit(&data->wayland);
+        free(data);
+        /* clear data in case we get re-entered from user32 before the thread is truly dead */
+        NtUserGetThreadInfo()->driver_data = 0;
+    }
+}
+
+const struct user_driver_funcs waylanddrv_funcs =
+{
+    .dc_funcs.pCreateDC = WAYLAND_CreateDC,
+    .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
+    .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.pPutImage = WAYLAND_PutImage,
+    .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
+
+    .pChangeDisplaySettings = WAYLAND_ChangeDisplaySettings,
+    .pClipCursor = WAYLAND_ClipCursor,
+    .pCreateWindow = WAYLAND_CreateWindow,
+    .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
+    .pDestroyWindow = WAYLAND_DestroyWindow,
+    .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
+    .pGetDisplayDepth = WAYLAND_GetDisplayDepth,
+    .pGetKeyNameText = WAYLAND_GetKeyNameText,
+    .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
+    .pProcessEvents = WAYLAND_ProcessEvents,
+    .pSetCursor = WAYLAND_SetCursor,
+    .pSetCursorPos = WAYLAND_SetCursorPos,
+    .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
+    .pSetWindowRgn = WAYLAND_SetWindowRgn,
+    .pSetWindowStyle = WAYLAND_SetWindowStyle,
+    .pSetWindowText = WAYLAND_SetWindowText,
+    .pShowWindow = WAYLAND_ShowWindow,
+    .pSysCommand = WAYLAND_SysCommand,
+    .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pUpdateLayeredWindow = WAYLAND_UpdateLayeredWindow,
+    .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
+    .pThreadDetach = WAYLAND_ThreadDetach,
+    .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
+    .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanged = WAYLAND_WindowPosChanged,
+    .pWindowPosChanging = WAYLAND_WindowPosChanging,
+    .pwine_get_vulkan_driver = WAYLAND_wine_get_vulkan_driver,
+    .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
+};
+
+static const struct user_driver_funcs null_funcs = { 0 };
+
+static void wayland_init_process_name(void)
+{
+    WCHAR *p, *appname;
+    WCHAR appname_lower[MAX_PATH];
+    DWORD appname_len;
+    DWORD appnamez_size;
+    DWORD utf8_size;
+    int i;
+
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    appname_len = lstrlenW(appname);
+
+    if (appname_len == 0 || appname_len >= MAX_PATH) return;
+
+    for (i = 0; appname[i]; i++) appname_lower[i] = RtlDowncaseUnicodeChar(appname[i]);
+    appname_lower[i] = 0;
+
+    appnamez_size = (appname_len + 1) * sizeof(WCHAR);
+
+    if (!RtlUnicodeToUTF8N(NULL, 0, &utf8_size, appname_lower, appnamez_size) &&
+        (process_name = malloc(utf8_size)))
+    {
+        RtlUnicodeToUTF8N(process_name, utf8_size, &utf8_size, appname_lower, appnamez_size);
+    }
+}
+
+static NTSTATUS waylanddrv_unix_init(void *arg)
+{
+    struct waylanddrv_unix_init_params *params = arg;
+
+    /* Set the user driver functions now so that they are available during
+     * our initialization. We clear them on error. */
+    __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
+
+    wayland_init_process_name();
+
+    wayland_read_options_from_registry();
+
+    wayland_data_device_init_formats();
+
+    if (!wayland_init_set_cursor()) goto err;
+
+    if (!wayland_process_init()) goto err;
+
+    params->option_show_systray = option_show_systray;
+
+    return 0;
+
+err:
+    __wine_set_user_driver(&null_funcs, WINE_GDI_DRIVER_VERSION);
+    return STATUS_UNSUCCESSFUL;
+}
+
+static NTSTATUS waylanddrv_unix_read_events(void *arg)
+{
+    while (wayland_read_events_and_dispatch_process()) continue;
+    /* This function only returns on a fatal error, e.g., if our connection
+     * to the Wayland server is lost. */
+    return STATUS_UNSUCCESSFUL;
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    waylanddrv_unix_init,
+    waylanddrv_unix_read_events,
+    waylanddrv_unix_clipboard_message,
+    waylanddrv_unix_data_offer_accept_format,
+    waylanddrv_unix_data_offer_import_format,
+    waylanddrv_unix_data_offer_enum_formats,
+};
+
+C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
+
+#ifdef _WIN64
+
+static NTSTATUS waylanddrv_unix_clipboard_message_wow64(void *arg)
+{
+    struct {
+        ULONG hwnd;
+        UINT msg;
+        ULONG wparam;
+        ULONG lparam;
+    } *params32 = arg;
+    struct waylanddrv_unix_clipboard_message_params params;
+
+    params.hwnd = UlongToHandle(params32->hwnd);
+    params.msg = params32->msg;
+    params.wparam = params32->wparam;
+    params.lparam = params32->lparam;
+    return waylanddrv_unix_clipboard_message(&params);
+}
+
+static NTSTATUS waylanddrv_unix_data_offer_enum_formats_wow64(void *arg)
+{
+    struct {
+        PTR32 data_offer;
+        ULONG formats;
+        UINT num_formats;
+    } *params32 = arg;
+    struct waylanddrv_unix_data_offer_enum_formats_params params;
+
+    params.data_offer = params32->data_offer;
+    params.formats = UlongToPtr(params32->formats);
+    params.num_formats = params32->num_formats;
+    return waylanddrv_unix_data_offer_enum_formats(&params);
+}
+
+const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
+{
+    waylanddrv_unix_init,
+    waylanddrv_unix_read_events,
+    waylanddrv_unix_clipboard_message_wow64,
+    waylanddrv_unix_data_offer_accept_format,
+    waylanddrv_unix_data_offer_import_format,
+    waylanddrv_unix_data_offer_enum_formats_wow64,
+};
+
+C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == waylanddrv_unix_func_count);
+
+#endif /* _WIN64 */
+
+/***********************************************************************
+ *           waylanddrv_client_call
+ */
+NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
+                                ULONG size)
+{
+    void *ret_ptr;
+    ULONG ret_len;
+    return KeUserModeCallback(func, params, size, &ret_ptr, &ret_len);
+}
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
new file mode 100644
index 00000000000..78a08c95976
--- /dev/null
+++ b/dlls/winewayland.drv/window.c
@@ -0,0 +1,1873 @@
+/*
+ * Window related functions
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntgdi.h"
+#include "ntuser.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+#include <limits.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* private window data */
+struct wayland_win_data
+{
+    /* hwnd that this private data belongs to */
+    HWND           hwnd;
+    /* parent hwnd for child windows */
+    HWND           parent;
+    /* effective parent hwnd (what the driver considers to
+     * be the parent for relative positioning) */
+    HWND           effective_parent;
+    /* USER window rectangle relative to parent */
+    RECT           window_rect;
+    /* client area relative to parent */
+    RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* wine window_surface backing this window */
+    struct window_surface *window_surface;
+    /* pending wine window_surface for this window */
+    struct window_surface *pending_window_surface;
+    /* whether the pending_window_surface value is valid */
+    BOOL           has_pending_window_surface;
+    /* whether this window is currently being resized */
+    BOOL           resizing;
+    /* the window_rect this window should be restored to after unmaximizing */
+    RECT           restore_rect;
+    /* whether the window is currently fullscreen */
+    BOOL           fullscreen;
+    /* whether the window is currently maximized */
+    BOOL           maximized;
+    /* whether we are currently handling a wayland configure event */
+    BOOL           handling_wayland_configure_event;
+    /* the configure flags for the configure event we are handling */
+    enum wayland_configure_flags wayland_configure_event_flags;
+    /* whether this window is visible */
+    BOOL           visible;
+    /* Save previous state to be able to decide when to recreate wayland surface */
+    HWND           old_parent;
+    RECT           old_window_rect;
+    /* whether a wayland surface update is needed */
+    BOOL           wayland_surface_needs_update;
+    /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
+    BOOL           pending_state_update_message;
+    /* The serial of the next expected WM_WAYLAND_SURFACE_OUTPUT_CHANGE message */
+    UINT           pending_surface_output_change_serial;
+};
+
+static struct wayland_mutex win_data_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": win_data_mutex"
+};
+
+static struct wayland_win_data *win_data_context[32768];
+
+static inline int context_idx(HWND hwnd)
+{
+    return LOWORD(hwnd) >> 1;
+}
+
+/***********************************************************************
+ *           wayland_win_data_destroy
+ */
+static void wayland_win_data_destroy(struct wayland_win_data *data)
+{
+    TRACE("hwnd=%p\n", data->hwnd);
+    win_data_context[context_idx(data->hwnd)] = NULL;
+
+    if (data->has_pending_window_surface && data->pending_window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->pending_window_surface, NULL);
+        window_surface_release(data->pending_window_surface);
+    }
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+        window_surface_release(data->window_surface);
+    }
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
+    free(data);
+
+    wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+static struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    if (!hwnd) return NULL;
+
+    wayland_mutex_lock(&win_data_mutex);
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data;
+    wayland_mutex_unlock(&win_data_mutex);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_release
+ *
+ * Release the data returned by wayland_win_data_get.
+ */
+static void wayland_win_data_release(struct wayland_win_data *data)
+{
+    if (data) wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_win_data_create
+ *
+ * Create a data window structure for an existing window.
+ */
+static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    HWND parent;
+
+    /* Don't create win data for desktop or HWND_MESSAGE windows. */
+    if (!(parent = NtUserGetAncestor(hwnd, GA_PARENT))) return NULL;
+    if (parent != NtUserGetDesktopWindow() && !NtUserGetAncestor(parent, GA_PARENT))
+        return NULL;
+
+    if (!(data = calloc(1, sizeof(*data))))
+        return NULL;
+
+    data->hwnd = hwnd;
+    data->wayland_surface_needs_update = TRUE;
+
+    wayland_mutex_lock(&win_data_mutex);
+    win_data_context[context_idx(hwnd)] = data;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    return data;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_lock
+ *
+ *  Gets the wayland surface for HWND while locking the private window data.
+ */
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+
+    if (data && data->wayland_surface)
+        return data->wayland_surface;
+
+    wayland_win_data_release(data);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlock
+ */
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+{
+    if (surface) wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlocked
+ *
+ * Helper function to get the wayland_surface for a HWND without any locking.
+ * The caller should ensure that win_data_mutex has been locked before this
+ * operation, and for as long as the association between the HWND and the
+ * returned wayland_surface needs to remain valid.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_unlocked(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    assert(win_data_mutex.owner_tid == GetCurrentThreadId());
+
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data->wayland_surface;
+
+    return NULL;
+}
+
+static BOOL can_be_effective_parent(HWND hwnd, HWND parent_hwnd)
+{
+    struct wayland_surface *surface, *parent_surface;
+
+    if (parent_hwnd == 0)
+        return FALSE;
+
+    if (parent_hwnd == hwnd)
+    {
+        TRACE("hwnd=%p can't use parent=%p since it's itself\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (!(parent_surface = wayland_surface_for_hwnd_unlocked(parent_hwnd)))
+    {
+        TRACE("hwnd=%p can't use parent=%p since we are not tracking it\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (NtUserGetAncestor(hwnd, GA_PARENT) != parent_hwnd &&
+        !(NtUserGetWindowLongW(parent_hwnd, GWL_STYLE) & WS_VISIBLE))
+    {
+        TRACE("hwnd=%p (non-child) can't use parent=%p since it's not visible\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    surface = wayland_surface_for_hwnd_unlocked(hwnd);
+    parent_surface = parent_surface->parent;
+    while (parent_surface)
+    {
+        if (surface == parent_surface)
+        {
+            TRACE("hwnd=%p can't use parent=%p since hwnd is an effective ancestor\n",
+                  hwnd, parent_hwnd);
+            return FALSE;
+        }
+        parent_surface = parent_surface->parent;
+    }
+
+    return TRUE;
+}
+
+static HWND guess_popup_parent(struct wayland *wayland, HWND hwnd)
+{
+    HWND pointer_hwnd;
+    HWND cursor_hwnd;
+    HWND keyboard_hwnd;
+    HWND focus_hwnd;
+    HWND popup_hwnd;
+    POINT cursor;
+
+    pointer_hwnd = wayland->pointer.focused_surface ?
+                   wayland->pointer.focused_surface->hwnd : NULL;
+    if (pointer_hwnd)
+        pointer_hwnd = NtUserGetAncestor(pointer_hwnd, GA_ROOT);
+
+    NtUserGetCursorPos(&cursor);
+    cursor_hwnd = NtUserWindowFromPoint(cursor.x, cursor.y);
+    if (cursor_hwnd)
+        cursor_hwnd = NtUserGetAncestor(cursor_hwnd, GA_ROOT);
+
+    keyboard_hwnd = wayland->keyboard.focused_surface ?
+                    wayland->keyboard.focused_surface->hwnd : NULL;
+    if (keyboard_hwnd)
+        keyboard_hwnd = NtUserGetAncestor(keyboard_hwnd, GA_ROOT);
+
+    focus_hwnd = get_focus();
+    if (focus_hwnd)
+        focus_hwnd = NtUserGetAncestor(focus_hwnd, GA_ROOT);
+
+    TRACE("pointer_hwnd=%p cursor_hwnd=%p keyboard_hwnd=%p focus_hwnd=%p "
+          "last_event_type=%d\n",
+          pointer_hwnd, cursor_hwnd, keyboard_hwnd, focus_hwnd,
+          wayland->last_event_type);
+
+    /* If we have a recent mouse event, the popup parent is likely the window
+     * under the cursor, so prefer it. Otherwise prefer the window with
+     * the keyboard focus. */
+    if (wayland->last_event_type == INPUT_MOUSE)
+    {
+        if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+    else
+    {
+        if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+
+    TRACE("=> popup_hwnd=%p\n", popup_hwnd);
+
+    return popup_hwnd;
+}
+
+/* Whether we consider this window to be a transient popup, so we can
+ * display it as a Wayland subsurface with relative positioning. */
+static BOOL wayland_win_data_can_be_popup(struct wayland_win_data *data)
+{
+    DWORD style;
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    double monitor_width;
+    double monitor_height;
+    int window_width;
+    int window_height;
+
+    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Child windows can't be popups, unless they are children of the desktop
+     * (thus effectively top-level). */
+    if ((style & WS_CHILD) && NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT))
+    {
+        TRACE("hwnd=%p is child => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* Minimized windows can't be popups. */
+    if (style & WS_MINIMIZE)
+    {
+        TRACE("hwnd=%p is minimized => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* If the window has top bar elements, don't consider it a popup candidate. */
+    if ((style & WS_CAPTION) == WS_CAPTION ||
+        (style & (WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)))
+    {
+        TRACE("hwnd=%p style=0x%08x => FALSE\n", data->hwnd, (UINT)style);
+        return FALSE;
+    }
+
+    mi.cbSize = sizeof(mi);
+    if (!(hmonitor = NtUserMonitorFromRect(&data->window_rect, MONITOR_DEFAULTTOPRIMARY)) ||
+        !NtUserGetMonitorInfo(hmonitor, &mi))
+    {
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    monitor_width = mi.rcMonitor.right - mi.rcMonitor.left;
+    monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
+    window_width = data->window_rect.right - data->window_rect.left;
+    window_height = data->window_rect.bottom - data->window_rect.top;
+
+    /* If the window has an unreasonably small size or is too large, don't consider
+     * it a popup candidate. */
+    if (window_width <= 1 || window_height <= 1 ||
+        window_width * window_height > 0.5 * monitor_width * monitor_height)
+    {
+        TRACE("hwnd=%p window=%s monitor=%s => FALSE\n",
+              data->hwnd, wine_dbgstr_rect(&data->window_rect),
+              wine_dbgstr_rect(&mi.rcMonitor));
+        return FALSE;
+    }
+
+    TRACE("hwnd=%p style=0x%08x window=%s monitor=%s => TRUE\n",
+          data->hwnd, (UINT)style, wine_dbgstr_rect(&data->window_rect),
+          wine_dbgstr_rect(&mi.rcMonitor));
+
+    return TRUE;
+}
+
+static HWND wayland_win_data_get_effective_parent(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_init_wayland();
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    HWND parent_hwnd = (HWND)NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    HWND effective_parent_hwnd;
+
+    if (!can_be_effective_parent(data->hwnd, parent_hwnd))
+        parent_hwnd = 0;
+
+    /* Many applications use top level, unowned (or owned by the desktop)
+     * popup windows for menus and tooltips and depend on screen
+     * coordinates for correct positioning. Since wayland can't deal with
+     * screen coordinates, try to guess the effective parent window of such
+     * popups and manage them as wayland subsurfaces. */
+    if (!parent_hwnd && wayland_win_data_can_be_popup(data))
+        effective_parent_hwnd = guess_popup_parent(wayland, data->hwnd);
+    else
+        effective_parent_hwnd = parent_hwnd;
+
+    TRACE("hwnd=%p parent=%p effective_parent=%p\n",
+          data->hwnd, parent_hwnd, effective_parent_hwnd);
+
+    return effective_parent_hwnd;
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_update)
+        return TRUE;
+
+    /* Change of parentage (either actual or effective) requires recreating the
+     * whole win_data to ensure we have a properly owned wayland surface. We
+     * check for change of effective parent only if the window changed in any
+     * way, to avoid spuriously reassigning parent windows when new windows
+     * are created. */
+    if ((!EqualRect(&data->window_rect, &data->old_window_rect) &&
+         data->effective_parent != wayland_win_data_get_effective_parent(data)) ||
+        data->parent != data->old_parent)
+    {
+        return TRUE;
+    }
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct wayland_surface *update_surface_for_role(struct wayland_win_data *data,
+                                                       enum wayland_surface_role role,
+                                                       struct wayland *wayland,
+                                                       struct wayland_surface *parent_surface)
+{
+    struct wayland_surface *surface = data->wayland_surface;
+
+    if (!surface ||
+        (role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != role))
+    {
+        surface = wayland_surface_create_plain(wayland);
+        if (surface) wayland_mutex_lock(&surface->mutex);
+        surface->hwnd = data->hwnd;
+    }
+    else
+    {
+        /* Lock the wayland surface to avoid other threads interacting with it
+         * while we are updating. */
+        wayland_mutex_lock(&surface->mutex);
+        wayland_surface_clear_role(surface);
+    }
+
+    if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
+        wayland_surface_make_toplevel(surface, parent_surface);
+    else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        wayland_surface_make_subsurface(surface, parent_surface);
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    return surface;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND effective_parent_hwnd;
+    struct wayland_surface *surface;
+    struct wayland_surface *parent_surface;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_update = FALSE;
+
+    effective_parent_hwnd = wayland_win_data_get_effective_parent(data);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+        parent_surface = wayland_surface_for_hwnd_unlocked(effective_parent_hwnd);
+
+    data->effective_parent = effective_parent_hwnd;
+
+    /* Reset window state, so that it can be properly applied again. */
+    data->maximized = FALSE;
+    data->fullscreen = FALSE;
+
+    /* Use wayland subsurfaces for children windows and toplevels that we
+     * consider to be popups and have an effective parent. Otherwise, if the
+     * window is visible make it wayland toplevel. Finally, if the window is
+     * not visible create a plain (without a role) surface to avoid polluting
+     * the compositor with empty xdg_toplevels. */
+    if (parent_surface && (data->parent || wayland_win_data_can_be_popup(data)))
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
+                                          wayland, parent_surface);
+    }
+    else if (data->visible)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_TOPLEVEL,
+                                          wayland, parent_surface);
+    }
+    else
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_NONE,
+                                          wayland, parent_surface);
+    }
+
+    if (surface && surface->xdg_toplevel)
+    {
+        WCHAR text[1024];
+        if (!NtUserInternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text)))
+            text[0] = 0;
+        wayland_surface_set_title(data->wayland_surface, text);
+    }
+
+    if (data->wayland_surface != surface)
+    {
+        if (data->wayland_surface)
+        {
+            struct wayland_surface *child;
+
+            /* Dependent Wayland surfaces require an update, so that they point
+             * to the updated surface. */
+            wayland_mutex_lock(&data->wayland_surface->mutex);
+            wl_list_for_each(child, &data->wayland_surface->child_list, parent_link)
+            {
+                struct wayland_win_data *child_data;
+                /* Don't handle glvk subsurfaces here, they are updated specially
+                 * below. */
+                if (child != data->wayland_surface->glvk &&
+                    (child_data = wayland_win_data_get(child->hwnd)))
+                {
+                    child_data->wayland_surface_needs_update = TRUE;
+                    wayland_win_data_release(child_data);
+                }
+            }
+            wayland_mutex_unlock(&data->wayland_surface->mutex);
+
+            wayland_surface_unref(data->wayland_surface);
+        }
+
+        data->wayland_surface = surface;
+
+        wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
+        /* Force client to recreate any Vulkan objects so that we use the updated
+         * backing Wayland surface in our internal Vulkan representations. */
+        wayland_invalidate_vulkan_objects(data->hwnd);
+    }
+}
+
+static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *data)
+{
+    int wayland_width, wayland_height;
+    BOOL compat_with_current = FALSE;
+    BOOL compat_with_pending = FALSE;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    enum wayland_configure_flags conf_flags = 0;
+    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    HMONITOR hmonitor;
+    MONITORINFOEXW mi;
+    struct wayland_output *output;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        output = wayland_output_get_by_wine_name(wsurface->wayland, mi.szDevice);
+    }
+    else
+    {
+        output = NULL;
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d handling_event=%d\n",
+          data->hwnd, width, height,
+          (int)(mi.rcMonitor.right - mi.rcMonitor.left),
+          (int)(mi.rcMonitor.bottom - mi.rcMonitor.top),
+          data->maximized, data->fullscreen, data->handling_wayland_configure_event);
+
+    wayland_surface_set_wine_output(data->wayland_surface, output);
+
+    /* If we are currently handling a wayland configure event (i.e., we are
+     * being called through handle_wm_wayland_configure() -> SetWindowPos()),
+     * use the event configure flags directly. Otherwise try to infer the flags
+     * from the window style and rectangle. */
+    if (data->handling_wayland_configure_event)
+    {
+        conf_flags = data->wayland_configure_event_flags;
+    }
+    else
+    {
+        /* Set the wayland fullscreen state if the window rect covers the
+         * current monitor. Note that we set/maintain the fullscreen
+         * wayland state, even if the window style is also maximized. */
+        if (contains_rect(&data->window_rect, &mi.rcMonitor) &&
+            !(style & (WS_MINIMIZE|WS_CAPTION)))
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        }
+        if (style & WS_MAXIMIZE)
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        }
+    }
+
+    /* First do all state unsettings, before setting new state. Some wayland
+     * compositors misbehave if the order is reversed. */
+    if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
+        data->maximized = FALSE;
+    }
+
+    if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
+        data->fullscreen = FALSE;
+    }
+
+    if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
+        data->maximized = TRUE;
+    }
+
+   /* Set the fullscreen state after the maximized state on the wayland surface
+    * to ensure compositors apply the final fullscreen state properly. */
+    if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        if (!data->handling_wayland_configure_event)
+        {
+            xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
+                                        output ? output->wl_output : NULL);
+        }
+        data->fullscreen = TRUE;
+    }
+
+    /* Ensure state change requests reach the compositor promptly. */
+    wl_display_flush(thread_wayland()->wl_display);
+
+    if (!(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        !(style & WS_MINIMIZE))
+    {
+        data->restore_rect = data->window_rect;
+        TRACE("setting hwnd=%p restore_rect=%s\n",
+              data->hwnd, wine_dbgstr_rect(&data->restore_rect));
+    }
+
+    /* Mark in the surface whether the associated window is fullscreen. */
+    wsurface->window_fullscreen = data->fullscreen;
+
+    TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
+          data->hwnd, data->maximized, data->fullscreen);
+
+    wayland_surface_coords_rounded_from_wine(wsurface, width, height,
+                                             &wayland_width, &wayland_height);
+
+    if (wsurface->current.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->current,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_current = TRUE;
+    }
+
+    if (wsurface->pending.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->pending,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_pending = TRUE;
+    }
+
+    TRACE("current conf serial=%d size=%dx%d flags=%#x\n compat=%d\n",
+          wsurface->current.serial, wsurface->current.width,
+          wsurface->current.height, wsurface->current.configure_flags,
+          compat_with_current);
+    TRACE("pending conf serial=%d size=%dx%d flags=%#x compat=%d\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          compat_with_pending);
+
+    /* Only update the wayland surface state to match the window
+     * configuration if the surface can accept the new config, in order to
+     * avoid transient states that may cause glitches. */
+    if (!compat_with_pending && !compat_with_current)
+    {
+        TRACE("hwnd=%p window state not compatible with current or "
+              "pending wayland surface configuration\n", data->hwnd);
+        wsurface->drawing_allowed = FALSE;
+        return FALSE;
+    }
+
+    if (compat_with_pending)
+        wayland_surface_ack_pending_configure(wsurface);
+
+    return TRUE;
+}
+
+static BOOL wayland_win_data_is_fullscreen_with_overshoot(struct wayland_win_data *data)
+{
+    RECT monitor_rect;
+    struct wayland_output *output;
+
+    if (!data->fullscreen) return FALSE;
+    if (!data->wayland_surface) return FALSE;
+
+    output = data->wayland_surface->main_output;
+    if (!output || !output->current_wine_mode) return FALSE;
+
+    SetRect(&monitor_rect, output->x, output->y,
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
+
+    return data->window_rect.left < monitor_rect.left &&
+           data->window_rect.top < monitor_rect.top &&
+           data->window_rect.right >= monitor_rect.right &&
+           data->window_rect.bottom >= monitor_rect.bottom;
+}
+
+static void wayland_win_data_get_wine_size_for_conf(struct wayland_win_data *data,
+                                                    struct wayland_surface_configure *conf,
+                                                    int *wine_width, int *wine_height)
+{
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        wayland_win_data_is_fullscreen_with_overshoot(data))
+    {
+        /* If the window is fullscreen while overshooting the monitor bounds
+         * don't try to resize it. Forcing the Wayland preferred size in such
+         * cases may trigger an endless loop of resizes while both the
+         * compositor and the app try to enforce different window sizes. */
+        *wine_width = data->window_rect.right - data->window_rect.left;
+        *wine_height = data->window_rect.bottom - data->window_rect.top;
+    }
+    else if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+             !(conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_find_wine_fullscreen_fit(data->wayland_surface,
+                                                 conf->width, conf->height,
+                                                 wine_width, wine_height);
+    }
+    else
+    {
+        wayland_surface_coords_to_wine(data->wayland_surface,
+                                       conf->width, conf->height,
+                                       wine_width, wine_height);
+    }
+}
+
+static void wayland_win_data_get_rect_in_monitor(struct wayland_win_data *data,
+                                                 enum wayland_configure_flags flags,
+                                                 RECT *rect)
+{
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    RECT *area = NULL;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+            area = &mi.rcMonitor;
+        else if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+            area = &mi.rcWork;
+    }
+
+    if (area)
+    {
+        intersect_rect(rect, area, &data->window_rect);
+        OffsetRect(rect, -data->window_rect.left, -data->window_rect.top);
+    }
+    else
+    {
+        SetRectEmpty(rect);
+    }
+}
+
+static void wayland_win_data_get_compatible_rect(struct wayland_win_data *data,
+                                                 RECT *rect)
+{
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    int wine_conf_width, wine_conf_height;
+    enum wayland_configure_flags conf_flags =
+        data->wayland_surface->current.configure_flags;
+
+    /* Get the window size corresponding to the Wayland surface configuration. */
+    wayland_win_data_get_wine_size_for_conf(data,
+                                            &data->wayland_surface->current,
+                                            &wine_conf_width,
+                                            &wine_conf_height);
+
+    /* If Wayland requires a surface size smaller than what wine provides,
+     * use part of the window contents for the surface. */
+    if (((conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+         (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        (width > wine_conf_width || height > wine_conf_height))
+    {
+        wayland_win_data_get_rect_in_monitor(data, conf_flags, rect);
+        /* If the window rect in the monitor is smaller than required
+         * fall back to an appropriately sized rect at the top-left. */
+        if (rect->right - rect->left < wine_conf_width ||
+            rect->bottom - rect->top < wine_conf_height)
+        {
+            SetRect(rect, 0, 0, wine_conf_width, wine_conf_height);
+        }
+        else
+        {
+            rect->right = min(rect->right, rect->left + wine_conf_width);
+            rect->bottom = min(rect->bottom, rect->top + wine_conf_height);
+        }
+        TRACE("Window is too large for wayland state, using subarea\n");
+    }
+    else
+    {
+        SetRect(rect, 0, 0, width, height);
+    }
+}
+
+static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
+{
+    RECT screen_rect;
+    RECT parent_screen_rect;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    TRACE("hwnd=%p window=%dx%d style=0x%08x\n", data->hwnd, width, height, (UINT)style);
+
+    if (!(style & WS_VISIBLE))
+    {
+        wayland_surface_unmap(wsurface);
+        return;
+    }
+
+    /* Lock the wayland surface to avoid commits from other threads while we
+     * are setting up the new state. */
+    wayland_mutex_lock(&wsurface->mutex);
+
+    if (wsurface->xdg_toplevel &&
+        !wayland_win_data_update_wayland_xdg_state(data))
+    {
+        wayland_mutex_unlock(&wsurface->mutex);
+        return;
+    }
+
+    wayland_surface_reconfigure_size(wsurface, width, height);
+
+    if (wsurface->wl_subsurface)
+    {
+        /* In addition to children windows, we manage some top level, popup window
+         * with subsurfaces (see wayland_win_data_get_effective_parent), which use
+         * coordinates relative to their parent surface. */
+        if (!NtUserGetWindowRect(data->hwnd, &screen_rect))
+            SetRectEmpty(&screen_rect);
+        if (!NtUserGetWindowRect(data->effective_parent, &parent_screen_rect))
+            SetRectEmpty(&parent_screen_rect);
+
+        wayland_surface_reconfigure_position(
+            wsurface,
+            screen_rect.left - parent_screen_rect.left,
+            screen_rect.top - parent_screen_rect.top);
+    }
+    else if (wsurface->xdg_surface)
+    {
+        RECT compat;
+        wayland_win_data_get_compatible_rect(data, &compat);
+        wayland_surface_reconfigure_geometry(wsurface, compat.left, compat.top,
+                                             compat.right - compat.left,
+                                             compat.bottom - compat.top);
+    }
+
+    /* The GL/VK subsurface (if any), is positioned over the client area of the
+     * window. The position of the GL/VK subsurface is relative to the window
+     * top-left. */
+    wayland_surface_reconfigure_glvk(wsurface,
+                                     data->client_rect.left - data->window_rect.left,
+                                     data->client_rect.top - data->window_rect.top,
+                                     data->client_rect.right - data->client_rect.left,
+                                     data->client_rect.bottom - data->client_rect.top);
+
+    if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
+        wsurface->drawing_allowed = TRUE;
+
+    /* Some compositors require the surface to be mapped when we have an
+     * ack-ed configuration. */
+    if (wsurface->current.serial)
+        wayland_surface_ensure_mapped(wsurface);
+
+    wayland_surface_reconfigure_apply(wsurface);
+
+    wayland_mutex_unlock(&wsurface->mutex);
+
+    wayland_surface_update_pointer_constraint(wsurface);
+}
+
+static struct wayland_win_data *update_wayland_state(struct wayland_win_data *data)
+{
+    HWND hwnd = data->hwnd;
+
+    /* Ensure we have a thread wayland instance. Perform the initialization
+     * outside the win_data lock to avoid potential deadlocks. */
+    if (!thread_wayland())
+    {
+        wayland_win_data_release(data);
+        thread_init_wayland();
+        data = wayland_win_data_get(hwnd);
+        if (!data) return NULL;
+    }
+
+    if (data->has_pending_window_surface)
+    {
+        if (data->window_surface)
+        {
+            if (data->window_surface != data->pending_window_surface)
+                wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+            window_surface_release(data->window_surface);
+        }
+        data->window_surface = data->pending_window_surface;
+        data->has_pending_window_surface = FALSE;
+        data->pending_window_surface = NULL;
+    }
+
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+
+    if (data->wayland_surface)
+        wayland_win_data_update_wayland_surface_state(data);
+
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+        if (wayland_window_surface_needs_flush(data->window_surface))
+            wayland_window_surface_flush(data->window_surface);
+    }
+
+    if (data->wayland_surface && data->wayland_surface->xdg_toplevel &&
+        data->wayland_surface->main_output)
+    {
+        struct wayland_output *output = data->wayland_surface->main_output;
+        /* We increase the serial even if we don't end up posting
+         * WM_WAYLAND_SURFACE_OUTPUT_CHANGE, to ensure all previous pending
+         * requests are invalidated. */
+        data->pending_surface_output_change_serial++;
+        /* Skip zero if we wrap around, since it has a special meaning. */
+        if (data->pending_surface_output_change_serial == 0)
+            data->pending_surface_output_change_serial++;
+
+        /* To maintain some degree of consistency between the Wayland surface and
+         * Windows window positioning, place top-level windows on the output
+         * dictated by the compositor. We position the window at the origin of that
+         * output to maximize the window area that is accessible by mouse events.
+         * We perform the move if the window:
+         * 1. is not already at origin, and
+         * 2. is not minimized
+         * 3. is not fullscreen */
+        if ((data->window_rect.left != output->x || data->window_rect.top != output->y) &&
+            !(NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_MINIMIZE) &&
+            !data->fullscreen)
+        {
+            TRACE("hwnd=%p window_rect=%s not at origin %dx%d, scheduling move\n",
+                  data->hwnd, wine_dbgstr_rect(&data->window_rect),
+                  output->x, output->y);
+            NtUserPostMessage(hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+                              data->pending_surface_output_change_serial, 0);
+        }
+    }
+
+    return data;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateWindow
+ */
+BOOL WAYLAND_CreateWindow(HWND hwnd)
+{
+    TRACE("%p\n", hwnd);
+
+    if (hwnd == NtUserGetDesktopWindow())
+    {
+        /* Initialize wayland so that the desktop process has access
+         * to all the wayland related information (e.g., displays). */
+        wayland_init_thread_data();
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLAND_DestroyWindow
+ */
+void WAYLAND_DestroyWindow(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    TRACE("%p\n", hwnd);
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_clear_window_surface_last_flushed(hwnd);
+    wayland_destroy_gl_drawable(hwnd);
+    wayland_invalidate_vulkan_objects(hwnd);
+    wayland_destroy_remote_surfaces(hwnd);
+    wayland_win_data_destroy(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanging
+ */
+BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                               const RECT *window_rect, const RECT *client_rect,
+                               RECT *visible_rect, struct window_surface **surface)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    BOOL exstyle = NtUserGetWindowLongW(hwnd, GWL_EXSTYLE);
+    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
+    RECT surface_rect;
+    DWORD flags;
+    COLORREF color_key;
+    BYTE alpha;
+
+    TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), (UINT)style, exstyle, swp_flags, insert_after);
+
+    if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
+
+    data->old_parent = data->parent;
+    data->old_window_rect = data->window_rect;
+    data->parent = (parent == NtUserGetDesktopWindow()) ? 0 : parent;
+    data->window_rect = *window_rect;
+    data->client_rect = *client_rect;
+    data->visible = ((style & WS_VISIBLE) == WS_VISIBLE ||
+                     (swp_flags & SWP_SHOWWINDOW)) &&
+                    !(swp_flags & SWP_HIDEWINDOW);
+
+    /* Release the dummy surface wine provides for toplevels. */
+    if (*surface) window_surface_release(*surface);
+    *surface = NULL;
+
+    /* Check if we don't want a dedicated window surface. */
+    if (data->parent || !data->visible) goto done;
+
+    surface_rect = *window_rect;
+    OffsetRect(&surface_rect, -surface_rect.left, -surface_rect.top);
+
+    /* Check if we can reuse our current window surface. */
+    if (data->window_surface &&
+        EqualRect(&data->window_surface->rect, &surface_rect))
+    {
+        window_surface_add_ref(data->window_surface);
+        *surface = data->window_surface;
+        TRACE("reusing surface %p\n", *surface);
+        goto done;
+    }
+
+    /* Create new window surface. */
+    color_key = alpha = flags = 0;
+    if (!(exstyle & WS_EX_LAYERED) ||
+        !NtUserGetLayeredWindowAttributes(hwnd, &color_key, &alpha, &flags))
+    {
+        flags = 0;
+    }
+    if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
+
+done:
+    wayland_win_data_release(data);
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), (UINT)NtUserGetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    if (surface) window_surface_add_ref(surface);
+    if (data->has_pending_window_surface && data->pending_window_surface)
+        window_surface_release(data->pending_window_surface);
+    data->pending_window_surface = surface;
+    data->has_pending_window_surface = TRUE;
+
+    /* In some cases, notably when the app calls UpdateLayeredWindow, position
+     * and size changes may be emitted from a thread other than the window
+     * thread. Since in the current implementation updating the wayland state
+     * needs to happen in the context of the window thread to avoid racy
+     * interactions, post a message to update the state in the right thread. */
+    if (GetCurrentThreadId() == NtUserGetWindowThread(hwnd, NULL))
+    {
+        data = update_wayland_state(data);
+    }
+    else if (!data->pending_state_update_message)
+    {
+        NtUserPostMessage(hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+        data->pending_state_update_message = TRUE;
+    }
+
+    wayland_win_data_release(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_ShowWindow
+ */
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+{
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p cmd=%d\n", hwnd, cmd);
+
+    if (IsRectEmpty(rect)) return swp;
+    if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE)) return swp;
+    /* always hide icons off-screen */
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect(rect, -32000 - rect->left, -32000 - rect->top);
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+
+    if ((wsurface = wayland_surface_for_hwnd_lock(hwnd)) && wsurface->xdg_toplevel)
+        xdg_toplevel_set_minimized(wsurface->xdg_toplevel);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+
+    return swp;
+}
+
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
+/***********************************************************************
+ *           WAYLAND_SetWindowStyle
+ */
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
+{
+    struct wayland_win_data *data;
+    DWORD changed = style->styleNew ^ style->styleOld;
+
+    TRACE("hwnd=%p offset=%d changed=%#x\n", hwnd, offset, (UINT)changed);
+
+    if (hwnd == NtUserGetDesktopWindow()) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED))
+    {
+        TRACE("hwnd=%p changed layered\n", hwnd);
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
+    }
+
+    wayland_win_data_release(data);
+}
+
+/*****************************************************************
+ *		WAYLAND_SetWindowText
+ */
+void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
+{
+    struct wayland_surface *wsurface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p text=%s\n", hwnd, wine_dbgstr_w(text));
+
+    if (wsurface && wsurface->xdg_toplevel)
+        wayland_surface_set_title(wsurface, text);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
+/***********************************************************************
+ *	     WAYLAND_SetLayeredWindowAttributes
+ */
+void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if (!(flags & LWA_COLORKEY)) key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
+        wayland_win_data_release(data);
+    }
+}
+
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect)
+{
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, (UINT)info->crKey, wine_dbgstr_rect(info->prcDirty), (UINT)info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = NtGdiCreateDIBSection(info->hdcDst, NULL, 0, bmi, DIB_RGB_COLORS, 0, 0, 0, &src_bits))) goto done;
+    if (!(hdc = NtGdiCreateCompatibleDC(0))) goto done;
+
+    NtGdiSelectBitmap(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        intersect_rect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        NtGdiPatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    NtGdiTransformPoints(info->hdcSrc, (POINT *)&src_rect, (POINT *)&src_rect, 2, NtGdiDPtoLP);
+
+    ret = NtGdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                          info->hdcSrc, src_rect.left, src_rect.top,
+                          src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                          (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend, 0);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        union_rect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) NtGdiDeleteObjectApp(hdc);
+    if (dib) NtGdiDeleteObjectApp(dib);
+    return ret;
+}
+
+static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
+{
+    switch (hittest) {
+    case WMSZ_LEFT:        return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
+    case WMSZ_RIGHT:       return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
+    case WMSZ_TOP:         return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
+    case WMSZ_TOPLEFT:     return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
+    case WMSZ_TOPRIGHT:    return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
+    case WMSZ_BOTTOM:      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
+    case WMSZ_BOTTOMLEFT:  return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
+    case WMSZ_BOTTOMRIGHT: return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
+    default:               return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
+    }
+}
+
+/***********************************************************************
+ *          WAYLAND_SysCommand
+ */
+LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
+{
+    LRESULT ret = -1;
+    WPARAM command = wparam & 0xfff0;
+    WPARAM hittest = wparam & 0x0f;
+    struct wayland_surface *wsurface;
+
+    TRACE("cmd=%lx hwnd=%p, %lx, %lx\n", (long)command, hwnd, (long)wparam, lparam);
+
+    if (!(wsurface = wayland_surface_for_hwnd_lock(hwnd)) || !wsurface->xdg_toplevel)
+        goto done;
+
+    if (command == SC_SIZE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_resize(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                                wsurface->wayland->last_button_serial,
+                                hittest_to_resize_edge(hittest));
+        }
+        ret = 0;
+    }
+    else if (command == SC_MOVE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_move(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                              wsurface->wayland->last_button_serial);
+        }
+        ret = 0;
+    }
+
+done:
+    wayland_surface_for_hwnd_unlock(wsurface);
+    return ret;
+}
+
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    wayland_update_outputs_from_process(wayland);
+
+    /* Update the state of all surfaces tracked by the wayland thread instance,
+     * in case any surface was affected by the monitor changes (e.g., gained or
+     * lost the fullscreen state). We post the message instead of updating the
+     * state synchronously in order to avoid deadlocks, since:
+     * 1. Wayland state updates may involve queries to the Wine monitor info.
+     * 2. This function is expected to be called as part of our display
+     *    configuration sequence which happens under the win32u display lock. */
+    wl_list_for_each(surface, &wayland->surface_list, link)
+        NtUserPostMessage(surface->hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+
+    /* Reapply the cursor to take updated monitor information (e.g., scaling)
+     * into account. */
+    NtUserPostThreadMessage(wayland->thread_id, WM_WAYLAND_REAPPLY_CURSOR, 0, 0);
+}
+
+static void handle_wm_wayland_configure(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+    DWORD flags, style;
+    int width, height, wine_width, wine_height, min_width, min_height;
+    int cxmintrack, cymintrack;
+    UINT swp_flags;
+    BOOL needs_enter_size_move = FALSE;
+    BOOL needs_exit_size_move = FALSE;
+    BOOL needs_set_size = FALSE;
+    BOOL needs_frame_changed = FALSE;
+    MINMAXINFO mm;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    if (!data->wayland_surface || !data->wayland_surface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        wayland_win_data_release(data);
+        return;
+    }
+
+    wsurface = data->wayland_surface;
+
+    TRACE("serial=%d size=%dx%d flags=%#x restore_rect=%s\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          wine_dbgstr_rect(&data->restore_rect));
+
+    if (wsurface->pending.serial == 0)
+    {
+        TRACE("pending configure event already handled, returning\n");
+        wayland_win_data_release(data);
+        return;
+    }
+
+    wsurface->pending.processed = TRUE;
+
+    data->wayland_configure_event_flags = wsurface->pending.configure_flags;
+
+    width = wsurface->pending.width;
+    height = wsurface->pending.height;
+    flags = wsurface->pending.configure_flags;
+    style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+
+    /* Ask the application for the window minimum width/height. It may not
+     * respond to the message, so we first set the system default values. */
+    memset(&mm, 0, sizeof(MINMAXINFO));
+    cxmintrack = mm.ptMinTrackSize.x = NtUserGetSystemMetrics(SM_CXMINTRACK);
+    cymintrack = mm.ptMinTrackSize.y = NtUserGetSystemMetrics(SM_CYMINTRACK);
+    mm.ptMaxTrackSize.x = NtUserGetSystemMetrics(SM_CXMAXTRACK);
+    mm.ptMaxTrackSize.y = NtUserGetSystemMetrics(SM_CYMAXTRACK);
+    send_message(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&mm);
+    wayland_surface_coords_rounded_from_wine(wsurface,
+                                             mm.ptMinTrackSize.x,
+                                             mm.ptMinTrackSize.y,
+                                             &min_width, &min_height);
+
+    /* If the compositor's size hints are smaller than the minimum that the
+     * application supports, ignore the hints, except if the application is
+     * fullscreen or maximized in which case we always need to respect the
+     * requested size to avoid protocol errors. This fixes bugs in which a
+     * compositor forces applications to become so small that would be
+     * impossible to interact with them: some applications do not allow resize
+     * without going through the menus and changing their resolution. */
+    if (!(flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED |
+                   WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        ((width != 0 && width < min_width) || (height != 0 && height < min_height)))
+    {
+        TRACE("ignoring compositor size hint (%dx%d) that is smaller than " \
+              "application minimum (%dx%d, wine=%dx%d)\n",
+              width, height, min_width, min_height,
+              (int)mm.ptMinTrackSize.x, (int)mm.ptMinTrackSize.y);
+        if (width < min_width) width = wsurface->pending.width = 0;
+        if (height < min_height) height = wsurface->pending.height = 0;
+    }
+
+    /* If we are free to set our size, first try the restore size, then
+     * the current size. */
+    if (width == 0)
+    {
+        int ignore;
+        if (!(style & WS_MINIMIZE))
+            width = data->restore_rect.right - data->restore_rect.left;
+        if (width == 0)
+            width = data->window_rect.right - data->window_rect.left;
+        wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
+                                                 &width, &ignore);
+        wsurface->pending.width = width;
+    }
+    if (height == 0)
+    {
+        int ignore;
+        if (!(style & WS_MINIMIZE))
+            height = data->restore_rect.bottom - data->restore_rect.top;
+        if (height == 0)
+            height = data->window_rect.bottom - data->window_rect.top;
+        wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
+                                                 &ignore, &height);
+        wsurface->pending.height = height;
+    }
+
+    wayland_win_data_get_wine_size_for_conf(data, &wsurface->pending,
+                                            &wine_width, &wine_height);
+
+    TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
+          data->hwnd, width, height, wine_width, wine_height);
+
+    if (wine_width > 0 && wine_height > 0 &&
+        (wine_width != data->window_rect.right - data->window_rect.left ||
+         wine_height != data->window_rect.bottom - data->window_rect.top))
+    {
+        needs_set_size = TRUE;
+    }
+
+    if ((flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && !data->resizing)
+    {
+        data->resizing = TRUE;
+        needs_enter_size_move = TRUE;
+    }
+
+    if (!(flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && data->resizing)
+    {
+        data->resizing = FALSE;
+        needs_exit_size_move = TRUE;
+    }
+
+    wayland_win_data_release(data);
+
+    if (needs_enter_size_move)
+        send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+
+    if (needs_exit_size_move)
+        send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = TRUE;
+        wayland_win_data_release(data);
+    }
+
+    if (!(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) != !(style & WS_MAXIMIZE))
+    {
+        NtUserSetWindowLong(hwnd, GWL_STYLE, style ^ WS_MAXIMIZE, FALSE);
+        needs_frame_changed = TRUE;
+    }
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE;
+
+    if (needs_frame_changed) swp_flags |= SWP_FRAMECHANGED;
+    if (!needs_set_size) swp_flags |= SWP_NOSIZE;
+    /* When we are maximized or fullscreen, wayland is particular about the
+     * surface size it accepts, so don't allow the app to change it. */
+    if (flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+        swp_flags |= SWP_NOSENDCHANGING;
+    /* If the maximum size the app allows is less than the minimum window size,
+     * nothing good can come from the app changing the size. */
+    if (mm.ptMaxTrackSize.x < cxmintrack || mm.ptMaxTrackSize.y < cymintrack)
+    {
+        TRACE("disallowing WM_WINDOWPOSCHANGING, app max %ldx%ld < min %dx%d\n",
+              (long)mm.ptMaxTrackSize.x, (long)mm.ptMaxTrackSize.y,
+              cxmintrack, cymintrack);
+        swp_flags |= SWP_NOSENDCHANGING;
+    }
+
+    NtUserSetWindowPos(hwnd, 0, 0, 0, wine_width, wine_height, swp_flags);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = FALSE;
+        wayland_win_data_release(data);
+    }
+}
+
+static void handle_wm_wayland_surface_output_change(HWND hwnd, UINT serial,
+                                                    BOOL resize)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    data = wayland_win_data_get(hwnd);
+    if (serial == 0) serial = ++data->pending_surface_output_change_serial;
+    if (serial != data->pending_surface_output_change_serial)
+    {
+        TRACE("hwnd=%p output change request has superseded serial\n", hwnd);
+        goto out;
+
+    }
+    if (!data || !data->wayland_surface || !data->wayland_surface->xdg_surface)
+    {
+        TRACE("hwnd=%p has no suitable wayland surface\n", hwnd);
+        goto out;
+    }
+
+    wsurface = data->wayland_surface;
+
+    if (wsurface->main_output)
+    {
+        struct wayland_surface_configure *conf;
+        int wine_width = 0;
+        int wine_height = 0;
+        UINT swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER |
+                         SWP_NOSENDCHANGING | SWP_NOSIZE;
+        int x = wsurface->main_output->x;
+        int y = wsurface->main_output->y;
+
+        TRACE("moving window to %d,%d\n", x, y);
+
+        if (wsurface->pending.serial)
+            conf = &wsurface->pending;
+        else if (wsurface->current.serial)
+            conf = &wsurface->current;
+        else
+            conf = NULL;
+
+        /* If we have a configuration that has size requirements (maximized or
+         * fullscreen), resize the window to ensure it matches the expected
+         * Wayland size (taking the new output scale into account). */
+        if (resize && conf && conf->width > 0 && conf->height > 0 &&
+            ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+             (conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)))
+        {
+            wayland_win_data_get_wine_size_for_conf(data, conf,
+                                                    &wine_width, &wine_height);
+
+            TRACE("resizing using %s configuration wayland=%dx%d wine=%dx%d\n",
+                  conf == &wsurface->pending ? "pending" : "current",
+                  conf->width, conf->height,
+                  wine_width, wine_height);
+
+            swp_flags &= ~SWP_NOSIZE;
+            /* Treat the resize as part of compositor initiated configuration. */
+            data->handling_wayland_configure_event = TRUE;
+            data->wayland_configure_event_flags = conf->configure_flags;
+        }
+
+        NtUserSetWindowPos(hwnd, 0, x, y, wine_width, wine_height, swp_flags);
+
+        data->handling_wayland_configure_event = FALSE;
+    }
+
+out:
+    wayland_win_data_release(data);
+}
+
+/**********************************************************************
+ *           WAYLAND_DesktopWindowProc
+ */
+LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_DISPLAYCHANGE:
+        {
+            RECT virtual_rect = NtUserGetVirtualScreenRect();
+            NtUserSetWindowPos(hwnd, 0, virtual_rect.left, virtual_rect.top,
+                               virtual_rect.right - virtual_rect.left,
+                               virtual_rect.bottom - virtual_rect.top,
+                               SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE);
+        }
+        break;
+    }
+
+    return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserDefWindowProc, FALSE);
+}
+
+/**********************************************************************
+ *           WAYLAND_WindowMessage
+ */
+LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    TRACE("msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
+
+    switch (msg)
+    {
+    case WM_WAYLAND_MONITOR_CHANGE:
+        handle_wm_wayland_monitor_change(thread_wayland());
+        break;
+    case WM_WAYLAND_SET_CURSOR:
+        wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
+                                                 (HCURSOR)lp);
+        break;
+    case WM_WAYLAND_QUERY_SURFACE_MAPPED:
+        {
+            LRESULT res;
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            res = wayland_surface ? wayland_surface->mapped : 0;
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+            return res;
+        }
+        break;
+    case WM_WAYLAND_CONFIGURE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            BOOL postpone = data && data->handling_wayland_configure_event;
+            /* Don't process nested WM_WAYLAND_CONFIGURE messages, schedule them for
+             * a bit later instead. */
+            if (postpone && data->wayland_surface)
+                wayland_surface_schedule_wm_configure(data->wayland_surface);
+            wayland_win_data_release(data);
+            if (!postpone) handle_wm_wayland_configure(hwnd);
+        }
+        break;
+    case WM_WAYLAND_STATE_UPDATE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data)
+            {
+                data->pending_state_update_message = FALSE;
+                data = update_wayland_state(data);
+                wayland_win_data_release(data);
+            }
+        }
+        break;
+    case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
+        handle_wm_wayland_surface_output_change(hwnd, wp, lp == 1);
+        break;
+    case WM_WAYLAND_REAPPLY_CURSOR:
+        wayland_reapply_thread_cursor();
+        break;
+    case WM_WAYLAND_WINDOW_SURFACE_FLUSH:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data && data->window_surface)
+                wayland_window_surface_flush(data->window_surface);
+            wayland_win_data_release(data);
+        }
+        break;
+    case WM_WAYLAND_REMOTE_SURFACE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+                wayland_remote_surface_handle_message(wayland_surface, wp, lp);
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
+    case WM_WAYLAND_POINTER_CONSTRAINT_UPDATE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+            {
+                if (wp == WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP)
+                {
+                    NtUserGetClipCursor(&wayland_surface->wayland->cursor_clip);
+                }
+                else if (wp == WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP)
+                {
+                    SetRect(&wayland_surface->wayland->cursor_clip,
+                            INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+                }
+                else if (wp == WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS)
+                {
+                    wayland_surface->set_cursor_pos = TRUE;
+                }
+                wayland_surface_update_pointer_constraint(wayland_surface);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
+    case WM_WAYLAND_CLIPBOARD_WINDOW_CREATE:
+        wayland_data_device_ensure_clipboard_window(thread_wayland());
+        break;
+    default:
+        FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *           wayland_get_client_rect_in_screen_coords
+ *
+ * On Windows, screen coordinates always have their origin at the top-left.
+ */
+void wayland_get_client_rect_in_screen_coords(HWND hwnd, RECT *client_rect)
+{
+    if (!NtUserGetClientRect(hwnd, client_rect)) goto err;
+
+    RtlSetLastWin32Error(ERROR_SUCCESS);
+    if (!NtUserMapWindowPoints(hwnd, NULL, (POINT *)client_rect, 2) &&
+        RtlGetLastWin32Error() != ERROR_SUCCESS)
+    {
+        goto err;
+    }
+
+    return;
+
+err:
+    ERR("Failed to get client rect for hwnd %p", hwnd);
+    SetRectEmpty(client_rect);
+}
+
+/*****************************************************************************
+ *           wayland_get_client_rect_in_top_left_win_coords
+ *
+ * On Windows, windows coordinates might have their origin at the top-left (LTR
+ * setups) or top-right (RTL setups) corner. This function returns the
+ * client_rect with the origin at the top-left corner.
+ */
+void wayland_get_client_rect_in_win_top_left_coords(HWND hwnd, RECT *client_rect)
+{
+    RECT window_rect;
+
+    wayland_get_client_rect_in_screen_coords(hwnd, client_rect);
+    if (!NtUserGetWindowRect(hwnd, &window_rect)) goto err;
+    if (!OffsetRect(client_rect, -window_rect.left, -window_rect.top)) goto err;
+
+    return;
+
+err:
+    ERR("Failed to get client rect for hwnd %p", hwnd);
+    SetRectEmpty(client_rect);
+}
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+
+        /* Trigger a redraw to apply any front buffer changes. */
+        NtUserPostMessage(hwnd, WM_WAYLAND_WINDOW_SURFACE_FLUSH, 0, 0);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
new file mode 100644
index 00000000000..ff71b875385
--- /dev/null
+++ b/dlls/winewayland.drv/window_surface.c
@@ -0,0 +1,860 @@
+/*
+ * Wayland window surface implementation
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include "ntgdi.h"
+#include "ntuser.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* Change to 1 to dump flushed surface buffer contents to disk */
+#define DEBUG_DUMP_FLUSH_SURFACE_BUFFER 0
+
+/* Change to 1 to dump front buffer contents to disk when performing front
+ * buffer rendering. */
+#define DEBUG_DUMP_FRONT_BUFFER 0
+
+struct wayland_window_surface
+{
+    struct window_surface header;
+    HWND                  hwnd;
+    struct wayland_surface *wayland_surface; /* Not owned by us */
+    struct wayland_buffer_queue *wayland_buffer_queue;
+    RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
+    COLORREF              color_key;
+    BYTE                  alpha;
+    BOOL                  src_alpha;
+    void                 *bits;
+    struct wayland_mutex  mutex;
+    BOOL                  last_flush_failed;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
+    BITMAPINFO            info;
+};
+
+struct last_flushed
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_shm_buffer *buffer;
+    BOOL owned;
+};
+
+static struct wayland_mutex last_flushed_mutex =
+{
+    PTHREAD_MUTEX_INITIALIZER, 0, 0, __FILE__ ": last_flushed_mutex"
+};
+
+static struct wl_list last_flushed_list = {&last_flushed_list, &last_flushed_list};
+
+static struct last_flushed *last_flushed_get(HWND hwnd)
+{
+    struct last_flushed *last_flushed;
+
+    wayland_mutex_lock(&last_flushed_mutex);
+
+    wl_list_for_each(last_flushed, &last_flushed_list, link)
+        if (last_flushed->hwnd == hwnd) return last_flushed;
+
+    wayland_mutex_unlock(&last_flushed_mutex);
+
+    return NULL;
+}
+
+static void last_flushed_release(struct last_flushed *last_flushed)
+{
+    if (last_flushed) wayland_mutex_unlock(&last_flushed_mutex);
+}
+
+static struct wayland_shm_buffer *get_last_flushed_buffer(HWND hwnd)
+{
+    struct last_flushed *last_flushed = last_flushed_get(hwnd);
+    struct wayland_shm_buffer *prev_flushed = last_flushed ? last_flushed->buffer : NULL;
+    last_flushed_release(last_flushed);
+    return prev_flushed;
+}
+
+static void update_last_flushed_buffer(HWND hwnd, struct wayland_shm_buffer *buffer)
+{
+    struct last_flushed *last_flushed;
+
+    last_flushed = last_flushed_get(hwnd);
+
+    TRACE("hwnd=%p buffer=%p (old_buffer=%p owned=%d)\n",
+          hwnd, buffer, last_flushed ? last_flushed->buffer : NULL,
+          last_flushed ? last_flushed->owned : FALSE);
+
+    if (last_flushed && last_flushed->owned)
+    {
+        if (last_flushed->buffer->busy)
+            last_flushed->buffer->destroy_on_release = TRUE;
+        else
+            wayland_shm_buffer_destroy(last_flushed->buffer);
+    }
+
+    if (buffer)
+    {
+        if (!last_flushed)
+        {
+            last_flushed = calloc(1, sizeof(*last_flushed));
+            last_flushed->hwnd = hwnd;
+            wayland_mutex_lock(&last_flushed_mutex);
+            wl_list_insert(&last_flushed_list, &last_flushed->link);
+        }
+        last_flushed->buffer = buffer;
+        last_flushed->owned = FALSE;
+    }
+    else if (last_flushed)
+    {
+        wl_list_remove(&last_flushed->link);
+        free(last_flushed);
+    }
+
+    last_flushed_release(last_flushed);
+}
+
+static void wayland_window_surface_destroy_buffer_queue(struct wayland_window_surface *wws)
+{
+    struct last_flushed *last_flushed = last_flushed_get(wws->hwnd);
+
+    /* Ensure the last flushed buffer is kept alive, so that we are able to
+     * copy data from it in later flushes for the same HWND, if needed. */
+    if (last_flushed && !last_flushed->owned)
+    {
+        wayland_buffer_queue_detach_buffer(wws->wayland_buffer_queue,
+                                           last_flushed->buffer, FALSE);
+        last_flushed->owned = TRUE;
+    }
+
+    last_flushed_release(last_flushed);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+    wws->wayland_buffer_queue = NULL;
+}
+
+static struct wayland_window_surface *wayland_window_surface_cast(
+    struct window_surface *window_surface)
+{
+    return (struct wayland_window_surface *)window_surface;
+}
+
+static inline int get_dib_stride(int width, int bpp)
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size(const BITMAPINFO *info)
+{
+    return get_dib_stride(info->bmiHeader.biWidth, info->bmiHeader.biBitCount) *
+           abs(info->bmiHeader.biHeight);
+}
+
+static inline void reset_bounds(RECT *bounds)
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR) ||
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) NtGdiDeleteObjectApp(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue || !wws->wayland_surface) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_window_surface_destroy_buffer_queue(wws);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region && NtUserGetWindowRgnEx(wws->hwnd, region, 0) == ERROR)
+        {
+            NtGdiDeleteObjectApp(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region) NtGdiCombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            NtGdiCombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = NtGdiCreateRectRgn(0, 0, 0, 0);
+            if (region) NtGdiCombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_lock
+ */
+static void wayland_window_surface_lock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    wayland_mutex_lock(&wws->mutex);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_unlock
+ */
+static void wayland_window_surface_unlock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    wayland_mutex_unlock(&wws->mutex);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bitmap_info
+ */
+static void *wayland_window_surface_get_bitmap_info(struct window_surface *window_surface,
+                                                    BITMAPINFO *info)
+{
+    struct wayland_window_surface *surface = wayland_window_surface_cast(window_surface);
+    /* We don't store any additional information at the end of our BITMAPINFO, so
+     * just copy the structure itself. */
+    memcpy(info, &surface->info, sizeof(*info));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bounds
+ */
+static RECT *wayland_window_surface_get_bounds(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return &wws->bounds;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_region
+ */
+static void wayland_window_surface_set_region(struct window_surface *window_surface,
+                                              HRGN region)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) NtGdiDeleteObjectApp(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        NtGdiCombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
+}
+
+static void wayland_window_surface_copy_to_buffer(struct wayland_window_surface *wws,
+                                                  struct wayland_shm_buffer *buffer,
+                                                  HRGN region)
+{
+    RGNDATA *rgndata = get_region_data(region);
+    RECT *rgn_rect;
+    RECT *rgn_rect_end;
+    BOOL apply_surface_alpha;
+
+    if (!rgndata) return;
+
+    rgn_rect = (RECT *)rgndata->Buffer;
+    rgn_rect_end = rgn_rect + rgndata->rdh.nCount;
+
+    /* If we have an ARGB buffer we need to explicitly apply the surface
+     * alpha to ensure the destination has sensible alpha values. The
+     * exception is when the surface uses source alpha values and the
+     * surface alpha is 255, in which case we can just copy pixel values
+     * as they are. */
+    apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                          (wws->alpha != 255 || !wws->src_alpha);
+
+    for (;rgn_rect < rgn_rect_end; rgn_rect++)
+    {
+        unsigned int *src, *dst;
+        int x, y, width, height;
+
+        TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
+
+        if (IsRectEmpty(rgn_rect))
+            continue;
+
+        src = (unsigned int *)wws->bits +
+              rgn_rect->top * wws->info.bmiHeader.biWidth +
+              rgn_rect->left;
+        dst = (unsigned int *)((unsigned char *)buffer->map_data +
+              rgn_rect->top * buffer->stride +
+              rgn_rect->left * 4);
+        width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
+        height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
+
+        /* Fast path for full width rectangles. */
+        if (width == buffer->width && !apply_surface_alpha &&
+            wws->color_key == CLR_INVALID)
+        {
+            memcpy(dst, src, height * buffer->stride);
+            continue;
+        }
+
+        for (y = 0; y < height; y++)
+        {
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else if (wws->alpha == 255 && !wws->src_alpha)
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
+            else if (!wws->src_alpha)
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((wws->alpha << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+
+            if (wws->color_key != CLR_INVALID)
+                for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
+
+            src += wws->info.bmiHeader.biWidth;
+            dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
+        }
+    }
+
+    free(rgndata);
+}
+
+static void wayland_window_surface_copy_front_to_buffer(struct wayland_window_surface *wws,
+                                                        struct wayland_shm_buffer *buffer)
+{
+    int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+    int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+    int stride = width * 4;
+    unsigned char *src = wws->front_bits;
+    unsigned char *dst = buffer->map_data;
+    int src_stride = wws->info.bmiHeader.biWidth * 4;
+    int dst_stride = buffer->width * 4;
+    int i;
+
+    TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+    /* Front buffer lines are stored bottom to top, so we need to flip
+     * when copying to our buffer. */
+    for (i = 0; i < height; i++)
+    {
+        memcpy(dst + (height - i - 1) * dst_stride,
+               src + i * src_stride,
+               stride);
+    }
+}
+
+/***********************************************************************
+ *           wayland_window_surface_flush
+ */
+void wayland_window_surface_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    struct wayland_shm_buffer *buffer, *last_buffer;
+    RECT damage_rect;
+    BOOL needs_flush;
+    HRGN surface_damage_region = NULL;
+    HRGN copy_from_window_region;
+
+    window_surface->funcs->lock(window_surface);
+
+    TRACE("hwnd=%p surface_rect=%s bounds=%s\n", wws->hwnd,
+          wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
+
+    needs_flush = intersect_rect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        RECT total_region_box;
+        surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
+                                                   damage_rect.right, damage_rect.bottom);
+        /* If the total_region is empty we are guaranteed to have empty SHM
+         * buffers. In order for this empty content to take effect, we still
+         * need to commit with non-empty damage, so don't AND with the
+         * total_region in this case, to ensure we don't end up with an empty
+         * surface_damage_region. */
+        if (wws->total_region &&
+            NtGdiGetRgnBox(wws->total_region, &total_region_box) != NULLREGION)
+        {
+            needs_flush = NtGdiCombineRgn(surface_damage_region, surface_damage_region,
+                                          wws->total_region, RGN_AND);
+        }
+    }
+
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * We also damage the whole surface if we just cleared the front buffer
+     * (i.e., front_bits == NULL and front_bits_dirty == TRUE). */
+    if (wws->front_bits || wws->front_bits_dirty)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                NtGdiSetRectRgn(surface_damage_region,
+                                wws->header.rect.left, wws->header.rect.top,
+                                wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = NtGdiCreateRectRgn(wws->header.rect.left,
+                                                           wws->header.rect.top,
+                                                           wws->header.rect.right,
+                                                           wws->header.rect.bottom);
+            }
+        }
+    }
+
+    if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
+    {
+        TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
+              wws->wayland_surface, wws->wayland_buffer_queue);
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+
+    if (needs_flush)
+    {
+        BOOL drawing_allowed;
+        wayland_mutex_lock(&wws->wayland_surface->mutex);
+        drawing_allowed = wws->wayland_surface->drawing_allowed;
+        wayland_mutex_unlock(&wws->wayland_surface->mutex);
+        if (!drawing_allowed)
+        {
+            TRACE("drawing disallowed on wayland surface=%p, returning\n",
+                  wws->wayland_surface);
+            wws->last_flush_failed = TRUE;
+            goto done;
+        }
+    }
+
+    wws->last_flush_failed = FALSE;
+
+    if (!needs_flush) goto done;
+
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
+          "alpha %02x src_alpha %d compression %d region %p\n",
+          wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
+          wws->bits, (UINT)wws->color_key, wws->alpha, wws->src_alpha,
+          (UINT)wws->info.bmiHeader.biCompression,
+          wws->total_region);
+
+    assert(wws->wayland_buffer_queue);
+
+    if (DEBUG_DUMP_FLUSH_SURFACE_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/flush-%.4d.pam", dbgid++, wws->bits,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    wws->wayland_buffer_queue->format == WL_SHM_FORMAT_ARGB8888,
+                    surface_damage_region, wws->total_region);
+    }
+
+    wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
+    buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
+    if (!buffer)
+    {
+        WARN("failed to acquire wayland buffer, returning\n");
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+
+    if (wws->front_bits)
+        wayland_window_surface_copy_front_to_buffer(wws, buffer);
+
+    /* If we have a front buffer, the whole window is overwritten in every
+     * flush, and all "overlay" contents will need to be reapplied
+     * from the window surface, rather than from the last buffer. */
+    if (!wws->front_bits && (last_buffer = get_last_flushed_buffer(wws->hwnd)))
+    {
+        if (last_buffer != buffer)
+        {
+            HRGN copy_from_last_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+            NtGdiCombineRgn(copy_from_last_region, buffer->damage_region,
+                            surface_damage_region, RGN_DIFF);
+            if (wws->total_region)
+            {
+                NtGdiCombineRgn(copy_from_last_region, copy_from_last_region,
+                                wws->total_region, RGN_AND);
+            }
+            wayland_shm_buffer_copy(buffer, last_buffer, copy_from_last_region);
+            NtGdiDeleteObjectApp(copy_from_last_region);
+        }
+        copy_from_window_region = surface_damage_region;
+    }
+    else if (wws->total_region)
+    {
+        copy_from_window_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        NtGdiCombineRgn(copy_from_window_region, buffer->damage_region,
+                        wws->total_region, RGN_AND);
+    }
+    else
+    {
+        copy_from_window_region = buffer->damage_region;
+    }
+
+    wayland_window_surface_copy_to_buffer(wws, buffer, copy_from_window_region);
+
+    if (copy_from_window_region != surface_damage_region &&
+        copy_from_window_region != buffer->damage_region)
+        NtGdiDeleteObjectApp(copy_from_window_region);
+
+    if (!wayland_surface_commit_buffer(wws->wayland_surface, buffer,
+                                       surface_damage_region))
+    {
+        wws->last_flush_failed = TRUE;
+    }
+
+    wayland_shm_buffer_clear_damage(buffer);
+    update_last_flushed_buffer(wws->hwnd, buffer);
+
+done:
+    if (!wws->last_flush_failed)
+    {
+        reset_bounds(&wws->bounds);
+        wws->front_bits_dirty = FALSE;
+    }
+    if (surface_damage_region) NtGdiDeleteObjectApp(surface_damage_region);
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_destroy
+ */
+static void wayland_window_surface_destroy(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("surface=%p\n", wws);
+
+    wayland_mutex_destroy(&wws->mutex);
+    if (wws->region) NtGdiDeleteObjectApp(wws->region);
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    if (wws->wayland_buffer_queue)
+        wayland_window_surface_destroy_buffer_queue(wws);
+    free(wws->bits);
+    free(wws->front_bits);
+    free(wws);
+}
+
+static const struct window_surface_funcs wayland_window_surface_funcs =
+{
+    wayland_window_surface_lock,
+    wayland_window_surface_unlock,
+    wayland_window_surface_get_bitmap_info,
+    wayland_window_surface_get_bounds,
+    wayland_window_surface_set_region,
+    wayland_window_surface_flush,
+    wayland_window_surface_destroy
+};
+
+/***********************************************************************
+ *           wayland_window_surface_create
+ */
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
+{
+    struct wayland_window_surface *wws;
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+
+    TRACE("win %p rect %s\n", hwnd, wine_dbgstr_rect(rect));
+    wws = calloc(1, sizeof(*wws));
+    if (!wws) return NULL;
+    wws->info.bmiHeader.biSize = sizeof(wws->info.bmiHeader);
+    wws->info.bmiHeader.biClrUsed = 0;
+    wws->info.bmiHeader.biBitCount = 32;
+    wws->info.bmiHeader.biCompression = BI_RGB;
+    wws->info.bmiHeader.biWidth       = width;
+    wws->info.bmiHeader.biHeight      = -height; /* top-down */
+    wws->info.bmiHeader.biPlanes      = 1;
+    wws->info.bmiHeader.biSizeImage   = get_dib_image_size(&wws->info);
+
+    wayland_mutex_init(&wws->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_window_surface");
+
+    wws->header.funcs = &wayland_window_surface_funcs;
+    wws->header.rect  = *rect;
+    wws->header.ref   = 1;
+    wws->hwnd         = hwnd;
+    wws->color_key    = color_key;
+    wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
+    reset_bounds(&wws->bounds);
+
+    if (!(wws->bits = malloc(wws->info.bmiHeader.biSizeImage)))
+        goto failed;
+
+    TRACE("created %p hwnd %p %s bits %p-%p compression %u\n", wws, hwnd, wine_dbgstr_rect(rect),
+           wws->bits, (char *)wws->bits + wws->info.bmiHeader.biSizeImage,
+           (UINT)wws->info.bmiHeader.biCompression);
+
+    return &wws->header;
+
+failed:
+    wayland_window_surface_destroy(&wws->header);
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_needs_flush
+ */
+BOOL wayland_window_surface_needs_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return wws->last_flush_failed;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_wayland_surface
+ */
+void wayland_window_surface_update_wayland_surface(struct window_surface *window_surface,
+                                                   struct wayland_surface *wayland_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wayland_surface) wayland_surface_ref(wayland_surface);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    wws->wayland_surface = wayland_surface;
+
+    /* We only need a buffer queue if we have a surface to commit to. */
+    if (wws->wayland_surface && !wws->wayland_buffer_queue)
+    {
+        wws->wayland_buffer_queue =
+            wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    get_preferred_format(wws));
+    }
+    else if (!wws->wayland_surface)
+    {
+        if (wws->wayland_buffer_queue)
+            wayland_window_surface_destroy_buffer_queue(wws);
+        free(wws->front_bits);
+        wws->front_bits = NULL;
+        wws->front_bits_dirty = FALSE;
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_layered
+ */
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
+        *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+
+    wws->alpha = alpha;
+    wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
+
+    if (wws->wayland_buffer_queue &&
+        wws->wayland_buffer_queue->format != get_preferred_format(wws))
+    {
+        recreate_wayland_buffer_queue(wws);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd=%p front_bits=%p read_pixels=%p size=%dx%d\n",
+          wws->hwnd, wws->front_bits, read_pixels,
+          (int)wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        if (wws->front_bits)
+        {
+            free(wws->front_bits);
+            wws->front_bits = NULL;
+            /* When the front_bits are first invalidated, we mark them as dirty
+             * to force the next window_surface flush. */
+            wws->front_bits_dirty = TRUE;
+        }
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = malloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+    if (DEBUG_DUMP_FRONT_BUFFER && wws->front_bits)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/front-%.4d.pam", dbgid++,
+                    wws->front_bits, wws->info.bmiHeader.biWidth,
+                    abs(wws->info.bmiHeader.biHeight),
+                    FALSE, NULL, NULL);
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_clear_window_surface_last_flushed
+ */
+void wayland_clear_window_surface_last_flushed(HWND hwnd)
+{
+    update_last_flushed_buffer(hwnd, NULL);
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
new file mode 100644
index 00000000000..5f086f5c4e5
--- /dev/null
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -0,0 +1,2 @@
+# System tray
+@ cdecl wine_notify_icon(long ptr)
diff --git a/dlls/winewayland.drv/xkb_util.c b/dlls/winewayland.drv/xkb_util.c
new file mode 100644
index 00000000000..475af4b5bd6
--- /dev/null
+++ b/dlls/winewayland.drv/xkb_util.c
@@ -0,0 +1,80 @@
+/*
+ * XKB related utility functions
+ *
+ * Copyright 2021 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include <xkbcommon/xkbcommon.h>
+
+/**********************************************************************
+ *          _xkb_state_get_active_layout
+ *
+ * Gets the active layout of the xkb state.
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state)
+{
+    struct xkb_keymap *xkb_keymap = xkb_state_get_keymap(xkb_state);
+    xkb_layout_index_t num_layouts = xkb_keymap_num_layouts(xkb_keymap);
+    xkb_layout_index_t layout;
+
+    for (layout = 0; layout < num_layouts; layout++)
+    {
+        if (xkb_state_layout_index_is_active(xkb_state, layout,
+                                             XKB_STATE_LAYOUT_LOCKED))
+            return layout;
+    }
+
+    return XKB_LAYOUT_INVALID;
+}
+
+/**********************************************************************
+ *          _xkb_keysyms_to_utf8
+ *
+ * Get the null-terminated UTF-8 string representation of a sequence of
+ * keysyms. Returns the length of the UTF-8 string written, *not* including
+ * the null byte. If no bytes were produced or in case of error returns 0
+ * and produces a properly null-terminated empty string if possible.
+ */
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size)
+{
+    int i;
+    int utf8_len = 0;
+
+    if (utf8_size == 0) return 0;
+
+    for (i = 0; i < nsyms; i++)
+    {
+        int nwritten = xkb_keysym_to_utf8(syms[i], utf8 + utf8_len,
+                                          utf8_size - utf8_len);
+        if (nwritten <= 0)
+        {
+            utf8_len = 0;
+            break;
+        }
+
+        /* nwritten includes the terminating null byte */
+        utf8_len += nwritten - 1;
+    }
+
+    utf8[utf8_len] = '\0';
+
+    return utf8_len;
+}
diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index e91368d69e7..959b59825e1 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -1285,7 +1285,7 @@ struct format_entry *import_xdnd_selection( Display *display, Window win, Atom s
     UINT i;
     void *data;
     struct clipboard_format *format;
-    struct format_entry *ret = NULL, *entry;
+    struct format_entry *ret = NULL, *tmp, *entry;
     BOOL have_hdrop = FALSE;
 
     register_x11_formats( targets, count );
@@ -1310,7 +1310,8 @@ struct format_entry *import_xdnd_selection( Display *display, Window win, Atom s
         entry_size = (FIELD_OFFSET( struct format_entry, data[size] ) + 7) & ~7;
         if (buf_size < size + entry_size)
         {
-            if (!(ret = realloc( ret, *ret_size + entry_size + 1024 ))) continue;
+            if (!(tmp = realloc( ret, *ret_size + entry_size + 1024 ))) continue;
+            ret = tmp;
             buf_size = *ret_size + entry_size + 1024; /* extra space for following entries */
         }
         entry = (struct format_entry *)((char *)ret + *ret_size);
diff --git a/dlls/winex11.drv/desktop.c b/dlls/winex11.drv/desktop.c
index bb998543ae7..a0367d6ce50 100644
--- a/dlls/winex11.drv/desktop.c
+++ b/dlls/winex11.drv/desktop.c
@@ -287,15 +287,11 @@ static void X11DRV_desktop_free_adapters( struct gdi_adapter *adapters )
 
 static BOOL X11DRV_desktop_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count )
 {
-    static const WCHAR generic_nonpnp_monitorW[] = {
-        'G','e','n','e','r','i','c',' ',
-        'N','o','n','-','P','n','P',' ','M','o','n','i','t','o','r',0};
     struct gdi_monitor *monitor;
 
     monitor = calloc( 1, sizeof(*monitor) );
     if (!monitor) return FALSE;
 
-    lstrcpyW( monitor->name, generic_nonpnp_monitorW );
     SetRect( &monitor->rc_monitor, 0, 0, desktop_width, desktop_height );
     SetRect( &monitor->rc_work, 0, 0, desktop_width, desktop_height );
     query_desktop_work_area( &monitor->rc_work );
diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index 34085c49543..78de6a6f88b 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -589,10 +589,7 @@ BOOL X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_manage
 
             /* Initialize monitors */
             for (monitor = 0; monitor < monitor_count; monitor++)
-            {
-                TRACE("monitor: %#x %s\n", monitor, wine_dbgstr_w(monitors[monitor].name));
                 device_manager->add_monitor( &monitors[monitor], param );
-            }
 
             handler->free_monitors(monitors, monitor_count);
 
diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 86edf66b820..1ae39eb9edf 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -472,33 +472,16 @@ static BOOL process_events( Display *display, Bool (*filter)(Display*, XEvent*,X
 
 
 /***********************************************************************
- *           MsgWaitForMultipleObjectsEx   (X11DRV.@)
+ *           ProcessEvents   (X11DRV.@)
  */
-NTSTATUS X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                             const LARGE_INTEGER *timeout, DWORD mask, DWORD flags )
+BOOL X11DRV_ProcessEvents( DWORD mask )
 {
     struct x11drv_thread_data *data = x11drv_thread_data();
-    NTSTATUS ret;
-
-    if (!data)
-    {
-        if (!count && timeout && !timeout->QuadPart) return WAIT_TIMEOUT;
-        return NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                         !!(flags & MWMO_ALERTABLE), timeout );
-    }
 
+    if (!data) return FALSE;
     if (data->current_event) mask = 0;  /* don't process nested events */
 
-    if (process_events( data->display, filter_event, mask )) ret = count - 1;
-    else if (count || !timeout || timeout->QuadPart)
-    {
-        ret = NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                        !!(flags & MWMO_ALERTABLE), timeout );
-        if (ret == count - 1) process_events( data->display, filter_event, mask );
-    }
-    else ret = WAIT_TIMEOUT;
-
-    return ret;
+    return process_events( data->display, filter_event, mask );
 }
 
 /***********************************************************************
diff --git a/dlls/winex11.drv/ime.c b/dlls/winex11.drv/ime.c
index 0599159646f..a293daa6ad9 100644
--- a/dlls/winex11.drv/ime.c
+++ b/dlls/winex11.drv/ime.c
@@ -43,7 +43,7 @@
 #include "x11drv_dll.h"
 #include "wine/debug.h"
 #include "imm.h"
-#include "ddk/imm.h"
+#include "immdev.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
@@ -56,12 +56,6 @@ typedef struct _IMEPRIVATE {
     HWND hwndDefault;
 } IMEPRIVATE, *LPIMEPRIVATE;
 
-typedef struct _tagTRANSMSG {
-    UINT message;
-    WPARAM wParam;
-    LPARAM lParam;
-} TRANSMSG, *LPTRANSMSG;
-
 static const WCHAR UI_CLASS_NAME[] = {'W','i','n','e','X','1','1','I','M','E',0};
 
 static HIMC *hSelectedFrom = NULL;
@@ -511,8 +505,7 @@ static void IME_AddToSelected(HIMC hIMC)
     hSelectedFrom[hSelectedCount-1] = hIMC;
 }
 
-BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass,
-                       LPCWSTR lpszOption)
+BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass, DWORD flags)
 {
     static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
 
@@ -619,7 +612,7 @@ BOOL WINAPI ImeSetActiveContext(HIMC hIMC,BOOL fFlag)
 }
 
 UINT WINAPI ImeToAsciiEx (UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState,
-                          LPDWORD lpdwTransKey, UINT fuState, HIMC hIMC)
+                          TRANSMSGLIST *lpdwTransKey, UINT fuState, HIMC hIMC)
 {
     /* See the comment at the head of this file */
     TRACE("We do no processing via this route\n");
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 7e343591413..e26cfb5a789 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -413,7 +413,7 @@ static const struct user_driver_funcs x11drv_funcs =
     .pDestroyWindow = X11DRV_DestroyWindow,
     .pFlashWindowEx = X11DRV_FlashWindowEx,
     .pGetDC = X11DRV_GetDC,
-    .pMsgWaitForMultipleObjectsEx = X11DRV_MsgWaitForMultipleObjectsEx,
+    .pProcessEvents = X11DRV_ProcessEvents,
     .pReleaseDC = X11DRV_ReleaseDC,
     .pScrollDC = X11DRV_ScrollDC,
     .pSetCapture = X11DRV_SetCapture,
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 96a8526604b..c44e9579cb6 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1931,14 +1931,14 @@ static BOOL glxdrv_wglShareLists(struct wgl_context *org, struct wgl_context *de
      * current or when it hasn't shared display lists before.
      */
 
-    if((org->has_been_current && dest->has_been_current) || dest->has_been_current)
+    if(dest->has_been_current)
     {
-        ERR("Could not share display lists, one of the contexts has been current already !\n");
+        ERR("Could not share display lists because the destination context has already been current\n");
         return FALSE;
     }
     else if(dest->sharing)
     {
-        ERR("Could not share display lists because hglrc2 has already shared lists before\n");
+        ERR("Could not share display lists because the destination context has already shared lists\n");
         return FALSE;
     }
     else
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 101504a7887..08e57c4def0 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -683,28 +683,28 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
-    X11DRV_vkCreateInstance,
-    X11DRV_vkCreateSwapchainKHR,
-    X11DRV_vkCreateWin32SurfaceKHR,
-    X11DRV_vkDestroyInstance,
-    X11DRV_vkDestroySurfaceKHR,
-    X11DRV_vkDestroySwapchainKHR,
-    X11DRV_vkEnumerateInstanceExtensionProperties,
-    X11DRV_vkGetDeviceGroupSurfacePresentModesKHR,
-    X11DRV_vkGetDeviceProcAddr,
-    X11DRV_vkGetInstanceProcAddr,
-    X11DRV_vkGetPhysicalDevicePresentRectanglesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceFormatsKHR,
-    X11DRV_vkGetPhysicalDeviceSurfacePresentModesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceSupportKHR,
-    X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
-    X11DRV_vkGetSwapchainImagesKHR,
-    X11DRV_vkQueuePresentKHR,
-
-    X11DRV_wine_get_native_surface,
+    .p_vkCreateInstance = X11DRV_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = X11DRV_vkCreateSwapchainKHR,
+    .p_vkCreateWin32SurfaceKHR = X11DRV_vkCreateWin32SurfaceKHR,
+    .p_vkDestroyInstance = X11DRV_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = X11DRV_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = X11DRV_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = X11DRV_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = X11DRV_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = X11DRV_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = X11DRV_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = X11DRV_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = X11DRV_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = X11DRV_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = X11DRV_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = X11DRV_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = X11DRV_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = X11DRV_vkGetSwapchainImagesKHR,
+    .p_vkQueuePresentKHR = X11DRV_vkQueuePresentKHR,
+
+    .p_wine_get_native_surface = X11DRV_wine_get_native_surface,
 };
 
 static void *X11DRV_get_vk_device_proc_addr(const char *name)
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 98b0b23e103..17fc6d867f5 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -984,7 +984,7 @@ static void update_net_wm_fullscreen_monitors( struct x11drv_win_data *data )
     if (!(data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)) || is_virtual_desktop())
         return;
 
-    /* If the current display device handler can not detect dynamic device changes, do not use
+    /* If the current display device handler cannot detect dynamic device changes, do not use
      * _NET_WM_FULLSCREEN_MONITORS because xinerama_get_fullscreen_monitors() may report wrong
      * indices because of stale xinerama monitor information */
     if (!X11DRV_DisplayDevices_SupportEventHandlers())
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 4997367ce9a..2b0b79e1665 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -453,7 +453,7 @@ extern int alloc_system_colors DECLSPEC_HIDDEN;
 extern int xrender_error_base DECLSPEC_HIDDEN;
 extern char *process_name DECLSPEC_HIDDEN;
 extern Display *clipboard_display DECLSPEC_HIDDEN;
-extern WNDPROC client_foreign_window_proc;
+extern WNDPROC client_foreign_window_proc DECLSPEC_HIDDEN;
 
 /* atoms */
 
@@ -691,9 +691,7 @@ extern void retry_grab_clipping_window(void) DECLSPEC_HIDDEN;
 extern BOOL clip_fullscreen_window( HWND hwnd, BOOL reset ) DECLSPEC_HIDDEN;
 extern void move_resize_window( HWND hwnd, int dir ) DECLSPEC_HIDDEN;
 extern void X11DRV_InitKeyboard( Display *display ) DECLSPEC_HIDDEN;
-extern NTSTATUS X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                    const LARGE_INTEGER *timeout,
-                                                    DWORD mask, DWORD flags ) DECLSPEC_HIDDEN;
+extern BOOL X11DRV_ProcessEvents( DWORD mask ) DECLSPEC_HIDDEN;
 extern HWND *build_hwnd_list(void) DECLSPEC_HIDDEN;
 
 typedef int (*x11drv_error_callback)( Display *display, XErrorEvent *event, void *arg );
diff --git a/dlls/winex11.drv/xinerama.c b/dlls/winex11.drv/xinerama.c
index 6835aa4a331..2691f9e9c5e 100644
--- a/dlls/winex11.drv/xinerama.c
+++ b/dlls/winex11.drv/xinerama.c
@@ -287,9 +287,6 @@ static void xinerama_free_adapters( struct gdi_adapter *adapters )
 
 static BOOL xinerama_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count )
 {
-    static const WCHAR generic_nonpnp_monitorW[] = {
-        'G','e','n','e','r','i','c',' ',
-        'N','o','n','-','P','n','P',' ','M','o','n','i','t','o','r',0};
     struct gdi_monitor *monitor;
     INT first = (INT)adapter_id;
     INT monitor_count = 0;
@@ -319,7 +316,6 @@ static BOOL xinerama_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
             || (EqualRect( &monitors[i].rcMonitor, &monitors[first].rcMonitor )
                 && !IsRectEmpty( &monitors[first].rcMonitor )))
         {
-            lstrcpyW( monitor[index].name, generic_nonpnp_monitorW );
             monitor[index].rc_monitor = monitors[i].rcMonitor;
             monitor[index].rc_work = monitors[i].rcWork;
             /* Xinerama only reports monitors already attached */
diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index dbd8a721074..7c32e683c5d 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -28,7 +28,11 @@
 
 #define NONAMELESSSTRUCT
 #define NONAMELESSUNION
-
+#include <assert.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+#include <dlfcn.h>
+#include "x11drv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xrandr);
@@ -38,12 +42,6 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifdef SONAME_LIBXRANDR
 
-#include <assert.h>
-#include <X11/Xlib.h>
-#include <X11/extensions/Xrandr.h>
-#include <dlfcn.h>
-#include "x11drv.h"
-
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
 
@@ -1029,9 +1027,6 @@ static void xrandr14_free_adapters( struct gdi_adapter *adapters )
 
 static BOOL xrandr14_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count )
 {
-    static const WCHAR generic_nonpnp_monitorW[] = {
-        'G','e','n','e','r','i','c',' ',
-        'N','o','n','-','P','n','P',' ','M','o','n','i','t','o','r',0};
     struct gdi_monitor *realloc_monitors, *monitors = NULL;
     XRRScreenResources *screen_resources = NULL;
     XRROutputInfo *output_info = NULL, *enum_output_info = NULL;
@@ -1065,7 +1060,6 @@ static BOOL xrandr14_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
     /* Inactive but attached monitor, no need to check for mirrored/replica monitors */
     if (!output_info->crtc || !crtc_info->mode)
     {
-        lstrcpyW( monitors[monitor_count].name, generic_nonpnp_monitorW );
         monitors[monitor_count].state_flags = DISPLAY_DEVICE_ATTACHED;
         monitors[monitor_count].edid_len = get_edid( adapter_id, &monitors[monitor_count].edid );
         monitor_count = 1;
@@ -1110,9 +1104,6 @@ static BOOL xrandr14_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
                     enum_crtc_info->width == crtc_info->width &&
                     enum_crtc_info->height == crtc_info->height)
                 {
-                    /* FIXME: Read output EDID property and parse the data to get the correct name */
-                    lstrcpyW( monitors[monitor_count].name, generic_nonpnp_monitorW );
-
                     SetRect( &monitors[monitor_count].rc_monitor, crtc_info->x, crtc_info->y,
                              crtc_info->x + crtc_info->width, crtc_info->y + crtc_info->height );
                     monitors[monitor_count].rc_work = get_work_area( &monitors[monitor_count].rc_monitor );
diff --git a/dlls/winhttp/tests/url.c b/dlls/winhttp/tests/url.c
index da51117e41e..fadf8b850ca 100644
--- a/dlls/winhttp/tests/url.c
+++ b/dlls/winhttp/tests/url.c
@@ -304,8 +304,8 @@ static void WinHttpCreateUrl_test( void )
     SetLastError( 0xdeadbeef );
     ret = WinHttpCreateUrl( &uc, ICU_ESCAPE, url, &len );
     err = GetLastError();
-    ok( !ret, "expected failure\n" );
-    ok( err == ERROR_INVALID_PARAMETER, "got %lu\n", err );
+    ok( !ret || GetACP() == CP_UTF8, "expected failure\n" );
+    ok( err == ERROR_INVALID_PARAMETER || (!err && GetACP() == CP_UTF8), "got %lu\n", err );
 
     /* extra info with Unicode characters, no ICU_ESCAPE */
     memset( &uc, 0, sizeof(uc) );
@@ -344,8 +344,8 @@ static void WinHttpCreateUrl_test( void )
     SetLastError( 0xdeadbeef );
     ret = WinHttpCreateUrl( &uc, ICU_ESCAPE, url, &len );
     err = GetLastError();
-    ok( !ret, "expected failure\n" );
-    ok( err == ERROR_INVALID_PARAMETER, "got %lu\n", err );
+    ok( !ret || GetACP() == CP_UTF8, "expected failure\n" );
+    ok( err == ERROR_INVALID_PARAMETER || (!err && GetACP() == CP_UTF8), "got %lu\n", err );
 
     /* path with Unicode characters, no ICU_ESCAPE */
     memset( &uc, 0, sizeof(uc) );
diff --git a/dlls/wininet/ftp.c b/dlls/wininet/ftp.c
index cf6555c63e2..f3f586cd6e1 100644
--- a/dlls/wininet/ftp.c
+++ b/dlls/wininet/ftp.c
@@ -1293,6 +1293,7 @@ static const object_vtbl_t FTPFILEVtbl = {
     NULL,
     FTPFILE_QueryOption,
     INET_SetOption,
+    NULL,
     FTPFILE_ReadFile,
     FTPFILE_WriteFile,
     FTPFILE_QueryDataAvailable,
@@ -2397,6 +2398,7 @@ static const object_vtbl_t FTPSESSIONVtbl = {
     NULL,
     NULL,
     NULL,
+    NULL,
     NULL
 };
 
@@ -3525,6 +3527,7 @@ static const object_vtbl_t FTPFINDNEXTVtbl = {
     NULL,
     NULL,
     NULL,
+    NULL,
     FTPFINDNEXT_FindNextFileW
 };
 
diff --git a/dlls/wininet/http.c b/dlls/wininet/http.c
index b42f823208c..b646ddf5b69 100644
--- a/dlls/wininet/http.c
+++ b/dlls/wininet/http.c
@@ -329,6 +329,7 @@ static void reset_data_stream(http_request_t *req)
     destroy_data_stream(req->data_stream);
     req->data_stream = &req->netconn_stream.data_stream;
     req->read_pos = req->read_size = req->netconn_stream.content_read = 0;
+    req->content_pos = 0;
     req->read_gzip = FALSE;
 }
 
@@ -2499,6 +2500,8 @@ static void create_cache_entry(http_request_t *req)
 
     create_req_file(file_name, &req->req_file);
     req->req_file->url = url;
+    req->content_pos = 0;
+    req->cache_size = 0;
 
     req->hCacheFile = CreateFileW(file_name, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
@@ -2512,7 +2515,9 @@ static void create_cache_entry(http_request_t *req)
         DWORD written;
 
         b = WriteFile(req->hCacheFile, req->read_buf+req->read_pos, req->read_size, &written, NULL);
-        if(!b)
+        if(b)
+            req->cache_size += written;
+        else
             FIXME("WriteFile failed: %lu\n", GetLastError());
 
         if(req->data_stream->vtbl->end_of_data(req->data_stream, req))
@@ -2621,7 +2626,9 @@ static DWORD read_http_stream(http_request_t *req, BYTE *buf, DWORD size, DWORD
             DWORD written;
 
             bres = WriteFile(req->hCacheFile, buf, *read, &written, NULL);
-            if(!bres)
+            if(bres)
+                req->cache_size += written;
+            else
                 FIXME("WriteFile failed: %lu\n", GetLastError());
         }
 
@@ -3033,6 +3040,35 @@ static void HTTP_ReceiveRequestData(http_request_t *req)
     send_request_complete(req, req->session->hdr.dwInternalFlags & INET_OPENURL ? (DWORD_PTR)req->hdr.hInternet : 1, 0);
 }
 
+static DWORD read_req_file(http_request_t *req, BYTE *buffer, DWORD size, DWORD *read, BOOL allow_blocking)
+{
+    DWORD ret_read = 0, res;
+    LARGE_INTEGER off;
+    BYTE buf[1024];
+
+    while (req->content_pos > req->cache_size) {
+        res = read_http_stream(req, (BYTE*)buf, min(sizeof(buf), req->content_pos - req->cache_size),
+                               &ret_read, allow_blocking);
+        if (res != ERROR_SUCCESS)
+            return res;
+        if (!ret_read) {
+            *read = 0;
+            return ERROR_SUCCESS;
+        }
+    }
+
+    if (req->content_pos < req->cache_size) {
+        off.QuadPart = req->content_pos;
+        if (!SetFilePointerEx(req->req_file->file_handle, off, NULL, FILE_BEGIN))
+            return GetLastError();
+        if (!ReadFile(req->req_file->file_handle, buffer, size, &ret_read, NULL))
+            return GetLastError();
+    }
+
+    *read = ret_read;
+    return ERROR_SUCCESS;
+}
+
 /* read data from the http connection (the read section must be held) */
 static DWORD HTTPREQ_Read(http_request_t *req, void *buffer, DWORD size, DWORD *read, BOOL allow_blocking)
 {
@@ -3046,13 +3082,16 @@ static DWORD HTTPREQ_Read(http_request_t *req, void *buffer, DWORD size, DWORD *
         memcpy(buffer, req->read_buf+req->read_pos, ret_read);
         req->read_size -= ret_read;
         req->read_pos += ret_read;
+        req->content_pos += ret_read;
         allow_blocking = FALSE;
     }
 
     if(ret_read < size) {
         res = read_http_stream(req, (BYTE*)buffer+ret_read, size-ret_read, &current_read, allow_blocking);
-        if(res == ERROR_SUCCESS)
+        if(res == ERROR_SUCCESS) {
             ret_read += current_read;
+            req->content_pos += current_read;
+        }
         else if(res == WSAEWOULDBLOCK && ret_read)
             res = ERROR_SUCCESS;
     }
@@ -3106,6 +3145,17 @@ static void async_read_file_proc(task_header_t *hdr)
 
     TRACE("req %p buf %p size %lu read_pos %lu ret_read %p\n", req, task->buf, task->size, task->read_pos, task->ret_read);
 
+    if(req->req_file && req->req_file->file_handle) {
+        DWORD ret, ret_read;
+        BYTE buf[1024];
+        while (req->content_pos > req->cache_size) {
+            ret = read_http_stream(req, (BYTE*)buf, min(sizeof(buf), req->content_pos - req->cache_size),
+                                   &ret_read, TRUE);
+            if(ret != ERROR_SUCCESS || !ret_read)
+                break;
+        }
+    }
+
     if(task->buf) {
         DWORD read_bytes;
         while (read < task->size) {
@@ -3155,6 +3205,47 @@ static DWORD async_read(http_request_t *req, void *buf, DWORD size, DWORD read_p
     return ERROR_IO_PENDING;
 }
 
+static DWORD HTTPREQ_SetFilePointer(object_header_t *hdr, LONG lDistanceToMove, DWORD dwMoveContext)
+{
+    http_request_t *req = (http_request_t*)hdr;
+    DWORD res = INVALID_SET_FILE_POINTER, err = ERROR_SUCCESS;
+
+    if(req->hdr.dwFlags & (INTERNET_FLAG_DONT_CACHE|INTERNET_FLAG_NO_CACHE_WRITE)) {
+        SetLastError(ERROR_INTERNET_INVALID_OPERATION);
+        return INVALID_SET_FILE_POINTER;
+    }
+
+    EnterCriticalSection(&req->read_section);
+
+    switch (dwMoveContext) {
+        case FILE_BEGIN:
+            res = lDistanceToMove;
+            break;
+        case FILE_CURRENT:
+            if(req->content_pos && lDistanceToMove < 0) {
+                err = ERROR_NEGATIVE_SEEK;
+                break;
+            }
+            res = req->content_pos + lDistanceToMove;
+            break;
+        case FILE_END:
+            FIXME("dwMoveContext FILE_END not implemented\n");
+            /* fallthrough */
+        default:
+            err = ERROR_INTERNET_INVALID_OPERATION;
+            break;
+    }
+
+    if(err == ERROR_SUCCESS) {
+        req->content_pos = res;
+        req->read_pos = req->read_size = 0;
+    }
+
+    LeaveCriticalSection(&req->read_section);
+    SetLastError(err);
+    return res;
+}
+
 static DWORD HTTPREQ_ReadFile(object_header_t *hdr, void *buf, DWORD size, DWORD *ret_read,
         DWORD flags, DWORD_PTR context)
 {
@@ -3182,9 +3273,18 @@ static DWORD HTTPREQ_ReadFile(object_header_t *hdr, void *buf, DWORD size, DWORD
             memcpy(buf, req->read_buf + req->read_pos, read);
             req->read_size -= read;
             req->read_pos += read;
+            req->content_pos += read;
         }
 
-        if(read < size && (!read || !(flags & IRF_NO_WAIT)) && !end_of_read_data(req)) {
+        if(read < size && req->req_file && req->req_file->file_handle) {
+            res = read_req_file(req, (BYTE*)buf + read, size - read, &cread, allow_blocking);
+            if(res == ERROR_SUCCESS) {
+                read += cread;
+                req->content_pos += cread;
+            }
+        }
+
+        if(res == ERROR_SUCCESS && read < size && (!read || !(flags & IRF_NO_WAIT)) && !end_of_read_data(req)) {
             LeaveCriticalSection(&req->read_section);
             INTERNET_SendCallback(&req->hdr, req->hdr.dwContext, INTERNET_STATUS_RECEIVING_RESPONSE, NULL, 0);
             EnterCriticalSection( &req->read_section );
@@ -3265,6 +3365,8 @@ static DWORD HTTPREQ_QueryDataAvailable(object_header_t *hdr, DWORD *available,
             hdr->dwError = ERROR_INTERNET_INTERNAL_ERROR;
 
         avail = req->read_size;
+        if(req->cache_size > req->content_pos)
+            avail = max(avail, req->cache_size - req->content_pos);
 
         if(!avail && !end_of_read_data(req)) {
             LeaveCriticalSection(&req->read_section);
@@ -3318,6 +3420,7 @@ static const object_vtbl_t HTTPREQVtbl = {
     HTTPREQ_CloseConnection,
     HTTPREQ_QueryOption,
     HTTPREQ_SetOption,
+    HTTPREQ_SetFilePointer,
     HTTPREQ_ReadFile,
     HTTPREQ_WriteFile,
     HTTPREQ_QueryDataAvailable,
@@ -5807,6 +5910,7 @@ static const object_vtbl_t HTTPSESSIONVtbl = {
     NULL,
     NULL,
     NULL,
+    NULL,
     NULL
 };
 
diff --git a/dlls/wininet/internet.c b/dlls/wininet/internet.c
index 2926fbccf9b..6dabb0fc5e3 100644
--- a/dlls/wininet/internet.c
+++ b/dlls/wininet/internet.c
@@ -957,6 +957,7 @@ static const object_vtbl_t APPINFOVtbl = {
     APPINFO_SetOption,
     NULL,
     NULL,
+    NULL,
     NULL
 };
 
@@ -2155,14 +2156,36 @@ INTERNET_STATUS_CALLBACK WINAPI InternetSetStatusCallbackW(
 
 /***********************************************************************
  *           InternetSetFilePointer (WININET.@)
+ *
+ * Sets read position for an open internet file.
+ *
+ * RETURNS
+ *    Current position of the file on success
+ *    INVALID_SET_FILE_POINTER on failure
  */
 DWORD WINAPI InternetSetFilePointer(HINTERNET hFile, LONG lDistanceToMove,
     PVOID pReserved, DWORD dwMoveContext, DWORD_PTR dwContext)
 {
-    FIXME("(%p %ld %p %ld %Ix): stub\n", hFile, lDistanceToMove, pReserved, dwMoveContext, dwContext);
+    object_header_t *hdr;
+    DWORD res;
+
+    TRACE("(%p %ld %p %ld %Ix)\n", hFile, lDistanceToMove, pReserved, dwMoveContext, dwContext);
+
+    hdr = get_handle_object(hFile);
+    if(!hdr) {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return INVALID_SET_FILE_POINTER;
+    }
 
-    SetLastError(ERROR_INTERNET_INVALID_OPERATION);
-    return INVALID_SET_FILE_POINTER;
+    if(hdr->vtbl->SetFilePointer) {
+        res = hdr->vtbl->SetFilePointer(hdr, lDistanceToMove, dwMoveContext);
+    }else {
+        SetLastError(ERROR_INVALID_HANDLE);
+        res = INVALID_SET_FILE_POINTER;
+    }
+
+    WININET_Release(hdr);
+    return res;
 }
 
 /***********************************************************************
diff --git a/dlls/wininet/internet.h b/dlls/wininet/internet.h
index 6756488d5a5..d9598d18eb5 100644
--- a/dlls/wininet/internet.h
+++ b/dlls/wininet/internet.h
@@ -225,6 +225,7 @@ typedef struct {
     void (*CloseConnection)(object_header_t*);
     DWORD (*QueryOption)(object_header_t*,DWORD,void*,DWORD*,BOOL);
     DWORD (*SetOption)(object_header_t*,DWORD,void*,DWORD);
+    DWORD (*SetFilePointer)(object_header_t*,LONG,DWORD);
     DWORD (*ReadFile)(object_header_t*,void*,DWORD,DWORD*,DWORD,DWORD_PTR);
     DWORD (*WriteFile)(object_header_t*,const void*,DWORD,DWORD*);
     DWORD (*QueryDataAvailable)(object_header_t*,DWORD*,DWORD,DWORD_PTR);
@@ -332,6 +333,7 @@ typedef struct
 
     FILETIME last_modified;
     HANDLE hCacheFile;
+    ULONGLONG cache_size;  /* size of cached data */
     req_file_t *req_file;
     FILETIME expires;
     struct HttpAuthInfo *authInfo;
@@ -339,6 +341,7 @@ typedef struct
 
     CRITICAL_SECTION read_section;  /* section to protect the following fields */
     ULONGLONG contentLength;  /* total number of bytes to be read */
+    ULONGLONG content_pos;    /* content read position */
     BOOL  read_gzip;      /* are we reading in gzip mode? */
     DWORD read_pos;       /* current read position in read_buf */
     DWORD read_size;      /* valid data size in read_buf */
diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index efa3e5928b6..eeb4a28da4b 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -581,6 +581,277 @@ static void close_async_handle(HINTERNET handle, int handle_cnt)
     CHECK_NOTIFIED2(INTERNET_STATUS_HANDLE_CLOSING, handle_cnt);
 }
 
+static void InternetSetFilePointer_test(const char *host, const char *path)
+{
+    BYTE expect_response[8192], buf[8192];
+    HINTERNET hi = 0, hic = 0, hor = 0;
+    BOOL res, expected;
+    DWORD count, size, i, pos, err;
+
+    hi = InternetOpenA("Winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(hi != 0x0, "InternetOpen failed: %lu\n", GetLastError());
+    if(hi == 0x0) goto abort;
+
+    hic = InternetConnectA(hi, host, INTERNET_DEFAULT_HTTP_PORT,
+                           NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
+    ok(hic != 0x0, "InternetConnect failed: %lu\n", GetLastError());
+    if(hic == 0x0) goto abort;
+
+    hor = HttpOpenRequestA(hic, NULL, path, NULL, NULL, NULL,
+                           INTERNET_FLAG_RELOAD,
+                           0x0);
+    ok(hor != 0x0, "HttpOpenRequest failed: %lu\n", GetLastError());
+    if(hor == 0x0) goto abort;
+
+    res = HttpSendRequestA(hor, NULL, 0, NULL, 0);
+    ok(res, "HttpSendRequest failed: %lu\n", GetLastError());
+    if(!res) goto abort;
+
+    size = 0;
+    while(size < sizeof(expect_response)) {
+        res = InternetReadFile(hor, expect_response+size, sizeof(expect_response)-size, &count);
+        if(!res || !count)
+            break;
+        size += count;
+    }
+    ok(size, "InternetReadFile returned no content\n");
+    if(!size) goto abort;
+
+    InternetCloseHandle(hor);
+    InternetCloseHandle(hic);
+    InternetCloseHandle(hi);
+
+    reset_events();
+
+    hi = InternetOpenA("Winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(hi != 0x0, "InternetOpen failed: %lu\n", GetLastError());
+    if(hi == 0x0) goto abort;
+
+    pInternetSetStatusCallbackA(hi, &callback);
+
+    SET_EXPECT(INTERNET_STATUS_HANDLE_CREATED);
+    hic = InternetConnectA(hi, host, INTERNET_DEFAULT_HTTP_PORT,
+                           NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0xdeadbeef);
+    ok(hic != 0x0, "InternetConnect failed: %lu\n", GetLastError());
+    if(hic == 0x0) goto abort;
+    CHECK_NOTIFIED(INTERNET_STATUS_HANDLE_CREATED);
+
+    SET_EXPECT(INTERNET_STATUS_HANDLE_CREATED);
+    hor = HttpOpenRequestA(hic, NULL, path, NULL, NULL, NULL,
+                           INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE,
+                           0xdeadbead);
+    ok(hor != 0x0, "HttpOpenRequest failed: %lu\n", GetLastError());
+    if(hor == 0x0) goto abort;
+    CHECK_NOTIFIED(INTERNET_STATUS_HANDLE_CREATED);
+
+    /* NULL handle tests */
+    pos = InternetSetFilePointer(NULL, 0, NULL, FILE_BEGIN, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INVALID_HANDLE;
+    ok(expected, "Expected ERROR_INVALID_HANDLE. Got %lu\n", err);
+    pos = InternetSetFilePointer(NULL, 0, NULL, FILE_CURRENT, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INVALID_HANDLE;
+    ok(expected, "Expected ERROR_INVALID_HANDLE. Got %lu\n", err);
+    pos = InternetSetFilePointer(NULL, 0, NULL, FILE_END, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INVALID_HANDLE;
+    ok(expected, "Expected ERROR_INVALID_HANDLE. Got %lu\n", err);
+
+    /* INTERNET_FLAG_DONT_CACHE before sending request */
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_BEGIN, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INTERNET_INVALID_OPERATION;
+    ok(expected, "Expected ERROR_INTERNET_INVALID_OPERATION. Got %lu\n", err);
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_CURRENT, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INTERNET_INVALID_OPERATION;
+    ok(expected, "Expected ERROR_INTERNET_INVALID_OPERATION. Got %lu\n", err);
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_END, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INTERNET_INVALID_OPERATION;
+    ok(expected, "Expected ERROR_INTERNET_INVALID_OPERATION. Got %lu\n", err);
+
+    SET_OPTIONAL(INTERNET_STATUS_CONNECTING_TO_SERVER);
+    SET_OPTIONAL(INTERNET_STATUS_CONNECTED_TO_SERVER);
+
+    SET_EXPECT(INTERNET_STATUS_SENDING_REQUEST);
+    SET_EXPECT(INTERNET_STATUS_REQUEST_SENT);
+    SET_EXPECT(INTERNET_STATUS_RECEIVING_RESPONSE);
+    SET_EXPECT(INTERNET_STATUS_RESPONSE_RECEIVED);
+
+    res = HttpSendRequestA(hor, NULL, 0, NULL, 0);
+    err = !res ? GetLastError() : NO_ERROR;
+    expected = res && err == NO_ERROR;
+    ok(expected, "HttpSendRequest failed: %lu\n", err);
+
+    CHECK_NOTIFIED(INTERNET_STATUS_SENDING_REQUEST);
+    CHECK_NOTIFIED(INTERNET_STATUS_REQUEST_SENT);
+    CHECK_NOTIFIED(INTERNET_STATUS_RECEIVING_RESPONSE);
+    CHECK_NOTIFIED(INTERNET_STATUS_RESPONSE_RECEIVED);
+
+    /* INTERNET_FLAG_DONT_CACHE after sending request */
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_BEGIN, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INTERNET_INVALID_OPERATION;
+    ok(expected, "Expected ERROR_INTERNET_INVALID_OPERATION. Got %lu\n", err);
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_CURRENT, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INTERNET_INVALID_OPERATION;
+    ok(expected, "Expected ERROR_INTERNET_INVALID_OPERATION. Got %lu\n", err);
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_END, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_INTERNET_INVALID_OPERATION;
+    ok(expected, "Expected ERROR_INTERNET_INVALID_OPERATION. Got %lu\n", err);
+
+    SET_EXPECT(INTERNET_STATUS_HANDLE_CLOSING);
+    InternetCloseHandle(hor);
+
+    SET_EXPECT(INTERNET_STATUS_HANDLE_CREATED);
+    hor = HttpOpenRequestA(hic, NULL, path, NULL, NULL, NULL,
+                           INTERNET_FLAG_RELOAD,
+                           0xdeadbead);
+    ok(hor != 0x0, "HttpOpenRequest failed: %lu\n", GetLastError());
+    if(hor == 0x0) goto abort;
+    CHECK_NOTIFIED(INTERNET_STATUS_HANDLE_CREATED);
+
+    SET_OPTIONAL(INTERNET_STATUS_CONNECTING_TO_SERVER);
+    SET_OPTIONAL(INTERNET_STATUS_CONNECTED_TO_SERVER);
+
+    SET_EXPECT(INTERNET_STATUS_SENDING_REQUEST);
+    SET_EXPECT(INTERNET_STATUS_REQUEST_SENT);
+    SET_EXPECT(INTERNET_STATUS_RECEIVING_RESPONSE);
+    SET_EXPECT(INTERNET_STATUS_RESPONSE_RECEIVED);
+
+    res = HttpSendRequestA(hor, NULL, 0, NULL, 0);
+    err = !res ? GetLastError() : NO_ERROR;
+    expected = res && err == NO_ERROR;
+    ok(expected, "HttpSendRequest failed: %lu\n", err);
+
+    CHECK_NOTIFIED(INTERNET_STATUS_SENDING_REQUEST);
+    CHECK_NOTIFIED(INTERNET_STATUS_REQUEST_SENT);
+    CHECK_NOTIFIED(INTERNET_STATUS_RECEIVING_RESPONSE);
+    CHECK_NOTIFIED(INTERNET_STATUS_RESPONSE_RECEIVED);
+
+    /* FILE_BEGIN tests */
+    i = 0;
+    while(i < min(size, 4)) {
+        SET_OPTIONAL(INTERNET_STATUS_RECEIVING_RESPONSE);
+        SET_OPTIONAL(INTERNET_STATUS_RESPONSE_RECEIVED);
+        pos = InternetSetFilePointer(hor, i, NULL, FILE_BEGIN, 0);
+        err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+        expected = pos == i && err == NO_ERROR;
+        ok(expected, "Expected position %#lx. Got %#lx. GetLastError() %lu\n", i, pos, err);
+        res = InternetReadFile(hor, buf, sizeof(buf), &count);
+        err = !res ? GetLastError() : NO_ERROR;
+        ok(res, "InternetReadFile failed: %lu\n", err);
+        ok(count, "InternetReadFile returned no content\n");
+        ok(!memcmp(expect_response+i, buf, min(sizeof(buf)-i, count)),
+           "Unexpected result from InternetReadFile\n");
+        i = i + 1;
+    }
+    while(i > 0) {
+        SET_OPTIONAL(INTERNET_STATUS_RECEIVING_RESPONSE);
+        SET_OPTIONAL(INTERNET_STATUS_RESPONSE_RECEIVED);
+        pos = InternetSetFilePointer(hor, i, NULL, FILE_BEGIN, 0);
+        err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+        expected = pos == i && err == NO_ERROR;
+        ok(expected, "Expected position %#lx. Got %#lx. GetLastError() %lu\n", i, pos, err);
+        res = InternetReadFile(hor, buf, sizeof(buf), &count);
+        err = !res ? GetLastError() : NO_ERROR;
+        ok(res, "InternetReadFile failed: %lu\n", err);
+        ok(!memcmp(expect_response+i, buf, min(sizeof(buf)-i, count)),
+           "Unexpected result from InternetReadFile\n");
+        i = i - 1;
+    }
+    SetLastError(0xdeadbeef);
+    pos = InternetSetFilePointer(hor, INT_MAX, NULL, FILE_BEGIN, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INT_MAX && err == NO_ERROR;
+    ok(expected, "Expected position %#x. Got %#lx. GetLastError() %lu\n", INT_MAX, pos, err);
+    SetLastError(0xdeadbeef);
+    pos = InternetSetFilePointer(hor, -1, NULL, FILE_BEGIN, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == -1 && err == NO_ERROR;
+    ok(expected, "Expected position %#x. Got %#lx. GetLastError() %lu\n", -1, pos, err);
+
+    /* FILE_CURRENT tests */
+    i = 0;
+    while(i < min(size, 4)) {
+        SET_OPTIONAL(INTERNET_STATUS_RECEIVING_RESPONSE);
+        SET_OPTIONAL(INTERNET_STATUS_RESPONSE_RECEIVED);
+        i = i + 1;
+        pos = InternetSetFilePointer(hor, 0, NULL, FILE_BEGIN, 0);
+        err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+        expected = pos == 0 && err == NO_ERROR;
+        ok(expected, "Expected position %#lx. Got %#lx. GetLastError() %lu\n", i, pos, err);
+        pos = InternetSetFilePointer(hor, i, NULL, FILE_CURRENT, 0);
+        err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+        expected = pos == i && err == NO_ERROR;
+        ok(expected, "Expected position %#lx. Got %#lx. GetLastError() %lu\n", i, pos, err);
+        res = InternetReadFile(hor, buf, 1024, &count);
+        err = !res ? GetLastError() : NO_ERROR;
+        ok(res, "InternetReadFile failed: %lu\n", err);
+        ok(!memcmp(expect_response+i, buf, min(sizeof(buf)-i, count)),
+           "Unexpected result from InternetReadFile\n");
+    }
+    pos = InternetSetFilePointer(hor, -1, NULL, FILE_CURRENT, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_NEGATIVE_SEEK;
+    ok(expected, "Expected ERROR_NEGATIVE_SEEK. Got %lu\n", err);
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_BEGIN, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == 0 && err == NO_ERROR;
+    ok(expected, "Expected position %#x. Got %#lx. GetLastError() %lu\n", 0, pos, err);
+    pos = InternetSetFilePointer(hor, -1, NULL, FILE_CURRENT, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == -1 && err == NO_ERROR;
+    ok(expected, "Expected position %#x. Got %#lx. GetLastError() %lu\n", -1, pos, err);
+    pos = InternetSetFilePointer(hor, -1, NULL, FILE_CURRENT, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_NEGATIVE_SEEK;
+    ok(expected, "Expected ERROR_NEGATIVE_SEEK. Got %lu\n", err);
+
+    /* FILE_END tests */
+    pos = InternetSetFilePointer(hor, 0, NULL, FILE_END, 0);
+    err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+    expected = pos == size && err == NO_ERROR;
+    todo_wine ok(expected, "Expected position %#lx. Got %#lx. GetLastError() %lu\n", size, pos, err);
+    i = 0;
+    while(i < min(size, 4)) {
+        SET_OPTIONAL(INTERNET_STATUS_RECEIVING_RESPONSE);
+        SET_OPTIONAL(INTERNET_STATUS_RESPONSE_RECEIVED);
+        i = i + 1;
+        pos = InternetSetFilePointer(hor, i, NULL, FILE_END, 0);
+        err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+        expected = pos == size+i && err == NO_ERROR;
+        todo_wine ok(expected, "Expected position %#lx. Got %#lx. GetLastError() %lu\n",
+           size+i, pos, err);
+    }
+    i = 0;
+    while(i < min(size, 4)) {
+        SET_OPTIONAL(INTERNET_STATUS_RECEIVING_RESPONSE);
+        SET_OPTIONAL(INTERNET_STATUS_RESPONSE_RECEIVED);
+        i = i + 1;
+        pos = InternetSetFilePointer(hor, -i, NULL, FILE_END, 0);
+        err = pos == INVALID_SET_FILE_POINTER ? GetLastError() : NO_ERROR;
+        expected = pos == INVALID_SET_FILE_POINTER && err == ERROR_NEGATIVE_SEEK;
+        todo_wine ok(expected, "Expected ERROR_NEGATIVE_SEEK. Got %lu\n", err);
+    }
+
+    CLEAR_NOTIFIED(INTERNET_STATUS_RECEIVING_RESPONSE);
+    CLEAR_NOTIFIED(INTERNET_STATUS_RESPONSE_RECEIVED);
+
+abort:
+    SET_OPTIONAL(INTERNET_STATUS_CLOSING_CONNECTION);
+    SET_OPTIONAL(INTERNET_STATUS_CONNECTION_CLOSED);
+    SET_OPTIONAL(INTERNET_STATUS_HANDLE_CLOSING);
+    if(hor) InternetCloseHandle(hor);
+    SET_OPTIONAL(INTERNET_STATUS_HANDLE_CLOSING);
+    if(hic) InternetCloseHandle(hic);
+    if(hi) InternetCloseHandle(hi);
+}
+
 static void InternetReadFile_test(int flags, const test_data_t *test)
 {
     char *post_data = NULL;
@@ -5838,6 +6109,80 @@ static void test_http_read(int port)
     skip_receive_notification_tests = FALSE;
 }
 
+static void test_file_pointer(int port)
+{
+    INTERNET_BUFFERSW ib;
+    test_request_t req;
+    char buf[24000];
+    DWORD pos, read_size;
+
+    skip_receive_notification_tests = TRUE;
+
+    memset(&ib, 0, sizeof(ib));
+    ib.dwStructSize = sizeof(ib);
+    ib.lpvBuffer = buf;
+
+    open_read_test_request(port, &req,
+                           "HTTP/1.1 200 OK\r\n"
+                           "Server: winetest\r\n"
+                           "Content-Length: 100\r\n"
+                           "\r\n"
+                           "xyz");
+
+    SET_OPTIONAL(INTERNET_STATUS_RECEIVING_RESPONSE);
+    readex_expect_sync_data(req.request, IRF_NO_WAIT, &ib, sizeof(buf), "xyz", 0);
+    CLEAR_NOTIFIED(INTERNET_STATUS_RECEIVING_RESPONSE);
+
+    /* jump back to 2nd byte */
+    pos = InternetSetFilePointer(req.request, 2, NULL, FILE_BEGIN, 0);
+    ok(pos == 2, "pos = %ld (gle %lu)\n", pos, GetLastError());
+
+    expect_data_available(req.request, 1);
+    readex_expect_sync_data(req.request, IRF_NO_WAIT, &ib, sizeof(buf), "z", 0);
+
+    /* jump forward to 5th byte (not yet available) */
+    pos = InternetSetFilePointer(req.request, 5, NULL, FILE_BEGIN, 0);
+    ok(pos == 5, "pos = %ld (gle %lu)\n", pos, GetLastError());
+
+    /* querying available data will wait until we have enough data */
+    async_query_data_available(req.request, &read_size);
+    send_response_and_wait("12345", FALSE, NULL, &read_size, NULL, 3, 3, 61);
+    expect_data_available(req.request, 3);
+
+    /* skip one byte and verify that we're at expected position by reading one byte */
+    pos = InternetSetFilePointer(req.request, 1, NULL, FILE_CURRENT, 0);
+    ok(pos == 6, "pos = %ld (gle %lu)\n", pos, GetLastError());
+    readex_expect_sync_data(req.request, IRF_NO_WAIT, &ib, 1, "4", 0);
+
+    /* jump past available bytes, read will wait for available data */
+    pos = InternetSetFilePointer(req.request, 2, NULL, FILE_CURRENT, 0);
+    ok(pos == 9, "pos = %ld (gle %lu)\n", pos, GetLastError());
+
+    readex_expect_async(req.request, IRF_ASYNC, &ib, 3, "");
+    send_response_ex_and_wait("abcde", FALSE, &ib, "bcd", 0, 61);
+
+    /* jump back to the beginning */
+    pos = InternetSetFilePointer(req.request, 0, NULL, FILE_BEGIN, 0);
+    ok(pos == 0, "pos = %ld (gle %lu)\n", pos, GetLastError());
+    readex_expect_sync_data(req.request, IRF_NO_WAIT, &ib, 12, "xyz12345abcd", 0);
+
+    /* jump past the available data then send more data and close the connection */
+    pos = InternetSetFilePointer(req.request, 3, NULL, FILE_CURRENT, 0);
+    ok(pos == 15, "pos = %ld (gle %lu)\n", pos, GetLastError());
+    readex_expect_async(req.request, IRF_ASYNC, &ib, sizeof(buf), "");
+    send_response_ex_and_wait("12345", TRUE, &ib, "345", 0, 61);
+
+    SET_EXPECT(INTERNET_STATUS_CLOSING_CONNECTION);
+    SET_EXPECT(INTERNET_STATUS_CONNECTION_CLOSED);
+    close_async_handle(req.session, 2);
+    todo_wine
+    CHECK_NOTIFIED(INTERNET_STATUS_CLOSING_CONNECTION);
+    todo_wine
+    CHECK_NOTIFIED(INTERNET_STATUS_CONNECTION_CLOSED);
+
+    skip_receive_notification_tests = FALSE;
+}
+
 static void test_connection_break(int port)
 {
     INTERNET_BUFFERSW ib;
@@ -6288,6 +6633,7 @@ static void test_http_connection(void)
     test_basic_auth_credentials_cached_manual(si.port);
     test_async_read(si.port);
     test_http_read(si.port);
+    test_file_pointer(si.port);
     test_connection_break(si.port);
     test_long_url(si.port);
     test_redirect(si.port);
@@ -7946,6 +8292,7 @@ START_TEST(http)
     InternetReadFile_chunked_test();
     HttpSendRequestEx_test();
     InternetReadFile_test(INTERNET_FLAG_ASYNC, &test_data[3]);
+    InternetSetFilePointer_test("test.winehq.org", "/tests/hello.html");
     test_connection_failure();
     test_default_service_port();
     test_concurrent_header_access();
diff --git a/dlls/winscard/Makefile.in b/dlls/winscard/Makefile.in
index 89449698b66..f8213728d22 100644
--- a/dlls/winscard/Makefile.in
+++ b/dlls/winscard/Makefile.in
@@ -1,7 +1,10 @@
 MODULE    = winscard.dll
 IMPORTLIB = winscard
+UNIXLIB   = winscard.so
+UNIX_LIBS = $(PCSCLITE_LIBS)
 
 C_SRCS = \
+	unixlib.c \
 	winscard.c
 
 RC_SRCS = \
diff --git a/dlls/winscard/tests/Makefile.in b/dlls/winscard/tests/Makefile.in
new file mode 100644
index 00000000000..70c3df9c3e8
--- /dev/null
+++ b/dlls/winscard/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL  = winscard.dll
+IMPORTS  = winscard
+
+C_SRCS = \
+	winscard.c
diff --git a/dlls/winscard/tests/winscard.c b/dlls/winscard/tests/winscard.c
new file mode 100644
index 00000000000..c31318cf1dd
--- /dev/null
+++ b/dlls/winscard/tests/winscard.c
@@ -0,0 +1,237 @@
+/*
+ * Unit test for winscard functions
+ *
+ * Copyright 2022 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdio.h>
+#include <windows.h>
+#include <winscard.h>
+
+#include "wine/test.h"
+
+static void test_SCardEstablishContext(void)
+{
+    const BYTE cmd[] = {0x00, 0xca, 0x01, 0x86, 0x00};
+    SCARDCONTEXT context;
+    SCARDHANDLE connect;
+    SCARD_READERSTATEA states[2];
+    SCARD_IO_REQUEST send_pci = {SCARD_PROTOCOL_T1, 8}, recv_pci = {SCARD_PROTOCOL_T1, 8};
+    char *readers, *groups, *ptr;
+    WCHAR *names, *ptrW;
+    BYTE buf[32], recv_buf[264], *atr, *attr;
+    DWORD len, atrlen, state, protocol;
+    LONG ret;
+
+    ret = SCardEstablishContext( 0, NULL, NULL, NULL );
+    ok( ret == SCARD_E_INVALID_PARAMETER, "got %lx\n", ret );
+
+    ret = SCardEstablishContext( 0, NULL, NULL, &context );
+    if (ret == SCARD_E_NO_SERVICE)
+    {
+        skip( "can't establish context, make sure pcscd is running\n" );
+        return;
+    }
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardIsValidContext( context );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    len = 0;
+    ret = SCardListReadersA( context, NULL, NULL, &len );
+    if (ret == SCARD_E_NO_READERS_AVAILABLE)
+    {
+        skip( "connect a smart card device to run more tests\n" );
+        return;
+    }
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( len, "got zero length\n" );
+
+    readers = calloc( 1, len );
+    ret = SCardListReadersA( context, NULL, readers, NULL );
+    ok( ret == SCARD_E_INVALID_PARAMETER, "got %lx\n", ret );
+
+    ret = SCardListReadersA( context, NULL, readers, &len );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ptr = readers;
+    while (*ptr)
+    {
+        trace( "found reader: %s\n", wine_dbgstr_a(ptr) );
+        ptr += strlen( ptr ) + 1;
+    }
+
+    len = 0;
+    ret = SCardListReaderGroupsA( context, NULL, &len );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( len, "got zero length\n" );
+
+    groups = calloc( 1, len );
+    ret = SCardListReaderGroupsA( context, groups, &len );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ptr = groups;
+    while (*ptr)
+    {
+        trace( "found group: %s\n", wine_dbgstr_a(ptr) );
+        ptr += strlen( ptr ) + 1;
+    }
+    free( groups );
+
+    ret = SCardGetStatusChangeW( context, 1000, NULL, 0 );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    memset( states, 0, sizeof(states) );
+    states[0].szReader = "\\\\?PnP?\\Notification";
+    states[1].szReader = readers;
+    ret = SCardGetStatusChangeA( context, 1000, states, 2 );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    states[1].dwCurrentState = states[1].dwEventState & ~SCARD_STATE_CHANGED;
+    ret = SCardGetStatusChangeA( context, 1000, states, 2 );
+    todo_wine ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardConnectA( context, readers, SCARD_SHARE_SHARED, SCARD_PROTOCOL_Tx, &connect, NULL );
+    if (ret == SCARD_E_READER_UNAVAILABLE)
+    {
+        skip( "can't connect to reader %s (in use by other application?)\n", wine_dbgstr_a(readers) );
+        free( readers );
+        return;
+    }
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    connect = 0xdeadbeef;
+    protocol = 0xdeadbeef;
+    ret = SCardConnectA( context, readers, SCARD_SHARE_SHARED, SCARD_PROTOCOL_Tx, &connect, &protocol );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( connect != 0xdeadbeef, "connect not set\n" );
+    ok( protocol == SCARD_PROTOCOL_T1, "got %lx\n", protocol );
+    free( readers );
+
+    len = atrlen = 0;
+    state = 0xdeadbeef;
+    protocol = 0xdeadbeef;
+    ret = SCardStatusW( connect, NULL, &len, &state, &protocol, NULL, &atrlen );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( len, "got zero length\n" );
+    ok( state != 0xdeadbeef, "state not set\n" );
+    ok( protocol == SCARD_PROTOCOL_T1, "got %lx\n", protocol );
+    ok( atrlen, "got zero length\n" );
+
+    names = calloc( 1, len * sizeof(WCHAR) );
+    atr = calloc( 1, atrlen );
+    state = protocol = 0xdeadbeef;
+    ret = SCardStatusW( connect, names, &len, &state, &protocol, atr, &atrlen );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( state != 0xdeadbeef, "state not set\n" );
+    ok( protocol == SCARD_PROTOCOL_T1, "got %lx\n", protocol );
+    ptrW = names;
+    while (*ptrW)
+    {
+        trace( "found name: %s\n", wine_dbgstr_w(ptrW) );
+        ptrW += wcslen( ptrW ) + 1;
+    }
+    ret = SCardStatusW( connect, names, &len, &state, &protocol, NULL, NULL );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ret = SCardStatusW( connect, NULL, NULL, &state, &protocol, NULL, NULL );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ret = SCardStatusW( connect, NULL, NULL, NULL, NULL, NULL, NULL );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    free( names );
+    free( atr );
+
+    ret = SCardBeginTransaction( connect );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardEndTransaction( connect, 0 );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardReconnect( connect, SCARD_SHARE_SHARED, SCARD_PROTOCOL_Tx, SCARD_LEAVE_CARD, NULL );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    protocol = 0xdeadbeef;
+    ret = SCardReconnect( connect, SCARD_SHARE_SHARED, SCARD_PROTOCOL_Tx, SCARD_LEAVE_CARD, &protocol );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( protocol == SCARD_PROTOCOL_T1, "got %lx\n", protocol );
+
+    len = 0;
+    ret = SCardGetAttrib( connect, SCARD_ATTR_VENDOR_NAME, NULL, &len );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    ok( len, "got zero length\n" );
+
+    attr = calloc( 1, len );
+    ret = SCardGetAttrib( connect, SCARD_ATTR_VENDOR_NAME, attr, &len );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardGetAttrib( connect, SCARD_ATTR_VENDOR_NAME, attr, NULL );
+    ok( ret == SCARD_E_INVALID_PARAMETER, "got %lx\n", ret );
+    free( attr );
+
+    ret = SCardBeginTransaction( connect );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    send_pci.dwProtocol = recv_pci.dwProtocol = protocol;
+    memset( recv_buf, 0, sizeof(recv_buf) );
+    ret = SCardTransmit( connect, &send_pci, cmd, sizeof(cmd), &recv_pci, recv_buf, NULL );
+    ok( ret == SCARD_E_INVALID_PARAMETER, "got %lx (%lu)\n", ret, ret );
+
+    len = sizeof(recv_buf);
+    ret = SCardTransmit( connect, &send_pci, cmd, sizeof(cmd), &recv_pci, recv_buf, &len );
+    ok( ret == SCARD_S_SUCCESS, "got %lx (%lu)\n", ret, ret );
+
+    ret = SCardEndTransaction( connect, 0 );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    buf[0] = 0x02;
+    ret = SCardControl( connect, SCARD_CTL_CODE(1), buf, 1, buf, sizeof(buf), NULL );
+    ok( ret == SCARD_E_INVALID_PARAMETER, "got %lx\n", ret );
+
+    len = sizeof(buf);
+    ret = SCardControl( connect, SCARD_CTL_CODE(1), buf, 1, buf, sizeof(buf), &len );
+    todo_wine ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+    todo_wine ok( !len, "got %lu\n", len );
+
+    ret = SCardDisconnect( connect, 0 );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardDisconnect( 0, 0 );
+    ok( ret == ERROR_INVALID_HANDLE, "got %lx\n", ret );
+
+    ret = SCardCancel( context );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardCancel( 0 );
+    ok( ret == ERROR_INVALID_HANDLE, "got %lx\n", ret );
+
+    ret = SCardIsValidContext( context );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardReleaseContext( 0 );
+    ok( ret == ERROR_INVALID_HANDLE, "got %lx\n", ret );
+
+    ret = SCardReleaseContext( context );
+    ok( ret == SCARD_S_SUCCESS, "got %lx\n", ret );
+
+    ret = SCardIsValidContext( context );
+    ok( ret == ERROR_INVALID_HANDLE, "got %lx\n", ret );
+
+    ret = SCardIsValidContext( 0 );
+    ok( ret == ERROR_INVALID_HANDLE, "got %lx\n", ret );
+}
+
+START_TEST(winscard)
+{
+    test_SCardEstablishContext();
+}
diff --git a/dlls/winscard/unixlib.c b/dlls/winscard/unixlib.c
new file mode 100644
index 00000000000..cd55e6352a8
--- /dev/null
+++ b/dlls/winscard/unixlib.c
@@ -0,0 +1,531 @@
+/*
+ * Copyright 2022 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include <stdarg.h>
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "winbase.h"
+
+#include "wine/debug.h"
+#include "wine/unixlib.h"
+#include "unixlib.h"
+
+LONG SCardEstablishContext( UINT64, const void *, const void *, UINT64 * );
+LONG SCardReleaseContext( UINT64 );
+LONG SCardIsValidContext( UINT64 );
+LONG SCardGetStatusChange( UINT64, UINT64, struct reader_state *, UINT64 );
+LONG SCardCancel( UINT64 );
+LONG SCardListReaders( UINT64, const char *, char *, UINT64 * );
+LONG SCardListReaderGroups( UINT64, char *, UINT64 * );
+LONG SCardConnect( UINT64, const char *, UINT64, UINT64, UINT64 *, UINT64 * );
+LONG SCardStatus( UINT64, char *, UINT64 *, UINT64 *, UINT64 *, BYTE *, UINT64 * );
+LONG SCardDisconnect( UINT64, UINT64 );
+LONG SCardReconnect( UINT64, UINT64, UINT64, UINT64, UINT64 * );
+LONG SCardBeginTransaction( UINT64 );
+LONG SCardEndTransaction( UINT64, UINT64 );
+LONG SCardTransmit( UINT64, const struct io_request *, const BYTE *, UINT64, struct io_request *, BYTE *, UINT64 * );
+LONG SCardControl( UINT64, UINT64, const void *, UINT64, void *, UINT64, UINT64 * );
+LONG SCardGetAttrib( UINT64, UINT64, BYTE *, UINT64 * );
+LONG SCardSetAttrib( UINT64, UINT64, const BYTE *, UINT64 );
+
+static NTSTATUS scard_establish_context( void *args )
+{
+    struct scard_establish_context_params *params = args;
+    return SCardEstablishContext( params->scope, NULL, NULL, params->handle );
+}
+
+static NTSTATUS scard_release_context( void *args )
+{
+    struct scard_release_context_params *params = args;
+    return SCardReleaseContext( params->handle );
+}
+
+static NTSTATUS scard_is_valid_context( void *args )
+{
+    struct scard_is_valid_context_params *params = args;
+    return SCardIsValidContext( params->handle );
+}
+
+static NTSTATUS scard_get_status_change( void *args )
+{
+    struct scard_get_status_change_params *params = args;
+    return SCardGetStatusChange( params->handle, params->timeout, params->states, params->count );
+}
+
+static NTSTATUS scard_cancel( void *args )
+{
+    struct scard_cancel_params *params = args;
+    return SCardCancel( params->handle );
+}
+
+static NTSTATUS scard_list_readers( void *args )
+{
+    struct scard_list_readers_params *params = args;
+    return SCardListReaders( params->handle, params->groups, params->readers, params->readers_len );
+}
+
+static NTSTATUS scard_list_reader_groups( void *args )
+{
+    struct scard_list_reader_groups_params *params = args;
+    return SCardListReaderGroups( params->handle, params->groups, params->groups_len );
+}
+
+static NTSTATUS scard_connect( void *args )
+{
+    struct scard_connect_params *params = args;
+    return SCardConnect( params->context_handle, params->reader, params->share_mode, params->preferred_protocols,
+                         params->connect_handle, params->protocol );
+}
+
+static NTSTATUS scard_status( void *args )
+{
+    struct scard_status_params *params = args;
+    return SCardStatus( params->handle, params->names, params->names_len, params->state, params->protocol,
+                        params->atr, params->atr_len );
+}
+
+static NTSTATUS scard_reconnect( void *args )
+{
+    struct scard_reconnect_params *params = args;
+    return SCardReconnect( params->handle, params->share_mode, params->preferred_protocols,
+                            params->initialization, params->protocol );
+}
+
+static NTSTATUS scard_disconnect( void *args )
+{
+    struct scard_disconnect_params *params = args;
+    return SCardDisconnect( params->handle, params->disposition );
+}
+
+static NTSTATUS scard_begin_transaction( void *args )
+{
+    struct scard_begin_transaction_params *params = args;
+    return SCardBeginTransaction( params->handle );
+}
+
+static NTSTATUS scard_end_transaction( void *args )
+{
+    struct scard_end_transaction_params *params = args;
+    return SCardEndTransaction( params->handle, params->disposition );
+}
+
+static NTSTATUS scard_transmit( void *args )
+{
+    struct scard_transmit_params *params = args;
+    return SCardTransmit( params->handle, params->send, params->send_buf, params->send_buflen, params->recv,
+                          params->recv_buf, params->recv_buflen );
+}
+
+static NTSTATUS scard_control( void *args )
+{
+    struct scard_control_params *params = args;
+    return SCardControl( params->handle, params->code, params->in_buf, params->in_buflen, params->out_buf,
+                         params->out_buflen, params->ret_len );
+}
+
+static NTSTATUS scard_get_attrib( void *args )
+{
+    struct scard_get_attrib_params *params = args;
+    return SCardGetAttrib( params->handle, params->id, params->attr, params->attr_len );
+}
+
+static NTSTATUS scard_set_attrib( void *args )
+{
+    struct scard_set_attrib_params *params = args;
+    return SCardSetAttrib( params->handle, params->id, params->attr, params->attr_len );
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    scard_establish_context,
+    scard_release_context,
+    scard_is_valid_context,
+    scard_get_status_change,
+    scard_cancel,
+    scard_list_readers,
+    scard_list_reader_groups,
+    scard_connect,
+    scard_status,
+    scard_reconnect,
+    scard_disconnect,
+    scard_begin_transaction,
+    scard_end_transaction,
+    scard_transmit,
+    scard_control,
+    scard_get_attrib,
+    scard_set_attrib,
+};
+
+#ifdef _WIN64
+
+typedef ULONG PTR32;
+
+static NTSTATUS wow64_scard_establish_context( void *args )
+{
+    struct
+    {
+        UINT64 scope;
+        PTR32 handle;
+    } const *params32 = args;
+
+    struct scard_establish_context_params params =
+    {
+        params32->scope,
+        ULongToPtr(params32->handle)
+    };
+    return scard_establish_context( &params );
+}
+
+static NTSTATUS wow64_scard_release_context( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+    } const *params32 = args;
+
+    struct scard_release_context_params params =
+    {
+        params32->handle
+    };
+    return scard_release_context( &params );
+}
+
+static NTSTATUS wow64_scard_is_valid_context( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+    } const *params32 = args;
+
+    struct scard_is_valid_context_params params =
+    {
+        params32->handle
+    };
+    return scard_is_valid_context( &params );
+}
+
+static NTSTATUS wow64_scard_get_status_change( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 timeout;
+        PTR32 states;
+        UINT64 count;
+    } const *params32 = args;
+
+    struct scard_get_status_change_params params =
+    {
+        params32->handle,
+        params32->timeout,
+        ULongToPtr(params32->states),
+        params32->count,
+    };
+    return scard_get_status_change( &params );
+}
+
+static NTSTATUS wow64_scard_cancel( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+    } const *params32 = args;
+
+    struct scard_cancel_params params =
+    {
+        params32->handle
+    };
+    return scard_cancel( &params );
+}
+
+static NTSTATUS wow64_scard_list_readers( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 groups;
+        PTR32 readers;
+        PTR32 readers_len;
+    } *params32 = args;
+
+    struct scard_list_readers_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->groups),
+        ULongToPtr(params32->readers),
+        ULongToPtr(params32->readers_len)
+    };
+    return scard_list_readers( &params );
+};
+
+static NTSTATUS wow64_scard_list_reader_groups( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 groups;
+        PTR32 groups_len;
+    } *params32 = args;
+
+    struct scard_list_reader_groups_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->groups),
+        ULongToPtr(params32->groups_len)
+    };
+    return scard_list_reader_groups( &params );
+}
+
+static NTSTATUS wow64_scard_connect( void *args )
+{
+    struct
+    {
+        UINT64 context_handle;
+        PTR32 reader;
+        UINT64 share_mode;
+        UINT64 preferred_protocols;
+        PTR32 connect_handle;
+        PTR32 protocol;
+    } *params32 = args;
+
+    struct scard_connect_params params =
+    {
+        params32->context_handle,
+        ULongToPtr(params32->reader),
+        params32->share_mode,
+        params32->preferred_protocols,
+        ULongToPtr(params32->connect_handle),
+        ULongToPtr(params32->protocol)
+    };
+    return scard_connect( &params );
+}
+
+static NTSTATUS wow64_scard_status( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 names;
+        PTR32 names_len;
+        PTR32 state;
+        PTR32 protocol;
+        PTR32 atr;
+        PTR32 atr_len;
+    } *params32 = args;
+
+    struct scard_status_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->names),
+        ULongToPtr(params32->names_len),
+        ULongToPtr(params32->state),
+        ULongToPtr(params32->protocol),
+        ULongToPtr(params32->atr),
+        ULongToPtr(params32->atr_len)
+    };
+    return scard_status( &params );
+};
+
+static NTSTATUS wow64_scard_reconnect( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 share_mode;
+        UINT64 preferred_protocols;
+        UINT64 initialization;
+        PTR32 protocol;
+    } *params32 = args;
+
+    struct scard_reconnect_params params =
+    {
+        params32->handle,
+        params32->share_mode,
+        params32->preferred_protocols,
+        params32->initialization,
+        ULongToPtr(params32->protocol)
+    };
+    return scard_reconnect( &params );
+}
+
+static NTSTATUS wow64_scard_disconnect( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 disposition;
+    } *params32 = args;
+
+    struct scard_disconnect_params params =
+    {
+        params32->handle,
+        params32->disposition
+    };
+    return scard_disconnect( &params );
+}
+
+static NTSTATUS wow64_scard_begin_transaction( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+    } *params32 = args;
+
+    struct scard_begin_transaction_params params =
+    {
+        params32->handle
+    };
+    return scard_begin_transaction( &params );
+}
+
+static NTSTATUS wow64_scard_end_transaction( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 disposition;
+    } *params32 = args;
+
+    struct scard_end_transaction_params params =
+    {
+        params32->handle,
+        params32->disposition
+    };
+    return scard_end_transaction( &params );
+}
+
+static NTSTATUS wow64_scard_transmit( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 send;
+        PTR32 send_buf;
+        UINT64 send_buflen;
+        PTR32 recv;
+        PTR32 recv_buf;
+        PTR32 recv_buflen;
+    } *params32 = args;
+
+    struct scard_transmit_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->send),
+        ULongToPtr(params32->send_buf),
+        params32->send_buflen,
+        ULongToPtr(params32->recv),
+        ULongToPtr(params32->recv_buf),
+        ULongToPtr(params32->recv_buflen)
+    };
+    return scard_transmit( &params );
+};
+
+static NTSTATUS wow64_scard_control( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 code;
+        PTR32 in_buf;
+        UINT64 in_buflen;
+        PTR32 out_buf;
+        UINT64 out_buflen;
+        PTR32 ret_len;
+    } *params32 = args;
+
+    struct scard_control_params params =
+    {
+        params32->handle,
+        params32->code,
+        ULongToPtr(params32->in_buf),
+        params32->in_buflen,
+        ULongToPtr(params32->out_buf),
+        params32->out_buflen,
+        ULongToPtr(params32->ret_len)
+    };
+    return scard_control( &params );
+};
+
+static NTSTATUS wow64_scard_get_attrib( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 id;
+        PTR32 attr;
+        PTR32 attr_len;
+    } *params32 = args;
+
+    struct scard_get_attrib_params params =
+    {
+        params32->handle,
+        params32->id,
+        ULongToPtr(params32->attr),
+        ULongToPtr(params32->attr_len)
+    };
+    return scard_get_attrib( &params );
+}
+
+static NTSTATUS wow64_scard_set_attrib( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        UINT64 id;
+        PTR32 attr;
+        UINT64 attr_len;
+    } *params32 = args;
+
+    struct scard_set_attrib_params params =
+    {
+        params32->handle,
+        params32->id,
+        ULongToPtr(params32->attr),
+        params32->attr_len
+    };
+    return scard_set_attrib( &params );
+}
+
+const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
+{
+    wow64_scard_establish_context,
+    wow64_scard_release_context,
+    wow64_scard_is_valid_context,
+    wow64_scard_get_status_change,
+    wow64_scard_cancel,
+    wow64_scard_list_readers,
+    wow64_scard_list_reader_groups,
+    wow64_scard_connect,
+    wow64_scard_status,
+    wow64_scard_reconnect,
+    wow64_scard_disconnect,
+    wow64_scard_begin_transaction,
+    wow64_scard_end_transaction,
+    wow64_scard_transmit,
+    wow64_scard_control,
+    wow64_scard_get_attrib,
+    wow64_scard_set_attrib,
+};
+
+#endif  /* _WIN64 */
diff --git a/dlls/winscard/unixlib.h b/dlls/winscard/unixlib.h
new file mode 100644
index 00000000000..ecb1b40ef68
--- /dev/null
+++ b/dlls/winscard/unixlib.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2022 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* pcsclite defines DWORD as unsigned long on 64-bit (except on macOS),
+ * so use UINT64 instead. */
+
+struct scard_establish_context_params
+{
+    UINT64 scope;
+    UINT64 *handle;
+};
+
+struct scard_release_context_params
+{
+    UINT64 handle;
+};
+
+struct scard_is_valid_context_params
+{
+    UINT64 handle;
+};
+
+#define MAX_ATR_SIZE 33
+struct reader_state
+{
+    UINT64 reader;
+    UINT64 userdata;
+    UINT64 current_state;
+    UINT64 event_state;
+    UINT64 atr_size;
+    unsigned char atr[MAX_ATR_SIZE];
+};
+
+struct scard_get_status_change_params
+{
+    UINT64 handle;
+    UINT64 timeout;
+    struct reader_state *states;
+    UINT64 count;
+};
+
+struct scard_cancel_params
+{
+    UINT64 handle;
+};
+
+struct scard_list_readers_params
+{
+    UINT64 handle;
+    const char *groups;
+    char *readers;
+    UINT64 *readers_len;
+};
+
+struct scard_list_reader_groups_params
+{
+    UINT64 handle;
+    char *groups;
+    UINT64 *groups_len;
+};
+
+struct scard_connect_params
+{
+    UINT64 context_handle;
+    const char *reader;
+    UINT64 share_mode;
+    UINT64 preferred_protocols;
+    UINT64 *connect_handle;
+    UINT64 *protocol;
+};
+
+struct scard_status_params
+{
+    UINT64 handle;
+    char *names;
+    UINT64 *names_len;
+    UINT64 *state;
+    UINT64 *protocol;
+    BYTE *atr;
+    UINT64 *atr_len;
+};
+
+struct scard_reconnect_params
+{
+    UINT64 handle;
+    UINT64 share_mode;
+    UINT64 preferred_protocols;
+    UINT64 initialization;
+    UINT64 *protocol;
+};
+
+struct scard_disconnect_params
+{
+    UINT64 handle;
+    UINT64 disposition;
+};
+
+struct scard_begin_transaction_params
+{
+    UINT64 handle;
+};
+
+struct scard_end_transaction_params
+{
+    UINT64 handle;
+    UINT64 disposition;
+};
+
+struct io_request
+{
+    UINT64 protocol;
+    UINT64 pci_len;
+};
+
+struct scard_transmit_params
+{
+    UINT64 handle;
+    const struct io_request *send;
+    const BYTE *send_buf;
+    UINT64 send_buflen;
+    struct io_request *recv;
+    BYTE *recv_buf;
+    UINT64 *recv_buflen;
+};
+
+struct scard_control_params
+{
+    UINT64 handle;
+    UINT64 code;
+    const void *in_buf;
+    UINT64 in_buflen;
+    void *out_buf;
+    UINT64 out_buflen;
+    UINT64 *ret_len;
+};
+
+struct scard_get_attrib_params
+{
+    UINT64 handle;
+    UINT64 id;
+    void *attr;
+    UINT64 *attr_len;
+};
+
+struct scard_set_attrib_params
+{
+    UINT64 handle;
+    UINT64 id;
+    const void *attr;
+    UINT64 attr_len;
+};
+
+enum winscard_funcs
+{
+    unix_scard_establish_context,
+    unix_scard_release_context,
+    unix_scard_is_valid_context,
+    unix_scard_get_status_change,
+    unix_scard_cancel,
+    unix_scard_list_readers,
+    unix_scard_list_reader_groups,
+    unix_scard_connect,
+    unix_scard_status,
+    unix_scard_reconnect,
+    unix_scard_disconnect,
+    unix_scard_begin_transaction,
+    unix_scard_end_transaction,
+    unix_scard_transmit,
+    unix_scard_control,
+    unix_scard_get_attrib,
+    unix_scard_set_attrib,
+};
diff --git a/dlls/winscard/winscard.c b/dlls/winscard/winscard.c
index accbaf75c3d..c7954faa400 100644
--- a/dlls/winscard/winscard.c
+++ b/dlls/winscard/winscard.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2007 Mounir IDRASSI  (mounir.idrassi@idrix.fr, for IDRIX)
+ * Copyright 2022 Hans Leidekker for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,131 +20,903 @@
 #include <stdarg.h>
 #include "windef.h"
 #include "winbase.h"
-#include "wine/debug.h"
 #include "winscard.h"
 #include "winternl.h"
 
+#include "wine/debug.h"
+#include "wine/unixlib.h"
+#include "unixlib.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(winscard);
 
-static HANDLE g_startedEvent = NULL;
+#define UNIX_CALL( func, params ) WINE_UNIX_CALL( unix_ ## func, params )
+
+static HANDLE g_startedEvent;
 
 const SCARD_IO_REQUEST g_rgSCardT0Pci = { SCARD_PROTOCOL_T0, 8 };
 const SCARD_IO_REQUEST g_rgSCardT1Pci = { SCARD_PROTOCOL_T1, 8 };
 const SCARD_IO_REQUEST g_rgSCardRawPci = { SCARD_PROTOCOL_RAW, 8 };
 
+static inline char *utf16_to_utf8( const WCHAR *src )
+{
+    char *dst = NULL;
+    if (src)
+    {
+        int len = WideCharToMultiByte( CP_UTF8, 0, src, -1, NULL, 0, NULL, NULL );
+        if ((dst = malloc( len ))) WideCharToMultiByte( CP_UTF8, 0, src, -1, dst, len, NULL, NULL );
+    }
+    return dst;
+}
 
-BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+static inline WCHAR *ansi_to_utf16( const char *src )
 {
-    TRACE("%p,%lx,%p\n", hinstDLL, fdwReason, lpvReserved);
+    WCHAR *dst = NULL;
+    if (src)
+    {
+        int len = MultiByteToWideChar( CP_ACP, 0, src, -1, NULL, 0 );
+        if ((dst = malloc( len * sizeof(WCHAR) ))) MultiByteToWideChar( CP_ACP, 0, src, -1, dst, len );
+    }
+    return dst;
+}
 
-    switch (fdwReason)
+static inline char *ansi_to_utf8( const char *src )
+{
+    char *dst = NULL;
+    if (src)
     {
-        case DLL_PROCESS_ATTACH:
-            DisableThreadLibraryCalls(hinstDLL);
-            /* FIXME: for now, we act as if the pcsc daemon is always started */
-            g_startedEvent = CreateEventA(NULL,TRUE,TRUE,NULL);
-            break;
-        case DLL_PROCESS_DETACH:
-            if (lpvReserved) break;
-            CloseHandle(g_startedEvent);
-            break;
+        WCHAR *tmp;
+        if ((tmp = ansi_to_utf16( src ))) dst = utf16_to_utf8( tmp );
+        free( tmp );
     }
+    return dst;
+}
 
-    return TRUE;
+static inline WCHAR *utf8_to_utf16( const char *src )
+{
+    WCHAR *dst = NULL;
+    if (src)
+    {
+        int len = MultiByteToWideChar( CP_UTF8, 0, src, -1, NULL, 0 );
+        if ((dst = malloc( len * sizeof(WCHAR) ))) MultiByteToWideChar( CP_UTF8, 0, src, -1, dst, len );
+    }
+    return dst;
+}
+
+static inline char *utf16_to_ansi( const WCHAR *src )
+{
+    char *dst = NULL;
+    if (src)
+    {
+        int len = WideCharToMultiByte( CP_ACP, WC_NO_BEST_FIT_CHARS, src, -1, NULL, 0, NULL, NULL );
+        if (*src && !len)
+        {
+            FIXME( "can't convert %s to ANSI codepage\n", debugstr_w(src) );
+            return NULL;
+        }
+        if ((dst = malloc( len ))) WideCharToMultiByte( CP_ACP, WC_NO_BEST_FIT_CHARS, src, -1, dst, len, NULL, NULL );
+    }
+    return dst;
+}
+
+static inline char *utf8_to_ansi( const char *src )
+{
+    char *dst = NULL;
+    if (src)
+    {
+        WCHAR *tmp;
+        if ((tmp = utf8_to_utf16( src ))) dst = utf16_to_ansi( tmp );
+        free( tmp );
+    }
+    return dst;
 }
 
 HANDLE WINAPI SCardAccessStartedEvent(void)
 {
+    FIXME( "stub\n" );
     return g_startedEvent;
 }
 
-LONG WINAPI SCardAddReaderToGroupA(SCARDCONTEXT context, LPCSTR reader, LPCSTR group)
+LONG WINAPI SCardAddReaderToGroupA( SCARDCONTEXT context, const char *reader, const char *group )
+{
+    WCHAR *readerW = NULL, *groupW = NULL;
+    LONG ret;
+
+    TRACE( "%Ix, %s, %s\n", context, debugstr_a(reader), debugstr_a(group) );
+
+    if (reader && !(readerW = ansi_to_utf16( reader ))) return SCARD_E_NO_MEMORY;
+    if (group && !(groupW = ansi_to_utf16( group )))
+    {
+        free( readerW );
+        return SCARD_E_NO_MEMORY;
+    }
+    ret = SCardAddReaderToGroupW( context, readerW, groupW );
+    free( readerW );
+    free( groupW );
+    return ret;
+}
+
+LONG WINAPI SCardAddReaderToGroupW( SCARDCONTEXT context, const WCHAR *reader, const WCHAR *group )
+{
+    FIXME( "%Ix, %s, %s\n", context, debugstr_w(reader), debugstr_w(group) );
+    return SCARD_S_SUCCESS;
+}
+
+#define CONTEXT_MAGIC (('C' << 24) | ('T' << 16) | ('X' << 8) | '0')
+#define CONNECT_MAGIC (('C' << 24) | ('O' << 16) | ('N' << 8) | '0')
+struct handle
+{
+    DWORD  magic;
+    UINT64 unix_handle;
+};
+
+LONG WINAPI SCardEstablishContext( DWORD scope, const void *reserved1, const void *reserved2, SCARDCONTEXT *context )
 {
-    LONG retval;
-    UNICODE_STRING readerW, groupW;
+    struct scard_establish_context_params params;
+    struct handle *handle;
+    LONG ret;
 
-    if(reader) RtlCreateUnicodeStringFromAsciiz(&readerW,reader);
-    else readerW.Buffer = NULL;
-    if(group) RtlCreateUnicodeStringFromAsciiz(&groupW,group);
-    else groupW.Buffer = NULL;
+    TRACE( "%#lx, %p, %p, %p\n", scope, reserved1, reserved2, context );
 
-    retval = SCardAddReaderToGroupW(context, readerW.Buffer, groupW.Buffer);
+    if (!context) return SCARD_E_INVALID_PARAMETER;
+    if (!(handle = malloc( sizeof(*handle) ))) return SCARD_E_NO_MEMORY;
+    handle->magic = CONTEXT_MAGIC;
 
-    RtlFreeUnicodeString(&readerW);
-    RtlFreeUnicodeString(&groupW);
+    params.scope = scope;
+    params.handle = &handle->unix_handle;
+    if (!(ret = UNIX_CALL( scard_establish_context, &params ))) *context = (SCARDCONTEXT)handle;
+    else free( handle );
 
-    return retval;
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
-LONG WINAPI SCardAddReaderToGroupW(SCARDCONTEXT context, LPCWSTR reader, LPCWSTR group)
+LONG WINAPI SCardIsValidContext( SCARDCONTEXT context )
 {
-    FIXME("%x %s %s\n", (unsigned int) context, debugstr_w(reader), debugstr_w(group));
-    return SCARD_S_SUCCESS;
+    struct handle *handle = (struct handle *)context;
+    struct scard_is_valid_context_params params;
+    LONG ret;
+
+    TRACE( "%Ix\n", context );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    ret = UNIX_CALL( scard_is_valid_context, &params );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
-LONG WINAPI SCardEstablishContext(DWORD dwScope, LPCVOID pvReserved1,
-    LPCVOID pvReserved2, LPSCARDCONTEXT phContext)
+LONG WINAPI SCardListCardsA( SCARDCONTEXT context, const BYTE *atr, const GUID *interfaces, DWORD interface_count,
+                             char *cards, DWORD *cards_len )
 {
-    FIXME("(%lx,%p,%p,%p) stub\n", dwScope, pvReserved1, pvReserved2, phContext);
+    FIXME( "%Ix, %p, %p, %lu, %p, %p stub\n", context, atr, interfaces, interface_count, cards, cards_len );
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
     return SCARD_F_INTERNAL_ERROR;
 }
 
-LONG WINAPI SCardIsValidContext(SCARDCONTEXT context)
+LONG WINAPI SCardReleaseContext( SCARDCONTEXT context )
 {
-    FIXME("(%Ix) stub\n", context);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return SCARD_F_INTERNAL_ERROR;
+    struct handle *handle = (struct handle *)context;
+    struct scard_release_context_params params;
+    LONG ret;
+
+    TRACE( "%Ix\n", context );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    ret = UNIX_CALL( scard_release_context, &params );
+    handle->magic = 0;
+    free( handle );
+
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
-LONG WINAPI SCardListCardsA(SCARDCONTEXT hContext, LPCBYTE pbAtr, LPCGUID rgguidInterfaces, DWORD cguidInterfaceCount, LPSTR mszCards, LPDWORD pcchCards)
+static LONG copy_multiszA( const char *src, char *dst, DWORD *dst_len )
 {
-    FIXME(": stub\n");
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return SCARD_F_INTERNAL_ERROR;
+    DWORD len, total_len = 0;
+    const char *ptr = src;
+
+    while (*ptr)
+    {
+        char *str;
+        if (!(str = utf8_to_ansi( ptr ))) return SCARD_E_NO_MEMORY;
+        len = strlen( str ) + 1;
+        if (dst && dst_len && *dst_len > total_len + len) strcpy( dst + total_len, str );
+        total_len += len;
+        ptr += strlen( ptr ) + 1;
+        free( str );
+    }
+
+    if (dst && dst_len && *dst_len > total_len + 1) dst[total_len] = 0;
+    if (dst_len) *dst_len = total_len + 1;
+    return SCARD_S_SUCCESS;
 }
 
-LONG WINAPI SCardReleaseContext(SCARDCONTEXT context)
+LONG WINAPI SCardStatusA( SCARDHANDLE connect, char *names, DWORD *names_len, DWORD *state, DWORD *protocol,
+                          BYTE *atr, DWORD *atr_len )
 {
-    FIXME("(%Ix) stub\n", context);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return SCARD_F_INTERNAL_ERROR;
+    struct handle *handle = (struct handle *)connect;
+    struct scard_status_params params;
+    UINT64 state64, protocol64, atr_len64, names_len_utf8 = 0;
+    LONG ret;
+
+    TRACE( "%Ix, %p, %p, %p, %p, %p, %p\n", connect, names, names_len, state, protocol, atr, atr_len );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+    if ((names_len && *names_len == SCARD_AUTOALLOCATE) || (atr_len && *atr_len == SCARD_AUTOALLOCATE))
+    {
+        FIXME( "SCARD_AUTOALLOCATE not supported\n" );
+        return SCARD_F_INTERNAL_ERROR;
+    }
+
+    params.handle = handle->unix_handle;
+    params.names = NULL;
+    params.names_len = &names_len_utf8;
+    params.state = &state64;
+    params.protocol = &protocol64;
+    params.atr = NULL;
+    if (!atr_len) params.atr_len = NULL;
+    else
+    {
+        atr_len64 = *atr_len;
+        params.atr_len = &atr_len64;
+    }
+    if ((ret = UNIX_CALL( scard_status, &params ))) return ret;
+
+    if (!(params.names = malloc( names_len_utf8 ))) return SCARD_E_NO_MEMORY;
+    if (!(ret = UNIX_CALL( scard_status, &params )) && !(ret = copy_multiszA( params.names, names, names_len )))
+    {
+        if (state) *state = state64;
+        if (protocol) *protocol = protocol64;
+        if (atr_len) *atr_len = atr_len64;
+    }
+
+    free( params.names );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
-LONG WINAPI SCardStatusA(SCARDHANDLE context, LPSTR szReaderName, LPDWORD pcchReaderLen, LPDWORD pdwState, LPDWORD pdwProtocol, LPBYTE pbAtr, LPDWORD pcbAtrLen)
+static LONG copy_multiszW( const char *src, WCHAR *dst, DWORD *dst_len )
 {
-    FIXME("(%Ix) stub\n", context);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return SCARD_F_INTERNAL_ERROR;
+    DWORD len, total_len = 0;
+    const char *ptr = src;
+
+    while (*ptr)
+    {
+        WCHAR *str;
+        if (!(str = utf8_to_utf16( ptr ))) return SCARD_E_NO_MEMORY;
+        len = wcslen( str ) + 1;
+        if (dst && dst_len && *dst_len > total_len + len) wcscpy( dst + total_len, str );
+        total_len += len;
+        ptr += strlen( ptr ) + 1;
+        free( str );
+    }
+
+    if (dst && dst_len && *dst_len > total_len + 1) dst[total_len] = 0;
+    if (dst_len) *dst_len = total_len + 1;
+    return SCARD_S_SUCCESS;
 }
 
-LONG WINAPI SCardStatusW(SCARDHANDLE context, LPWSTR szReaderName, LPDWORD pcchReaderLen, LPDWORD pdwState,LPDWORD pdwProtocol,LPBYTE pbAtr,LPDWORD pcbArtLen)
+LONG WINAPI SCardStatusW( SCARDHANDLE connect, WCHAR *names, DWORD *names_len, DWORD *state, DWORD *protocol,
+                          BYTE *atr, DWORD *atr_len )
 {
-    FIXME("(%Ix) stub\n", context);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return SCARD_F_INTERNAL_ERROR;
+    struct handle *handle = (struct handle *)connect;
+    struct scard_status_params params;
+    UINT64 state64, protocol64, atr_len64, names_len_utf8 = 0;
+    LONG ret;
+
+    TRACE( "%Ix, %p, %p, %p, %p, %p, %p\n", connect, names, names_len, state, protocol, atr, atr_len );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+    if ((names_len && *names_len == SCARD_AUTOALLOCATE) || (atr_len && *atr_len == SCARD_AUTOALLOCATE))
+    {
+        FIXME( "SCARD_AUTOALLOCATE not supported\n" );
+        return SCARD_F_INTERNAL_ERROR;
+    }
+
+    params.handle = handle->unix_handle;
+    params.names = NULL;
+    params.names_len = &names_len_utf8;
+    params.state = &state64;
+    params.protocol = &protocol64;
+    params.atr = atr;
+    if (!atr_len) params.atr_len = NULL;
+    else
+    {
+        atr_len64 = *atr_len;
+        params.atr_len = &atr_len64;
+    }
+    if ((ret = UNIX_CALL( scard_status, &params ))) return ret;
+
+    if (!(params.names = malloc( names_len_utf8 ))) return SCARD_E_NO_MEMORY;
+    if (!(ret = UNIX_CALL( scard_status, &params )) && !(ret = copy_multiszW( params.names, names, names_len )))
+    {
+        if (state) *state = state64;
+        if (protocol) *protocol = protocol64;
+        if (atr_len) *atr_len = atr_len64;
+    }
+
+    free( params.names );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
 void WINAPI SCardReleaseStartedEvent(void)
 {
-    FIXME("stub\n");
+    FIXME( "stub\n" );
 }
 
-LONG WINAPI SCardListReadersA(SCARDCONTEXT context, const CHAR *groups, CHAR *readers, DWORD *buflen)
+LONG WINAPI SCardListReadersA( SCARDCONTEXT context, const char *groups, char *readers, DWORD *readers_len )
 {
-    FIXME("(%Ix, %s, %p, %p) stub\n", context, debugstr_a(groups), readers, buflen);
-    return SCARD_E_NO_READERS_AVAILABLE;
+    struct handle *handle = (struct handle *)context;
+    struct scard_list_readers_params params;
+    UINT64 readers_len_utf8;
+    LONG ret;
+
+    TRACE( "%Ix, %s, %p, %p\n", context, debugstr_a(groups), readers, readers_len );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!readers_len) return SCARD_E_INVALID_PARAMETER;
+    if (*readers_len == SCARD_AUTOALLOCATE)
+    {
+        FIXME( "SCARD_AUTOALLOCATE not supported\n" );
+        return SCARD_F_INTERNAL_ERROR;
+    }
+
+    params.handle = handle->unix_handle;
+    if (!groups) params.groups = NULL;
+    else if (!(params.groups = ansi_to_utf8( groups ))) return SCARD_E_NO_MEMORY;
+    params.readers = NULL;
+    params.readers_len = &readers_len_utf8;
+    if ((ret = UNIX_CALL( scard_list_readers, &params ))) goto done;
+
+    if (!(params.readers = malloc( readers_len_utf8 )))
+    {
+        free( (void *)params.groups );
+        return SCARD_E_NO_MEMORY;
+    }
+    if (!(ret = UNIX_CALL( scard_list_readers, &params )))
+    {
+        ret = copy_multiszA( params.readers, readers, readers_len );
+    }
+
+done:
+    free( (void *)params.groups );
+    free( params.readers );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
-LONG WINAPI SCardListReadersW(SCARDCONTEXT context, const WCHAR *groups, WCHAR *readers, DWORD *buflen)
+LONG WINAPI SCardListReadersW( SCARDCONTEXT context, const WCHAR *groups, WCHAR *readers, DWORD *readers_len )
 {
-    FIXME("(%Ix, %s, %p, %p) stub\n", context, debugstr_w(groups), readers, buflen);
-    return SCARD_E_NO_READERS_AVAILABLE;
+    struct handle *handle = (struct handle *)context;
+    struct scard_list_readers_params params;
+    UINT64 readers_len_utf8;
+    LONG ret;
+
+    TRACE( "%Ix, %s, %p, %p\n", context, debugstr_w(groups), readers, readers_len );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!readers_len) return SCARD_E_INVALID_PARAMETER;
+    if (*readers_len == SCARD_AUTOALLOCATE)
+    {
+        FIXME( "SCARD_AUTOALLOCATE not supported\n" );
+        return SCARD_F_INTERNAL_ERROR;
+    }
+
+    params.handle = handle->unix_handle;
+    if (!groups) params.groups = NULL;
+    else if (!(params.groups = utf16_to_utf8( groups ))) return SCARD_E_NO_MEMORY;
+    params.readers = NULL;
+    params.readers_len = &readers_len_utf8;
+    if ((ret = UNIX_CALL( scard_list_readers, &params ))) goto done;
+
+    params.handle = handle->unix_handle;
+    if (!(params.readers = malloc( readers_len_utf8 )))
+    {
+        free( (void *)params.groups );
+        return SCARD_E_NO_MEMORY;
+    }
+    if (!(ret = UNIX_CALL( scard_list_readers, &params )))
+    {
+        ret = copy_multiszW( params.readers, readers, readers_len );
+    }
+
+done:
+    free( (void *)params.groups );
+    free( params.readers );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
 }
 
-LONG WINAPI SCardCancel(SCARDCONTEXT context)
+LONG WINAPI SCardCancel( SCARDCONTEXT context )
 {
-    FIXME("(%Ix) stub\n", context);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return SCARD_F_INTERNAL_ERROR;
+    struct handle *handle = (struct handle *)context;
+    struct scard_cancel_params params;
+    LONG ret;
+
+    TRACE( "%Ix\n", context );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    ret = UNIX_CALL( scard_cancel, &params );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardListReaderGroupsA( SCARDCONTEXT context, char *groups, DWORD *groups_len )
+{
+    struct handle *handle = (struct handle *)context;
+    struct scard_list_reader_groups_params params;
+    UINT64 groups_len_utf8;
+    LONG ret;
+
+    TRACE( "%Ix, %p, %p\n", context, groups, groups_len );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!groups_len) return SCARD_E_INVALID_PARAMETER;
+    if (*groups_len == SCARD_AUTOALLOCATE)
+    {
+        FIXME( "SCARD_AUTOALLOCATE not supported\n" );
+        return SCARD_F_INTERNAL_ERROR;
+    }
+
+    params.handle = handle->unix_handle;
+    params.groups = NULL;
+    params.groups_len = &groups_len_utf8;
+    if ((ret = UNIX_CALL( scard_list_reader_groups, &params ))) goto done;
+
+    params.handle = handle->unix_handle;
+    if (!(params.groups = malloc( groups_len_utf8 ))) return SCARD_E_NO_MEMORY;
+    if (!(ret = UNIX_CALL( scard_list_reader_groups, &params )))
+    {
+        ret = copy_multiszA( params.groups, groups, groups_len );
+    }
+
+done:
+    free( params.groups );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardListReaderGroupsW( SCARDCONTEXT context, WCHAR *groups, DWORD *groups_len )
+{
+    struct handle *handle = (struct handle *)context;
+    struct scard_list_reader_groups_params params;
+    UINT64 groups_len_utf8;
+    LONG ret;
+
+    TRACE( "%Ix, %p, %p\n", context, groups, groups_len );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!groups_len) return SCARD_E_INVALID_PARAMETER;
+    if (*groups_len == SCARD_AUTOALLOCATE)
+    {
+        FIXME( "SCARD_AUTOALLOCATE not supported\n" );
+        return SCARD_F_INTERNAL_ERROR;
+    }
+
+    params.handle = handle->unix_handle;
+    params.groups = NULL;
+    params.groups_len = &groups_len_utf8;
+    if ((ret = UNIX_CALL( scard_list_reader_groups, &params ))) goto done;
+
+    if (!(params.groups = malloc( groups_len_utf8 ))) return SCARD_E_NO_MEMORY;
+    if (!(ret = UNIX_CALL( scard_list_reader_groups, &params )))
+    {
+        ret = copy_multiszW( params.groups, groups, groups_len );
+    }
+
+done:
+    TRACE( "returning %#lx\n", ret );
+    free( params.groups );
+    return ret;
+}
+
+static LONG map_states_inA( const SCARD_READERSTATEA *src, struct reader_state *dst, DWORD count )
+{
+    DWORD i;
+    for (i = 0; i < count; i++)
+    {
+        if (src[i].szReader && !(dst[i].reader = (UINT64)(ULONG_PTR)ansi_to_utf8( src[i].szReader )))
+            return SCARD_E_NO_MEMORY;
+        dst[i].current_state = src[i].dwCurrentState;
+        dst[i].event_state = src[i].dwEventState;
+        dst[i].atr_size = src[i].cbAtr;
+        memcpy( dst[i].atr, src[i].rgbAtr, src[i].cbAtr );
+    }
+    return SCARD_S_SUCCESS;
+}
+
+static void map_states_out( const struct reader_state *src, SCARD_READERSTATEA *dst, DWORD count )
+{
+    DWORD i;
+    for (i = 0; i < count; i++)
+    {
+        dst[i].dwCurrentState = src[i].current_state;
+        dst[i].dwEventState = src[i].event_state;
+        dst[i].cbAtr = src[i].atr_size;
+        memcpy( dst[i].rgbAtr, src[i].atr, src[i].atr_size );
+    }
+}
+
+static void free_states( struct reader_state *states, DWORD count )
+{
+    DWORD i;
+    for (i = 0; i < count; i++) free( (void *)(ULONG_PTR)states[i].reader );
+    free( states );
+}
+
+LONG WINAPI SCardGetStatusChangeA( SCARDCONTEXT context, DWORD timeout, SCARD_READERSTATEA *states, DWORD count )
+{
+    struct handle *handle = (struct handle *)context;
+    struct scard_get_status_change_params params;
+    struct reader_state *states_utf8 = NULL;
+    LONG ret;
+
+    TRACE( "%Ix, %lu, %p, %lu\n", context, timeout, states, count );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    if (!(states_utf8 = calloc( count, sizeof(*states_utf8) ))) return SCARD_E_NO_MEMORY;
+    if ((ret = map_states_inA( states, states_utf8, count )))
+    {
+        free_states( states_utf8, count );
+        return ret;
+    }
+
+    params.handle = handle->unix_handle;
+    params.timeout = timeout;
+    params.states = states_utf8;
+    params.count = count;
+    if (!(ret = UNIX_CALL( scard_get_status_change, &params )) && states)
+    {
+        map_states_out( states_utf8, states, count );
+    }
+
+    free_states( states_utf8, count );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+static LONG map_states_inW( SCARD_READERSTATEW *src, struct reader_state *dst, DWORD count )
+{
+    DWORD i;
+    for (i = 0; i < count; i++)
+    {
+        if (src[i].szReader && !(dst[i].reader = (UINT64)(ULONG_PTR)utf16_to_utf8( src[i].szReader )))
+            return SCARD_E_NO_MEMORY;
+        dst[i].current_state = src[i].dwCurrentState;
+        dst[i].event_state = src[i].dwEventState;
+        dst[i].atr_size = src[i].cbAtr;
+        memcpy( dst[i].atr, src[i].rgbAtr, src[i].cbAtr );
+    }
+    return SCARD_S_SUCCESS;
+}
+
+LONG WINAPI SCardGetStatusChangeW( SCARDCONTEXT context, DWORD timeout, SCARD_READERSTATEW *states, DWORD count )
+{
+    struct handle *handle = (struct handle *)context;
+    struct scard_get_status_change_params params;
+    struct reader_state *states_utf8;
+    LONG ret;
+
+    TRACE( "%Ix, %lu, %p, %lu\n", context, timeout, states, count );
+
+    if (!handle || handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    if (!(states_utf8 = calloc( count, sizeof(*states_utf8) ))) return SCARD_E_NO_MEMORY;
+    if ((ret = map_states_inW( states, states_utf8, count )))
+    {
+        free_states( states_utf8, count );
+        return ret;
+    }
+
+    params.handle = handle->unix_handle;
+    params.timeout = timeout;
+    params.states = states_utf8;
+    params.count = count;
+    if (!(ret = UNIX_CALL( scard_get_status_change, &params )))
+    {
+        map_states_out( states_utf8, (SCARD_READERSTATEA *)states, count );
+    }
+
+    free_states( states_utf8, count );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardConnectA( SCARDCONTEXT context, const char *reader, DWORD share_mode, DWORD preferred_protocols,
+                           SCARDHANDLE *connect, DWORD *protocol )
+{
+    struct handle *context_handle = (struct handle *)context, *connect_handle;
+    struct scard_connect_params params;
+    char *reader_utf8;
+    UINT64 protocol64;
+    LONG ret;
+
+    TRACE( "%Ix, %s, %#lx, %#lx, %p, %p\n", context, debugstr_a(reader), share_mode, preferred_protocols, connect,
+           protocol );
+
+    if (!context_handle || context_handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!connect) return SCARD_E_INVALID_PARAMETER;
+
+    if (!(connect_handle = malloc( sizeof(*connect_handle) ))) return SCARD_E_NO_MEMORY;
+    connect_handle->magic = CONNECT_MAGIC;
+
+    if (!(reader_utf8 = ansi_to_utf8( reader )))
+    {
+        free( connect_handle );
+        return SCARD_E_NO_MEMORY;
+    }
+
+    params.context_handle = context_handle->unix_handle;
+    params.reader = reader_utf8;
+    params.share_mode = share_mode;
+    params.preferred_protocols = preferred_protocols;
+    params.connect_handle = &connect_handle->unix_handle;
+    params.protocol = &protocol64;
+    if ((ret = UNIX_CALL( scard_connect, &params ))) free( connect_handle );
+    else
+    {
+        *connect = (SCARDHANDLE)connect_handle;
+        if (protocol) *protocol = protocol64;
+    }
+
+    free( reader_utf8 );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardConnectW( SCARDCONTEXT context, const WCHAR *reader, DWORD share_mode, DWORD preferred_protocols,
+                           SCARDHANDLE *connect, DWORD *protocol )
+{
+    struct handle *context_handle = (struct handle *)context, *connect_handle;
+    struct scard_connect_params params;
+    char *reader_utf8;
+    UINT64 protocol64;
+    LONG ret;
+
+    TRACE( "%Ix, %s, %#lx, %#lx, %p, %p\n", context, debugstr_w(reader), share_mode, preferred_protocols, connect,
+           protocol );
+
+    if (!context_handle || context_handle->magic != CONTEXT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!connect) return SCARD_E_INVALID_PARAMETER;
+
+    if (!(connect_handle = malloc( sizeof(*connect_handle) ))) return SCARD_E_NO_MEMORY;
+    connect_handle->magic = CONNECT_MAGIC;
+
+    if (!(reader_utf8 = utf16_to_utf8( reader )))
+    {
+        free( connect_handle );
+        return SCARD_E_NO_MEMORY;
+    }
+
+    params.context_handle = context_handle->unix_handle;
+    params.reader = reader_utf8;
+    params.share_mode = share_mode;
+    params.preferred_protocols = preferred_protocols;
+    params.connect_handle = &connect_handle->unix_handle;
+    params.protocol = &protocol64;
+    if ((ret = UNIX_CALL( scard_connect, &params ))) free( connect_handle );
+    else
+    {
+        *connect = (SCARDHANDLE)connect_handle;
+        if (protocol) *protocol = protocol64;
+    }
+
+    free( reader_utf8 );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardReconnect( SCARDHANDLE connect, DWORD share_mode, DWORD preferred_protocols, DWORD initalization,
+                            DWORD *protocol )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_reconnect_params params;
+    UINT64 protocol64;
+    LONG ret;
+
+    TRACE( "%Ix, %#lx, %#lx, %#lx, %p\n", connect, share_mode, preferred_protocols, initalization, protocol );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    params.share_mode = share_mode;
+    params.preferred_protocols = preferred_protocols;
+    params.initialization = initalization;
+    params.protocol = &protocol64;
+    if (!(ret = UNIX_CALL( scard_reconnect, &params )) && protocol) *protocol = protocol64;
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardDisconnect( SCARDHANDLE connect, DWORD disposition )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_disconnect_params params;
+    LONG ret;
+
+    TRACE( "%Ix, %#lx\n", connect, disposition );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    params.disposition = disposition;
+    if (!(ret = UNIX_CALL( scard_disconnect, &params )))
+    {
+        handle->magic = 0;
+        free( handle );
+    }
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardBeginTransaction( SCARDHANDLE connect )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_begin_transaction_params params;
+    LONG ret;
+
+    TRACE( "%Ix\n", connect );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    ret = UNIX_CALL( scard_begin_transaction, &params );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardEndTransaction( SCARDHANDLE connect, DWORD disposition )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_end_transaction_params params;
+    LONG ret;
+
+    TRACE( "%Ix, %#lx\n", connect, disposition );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    params.disposition = disposition;
+    ret = UNIX_CALL( scard_end_transaction, &params );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardTransmit( SCARDHANDLE connect, const SCARD_IO_REQUEST *send, const BYTE *send_buf,
+                           DWORD send_buflen, SCARD_IO_REQUEST *recv, BYTE *recv_buf, DWORD *recv_buflen )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_transmit_params params;
+    struct io_request send64 = { send->dwProtocol, send->cbPciLength }, recv64;
+    UINT64 recv_buflen64;
+    LONG ret;
+
+    TRACE( "%Ix, %p, %p, %lu, %p, %p, %p\n", connect, send, send_buf, send_buflen, recv, recv_buf, recv_buflen );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!recv_buflen) return SCARD_E_INVALID_PARAMETER;
+
+    params.handle = handle->unix_handle;
+    params.send = &send64;
+    params.send_buf = send_buf;
+    params.send_buflen = send_buflen;
+    params.recv = &recv64;
+    params.recv_buf = recv_buf;
+    recv_buflen64 = *recv_buflen;
+    params.recv_buflen = &recv_buflen64;
+    if (!(ret = UNIX_CALL( scard_transmit, &params )))
+    {
+        if (recv)
+        {
+            recv->dwProtocol = recv64.protocol;
+            recv->cbPciLength = recv64.pci_len;
+        }
+        *recv_buflen = recv_buflen64;
+    }
+
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardControl( SCARDHANDLE connect, DWORD code, const void *in_buf, DWORD in_buflen, void *out_buf,
+                          DWORD out_buflen, DWORD *ret_len )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_control_params params;
+    UINT64 ret_len64;
+    LONG ret;
+
+    TRACE( "%Ix, %#lx, %p, %lu, %p, %lu, %p\n", connect, code, in_buf, in_buflen, out_buf, out_buflen, ret_len );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!ret_len) return SCARD_E_INVALID_PARAMETER;
+
+    params.handle = handle->unix_handle;
+    params.code = code;
+    params.in_buf = in_buf;
+    params.in_buflen = in_buflen;
+    params.out_buf = out_buf;
+    params.out_buflen = out_buflen;
+    params.ret_len = &ret_len64;
+    if (!(ret = UNIX_CALL( scard_control, &params ))) *ret_len = ret_len64;
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardGetAttrib( SCARDHANDLE connect, DWORD id, BYTE *attr, DWORD *attr_len )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_get_attrib_params params;
+    UINT64 attr_len64;
+    LONG ret;
+
+    TRACE( "%Ix, %#lx, %p, %p\n", connect, id, attr, attr_len );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+    if (!attr_len) return SCARD_E_INVALID_PARAMETER;
+
+    params.handle = handle->unix_handle;
+    params.id = id;
+    params.attr = attr;
+    attr_len64 = *attr_len;
+    params.attr_len = &attr_len64;
+    if (!(ret = UNIX_CALL( scard_get_attrib, &params ))) *attr_len = attr_len64;
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardSetAttrib( SCARDHANDLE connect, DWORD id, const BYTE *attr, DWORD attr_len )
+{
+    struct handle *handle = (struct handle *)connect;
+    struct scard_set_attrib_params params;
+    LONG ret;
+
+    TRACE( "%Ix, %#lx, %p, %lu\n", connect, id, attr, attr_len );
+
+    if (!handle || handle->magic != CONNECT_MAGIC) return ERROR_INVALID_HANDLE;
+
+    params.handle = handle->unix_handle;
+    params.id = id;
+    params.attr = attr;
+    params.attr_len = attr_len;
+    ret = UNIX_CALL( scard_set_attrib, &params );
+    TRACE( "returning %#lx\n", ret );
+    return ret;
+}
+
+LONG WINAPI SCardFreeMemory( SCARDCONTEXT context, const void *mem )
+{
+    TRACE( "%Ix, %p\n", context, mem );
+
+    free( (void *)mem );
+    return SCARD_S_SUCCESS;
+}
+
+BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, void *reserved )
+{
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls( hinst );
+        if (__wine_init_unix_call()) ERR( "no pcsclite support, expect problems\n" );
+
+        /* FIXME: for now, we act as if the pcsc daemon is always started */
+        g_startedEvent = CreateEventW( NULL, TRUE, TRUE, NULL );
+        break;
+
+    case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        CloseHandle( g_startedEvent );
+        g_startedEvent = NULL;
+        break;
+    }
+
+    return TRUE;
 }
diff --git a/dlls/winscard/winscard.spec b/dlls/winscard/winscard.spec
index 037d3bef903..34bf1c67950 100644
--- a/dlls/winscard/winscard.spec
+++ b/dlls/winscard/winscard.spec
@@ -5,13 +5,13 @@
 @ stdcall SCardAccessStartedEvent()
 @ stdcall SCardAddReaderToGroupA(long str str)
 @ stdcall SCardAddReaderToGroupW(long wstr wstr)
-@ stub SCardBeginTransaction
+@ stdcall SCardBeginTransaction(long)
 @ stdcall SCardCancel(long)
-@ stub SCardConnectA
-@ stub SCardConnectW
-@ stub SCardControl
-@ stub SCardDisconnect
-@ stub SCardEndTransaction
+@ stdcall SCardConnectA(long str long long ptr ptr)
+@ stdcall SCardConnectW(long wstr long long ptr ptr)
+@ stdcall SCardControl(long long ptr long ptr long ptr)
+@ stdcall SCardDisconnect(long long)
+@ stdcall SCardEndTransaction(long long)
 @ stdcall SCardEstablishContext(long ptr ptr ptr)
 @ stub SCardForgetCardTypeA
 @ stub SCardForgetCardTypeW
@@ -19,14 +19,14 @@
 @ stub SCardForgetReaderGroupA
 @ stub SCardForgetReaderGroupW
 @ stub SCardForgetReaderW
-@ stub SCardFreeMemory
-@ stub SCardGetAttrib
+@ stdcall SCardFreeMemory(long ptr)
+@ stdcall SCardGetAttrib(long long ptr ptr)
 @ stub SCardGetCardTypeProviderNameA
 @ stub SCardGetCardTypeProviderNameW
 @ stub SCardGetProviderIdA
 @ stub SCardGetProviderIdW
-@ stub SCardGetStatusChangeA
-@ stub SCardGetStatusChangeW
+@ stdcall SCardGetStatusChangeA(long long ptr long)
+@ stdcall SCardGetStatusChangeW(long long ptr long)
 @ stub SCardIntroduceCardTypeA
 @ stub SCardIntroduceCardTypeW
 @ stub SCardIntroduceReaderA
@@ -38,26 +38,26 @@
 @ stub SCardListCardsW
 @ stub SCardListInterfacesA
 @ stub SCardListInterfacesW
-@ stub SCardListReaderGroupsA
-@ stub SCardListReaderGroupsW
+@ stdcall SCardListReaderGroupsA(long ptr ptr)
+@ stdcall SCardListReaderGroupsW(long ptr ptr)
 @ stdcall SCardListReadersA(long str ptr ptr)
 @ stdcall SCardListReadersW(long wstr ptr ptr)
 @ stub SCardLocateCardsA
 @ stub SCardLocateCardsByATRA
 @ stub SCardLocateCardsByATRW
 @ stub SCardLocateCardsW
-@ stub SCardReconnect
+@ stdcall SCardReconnect(long long long long ptr)
 @ stdcall SCardReleaseContext(long)
 @ stdcall SCardReleaseStartedEvent()
 @ stub SCardRemoveReaderFromGroupA
 @ stub SCardRemoveReaderFromGroupW
-@ stub SCardSetAttrib
+@ stdcall SCardSetAttrib(long long ptr long)
 @ stub SCardSetCardTypeProviderNameA
 @ stub SCardSetCardTypeProviderNameW
 @ stub SCardState
 @ stdcall SCardStatusA(long str ptr ptr ptr ptr ptr)
 @ stdcall SCardStatusW(long wstr ptr ptr ptr ptr ptr)
-@ stub SCardTransmit
+@ stdcall SCardTransmit(long ptr ptr long ptr ptr ptr)
 @ extern g_rgSCardRawPci
 @ extern g_rgSCardT0Pci
 @ extern g_rgSCardT1Pci
diff --git a/dlls/winspool.drv/info.c b/dlls/winspool.drv/info.c
index bc55d7f6d73..54ecb81d3be 100644
--- a/dlls/winspool.drv/info.c
+++ b/dlls/winspool.drv/info.c
@@ -635,14 +635,13 @@ static BOOL add_printer_driver( const WCHAR *name, const WCHAR *ppd_dir )
 {
     WCHAR *ppd = get_ppd_filename( ppd_dir, name );
     struct get_ppd_params ppd_params;
-    UNICODE_STRING nt_ppd;
+    UNICODE_STRING nt_ppd = { .Buffer = NULL };
     DRIVER_INFO_3W di3;
     unsigned int i;
     BOOL res = FALSE;
     WCHAR raw[] = L"RAW", driver_nt[] = L"wineps.drv";
 
     if (!ppd) return FALSE;
-    RtlInitUnicodeString( &nt_ppd, NULL );
     if (!RtlDosPathNameToNtPathName_U( ppd, &nt_ppd, NULL, NULL )) goto end;
 
     ppd_params.printer = name;
@@ -887,7 +886,7 @@ static LPWSTR get_servername_from_name(LPCWSTR name)
     if (name == NULL) return NULL;
     if ((name[0] != '\\') || (name[1] != '\\')) return NULL;
 
-    server = wcsdup(&name[2]);     /* skip over both backslash */
+    server = wcsdup(&name[2]);     /* skip over both backslashes */
     if (server == NULL) return NULL;
 
     /* strip '\' and the printername */
@@ -7491,9 +7490,6 @@ static BOOL is_port(const WCHAR *port_list, const WCHAR *output)
 {
     size_t len;
 
-    if (!output)
-        return FALSE;
-
     if (wcschr(output, ':'))
         return TRUE;
 
@@ -7533,7 +7529,7 @@ LPWSTR WINAPI StartDocDlgW( HANDLE hPrinter, DOCINFOW *doc )
 
     /* Check whether default port is FILE: */
     b = !doc->lpszOutput && (!pi5->pPortName || wcscmp( pi5->pPortName, L"FILE:" ));
-    if (!b)
+    if (!b && doc->lpszOutput && wcscmp( doc->lpszOutput, L"FILE:" ))
         b = is_port(pi5->pPortName, doc->lpszOutput);
     free(pi5);
     if (b)
diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index edf1f196353..f515698d095 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -218,13 +218,19 @@ WCHAR * CDECL ldap_first_attributeW( LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP
     if (ld && entry) retU = ldap_first_attribute( CTX(ld), MSG(entry), &berU );
     else return NULL;
 
-    if (retU && (ber = malloc( sizeof(*ber) )))
+    if (!retU)
+        return NULL;
+
+    if (!(ber = malloc( sizeof(*ber) )))
     {
-        ber->opaque = (char *)berU;
-        *ptr = ber;
-        ret = strUtoW( retU );
+        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        ldap_memfree( retU );
+        return NULL;
     }
 
+    ber->opaque = (char *)berU;
+    *ptr = ber;
+    ret = strUtoW( retU );
     ldap_memfree( retU );
     return ret;
 }
@@ -358,12 +364,18 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( LDAP *ld, WLDAP32_LDAPMessa
     if (entry->lm_next) return entry->lm_next;
 
     msgU = ldap_next_entry( CTX(ld), MSG(entry) );
-    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
+
+    if (!msgU)
+        return NULL;
+
+    if (!(msg = calloc( 1, sizeof(*msg) )))
     {
-        MSG(msg) = msgU;
-        entry->lm_next = msg;
+        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        return NULL;
     }
 
+    MSG(msg) = msgU;
+    entry->lm_next = msg;
     return msg;
 }
 
@@ -382,12 +394,18 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( LDAP *ld, WLDAP32_LDAPM
     if (entry->lm_next) return entry->lm_next;
 
     msgU = ldap_next_reference( CTX(ld), MSG(entry) );
-    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
+
+    if (!msgU)
+        return NULL;
+
+    if (!(msg = calloc( 1, sizeof(*msg) )))
     {
-        MSG(msg) = msgU;
-        entry->lm_next = msg;
+        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        return NULL;
     }
 
+    MSG(msg) = msgU;
+    entry->lm_next = msg;
     return msg;
 }
 
@@ -413,12 +431,18 @@ ULONG CDECL WLDAP32_ldap_result( LDAP *ld, ULONG msgid, ULONG all, struct l_time
 
         ret = ldap_result( CTX(ld), msgid, all, timeout ? &timeval : NULL, &msgU );
     }
-    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
+
+    if (!msgU)
+        return ret;
+
+    if (!(msg = calloc( 1, sizeof(*msg) )))
     {
-        MSG(msg) = msgU;
-        *res = msg;
+        free( msgU );
+        return WLDAP32_LDAP_NO_MEMORY;
     }
 
+    MSG(msg) = msgU;
+    *res = msg;
     return ret;
 }
 
diff --git a/dlls/wmvcore/async_reader.c b/dlls/wmvcore/async_reader.c
index a51018260b1..47de592c95c 100644
--- a/dlls/wmvcore/async_reader.c
+++ b/dlls/wmvcore/async_reader.c
@@ -544,7 +544,8 @@ static HRESULT WINAPI WMReader_QueryInterface(IWMReader *iface, REFIID iid, void
         *out = &reader->IReferenceClock_iface;
     else
     {
-        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        *out = NULL;
         return E_NOINTERFACE;
     }
 
diff --git a/dlls/wmvcore/tests/wmvcore.c b/dlls/wmvcore/tests/wmvcore.c
index ae6071159f6..f07abb8d4bb 100644
--- a/dlls/wmvcore/tests/wmvcore.c
+++ b/dlls/wmvcore/tests/wmvcore.c
@@ -134,7 +134,7 @@ static WCHAR *load_resource(const WCHAR *name)
 static HRESULT check_interface_(unsigned int line, void *iface, REFIID riid, BOOL supported)
 {
     HRESULT hr, expected_hr;
-    IUnknown *unknown = iface, *out;
+    IUnknown *unknown = iface, *out = (IUnknown *)0xbeef;
 
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
@@ -142,6 +142,8 @@ static HRESULT check_interface_(unsigned int line, void *iface, REFIID riid, BOO
     ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(out);
+    else if (!supported)
+        ok_(__FILE__, line)(out == NULL, "Expected out == NULL\n");
     return hr;
 }
 
diff --git a/dlls/wow64/file.c b/dlls/wow64/file.c
index ebe0e9b3a77..d32ef0b5455 100644
--- a/dlls/wow64/file.c
+++ b/dlls/wow64/file.c
@@ -59,12 +59,12 @@ static inline ULONG starts_with_path( const WCHAR *name, ULONG name_len, const W
 void init_file_redirects(void)
 {
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
+    UNICODE_STRING windows = RTL_CONSTANT_STRING( L"\\??\\C:\\windows" );
+    UNICODE_STRING system32 = RTL_CONSTANT_STRING( L"\\??\\C:\\windows\\system32" );
     IO_STATUS_BLOCK io;
     HANDLE handle;
 
-    InitializeObjectAttributes( &attr, &nameW, OBJ_CASE_INSENSITIVE, 0, NULL );
-    RtlInitUnicodeString( &nameW, L"\\??\\C:\\windows" );
+    InitializeObjectAttributes( &attr, &windows, OBJ_CASE_INSENSITIVE, 0, NULL );
     if (!NtOpenFile( &handle, SYNCHRONIZE | FILE_LIST_DIRECTORY, &attr, &io,
                      FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT |
                      FILE_OPEN_FOR_BACKUP_INTENT | FILE_DIRECTORY_FILE ))
@@ -72,7 +72,7 @@ void init_file_redirects(void)
         get_file_id( handle, &windir_id );
         NtClose( handle );
     }
-    RtlInitUnicodeString( &nameW, L"\\??\\C:\\windows\\system32" );
+    attr.ObjectName = &system32;
     if (!NtOpenFile( &handle, SYNCHRONIZE | FILE_LIST_DIRECTORY, &attr, &io,
                      FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT |
                      FILE_OPEN_FOR_BACKUP_INTENT | FILE_DIRECTORY_FILE ))
@@ -944,40 +944,6 @@ NTSTATUS WINAPI wow64_wine_nt_to_unix_file_name( UINT *args )
 }
 
 
-/**********************************************************************
- *           wow64_wine_server_fd_to_handle
- */
-NTSTATUS WINAPI wow64_wine_server_fd_to_handle( UINT *args )
-{
-    int fd = get_ulong( &args );
-    ACCESS_MASK access = get_ulong( &args );
-    ULONG attributes = get_ulong( &args );
-    ULONG *handle_ptr = get_ptr( &args );
-
-    HANDLE handle = 0;
-    NTSTATUS status;
-
-    *handle_ptr = 0;
-    status = wine_server_fd_to_handle( fd, access, attributes, &handle );
-    put_handle( handle_ptr, handle );
-    return status;
-}
-
-
-/**********************************************************************
- *           wow64_wine_server_handle_to_fd
- */
-NTSTATUS WINAPI wow64_wine_server_handle_to_fd( UINT *args )
-{
-    HANDLE handle = get_handle( &args );
-    ACCESS_MASK access = get_ulong( &args );
-    int *unix_fd = get_ptr( &args );
-    unsigned int *options = get_ptr( &args );
-
-    return wine_server_handle_to_fd( handle, access, unix_fd, options );
-}
-
-
 /**********************************************************************
  *           wow64_wine_unix_to_nt_file_name
  */
diff --git a/dlls/wow64/process.c b/dlls/wow64/process.c
index 97dbfdef761..2a14ef4cc3c 100644
--- a/dlls/wow64/process.c
+++ b/dlls/wow64/process.c
@@ -34,19 +34,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(wow);
 
 
-static SIZE_T get_machine_context_size( USHORT machine )
-{
-    switch (machine)
-    {
-    case IMAGE_FILE_MACHINE_I386:  return sizeof(I386_CONTEXT);
-    case IMAGE_FILE_MACHINE_ARMNT: return sizeof(ARM_CONTEXT);
-    case IMAGE_FILE_MACHINE_AMD64: return sizeof(AMD64_CONTEXT);
-    case IMAGE_FILE_MACHINE_ARM64: return sizeof(ARM64_NT_CONTEXT);
-    default: return 0;
-    }
-}
-
-
 static BOOL is_process_wow64( HANDLE handle )
 {
     ULONG_PTR info;
@@ -73,23 +60,6 @@ static BOOL is_process_id_wow64( const CLIENT_ID *id )
 }
 
 
-static EXCEPTION_RECORD *exception_record_32to64( const EXCEPTION_RECORD32 *rec32 )
-{
-    EXCEPTION_RECORD *rec;
-    unsigned int i;
-
-    rec = Wow64AllocateTemp( sizeof(*rec) );
-    rec->ExceptionCode = rec32->ExceptionCode;
-    rec->ExceptionFlags = rec32->ExceptionFlags;
-    rec->ExceptionRecord = rec32->ExceptionRecord ? exception_record_32to64( ULongToPtr(rec32->ExceptionRecord) ) : NULL;
-    rec->ExceptionAddress = ULongToPtr( rec32->ExceptionAddress );
-    rec->NumberParameters = rec32->NumberParameters;
-    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
-        rec->ExceptionInformation[i] = rec32->ExceptionInformation[i];
-    return rec;
-}
-
-
 static RTL_USER_PROCESS_PARAMETERS *process_params_32to64( RTL_USER_PROCESS_PARAMETERS **params,
                                                            RTL_USER_PROCESS_PARAMETERS32 *params32 )
 {
@@ -297,149 +267,6 @@ void put_vm_counters( VM_COUNTERS_EX32 *info32, const VM_COUNTERS_EX *info, ULON
 }
 
 
-static void call_user_exception_dispatcher( EXCEPTION_RECORD32 *rec, void *ctx32_ptr, void *ctx64_ptr )
-{
-    switch (current_machine)
-    {
-    case IMAGE_FILE_MACHINE_I386:
-        {
-            struct stack_layout
-            {
-                ULONG               rec_ptr;       /* first arg for KiUserExceptionDispatcher */
-                ULONG               context_ptr;   /* second arg for KiUserExceptionDispatcher */
-                EXCEPTION_RECORD32  rec;
-                I386_CONTEXT        context;
-            } *stack;
-            I386_CONTEXT *context, ctx = { CONTEXT_I386_ALL };
-            CONTEXT_EX *context_ex, *src_ex = NULL;
-            ULONG size, flags;
-
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
-
-            if (ctx32_ptr)
-            {
-                I386_CONTEXT *ctx32 = ctx32_ptr;
-
-                if ((ctx32->ContextFlags & CONTEXT_I386_XSTATE) == CONTEXT_I386_XSTATE)
-                    src_ex = (CONTEXT_EX *)(ctx32 + 1);
-            }
-            else if (native_machine == IMAGE_FILE_MACHINE_AMD64)
-            {
-                AMD64_CONTEXT *ctx64 = ctx64_ptr;
-
-                if ((ctx64->ContextFlags & CONTEXT_AMD64_FLOATING_POINT) == CONTEXT_AMD64_FLOATING_POINT)
-                    memcpy( ctx.ExtendedRegisters, &ctx64->FltSave, sizeof(ctx.ExtendedRegisters) );
-                if ((ctx64->ContextFlags & CONTEXT_AMD64_XSTATE) == CONTEXT_AMD64_XSTATE)
-                    src_ex = (CONTEXT_EX *)(ctx64 + 1);
-            }
-
-            flags = ctx.ContextFlags;
-            if (src_ex) flags |= CONTEXT_I386_XSTATE;
-            RtlGetExtendedContextLength( flags, &size );
-            size = ((size + 15) & ~15) + offsetof(struct stack_layout,context);
-
-            stack = (struct stack_layout *)(ULONG_PTR)(ctx.Esp - size);
-            stack->rec_ptr = PtrToUlong( &stack->rec );
-            stack->rec = *rec;
-            RtlInitializeExtendedContext( &stack->context, flags, &context_ex );
-            context = RtlLocateLegacyContext( context_ex, NULL );
-            *context = ctx;
-            context->ContextFlags = flags;
-            stack->context_ptr = PtrToUlong( context );
-
-            if (src_ex)
-            {
-                XSTATE *src_xs = (XSTATE *)((char *)src_ex + src_ex->XState.Offset);
-                XSTATE *dst_xs = (XSTATE *)((char *)context_ex + context_ex->XState.Offset);
-
-                dst_xs->Mask = src_xs->Mask & ~(ULONG64)3;
-                dst_xs->CompactionMask = src_xs->CompactionMask;
-                if ((dst_xs->Mask & 4) &&
-                    src_ex->XState.Length >= sizeof(XSTATE) &&
-                    context_ex->XState.Length >= sizeof(XSTATE))
-                    memcpy( &dst_xs->YmmContext, &src_xs->YmmContext, sizeof(dst_xs->YmmContext) );
-            }
-
-            ctx.Esp = PtrToUlong( stack );
-            ctx.Eip = pLdrSystemDllInitBlock->pKiUserExceptionDispatcher;
-            ctx.EFlags &= ~(0x100|0x400|0x40000);
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
-
-            TRACE( "exception %08lx dispatcher %08lx stack %08lx eip %08lx\n",
-                   rec->ExceptionCode, ctx.Eip, ctx.Esp, stack->context.Eip );
-        }
-        break;
-
-    case IMAGE_FILE_MACHINE_ARMNT:
-        {
-            struct stack_layout
-            {
-                ARM_CONTEXT        context;
-                EXCEPTION_RECORD32 rec;
-            } *stack;
-            ARM_CONTEXT ctx = { CONTEXT_ARM_ALL };
-
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
-            stack = (struct stack_layout *)(ULONG_PTR)(ctx.Sp & ~3) - 1;
-            stack->rec = *rec;
-            stack->context = ctx;
-
-            ctx.R0 = PtrToUlong( &stack->rec );     /* first arg for KiUserExceptionDispatcher */
-            ctx.R1 = PtrToUlong( &stack->context ); /* second arg for KiUserExceptionDispatcher */
-            ctx.Sp = PtrToUlong( stack );
-            ctx.Pc = pLdrSystemDllInitBlock->pKiUserExceptionDispatcher;
-            if (ctx.Pc & 1) ctx.Cpsr |= 0x20;
-            else ctx.Cpsr &= ~0x20;
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
-
-            TRACE( "exception %08lx dispatcher %08lx stack %08lx pc %08lx\n",
-                   rec->ExceptionCode, ctx.Pc, ctx.Sp, stack->context.Sp );
-        }
-        break;
-    }
-}
-
-
-/* based on RtlRaiseException: call NtRaiseException with context setup to return to caller */
-void WINAPI raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance ) DECLSPEC_HIDDEN;
-#ifdef __x86_64__
-__ASM_GLOBAL_FUNC( raise_exception,
-                   "sub $0x28,%rsp\n\t"
-                   __ASM_SEH(".seh_stackalloc 0x28\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 0x28\n\t")
-                   "movq %rcx,(%rsp)\n\t"
-                   "movq %rdx,%rcx\n\t"
-                   "call " __ASM_NAME("RtlCaptureContext") "\n\t"
-                   "leaq 0x30(%rsp),%rax\n\t"   /* orig stack pointer */
-                   "movq %rax,0x98(%rdx)\n\t"   /* context->Rsp */
-                   "movq (%rsp),%rcx\n\t"       /* original first parameter */
-                   "movq 0x28(%rsp),%rax\n\t"   /* return address */
-                   "movq %rax,0xf8(%rdx)\n\t"   /* context->Rip */
-                   "movq %rax,0x10(%rcx)\n\t"   /* rec->ExceptionAddress */
-                   "call " __ASM_NAME("NtRaiseException") )
-#elif defined(__aarch64__)
-__ASM_GLOBAL_FUNC( raise_exception,
-                   "stp x29, x30, [sp, #-32]!\n\t"
-                   __ASM_SEH(".seh_save_fplr_x 32\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   __ASM_CFI(".cfi_def_cfa x29, 32\n\t")
-                   __ASM_CFI(".cfi_offset x30, -24\n\t")
-                   __ASM_CFI(".cfi_offset x29, -32\n\t")
-                   "mov x29, sp\n\t"
-                   "stp x0, x1, [sp, #16]\n\t"
-                   "mov x0, x1\n\t"
-                   "bl " __ASM_NAME("RtlCaptureContext") "\n\t"
-                   "ldp x0, x1, [sp, #16]\n\t"    /* orig parameters */
-                   "ldp x4, x5, [sp]\n\t"         /* frame pointer, return address */
-                   "stp x4, x5, [x1, #0xf0]\n\t"  /* context->Fp, Lr */
-                   "add x4, sp, #32\n\t"          /* orig stack pointer */
-                   "stp x4, x5, [x1, #0x100]\n\t" /* context->Sp, Pc */
-                   "str x5, [x0, #0x10]\n\t"      /* rec->ExceptionAddress */
-                   "bl " __ASM_NAME("NtRaiseException") )
-#endif
-
-
 /**********************************************************************
  *           wow64_NtAlertResumeThread
  */
@@ -486,21 +313,6 @@ NTSTATUS WINAPI wow64_NtAssignProcessToJobObject( UINT *args )
 }
 
 
-/**********************************************************************
- *           wow64_NtContinue
- */
-NTSTATUS WINAPI wow64_NtContinue( UINT *args )
-{
-    void *context = get_ptr( &args );
-    BOOLEAN alertable = get_ulong( &args );
-
-    NtSetInformationThread( GetCurrentThread(), ThreadWow64Context,
-                            context, get_machine_context_size( current_machine ));
-    if (alertable) NtTestAlert();
-    return STATUS_SUCCESS;
-}
-
-
 /**********************************************************************
  *           wow64_NtCreateThread
  */
@@ -635,19 +447,6 @@ NTSTATUS WINAPI wow64_NtFlushProcessWriteBuffers( UINT *args )
 }
 
 
-/**********************************************************************
- *           wow64_NtGetContextThread
- */
-NTSTATUS WINAPI wow64_NtGetContextThread( UINT *args )
-{
-    HANDLE handle = get_handle( &args );
-    WOW64_CONTEXT *context = get_ptr( &args );
-
-    return NtQueryInformationThread( handle, ThreadWow64Context, context,
-                                     get_machine_context_size( current_machine ), NULL );
-}
-
-
 /**********************************************************************
  *           wow64_NtGetNextThread
  */
@@ -774,6 +573,7 @@ NTSTATUS WINAPI wow64_NtQueryInformationProcess( UINT *args )
     case ProcessDebugFlags:  /* ULONG */
     case ProcessExecuteFlags:  /* ULONG */
     case ProcessCookie:  /* ULONG */
+    case ProcessCycleTime:  /* PROCESS_CYCLE_TIME_INFORMATION */
         /* FIXME: check buffer alignment */
         return NtQueryInformationProcess( handle, class, ptr, len, retlen );
 
@@ -986,34 +786,6 @@ NTSTATUS WINAPI wow64_NtQueueApcThread( UINT *args )
 }
 
 
-/**********************************************************************
- *           wow64_NtRaiseException
- */
-NTSTATUS WINAPI wow64_NtRaiseException( UINT *args )
-{
-    EXCEPTION_RECORD32 *rec32 = get_ptr( &args );
-    void *context32 = get_ptr( &args );
-    BOOL first_chance = get_ulong( &args );
-
-    EXCEPTION_RECORD *rec = exception_record_32to64( rec32 );
-    CONTEXT context;
-
-    NtSetInformationThread( GetCurrentThread(), ThreadWow64Context,
-                            context32, get_machine_context_size( current_machine ));
-
-    __TRY
-    {
-        raise_exception( rec, &context, first_chance );
-    }
-    __EXCEPT_ALL
-    {
-        call_user_exception_dispatcher( rec32, context32, &context );
-    }
-    __ENDTRY
-    return STATUS_SUCCESS;
-}
-
-
 /**********************************************************************
  *           wow64_NtRemoveProcessDebug
  */
@@ -1049,19 +821,6 @@ NTSTATUS WINAPI wow64_NtResumeThread( UINT *args )
 }
 
 
-/**********************************************************************
- *           wow64_NtSetContextThread
- */
-NTSTATUS WINAPI wow64_NtSetContextThread( UINT *args )
-{
-    HANDLE handle = get_handle( &args );
-    WOW64_CONTEXT *context = get_ptr( &args );
-
-    return NtSetInformationThread( handle, ThreadWow64Context,
-                                   context, get_machine_context_size( current_machine ));
-}
-
-
 /**********************************************************************
  *           wow64_NtSetInformationProcess
  */
@@ -1273,24 +1032,3 @@ NTSTATUS WINAPI wow64_NtTerminateThread( UINT *args )
 
     return NtTerminateThread( handle, exit_code );
 }
-
-
-/**********************************************************************
- *           Wow64PassExceptionToGuest  (wow64.@)
- */
-void WINAPI Wow64PassExceptionToGuest( EXCEPTION_POINTERS *ptrs )
-{
-    EXCEPTION_RECORD *rec = ptrs->ExceptionRecord;
-    EXCEPTION_RECORD32 rec32;
-    ULONG i;
-
-    rec32.ExceptionCode    = rec->ExceptionCode;
-    rec32.ExceptionFlags   = rec->ExceptionFlags;
-    rec32.ExceptionRecord  = PtrToUlong( rec->ExceptionRecord );
-    rec32.ExceptionAddress = PtrToUlong( rec->ExceptionAddress );
-    rec32.NumberParameters = rec->NumberParameters;
-    for (i = 0; i < rec->NumberParameters; i++)
-        rec32.ExceptionInformation[i] = rec->ExceptionInformation[i];
-
-    call_user_exception_dispatcher( &rec32, NULL, ptrs->ContextRecord );
-}
diff --git a/dlls/wow64/struct32.h b/dlls/wow64/struct32.h
index 9511f80523f..76308a7f659 100644
--- a/dlls/wow64/struct32.h
+++ b/dlls/wow64/struct32.h
@@ -21,8 +21,6 @@
 #ifndef __WOW64_STRUCT32_H
 #define __WOW64_STRUCT32_H
 
-#include "wine/server.h"
-
 typedef struct
 {
     ULONG Length;
@@ -667,24 +665,6 @@ typedef struct
     ULONG NumberOfBytes;
 } MEMORY_RANGE_ENTRY32;
 
-struct __server_iovec32
-{
-    ULONG        ptr;
-    data_size_t  size;
-};
-
-struct __server_request_info32
-{
-    union
-    {
-        union generic_request req;
-        union generic_reply   reply;
-    } u;
-    unsigned int            data_count;
-    ULONG                   reply_data;
-    struct __server_iovec32 data[__SERVER_MAX_DATA];
-};
-
 typedef struct
 {
   ULONG LowestStartingAddress;
diff --git a/dlls/wow64/sync.c b/dlls/wow64/sync.c
index 578ef57201f..bf42f43b7e6 100644
--- a/dlls/wow64/sync.c
+++ b/dlls/wow64/sync.c
@@ -1617,3 +1617,57 @@ NTSTATUS WINAPI wow64_NtYieldExecution( UINT *args )
 {
     return NtYieldExecution();
 }
+
+
+/**********************************************************************
+ *           wow64_NtCreateTransaction
+ */
+NTSTATUS WINAPI wow64_NtCreateTransaction( UINT *args )
+{
+    ULONG *handle_ptr = get_ptr( &args );
+    ACCESS_MASK access = get_ulong( &args );
+    OBJECT_ATTRIBUTES32 *attr32 = get_ptr( &args );
+    GUID *guid = get_ptr( &args );
+    HANDLE tm = get_handle( &args );
+    ULONG options = get_ulong( &args );
+    ULONG isol_level = get_ulong( &args );
+    ULONG isol_flags = get_ulong( &args );
+    LARGE_INTEGER *timeout = get_ptr( &args );
+    UNICODE_STRING32 *desc32 = get_ptr( &args );
+
+    struct object_attr64 attr;
+    UNICODE_STRING desc;
+    HANDLE handle = 0;
+    NTSTATUS status;
+
+    *handle_ptr = 0;
+    status = NtCreateTransaction( &handle, access, objattr_32to64( &attr, attr32 ), guid, tm, options,
+            isol_level, isol_flags, timeout, unicode_str_32to64( &desc, desc32 ));
+    put_handle( handle_ptr, handle );
+
+    return status;
+}
+
+
+/**********************************************************************
+ *           wow64_NtCommitTransaction
+ */
+NTSTATUS WINAPI wow64_NtCommitTransaction( UINT *args )
+{
+    HANDLE handle = get_handle( &args );
+    BOOLEAN wait = get_ulong( &args );
+
+    return NtCommitTransaction( handle, wait );
+}
+
+
+/**********************************************************************
+ *           wow64_NtRollbackTransaction
+ */
+NTSTATUS WINAPI wow64_NtRollbackTransaction( UINT *args )
+{
+    HANDLE handle = get_handle( &args );
+    BOOLEAN wait = get_ulong( &args );
+
+    return NtRollbackTransaction( handle, wait );
+}
diff --git a/dlls/wow64/syscall.c b/dlls/wow64/syscall.c
index 5ba9cd14954..8caf06ec013 100644
--- a/dlls/wow64/syscall.c
+++ b/dlls/wow64/syscall.c
@@ -28,6 +28,7 @@
 #include "winternl.h"
 #include "wine/exception.h"
 #include "wine/unixlib.h"
+#include "wine/asm.h"
 #include "wow64_private.h"
 #include "wine/debug.h"
 
@@ -92,7 +93,10 @@ static HMODULE win32u_module;
 
 /* cpu backend dll functions */
 static void *   (WINAPI *pBTCpuGetBopCode)(void);
+static NTSTATUS (WINAPI *pBTCpuGetContext)(HANDLE,HANDLE,void *,void *);
 static void     (WINAPI *pBTCpuProcessInit)(void);
+static NTSTATUS (WINAPI *pBTCpuSetContext)(HANDLE,HANDLE,void *,void *);
+static void     (WINAPI *pBTCpuThreadInit)(void);
 static void     (WINAPI *pBTCpuSimulate)(void);
 static NTSTATUS (WINAPI *pBTCpuResetToConsistentState)( EXCEPTION_POINTERS * );
 static void *   (WINAPI *p__wine_get_unix_opcode)(void);
@@ -121,6 +125,169 @@ void __cdecl __wine_spec_unimplemented_stub( const char *module, const char *fun
 }
 
 
+static EXCEPTION_RECORD *exception_record_32to64( const EXCEPTION_RECORD32 *rec32 )
+{
+    EXCEPTION_RECORD *rec;
+    unsigned int i;
+
+    rec = Wow64AllocateTemp( sizeof(*rec) );
+    rec->ExceptionCode = rec32->ExceptionCode;
+    rec->ExceptionFlags = rec32->ExceptionFlags;
+    rec->ExceptionRecord = rec32->ExceptionRecord ? exception_record_32to64( ULongToPtr(rec32->ExceptionRecord) ) : NULL;
+    rec->ExceptionAddress = ULongToPtr( rec32->ExceptionAddress );
+    rec->NumberParameters = rec32->NumberParameters;
+    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
+        rec->ExceptionInformation[i] = rec32->ExceptionInformation[i];
+    return rec;
+}
+
+
+/**********************************************************************
+ *           call_user_exception_dispatcher
+ */
+static void call_user_exception_dispatcher( EXCEPTION_RECORD32 *rec, void *ctx32_ptr, void *ctx64_ptr )
+{
+    switch (current_machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:
+        {
+            struct stack_layout
+            {
+                ULONG               rec_ptr;       /* first arg for KiUserExceptionDispatcher */
+                ULONG               context_ptr;   /* second arg for KiUserExceptionDispatcher */
+                EXCEPTION_RECORD32  rec;
+                I386_CONTEXT        context;
+            } *stack;
+            I386_CONTEXT *context, ctx = { CONTEXT_I386_ALL };
+            CONTEXT_EX *context_ex, *src_ex = NULL;
+            ULONG size, flags;
+
+            pBTCpuGetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
+
+            if (ctx32_ptr)
+            {
+                I386_CONTEXT *ctx32 = ctx32_ptr;
+
+                if ((ctx32->ContextFlags & CONTEXT_I386_XSTATE) == CONTEXT_I386_XSTATE)
+                    src_ex = (CONTEXT_EX *)(ctx32 + 1);
+            }
+            else if (native_machine == IMAGE_FILE_MACHINE_AMD64)
+            {
+                AMD64_CONTEXT *ctx64 = ctx64_ptr;
+
+                if ((ctx64->ContextFlags & CONTEXT_AMD64_FLOATING_POINT) == CONTEXT_AMD64_FLOATING_POINT)
+                    memcpy( ctx.ExtendedRegisters, &ctx64->FltSave, sizeof(ctx.ExtendedRegisters) );
+                if ((ctx64->ContextFlags & CONTEXT_AMD64_XSTATE) == CONTEXT_AMD64_XSTATE)
+                    src_ex = (CONTEXT_EX *)(ctx64 + 1);
+            }
+
+            flags = ctx.ContextFlags;
+            if (src_ex) flags |= CONTEXT_I386_XSTATE;
+            RtlGetExtendedContextLength( flags, &size );
+            size = ((size + 15) & ~15) + offsetof(struct stack_layout,context);
+
+            stack = (struct stack_layout *)(ULONG_PTR)(ctx.Esp - size);
+            stack->rec_ptr = PtrToUlong( &stack->rec );
+            stack->rec = *rec;
+            RtlInitializeExtendedContext( &stack->context, flags, &context_ex );
+            context = RtlLocateLegacyContext( context_ex, NULL );
+            *context = ctx;
+            context->ContextFlags = flags;
+            stack->context_ptr = PtrToUlong( context );
+
+            if (src_ex)
+            {
+                XSTATE *src_xs = (XSTATE *)((char *)src_ex + src_ex->XState.Offset);
+                XSTATE *dst_xs = (XSTATE *)((char *)context_ex + context_ex->XState.Offset);
+
+                dst_xs->Mask = src_xs->Mask & ~(ULONG64)3;
+                dst_xs->CompactionMask = src_xs->CompactionMask;
+                if ((dst_xs->Mask & 4) &&
+                    src_ex->XState.Length >= sizeof(XSTATE) &&
+                    context_ex->XState.Length >= sizeof(XSTATE))
+                    memcpy( &dst_xs->YmmContext, &src_xs->YmmContext, sizeof(dst_xs->YmmContext) );
+            }
+
+            ctx.Esp = PtrToUlong( stack );
+            ctx.Eip = pLdrSystemDllInitBlock->pKiUserExceptionDispatcher;
+            ctx.EFlags &= ~(0x100|0x400|0x40000);
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
+
+            TRACE( "exception %08lx dispatcher %08lx stack %08lx eip %08lx\n",
+                   rec->ExceptionCode, ctx.Eip, ctx.Esp, stack->context.Eip );
+        }
+        break;
+
+    case IMAGE_FILE_MACHINE_ARMNT:
+        {
+            struct stack_layout
+            {
+                ARM_CONTEXT        context;
+                EXCEPTION_RECORD32 rec;
+            } *stack;
+            ARM_CONTEXT ctx = { CONTEXT_ARM_ALL };
+
+            pBTCpuGetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
+            stack = (struct stack_layout *)(ULONG_PTR)(ctx.Sp & ~3) - 1;
+            stack->rec = *rec;
+            stack->context = ctx;
+
+            ctx.R0 = PtrToUlong( &stack->rec );     /* first arg for KiUserExceptionDispatcher */
+            ctx.R1 = PtrToUlong( &stack->context ); /* second arg for KiUserExceptionDispatcher */
+            ctx.Sp = PtrToUlong( stack );
+            ctx.Pc = pLdrSystemDllInitBlock->pKiUserExceptionDispatcher;
+            if (ctx.Pc & 1) ctx.Cpsr |= 0x20;
+            else ctx.Cpsr &= ~0x20;
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
+
+            TRACE( "exception %08lx dispatcher %08lx stack %08lx pc %08lx\n",
+                   rec->ExceptionCode, ctx.Pc, ctx.Sp, stack->context.Sp );
+        }
+        break;
+    }
+}
+
+
+/* based on RtlRaiseException: call NtRaiseException with context setup to return to caller */
+void WINAPI raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance ) DECLSPEC_HIDDEN;
+#ifdef __x86_64__
+__ASM_GLOBAL_FUNC( raise_exception,
+                   "sub $0x28,%rsp\n\t"
+                   __ASM_SEH(".seh_stackalloc 0x28\n\t")
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   __ASM_CFI(".cfi_adjust_cfa_offset 0x28\n\t")
+                   "movq %rcx,(%rsp)\n\t"
+                   "movq %rdx,%rcx\n\t"
+                   "call " __ASM_NAME("RtlCaptureContext") "\n\t"
+                   "leaq 0x30(%rsp),%rax\n\t"   /* orig stack pointer */
+                   "movq %rax,0x98(%rdx)\n\t"   /* context->Rsp */
+                   "movq (%rsp),%rcx\n\t"       /* original first parameter */
+                   "movq 0x28(%rsp),%rax\n\t"   /* return address */
+                   "movq %rax,0xf8(%rdx)\n\t"   /* context->Rip */
+                   "movq %rax,0x10(%rcx)\n\t"   /* rec->ExceptionAddress */
+                   "call " __ASM_NAME("NtRaiseException") )
+#elif defined(__aarch64__)
+__ASM_GLOBAL_FUNC( raise_exception,
+                   "stp x29, x30, [sp, #-32]!\n\t"
+                   __ASM_SEH(".seh_save_fplr_x 32\n\t")
+                   __ASM_SEH(".seh_endprologue\n\t")
+                   __ASM_CFI(".cfi_def_cfa x29, 32\n\t")
+                   __ASM_CFI(".cfi_offset x30, -24\n\t")
+                   __ASM_CFI(".cfi_offset x29, -32\n\t")
+                   "mov x29, sp\n\t"
+                   "stp x0, x1, [sp, #16]\n\t"
+                   "mov x0, x1\n\t"
+                   "bl " __ASM_NAME("RtlCaptureContext") "\n\t"
+                   "ldp x0, x1, [sp, #16]\n\t"    /* orig parameters */
+                   "ldp x4, x5, [sp]\n\t"         /* frame pointer, return address */
+                   "stp x4, x5, [x1, #0xf0]\n\t"  /* context->Fp, Lr */
+                   "add x4, sp, #32\n\t"          /* orig stack pointer */
+                   "stp x4, x5, [x1, #0x100]\n\t" /* context->Sp, Pc */
+                   "str x5, [x0, #0x10]\n\t"      /* rec->ExceptionAddress */
+                   "bl " __ASM_NAME("NtRaiseException") )
+#endif
+
+
 /**********************************************************************
  *           wow64_NtAddAtom
  */
@@ -190,6 +357,20 @@ NTSTATUS WINAPI wow64_NtClose( UINT *args )
 }
 
 
+/**********************************************************************
+ *           wow64_NtContinue
+ */
+NTSTATUS WINAPI wow64_NtContinue( UINT *args )
+{
+    void *context = get_ptr( &args );
+    BOOLEAN alertable = get_ulong( &args );
+
+    pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, context );
+    if (alertable) NtTestAlert();
+    return STATUS_SUCCESS;
+}
+
+
 /**********************************************************************
  *           wow64_NtDeleteAtom
  */
@@ -214,6 +395,18 @@ NTSTATUS WINAPI wow64_NtFindAtom( UINT *args )
 }
 
 
+/**********************************************************************
+ *           wow64_NtGetContextThread
+ */
+NTSTATUS WINAPI wow64_NtGetContextThread( UINT *args )
+{
+    HANDLE handle = get_handle( &args );
+    WOW64_CONTEXT *context = get_ptr( &args );
+
+    return RtlWow64GetThreadContext( handle, context );
+}
+
+
 /**********************************************************************
  *           wow64_NtGetCurrentProcessorNumber
  */
@@ -274,94 +467,77 @@ NTSTATUS WINAPI wow64_NtQueryInstallUILanguage( UINT *args )
 
 
 /**********************************************************************
- *           wow64_NtSetDebugFilterState
+ *           wow64_NtRaiseException
  */
-NTSTATUS WINAPI wow64_NtSetDebugFilterState( UINT *args )
+NTSTATUS WINAPI wow64_NtRaiseException( UINT *args )
 {
-    ULONG component_id = get_ulong( &args );
-    ULONG level = get_ulong( &args );
-    BOOLEAN state = get_ulong( &args );
-
-    return NtSetDebugFilterState( component_id, level, state );
-}
+    EXCEPTION_RECORD32 *rec32 = get_ptr( &args );
+    void *context32 = get_ptr( &args );
+    BOOL first_chance = get_ulong( &args );
 
+    EXCEPTION_RECORD *rec = exception_record_32to64( rec32 );
+    CONTEXT context;
 
-/**********************************************************************
- *           wow64_NtSetDefaultLocale
- */
-NTSTATUS WINAPI wow64_NtSetDefaultLocale( UINT *args )
-{
-    BOOLEAN user = get_ulong( &args );
-    LCID lcid = get_ulong( &args );
+    pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, context32 );
 
-    return NtSetDefaultLocale( user, lcid );
+    __TRY
+    {
+        raise_exception( rec, &context, first_chance );
+    }
+    __EXCEPT_ALL
+    {
+        call_user_exception_dispatcher( rec32, context32, &context );
+    }
+    __ENDTRY
+    return STATUS_SUCCESS;
 }
 
 
 /**********************************************************************
- *           wow64_NtSetDefaultUILanguage
+ *           wow64_NtSetContextThread
  */
-NTSTATUS WINAPI wow64_NtSetDefaultUILanguage( UINT *args )
+NTSTATUS WINAPI wow64_NtSetContextThread( UINT *args )
 {
-    LANGID lang = get_ulong( &args );
+    HANDLE handle = get_handle( &args );
+    WOW64_CONTEXT *context = get_ptr( &args );
 
-    return NtSetDefaultUILanguage( lang );
+    return RtlWow64SetThreadContext( handle, context );
 }
 
 
 /**********************************************************************
- *           wow64___wine_dbg_write
+ *           wow64_NtSetDebugFilterState
  */
-NTSTATUS WINAPI wow64___wine_dbg_write( UINT *args )
+NTSTATUS WINAPI wow64_NtSetDebugFilterState( UINT *args )
 {
-    const char *str = get_ptr( &args );
-    ULONG len = get_ulong( &args );
+    ULONG component_id = get_ulong( &args );
+    ULONG level = get_ulong( &args );
+    BOOLEAN state = get_ulong( &args );
 
-    return __wine_dbg_write( str, len );
+    return NtSetDebugFilterState( component_id, level, state );
 }
 
 
 /**********************************************************************
- *           wow64___wine_unix_spawnvp
+ *           wow64_NtSetDefaultLocale
  */
-NTSTATUS WINAPI wow64___wine_unix_spawnvp( UINT *args )
+NTSTATUS WINAPI wow64_NtSetDefaultLocale( UINT *args )
 {
-    ULONG *argv32 = get_ptr( &args );
-    int wait = get_ulong( &args );
-
-    unsigned int i, count = 0;
-    char **argv;
+    BOOLEAN user = get_ulong( &args );
+    LCID lcid = get_ulong( &args );
 
-    while (argv32[count]) count++;
-    argv = Wow64AllocateTemp( (count + 1) * sizeof(*argv) );
-    for (i = 0; i < count; i++) argv[i] = ULongToPtr( argv32[i] );
-    argv[count] = NULL;
-    return __wine_unix_spawnvp( argv, wait );
+    return NtSetDefaultLocale( user, lcid );
 }
 
 
 /**********************************************************************
- *           wow64_wine_server_call
+ *           wow64_NtSetDefaultUILanguage
  */
-NTSTATUS WINAPI wow64_wine_server_call( UINT *args )
+NTSTATUS WINAPI wow64_NtSetDefaultUILanguage( UINT *args )
 {
-    struct __server_request_info32 *req32 = get_ptr( &args );
-
-    unsigned int i;
-    NTSTATUS status;
-    struct __server_request_info req;
+    LANGID lang = get_ulong( &args );
 
-    req.u.req = req32->u.req;
-    req.data_count = req32->data_count;
-    for (i = 0; i < req.data_count; i++)
-    {
-        req.data[i].ptr = ULongToPtr( req32->data[i].ptr );
-        req.data[i].size = req32->data[i].size;
-    }
-    req.reply_data = ULongToPtr( req32->reply_data );
-    status = wine_server_call( &req );
-    req32->u.reply = req.u.reply;
-    return status;
+    return NtSetDefaultUILanguage( lang );
 }
 
 
@@ -520,7 +696,7 @@ static const WCHAR *get_cpu_dll_name(void)
 static DWORD WINAPI process_init( RTL_RUN_ONCE *once, void *param, void **context )
 {
     HMODULE module;
-    UNICODE_STRING str;
+    UNICODE_STRING str = RTL_CONSTANT_STRING( L"ntdll.dll" );
     SYSTEM_BASIC_INFORMATION info;
 
     RtlWow64GetProcessMachines( GetCurrentProcess(), &current_machine, &native_machine );
@@ -532,14 +708,16 @@ static DWORD WINAPI process_init( RTL_RUN_ONCE *once, void *param, void **contex
 
 #define GET_PTR(name) p ## name = RtlFindExportedRoutineByName( module, #name )
 
-    RtlInitUnicodeString( &str, L"ntdll.dll" );
     LdrGetDllHandle( NULL, 0, &str, &module );
     GET_PTR( LdrSystemDllInitBlock );
 
     module = load_64bit_module( get_cpu_dll_name() );
     GET_PTR( BTCpuGetBopCode );
+    GET_PTR( BTCpuGetContext );
     GET_PTR( BTCpuProcessInit );
+    GET_PTR( BTCpuThreadInit );
     GET_PTR( BTCpuResetToConsistentState );
+    GET_PTR( BTCpuSetContext );
     GET_PTR( BTCpuSimulate );
     GET_PTR( __wine_get_unix_opcode );
 
@@ -566,17 +744,21 @@ static DWORD WINAPI process_init( RTL_RUN_ONCE *once, void *param, void **contex
  */
 static void thread_init(void)
 {
+    void *cpu_area_ctx;
+
+    RtlWow64GetCurrentCpuArea( NULL, &cpu_area_ctx, NULL );
+    if (pBTCpuThreadInit) pBTCpuThreadInit();
+
     /* update initial context to jump to 32-bit LdrInitializeThunk (cf. 32-bit call_init_thunk) */
     switch (current_machine)
     {
     case IMAGE_FILE_MACHINE_I386:
         {
-            I386_CONTEXT *ctx_ptr, ctx = { CONTEXT_I386_ALL };
+            I386_CONTEXT *ctx_ptr, *ctx = cpu_area_ctx;
             ULONG *stack;
 
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
-            ctx_ptr = (I386_CONTEXT *)ULongToPtr( ctx.Esp ) - 1;
-            *ctx_ptr = ctx;
+            ctx_ptr = (I386_CONTEXT *)ULongToPtr( ctx->Esp ) - 1;
+            *ctx_ptr = *ctx;
 
             stack = (ULONG *)ctx_ptr;
             *(--stack) = 0;
@@ -584,24 +766,23 @@ static void thread_init(void)
             *(--stack) = 0;
             *(--stack) = PtrToUlong( ctx_ptr );
             *(--stack) = 0xdeadbabe;
-            ctx.Esp = PtrToUlong( stack );
-            ctx.Eip = pLdrSystemDllInitBlock->pLdrInitializeThunk;
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
+            ctx->Esp = PtrToUlong( stack );
+            ctx->Eip = pLdrSystemDllInitBlock->pLdrInitializeThunk;
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, ctx );
         }
         break;
 
     case IMAGE_FILE_MACHINE_ARMNT:
         {
-            ARM_CONTEXT *ctx_ptr, ctx = { CONTEXT_ARM_ALL };
+            ARM_CONTEXT *ctx_ptr, *ctx = cpu_area_ctx;
 
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
-            ctx_ptr = (ARM_CONTEXT *)ULongToPtr( ctx.Sp & ~15 ) - 1;
-            *ctx_ptr = ctx;
+            ctx_ptr = (ARM_CONTEXT *)ULongToPtr( ctx->Sp & ~15 ) - 1;
+            *ctx_ptr = *ctx;
 
-            ctx.R0 = PtrToUlong( ctx_ptr );
-            ctx.Sp = PtrToUlong( ctx_ptr );
-            ctx.Pc = pLdrSystemDllInitBlock->pLdrInitializeThunk;
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
+            ctx->R0 = PtrToUlong( ctx_ptr );
+            ctx->Sp = PtrToUlong( ctx_ptr );
+            ctx->Pc = pLdrSystemDllInitBlock->pLdrInitializeThunk;
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, ctx );
         }
         break;
 
@@ -749,7 +930,7 @@ void WINAPI Wow64ApcRoutine( ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3, CON
             } *stack;
             I386_CONTEXT ctx = { CONTEXT_I386_FULL };
 
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
+            pBTCpuGetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
             stack = (struct apc_stack_layout *)ULongToPtr( ctx.Esp & ~3 ) - 1;
             stack->context_ptr = PtrToUlong( &stack->context );
             stack->func = arg1 >> 32;
@@ -760,7 +941,7 @@ void WINAPI Wow64ApcRoutine( ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3, CON
             stack->context.Eax = retval;
             ctx.Esp = PtrToUlong( stack );
             ctx.Eip = pLdrSystemDllInitBlock->pKiUserApcDispatcher;
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
         }
         break;
 
@@ -774,7 +955,7 @@ void WINAPI Wow64ApcRoutine( ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3, CON
             } *stack;
             ARM_CONTEXT ctx = { CONTEXT_ARM_FULL };
 
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
+            pBTCpuGetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
             stack = (struct apc_stack_layout *)ULongToPtr( ctx.Sp & ~15 ) - 1;
             stack->func = arg1 >> 32;
             stack->context = ctx;
@@ -785,7 +966,7 @@ void WINAPI Wow64ApcRoutine( ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3, CON
             ctx.R1 = arg1;
             ctx.R2 = arg2;
             ctx.R3 = arg3;
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
         }
         break;
     }
@@ -798,9 +979,11 @@ void WINAPI Wow64ApcRoutine( ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3, CON
 NTSTATUS WINAPI Wow64KiUserCallbackDispatcher( ULONG id, void *args, ULONG len,
                                                void **ret_ptr, ULONG *ret_len )
 {
+    WOW64_CPURESERVED *cpu = NtCurrentTeb()->TlsSlots[WOW64_TLS_CPURESERVED];
     TEB32 *teb32 = (TEB32 *)((char *)NtCurrentTeb() + NtCurrentTeb()->WowTebOffset);
     ULONG teb_frame = teb32->Tib.ExceptionList;
     struct user_callback_frame frame;
+    USHORT flags = cpu->Flags;
 
     frame.prev_frame = NtCurrentTeb()->TlsSlots[WOW64_TLS_USERCALLBACKDATA];
     frame.temp_list  = NtCurrentTeb()->TlsSlots[WOW64_TLS_TEMPLIST];
@@ -815,14 +998,14 @@ NTSTATUS WINAPI Wow64KiUserCallbackDispatcher( ULONG id, void *args, ULONG len,
     {
     case IMAGE_FILE_MACHINE_I386:
         {
-            I386_CONTEXT orig_ctx, *ctx;
+            I386_CONTEXT orig_ctx, ctx = { CONTEXT_I386_FULL };
             void *args_data;
             ULONG *stack;
 
-            RtlWow64GetCurrentCpuArea( NULL, (void **)&ctx, NULL );
-            orig_ctx = *ctx;
+            pBTCpuGetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
+            orig_ctx = ctx;
 
-            stack = args_data = ULongToPtr( (ctx->Esp - len) & ~15 );
+            stack = args_data = ULongToPtr( (ctx.Esp - len) & ~15 );
             memcpy( args_data, args, len );
             *(--stack) = 0;
             *(--stack) = len;
@@ -830,13 +1013,14 @@ NTSTATUS WINAPI Wow64KiUserCallbackDispatcher( ULONG id, void *args, ULONG len,
             *(--stack) = id;
             *(--stack) = 0xdeadbabe;
 
-            ctx->Esp = PtrToUlong( stack );
-            ctx->Eip = pLdrSystemDllInitBlock->pKiUserCallbackDispatcher;
+            ctx.Esp = PtrToUlong( stack );
+            ctx.Eip = pLdrSystemDllInitBlock->pKiUserCallbackDispatcher;
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
 
             if (!__wine_setjmpex( &frame.jmpbuf, NULL ))
                 cpu_simulate();
             else
-                *ctx = orig_ctx;
+                pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &orig_ctx );
         }
         break;
 
@@ -845,7 +1029,8 @@ NTSTATUS WINAPI Wow64KiUserCallbackDispatcher( ULONG id, void *args, ULONG len,
             ARM_CONTEXT orig_ctx, ctx = { CONTEXT_ARM_FULL };
             void *args_data;
 
-            NtQueryInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx), NULL );
+            pBTCpuGetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
+            orig_ctx = ctx;
 
             args_data = ULongToPtr( (ctx.Sp - len) & ~15 );
             memcpy( args_data, args, len );
@@ -855,13 +1040,12 @@ NTSTATUS WINAPI Wow64KiUserCallbackDispatcher( ULONG id, void *args, ULONG len,
             ctx.R2 = len;
             ctx.Sp = PtrToUlong( args_data );
             ctx.Pc = pLdrSystemDllInitBlock->pKiUserCallbackDispatcher;
-            NtSetInformationThread( GetCurrentThread(), ThreadWow64Context, &ctx, sizeof(ctx) );
+            pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &ctx );
 
             if (!__wine_setjmpex( &frame.jmpbuf, NULL ))
                 cpu_simulate();
             else
-                NtSetInformationThread( GetCurrentThread(), ThreadWow64Context,
-                                        &orig_ctx, sizeof(orig_ctx) );
+                pBTCpuSetContext( GetCurrentThread(), GetCurrentProcess(), NULL, &orig_ctx );
         }
         break;
     }
@@ -869,6 +1053,7 @@ NTSTATUS WINAPI Wow64KiUserCallbackDispatcher( ULONG id, void *args, ULONG len,
     teb32->Tib.ExceptionList = teb_frame;
     NtCurrentTeb()->TlsSlots[WOW64_TLS_USERCALLBACKDATA] = frame.prev_frame;
     NtCurrentTeb()->TlsSlots[WOW64_TLS_TEMPLIST] = frame.temp_list;
+    cpu->Flags = flags;
     return frame.status;
 }
 
@@ -895,3 +1080,24 @@ void WINAPI Wow64PrepareForException( EXCEPTION_RECORD *rec, CONTEXT *context )
 
     pBTCpuResetToConsistentState( &ptrs );
 }
+
+
+/**********************************************************************
+ *           Wow64PassExceptionToGuest  (wow64.@)
+ */
+void WINAPI Wow64PassExceptionToGuest( EXCEPTION_POINTERS *ptrs )
+{
+    EXCEPTION_RECORD *rec = ptrs->ExceptionRecord;
+    EXCEPTION_RECORD32 rec32;
+    ULONG i;
+
+    rec32.ExceptionCode    = rec->ExceptionCode;
+    rec32.ExceptionFlags   = rec->ExceptionFlags;
+    rec32.ExceptionRecord  = PtrToUlong( rec->ExceptionRecord );
+    rec32.ExceptionAddress = PtrToUlong( rec->ExceptionAddress );
+    rec32.NumberParameters = rec->NumberParameters;
+    for (i = 0; i < rec->NumberParameters; i++)
+        rec32.ExceptionInformation[i] = rec->ExceptionInformation[i];
+
+    call_user_exception_dispatcher( &rec32, NULL, ptrs->ContextRecord );
+}
diff --git a/dlls/wow64/syscall.h b/dlls/wow64/syscall.h
index d4216b8c04c..e91be71ebac 100644
--- a/dlls/wow64/syscall.h
+++ b/dlls/wow64/syscall.h
@@ -44,6 +44,7 @@
     SYSCALL_ENTRY( NtCancelTimer ) \
     SYSCALL_ENTRY( NtClearEvent ) \
     SYSCALL_ENTRY( NtClose ) \
+    SYSCALL_ENTRY( NtCommitTransaction ) \
     SYSCALL_ENTRY( NtCompareObjects ) \
     SYSCALL_ENTRY( NtCompleteConnectPort ) \
     SYSCALL_ENTRY( NtConnectPort ) \
@@ -69,6 +70,7 @@
     SYSCALL_ENTRY( NtCreateThread ) \
     SYSCALL_ENTRY( NtCreateThreadEx ) \
     SYSCALL_ENTRY( NtCreateTimer ) \
+    SYSCALL_ENTRY( NtCreateTransaction ) \
     SYSCALL_ENTRY( NtCreateUserProcess ) \
     SYSCALL_ENTRY( NtDebugActiveProcess ) \
     SYSCALL_ENTRY( NtDebugContinue ) \
@@ -197,6 +199,7 @@
     SYSCALL_ENTRY( NtRestoreKey ) \
     SYSCALL_ENTRY( NtResumeProcess ) \
     SYSCALL_ENTRY( NtResumeThread ) \
+    SYSCALL_ENTRY( NtRollbackTransaction ) \
     SYSCALL_ENTRY( NtSaveKey ) \
     SYSCALL_ENTRY( NtSecureConnectPort ) \
     SYSCALL_ENTRY( NtSetContextThread ) \
@@ -254,12 +257,7 @@
     SYSCALL_ENTRY( NtWriteFileGather ) \
     SYSCALL_ENTRY( NtWriteVirtualMemory ) \
     SYSCALL_ENTRY( NtYieldExecution ) \
-    SYSCALL_ENTRY( __wine_dbg_write ) \
-    SYSCALL_ENTRY( __wine_unix_spawnvp ) \
     SYSCALL_ENTRY( wine_nt_to_unix_file_name ) \
-    SYSCALL_ENTRY( wine_server_call ) \
-    SYSCALL_ENTRY( wine_server_fd_to_handle ) \
-    SYSCALL_ENTRY( wine_server_handle_to_fd ) \
     SYSCALL_ENTRY( wine_unix_to_nt_file_name )
 
 #endif /* __WOW64_SYSCALL_H */
diff --git a/dlls/wow64cpu/Makefile.in b/dlls/wow64cpu/Makefile.in
index 0bf3c35ab3b..a4a43fc85cd 100644
--- a/dlls/wow64cpu/Makefile.in
+++ b/dlls/wow64cpu/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = wow64cpu.dll
 IMPORTS   = wow64 ntdll winecrt0
 
-EXTRADLLFLAGS = -nodefaultlibs -Wl,--image-base,0x6f100000
+EXTRADLLFLAGS = -nodefaultlibs -Wl,--image-base,0x6f400000
 
 C_SRCS = cpu.c
diff --git a/dlls/wow64cpu/cpu.c b/dlls/wow64cpu/cpu.c
index 750ab68d071..835353d9af8 100644
--- a/dlls/wow64cpu/cpu.c
+++ b/dlls/wow64cpu/cpu.c
@@ -353,7 +353,7 @@ void * WINAPI __wine_get_unix_opcode(void)
  */
 NTSTATUS WINAPI BTCpuGetContext( HANDLE thread, HANDLE process, void *unknown, I386_CONTEXT *ctx )
 {
-    return NtQueryInformationThread( thread, ThreadWow64Context, ctx, sizeof(*ctx), NULL );
+    return RtlWow64GetThreadContext( thread, ctx );
 }
 
 
@@ -362,7 +362,7 @@ NTSTATUS WINAPI BTCpuGetContext( HANDLE thread, HANDLE process, void *unknown, I
  */
 NTSTATUS WINAPI BTCpuSetContext( HANDLE thread, HANDLE process, void *unknown, I386_CONTEXT *ctx )
 {
-    return NtSetInformationThread( thread, ThreadWow64Context, ctx, sizeof(*ctx) );
+    return RtlWow64SetThreadContext( thread, ctx );
 }
 
 
diff --git a/dlls/wow64win/syscall.h b/dlls/wow64win/syscall.h
index ecf79f69cce..4977013c595 100644
--- a/dlls/wow64win/syscall.h
+++ b/dlls/wow64win/syscall.h
@@ -131,6 +131,7 @@
     SYSCALL_ENTRY( NtUserDrawIconEx ) \
     SYSCALL_ENTRY( NtUserEmptyClipboard ) \
     SYSCALL_ENTRY( NtUserEnableMenuItem ) \
+    SYSCALL_ENTRY( NtUserEnableMouseInPointer ) \
     SYSCALL_ENTRY( NtUserEnableScrollBar ) \
     SYSCALL_ENTRY( NtUserEndDeferWindowPosEx ) \
     SYSCALL_ENTRY( NtUserEndMenu ) \
@@ -178,6 +179,7 @@
     SYSCALL_ENTRY( NtUserGetMouseMovePointsEx ) \
     SYSCALL_ENTRY( NtUserGetObjectInformation ) \
     SYSCALL_ENTRY( NtUserGetOpenClipboardWindow ) \
+    SYSCALL_ENTRY( NtUserGetPointerInfoList ) \
     SYSCALL_ENTRY( NtUserGetPriorityClipboardFormat ) \
     SYSCALL_ENTRY( NtUserGetProcessDpiAwarenessContext ) \
     SYSCALL_ENTRY( NtUserGetProcessWindowStation ) \
@@ -207,6 +209,7 @@
     SYSCALL_ENTRY( NtUserInvalidateRect ) \
     SYSCALL_ENTRY( NtUserInvalidateRgn ) \
     SYSCALL_ENTRY( NtUserIsClipboardFormatAvailable ) \
+    SYSCALL_ENTRY( NtUserIsMouseInPointerEnabled ) \
     SYSCALL_ENTRY( NtUserKillTimer ) \
     SYSCALL_ENTRY( NtUserLockWindowUpdate ) \
     SYSCALL_ENTRY( NtUserLogicalToPerMonitorDPIPhysicalPoint ) \
diff --git a/dlls/wow64win/user.c b/dlls/wow64win/user.c
index 4ce8c94c1af..2ce82907a88 100644
--- a/dlls/wow64win/user.c
+++ b/dlls/wow64win/user.c
@@ -1629,6 +1629,13 @@ NTSTATUS WINAPI wow64_NtUserEnableMenuItem( UINT *args )
     return NtUserEnableMenuItem( handle, id, flags );
 }
 
+NTSTATUS WINAPI wow64_NtUserEnableMouseInPointer( UINT *args )
+{
+    UINT enable = get_ulong( &args );
+
+    return NtUserEnableMouseInPointer( enable );
+}
+
 NTSTATUS WINAPI wow64_NtUserEnableScrollBar( UINT *args )
 {
     HWND hwnd = get_handle( &args );
@@ -2239,6 +2246,20 @@ NTSTATUS WINAPI wow64_NtUserGetOpenClipboardWindow( UINT *args )
     return HandleToUlong( NtUserGetOpenClipboardWindow() );
 }
 
+NTSTATUS WINAPI wow64_NtUserGetPointerInfoList( UINT *args )
+{
+    UINT id = get_ulong( &args );
+    UINT type = get_ulong( &args );
+    UINT unk0 = get_ulong( &args );
+    UINT unk1 = get_ulong( &args );
+    UINT size = get_ulong( &args );
+    void *entry_count = get_ptr( &args );
+    void *pointer_count = get_ptr( &args );
+    void *pointer_info = get_ptr( &args );
+
+    return NtUserGetPointerInfoList( id, type, unk0, unk1, size, entry_count, pointer_count, pointer_info );
+}
+
 NTSTATUS WINAPI wow64_NtUserGetPriorityClipboardFormat( UINT *args )
 {
     UINT *list = get_ptr( &args );
@@ -2724,6 +2745,11 @@ NTSTATUS WINAPI wow64_NtUserIsClipboardFormatAvailable( UINT *args )
     return NtUserIsClipboardFormatAvailable( format );
 }
 
+NTSTATUS WINAPI wow64_NtUserIsMouseInPointerEnabled( UINT *args )
+{
+    return NtUserIsMouseInPointerEnabled();
+}
+
 NTSTATUS WINAPI wow64_NtUserKillTimer( UINT *args )
 {
     HWND hwnd = get_handle( &args );
diff --git a/dlls/wpcap/tests/Makefile.in b/dlls/wpcap/tests/Makefile.in
new file mode 100644
index 00000000000..c2f8fce6da8
--- /dev/null
+++ b/dlls/wpcap/tests/Makefile.in
@@ -0,0 +1,4 @@
+TESTDLL  = wpcap.dll
+
+C_SRCS = \
+	wpcap.c
diff --git a/dlls/wpcap/tests/wpcap.c b/dlls/wpcap/tests/wpcap.c
new file mode 100644
index 00000000000..017d3b77a4e
--- /dev/null
+++ b/dlls/wpcap/tests/wpcap.c
@@ -0,0 +1,374 @@
+/*
+ * Unit test for wpcap functions
+ *
+ * Copyright 2022 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdio.h>
+#include <ntstatus.h>
+#define WIN32_NO_STATUS
+#include <windows.h>
+
+#include "wine/test.h"
+
+#define PCAP_MMAP_32BIT  2
+#define PCAP_ERRBUF_SIZE 256
+#define PCAP_ERROR_PERM_DENIED -8
+
+typedef struct pcap pcap_t;
+typedef struct pcap_if pcap_if_t;
+typedef struct pcap_dumper pcap_dumper_t;
+
+struct pcap_if
+{
+    struct pcap_if *next;
+    char *name;
+};
+
+struct pcap_stat
+{
+    unsigned int ps_recv;
+    unsigned int ps_drop;
+    unsigned int ps_ifdrop;
+    unsigned int ps_capt;
+    unsigned int ps_sent;
+    unsigned int ps_netdrop;
+};
+
+struct bpf_insn
+{
+    unsigned short code;
+    unsigned char jt;
+    unsigned char jf;
+    unsigned int k;
+};
+
+struct bpf_program
+{
+    unsigned int bf_len;
+    struct bpf_insn *bf_insns;
+};
+
+struct pcap_pkthdr
+{
+    struct
+    {
+        int tv_sec;
+        int tv_usec;
+    } ts;
+    unsigned int caplen;
+    unsigned int len;
+};
+
+static int (CDECL *ppcap_activate)( pcap_t * );
+static void (CDECL *ppcap_breakloop)( pcap_t * );
+static int (CDECL *ppcap_bufsize)( pcap_t * );
+static int (CDECL *ppcap_can_set_rfmon)( pcap_t * );
+static void (CDECL *ppcap_close)( pcap_t * );
+static int (CDECL *ppcap_compile)( pcap_t *, struct bpf_program *, const char *, int, unsigned int );
+static pcap_t * (CDECL *ppcap_create)( const char *, char * );
+static int (CDECL *ppcap_datalink)( pcap_t * );
+static int (CDECL *ppcap_datalink_name_to_val)( const char * );
+static const char * (CDECL *ppcap_datalink_val_to_description)( int );
+static const char * (CDECL *ppcap_datalink_val_to_name)( int );
+static int (CDECL *ppcap_dispatch)( pcap_t *, int,
+                                    void (CALLBACK *)(unsigned char *, const struct pcap_pkthdr *, const unsigned char *),
+                                    unsigned char * );
+static pcap_dumper_t * (CDECL *ppcap_dump_open)( pcap_t *, const char * );
+static void (CDECL *ppcap_dump)( unsigned char *, const struct pcap_pkthdr *, const unsigned char * );
+static void (CDECL *ppcap_dump_close)( pcap_dumper_t * );
+static int (CDECL *ppcap_findalldevs)( pcap_if_t **, char * );
+static void (CDECL *ppcap_freealldevs)( pcap_if_t * );
+static void (CDECL *ppcap_free_datalinks)( int * );
+static void (CDECL *ppcap_free_tstamp_types)( int * );
+static void (CDECL *ppcap_freecode)( struct bpf_program * );
+static void * (CDECL *ppcap_get_airpcap_handle)( pcap_t * );
+static int (CDECL *ppcap_get_tstamp_precision)( pcap_t * );
+static char * (CDECL *ppcap_geterr)( pcap_t * );
+static int (CDECL *ppcap_getnonblock)( pcap_t *, char * );
+static int (CDECL *ppcap_init)( unsigned int, char * );
+static const char * (CDECL *ppcap_lib_version)( void );
+static int (CDECL *ppcap_list_datalinks)( pcap_t *, int ** );
+static int (CDECL *ppcap_list_tstamp_types)( pcap_t *, int ** );
+static char * (CDECL *ppcap_lookupdev)( char * );
+static int (CDECL *ppcap_lookupnet)( const char *, unsigned int *, unsigned int *, char * );
+static int (CDECL *ppcap_loop)( pcap_t *, int,
+                                void (CALLBACK *)(unsigned char *, const struct pcap_pkthdr *, const unsigned char *),
+                                unsigned char * );
+static int (CDECL *ppcap_set_buffer_size)( pcap_t *, int );
+static int (CDECL *ppcap_set_datalink)( pcap_t *, int );
+static int (CDECL *ppcap_set_promisc)( pcap_t *, int );
+static int (CDECL *ppcap_set_timeout)( pcap_t *, int );
+static int (CDECL *ppcap_set_tstamp_precision)( pcap_t *, int );
+static int (CDECL *ppcap_setfilter)( pcap_t *, struct bpf_program * );
+static int (CDECL *ppcap_snapshot)( pcap_t * );
+static int (CDECL *ppcap_stats)( pcap_t *, struct pcap_stat * );
+static int CDECL (*ppcap_tstamp_type_name_to_val)( const char * );
+static const char * (CDECL *ppcap_tstamp_type_val_to_description)( int );
+static const char * (CDECL *ppcap_tstamp_type_val_to_name)( int );
+
+static void CALLBACK capture_callback( unsigned char *user, const struct pcap_pkthdr *hdr, const unsigned char *bytes )
+{
+    trace( "user %p hdr %p byte %p\n", user, hdr, bytes );
+}
+
+static void test_capture( void )
+{
+    char errbuf[PCAP_ERRBUF_SIZE], *dev, *err;
+    pcap_t *pcap;
+    void *aircap;
+    struct pcap_stat stats;
+    unsigned int net, mask;
+    struct bpf_program program;
+    int ret, *links, *types;
+
+    dev = ppcap_lookupdev( errbuf );
+    ok( dev != NULL, "got NULL (%s)\n", errbuf );
+
+    pcap = ppcap_create( dev, errbuf );
+    ok( pcap != NULL, "got NULL (%s)\n", errbuf );
+
+    ret = ppcap_set_promisc( pcap, 1 );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_set_timeout( pcap, 100 );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_set_tstamp_precision( pcap, 0 );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_can_set_rfmon( pcap );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_getnonblock( pcap, errbuf );
+    ok( ret == -3, "got %d\n", ret );
+
+    ret = ppcap_datalink( pcap );
+    ok( ret == -3, "got %d\n", ret );
+
+    err = ppcap_geterr( pcap );
+    ok( err != NULL, "got NULL\n" );
+
+    ret = ppcap_set_buffer_size( pcap, 2097152 );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_activate( pcap );
+    if (ret == PCAP_ERROR_PERM_DENIED)
+    {
+        skip( "no permission\n" );
+        ppcap_close( pcap );
+        return;
+    }
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_set_buffer_size( pcap, 256000 );
+    ok( ret == -4, "got %d\n", ret );
+
+    ret = ppcap_bufsize( pcap );
+    ok( ret > 0, "got %d\n", ret );
+
+    ret = ppcap_getnonblock( pcap, errbuf );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_get_tstamp_precision( pcap );
+    trace( "pcap_get_tstamp_precision %d\n", ret );
+
+    ret = ppcap_datalink( pcap );
+    trace( "pcap_datalink %d\n", ret );
+
+    links = NULL;
+    ret = ppcap_list_datalinks( pcap, &links );
+    ok( ret > 0, "got %d\n", ret );
+    ok( links != NULL, "got NULL\n" );
+
+    ret = ppcap_set_datalink( pcap, links[0] );
+    ok( !ret, "got %d\n", ret );
+    ppcap_free_datalinks( links );
+
+    types = NULL;
+    ret = ppcap_list_tstamp_types( pcap, &types );
+    ok( ret > 0, "got %d\n", ret );
+    ok( types != NULL, "got NULL\n" );
+    ppcap_free_tstamp_types( types );
+
+    net = mask = 0;
+    ret = ppcap_lookupnet( dev, &net, &mask, errbuf );
+    ok( !ret, "got %d\n", ret );
+
+    memset( &program, 0, sizeof(program) );
+    ret = ppcap_compile( pcap, &program, "", 1, 0xffffff );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_setfilter( pcap, &program );
+    ok( !ret, "got %d\n", ret );
+    ppcap_freecode( &program );
+
+    ret = ppcap_snapshot( pcap );
+    ok( ret > 0, "got %d\n", ret );
+
+    ret = ppcap_dispatch( pcap, 1, capture_callback, NULL );
+    ok( ret >= 0, "got %d\n", ret );
+
+    aircap = ppcap_get_airpcap_handle( pcap );
+    ok( aircap == NULL, "got %p\n", aircap );
+
+    memset( &stats, 0, sizeof(stats) );
+    ret = ppcap_stats( pcap, &stats );
+    ok( !ret, "got %d\n", ret );
+    ppcap_close( pcap );
+}
+
+static void test_datalink( void )
+{
+    const char *str;
+    int ret;
+
+    str = ppcap_datalink_val_to_name( 0 );
+    ok( str != NULL, "got NULL\n" );
+    ok( !strcmp(str, "NULL"), "got %s\n", wine_dbgstr_a(str) );
+
+    ret = ppcap_datalink_name_to_val( str );
+    ok( !ret, "got %d\n", ret );
+
+    str = ppcap_datalink_val_to_description( 0 );
+    ok( str != NULL, "got NULL\n" );
+    ok( !strcmp(str, "BSD loopback"), "got %s\n", wine_dbgstr_a(str) );
+
+    str = ppcap_datalink_val_to_name( 1 );
+    ok( str != NULL, "got NULL\n" );
+    ok( !strcmp(str, "EN10MB"), "got %s\n", wine_dbgstr_a(str) );
+
+    ret = ppcap_datalink_name_to_val( str );
+    ok( ret == 1, "got %d\n", ret );
+
+    str = ppcap_datalink_val_to_description( 1 );
+    ok( str != NULL, "got NULL\n" );
+    ok( !strcmp(str, "Ethernet"), "got %s\n", wine_dbgstr_a(str) );
+}
+
+static void CALLBACK dump_callback( unsigned char *user, const struct pcap_pkthdr *hdr, const unsigned char *bytes )
+{
+    trace( "user %p hdr %p bytes %p\n", user, hdr, bytes );
+    ppcap_dump( user, hdr, bytes );
+}
+
+static void test_dump( void )
+{
+    char errbuf[PCAP_ERRBUF_SIZE], path[MAX_PATH], filename[MAX_PATH];
+    pcap_t *pcap;
+    pcap_if_t *devs;
+    pcap_dumper_t *dumper;
+    int ret;
+
+    devs = NULL;
+    ret = ppcap_findalldevs( &devs, errbuf );
+    ok( !ret, "got %d (%s)\n", ret, errbuf );
+    ok( devs != NULL, "got NULL\n" );
+
+    pcap = ppcap_create( devs->name, errbuf );
+    ok( pcap != NULL, "got NULL (%s)\n", errbuf );
+
+    ret = ppcap_set_timeout( pcap, 100 );
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_activate( pcap );
+    if (ret == PCAP_ERROR_PERM_DENIED)
+    {
+        skip( "no permission\n" );
+        ppcap_freealldevs( devs );
+        ppcap_close( pcap );
+        return;
+    }
+    ok( !ret, "got %d\n", ret );
+
+    ret = ppcap_bufsize( pcap );
+    ok( ret > 0, "got %d\n", ret );
+
+    GetTempPathA( sizeof(path), path );
+    GetTempFileNameA( path, "cap", 0, filename );
+
+    dumper = ppcap_dump_open( pcap, filename );
+    ok( dumper != NULL, "got NULL\n" );
+
+    ret = ppcap_dispatch( pcap, 1, dump_callback, NULL );
+    ok( ret >= 0, "got %d\n", ret );
+
+    ppcap_dump_close( dumper );
+    ppcap_freealldevs( devs );
+    ppcap_close( pcap );
+    DeleteFileA( filename );
+}
+
+START_TEST( wpcap )
+{
+    char errbuf[PCAP_ERRBUF_SIZE];
+    HMODULE module = LoadLibraryW( L"wpcap.dll" );
+    if (!module)
+    {
+        win_skip( "wpcap.dll not found\n" );
+        return;
+    }
+    ppcap_activate = (void *)GetProcAddress( module, "pcap_activate" );
+    ppcap_breakloop = (void *)GetProcAddress( module, "pcap_breakloop" );
+    ppcap_bufsize = (void *)GetProcAddress( module, "pcap_bufsize" );
+    ppcap_can_set_rfmon = (void *)GetProcAddress( module, "pcap_can_set_rfmon" );
+    ppcap_close = (void *)GetProcAddress( module, "pcap_close" );
+    ppcap_compile = (void *)GetProcAddress( module, "pcap_compile" );
+    ppcap_create = (void *)GetProcAddress( module, "pcap_create" );
+    ppcap_datalink = (void *)GetProcAddress( module, "pcap_datalink" );
+    ppcap_datalink_name_to_val = (void *)GetProcAddress( module, "pcap_datalink_name_to_val" );
+    ppcap_datalink_val_to_description = (void *)GetProcAddress( module, "pcap_datalink_val_to_description" );
+    ppcap_datalink_val_to_name = (void *)GetProcAddress( module, "pcap_datalink_val_to_name" );
+    ppcap_dispatch = (void *)GetProcAddress( module, "pcap_dispatch" );
+    ppcap_dump_open = (void *)GetProcAddress( module, "pcap_dump_open" );
+    ppcap_dump = (void *)GetProcAddress( module, "pcap_dump" );
+    ppcap_dump_close = (void *)GetProcAddress( module, "pcap_dump_close" );
+    ppcap_get_airpcap_handle = (void *)GetProcAddress( module, "pcap_get_airpcap_handle" );
+    ppcap_get_tstamp_precision = (void *)GetProcAddress( module, "pcap_get_tstamp_precision" );
+    ppcap_geterr = (void *)GetProcAddress( module, "pcap_geterr" );
+    ppcap_getnonblock = (void *)GetProcAddress( module, "pcap_getnonblock" );
+    ppcap_findalldevs = (void *)GetProcAddress( module, "pcap_findalldevs" );
+    ppcap_freealldevs = (void *)GetProcAddress( module, "pcap_freealldevs" );
+    ppcap_free_datalinks = (void *)GetProcAddress( module, "pcap_free_datalinks" );
+    ppcap_free_tstamp_types = (void *)GetProcAddress( module, "pcap_free_tstamp_types" );
+    ppcap_freecode = (void *)GetProcAddress( module, "pcap_freecode" );
+    ppcap_init = (void *)GetProcAddress( module, "pcap_init" );
+    ppcap_lib_version = (void *)GetProcAddress( module, "pcap_lib_version" );
+    ppcap_list_datalinks = (void *)GetProcAddress( module, "pcap_list_datalinks" );
+    ppcap_list_tstamp_types = (void *)GetProcAddress( module, "pcap_list_tstamp_types" );
+    ppcap_lookupdev = (void *)GetProcAddress( module, "pcap_lookupdev" );
+    ppcap_lookupnet = (void *)GetProcAddress( module, "pcap_lookupnet" );
+    ppcap_loop = (void *)GetProcAddress( module, "pcap_loop" );
+    ppcap_set_buffer_size = (void *)GetProcAddress( module, "pcap_set_buffer_size" );
+    ppcap_set_datalink = (void *)GetProcAddress( module, "pcap_set_datalink" );
+    ppcap_set_promisc = (void *)GetProcAddress( module, "pcap_set_promisc" );
+    ppcap_set_timeout = (void *)GetProcAddress( module, "pcap_set_timeout" );
+    ppcap_set_tstamp_precision = (void *)GetProcAddress( module, "pcap_set_tstamp_precision" );
+    ppcap_setfilter = (void *)GetProcAddress( module, "pcap_setfilter" );
+    ppcap_snapshot = (void *)GetProcAddress( module, "pcap_snapshot" );
+    ppcap_stats = (void *)GetProcAddress( module, "pcap_stats" );
+    ppcap_tstamp_type_name_to_val = (void *)GetProcAddress( module, "pcap_tstamp_type_name_to_val" );
+    ppcap_tstamp_type_val_to_description = (void *)GetProcAddress( module, "pcap_tstamp_type_val_to_description" );
+    ppcap_tstamp_type_val_to_name = (void *)GetProcAddress( module, "pcap_tstamp_type_val_to_name" );
+
+    trace( "lib version %s\n", ppcap_lib_version() );
+    trace( "supports PCAP_MMAP_32BIT: %s\n", (ppcap_init(PCAP_MMAP_32BIT, errbuf) < 0) ? "no" : "yes" );
+
+    test_capture();
+    test_datalink();
+    test_dump();
+}
diff --git a/dlls/wpcap/unixlib.c b/dlls/wpcap/unixlib.c
index a44627a7754..55069fac79e 100644
--- a/dlls/wpcap/unixlib.c
+++ b/dlls/wpcap/unixlib.c
@@ -26,6 +26,7 @@
 #ifdef HAVE_PCAP_PCAP_H
 #include <pcap/pcap.h>
 
+#include <assert.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <limits.h>
@@ -40,78 +41,104 @@
 #include "unixlib.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wpcap);
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 static NTSTATUS wrap_activate( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_activate( pcap->handle );
+    const struct activate_params *params = args;
+    return pcap_activate( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_breakloop( void *args )
 {
-    struct pcap *pcap = args;
-    pcap_breakloop( pcap->handle );
+    const struct breakloop_params *params = args;
+    pcap_breakloop( (pcap_t *)(ULONG_PTR)params->handle );
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS wrap_bufsize( void *args )
+{
+    const struct bufsize_params *params = args;
+    return pcap_bufsize( (pcap_t *)(ULONG_PTR)params->handle );
+}
+
 static NTSTATUS wrap_can_set_rfmon( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_can_set_rfmon( pcap->handle );
+    const struct can_set_rfmon_params *params = args;
+    return pcap_can_set_rfmon( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_close( void *args )
 {
-    struct pcap *pcap = args;
-    pcap_close( pcap->handle );
-    free( pcap );
+    const struct close_params *params = args;
+    pcap_close( (pcap_t *)(ULONG_PTR)params->handle );
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_compile( void *args )
 {
-    const struct compile_params *params = args;
-    return pcap_compile( params->pcap->handle, params->program, params->buf, params->optimize, params->mask );
+    struct compile_params *params = args;
+    struct bpf_program program;
+    int ret;
+
+    if (!(ret = pcap_compile( (pcap_t *)(ULONG_PTR)params->handle, &program, params->str, params->optimize,
+                              params->mask )))
+    {
+        if (*params->program_len < program.bf_len) ret = STATUS_BUFFER_TOO_SMALL;
+        else memcpy( params->program_insns, program.bf_insns, program.bf_len * sizeof(*program.bf_insns) );
+        *params->program_len = program.bf_len;
+        pcap_freecode( &program );
+    }
+    return ret;
 }
 
 static NTSTATUS wrap_create( void *args )
 {
-    const struct create_params *params = args;
-    struct pcap *ret = malloc( sizeof(*ret) );
-
-    if (ret && !(ret->handle = pcap_create( params->src, params->errbuf )))
-    {
-        free( ret );
-        ret = NULL;
-    }
-    *params->ret = ret;
+    struct create_params *params = args;
+    if (!(*params->handle = (ULONG_PTR)pcap_create( params->source, params->errbuf ))) return STATUS_NO_MEMORY;
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_datalink( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_datalink( pcap->handle );
+    struct datalink_params *params = args;
+    return pcap_datalink( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_datalink_name_to_val( void *args )
 {
-    const struct datalink_name_to_val_params *params = args;
+    struct datalink_name_to_val_params *params = args;
     return pcap_datalink_name_to_val( params->name );
 }
 
 static NTSTATUS wrap_datalink_val_to_description( void *args )
 {
     const struct datalink_val_to_description_params *params = args;
-    *params->ret = pcap_datalink_val_to_description( params->link );
+    const char *str = pcap_datalink_val_to_description( params->link );
+    int len;
+
+    if (!str || !params->buf) return STATUS_INVALID_PARAMETER;
+    if ((len = strlen( str )) >= *params->buflen)
+    {
+        *params->buflen = len + 1;
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+    strcpy( params->buf, str );
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_datalink_val_to_name( void *args )
 {
     const struct datalink_val_to_name_params *params = args;
-    *params->ret = pcap_datalink_val_to_name( params->link );
+    const char *str = pcap_datalink_val_to_name( params->link );
+    int len;
+
+    if (!str || !params->buf) return STATUS_INVALID_PARAMETER;
+    if ((len = strlen( str )) >= *params->buflen)
+    {
+        *params->buflen = len + 1;
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+    strcpy( params->buf, str );
     return STATUS_SUCCESS;
 }
 
@@ -128,68 +155,85 @@ static NTSTATUS wrap_dump( void *args )
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS wrap_dump_close( void *args )
+{
+    const struct dump_close_params *params = args;
+    pcap_dump_close( (pcap_dumper_t *)(ULONG_PTR)params->handle );
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS wrap_dump_open( void *args )
 {
     const struct dump_open_params *params = args;
-    *params->ret = pcap_dump_open( params->pcap->handle, params->name );
+    *params->ret_handle = (ULONG_PTR)pcap_dump_open( (pcap_t *)(ULONG_PTR)params->handle, params->name );
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_findalldevs( void *args )
 {
     const struct findalldevs_params *params = args;
-    int ret;
-    ret = pcap_findalldevs( (pcap_if_t **)params->devs, params->errbuf );
-    if (params->devs && !*params->devs)
-        ERR_(winediag)( "Failed to access raw network (pcap), this requires special permissions.\n" );
-    return ret;
-}
+    pcap_if_t *devs = NULL, *src;
+    struct pcap_interface_offsets *dst = (struct pcap_interface_offsets *)params->buf;
+    int ret, len_total = 0;
 
-static NTSTATUS wrap_free_datalinks( void *args )
-{
-    int *links = args;
-    pcap_free_datalinks( links );
-    return STATUS_SUCCESS;
-}
+    if ((ret = pcap_findalldevs( &devs, params->errbuf ))) return ret;
 
-static NTSTATUS wrap_free_tstamp_types( void *args )
-{
-    int *types = args;
-    pcap_free_tstamp_types( types );
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS wrap_freealldevs( void *args )
-{
-    struct pcap_interface *devs = args;
-    pcap_freealldevs( (pcap_if_t *)devs );
-    return STATUS_SUCCESS;
-}
+    src = devs;
+    while (src)
+    {
+        int len_name = strlen( src->name ) + 1, len_description = src->description ? strlen( src->description ) + 1 : 0;
+        int len = sizeof(*dst) + len_name + len_description;
+
+        if (*params->buflen >= len_total + len)
+        {
+            dst->name_offset = sizeof(*dst);
+            dst->name_len = len_name;
+            strcpy( (char *)dst + dst->name_offset, src->name );
+            if (!len_description) dst->description_offset = dst->description_len = 0;
+            else
+            {
+                dst->description_offset = dst->name_offset + len_name;
+                dst->description_len = len_description;
+                strcpy( (char *)dst + dst->description_offset, src->description );
+            }
+            dst->flags = src->flags;
+            dst = (struct pcap_interface_offsets *)((char *)dst + len);
+        }
+        len_total += len;
+        src = src->next;
+    }
 
-static NTSTATUS wrap_freecode( void *args )
-{
-    void *program = args;
-    pcap_freecode( program );
-    return STATUS_SUCCESS;
+    if (*params->buflen < len_total) ret = STATUS_BUFFER_TOO_SMALL;
+    *params->buflen = len_total;
+    pcap_freealldevs( devs );
+    return ret;
 }
 
 static NTSTATUS wrap_get_tstamp_precision( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_get_tstamp_precision( pcap->handle );
+    const struct get_tstamp_precision_params *params = args;
+    return pcap_get_tstamp_precision( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_geterr( void *args )
 {
     const struct geterr_params *params = args;
-    *params->ret = pcap_geterr( params->pcap->handle );
+    char *errbuf = pcap_geterr( (pcap_t *)(ULONG_PTR)params->handle );
+    assert( strlen(errbuf) < PCAP_ERRBUF_SIZE );
+    strcpy( params->errbuf, errbuf );
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_getnonblock( void *args )
 {
     const struct getnonblock_params *params = args;
-    return pcap_getnonblock( params->pcap->handle, params->errbuf );
+    return pcap_getnonblock( (pcap_t *)(ULONG_PTR)params->handle, params->errbuf );
+}
+
+static NTSTATUS wrap_init( void *args )
+{
+    const struct init_params *params = args;
+    return pcap_init( params->opt, params->errbuf );
 }
 
 static NTSTATUS wrap_lib_version( void *args )
@@ -197,6 +241,7 @@ static NTSTATUS wrap_lib_version( void *args )
     const struct lib_version_params *params = args;
     const char *str = pcap_lib_version();
     unsigned int len = min( strlen(str) + 1, params->size );
+
     memcpy( params->version, str, len );
     params->version[len - 1] = 0;
     return STATUS_SUCCESS;
@@ -205,13 +250,33 @@ static NTSTATUS wrap_lib_version( void *args )
 static NTSTATUS wrap_list_datalinks( void *args )
 {
     const struct list_datalinks_params *params = args;
-    return pcap_list_datalinks( params->pcap->handle, params->buf );
+    NTSTATUS status = STATUS_SUCCESS;
+    int *links = NULL, count;
+
+    if ((count = pcap_list_datalinks( (pcap_t *)(ULONG_PTR)params->handle, &links )) > 0)
+    {
+        if (*params->count < count) status = STATUS_BUFFER_TOO_SMALL;
+        else memcpy( params->links, links, count * sizeof(*links) );
+    }
+    pcap_free_datalinks( links );
+    *params->count = count;
+    return status;
 }
 
 static NTSTATUS wrap_list_tstamp_types( void *args )
 {
     const struct list_tstamp_types_params *params = args;
-    return pcap_list_tstamp_types( params->pcap->handle, params->types );
+    NTSTATUS status = STATUS_SUCCESS;
+    int *types = NULL, count;
+
+    if ((count = pcap_list_tstamp_types( (pcap_t *)(ULONG_PTR)params->handle, &types )) > 0)
+    {
+        if (*params->count < count) status = STATUS_BUFFER_TOO_SMALL;
+        else memcpy( params->types, types, count * sizeof(*types) );
+    }
+    pcap_free_tstamp_types( types );
+    *params->count = count;
+    return status;
 }
 
 static NTSTATUS wrap_lookupnet( void *args )
@@ -222,31 +287,29 @@ static NTSTATUS wrap_lookupnet( void *args )
 
 static NTSTATUS wrap_major_version( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_major_version( pcap->handle );
+    const struct major_version_params *params = args;
+    return pcap_major_version( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_minor_version( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_minor_version( pcap->handle );
+    const struct minor_version_params *params = args;
+    return pcap_minor_version( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_next_ex( void *args )
 {
-    const struct next_ex_params *params = args;
-    struct pcap *pcap = params->pcap;
+    struct next_ex_params *params = args;
     struct pcap_pkthdr *hdr_unix;
     int ret;
 
-    if ((ret = pcap_next_ex( pcap->handle, &hdr_unix, params->data )) == 1)
+    if ((ret = pcap_next_ex( (pcap_t *)(ULONG_PTR)params->handle, &hdr_unix, params->data )) == 1)
     {
         if (hdr_unix->ts.tv_sec > INT_MAX || hdr_unix->ts.tv_usec > INT_MAX) WARN( "truncating timeval values(s)\n" );
-        pcap->hdr.ts.tv_sec  = hdr_unix->ts.tv_sec;
-        pcap->hdr.ts.tv_usec = hdr_unix->ts.tv_usec;
-        pcap->hdr.caplen     = hdr_unix->caplen;
-        pcap->hdr.len        = hdr_unix->len;
-        *params->hdr = &pcap->hdr;
+        params->hdr->ts.tv_sec  = hdr_unix->ts.tv_sec;
+        params->hdr->ts.tv_usec = hdr_unix->ts.tv_usec;
+        params->hdr->caplen     = hdr_unix->caplen;
+        params->hdr->len        = hdr_unix->len;
     }
     return ret;
 }
@@ -254,100 +317,100 @@ static NTSTATUS wrap_next_ex( void *args )
 static NTSTATUS wrap_open_live( void *args )
 {
     const struct open_live_params *params = args;
-    struct pcap *ret = malloc( sizeof(*ret) );
-    if (ret && !(ret->handle = pcap_open_live( params->source, params->snaplen, params->promisc,
-                                               params->to_ms, params->errbuf )))
-    {
-        free( ret );
-        ret = NULL;
-    }
-    *params->ret = ret;
+    if (!(*params->handle = (ULONG_PTR)pcap_open_live( params->source, params->snaplen, params->promisc,
+                                                       params->timeout, params->errbuf ))) return STATUS_NO_MEMORY;
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_sendpacket( void *args )
 {
     const struct sendpacket_params *params = args;
-    return pcap_sendpacket( params->pcap->handle, params->buf, params->size );
+    return pcap_sendpacket( (pcap_t *)(ULONG_PTR)params->handle, params->buf, params->size );
 }
 
 static NTSTATUS wrap_set_buffer_size( void *args )
 {
     const struct set_buffer_size_params *params = args;
-    return pcap_set_buffer_size( params->pcap->handle, params->size );
+    return pcap_set_buffer_size( (pcap_t *)(ULONG_PTR)params->handle, params->size );
 }
 
 static NTSTATUS wrap_set_datalink( void *args )
 {
     const struct set_datalink_params *params = args;
-    return pcap_set_datalink( params->pcap->handle, params->link );
+    return pcap_set_datalink( (pcap_t *)(ULONG_PTR)params->handle, params->link );
 }
 
 static NTSTATUS wrap_set_promisc( void *args )
 {
     const struct set_promisc_params *params = args;
-    return pcap_set_promisc( params->pcap->handle, params->enable );
+    return pcap_set_promisc( (pcap_t *)(ULONG_PTR)params->handle, params->enable );
 }
 
 static NTSTATUS wrap_set_rfmon( void *args )
 {
     const struct set_rfmon_params *params = args;
-    return pcap_set_rfmon( params->pcap->handle, params->enable );
+    return pcap_set_rfmon( (pcap_t *)(ULONG_PTR)params->handle, params->enable );
 }
 
 static NTSTATUS wrap_set_snaplen( void *args )
 {
     const struct set_snaplen_params *params = args;
-    return pcap_set_snaplen( params->pcap->handle, params->len );
+    return pcap_set_snaplen( (pcap_t *)(ULONG_PTR)params->handle, params->len );
 }
 
 static NTSTATUS wrap_set_timeout( void *args )
 {
     const struct set_timeout_params *params = args;
-    return pcap_set_timeout( params->pcap->handle, params->timeout );
+    return pcap_set_timeout( (pcap_t *)(ULONG_PTR)params->handle, params->timeout );
 }
 
 static NTSTATUS wrap_set_tstamp_precision( void *args )
 {
     const struct set_tstamp_precision_params *params = args;
-    return pcap_set_tstamp_precision( params->pcap->handle, params->precision );
+    return pcap_set_tstamp_precision( (pcap_t *)(ULONG_PTR)params->handle, params->precision );
 }
 
 static NTSTATUS wrap_set_tstamp_type( void *args )
 {
     const struct set_tstamp_type_params *params = args;
-    return pcap_set_tstamp_type( params->pcap->handle, params->type );
+    return pcap_set_tstamp_type( (pcap_t *)(ULONG_PTR)params->handle, params->type );
 }
 
 static NTSTATUS wrap_setfilter( void *args )
 {
     const struct setfilter_params *params = args;
-    return pcap_setfilter( params->pcap->handle, params->program );
+    struct bpf_program program = { params->program_len, params->program_insns };
+    return pcap_setfilter( (pcap_t *)(ULONG_PTR)params->handle, &program );
 }
 
 static NTSTATUS wrap_setnonblock( void *args )
 {
     const struct setnonblock_params *params = args;
-    return pcap_setnonblock( params->pcap->handle, params->nonblock, params->errbuf );
+    return pcap_setnonblock( (pcap_t *)(ULONG_PTR)params->handle, params->nonblock, params->errbuf );
 }
 
 static NTSTATUS wrap_snapshot( void *args )
 {
-    struct pcap *pcap = args;
-    return pcap_snapshot( pcap->handle );
+    const struct snapshot_params *params = args;
+    return pcap_snapshot( (pcap_t *)(ULONG_PTR)params->handle );
 }
 
 static NTSTATUS wrap_stats( void *args )
 {
-    const struct stats_params *params = args;
-    return pcap_stats( params->pcap->handle, params->stats );
-}
+    struct stats_params *params = args;
+    struct pcap_stat stat;
+    int ret;
 
-static NTSTATUS wrap_statustostr( void *args )
-{
-    const struct statustostr_params *params = args;
-    *params->ret = pcap_statustostr( params->status );
-    return STATUS_SUCCESS;
+    if (!(ret = pcap_stats( (pcap_t *)(ULONG_PTR)params->handle, &stat )))
+    {
+        params->stat.ps_recv    = stat.ps_recv;
+        params->stat.ps_drop    = stat.ps_drop;
+        params->stat.ps_ifdrop  = stat.ps_ifdrop;
+        params->stat.ps_capt    = 0;
+        params->stat.ps_sent    = 0;
+        params->stat.ps_netdrop = 0;
+    }
+    return ret;
 }
 
 static NTSTATUS wrap_tstamp_type_name_to_val( void *args )
@@ -359,14 +422,32 @@ static NTSTATUS wrap_tstamp_type_name_to_val( void *args )
 static NTSTATUS wrap_tstamp_type_val_to_description( void *args )
 {
     const struct tstamp_type_val_to_description_params *params = args;
-    *params->ret = pcap_tstamp_type_val_to_description( params->val );
+    const char *str = pcap_tstamp_type_val_to_description( params->type );
+    int len;
+
+    if (!str || !params->buf) return STATUS_INVALID_PARAMETER;
+    if ((len = strlen( str )) >= *params->buflen)
+    {
+        *params->buflen = len + 1;
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+    strcpy( params->buf, str );
     return STATUS_SUCCESS;
 }
 
 static NTSTATUS wrap_tstamp_type_val_to_name( void *args )
 {
     const struct tstamp_type_val_to_name_params *params = args;
-    *params->ret = pcap_tstamp_type_val_to_name( params->val );
+    const char *str = pcap_tstamp_type_val_to_name( params->type );
+    int len;
+
+    if (!str || !params->buf) return STATUS_INVALID_PARAMETER;
+    if ((len = strlen( str )) >= *params->buflen)
+    {
+        *params->buflen = len + 1;
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+    strcpy( params->buf, str );
     return STATUS_SUCCESS;
 }
 
@@ -374,6 +455,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     wrap_activate,
     wrap_breakloop,
+    wrap_bufsize,
     wrap_can_set_rfmon,
     wrap_close,
     wrap_compile,
@@ -382,22 +464,18 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     wrap_datalink_name_to_val,
     wrap_datalink_val_to_description,
     wrap_datalink_val_to_name,
-    /* wrap_dispatch, */
     wrap_dump,
+    wrap_dump_close,
     wrap_dump_open,
     wrap_findalldevs,
-    wrap_free_datalinks,
-    wrap_free_tstamp_types,
-    wrap_freealldevs,
-    wrap_freecode,
     wrap_get_tstamp_precision,
     wrap_geterr,
     wrap_getnonblock,
+    wrap_init,
     wrap_lib_version,
     wrap_list_datalinks,
     wrap_list_tstamp_types,
     wrap_lookupnet,
-    /* wrap_loop, */
     wrap_major_version,
     wrap_minor_version,
     wrap_next_ex,
@@ -415,10 +493,474 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     wrap_setnonblock,
     wrap_snapshot,
     wrap_stats,
-    wrap_statustostr,
     wrap_tstamp_type_name_to_val,
     wrap_tstamp_type_val_to_description,
     wrap_tstamp_type_val_to_name,
 };
 
+#ifdef _WIN64
+
+typedef ULONG PTR32;
+
+static NTSTATUS wow64_compile( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 program_len;
+        PTR32 program_insns;
+        PTR32 str;
+        int optimize;
+        unsigned int mask;
+    } const *params32 = args;
+
+    struct compile_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->program_len),
+        ULongToPtr(params32->program_insns),
+        ULongToPtr(params32->str),
+        params32->optimize,
+        params32->mask
+    };
+    return wrap_compile( &params );
+}
+
+static NTSTATUS wow64_create( void *args )
+{
+    struct
+    {
+        PTR32 source;
+        PTR32 errbuf;
+        PTR32 handle;
+    } const *params32 = args;
+
+    struct create_params params =
+    {
+        ULongToPtr(params32->source),
+        ULongToPtr(params32->errbuf),
+        ULongToPtr(params32->handle),
+    };
+    return wrap_create( &params );
+}
+
+static NTSTATUS wow64_datalink_name_to_val( void *args )
+{
+    struct
+    {
+        PTR32 name;
+    } const *params32 = args;
+
+    struct datalink_name_to_val_params params =
+    {
+        ULongToPtr(params32->name),
+    };
+    return wrap_datalink_name_to_val( &params );
+}
+
+static NTSTATUS wow64_datalink_val_to_description( void *args )
+{
+    struct
+    {
+        int link;
+        PTR32 buf;
+        PTR32 buflen;
+    } const *params32 = args;
+
+    struct datalink_val_to_description_params params =
+    {
+        params32->link,
+        ULongToPtr(params32->buf),
+        ULongToPtr(params32->buflen)
+    };
+    return wrap_datalink_val_to_description( &params );
+}
+
+static NTSTATUS wow64_datalink_val_to_name( void *args )
+{
+    struct
+    {
+        int link;
+        PTR32 buf;
+        PTR32 buflen;
+    } const *params32 = args;
+
+    struct datalink_val_to_name_params params =
+    {
+        params32->link,
+        ULongToPtr(params32->buf),
+        ULongToPtr(params32->buflen)
+    };
+    return wrap_datalink_val_to_name( &params );
+}
+
+static NTSTATUS wow64_dump( void *args )
+{
+    struct
+    {
+        PTR32 user;
+        PTR32 hdr;
+        PTR32 packet;
+    } const *params32 = args;
+
+    struct dump_params params =
+    {
+        ULongToPtr(params32->user),
+        ULongToPtr(params32->hdr),
+        ULongToPtr(params32->packet)
+    };
+    return wrap_dump( &params );
+}
+
+static NTSTATUS wow64_dump_open( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 name;
+        PTR32 ret_handle;
+    } const *params32 = args;
+
+    struct datalink_val_to_name_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->name),
+        ULongToPtr(params32->ret_handle)
+    };
+    return wrap_dump_open( &params );
+}
+
+static NTSTATUS wow64_findalldevs( void *args )
+{
+    struct
+    {
+        PTR32 buf;
+        PTR32 buflen;
+        PTR32 errbuf;
+    } const *params32 = args;
+
+    struct findalldevs_params params =
+    {
+        ULongToPtr(params32->buf),
+        ULongToPtr(params32->buflen),
+        ULongToPtr(params32->errbuf)
+    };
+    return wrap_findalldevs( &params );
+}
+
+static NTSTATUS wow64_geterr( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 errbuf;
+    } const *params32 = args;
+
+    struct geterr_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->errbuf)
+    };
+    return wrap_geterr( &params );
+}
+
+static NTSTATUS wow64_getnonblock( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 errbuf;
+    } const *params32 = args;
+
+    struct getnonblock_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->errbuf)
+    };
+    return wrap_getnonblock( &params );
+}
+
+static NTSTATUS wow64_init( void *args )
+{
+    struct
+    {
+        int opt;
+        PTR32 errbuf;
+    } const *params32 = args;
+
+    struct init_params params =
+    {
+        params32->opt,
+        ULongToPtr(params32->errbuf)
+    };
+    return wrap_init( &params );
+}
+
+static NTSTATUS wow64_lib_version( void *args )
+{
+    struct
+    {
+        PTR32 version;
+        unsigned int size;
+    } const *params32 = args;
+
+    struct lib_version_params params =
+    {
+        ULongToPtr(params32->version),
+        params32->size
+    };
+    return wrap_lib_version( &params );
+}
+
+static NTSTATUS wow64_list_datalinks( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 links;
+        PTR32 count;
+    } const *params32 = args;
+
+    struct list_datalinks_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->links),
+        ULongToPtr(params32->count)
+    };
+    return wrap_list_datalinks( &params );
+}
+
+static NTSTATUS wow64_list_tstamp_types( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 types;
+        PTR32 count;
+    } const *params32 = args;
+
+    struct list_tstamp_types_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->types),
+        ULongToPtr(params32->count)
+    };
+    return wrap_list_tstamp_types( &params );
+}
+
+static NTSTATUS wow64_lookupnet( void *args )
+{
+    struct
+    {
+        PTR32 device;
+        PTR32 net;
+        PTR32 mask;
+        PTR32 errbuf;
+    } const *params32 = args;
+
+    struct lookupnet_params params =
+    {
+        ULongToPtr(params32->device),
+        ULongToPtr(params32->net),
+        ULongToPtr(params32->mask),
+        ULongToPtr(params32->errbuf)
+    };
+    return wrap_lookupnet( &params );
+}
+
+static NTSTATUS wow64_next_ex( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 hdr;
+        PTR32 data;
+    } const *params32 = args;
+
+    struct next_ex_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->hdr),
+        ULongToPtr(params32->data)
+    };
+    return wrap_next_ex( &params );
+}
+
+static NTSTATUS wow64_open_live( void *args )
+{
+    struct
+    {
+        PTR32 source;
+        int snaplen;
+        int promisc;
+        int timeout;
+        PTR32 errbuf;
+        PTR32 handle;
+    } const *params32 = args;
+
+    struct open_live_params params =
+    {
+        ULongToPtr(params32->source),
+        params32->snaplen,
+        params32->promisc,
+        params32->timeout,
+        ULongToPtr(params32->errbuf),
+        ULongToPtr(params32->handle)
+    };
+    return wrap_open_live( &params );
+}
+
+static NTSTATUS wow64_sendpacket( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        PTR32 buf;
+        int size;
+    } const *params32 = args;
+
+    struct sendpacket_params params =
+    {
+        params32->handle,
+        ULongToPtr(params32->buf),
+        params32->size
+    };
+    return wrap_sendpacket( &params );
+}
+
+static NTSTATUS wow64_setfilter( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        unsigned int program_len;
+        PTR32 program_insns;
+    } const *params32 = args;
+
+    struct setfilter_params params =
+    {
+        params32->handle,
+        params32->program_len,
+        ULongToPtr(params32->program_insns)
+    };
+    return wrap_setfilter( &params );
+}
+
+static NTSTATUS wow64_setnonblock( void *args )
+{
+    struct
+    {
+        UINT64 handle;
+        int nonblock;
+        PTR32 errbuf;
+    } const *params32 = args;
+
+    struct setnonblock_params params =
+    {
+        params32->handle,
+        params32->nonblock,
+        ULongToPtr(params32->errbuf)
+    };
+    return wrap_setnonblock( &params );
+}
+
+static NTSTATUS wow64_tstamp_type_name_to_val( void *args )
+{
+    struct
+    {
+        PTR32 name;
+    } const *params32 = args;
+
+    struct tstamp_type_name_to_val_params params =
+    {
+        ULongToPtr(params32->name)
+    };
+    return wrap_tstamp_type_name_to_val( &params );
+}
+
+static NTSTATUS wow64_tstamp_type_val_to_description( void *args )
+{
+    struct
+    {
+        int type;
+        PTR32 buf;
+        PTR32 buflen;
+    } const *params32 = args;
+
+    struct tstamp_type_val_to_description_params params =
+    {
+        params32->type,
+        ULongToPtr(params32->buf),
+        ULongToPtr(params32->buflen)
+    };
+    return wrap_tstamp_type_val_to_description( &params );
+}
+
+static NTSTATUS wow64_tstamp_type_val_to_name( void *args )
+{
+    struct
+    {
+        int type;
+        PTR32 buf;
+        PTR32 buflen;
+    } const *params32 = args;
+
+    struct tstamp_type_val_to_name_params params =
+    {
+        params32->type,
+        ULongToPtr(params32->buf),
+        ULongToPtr(params32->buflen)
+    };
+    return wrap_tstamp_type_val_to_name( &params );
+}
+
+const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
+{
+    wrap_activate,
+    wrap_breakloop,
+    wrap_bufsize,
+    wrap_can_set_rfmon,
+    wrap_close,
+    wow64_compile,
+    wow64_create,
+    wrap_datalink,
+    wow64_datalink_name_to_val,
+    wow64_datalink_val_to_description,
+    wow64_datalink_val_to_name,
+    wow64_dump,
+    wrap_dump_close,
+    wow64_dump_open,
+    wow64_findalldevs,
+    wrap_get_tstamp_precision,
+    wow64_geterr,
+    wow64_getnonblock,
+    wow64_init,
+    wow64_lib_version,
+    wow64_list_datalinks,
+    wow64_list_tstamp_types,
+    wow64_lookupnet,
+    wrap_major_version,
+    wrap_minor_version,
+    wow64_next_ex,
+    wow64_open_live,
+    wow64_sendpacket,
+    wrap_set_buffer_size,
+    wrap_set_datalink,
+    wrap_set_promisc,
+    wrap_set_rfmon,
+    wrap_set_snaplen,
+    wrap_set_timeout,
+    wrap_set_tstamp_precision,
+    wrap_set_tstamp_type,
+    wow64_setfilter,
+    wow64_setnonblock,
+    wrap_snapshot,
+    wrap_stats,
+    wow64_tstamp_type_name_to_val,
+    wow64_tstamp_type_val_to_description,
+    wow64_tstamp_type_val_to_name,
+};
+
+#endif /* _WIN64 */
+
 #endif /* HAVE_PCAP_PCAP_H */
diff --git a/dlls/wpcap/unixlib.h b/dlls/wpcap/unixlib.h
index 18854e0b86b..668658089f3 100644
--- a/dlls/wpcap/unixlib.h
+++ b/dlls/wpcap/unixlib.h
@@ -35,6 +35,15 @@ struct pcap_interface
     unsigned int flags;
 };
 
+struct pcap_interface_offsets
+{
+    unsigned int name_offset;
+    unsigned int name_len;
+    unsigned int description_offset;
+    unsigned int description_len;
+    unsigned int flags;
+};
+
 struct pcap_pkthdr_win32
 {
     struct
@@ -46,26 +55,61 @@ struct pcap_pkthdr_win32
     unsigned int len;
 };
 
-struct pcap
+struct pcap_stat_win32
+{
+    unsigned int ps_recv;
+    unsigned int ps_drop;
+    unsigned int ps_ifdrop;
+    unsigned int ps_capt;
+    unsigned int ps_sent;
+    unsigned int ps_netdrop;
+};
+
+struct activate_params
+{
+    UINT64 handle;
+};
+
+struct breakloop_params
 {
-    void *handle;
-    struct pcap_pkthdr_win32 hdr;
+    UINT64 handle;
+};
+
+struct bufsize_params
+{
+    UINT64 handle;
+};
+
+struct can_set_rfmon_params
+{
+    UINT64 handle;
+};
+
+struct close_params
+{
+    UINT64 handle;
 };
 
 struct compile_params
 {
-    struct pcap *pcap;
-    void *program;
-    const char *buf;
+    UINT64 handle;
+    unsigned int *program_len;
+    struct bpf_insn *program_insns;
+    const char *str;
     int optimize;
     unsigned int mask;
 };
 
 struct create_params
 {
-    const char *src;
+    char *source;
     char *errbuf;
-    struct pcap **ret;
+    UINT64 *handle;
+};
+
+struct datalink_params
+{
+    UINT64 handle;
 };
 
 struct datalink_name_to_val_params
@@ -76,13 +120,15 @@ struct datalink_name_to_val_params
 struct datalink_val_to_description_params
 {
     int link;
-    const char **ret;
+    char *buf;
+    unsigned int *buflen;
 };
 
 struct datalink_val_to_name_params
 {
     int link;
-    const char **ret;
+    char *buf;
+    unsigned int *buflen;
 };
 
 struct dump_params
@@ -92,28 +138,45 @@ struct dump_params
     const unsigned char *packet;
 };
 
+struct dump_close_params
+{
+    UINT64 handle;
+};
+
 struct dump_open_params
 {
-    struct pcap *pcap;
-    const char *name;
-    void **ret;
+    UINT64 handle;
+    char *name;
+    UINT64 *ret_handle;
 };
 
 struct findalldevs_params
 {
-    struct pcap_interface **devs;
+    char *buf;
+    unsigned int *buflen;
     char *errbuf;
 };
 
 struct geterr_params
 {
-    struct pcap *pcap;
-    char **ret;
+    UINT64 handle;
+    char *errbuf;
 };
 
 struct getnonblock_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
+    char *errbuf;
+};
+
+struct get_tstamp_precision_params
+{
+    UINT64 handle;
+};
+
+struct init_params
+{
+    int opt;
     char *errbuf;
 };
 
@@ -125,119 +188,131 @@ struct lib_version_params
 
 struct list_datalinks_params
 {
-    struct pcap *pcap;
-    int **buf;
+    UINT64 handle;
+    int *links;
+    int *count;
 };
 
 struct list_tstamp_types_params
 {
-    struct pcap *pcap;
-    int **types;
+    UINT64 handle;
+    int *types;
+    int *count;
 };
 
 struct lookupnet_params
 {
-    const char *device;
+    char *device;
     unsigned int *net;
     unsigned int *mask;
     char *errbuf;
 };
 
+struct major_version_params
+{
+    UINT64 handle;
+};
+
+struct minor_version_params
+{
+    UINT64 handle;
+};
+
 struct next_ex_params
 {
-    struct pcap *pcap;
-    struct pcap_pkthdr_win32 **hdr;
+    UINT64 handle;
+    struct pcap_pkthdr_win32 *hdr;
     const unsigned char **data;
 };
 
 struct open_live_params
 {
-    const char *source;
+    char *source;
     int snaplen;
     int promisc;
-    int to_ms;
+    int timeout;
     char *errbuf;
-    struct pcap **ret;
+    UINT64 *handle;
 };
 
 struct sendpacket_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     const unsigned char *buf;
     int size;
 };
 
 struct set_buffer_size_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int size;
 };
 
 struct set_datalink_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int link;
 };
 
 struct set_promisc_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int enable;
 };
 
 struct set_rfmon_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int enable;
 };
 
 struct set_snaplen_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int len;
 };
 
 struct set_timeout_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int timeout;
 };
 
 struct set_tstamp_precision_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int precision;
 };
 
 struct set_tstamp_type_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int type;
 };
 
 struct setfilter_params
 {
-    struct pcap *pcap;
-    void *program;
+    UINT64 handle;
+    unsigned int program_len;
+    struct bpf_insn *program_insns;
 };
 
 struct setnonblock_params
 {
-    struct pcap *pcap;
+    UINT64 handle;
     int nonblock;
     char *errbuf;
 };
 
-struct stats_params
+struct snapshot_params
 {
-    struct pcap *pcap;
-    void *stats;
+    UINT64 handle;
 };
 
-struct statustostr_params
+struct stats_params
 {
-    int status;
-    const char **ret;
+    UINT64 handle;
+    struct pcap_stat_win32 stat;
 };
 
 struct tstamp_type_name_to_val_params
@@ -247,20 +322,23 @@ struct tstamp_type_name_to_val_params
 
 struct tstamp_type_val_to_description_params
 {
-    int val;
-    const char **ret;
+    int type;
+    char *buf;
+    unsigned int *buflen;
 };
 
 struct tstamp_type_val_to_name_params
 {
-    int val;
-    const char **ret;
+    int type;
+    char *buf;
+    unsigned int *buflen;
 };
 
 enum pcap_funcs
 {
     unix_activate,
     unix_breakloop,
+    unix_bufsize,
     unix_can_set_rfmon,
     unix_close,
     unix_compile,
@@ -269,22 +347,18 @@ enum pcap_funcs
     unix_datalink_name_to_val,
     unix_datalink_val_to_description,
     unix_datalink_val_to_name,
-    /* unix_dispatch, */
     unix_dump,
+    unix_dump_close,
     unix_dump_open,
     unix_findalldevs,
-    unix_free_datalinks,
-    unix_free_tstamp_types,
-    unix_freealldevs,
-    unix_freecode,
     unix_get_tstamp_precision,
     unix_geterr,
     unix_getnonblock,
+    unix_init,
     unix_lib_version,
     unix_list_datalinks,
     unix_list_tstamp_types,
     unix_lookupnet,
-    /* unix_loop, */
     unix_major_version,
     unix_minor_version,
     unix_next_ex,
@@ -302,7 +376,6 @@ enum pcap_funcs
     unix_setnonblock,
     unix_snapshot,
     unix_stats,
-    unix_statustostr,
     unix_tstamp_type_name_to_val,
     unix_tstamp_type_val_to_description,
     unix_tstamp_type_val_to_name,
diff --git a/dlls/wpcap/wpcap.c b/dlls/wpcap/wpcap.c
index 4d8a115b0ea..8c304ce66a4 100644
--- a/dlls/wpcap/wpcap.c
+++ b/dlls/wpcap/wpcap.c
@@ -2,6 +2,7 @@
  * WPcap.dll Proxy.
  *
  * Copyright 2011, 2014 André Hentschel
+ * Copyright 2022 Hans Leidekker for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,6 +20,10 @@
  */
 
 #include <stdarg.h>
+#include <malloc.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winbase.h"
 #include "winternl.h"
@@ -33,44 +38,158 @@
 #include "unixlib.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wpcap);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #define PCAP_CALL( func, params ) WINE_UNIX_CALL( unix_ ## func, params )
 
+#define PCAP_ERROR -1
+#define PCAP_ERROR_BREAK -2
+#define PCAP_ERROR_NOT_ACTIVATED -3
+#define PCAP_ERROR_ACTIVATED -4
+#define PCAP_ERROR_NO_SUCH_DEVICE -5
+#define PCAP_ERROR_RFMON_NOTSUP -6
+#define PCAP_ERROR_NOT_RFMON -7
+#define PCAP_ERROR_PERM_DENIED -8
+#define PCAP_ERROR_IFACE_NOT_UP -9
+#define PCAP_ERROR_CANTSET_TSTAMP_TYPE -10
+#define PCAP_ERROR_PROMISC_PERM_DENIED -11
+#define PCAP_ERROR_TSTAMP_PRECISION_NOTSUP -12
+
+#define PCAP_WARNING 1
+#define PCAP_WARNING_PROMISC_NOTSUP 2
+#define PCAP_WARNING_TSTAMP_TYPE_NOTSUP 3
+
+#define PCAP_ERRBUF_SIZE 256
+struct pcap
+{
+    UINT64 handle;
+    struct pcap_pkthdr_win32 hdr;
+    char errbuf[PCAP_ERRBUF_SIZE];
+};
+
+struct bpf_insn
+{
+    unsigned short code;
+    unsigned char jt;
+    unsigned char jf;
+    unsigned int k;
+};
+
+struct bpf_program
+{
+    unsigned int bf_len;
+    struct bpf_insn *bf_insns;
+};
+
 int CDECL pcap_activate( struct pcap *pcap )
 {
+    struct activate_params params;
+    int ret;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( activate, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+
+    params.handle = pcap->handle;
+    ret = PCAP_CALL( activate, &params );
+    if (ret == PCAP_ERROR_PERM_DENIED)
+        ERR_(winediag)( "Failed to access raw network (pcap), this requires special permissions.\n" );
+    return ret;
 }
 
 void CDECL pcap_breakloop( struct pcap *pcap )
 {
+    struct breakloop_params params;
+
     TRACE( "%p\n", pcap );
-    PCAP_CALL( breakloop, pcap );
+
+    if (!pcap) return;
+    params.handle = pcap->handle;
+    PCAP_CALL( breakloop, &params );
+}
+
+int CDECL pcap_bufsize( struct pcap *pcap )
+{
+    struct bufsize_params params;
+
+    TRACE( "%p\n", pcap );
+
+    if (!pcap) return 0;
+    params.handle = pcap->handle;
+    return PCAP_CALL( bufsize, &params );
 }
 
 int CDECL pcap_can_set_rfmon( struct pcap *pcap )
 {
+    struct can_set_rfmon_params params;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( can_set_rfmon, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    return PCAP_CALL( can_set_rfmon, &params );
 }
 
 void CDECL pcap_close( struct pcap *pcap )
 {
+    struct close_params params;
+
     TRACE( "%p\n", pcap );
-    PCAP_CALL( close, pcap );
+
+    if (!pcap) return;
+    params.handle = pcap->handle;
+    PCAP_CALL( close, &params );
+    free( pcap );
 }
 
-int CDECL pcap_compile( struct pcap *pcap, void *program, const char *buf, int optimize, unsigned int mask )
+int CDECL pcap_compile( struct pcap *pcap, struct bpf_program *program, const char *str, int optimize, unsigned int mask )
 {
-    struct compile_params params = { pcap, program, buf, optimize, mask };
-    TRACE( "%p, %p, %s, %d, %u\n", pcap, program, debugstr_a(buf), optimize, mask );
-    return PCAP_CALL( compile, &params );
+    struct compile_params params;
+    unsigned int len = 64;
+    struct bpf_insn *tmp;
+    NTSTATUS status;
+
+    TRACE( "%p, %p, %s, %d, %#x\n", pcap, program, debugstr_a(str), optimize, mask );
+
+    if (!pcap || !program) return PCAP_ERROR;
+
+    if (!(params.program_insns = malloc( len * sizeof(*params.program_insns) ))) return PCAP_ERROR;
+    params.handle        = pcap->handle;
+    params.program_len   = &len;
+    params.str           = str;
+    params.optimize      = optimize;
+    params.mask          = mask;
+    if ((status = PCAP_CALL( compile, &params )) == STATUS_SUCCESS)
+    {
+        program->bf_len   = *params.program_len;
+        program->bf_insns = params.program_insns;
+        return 0;
+    }
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.program_insns, len * sizeof(*tmp) )))
+    {
+        free( params.program_insns );
+        return PCAP_ERROR;
+    }
+    params.program_insns = tmp;
+    if (PCAP_CALL( compile, &params ))
+    {
+        free( params.program_insns );
+        return PCAP_ERROR;
+    }
+    program->bf_len   = *params.program_len;
+    program->bf_insns = params.program_insns;
+    return 0;
 }
 
 int CDECL pcap_datalink( struct pcap *pcap )
 {
+    struct datalink_params params;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( datalink, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    return PCAP_CALL( datalink, &params );
 }
 
 int CDECL pcap_datalink_name_to_val( const char *name )
@@ -80,22 +199,94 @@ int CDECL pcap_datalink_name_to_val( const char *name )
     return PCAP_CALL( datalink_name_to_val, &params );
 }
 
+static struct
+{
+    char *name;
+    char *description;
+} datalinks[192];
+
+static void free_datalinks( void )
+{
+    unsigned int i;
+    for (i = 0; i < ARRAY_SIZE(datalinks); i++)
+    {
+        free( datalinks[i].name );
+        datalinks[i].name = NULL;
+        free( datalinks[i].description );
+        datalinks[i].description = NULL;
+    }
+}
+
 const char * CDECL pcap_datalink_val_to_description( int link )
 {
-    const char *ret;
-    struct datalink_val_to_description_params params = { link, &ret };
+    struct datalink_val_to_description_params params;
+    unsigned int len = 192;
+    char *tmp;
+    NTSTATUS status;
+
     TRACE( "%d\n", link );
-    PCAP_CALL( datalink_val_to_description, &params );
-    return ret;
+
+    if (link < 0 || link >= ARRAY_SIZE(datalinks))
+    {
+        WARN( "unhandled link type %d\n", link );
+        return NULL;
+    }
+    if (datalinks[link].description) return datalinks[link].description;
+
+    if (!(params.buf = malloc( len ))) return NULL;
+    params.link   = link;
+    params.buflen = &len;
+    status = PCAP_CALL( datalink_val_to_description, &params );
+    if (status == STATUS_SUCCESS) return (datalinks[link].description = params.buf);
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.buf, len )))
+    {
+        free( params.buf );
+        return NULL;
+    }
+    params.buf = tmp;
+    if (PCAP_CALL( datalink_val_to_description, &params ))
+    {
+        free( params.buf );
+        return NULL;
+    }
+
+    return (datalinks[link].description = params.buf);
 }
 
 const char * CDECL pcap_datalink_val_to_name( int link )
 {
-    const char *ret;
-    struct datalink_val_to_name_params params = { link, &ret };
+    struct datalink_val_to_name_params params;
+    unsigned int len = 64;
+    char *tmp;
+    NTSTATUS status;
+
     TRACE( "%d\n", link );
-    PCAP_CALL( datalink_val_to_name, &params );
-    return ret;
+
+    if (link < 0 || link >= ARRAY_SIZE(datalinks))
+    {
+        WARN( "unhandled link type %d\n", link );
+        return NULL;
+    }
+    if (datalinks[link].name) return datalinks[link].name;
+
+    if (!(params.buf = malloc( len ))) return NULL;
+    params.link   = link;
+    params.buflen = &len;
+    status = PCAP_CALL( datalink_val_to_name, &params );
+    if (status == STATUS_SUCCESS) return (datalinks[link].name = params.buf);
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.buf, len )))
+    {
+        free( params.buf );
+        return NULL;
+    }
+    params.buf = tmp;
+    if (PCAP_CALL( datalink_val_to_name, &params ))
+    {
+        free( params.buf );
+        return NULL;
+    }
+
+    return (datalinks[link].name = params.buf);
 }
 
 void CDECL pcap_dump( unsigned char *user, const struct pcap_pkthdr_win32 *hdr, const unsigned char *packet )
@@ -105,38 +296,65 @@ void CDECL pcap_dump( unsigned char *user, const struct pcap_pkthdr_win32 *hdr,
     PCAP_CALL( dump, &params );
 }
 
-static inline WCHAR *strdupAW( const char *str )
+struct dumper
+{
+    UINT64 handle;
+};
+
+void CDECL pcap_dump_close( struct dumper *dumper )
+{
+    struct dump_close_params params;
+
+    TRACE( "%p\n", dumper );
+
+    if (!dumper) return;
+    params.handle = dumper->handle;
+    PCAP_CALL( dump, &params );
+    free( dumper );
+}
+
+static inline WCHAR *strdup_from_utf8( const char *str )
 {
     WCHAR *ret = NULL;
     if (str)
     {
-        int len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-        if ((ret = malloc( len * sizeof(WCHAR) ))) MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
+        int len = MultiByteToWideChar( CP_UTF8, 0, str, -1, NULL, 0 );
+        if ((ret = malloc( len * sizeof(WCHAR) ))) MultiByteToWideChar( CP_UTF8, 0, str, -1, ret, len );
     }
     return ret;
 }
 
-void * CDECL pcap_dump_open( struct pcap *pcap, const char *filename )
+struct dumper * CDECL pcap_dump_open( struct pcap *pcap, const char *filename )
 {
-    void *dumper;
+    struct dumper *dumper;
     WCHAR *filenameW;
-    char *unix_path;
     struct dump_open_params params;
 
     TRACE( "%p, %s\n", pcap, debugstr_a(filename) );
 
-    if (!(filenameW = strdupAW( filename ))) return NULL;
-    unix_path = wine_get_unix_file_name( filenameW );
+    if (!pcap) return NULL;
+
+    if (!(filenameW = strdup_from_utf8( filename ))) return NULL;
+    params.name = wine_get_unix_file_name( filenameW );
     free( filenameW );
-    if (!unix_path) return NULL;
+    if (!params.name) return NULL;
 
-    TRACE( "unix_path %s\n", debugstr_a(unix_path) );
+    if (!(dumper = calloc( 1, sizeof(*dumper) )))
+    {
+        HeapFree( GetProcessHeap(), 0, params.name );
+        return NULL;
+    }
+
+    TRACE( "unix_path %s\n", debugstr_a(params.name) );
 
-    params.pcap = pcap;
-    params.name = unix_path;
-    params.ret = &dumper;
-    PCAP_CALL( dump_open, &params );
-    HeapFree( GetProcessHeap(), 0, unix_path );
+    params.handle     = pcap->handle;
+    params.ret_handle = &dumper->handle;
+    if (PCAP_CALL( dump_open, &params ))
+    {
+        free( dumper );
+        dumper = NULL;
+    }
+    HeapFree( GetProcessHeap(), 0, params.name );
     return dumper;
 }
 
@@ -192,7 +410,7 @@ static IP_ADAPTER_ADDRESSES *find_adapter( IP_ADAPTER_ADDRESSES *list, const cha
     IP_ADAPTER_ADDRESSES *ret;
     WCHAR *nameW;
 
-    if (!(nameW = strdupAW( name ))) return NULL;
+    if (!(nameW = strdup_from_utf8( name ))) return NULL;
     for (ret = list; ret; ret = ret->Next)
     {
         if (!wcscmp( nameW, ret->FriendlyName )) break;
@@ -218,21 +436,22 @@ static char *build_win32_name( const char *source, const char *adapter_name )
     return ret;
 }
 
-static char *build_win32_description( const struct pcap_interface *unix_dev )
+static char *build_win32_description( const struct pcap_interface_offsets *unix_dev )
 {
-    int len = strlen(unix_dev->name) + 1;
+    const char *name = (const char *)unix_dev + unix_dev->name_offset;
+    const char *description = (const char *)unix_dev + unix_dev->description_offset;
+    int len = unix_dev->name_len + unix_dev->description_len + 1;
     char *ret;
 
-    if (unix_dev->description && unix_dev->description[0]) len += strlen(unix_dev->description) + 1;
     if ((ret = malloc( len )))
     {
-        if (unix_dev->description)
+        if (unix_dev->description_len)
         {
-            strcpy( ret, unix_dev->description );
+            strcpy( ret, description );
             strcat( ret, " " );
-            strcat( ret, unix_dev->name );
+            strcat( ret, name );
         }
-        else strcpy( ret, unix_dev->name );
+        else strcpy( ret, name );
     }
     return ret;
 }
@@ -248,7 +467,7 @@ static struct sockaddr *get_address( const IP_ADAPTER_UNICAST_ADDRESS *addr )
 static void convert_length_to_ipv6_mask( ULONG length, IN6_ADDR *mask )
 {
     unsigned int i;
-    for (i = 0; i < length / 8; i++) mask->u.Byte[i] = 0xff;
+    for (i = 0; i < length / 8 - 1; i++) mask->u.Byte[i] = 0xff;
     mask->u.Byte[i] = 0xff << (8 - length % 8);
 }
 
@@ -366,7 +585,7 @@ static struct pcap_address *build_win32_addresses( const IP_ADAPTER_ADDRESSES *a
     return ret;
 }
 
-static struct pcap_interface *build_win32_device( const struct pcap_interface *unix_dev, const char *source,
+static struct pcap_interface *build_win32_device( const struct pcap_interface_offsets *unix_dev, const char *source,
                                                   const IP_ADAPTER_ADDRESSES *adapter )
 {
     struct pcap_interface *ret;
@@ -399,33 +618,58 @@ static void add_win32_device( struct pcap_interface **list, struct pcap_interfac
 
 static int find_all_devices( const char *source, struct pcap_interface **devs, char *errbuf )
 {
-    struct pcap_interface *unix_devs, *win32_devs = NULL, *cur, *dev;
-    IP_ADAPTER_ADDRESSES *ptr, *adapters = get_adapters();
-    struct findalldevs_params params = { &unix_devs, errbuf };
+    struct pcap_interface *win32_devs = NULL, *dst;
+    const struct pcap_interface_offsets *src;
+    IP_ADAPTER_ADDRESSES *ptr, *adapters;
+    struct findalldevs_params params;
+    unsigned int len_total = 0, len = 512;
     int ret;
 
-    if (!adapters)
+    if (!(params.buf = malloc( len ))) return PCAP_ERROR;
+    params.buflen = &len;
+    params.errbuf = errbuf;
+    for (;;)
     {
-        if (errbuf) sprintf( errbuf, "Out of memory." );
-        return -1;
+        char *tmp;
+        if ((ret = PCAP_CALL( findalldevs, &params )) != STATUS_BUFFER_TOO_SMALL) break;
+        if (!(tmp = realloc( params.buf, *params.buflen )))
+        {
+            free( params.buf );
+            return PCAP_ERROR;
+        }
+        params.buf = tmp;
+    }
+    if (ret)
+    {
+        free( params.buf );
+        return ret;
     }
 
-    if (!(ret = PCAP_CALL( findalldevs, &params )))
+    if (!(adapters = get_adapters()))
     {
-        cur = unix_devs;
-        while (cur)
+        free( params.buf );
+        return PCAP_ERROR;
+    }
+
+    src = (const struct pcap_interface_offsets *)params.buf;
+    for (;;)
+    {
+        const char *name = (const char *)src + src->name_offset;
+        unsigned int len_src = sizeof(*src) + src->name_len + src->description_len;
+
+        if ((ptr = find_adapter( adapters, name )) && (dst = build_win32_device( src, source, ptr )))
         {
-            if ((ptr = find_adapter( adapters, cur->name )) && (dev = build_win32_device( cur, source, ptr )))
-            {
-                add_win32_device( &win32_devs, dev );
-            }
-            cur = cur->next;
+            add_win32_device( &win32_devs, dst );
         }
-        *devs = win32_devs;
-        PCAP_CALL( freealldevs, unix_devs );
+
+        len_total += len_src;
+        if (len_total >= *params.buflen) break;
+        src = (const struct pcap_interface_offsets *)((const char *)src + len_src);
     }
+    *devs = win32_devs;
 
     free( adapters );
+    free( params.buf );
     return ret;
 }
 
@@ -444,13 +688,13 @@ int CDECL pcap_findalldevs_ex( char *source, void *auth, struct pcap_interface *
 void CDECL pcap_free_datalinks( int *links )
 {
     TRACE( "%p\n", links );
-    PCAP_CALL( free_datalinks, links );
+    free( links );
 }
 
 void CDECL pcap_free_tstamp_types( int *types )
 {
     TRACE( "%p\n", types );
-    PCAP_CALL( free_tstamp_types, types );
+    free( types );
 }
 
 void CDECL pcap_freealldevs( struct pcap_interface *devs )
@@ -459,10 +703,12 @@ void CDECL pcap_freealldevs( struct pcap_interface *devs )
     free_devices( devs );
 }
 
-void CDECL pcap_freecode( void *program )
+void CDECL pcap_freecode( struct bpf_program *program )
 {
     TRACE( "%p\n", program );
-    PCAP_CALL( freecode, program );
+
+    if (!program) return;
+    free( program->bf_insns );
 }
 
 void * CDECL pcap_get_airpcap_handle( struct pcap *pcap )
@@ -473,23 +719,37 @@ void * CDECL pcap_get_airpcap_handle( struct pcap *pcap )
 
 int CDECL pcap_get_tstamp_precision( struct pcap *pcap )
 {
+    struct get_tstamp_precision_params params;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( get_tstamp_precision, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    return PCAP_CALL( get_tstamp_precision, &params );
 }
 
 char * CDECL pcap_geterr( struct pcap *pcap )
 {
-    char *ret;
-    struct geterr_params params = { pcap, &ret };
+    struct geterr_params params;
+
     TRACE( "%p\n", pcap );
+
+    if (!pcap) return NULL;
+    params.handle = pcap->handle;
+    params.errbuf = pcap->errbuf;
     PCAP_CALL( geterr, &params );
-    return ret;
+    return pcap->errbuf; /* FIXME: keep up-to-date */
 }
 
 int CDECL pcap_getnonblock( struct pcap *pcap, char *errbuf )
 {
-    struct getnonblock_params params = { pcap, errbuf };
+    struct getnonblock_params params;
+
     TRACE( "%p, %p\n", pcap, errbuf );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.errbuf = errbuf;
     return PCAP_CALL( getnonblock, &params );
 }
 
@@ -509,18 +769,82 @@ const char * CDECL pcap_lib_version( void )
     return lib_version;
 }
 
-int CDECL pcap_list_datalinks( struct pcap *pcap, int **buf )
+int CDECL pcap_list_datalinks( struct pcap *pcap, int **links )
 {
-    struct list_datalinks_params params = { pcap, buf };
-    TRACE( "%p, %p\n", pcap, buf );
-    return PCAP_CALL( list_datalinks, &params );
+    struct list_datalinks_params params;
+    int count = 8, *tmp;
+    NTSTATUS status;
+
+    TRACE( "%p, %p\n", pcap, links );
+
+    if (!pcap || !links) return PCAP_ERROR;
+
+    if (!(params.links = malloc( count * sizeof(*params.links) ))) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.count  = &count;
+    if ((status = PCAP_CALL( list_datalinks, &params )) == STATUS_SUCCESS)
+    {
+        if (count > 0) *links = params.links;
+        else
+        {
+            free( params.links );
+            *links = NULL;
+        }
+        return count;
+    }
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.links, count * sizeof(*tmp) )))
+    {
+        free( params.links );
+        return PCAP_ERROR;
+    }
+    params.links = tmp;
+    if (PCAP_CALL( list_datalinks, &params ))
+    {
+        free( params.links );
+        return PCAP_ERROR;
+    }
+    *links = params.links;
+    return count;
 }
 
 int CDECL pcap_list_tstamp_types( struct pcap *pcap, int **types )
 {
-    struct list_tstamp_types_params params = { pcap, types };
+    struct list_tstamp_types_params params;
+    int count = 8, *tmp;
+    NTSTATUS status;
+
     TRACE( "%p, %p\n", pcap, types );
-    return PCAP_CALL( list_tstamp_types, &params );
+
+    TRACE( "%p, %p\n", pcap, types );
+
+    if (!pcap || !types) return PCAP_ERROR;
+
+    if (!(params.types = malloc( count * sizeof(*params.types) ))) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.count  = &count;
+    if ((status = PCAP_CALL( list_tstamp_types, &params )) == STATUS_SUCCESS)
+    {
+        if (count > 0) *types = params.types;
+        else
+        {
+            free( params.types );
+            *types = NULL;
+        }
+        return count;
+    }
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.types, count * sizeof(*tmp) )))
+    {
+        free( params.types );
+        return PCAP_ERROR;
+    }
+    params.types = tmp;
+    if (PCAP_CALL( list_tstamp_types, &params ))
+    {
+        free( params.types );
+        return PCAP_ERROR;
+    }
+    *types = params.types;
+    return count;
 }
 
 char * CDECL pcap_lookupdev( char *errbuf )
@@ -531,46 +855,95 @@ char * CDECL pcap_lookupdev( char *errbuf )
     TRACE( "%p\n", errbuf );
     if (!ret)
     {
-        if (pcap_findalldevs( &devs, errbuf ) == -1 || !devs) return NULL;
+        if (pcap_findalldevs( &devs, errbuf ) == PCAP_ERROR || !devs) return NULL;
         if ((ret = malloc( strlen(devs->name) + 1 ))) strcpy( ret, devs->name );
         pcap_freealldevs( devs );
     }
     return ret;
 }
 
-int CDECL pcap_lookupnet( const char *device, unsigned int *net, unsigned int *mask, char *errbuf )
+static char *strdup_to_utf8( const WCHAR *src )
 {
-    struct lookupnet_params params = { device, net, mask, errbuf };
-    TRACE( "%s, %p, %p, %p\n", debugstr_a(device), net, mask, errbuf );
-    return PCAP_CALL( lookupnet, &params );
+    char *dst;
+    int len = WideCharToMultiByte( CP_UTF8, 0, src, -1, NULL, 0, NULL, NULL );
+    if ((dst = malloc( len ))) WideCharToMultiByte( CP_UTF8, 0, src, -1, dst, len, NULL, NULL );
+    return dst;
 }
 
-int CDECL pcap_loop( struct pcap *pcap, int count,
-                     void (CALLBACK *callback)(unsigned char *, const struct pcap_pkthdr_win32 *, const unsigned char *),
-                     unsigned char *user)
+static char *map_win32_device_name( const char *dev )
 {
-    /* FIXME: reimplement on top of pcap_next_ex */
-    FIXME( "%p, %d, %p, %p: not implemented\n", pcap, count, callback, user );
-    return -1;
+    IP_ADAPTER_ADDRESSES *ptr, *adapters = get_adapters();
+    const char *name = strchr( dev, '{' );
+    char *ret = NULL;
+
+    if (!adapters || !name) return NULL;
+    for (ptr = adapters; ptr; ptr = ptr->Next)
+    {
+        if (!strcmp( name, ptr->AdapterName ))
+        {
+            ret = strdup_to_utf8( ptr->FriendlyName );
+            break;
+        }
+    }
+    free( adapters );
+    return ret;
+}
+
+int CDECL pcap_lookupnet( const char *device, unsigned int *net, unsigned int *mask, char *errbuf )
+{
+    struct lookupnet_params params;
+    int ret;
+
+    TRACE( "%s, %p, %p, %p\n", debugstr_a(device), net, mask, errbuf );
+
+    if (!(params.device = map_win32_device_name( device )))
+    {
+        if (errbuf) sprintf( errbuf, "Unable to open the adapter." );
+        return PCAP_ERROR;
+    }
+    params.net    = net;
+    params.mask   = mask;
+    params.errbuf = errbuf;
+    ret = PCAP_CALL( lookupnet, &params );
+    free( params.device );
+    return ret;
 }
 
 int CDECL pcap_major_version( struct pcap *pcap )
 {
+    struct major_version_params params;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( major_version, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    return PCAP_CALL( major_version, &params );
 }
 
 int CDECL pcap_minor_version( struct pcap *pcap )
 {
+    struct minor_version_params params;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( minor_version, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    return PCAP_CALL( minor_version, &params );
 }
 
 int CDECL pcap_next_ex( struct pcap *pcap, struct pcap_pkthdr_win32 **hdr, const unsigned char **data )
 {
-    struct next_ex_params params = { pcap, hdr, data };
+    struct next_ex_params params;
+    int ret;
+
     TRACE( "%p, %p, %p\n", pcap, hdr, data );
-    return PCAP_CALL( next_ex, &params );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.hdr    = &pcap->hdr;
+    params.data   = data;
+    if ((ret = PCAP_CALL( next_ex, &params )) == 1) *hdr = &pcap->hdr;
+    return ret;
 }
 
 const unsigned char * CDECL pcap_next( struct pcap *pcap, struct pcap_pkthdr_win32 *hdr )
@@ -578,9 +951,12 @@ const unsigned char * CDECL pcap_next( struct pcap *pcap, struct pcap_pkthdr_win
     struct pcap_pkthdr_win32 *hdr_ptr;
     const unsigned char *data;
 
-    pcap_next_ex( pcap, &hdr_ptr, &data );
-    *hdr = *hdr_ptr;
-    return data;
+    if (pcap_next_ex( pcap, &hdr_ptr, &data ) == 1)
+    {
+        *hdr = *hdr_ptr;
+        return data;
+    }
+    return NULL;
 }
 
 int CDECL pcap_dispatch( struct pcap *pcap, int count,
@@ -588,6 +964,7 @@ int CDECL pcap_dispatch( struct pcap *pcap, int count,
                          unsigned char *user )
 {
     int processed = 0;
+
     TRACE( "%p, %d, %p, %p\n", pcap, count, callback, user );
 
     while (processed < count)
@@ -601,9 +978,9 @@ int CDECL pcap_dispatch( struct pcap *pcap, int count,
             processed++;
         else if (ret == 0)
             break;
-        else if (ret == -2)
+        else if (ret == PCAP_ERROR_BREAK)
         {
-            if (processed == 0) return -2;
+            if (processed == 0) return PCAP_ERROR_BREAK;
             break;
         }
         else
@@ -615,69 +992,89 @@ int CDECL pcap_dispatch( struct pcap *pcap, int count,
     return processed;
 }
 
-static char *strdupWA( const WCHAR *src )
+int CDECL pcap_loop( struct pcap *pcap, int count,
+                     void (CALLBACK *callback)(unsigned char *, const struct pcap_pkthdr_win32 *, const unsigned char *),
+                     unsigned char *user)
 {
-    char *dst;
-    int len = WideCharToMultiByte( CP_ACP, 0, src, -1, NULL, 0, NULL, NULL );
-    if ((dst = malloc( len ))) WideCharToMultiByte( CP_ACP, 0, src, -1, dst, len, NULL, NULL );
-    return dst;
-}
+    int processed = 0;
 
-static char *map_win32_device_name( const char *dev )
-{
-    IP_ADAPTER_ADDRESSES *ptr, *adapters = get_adapters();
-    const char *name = strchr( dev, '{' );
-    char *ret = NULL;
+    TRACE( "%p, %d, %p, %p\n", pcap, count, callback, user );
 
-    if (!adapters || !name) return NULL;
-    for (ptr = adapters; ptr; ptr = ptr->Next)
+    while (processed < count)
     {
-        if (!strcmp( name, ptr->AdapterName ))
+        struct pcap_pkthdr_win32 *hdr = NULL;
+        const unsigned char *data = NULL;
+
+        int ret = pcap_next_ex( pcap, &hdr, &data );
+
+        if (ret == 1)
+            processed++;
+        else if (ret == 0)
+            continue;
+        else if (ret == PCAP_ERROR_BREAK)
         {
-            ret = strdupWA( ptr->FriendlyName );
+            if (processed == 0) return PCAP_ERROR_BREAK;
             break;
         }
+        else
+            return ret;
+
+        callback( user, hdr, data );
     }
-    free( adapters );
-    return ret;
+
+    return processed;
 }
 
 struct pcap * CDECL pcap_create( const char *source, char *errbuf )
 {
-    char *unix_dev;
     struct pcap *ret;
+    struct create_params params;
+
     TRACE( "%s, %p\n", source, errbuf );
 
-    if (!(unix_dev = map_win32_device_name( source )))
+    if (!(ret = calloc( 1, sizeof(*ret) ))) return NULL;
+
+    if (!(params.source = map_win32_device_name( source )))
     {
         if (errbuf) sprintf( errbuf, "Unable to open the adapter." );
+        free( ret );
         return NULL;
     }
-    else
+    params.errbuf = errbuf;
+    params.handle = &ret->handle;
+    if (PCAP_CALL( create, &params ))
     {
-        struct create_params params = { unix_dev, errbuf, &ret };
-        PCAP_CALL( create, &params );
+        free( ret );
+        ret = NULL;
     }
-    free( unix_dev );
+    free( params.source );
     return ret;
 }
 
 static struct pcap *open_live( const char *source, int snaplen, int promisc, int timeout, char *errbuf )
 {
-    char *unix_dev;
     struct pcap *ret;
+    struct open_live_params params;
 
-    if (!(unix_dev = map_win32_device_name( source )))
+    if (!(ret = calloc( 1, sizeof(*ret) ))) return NULL;
+
+    if (!(params.source = map_win32_device_name( source )))
     {
         if (errbuf) sprintf( errbuf, "Unable to open the adapter." );
+        free( ret );
         return NULL;
     }
-    else
+    params.snaplen = snaplen;
+    params.promisc = promisc;
+    params.timeout = timeout;
+    params.errbuf  = errbuf;
+    params.handle  = &ret->handle;
+    if (PCAP_CALL( open_live, &params ))
     {
-        struct open_live_params params = { unix_dev, snaplen, promisc, timeout, errbuf, &ret };
-        PCAP_CALL( open_live, &params );
+        free( ret );
+        ret = NULL;
     }
-    free( unix_dev );
+    free( params.source );
     return ret;
 }
 
@@ -697,104 +1094,141 @@ struct pcap * CDECL pcap_open_live( const char *source, int snaplen, int promisc
 #define PCAP_SRC_FILE    2
 #define PCAP_SRC_IFLOCAL 3
 
-int CDECL pcap_parsesrcstr( const char *source, int *type, char *host, char *port, char *name, char *errbuf )
+int CDECL pcap_parsesrcstr( const char *source, int *ret_type, char *host, char *port, char *name, char *errbuf )
 {
-    int t = PCAP_SRC_IFLOCAL;
-    const char *p = source;
+    int type = PCAP_SRC_IFLOCAL;
+    const char *ptr = source;
 
-    FIXME( "%s, %p, %p, %p, %p, %p: partial stub\n", debugstr_a(source), type, host, port, name, errbuf );
+    FIXME( "%s, %p, %p, %p, %p, %p: partial stub\n", debugstr_a(source), ret_type, host, port, name, errbuf );
 
-    if (host)
-        *host = '\0';
-    if (port)
-        *port = '\0';
-    if (name)
-        *name = '\0';
+    if (host) *host = 0;
+    if (port) *port = 0;
+    if (name) *name = 0;
 
-    if (!strncmp(p, "rpcap://", strlen("rpcap://")))
-        p += strlen("rpcap://");
-    else if (!strncmp(p, "file://", strlen("file://")))
+    if (!strncmp( ptr, "rpcap://", strlen("rpcap://"))) ptr += strlen( "rpcap://" );
+    else if (!strncmp( ptr, "file://", strlen("file://") ))
     {
-        p += strlen("file://");
-        t = PCAP_SRC_FILE;
+        ptr += strlen( "file://" );
+        type = PCAP_SRC_FILE;
     }
 
-    if (type)
-        *type = t;
-
-    if (!*p)
+    if (ret_type) *ret_type = type;
+    if (!*ptr)
     {
-        if (errbuf)
-            sprintf(errbuf, "The name has not been specified in the source string.");
-        return -1;
+        if (errbuf) sprintf( errbuf, "The name has not been specified in the source string." );
+        return PCAP_ERROR;
     }
 
-    if (name)
-        strcpy(name, p);
-
+    if (name) strcpy( name, ptr );
     return 0;
 }
 
 int CDECL pcap_sendpacket( struct pcap *pcap, const unsigned char *buf, int size )
 {
-    struct sendpacket_params params = { pcap, buf, size };
+    struct sendpacket_params params;
+
     TRACE( "%p, %p, %d\n", pcap, buf, size );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.buf    = buf;
+    params.size   = size;
     return PCAP_CALL( sendpacket, &params );
 }
 
 int CDECL pcap_set_buffer_size( struct pcap *pcap, int size )
 {
-    struct set_buffer_size_params params = { pcap, size };
+    struct set_buffer_size_params params;
+
     TRACE( "%p, %d\n", pcap, size );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.size   = size;
     return PCAP_CALL( set_buffer_size, &params );
 }
 
 int CDECL pcap_set_datalink( struct pcap *pcap, int link )
 {
-    struct set_datalink_params params = { pcap, link };
+    struct set_datalink_params params;
+
     TRACE( "%p, %d\n", pcap, link );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.link   = link;
     return PCAP_CALL( set_datalink, &params );
 }
 
 int CDECL pcap_set_promisc( struct pcap *pcap, int enable )
 {
-    struct set_promisc_params params = { pcap, enable };
+    struct set_promisc_params params;
+
     TRACE( "%p, %d\n", pcap, enable );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.enable = enable;
     return PCAP_CALL( set_promisc, &params );
 }
 
 int CDECL pcap_set_rfmon( struct pcap *pcap, int enable )
 {
-    struct set_rfmon_params params = { pcap, enable };
+    struct set_rfmon_params params;
+
     TRACE( "%p, %d\n", pcap, enable );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.enable = enable;
     return PCAP_CALL( set_rfmon, &params );
 }
 
 int CDECL pcap_set_snaplen( struct pcap *pcap, int len )
 {
-    struct set_snaplen_params params = { pcap, len };
+    struct set_snaplen_params params;
+
     TRACE( "%p, %d\n", pcap, len );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.len    = len;
     return PCAP_CALL( set_snaplen, &params );
 }
 
 int CDECL pcap_set_timeout( struct pcap *pcap, int timeout )
 {
-    struct set_timeout_params params = { pcap, timeout };
+    struct set_timeout_params params;
+
     TRACE( "%p, %d\n", pcap, timeout );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle  = pcap->handle;
+    params.timeout = timeout;
     return PCAP_CALL( set_timeout, &params );
 }
 
 int CDECL pcap_set_tstamp_precision( struct pcap *pcap, int precision )
 {
-    struct set_tstamp_precision_params params = { pcap, precision };
+    struct set_tstamp_precision_params params;
+
     TRACE( "%p, %d\n", pcap, precision );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle    = pcap->handle;
+    params.precision = precision;
     return PCAP_CALL( set_tstamp_precision, &params );
 }
 
 int CDECL pcap_set_tstamp_type( struct pcap *pcap, int type )
 {
-    struct set_tstamp_type_params params = { pcap, type };
+    struct set_tstamp_type_params params;
+
     TRACE( "%p, %d\n", pcap, type );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    params.type   = type;
     return PCAP_CALL( set_tstamp_type, &params );
 }
 
@@ -804,40 +1238,84 @@ int CDECL pcap_setbuff( struct pcap *pcap, int size )
     return 0;
 }
 
-int CDECL pcap_setfilter( struct pcap *pcap, void *program )
+int CDECL pcap_setfilter( struct pcap *pcap, struct bpf_program *program )
 {
-    struct setfilter_params params = { pcap, program };
+    struct setfilter_params params;
+
     TRACE( "%p, %p\n", pcap, program );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle        = pcap->handle;
+    params.program_len   = program->bf_len;
+    params.program_insns = program->bf_insns;
     return PCAP_CALL( setfilter, &params );
 }
 
 int CDECL pcap_setnonblock( struct pcap *pcap, int nonblock, char *errbuf )
 {
-    struct setnonblock_params params = { pcap, nonblock, errbuf };
+    struct setnonblock_params params;
+
     TRACE( "%p, %d, %p\n", pcap, nonblock, errbuf );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle   = pcap->handle;
+    params.nonblock = nonblock;
+    params.errbuf   = errbuf;
     return PCAP_CALL( setnonblock, &params );
 }
 
 int CDECL pcap_snapshot( struct pcap *pcap )
 {
+    struct snapshot_params params;
+
     TRACE( "%p\n", pcap );
-    return PCAP_CALL( snapshot, pcap );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    return PCAP_CALL( snapshot, &params );
 }
 
-int CDECL pcap_stats( struct pcap *pcap, void *stats )
+int CDECL pcap_stats( struct pcap *pcap, struct pcap_stat_win32 *stat )
 {
-    struct stats_params params = { pcap, stats };
-    TRACE( "%p, %p\n", pcap, stats );
-    return PCAP_CALL( stats, &params );
+    struct stats_params params;
+    int ret;
+
+    TRACE( "%p, %p\n", pcap, stat );
+
+    if (!pcap) return PCAP_ERROR;
+    params.handle = pcap->handle;
+    if (!(ret = PCAP_CALL( stats, &params ))) *stat = params.stat;
+    return ret;
 }
 
 const char * CDECL pcap_statustostr( int status )
 {
-    const char *ret;
-    struct statustostr_params params = { status, &ret };
+    static char errbuf[32];
+
     TRACE( "%d\n", status );
-    PCAP_CALL( statustostr, &params );
-    return ret;
+
+    switch (status)
+    {
+    case PCAP_WARNING:
+        return "Generic warning";
+    case PCAP_WARNING_TSTAMP_TYPE_NOTSUP:
+        return "That type of time stamp is not supported by that device";
+    case PCAP_WARNING_PROMISC_NOTSUP:
+        return "That device doesn't support promiscuous mode";
+    case PCAP_ERROR:
+        return "Generic error";
+    case PCAP_ERROR_BREAK:
+        return "Loop terminated by pcap_breakloop";
+    case PCAP_ERROR_NOT_ACTIVATED:
+        return "The pcap_t has not been activated";
+    case PCAP_ERROR_ACTIVATED:
+        return "The setting can't be changed after the pcap_t is activated";
+    case PCAP_ERROR_NO_SUCH_DEVICE:
+        return "No such device exists";
+    default:
+        sprintf( errbuf, "Unknown error: %d", status );
+        return errbuf;
+    }
 }
 
 int CDECL pcap_tstamp_type_name_to_val( const char *name )
@@ -847,42 +1325,149 @@ int CDECL pcap_tstamp_type_name_to_val( const char *name )
     return PCAP_CALL( tstamp_type_name_to_val, &params );
 }
 
-const char * CDECL pcap_tstamp_type_val_to_description( int val )
+static struct
 {
-    const char *ret;
-    struct tstamp_type_val_to_description_params params = { val, &ret };
-    TRACE( "%d\n", val );
-    PCAP_CALL( tstamp_type_val_to_description, &params );
-    return ret;
+    char *name;
+    char *description;
+} tstamp_types[16];
+
+static void free_tstamp_types( void )
+{
+    unsigned int i;
+    for (i = 0; i < ARRAY_SIZE(tstamp_types); i++)
+    {
+        free( tstamp_types[i].name );
+        tstamp_types[i].name = NULL;
+        free( tstamp_types[i].description );
+        tstamp_types[i].description = NULL;
+    }
 }
 
-const char * CDECL pcap_tstamp_type_val_to_name( int val )
+const char * CDECL pcap_tstamp_type_val_to_description( int type )
 {
-    const char *ret;
-    struct tstamp_type_val_to_name_params params = { val, &ret };
-    TRACE( "%d\n", val );
-    PCAP_CALL( tstamp_type_val_to_name, &params );
-    return ret;
+    struct tstamp_type_val_to_description_params params;
+    unsigned int len = 64;
+    char *tmp;
+    NTSTATUS status;
+
+    TRACE( "%d\n", type );
+
+    if (type < 0 || type >= ARRAY_SIZE(tstamp_types))
+    {
+        WARN( "unhandled tstamp type %d\n", type );
+        return NULL;
+    }
+    if (tstamp_types[type].description) return tstamp_types[type].description;
+
+    if (!(params.buf = malloc( len ))) return NULL;
+    params.type   = type;
+    params.buflen = &len;
+    status = PCAP_CALL( tstamp_type_val_to_description, &params );
+    if (status == STATUS_SUCCESS) return (tstamp_types[type].description = params.buf);
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.buf, len )))
+    {
+        free( params.buf );
+        return NULL;
+    }
+    params.buf = tmp;
+    if (PCAP_CALL( tstamp_type_val_to_description, &params ))
+    {
+        free( params.buf );
+        return NULL;
+    }
+
+    return (tstamp_types[type].description = params.buf);
 }
 
-int CDECL wsockinit( void )
+const char * CDECL pcap_tstamp_type_val_to_name( int type )
+{
+    struct tstamp_type_val_to_name_params params;
+    unsigned int len = 32;
+    char *tmp;
+    NTSTATUS status;
+
+    TRACE( "%d\n", type );
+
+    if (type < 0 || type >= ARRAY_SIZE(tstamp_types))
+    {
+        WARN( "unhandled tstamp type %d\n", type );
+        return NULL;
+    }
+    if (tstamp_types[type].name) return tstamp_types[type].name;
+
+    if (!(params.buf = malloc( len ))) return NULL;
+    params.type   = type;
+    params.buflen = &len;
+    status = PCAP_CALL( tstamp_type_val_to_name, &params );
+    if (status == STATUS_SUCCESS) return (tstamp_types[type].name = params.buf);
+    if (status != STATUS_BUFFER_TOO_SMALL || !(tmp = realloc( params.buf, len )))
+    {
+        free( params.buf );
+        return NULL;
+    }
+    params.buf = tmp;
+    if (PCAP_CALL( tstamp_type_val_to_name, &params ))
+    {
+        free( params.buf );
+        return NULL;
+    }
+
+    return (tstamp_types[type].name = params.buf);
+}
+
+int CDECL pcap_wsockinit( void )
 {
     WSADATA wsadata;
     TRACE( "\n" );
-    if (WSAStartup( MAKEWORD(1, 1), &wsadata )) return -1;
+    if (WSAStartup( MAKEWORD(1, 1), &wsadata )) return PCAP_ERROR;
     return 0;
 }
 
+#define PCAP_CHAR_ENC_LOCAL 0
+#define PCAP_CHAR_ENC_UTF_8 1
+#define PCAP_MMAP_32BIT     2
+
+int CDECL pcap_init( unsigned int opt, char *errbuf )
+{
+    struct init_params params;
+
+    TRACE( "%u, %p\n", opt, errbuf );
+    if (opt == PCAP_CHAR_ENC_LOCAL) FIXME( "need to convert to/from local encoding\n" );
+
+    params.opt    = opt;
+    params.errbuf = errbuf;
+    return PCAP_CALL( init, &params );
+}
+
 BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, void *reserved )
 {
     switch (reason)
     {
     case DLL_PROCESS_ATTACH:
+    {
         DisableThreadLibraryCalls( hinst );
-        if (__wine_init_unix_call())
-            ERR( "No pcap support, expect problems\n" );
+        if (__wine_init_unix_call()) ERR( "No pcap support, expect problems\n" );
+        else
+        {
+            char errbuf[PCAP_ERRBUF_SIZE];
+            struct init_params params = { PCAP_CHAR_ENC_UTF_8, errbuf };
+            BOOL is_wow64;
+
+            if (PCAP_CALL( init, &params ) == PCAP_ERROR)
+                WARN( "failed to enable UTF-8 encoding %s\n", debugstr_a(errbuf) );
+            if (IsWow64Process( GetCurrentProcess(), &is_wow64 ) && is_wow64)
+            {
+                params.opt = PCAP_MMAP_32BIT;
+                if (PCAP_CALL( init, &params ) == PCAP_ERROR)
+                    WARN( "failed to enable 32-bit mmap() %s\n", debugstr_a(errbuf) );
+            }
+        }
         break;
+    }
     case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        free_datalinks();
+        free_tstamp_types();
         break;
     }
     return TRUE;
diff --git a/dlls/wpcap/wpcap.spec b/dlls/wpcap/wpcap.spec
index 8cbb44148e8..ec2e17dc16e 100644
--- a/dlls/wpcap/wpcap.spec
+++ b/dlls/wpcap/wpcap.spec
@@ -2,11 +2,9 @@
 @ stub bpf_filter
 @ stub bpf_image
 @ stub bpf_validate
-@ stub endservent
 @ stub eproto_db
-@ stub getservent
-@ stub install_bpf_program
 @ cdecl pcap_activate(ptr)
+@ cdecl pcap_bufsize(ptr)
 @ cdecl pcap_breakloop(ptr)
 @ cdecl pcap_can_set_rfmon(ptr)
 @ cdecl pcap_close(ptr)
@@ -14,17 +12,24 @@
 @ stub pcap_compile_nopcap
 @ cdecl pcap_create(str ptr)
 @ stub pcap_createsrcstr
+@ stub pcap_datalink_ext
 @ cdecl pcap_datalink(ptr)
 @ cdecl pcap_datalink_name_to_val(str)
 @ cdecl pcap_datalink_val_to_description(long)
+@ stub pcap_datalink_val_to_description_or_dlt
 @ cdecl pcap_datalink_val_to_name(long)
 @ cdecl pcap_dispatch(ptr long ptr ptr)
 @ cdecl pcap_dump(ptr ptr str)
-@ stub pcap_dump_close
+@ cdecl pcap_dump_close(ptr)
 @ stub pcap_dump_file
 @ stub pcap_dump_flush
 @ stub pcap_dump_ftell
+@ stub pcap_dump_ftell64
+@ stub pcap_dump_hopen
 @ cdecl pcap_dump_open(ptr str)
+@ stub pcap_dump_open_append
+@ stub pcap_ether_aton
+@ stub pcap_ether_hostton
 @ stub pcap_file
 @ stub pcap_fileno
 @ cdecl pcap_findalldevs(ptr ptr)
@@ -38,6 +43,10 @@
 @ cdecl pcap_geterr(ptr)
 @ stub pcap_getevent
 @ cdecl pcap_getnonblock(ptr ptr)
+@ stub pcap_hopen_offline
+@ stub pcap_hopen_offline_with_tstamp_precision
+@ cdecl pcap_init(long ptr)
+@ stub pcap_inject
 @ stub pcap_is_swapped
 @ cdecl pcap_lib_version()
 @ cdecl pcap_list_datalinks(ptr ptr)
@@ -53,15 +62,18 @@
 @ stub pcap_next_etherent
 @ cdecl pcap_next_ex(ptr ptr ptr)
 @ stub pcap_offline_filter
-@ stub pcap_offline_read
+@ stub pcap_oid_get_request
+@ stub pcap_oid_set_request
 @ cdecl pcap_open(str long long long ptr ptr)
 @ stub pcap_open_dead
+@ stub pcap_open_dead_with_tstamp_precision
 @ cdecl pcap_open_live(str long long long ptr)
 @ stub pcap_open_offline
+@ stub pcap_open_offline_with_tstamp_precision
 @ cdecl pcap_parsesrcstr(str ptr ptr ptr ptr ptr)
 @ stub pcap_perror
-@ stub pcap_read
 @ stub pcap_remoteact_accept
+@ stub pcap_remoteact_accept_ex
 @ stub pcap_remoteact_cleanup
 @ stub pcap_remoteact_close
 @ stub pcap_remoteact_list
@@ -72,6 +84,7 @@
 @ stub pcap_sendqueue_transmit
 @ cdecl pcap_set_buffer_size(ptr long)
 @ cdecl pcap_set_datalink(ptr long)
+@ stub pcap_set_immediate_mode
 @ cdecl pcap_set_promisc(ptr long)
 @ cdecl pcap_set_rfmon(ptr long)
 @ cdecl pcap_set_snaplen(ptr long)
@@ -79,6 +92,7 @@
 @ cdecl pcap_set_tstamp_precision(ptr long)
 @ cdecl pcap_set_tstamp_type(ptr long)
 @ cdecl pcap_setbuff(ptr long)
+@ stub pcap_setdirection
 @ cdecl pcap_setfilter(ptr ptr)
 @ stub pcap_setmintocopy
 @ stub pcap_setmode
@@ -93,4 +107,5 @@
 @ cdecl pcap_tstamp_type_name_to_val(str)
 @ cdecl pcap_tstamp_type_val_to_description(long)
 @ cdecl pcap_tstamp_type_val_to_name(long)
-@ cdecl wsockinit()
+@ stub pcap_version
+@ cdecl pcap_wsockinit()
diff --git a/dlls/ws2_32/Makefile.in b/dlls/ws2_32/Makefile.in
index 13937dc6ee7..fc13323b930 100644
--- a/dlls/ws2_32/Makefile.in
+++ b/dlls/ws2_32/Makefile.in
@@ -3,6 +3,7 @@ MODULE    = ws2_32.dll
 UNIXLIB   = ws2_32.so
 IMPORTLIB = ws2_32
 DELAYIMPORTS = dnsapi advapi32 iphlpapi user32
+UNIX_LIBS    = $(PTHREAD_LIBS)
 
 C_SRCS = \
 	async.c \
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index e8a04e2e714..5eb926a408b 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3823,7 +3823,7 @@ SOCKET WINAPI WSASocketW(int af, int type, int protocol,
 {
     struct afd_create_params create_params;
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING string;
+    UNICODE_STRING string = RTL_CONSTANT_STRING(L"\\Device\\Afd");
     IO_STATUS_BLOCK io;
     NTSTATUS status;
     HANDLE handle;
@@ -3901,7 +3901,6 @@ SOCKET WINAPI WSASocketW(int af, int type, int protocol,
         }
     }
 
-    RtlInitUnicodeString(&string, L"\\Device\\Afd");
     InitializeObjectAttributes(&attr, &string, (flags & WSA_FLAG_NO_HANDLE_INHERIT) ? 0 : OBJ_INHERIT, NULL, NULL);
     if ((status = NtOpenFile(&handle, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &attr,
             &io, 0, (flags & WSA_FLAG_OVERLAPPED) ? 0 : FILE_SYNCHRONOUS_IO_NONALERT)))
@@ -4035,6 +4034,12 @@ int WINAPI WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
                    LPWSAOVERLAPPED lpOverlapped,
                    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
 {
+    if (!dwBufferCount)
+    {
+        SetLastError( WSAEINVAL );
+        return -1;
+    }
+
     return WS2_recv_base(s, lpBuffers, dwBufferCount, NumberOfBytesReceived, lpFlags,
                        NULL, NULL, lpOverlapped, lpCompletionRoutine, NULL);
 }
diff --git a/dlls/ws2_32/tests/afd.c b/dlls/ws2_32/tests/afd.c
index 3215ddaef62..b07fb40fe3f 100644
--- a/dlls/ws2_32/tests/afd.c
+++ b/dlls/ws2_32/tests/afd.c
@@ -569,13 +569,7 @@ static void test_poll(void)
 
         ret = connect(client, (struct sockaddr *)&addr, sizeof(addr));
         ok(ret == -1, "got %d\n", ret);
-        todo_wine ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
-        if (WSAGetLastError() == WSAECONNABORTED)
-        {
-            ret = connect(client, (struct sockaddr *)&addr, sizeof(addr));
-            ok(ret == -1, "got %d\n", ret);
-            ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
-        }
+        ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
 
         /* A subsequent poll call returns no events, or times out. However, this
          * can't be reliably tested, as e.g. Linux will fail the connection
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index 6f2bcb73a06..17298ca4136 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -2153,7 +2153,7 @@ static void test_reuseaddr(void)
     };
 
     unsigned int rc, reuse, value;
-    struct sockaddr saddr;
+    struct sockaddr_storage saddr;
     SOCKET s1, s2, s3, s4;
     unsigned int i, j;
     int size;
@@ -2245,7 +2245,7 @@ static void test_reuseaddr(void)
 
         /* The connection is delivered to the first socket. */
         size = tests[i].addrlen;
-        s4 = accept(s1, &saddr, &size);
+        s4 = accept(s1, (struct sockaddr *)&saddr, &size);
         ok(s4 != INVALID_SOCKET, "got error %d.\n", WSAGetLastError());
 
         closesocket(s1);
@@ -2279,7 +2279,7 @@ static void test_reuseaddr(void)
         ok(!rc, "got error %d.\n", WSAGetLastError());
 
         size = tests[i].addrlen;
-        s4 = accept(s2, &saddr, &size);
+        s4 = accept(s2, (struct sockaddr *)&saddr, &size);
         todo_wine ok(s4 != INVALID_SOCKET, "got error %d.\n", WSAGetLastError());
 
         closesocket(s1);
@@ -2313,7 +2313,7 @@ static void test_reuseaddr(void)
         rc = connect(s3, tests[i].addr_loopback, tests[i].addrlen);
         ok(!rc, "got error %d.\n", WSAGetLastError());
         size = tests[i].addrlen;
-        s4 = accept(s1, &saddr, &size);
+        s4 = accept(s1, (struct sockaddr *)&saddr, &size);
 
         ok(s4 != INVALID_SOCKET, "got error %d.\n", WSAGetLastError());
 
@@ -3003,6 +3003,7 @@ static void test_WSASocket(void)
         int family, type, protocol;
         DWORD error;
         int ret_family, ret_type, ret_protocol;
+        int ret_family_alt;
     }
     tests[] =
     {
@@ -3030,14 +3031,14 @@ static void test_WSASocket(void)
         {AF_INET,   SOCK_DGRAM,  IPPROTO_TCP, WSAEPROTONOSUPPORT},
 
         /* 19 */
-        {AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP, 0, AF_INET, SOCK_STREAM, IPPROTO_TCP},
+        {AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP, 0, AF_INET, SOCK_STREAM, IPPROTO_TCP, AF_INET6 /* win11 */},
         {AF_UNSPEC, SOCK_STREAM, 0xdead,      WSAEPROTONOSUPPORT},
         {AF_UNSPEC, 0xdead,      IPPROTO_UDP, WSAESOCKTNOSUPPORT},
         {AF_UNSPEC, SOCK_STREAM, 0,           WSAEINVAL},
         {AF_UNSPEC, SOCK_DGRAM,  0,           WSAEINVAL},
         {AF_UNSPEC, 0xdead,      0,           WSAEINVAL},
-        {AF_UNSPEC, 0,           IPPROTO_TCP, 0, AF_INET, SOCK_STREAM, IPPROTO_TCP},
-        {AF_UNSPEC, 0,           IPPROTO_UDP, 0, AF_INET, SOCK_DGRAM,  IPPROTO_UDP},
+        {AF_UNSPEC, 0,           IPPROTO_TCP, 0, AF_INET, SOCK_STREAM, IPPROTO_TCP, AF_INET6 /* win11 */},
+        {AF_UNSPEC, 0,           IPPROTO_UDP, 0, AF_INET, SOCK_DGRAM,  IPPROTO_UDP, AF_INET6 /* win11 */},
         {AF_UNSPEC, 0,           0xdead,      WSAEPROTONOSUPPORT},
         {AF_UNSPEC, 0,           0,           WSAEINVAL},
     };
@@ -3061,7 +3062,9 @@ static void test_WSASocket(void)
             size = sizeof(info);
             err = getsockopt( sock, SOL_SOCKET, SO_PROTOCOL_INFOA, (char *)&info, &size );
             ok(!err, "Test %u: getsockopt failed, error %u\n", i, WSAGetLastError());
-            ok(info.iAddressFamily == tests[i].ret_family, "Test %u: got wrong family %d\n", i, info.iAddressFamily);
+            ok(info.iAddressFamily == tests[i].ret_family ||
+               (tests[i].ret_family_alt && info.iAddressFamily == tests[i].ret_family_alt),
+               "Test %u: got wrong family %d\n", i, info.iAddressFamily);
             ok(info.iSocketType == tests[i].ret_type, "Test %u: got wrong type %d\n", i, info.iSocketType);
             ok(info.iProtocol == tests[i].ret_protocol, "Test %u: got wrong protocol %d\n", i, info.iProtocol);
 
@@ -4349,13 +4352,7 @@ static void test_select(void)
 
         ret = connect(fdWrite, (const struct sockaddr *)&invalid_addr, sizeof(invalid_addr));
         ok(ret == -1, "got %d\n", ret);
-        todo_wine ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
-        if (WSAGetLastError() == WSAECONNABORTED)
-        {
-            ret = connect(fdWrite, (const struct sockaddr *)&invalid_addr, sizeof(invalid_addr));
-            ok(ret == -1, "got %d\n", ret);
-            ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
-        }
+        ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
 
         len = sizeof(id);
         id = 0xdeadbeef;
@@ -4377,13 +4374,7 @@ static void test_select(void)
         ok(!ret, "got error %u\n", WSAGetLastError());
         ret = connect(fdWrite, (const struct sockaddr *)&address, sizeof(address));
         ok(ret == -1, "got %d\n", ret);
-        todo_wine ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
-        if (WSAGetLastError() == WSAECONNABORTED)
-        {
-            ret = connect(fdWrite, (const struct sockaddr *)&address, sizeof(address));
-            ok(ret == -1, "got %d\n", ret);
-            ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
-        }
+        ok(WSAGetLastError() == WSAEWOULDBLOCK, "got error %u\n", WSAGetLastError());
 
         FD_ZERO_ALL();
         FD_SET(fdWrite, &readfds);
@@ -8317,7 +8308,6 @@ static void test_connect(void)
 
     closesocket(connector);
     closesocket(acceptor);
-    closesocket(listener);
 
     tcp_socketpair(&connector, &acceptor);
 
@@ -8377,6 +8367,30 @@ static void test_connect(void)
 
     WSACloseEvent(overlapped.hEvent);
     closesocket(connector);
+
+    /* Test connect after previous connect attempt failure. */
+    connector = socket(AF_INET, SOCK_STREAM, 0);
+    ok(connector != INVALID_SOCKET, "failed to create socket, error %u\n", WSAGetLastError());
+
+    conaddress.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    conaddress.sin_port = htons(255);
+    iret = connect(connector, (struct sockaddr *)&conaddress, sizeof(conaddress));
+    ok(iret == -1, "connection succeeded.\n");
+
+    ok(WSAGetLastError() == WSAECONNREFUSED, "got error %u\n", WSAGetLastError());
+    set_blocking( connector, FALSE );
+    iret = getsockname(listener, (struct sockaddr*)&address, &addrlen);
+    ok(!iret, "failed to get address, error %u\n", WSAGetLastError());
+
+    iret = connect(connector, (struct sockaddr *)&address, sizeof(address));
+    ok(iret == -1 && WSAGetLastError() == WSAEWOULDBLOCK, "unexpected iret %d, error %d.\n",
+            iret, WSAGetLastError());
+    acceptor = accept(listener, NULL, NULL);
+    ok(acceptor != INVALID_SOCKET, "could not accept socket error %d\n", WSAGetLastError());
+
+    closesocket(acceptor);
+    closesocket(connector);
+    closesocket(listener);
 }
 
 static void test_AcceptEx(void)
@@ -12206,6 +12220,8 @@ static void test_bind(void)
     {
         const IP_ADAPTER_UNICAST_ADDRESS *unicast_addr;
 
+        if (adapter->OperStatus != IfOperStatusUp) continue;
+
         for (unicast_addr = adapter->FirstUnicastAddress; unicast_addr != NULL; unicast_addr = unicast_addr->Next)
         {
             short family = unicast_addr->Address.lpSockaddr->sa_family;
@@ -12806,14 +12822,14 @@ static void test_empty_recv(void)
     WSASetLastError(0xdeadbeef);
     ret = WSARecv(client, NULL, 0, NULL, &flags, &overlapped, NULL);
     ok(ret == -1, "expected failure\n");
-    todo_wine ok(WSAGetLastError() == WSAEINVAL, "got error %u\n", WSAGetLastError());
+    ok(WSAGetLastError() == WSAEINVAL, "got error %u\n", WSAGetLastError());
 
     wsabuf.buf = buffer;
     wsabuf.len = 0;
     WSASetLastError(0xdeadbeef);
     ret = WSARecv(client, &wsabuf, 0, NULL, &flags, &overlapped, NULL);
     ok(ret == -1, "expected failure\n");
-    todo_wine ok(WSAGetLastError() == WSAEINVAL, "got error %u\n", WSAGetLastError());
+    ok(WSAGetLastError() == WSAEINVAL, "got error %u\n", WSAGetLastError());
 
     WSASetLastError(0xdeadbeef);
     ret = WSARecv(client, &wsabuf, 1, NULL, &flags, &overlapped, NULL);
diff --git a/dlls/ws2_32/unixlib.c b/dlls/ws2_32/unixlib.c
index 0625c5c72ce..4646e8ff26f 100644
--- a/dlls/ws2_32/unixlib.c
+++ b/dlls/ws2_32/unixlib.c
@@ -102,6 +102,7 @@
 #include "ws2_32_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(winsock);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifndef HAVE_LINUX_GETHOSTBYNAME_R_6
 static pthread_mutex_t host_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -167,6 +168,51 @@ static const int ip_protocol_map[][2] =
 
 #undef MAP
 
+static pthread_once_t hash_init_once = PTHREAD_ONCE_INIT;
+static BYTE byte_hash[256];
+
+static void init_hash(void)
+{
+    unsigned i, index;
+    NTSTATUS status;
+    BYTE *buf, tmp;
+    ULONG buf_len;
+
+    for (i = 0; i < sizeof(byte_hash); ++i)
+        byte_hash[i] = i;
+
+    buf_len = sizeof(SYSTEM_INTERRUPT_INFORMATION) * NtCurrentTeb()->Peb->NumberOfProcessors;
+    if (!(buf = malloc( buf_len )))
+    {
+        ERR( "No memory.\n" );
+        return;
+    }
+
+    for (i = 0; i < sizeof(byte_hash) - 1; ++i)
+    {
+        if (!(i % buf_len) && (status = NtQuerySystemInformation( SystemInterruptInformation, buf,
+                                                                  buf_len, &buf_len )))
+        {
+            ERR( "Failed to get random bytes.\n" );
+            free( buf );
+            return;
+        }
+        index = i + buf[i % buf_len] % (sizeof(byte_hash) - i);
+        tmp = byte_hash[index];
+        byte_hash[index] = byte_hash[i];
+        byte_hash[i] = tmp;
+    }
+    free( buf );
+}
+
+static void hash_random( BYTE *d, const BYTE *s, unsigned int len )
+{
+    unsigned int i;
+
+    for (i = 0; i < len; ++i)
+        d[i] = byte_hash[s[i]];
+}
+
 static int addrinfo_flags_from_unix( int flags )
 {
     int ws_flags = 0;
@@ -418,6 +464,7 @@ static int addrinfo_err_from_unix( int err )
         case EAI_SERVICE:   return WS_EAI_SERVICE;
         case EAI_SOCKTYPE:  return WS_EAI_SOCKTYPE;
         case EAI_SYSTEM:
+            if (errno == EBUSY) ERR_(winediag)("getaddrinfo() returned EBUSY. You may be missing a libnss plugin\n");
             /* some broken versions of glibc return EAI_SYSTEM and set errno to
              * 0 instead of returning EAI_NONAME */
             return errno ? errno_from_unix( errno ) : WS_EAI_NONAME;
@@ -889,6 +936,44 @@ static NTSTATUS unix_gethostbyaddr( void *args )
 #endif
 }
 
+static int compare_addrs_hashed( const void *a1, const void *a2, int addr_len )
+{
+    char a1_hashed[16], a2_hashed[16];
+
+    assert( addr_len <= sizeof(a1_hashed) );
+    hash_random( (BYTE *)a1_hashed, a1, addr_len );
+    hash_random( (BYTE *)a2_hashed, a2, addr_len );
+    return memcmp( a1_hashed, a2_hashed, addr_len );
+}
+
+static void sort_addrs_hashed( struct hostent *host )
+{
+    /* On Unix gethostbyname() may return IP addresses in random order on each call. On Windows the order of
+     * IP addresses is not determined as well but it is the same on consequent calls (changes after network
+     * resets and probably DNS timeout expiration).
+     * Life is Strange Remastered depends on gethostbyname() returning IP addresses in the same order to reuse
+     * the established TLS connection and avoid timeouts that happen in game when establishing multiple extra TLS
+     * connections.
+     * Just sorting the addresses would break server load balancing provided by gethostbyname(), so randomize the
+     * sort once per process. */
+    unsigned int i, j;
+    char *tmp;
+
+    pthread_once( &hash_init_once, init_hash );
+
+    for (i = 0; host->h_addr_list[i]; ++i)
+    {
+        for (j = i + 1; host->h_addr_list[j]; ++j)
+        {
+            if (compare_addrs_hashed( host->h_addr_list[j], host->h_addr_list[i], host->h_length ) < 0)
+            {
+                tmp = host->h_addr_list[j];
+                host->h_addr_list[j] = host->h_addr_list[i];
+                host->h_addr_list[i] = tmp;
+            }
+        }
+    }
+}
 
 #ifdef HAVE_LINUX_GETHOSTBYNAME_R_6
 static NTSTATUS unix_gethostbyname( void *args )
@@ -915,9 +1000,14 @@ static NTSTATUS unix_gethostbyname( void *args )
     }
 
     if (!unix_host)
+    {
         ret = (locerr < 0 ? errno_from_unix( errno ) : host_errno_from_unix( locerr ));
+    }
     else
+    {
+        sort_addrs_hashed( unix_host );
         ret = hostent_from_unix( unix_host, params->host, params->size );
+    }
 
     free( unix_buffer );
     return ret;
@@ -938,6 +1028,7 @@ static NTSTATUS unix_gethostbyname( void *args )
         return ret;
     }
 
+    sort_addrs_hashed( unix_host );
     ret = hostent_from_unix( unix_host, params->host, params->size );
 
     pthread_mutex_unlock( &host_mutex );
diff --git a/include/Makefile.in b/include/Makefile.in
index 54cbf4d955c..19dacb850ed 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -182,6 +182,9 @@ SOURCES = \
 	dciddi.h \
 	dciman.h \
 	dcommon.idl \
+	dcomp.idl \
+	dcompanimation.idl \
+	dcomptypes.idl \
 	dde.h \
 	dde.rh \
 	ddeml.h \
@@ -195,7 +198,6 @@ SOURCES = \
 	ddk/hidport.h \
 	ddk/hidsdi.h \
 	ddk/hidtypes.h \
-	ddk/imm.h \
 	ddk/mountmgr.h \
 	ddk/ndis.h \
 	ddk/ntddcdvd.h \
@@ -359,6 +361,7 @@ SOURCES = \
 	imagehlp.h \
 	ime.h \
 	imm.h \
+	immdev.h \
 	imnact.idl \
 	imnxport.idl \
 	in6addr.h \
@@ -378,6 +381,8 @@ SOURCES = \
 	iprtrmib.h \
 	iptypes.h \
 	isguids.h \
+	ivectorchangedeventargs.idl \
+	kbd.h \
 	knownfolders.h \
 	ks.h \
 	ksguid.h \
@@ -628,6 +633,7 @@ SOURCES = \
 	ras.h \
 	rasdlg.h \
 	raserror.h \
+	realtimeapiset.h \
 	reason.h \
 	regstr.h \
 	relogger.idl \
@@ -748,6 +754,7 @@ SOURCES = \
 	uiautomationcore.idl \
 	uiautomationcoreapi.h \
 	uiribbon.idl \
+	uiviewsettingsinterop.idl \
 	unexposeenums2managed.h \
 	unknwn.idl \
 	urlhist.idl \
@@ -814,13 +821,16 @@ SOURCES = \
 	windows.media.idl \
 	windows.media.speechrecognition.idl \
 	windows.media.speechsynthesis.idl \
+	windows.security.credentials.idl \
 	windows.security.cryptography.idl \
 	windows.storage.streams.idl \
 	windows.system.idl \
 	windows.system.power.idl \
+	windows.system.profile.systemmanufacturers.idl \
 	windows.system.threading.idl \
 	windows.system.userprofile.idl \
 	windows.ui.idl \
+	windows.ui.viewmanagement.idl \
 	windowscontracts.idl \
 	windowsx.h \
 	wine/afd.h \
diff --git a/include/adshlp.h b/include/adshlp.h
index 5dacbb6b821..7366c077788 100644
--- a/include/adshlp.h
+++ b/include/adshlp.h
@@ -25,7 +25,7 @@ extern "C" {
 
 BOOL    WINAPI FreeADsMem(void*);
 void*   WINAPI AllocADsMem(DWORD) __WINE_ALLOC_SIZE(1) __WINE_DEALLOC(FreeADsMem) __WINE_MALLOC;
-void*   WINAPI ReallocADsMem(void*,DWORD,DWORD) __WINE_ALLOC_SIZE(3) __WINE_DEALLOC(FreeADsMem) __WINE_MALLOC;
+void*   WINAPI ReallocADsMem(void*,DWORD,DWORD) __WINE_ALLOC_SIZE(3) __WINE_DEALLOC(FreeADsMem);
 BOOL    WINAPI FreeADsStr(WCHAR*);
 WCHAR*  WINAPI AllocADsStr(WCHAR*) __WINE_DEALLOC(FreeADsStr) __WINE_MALLOC;
 
diff --git a/include/bluetoothapis.h b/include/bluetoothapis.h
index fd90b731bf9..d3b5c941b7c 100644
--- a/include/bluetoothapis.h
+++ b/include/bluetoothapis.h
@@ -110,6 +110,49 @@ typedef struct _BLUETOOTH_SELECT_DEVICE_PARAMS {
 
 typedef BOOL (WINAPI *PFN_AUTHENTICATION_CALLBACK)(void *, PBLUETOOTH_DEVICE_INFO);
 
+#define BLUETOOTH_DEVICE_INFO BLUETOOTH_DEVICE_INFO_STRUCT
+
+typedef BLUETOOTH_DEVICE_INFO *PBLUETOOTH_DEVICE_INFO;
+
+typedef enum _BLUETOOTH_AUTHENTICATION_METHOD {
+    BLUETOOTH_AUTHENTICATION_METHOD_LEGACY = 0x1,
+    BLUETOOTH_AUTHENTICATION_METHOD_OOB,
+    BLUETOOTH_AUTHENTICATION_METHOD_NUMERIC_COMPARISON,
+    BLUETOOTH_AUTHENTICATION_METHOD_PASSKEY_NOTIFICATION,
+    BLUETOOTH_AUTHENTICATION_METHOD_PASSKEY,
+} BLUETOOTH_AUTHENTICATION_METHOD, *PBLUETOOTH_AUTHENTICATION_METHOD;
+
+typedef enum _BLUETOOTH_IO_CAPABILITY {
+    BLUETOOTH_IO_CAPABILITY_DISPLAYONLY = 0x00,
+    BLUETOOTH_IO_CAPABILITY_DISPLAYYESNO = 0x01,
+    BLUETOOTH_IO_CAPABILITY_KEYBOARDONLY = 0x02,
+    BLUETOOTH_IO_CAPABILITY_NOINPUTNOOUTPUT = 0x03,
+    BLUETOOTH_IO_CAPABILITY_UNDEFINED = 0xff,
+} BLUETOOTH_IO_CAPABILITY;
+
+typedef enum _BLUETOOTH_AUTHENTICATION_REQUIREMENTS{
+    BLUETOOTH_MITM_ProtectionNotRequired = 0,
+    BLUETOOTH_MITM_ProtectionRequired = 0x1,
+    BLUETOOTH_MITM_ProtectionNotRequiredBonding = 0x2,
+    BLUETOOTH_MITM_ProtectionRequiredBonding = 0x3,
+    BLUETOOTH_MITM_ProtectionNotRequiredGeneralBonding = 0x4,
+    BLUETOOTH_MITM_ProtectionRequiredGeneralBonding = 0x5,
+    BLUETOOTH_MITM_ProtectionNotDefined = 0xff,
+} BLUETOOTH_AUTHENTICATION_REQUIREMENTS;
+
+typedef struct _BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS {
+    BLUETOOTH_DEVICE_INFO deviceInfo;
+    BLUETOOTH_AUTHENTICATION_METHOD authenticationMethod;
+    BLUETOOTH_IO_CAPABILITY ioCapability;
+    BLUETOOTH_AUTHENTICATION_REQUIREMENTS authenticationRequirements;
+    union{
+        ULONG Numeric_Value;
+        ULONG Passkey;
+    };
+} BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS, *PBLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS;
+
+typedef BOOL (CALLBACK *PFN_AUTHENTICATION_CALLBACK_EX)(void *, BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS *);
+
 typedef struct _SDP_ELEMENT_DATA {
     SDP_TYPE type;
     SDP_SPECIFICTYPE specificType;
@@ -182,7 +225,8 @@ DWORD WINAPI BluetoothGetDeviceInfo(HANDLE, BLUETOOTH_DEVICE_INFO *);
 DWORD WINAPI BluetoothGetRadioInfo(HANDLE, PBLUETOOTH_RADIO_INFO);
 BOOL  WINAPI BluetoothIsConnectable(HANDLE);
 BOOL  WINAPI BluetoothIsDiscoverable(HANDLE);
-DWORD WINAPI BluetoothRegisterForAuthentication(BLUETOOTH_DEVICE_INFO *, HBLUETOOTH_AUTHENTICATION_REGISTRATION *, PFN_AUTHENTICATION_CALLBACK, void  *);
+DWORD WINAPI BluetoothRegisterForAuthentication(const BLUETOOTH_DEVICE_INFO *, HBLUETOOTH_AUTHENTICATION_REGISTRATION *, PFN_AUTHENTICATION_CALLBACK, void  *);
+DWORD WINAPI BluetoothRegisterForAuthenticationEx(const BLUETOOTH_DEVICE_INFO *, HBLUETOOTH_AUTHENTICATION_REGISTRATION *, PFN_AUTHENTICATION_CALLBACK_EX, void *);
 DWORD WINAPI BluetoothRemoveDevice(BLUETOOTH_ADDRESS *);
 #define BluetoothEnumAttributes BluetoothSdpEnumAttributes
 BOOL  WINAPI BluetoothSdpEnumAttributes(BYTE  *, ULONG, PFN_BLUETOOTH_ENUM_ATTRIBUTES_CALLBACK, void  *);
diff --git a/include/config.h.in b/include/config.h.in
index 0e43013a8ab..c02b6ce3ab4 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -39,6 +39,9 @@
 /* Define to 1 if you have the `dlinfo' function. */
 #undef HAVE_DLINFO
 
+/* Define to 1 if you have the <drm.h> header file. */
+#undef HAVE_DRM_H
+
 /* Define to 1 if you have the <EGL/egl.h> header file. */
 #undef HAVE_EGL_EGL_H
 
@@ -75,6 +78,13 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gbm.h> header file. */
+#undef HAVE_GBM_H
+
+/* Define to 1 if you have the `gbm_surface_create_with_modifiers2' function.
+   */
+#undef HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2
+
 /* Define to 1 if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
@@ -375,18 +385,12 @@
 /* Define to 1 if `interface_id' is a member of `sg_io_hdr_t'. */
 #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
 
-/* Define if sigaddset is supported */
-#undef HAVE_SIGADDSET
-
 /* Define to 1 if `si_fd' is a member of `siginfo_t'. */
 #undef HAVE_SIGINFO_T_SI_FD
 
 /* Define to 1 if you have the `sigprocmask' function. */
 #undef HAVE_SIGPROCMASK
 
-/* Define to 1 if the system has the type `sigset_t'. */
-#undef HAVE_SIGSET_T
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
@@ -651,6 +655,12 @@
 /* Define to 1 if you have the <valgrind/valgrind.h> header file. */
 #undef HAVE_VALGRIND_VALGRIND_H
 
+/* Define to 1 if you have the <wayland-client.h> header file. */
+#undef HAVE_WAYLAND_CLIENT_H
+
+/* Define to 1 if you have the <wayland-cursor.h> header file. */
+#undef HAVE_WAYLAND_CURSOR_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
@@ -705,6 +715,9 @@
 /* Define if you have the XKB extension */
 #undef HAVE_XKB
 
+/* Define to 1 if you have the <xkbcommon/xkbcommon.h> header file. */
+#undef HAVE_XKBCOMMON_XKBCOMMON_H
+
 /* Define if Xrender has the XRenderCreateLinearGradient function */
 #undef HAVE_XRENDERCREATELINEARGRADIENT
 
diff --git a/include/d2d1_1.idl b/include/d2d1_1.idl
index b60064be3b6..9da56050ecb 100644
--- a/include/d2d1_1.idl
+++ b/include/d2d1_1.idl
@@ -157,7 +157,7 @@ typedef enum D2D1_LAYER_OPTIONS1
     D2D1_LAYER_OPTIONS1_FORCE_DWORD = 0xffffffff,
 } D2D1_LAYER_OPTIONS1;
 
-typedef struct D2D1_PROPERTY_BINDING D2D1_PROPERTY_BINDING;
+struct D2D1_PROPERTY_BINDING;
 typedef D2D_MATRIX_4X4_F D2D1_MATRIX_4X4_F;
 
 typedef enum D2D1_PROPERTY_TYPE
@@ -936,14 +936,14 @@ interface ID2D1Factory1 : ID2D1Factory
     HRESULT RegisterEffectFromStream(
         [in] REFCLSID effect_id,
         [in] IStream *property_xml,
-        [in, size_is(binding_count)] const D2D1_PROPERTY_BINDING *bindings,
+        [in, size_is(binding_count)] const struct D2D1_PROPERTY_BINDING *bindings,
         [in] UINT32 binding_count,
         [in] PD2D1_EFFECT_FACTORY effect_factory
     );
     HRESULT RegisterEffectFromString(
         [in] REFCLSID effect_id,
         [in] const WCHAR *property_xml,
-        [in, size_is(binding_count)] const D2D1_PROPERTY_BINDING *bindings,
+        [in, size_is(binding_count)] const struct D2D1_PROPERTY_BINDING *bindings,
         [in] UINT32 binding_count,
         [in] PD2D1_EFFECT_FACTORY effect_factory
     );
diff --git a/include/d3d12.idl b/include/d3d12.idl
index 082a436c9ec..816ff283ee8 100644
--- a/include/d3d12.idl
+++ b/include/d3d12.idl
@@ -66,6 +66,7 @@ const UINT D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT = 256;
 const UINT D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT = 4194304;
 const UINT D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT = 65536;
 const UINT D3D12_RAW_UAV_SRV_BYTE_ALIGNMENT = 16;
+const UINT D3D12_SDK_VERSION = 4;
 const UINT D3D12_SMALL_MSAA_RESOURCE_PLACEMENT_ALIGNMENT = 65536;
 const UINT D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT = 4096;
 const UINT D3D12_STANDARD_MAXIMUM_ELEMENT_ALIGNMENT_BYTE_MULTIPLE = 4;
@@ -2589,3 +2590,55 @@ typedef HRESULT (__stdcall *PFN_D3D12_GET_DEBUG_INTERFACE)(REFIID iid, void **de
 
 [local] HRESULT __stdcall D3D12EnableExperimentalFeatures(UINT feature_count,
         const IID *iids, void *configurations, UINT *configurations_sizes);
+
+cpp_quote("DEFINE_GUID(CLSID_D3D12Debug,                     0xf2352aeb, 0xdd84, 0x49fe, 0xb9, 0x7b, 0xa9, 0xdc, 0xfd, 0xcc, 0x1b, 0x4f);")
+cpp_quote("DEFINE_GUID(CLSID_D3D12Tools,                     0xe38216b1, 0x3c8c, 0x4833, 0xaa, 0x09, 0x0a, 0x06, 0xb6, 0x5d, 0x96, 0xc8);")
+cpp_quote("DEFINE_GUID(CLSID_D3D12DeviceRemovedExtendedData, 0x4a75bbc4, 0x9ff4, 0x4ad8, 0x9f, 0x18, 0xab, 0xae, 0x84, 0xdc, 0x5f, 0xf2);")
+cpp_quote("DEFINE_GUID(CLSID_D3D12SDKConfiguration,          0x7cda6aca, 0xa03e, 0x49c8, 0x94, 0x58, 0x03, 0x34, 0xd2, 0x0e, 0x07, 0xce);")
+
+typedef enum D3D12_DRED_ENABLEMENT
+{
+    D3D12_DRED_ENABLEMENT_SYSTEM_CONTROLLED = 0,
+    D3D12_DRED_ENABLEMENT_FORCED_OFF        = 1,
+    D3D12_DRED_ENABLEMENT_FORCED_ON         = 2,
+} D3D12_DRED_ENABLEMENT;
+
+typedef HRESULT (__stdcall *PFN_D3D12_GET_INTERFACE)(REFCLSID clsid, REFIID iid, void **debug);
+
+[local] HRESULT __stdcall D3D12GetInterface(REFCLSID clsid, REFIID iid, void **debug);
+
+[
+    uuid(7071e1f0-e84b-4b33-974f-12fa49de65c5),
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ID3D12Tools : IUnknown
+{
+    void EnableShaderInstrumentation(BOOL enable);
+    BOOL ShaderInstrumentationEnabled();
+}
+
+[
+    uuid(82bc481c-6b9b-4030-aedb-7ee3d1df1e63),
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ID3D12DeviceRemovedExtendedDataSettings : IUnknown
+{
+    void SetAutoBreadcrumbsEnablement(D3D12_DRED_ENABLEMENT enablement);
+    void SetPageFaultEnablement(D3D12_DRED_ENABLEMENT enablement);
+    void SetWatsonDumpEnablement(D3D12_DRED_ENABLEMENT enablement);
+};
+
+[
+    uuid(e9eb5314-33aa-42b2-a718-d77f58b1f1c7),
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ID3D12SDKConfiguration : IUnknown
+{
+    HRESULT SetSDKVersion(UINT version, const char *path);
+}
diff --git a/include/d3dx10core.h b/include/d3dx10core.h
index cca9052cc13..c8c5e97505f 100644
--- a/include/d3dx10core.h
+++ b/include/d3dx10core.h
@@ -287,8 +287,8 @@ HRESULT WINAPI D3DX10CreateDevice(IDXGIAdapter *adapter, D3D10_DRIVER_TYPE drive
 HRESULT WINAPI D3DX10CreateDeviceAndSwapChain(IDXGIAdapter *adapter, D3D10_DRIVER_TYPE driver_type,
         HMODULE swrast, unsigned int flags, DXGI_SWAP_CHAIN_DESC *desc, IDXGISwapChain **swapchain,
         ID3D10Device **device);
-typedef interface ID3D10Device1 ID3D10Device1;
-HRESULT WINAPI D3DX10GetFeatureLevel1(ID3D10Device *device, ID3D10Device1 **device1);
+interface ID3D10Device1;
+HRESULT WINAPI D3DX10GetFeatureLevel1(ID3D10Device *device, interface ID3D10Device1 **device1);
 HRESULT WINAPI D3DX10CreateFontIndirectA(ID3D10Device *device, const D3DX10_FONT_DESCA *desc, ID3DX10Font **font);
 HRESULT WINAPI D3DX10CreateFontIndirectW(ID3D10Device *device, const D3DX10_FONT_DESCW *desc, ID3DX10Font **font);
 HRESULT WINAPI D3DX10CreateFontA(ID3D10Device *device, INT height, UINT width, UINT weight,
diff --git a/include/dbghelp.h b/include/dbghelp.h
index e56d8de0d5d..fda8fefa35f 100644
--- a/include/dbghelp.h
+++ b/include/dbghelp.h
@@ -510,6 +510,7 @@ DWORD64 WINAPI SymLoadModuleEx(HANDLE, HANDLE, PCSTR, PCSTR, DWORD64, DWORD,
 DWORD64 WINAPI SymLoadModuleExW(HANDLE, HANDLE, PCWSTR, PCWSTR, DWORD64, DWORD,
                                 PMODLOAD_DATA, DWORD);
 BOOL    WINAPI SymUnloadModule64(HANDLE, DWORD64);
+BOOL    WINAPI SymRefreshModuleList(HANDLE);
 
 /*************************
  *    Symbol Handling    *
@@ -1098,6 +1099,7 @@ typedef enum
 
 #ifdef __WINESRC__
     SYMOPT_EX_WINE_NATIVE_MODULES = 1000,
+    SYMOPT_EX_WINE_MODULE_REAL_PATH,
 #endif
 } IMAGEHLP_EXTENDED_OPTIONS;
 
@@ -1226,7 +1228,6 @@ BOOL    WINAPI SymGetSymPrevW(HANDLE, PIMAGEHLP_SYMBOLW);
 DWORD   WINAPI SymLoadModule(HANDLE, HANDLE, PCSTR, PCSTR, DWORD, DWORD);
 BOOL    WINAPI SymRegisterCallback(HANDLE, PSYMBOL_REGISTERED_CALLBACK, PVOID);
 BOOL    WINAPI SymRegisterFunctionEntryCallback(HANDLE, PSYMBOL_FUNCENTRY_CALLBACK, PVOID);
-BOOL    WINAPI SymRefreshModuleList(HANDLE);
 BOOL    WINAPI SymUnDName(PIMAGEHLP_SYMBOL, PSTR, DWORD);
 BOOL    WINAPI SymUnloadModule(HANDLE, DWORD);
 
diff --git a/include/dcomp.idl b/include/dcomp.idl
new file mode 100644
index 00000000000..d5a9c362024
--- /dev/null
+++ b/include/dcomp.idl
@@ -0,0 +1,442 @@
+/*
+ * Copyright 2023 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "objidl.idl";
+import "d2dbasetypes.h";
+import "dcommon.idl";
+import "dcompanimation.idl";
+import "dcomptypes.idl";
+import "unknwn.idl";
+
+typedef struct _D3DMATRIX
+{
+    float m[4][4];
+} D3DMATRIX;
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(bb8a4953-2c99-4f5a-96f5-4819027fa3ac)
+]
+interface IDCompositionSurface : IUnknown
+{
+    HRESULT BeginDraw([in, optional] const RECT *rect, [in] REFIID iid, [out] void **object, [out] POINT *offset);
+    HRESULT EndDraw();
+    HRESULT SuspendDraw();
+    HRESULT ResumeDraw();
+    HRESULT Scroll([in, optional] const RECT *scroll, [in, optional] const RECT *clip, [in] int offset_x, [in] int offset_y);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(ae471c51-5f53-4a24-8d3e-d0c39c30b3f0)
+]
+interface IDCompositionVirtualSurface : IDCompositionSurface
+{
+    HRESULT Resize([in] UINT width, [in] UINT height);
+    HRESULT Trim([in, optional, size_is(count)] const RECT *rectangles, [in] UINT count);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(e334bc12-3937-4e02-85eb-fcf4eb30d2c8)
+]
+interface IDCompositionSurfaceFactory : IUnknown
+{
+    HRESULT CreateSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionSurface **surface);
+    HRESULT CreateVirtualSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionVirtualSurface **surface);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(64ac3703-9d3f-45ec-a109-7cac0e7a13a7)
+]
+interface IDCompositionClip : IUnknown
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(9842ad7d-d9cf-4908-aed7-48b51da5e7c2)
+]
+interface IDCompositionRectangleClip : IDCompositionClip
+{
+    HRESULT SetLeft([in] float left);
+    HRESULT SetLeftAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTop([in] float top);
+    HRESULT SetTopAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetRight([in] float right);
+    HRESULT SetRightAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottom([in] float bottom);
+    HRESULT SetBottomAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopLeftRadiusX([in] float radius);
+    HRESULT SetTopLeftRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopLeftRadiusY([in] float radius);
+    HRESULT SetTopLeftRadiusYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopRightRadiusX([in] float radius);
+    HRESULT SetTopRightRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopRightRadiusY([in] float radius);
+    HRESULT SetTopRightRadiusYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomLeftRadiusX([in] float radius);
+    HRESULT SetBottomLeftRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomLeftRadiusY([in] float radius);
+    HRESULT SetBottomLeftRadiusYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomRightRadiusX([in] float radius);
+    HRESULT SetBottomRightRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomRightRadiusY([in] float radius);
+    HRESULT SetBottomRightRadiusYAnimation([in] IDCompositionAnimation *animation);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(ec81b08f-bfcb-4e8d-b193-a915587999e8)
+]
+interface IDCompositionEffect : IUnknown
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(71185722-246b-41f2-aad1-0443f7f4bfc2)
+]
+interface IDCompositionTransform3D : IDCompositionEffect
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(a7929a74-e6b2-4bd6-8b95-4040119ca34d)
+]
+interface IDCompositionEffectGroup : IDCompositionEffect
+{
+    HRESULT SetOpacity([in] float opacity);
+    HRESULT SetOpacityAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTransform3D([in, optional] IDCompositionTransform3D *transform);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(91636d4b-9ba1-4532-aaf7-e3344994d788)
+]
+interface IDCompositionTranslateTransform3D : IDCompositionTransform3D
+{
+    HRESULT SetOffsetX([in] float offset);
+    HRESULT SetOffsetXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetY([in] float offset);
+    HRESULT SetOffsetYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetZ([in] float offset);
+    HRESULT SetOffsetZAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(2a9e9ead-364b-4b15-a7c4-a1997f78b389)
+]
+interface IDCompositionScaleTransform3D : IDCompositionTransform3D
+{
+    HRESULT SetScaleX([in] float scale);
+    HRESULT SetScaleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleY([in] float scale);
+    HRESULT SetScaleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleZ([in] float scale);
+    HRESULT SetScaleZAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterZ([in] float center);
+    HRESULT SetCenterZAnimation([in] IDCompositionAnimation *animation);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(d8f5b23f-d429-4a91-b55a-d2f45fd75b18)
+]
+interface IDCompositionRotateTransform3D : IDCompositionTransform3D
+{
+    HRESULT SetScaleX([in] float scale);
+    HRESULT SetScaleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleY([in] float scale);
+    HRESULT SetScaleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleZ([in] float scale);
+    HRESULT SetScaleZAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterZ([in] float center);
+    HRESULT SetCenterZAnimation([in] IDCompositionAnimation *animation);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(4b3363f0-643b-41b7-b6e0-ccf22d34467c)
+]
+interface IDCompositionMatrixTransform3D : IDCompositionTransform3D
+{
+    /* C++ method: HRESULT SetMatrix(const D3DMATRIX &matrix); Use pointer instead of reference */
+    HRESULT SetMatrix([in] const D3DMATRIX *matrix);
+    HRESULT SetMatrixElement([in] int row, [in] int column, [in] float value);
+    HRESULT SetMatrixElementAnimation([in] int row, [in] int column, [in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(fd55faa7-37e0-4c20-95d2-9be45bc33f55)
+]
+interface IDCompositionTransform : IDCompositionTransform3D
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(71fde914-40ef-45ef-bd51-68b037c339f9)
+]
+interface IDCompositionScaleTransform : IDCompositionTransform
+{
+    HRESULT SetScaleX([in] float scale);
+    HRESULT SetScaleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleY([in] float scale);
+    HRESULT SetScaleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(641ed83c-ae96-46c5-90dc-32774cc5c6d5)
+]
+interface IDCompositionRotateTransform : IDCompositionTransform
+{
+    HRESULT SetAngle([in] float angle);
+    HRESULT SetAngleAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center_x);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center_y);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(e57aa735-dcdb-4c72-9c61-0591f58889ee)
+]
+interface IDCompositionSkewTransform : IDCompositionTransform
+{
+    HRESULT SetAngleX([in] float angle);
+    HRESULT SetAngleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetAngleY([in] float angle);
+    HRESULT SetAngleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(16cdff07-c503-419c-83f2-0965c7af1fa6)
+]
+interface IDCompositionMatrixTransform : IDCompositionTransform
+{
+    /* C++ method: HRESULT SetMatrix(const D2D_MATRIX_3X2_F &matrix); Use pointer instead of reference */
+    HRESULT SetMatrix([in] const D2D_MATRIX_3X2_F *matrix);
+    HRESULT SetMatrixElement([in] int row, [in] int column, [in] float value);
+    HRESULT SetMatrixElementAnimation([in] int row, [in] int column, [in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(06791122-c6f0-417d-8323-269e987f5954)
+]
+interface IDCompositionTranslateTransform : IDCompositionTransform
+{
+    HRESULT SetOffsetX([in] float offset);
+    HRESULT SetOffsetXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetY([in] float offset);
+    HRESULT SetOffsetYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    object,
+    uuid(4d93059d-097b-4651-9a60-f0f25116e2f3),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionVisual : IUnknown
+{
+    HRESULT SetOffsetX([in] float offset_x);
+    HRESULT SetOffsetXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetY([in] float offset_y);
+    HRESULT SetOffsetYAnimation([in] IDCompositionAnimation *animation);
+    /* C++ method: HRESULT SetTransform(const D2D_MATRIX_3X2_F &matrix); Use pointer instead of reference */
+    HRESULT SetTransform([in] const D2D_MATRIX_3X2_F *matrix);
+    HRESULT SetTransformObject([in] IDCompositionTransform *transform);
+    HRESULT SetTransformParent([in] IDCompositionVisual *visual);
+    HRESULT SetEffect([in] IDCompositionEffect *effect);
+    HRESULT SetBitmapInterpolationMode([in] enum DCOMPOSITION_BITMAP_INTERPOLATION_MODE interpolation_mode);
+    HRESULT SetBorderMode([in] enum DCOMPOSITION_BORDER_MODE border_mode);
+    /* C++ method: HRESULT SetClip(const D2D_RECT_F &rect); Use pointer instead of reference */
+    HRESULT SetClip([in] const D2D_RECT_F *rect);
+    HRESULT SetClipObject([in] IDCompositionClip *clip);
+    HRESULT SetContent([in] IUnknown *content);
+    HRESULT AddVisual([in] IDCompositionVisual *visual, [in] BOOL insert_above, [in] IDCompositionVisual *reference_visual);
+    HRESULT RemoveVisual([in] IDCompositionVisual *visual);
+    HRESULT RemoveAllVisuals();
+    HRESULT SetCompositeMode([in] enum DCOMPOSITION_COMPOSITE_MODE composite_mode);
+}
+
+[
+    object,
+    uuid(e8de1639-4331-4b26-bc5f-6a321d347a85),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionVisual2 : IDCompositionVisual
+{
+    HRESULT SetOpacityMode([in] enum DCOMPOSITION_OPACITY_MODE opacity_mode);
+    HRESULT SetBackFaceVisibility([in] enum DCOMPOSITION_BACKFACE_VISIBILITY visibility);
+}
+
+[
+    object,
+    uuid(eacdd04c-117e-4e17-88f4-d1b12b0e3d89),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionTarget : IUnknown
+{
+    HRESULT SetRoot([in] IDCompositionVisual *visual);
+}
+
+[
+    object,
+    uuid(c37ea93a-e7aa-450d-b16f-9746cb0407f3),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionDevice : IUnknown
+{
+    HRESULT Commit();
+    HRESULT WaitForCommitCompletion();
+    HRESULT GetFrameStatistics([out] DCOMPOSITION_FRAME_STATISTICS *statistics);
+    HRESULT CreateTargetForHwnd([in] HWND hwnd, [in] BOOL topmost, [out] IDCompositionTarget **target);
+    HRESULT CreateVisual([out] IDCompositionVisual **visual);
+    HRESULT CreateSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionSurface **surface);
+    HRESULT CreateVirtualSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionVirtualSurface **surface);
+    HRESULT CreateSurfaceFromHandle([in] HANDLE handle, [out] IUnknown **surface);
+    HRESULT CreateSurfaceFromHwnd([in] HWND hwnd, [out] IUnknown **surface);
+    HRESULT CreateTranslateTransform([out] IDCompositionTranslateTransform **transform);
+    HRESULT CreateScaleTransform([out] IDCompositionScaleTransform **transform);
+    HRESULT CreateRotateTransform([out] IDCompositionRotateTransform **transform);
+    HRESULT CreateSkewTransform([out] IDCompositionSkewTransform **transform);
+    HRESULT CreateMatrixTransform([out] IDCompositionMatrixTransform **transform);
+    HRESULT CreateTransformGroup([in, size_is(elements)] IDCompositionTransform **transforms, [in] UINT elements, [out] IDCompositionTransform **transform_group);
+    HRESULT CreateTranslateTransform3D([out] IDCompositionTranslateTransform3D **transform_3d);
+    HRESULT CreateScaleTransform3D([out] IDCompositionScaleTransform3D **transform_3d);
+    HRESULT CreateRotateTransform3D([out] IDCompositionRotateTransform3D **transform_3d);
+    HRESULT CreateMatrixTransform3D([out] IDCompositionMatrixTransform3D **transform_3d);
+    HRESULT CreateTransform3DGroup([in, size_is(elements)] IDCompositionTransform3D **transforms_3d, [in] UINT elements, [out] IDCompositionTransform3D **transform_3d_group);
+    HRESULT CreateEffectGroup([out] IDCompositionEffectGroup **effect_group);
+    HRESULT CreateRectangleClip([out] IDCompositionRectangleClip **clip);
+    HRESULT CreateAnimation([out] IDCompositionAnimation **animation);
+    HRESULT CheckDeviceState([out] BOOL *valid);
+}
+
+[
+    object,
+    uuid(75f6468d-1b8e-447c-9bc6-75fea80b5b25),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionDevice2 : IUnknown
+{
+    HRESULT Commit();
+    HRESULT WaitForCommitCompletion();
+    HRESULT GetFrameStatistics([out] DCOMPOSITION_FRAME_STATISTICS *statistics);
+    HRESULT CreateVisual([out] IDCompositionVisual2 **visual);
+    HRESULT CreateSurfaceFactory([in] IUnknown *rendering_device, [out] IDCompositionSurfaceFactory **surface_factory);
+    HRESULT CreateSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionSurface **surface);
+    HRESULT CreateVirtualSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionVirtualSurface **surface);
+    HRESULT CreateTranslateTransform([out] IDCompositionTranslateTransform **transform);
+    HRESULT CreateScaleTransform([out] IDCompositionScaleTransform **transform);
+    HRESULT CreateRotateTransform([out] IDCompositionRotateTransform **transform);
+    HRESULT CreateSkewTransform([out] IDCompositionSkewTransform **transform);
+    HRESULT CreateMatrixTransform([out] IDCompositionMatrixTransform **transform);
+    HRESULT CreateTransformGroup([in, size_is(elements)] IDCompositionTransform **transforms, [in] UINT elements, [out] IDCompositionTransform **transform_group);
+    HRESULT CreateTranslateTransform3D([out] IDCompositionTranslateTransform3D **transform_3d);
+    HRESULT CreateScaleTransform3D([out] IDCompositionScaleTransform3D **transform_3d);
+    HRESULT CreateRotateTransform3D([out] IDCompositionRotateTransform3D **transform_3d);
+    HRESULT CreateMatrixTransform3D([out] IDCompositionMatrixTransform3D **transform_3d);
+    HRESULT CreateTransform3DGroup([in, size_is(elements)] IDCompositionTransform3D **transforms_3d, [in] UINT elements, [out] IDCompositionTransform3D **transform_3d_group);
+    HRESULT CreateEffectGroup([out] IDCompositionEffectGroup **effect_group);
+    HRESULT CreateRectangleClip([out] IDCompositionRectangleClip **clip);
+    HRESULT CreateAnimation([out] IDCompositionAnimation **animation);
+}
+
+[
+    object,
+    uuid(5f4633fe-1e08-4cb8-8c75-ce24333f5602),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionDesktopDevice : IDCompositionDevice2
+{
+    HRESULT CreateTargetForHwnd([in] HWND hwnd, [in] BOOL topmost, [out] IDCompositionTarget **target);
+    HRESULT CreateSurfaceFromHandle([in] HANDLE handle, [out] IUnknown **surface);
+    HRESULT CreateSurfaceFromHwnd([in] HWND hwnd, [out] IUnknown **surface);
+}
+
+cpp_quote("STDAPI DCompositionCreateDevice(IDXGIDevice *dxgi_device, REFIID iid, void **device);")
+cpp_quote("STDAPI DCompositionCreateDevice2(IUnknown *rendering_device, REFIID iid, void **device);")
diff --git a/include/dcompanimation.idl b/include/dcompanimation.idl
new file mode 100644
index 00000000000..dac6a2615ed
--- /dev/null
+++ b/include/dcompanimation.idl
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2023 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "wtypes.idl";
+import "unknwn.idl";
+
+[
+    local,
+    object,
+    uuid(cbfd91d9-51b2-45e4-b3de-d19ccfb863c5),
+    pointer_default(unique)
+]
+interface IDCompositionAnimation : IUnknown
+{
+    HRESULT Reset();
+    HRESULT SetAbsoluteBeginTime([in] LARGE_INTEGER time);
+    HRESULT AddCubic([in] double offset, [in] float constant_coefficient, [in] float linear_coefficient, [in] float quadratic_coefficient, [in] float cubic_coefficient);
+    HRESULT AddSinusoidal([in] double offset, [in] float bias, [in] float amplitude, [in] float frequency, [in] float phase);
+    HRESULT AddRepeat([in] double offset, [in] double duration);
+    HRESULT End([in] double offset, [in] float value);
+};
diff --git a/include/dcomptypes.idl b/include/dcomptypes.idl
new file mode 100644
index 00000000000..2ee6b17cde3
--- /dev/null
+++ b/include/dcomptypes.idl
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2023 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "dxgitype.idl";
+import "dxgi1_5.idl";
+
+enum DCOMPOSITION_BITMAP_INTERPOLATION_MODE
+{
+    DCOMPOSITION_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
+    DCOMPOSITION_BITMAP_INTERPOLATION_MODE_LINEAR           = 1,
+    DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT          = 0xffffffff
+};
+
+enum DCOMPOSITION_BORDER_MODE
+{
+    DCOMPOSITION_BORDER_MODE_SOFT    = 0,
+    DCOMPOSITION_BORDER_MODE_HARD    = 1,
+    DCOMPOSITION_BORDER_MODE_INHERIT = 0xffffffff
+};
+
+enum DCOMPOSITION_COMPOSITE_MODE
+{
+    DCOMPOSITION_COMPOSITE_MODE_SOURCE_OVER        = 0,
+    DCOMPOSITION_COMPOSITE_MODE_DESTINATION_INVERT = 1,
+    DCOMPOSITION_COMPOSITE_MODE_MIN_BLEND          = 2,
+    DCOMPOSITION_COMPOSITE_MODE_INHERIT            = 0xffffffff
+};
+
+enum DCOMPOSITION_BACKFACE_VISIBILITY
+{
+    DCOMPOSITION_BACKFACE_VISIBILITY_VISIBLE = 0,
+    DCOMPOSITION_BACKFACE_VISIBILITY_HIDDEN  = 1,
+    DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT = 0xffffffff
+};
+
+enum DCOMPOSITION_OPACITY_MODE
+{
+    DCOMPOSITION_OPACITY_MODE_LAYER    = 0,
+    DCOMPOSITION_OPACITY_MODE_MULTIPLY = 1,
+    DCOMPOSITION_OPACITY_MODE_INHERIT  = 0xffffffff
+};
+
+enum DCOMPOSITION_DEPTH_MODE
+{
+    DCOMPOSITION_DEPTH_MODE_TREE    = 0,
+    DCOMPOSITION_DEPTH_MODE_SPATIAL = 1,
+    DCOMPOSITION_DEPTH_MODE_SORTED  = 3,
+    DCOMPOSITION_DEPTH_MODE_INHERIT = 0xffffffff
+};
+
+typedef struct
+{
+    LARGE_INTEGER lastFrameTime;
+    DXGI_RATIONAL currentCompositionRate;
+    LARGE_INTEGER currentTime;
+    LARGE_INTEGER timeFrequency;
+    LARGE_INTEGER nextEstimatedFrameTime;
+} DCOMPOSITION_FRAME_STATISTICS;
+
+cpp_quote("#define COMPOSITIONOBJECT_READ       0x0001L")
+cpp_quote("#define COMPOSITIONOBJECT_WRITE      0x0002L")
+cpp_quote("#define COMPOSITIONOBJECT_ALL_ACCESS (COMPOSITIONOBJECT_READ | COMPOSITIONOBJECT_WRITE)")
diff --git a/include/ddk/d3dkmthk.h b/include/ddk/d3dkmthk.h
index b65fcb8c9c6..69239a45fd9 100644
--- a/include/ddk/d3dkmthk.h
+++ b/include/ddk/d3dkmthk.h
@@ -667,6 +667,20 @@ typedef struct _D3DKMT_ESCAPE
     D3DKMT_HANDLE      hContext;
 } D3DKMT_ESCAPE;
 
+typedef struct _D3DKMT_ADAPTERINFO
+{
+  D3DKMT_HANDLE hAdapter;
+  LUID          AdapterLuid;
+  ULONG         NumOfSources;
+  BOOL          bPrecisePresentRegionsPreferred;
+} D3DKMT_ADAPTERINFO;
+
+typedef struct _D3DKMT_ENUMADAPTERS2
+{
+  ULONG               NumAdapters;
+  D3DKMT_ADAPTERINFO *pAdapters;
+} D3DKMT_ENUMADAPTERS2;
+
 #ifdef __cplusplus
 extern "C"
 {
diff --git a/include/difxapi.h b/include/difxapi.h
index 21d43c90de6..3e0284509e2 100644
--- a/include/difxapi.h
+++ b/include/difxapi.h
@@ -23,6 +23,19 @@
 extern "C" {
 #endif
 
+#define ERROR_DEPENDENT_APPLICATIONS_EXIST  0xe0000300
+#define ERROR_NO_DEVICE_ID                  0xe0000301
+#define ERROR_DRIVER_PACKAGE_NOT_IN_STORE   0xe0000302
+#define ERROR_MISSING_FILE                  0xe0000303
+#define ERROR_INVALID_CATALOG_DATA          0xe0000304
+
+#define DRIVER_PACKAGE_REPAIR                   0x00000001
+#define DRIVER_PACKAGE_SILENT                   0x00000002
+#define DRIVER_PACKAGE_FORCE                    0x00000004
+#define DRIVER_PACKAGE_ONLY_IF_DEVICE_PRESENT   0x00000008
+#define DRIVER_PACKAGE_LEGACY_MODE              0x00000010
+#define DRIVER_PACKAGE_DELETE_FILES             0x00000020
+
 typedef struct _INSTALLERINFO_A
 {
     PSTR pApplicationId;
@@ -49,8 +62,8 @@ typedef enum _DIFXAPI_LOG
     DIFXAPI_ERROR,
 } DIFXAPI_LOG;
 
-typedef VOID (CALLBACK *DIFXAPILOGCALLBACK_A)(DIFXAPI_LOG,DWORD,PCSTR,PVOID);
-typedef VOID (CALLBACK *DIFXAPILOGCALLBACK_W)(DIFXAPI_LOG,DWORD,PCWSTR,PVOID);
+typedef void (__cdecl *DIFXAPILOGCALLBACK_A)(DIFXAPI_LOG, DWORD, const char *, void *);
+typedef void (__cdecl *DIFXAPILOGCALLBACK_W)(DIFXAPI_LOG, DWORD, const WCHAR *, void *);
 typedef VOID (CALLBACK *DIFXLOGCALLBACK_A)(DIFXAPI_LOG,DWORD,PCSTR,PVOID);
 typedef VOID (CALLBACK *DIFXLOGCALLBACK_W)(DIFXAPI_LOG,DWORD,PCWSTR,PVOID);
 
diff --git a/include/dwrite_3.idl b/include/dwrite_3.idl
index 845754f6e3f..e67c8ab6364 100644
--- a/include/dwrite_3.idl
+++ b/include/dwrite_3.idl
@@ -473,6 +473,29 @@ interface IDWriteFontSet3 : IDWriteFontSet2
     HRESULT GetFontSourceName(UINT32 index, WCHAR *buffer, UINT32 buffer_size);
 }
 
+[
+    local,
+    object,
+    uuid(eec175fc-bea9-4c86-8b53-ccbdd7df0c82)
+]
+interface IDWriteFontSet4 : IDWriteFontSet3
+{
+    UINT32 ConvertWeightStretchStyleToFontAxisValues(
+        DWRITE_FONT_AXIS_VALUE const *input_axis_values,
+        UINT32 input_axis_count,
+        DWRITE_FONT_WEIGHT weight,
+        DWRITE_FONT_STRETCH stretch,
+        DWRITE_FONT_STYLE style,
+        float size,
+        DWRITE_FONT_AXIS_VALUE *output_axis_values);
+    HRESULT GetMatchingFonts(
+        WCHAR const *family_name,
+        DWRITE_FONT_AXIS_VALUE const *axis_values,
+        UINT32 axis_value_count,
+        DWRITE_FONT_SIMULATIONS allowed_simulations,
+        IDWriteFontSet4 **fonts);
+}
+
 [
     local,
     object,
@@ -795,6 +818,21 @@ interface IDWriteFontFace5 : IDWriteFontFace4
     BOOL Equals(IDWriteFontFace *fontface);
 }
 
+[
+    local,
+    object,
+    uuid(c4b1fe1b-6e84-47d5-b54c-a597981b06ad)
+]
+interface IDWriteFontFace6 : IDWriteFontFace5
+{
+    HRESULT GetFamilyNames(
+        DWRITE_FONT_FAMILY_MODEL font_family_model,
+        IDWriteLocalizedStrings **names);
+    HRESULT GetFaceNames(
+        DWRITE_FONT_FAMILY_MODEL font_family_model,
+        IDWriteLocalizedStrings **names);
+}
+
 typedef struct DWRITE_COLOR_GLYPH_RUN1 DWRITE_COLOR_GLYPH_RUN1;
 
 cpp_quote("struct DWRITE_COLOR_GLYPH_RUN1")
diff --git a/include/dxgicommon.idl b/include/dxgicommon.idl
index 99ace03c37d..29c8f6af642 100644
--- a/include/dxgicommon.idl
+++ b/include/dxgicommon.idl
@@ -45,6 +45,11 @@ typedef enum DXGI_COLOR_SPACE_TYPE
     DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020            = 0x11,
     DXGI_COLOR_SPACE_YCBCR_STUDIO_GHLG_TOPLEFT_P2020    = 0x12,
     DXGI_COLOR_SPACE_YCBCR_FULL_GHLG_TOPLEFT_P2020      = 0x13,
+    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P709           = 0x14,
+    DXGI_COLOR_SPACE_RGB_STUDIO_G24_NONE_P2020          = 0x15,
+    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P709         = 0x16,
+    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_LEFT_P2020        = 0x17,
+    DXGI_COLOR_SPACE_YCBCR_STUDIO_G24_TOPLEFT_P2020     = 0x18,
     DXGI_COLOR_SPACE_CUSTOM                             = 0xffffffff,
 } DXGI_COLOR_SPACE_TYPE;
 
diff --git a/include/ddk/imm.h b/include/immdev.h
similarity index 89%
rename from include/ddk/imm.h
rename to include/immdev.h
index bbbd70a596f..92f2a47c167 100644
--- a/include/ddk/imm.h
+++ b/include/immdev.h
@@ -16,14 +16,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#ifndef _DDKIMM_H_
-#define _DDKIMM_H_
+#ifndef __WINE_IMMDEV_H
+#define __WINE_IMMDEV_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-typedef struct _tagINPUTCONTEXT {
+typedef struct tagINPUTCONTEXT
+{
     HWND                hWnd;
     BOOL                fOpen;
     POINT               ptStatusWndPos;
@@ -46,7 +47,8 @@ typedef struct _tagINPUTCONTEXT {
     DWORD               dwReserve[3];
 } INPUTCONTEXT, *LPINPUTCONTEXT;
 
-typedef struct _tagIMEINFO {
+typedef struct tagIMEINFO
+{
     DWORD       dwPrivateDataSize;
     DWORD       fdwProperty;
     DWORD       fdwConversionCaps;
@@ -56,7 +58,8 @@ typedef struct _tagIMEINFO {
     DWORD       fdwSelectCaps;
 } IMEINFO, *LPIMEINFO;
 
-typedef struct tagCOMPOSITIONSTRING {
+typedef struct tagCOMPOSITIONSTRING
+{
     DWORD dwSize;
     DWORD dwCompReadAttrLen;
     DWORD dwCompReadAttrOffset;
@@ -84,7 +87,8 @@ typedef struct tagCOMPOSITIONSTRING {
     DWORD dwPrivateOffset;
 } COMPOSITIONSTRING, *LPCOMPOSITIONSTRING;
 
-typedef struct tagGUIDELINE {
+typedef struct tagGUIDELINE
+{
     DWORD dwSize;
     DWORD dwLevel;
     DWORD dwIndex;
@@ -94,7 +98,8 @@ typedef struct tagGUIDELINE {
     DWORD dwPrivateOffset;
 } GUIDELINE, *LPGUIDELINE;
 
-typedef struct tagCANDIDATEINFO {
+typedef struct tagCANDIDATEINFO
+{
     DWORD               dwSize;
     DWORD               dwCount;
     DWORD               dwOffset[32];
@@ -102,6 +107,19 @@ typedef struct tagCANDIDATEINFO {
     DWORD               dwPrivateOffset;
 } CANDIDATEINFO, *LPCANDIDATEINFO;
 
+typedef struct tagTRANSMSG
+{
+    UINT message;
+    WPARAM wParam;
+    LPARAM lParam;
+} TRANSMSG, *LPTRANSMSG;
+
+typedef struct tagTRANSMSGLIST
+{
+    UINT uMsgCount;
+    TRANSMSG TransMsg[1];
+} TRANSMSGLIST, *LPTRANSMSGLIST;
+
 LPINPUTCONTEXT WINAPI ImmLockIMC(HIMC);
 BOOL  WINAPI ImmUnlockIMC(HIMC);
 DWORD WINAPI ImmGetIMCLockCount(HIMC);
@@ -140,6 +158,8 @@ DWORD  WINAPI ImmGetIMCCSize(HIMCC);
 #define NI_SETCANDIDATE_PAGESIZE        0x0017
 #define NI_IMEMENUSELECTED              0x0018
 
+BOOL WINAPI ImmGetHotKey(DWORD,UINT*,UINT*,HKL*);
+BOOL WINAPI ImmSetHotKey(DWORD,UINT,UINT,HKL);
 BOOL WINAPI ImmGenerateMessage(HIMC);
 LRESULT WINAPI ImmRequestMessageA(HIMC, WPARAM, LPARAM);
 LRESULT WINAPI ImmRequestMessageW(HIMC, WPARAM, LPARAM);
@@ -149,7 +169,7 @@ HWND WINAPI ImmCreateSoftKeyboard(UINT, UINT, int, int);
 BOOL WINAPI ImmDestroySoftKeyboard(HWND);
 BOOL WINAPI ImmShowSoftKeyboard(HWND, int);
 
-BOOL WINAPI ImeInquire(LPIMEINFO, LPWSTR, LPCWSTR lpszOptions);
+BOOL WINAPI ImeInquire(LPIMEINFO, LPWSTR, DWORD);
 BOOL WINAPI ImeConfigure (HKL, HWND, DWORD, LPVOID);
 DWORD WINAPI ImeConversionList(HIMC, LPCWSTR, LPCANDIDATELIST,DWORD,UINT);
 BOOL WINAPI ImeDestroy(UINT);
@@ -157,7 +177,7 @@ LRESULT WINAPI ImeEscape(HIMC, UINT, LPVOID);
 BOOL WINAPI ImeProcessKey(HIMC, UINT, LPARAM, const LPBYTE);
 BOOL WINAPI ImeSelect(HIMC, BOOL);
 BOOL WINAPI ImeSetActiveContext(HIMC, BOOL);
-UINT WINAPI ImeToAsciiEx(UINT, UINT, const LPBYTE, LPDWORD, UINT, HIMC);
+UINT WINAPI ImeToAsciiEx(UINT, UINT, const LPBYTE, LPTRANSMSGLIST, UINT, HIMC);
 BOOL WINAPI NotifyIME(HIMC, DWORD, DWORD, DWORD);
 BOOL WINAPI ImeRegisterWord(LPCWSTR, DWORD, LPCWSTR);
 BOOL WINAPI ImeUnregisterWord(LPCWSTR, DWORD, LPCWSTR);
@@ -170,4 +190,4 @@ DWORD WINAPI ImeGetImeMenuItems(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMEN
 } /* extern "C" */
 #endif
 
-#endif  /* _DDKIMM_H_ */
+#endif  /* __WINE_IMMDEV_H */
diff --git a/include/ivectorchangedeventargs.idl b/include/ivectorchangedeventargs.idl
new file mode 100644
index 00000000000..45720b595f2
--- /dev/null
+++ b/include/ivectorchangedeventargs.idl
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "windowscontracts.idl";
+
+namespace Windows.Foundation.Collections {
+    [contract(Windows.Foundation.FoundationContract, 1.0)]
+    enum CollectionChange
+    {
+        Reset = 0,
+        ItemInserted = 1,
+        ItemRemoved = 2,
+        ItemChanged = 3,
+    };
+    typedef enum CollectionChange CollectionChange;
+
+    [
+        contract(Windows.Foundation.FoundationContract, 1.0),
+        uuid(575933df-34fe-4480-af15-07691f3d5d9b),
+        pointer_default(unique),
+        version(0x06020000 /* NTDDI_WIN8 */),
+        object,
+    ]
+    interface IVectorChangedEventArgs : IInspectable
+    {
+        [propget] HRESULT CollectionChange([out, retval] CollectionChange *value);
+        [propget] HRESULT Index([out, retval] unsigned *value);
+    };
+}
diff --git a/include/kbd.h b/include/kbd.h
new file mode 100644
index 00000000000..9bbcd886b1c
--- /dev/null
+++ b/include/kbd.h
@@ -0,0 +1,342 @@
+/*
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_KBD_H
+#define __WINE_KBD_H
+
+#include "windef.h"
+
+#define KBDBASE          0
+#define KBDSHIFT         1
+#define KBDCTRL          2
+#define KBDALT           4
+#define KBDKANA          8
+#define KBDROYA          0x10
+#define KBDLOYA          0x20
+#define KBDGRPSELTAP     0x80
+
+#define WCH_NONE         0xf000
+#define WCH_DEAD         0xf001
+#define WCH_LGTR         0xf002
+
+#define CAPLOK           0x01
+#define SGCAPS           0x02
+#define CAPLOKALTGR      0x04
+#define KANALOK          0x08
+#define GRPSELTAP        0x80
+
+typedef struct
+{
+    BYTE Vk;
+    BYTE ModBits;
+} VK_TO_BIT, *PVK_TO_BIT;
+
+typedef struct
+{
+    VK_TO_BIT *pVkToBit;
+    WORD wMaxModBits;
+    BYTE ModNumber[];
+} MODIFIERS, *PMODIFIERS;
+
+#define TYPEDEF_VK_TO_WCHARS(n) \
+    typedef struct _VK_TO_WCHARS##n \
+    { \
+        BYTE VirtualKey; \
+        BYTE Attributes; \
+        WCHAR wch[n]; \
+    } VK_TO_WCHARS##n, *PVK_TO_WCHARS##n
+
+TYPEDEF_VK_TO_WCHARS(1);
+TYPEDEF_VK_TO_WCHARS(2);
+TYPEDEF_VK_TO_WCHARS(3);
+TYPEDEF_VK_TO_WCHARS(4);
+TYPEDEF_VK_TO_WCHARS(5);
+TYPEDEF_VK_TO_WCHARS(6);
+TYPEDEF_VK_TO_WCHARS(7);
+TYPEDEF_VK_TO_WCHARS(8);
+TYPEDEF_VK_TO_WCHARS(9);
+TYPEDEF_VK_TO_WCHARS(10);
+
+typedef struct _VK_TO_WCHAR_TABLE
+{
+    VK_TO_WCHARS1 *pVkToWchars;
+    BYTE nModifications;
+    BYTE cbSize;
+} VK_TO_WCHAR_TABLE, *PVK_TO_WCHAR_TABLE;
+
+typedef struct
+{
+    DWORD dwBoth;
+    WCHAR wchComposed;
+    USHORT uFlags;
+} DEADKEY, *PDEADKEY;
+
+typedef struct
+{
+    BYTE vsc;
+    WCHAR *pwsz;
+} VSC_LPWSTR, *PVSC_LPWSTR;
+
+typedef struct _VSC_VK
+{
+    BYTE Vsc;
+    USHORT Vk;
+} VSC_VK, *PVSC_VK;
+
+#define TYPEDEF_LIGATURE(n) \
+    typedef struct _LIGATURE##n \
+    { \
+        BYTE VirtualKey; \
+        WORD ModificationNumber; \
+        WCHAR wch[n]; \
+    } LIGATURE##n, *PLIGATURE##n;
+
+TYPEDEF_LIGATURE(1)
+TYPEDEF_LIGATURE(2)
+TYPEDEF_LIGATURE(3)
+TYPEDEF_LIGATURE(4)
+TYPEDEF_LIGATURE(5)
+
+typedef struct tagKbdLayer
+{
+    MODIFIERS *pCharModifiers;
+    VK_TO_WCHAR_TABLE *pVkToWcharTable;
+    DEADKEY *pDeadKey;
+    VSC_LPWSTR *pKeyNames;
+    VSC_LPWSTR *pKeyNamesExt;
+    WCHAR **pKeyNamesDead;
+    USHORT *pusVSCtoVK;
+    BYTE bMaxVSCtoVK;
+    VSC_VK *pVSCtoVK_E0;
+    VSC_VK *pVSCtoVK_E1;
+    DWORD fLocaleFlags;
+    BYTE nLgMax;
+    BYTE cbLgEntry;
+    LIGATURE1 *pLigature;
+    DWORD dwType;
+    DWORD dwSubType;
+} KBDTABLES, *PKBDTABLES;
+
+#define KBD_VERSION              1
+#define GET_KBD_VERSION(table)   (HIWORD((table)->fLocaleFlags))
+
+#ifndef KBD_TYPE
+#define KBD_TYPE 4
+#endif
+
+#define KBDEXT         (USHORT)0x0100
+#define KBDMULTIVK     (USHORT)0x0200
+#define KBDSPECIAL     (USHORT)0x0400
+#define KBDNUMPAD      (USHORT)0x0800
+#define KBDUNICODE     (USHORT)0x1000
+#define KBDINJECTEDVK  (USHORT)0x2000
+#define KBDMAPPEDVK    (USHORT)0x4000
+#define KBDBREAK       (USHORT)0x8000
+
+#define VK__none_      0xff
+#define VK_ABNT_C1     0xc1
+#define VK_ABNT_C2     0xc2
+
+#if (KBD_TYPE <= 6)
+#define _EQ(v4)                     (VK_##v4)
+#if (KBD_TYPE == 1)
+#define _NE(v1, v2, v3, v4, v5, v6) (VK_##v1)
+#elif (KBD_TYPE == 2)
+#define _NE(v1, v2, v3, v4, v5, v6) (VK_##v2)
+#elif (KBD_TYPE == 3)
+#define _NE(v1, v2, v3, v4, v5, v6) (VK_##v3)
+#elif (KBD_TYPE == 4)
+#define _NE(v1, v2, v3, v4, v5, v6) (VK_##v4)
+#elif (KBD_TYPE == 5)
+#define _NE(v1, v2, v3, v4, v5, v6) (VK_##v5)
+#elif (KBD_TYPE == 6)
+#define _NE(v1, v2, v3, v4, v5, v6) (VK_##v6)
+#endif
+#define T00 _EQ(_none_)
+#define T01 _EQ(ESCAPE)
+#define T02 '1'
+#define T03 '2'
+#define T04 '3'
+#define T05 '4'
+#define T06 '5'
+#define T07 '6'
+#define T08 '7'
+#define T09 '8'
+#define T0A '9'
+#define T0B '0'
+#define T0C _EQ(OEM_MINUS)
+#define T0D _NE(OEM_PLUS,OEM_4, OEM_PLUS, OEM_PLUS, OEM_PLUS, OEM_PLUS)
+#define T0E _EQ(BACK)
+#define T0F _EQ(TAB)
+#define T10 'Q'
+#define T11 'W'
+#define T12 'E'
+#define T13 'R'
+#define T14 'T'
+#define T15 'Y'
+#define T16 'U'
+#define T17 'I'
+#define T18 'O'
+#define T19 'P'
+#define T1A _NE(OEM_4, OEM_6, OEM_4, OEM_4, OEM_4, OEM_4)
+#define T1B _NE(OEM_6, OEM_1, OEM_6, OEM_6, OEM_6, OEM_6)
+#define T1C _EQ(RETURN)
+#define T1D _EQ(LCONTROL)
+#define T1E 'A'
+#define T1F 'S'
+#define T20 'D'
+#define T21 'F'
+#define T22 'G'
+#define T23 'H'
+#define T24 'J'
+#define T25 'K'
+#define T26 'L'
+#define T27 _NE(OEM_1, OEM_PLUS, OEM_1, OEM_1, OEM_1, OEM_1)
+#define T28 _NE(OEM_7, OEM_3, OEM_7, OEM_7, OEM_3, OEM_3)
+#define T29 _NE(OEM_3, OEM_7, OEM_3, OEM_3, OEM_7, OEM_7)
+#define T2A _EQ(LSHIFT)
+#define T2B _EQ(OEM_5)
+#define T2C 'Z'
+#define T2D 'X'
+#define T2E 'C'
+#define T2F 'V'
+#define T30 'B'
+#define T31 'N'
+#define T32 'M'
+#define T33 _EQ(OEM_COMMA)
+#define T34 _EQ(OEM_PERIOD)
+#define T35 _EQ(OEM_2)
+#define T36 _EQ(RSHIFT)
+#define T37 _EQ(MULTIPLY)
+#define T38 _EQ(LMENU)
+#define T39 ' '
+#define T3A _EQ(CAPITAL)
+#define T3B _EQ(F1)
+#define T3C _EQ(F2)
+#define T3D _EQ(F3)
+#define T3E _EQ(F4)
+#define T3F _EQ(F5)
+#define T40 _EQ(F6)
+#define T41 _EQ(F7)
+#define T42 _EQ(F8)
+#define T43 _EQ(F9)
+#define T44 _EQ(F10)
+#define T45 _EQ(NUMLOCK)
+#define T46 _EQ(SCROLL)
+#define T47 _EQ(HOME)
+#define T48 _EQ(UP)
+#define T49 _EQ(PRIOR)
+#define T4A _EQ(SUBTRACT)
+#define T4B _EQ(LEFT)
+#define T4C _EQ(CLEAR)
+#define T4D _EQ(RIGHT)
+#define T4E _EQ(ADD)
+#define T4F _EQ(END)
+#define T50 _EQ(DOWN)
+#define T51 _EQ(NEXT)
+#define T52 _EQ(INSERT)
+#define T53 _EQ(DELETE)
+#define T54 _EQ(SNAPSHOT)
+#define T55 _EQ(_none_)
+#define T56 _NE(OEM_102, HELP, OEM_102, OEM_102, _none_, OEM_PA2)
+#define T57 _NE(F11, RETURN, F11, F11, _none_, HELP)
+#define T58 _NE(F12, LEFT, F12, F12, _none_, OEM_102)
+#define T59 _EQ(CLEAR)
+#define T5A _EQ(OEM_WSCTRL)
+#define T5B _EQ(OEM_FINISH)
+#define T5C _EQ(OEM_JUMP)
+#define T5D _EQ(EREOF)
+#define T5E _EQ(OEM_BACKTAB)
+#define T5F _EQ(OEM_AUTO)
+#define T60 _EQ(_none_)
+#define T61 _EQ(_none_)
+#define T62 _EQ(ZOOM)
+#define T63 _EQ(HELP)
+#define T64 _EQ(F13)
+#define T65 _EQ(F14)
+#define T66 _EQ(F15)
+#define T67 _EQ(F16)
+#define T68 _EQ(F17)
+#define T69 _EQ(F18)
+#define T6A _EQ(F19)
+#define T6B _EQ(F20)
+#define T6C _EQ(F21)
+#define T6D _EQ(F22)
+#define T6E _EQ(F23)
+#define T6F _EQ(OEM_PA3)
+#define T70 _EQ(_none_)
+#define T71 _EQ(OEM_RESET)
+#define T72 _EQ(_none_)
+#define T73 _EQ(ABNT_C1)
+#define T74 _EQ(_none_)
+#define T75 _EQ(_none_)
+#define T76 _EQ(F24)
+#define T77 _EQ(_none_)
+#define T78 _EQ(_none_)
+#define T79 _EQ(_none_)
+#define T7A _EQ(_none_)
+#define T7B _EQ(OEM_PA1)
+#define T7C _EQ(TAB)
+#define T7D _EQ(_none_)
+#define T7E _EQ(ABNT_C2)
+#define T7F _EQ(OEM_PA2)
+#define X10 _EQ(MEDIA_PREV_TRACK)
+#define X19 _EQ(MEDIA_NEXT_TRACK)
+#define X1C _EQ(RETURN)
+#define X1D _EQ(RCONTROL)
+#define X20 _EQ(VOLUME_MUTE)
+#define X21 _EQ(LAUNCH_APP2)
+#define X22 _EQ(MEDIA_PLAY_PAUSE)
+#define X24 _EQ(MEDIA_STOP)
+#define X2E _EQ(VOLUME_DOWN)
+#define X30 _EQ(VOLUME_UP)
+#define X32 _EQ(BROWSER_HOME)
+#define X35 _EQ(DIVIDE)
+#define X37 _EQ(SNAPSHOT)
+#define X38 _EQ(RMENU)
+#define X46 _EQ(CANCEL)
+#define X47 _EQ(HOME)
+#define X48 _EQ(UP)
+#define X49 _EQ(PRIOR)
+#define X4B _EQ(LEFT)
+#define X4D _EQ(RIGHT)
+#define X4F _EQ(END)
+#define X50 _EQ(DOWN)
+#define X51 _NE(NEXT, F1, NEXT, NEXT, _none_, OEM_PA2)
+#define X52 _EQ(INSERT)
+#define X53 _EQ(DELETE)
+#define X5B _EQ(LWIN)
+#define X5C _EQ(RWIN)
+#define X5D _EQ(APPS)
+#define X5E _EQ(POWER)
+#define X5F _EQ(SLEEP)
+#define X65 _EQ(BROWSER_SEARCH)
+#define X66 _EQ(BROWSER_FAVORITES)
+#define X67 _EQ(BROWSER_REFRESH)
+#define X68 _EQ(BROWSER_STOP)
+#define X69 _EQ(BROWSER_FORWARD)
+#define X6A _EQ(BROWSER_BACK)
+#define X6B _EQ(LAUNCH_APP1)
+#define X6C _EQ(LAUNCH_MAIL)
+#define X6D _EQ(LAUNCH_MEDIA_SELECT)
+#define Y1D _EQ(PAUSE)
+#else
+#error "Unsupported KBD_TYPE"
+#endif
+
+#endif /* __WINE_KBD_H */
diff --git a/include/mshtmdid.h b/include/mshtmdid.h
index 0e95a7d7165..a28d706903f 100644
--- a/include/mshtmdid.h
+++ b/include/mshtmdid.h
@@ -3487,6 +3487,17 @@
 /* IHTMLEventObj4 */
 #define DISPID_IHTMLEVENTOBJ4_WHEELDELTA  DISPID_EVENTOBJ+51
 
+/* IHTMLEventObj5 */
+#define DISPID_IHTMLEVENTOBJ5_URL         DISPID_EVENTOBJ+52
+#define DISPID_IHTMLEVENTOBJ5_DATA        DISPID_EVENTOBJ+54
+#define DISPID_IHTMLEVENTOBJ5_SOURCE      DISPID_EVENTOBJ+55
+#define DISPID_IHTMLEVENTOBJ5_ORIGIN      DISPID_EVENTOBJ+53
+#define DISPID_IHTMLEVENTOBJ5_ISSESSION   DISPID_EVENTOBJ+56
+
+/* IHTMLEventObj6 */
+#define DISPID_IHTMLEVENTOBJ6_ACTIONURL   DISPID_EVENTOBJ+58
+#define DISPID_IHTMLEVENTOBJ6_BUTTONID    DISPID_EVENTOBJ+57
+
 /* IHTMLStyleMedia */
 #define DISPID_IHTMLSTYLEMEDIA_TYPE         DISPID_STYLEMEDIA+1
 #define DISPID_IHTMLSTYLEMEDIA_MATCHMEDIUM  DISPID_STYLEMEDIA+2
@@ -4135,6 +4146,10 @@
 #define DISPID_IHTMLRECT_RIGHT   DISPID_OMRECT+3
 #define DISPID_IHTMLRECT_BOTTOM  DISPID_OMRECT+4
 
+/* IHTMLRect2 */
+#define DISPID_IHTMLRECT2_WIDTH  DISPID_OMRECT+5
+#define DISPID_IHTMLRECT2_HEIGHT DISPID_OMRECT+6
+
 /* IHTMLRectCollection */
 #define DISPID_IHTMLRECTCOLLECTION_LENGTH    DISPID_COLLECTION
 #define DISPID_IHTMLRECTCOLLECTION__NEWENUM  DISPID_NEWENUM
diff --git a/include/mshtml.idl b/include/mshtml.idl
index eff87a4593e..2a1fccba6be 100644
--- a/include/mshtml.idl
+++ b/include/mshtml.idl
@@ -7937,6 +7937,24 @@ interface IHTMLRect : IDispatch
     HRESULT bottom([retval, out] LONG *p);
 }
 
+/*****************************************************************************
+ *    IHTMLRect2 interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(3051076c-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IHTMLRect2 : IDispatch
+{
+    [propget, id(DISPID_IHTMLRECT2_WIDTH)]
+    HRESULT width([retval, out] FLOAT *p);
+
+    [propget, id(DISPID_IHTMLRECT2_HEIGHT)]
+    HRESULT height([retval, out] FLOAT *p);
+}
+
 /*****************************************************************************
  *    IHTMLRectCollection interface
  */
@@ -19382,6 +19400,327 @@ interface IHTMLEventObj : IDispatch
     HRESULT srcFilter([retval, out] IDispatch **p);
 }
 
+/*****************************************************************************
+ *    IHTMLEventObj2 interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(3050f48B-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IHTMLEventObj2 : IDispatch
+{
+    [id(DISPID_IHTMLEVENTOBJ2_SETATTRIBUTE)]
+    HRESULT setAttribute(
+            [in] BSTR strAttributeName,
+            [in] VARIANT AttributeValue,
+            [in, defaultvalue(1)] LONG lFlags);
+
+    [id(DISPID_IHTMLEVENTOBJ2_GETATTRIBUTE)]
+    HRESULT getAttribute(
+            [in] BSTR strAttributeName,
+            [in, defaultvalue(0)] LONG lFlags,
+            [out, retval] VARIANT *AttributeValue);
+
+    [id(DISPID_IHTMLEVENTOBJ2_REMOVEATTRIBUTE)]
+    HRESULT removeAttribute(
+            [in] BSTR strAttributeName,
+            [in, defaultvalue(1)] LONG lFlags,
+            [out, retval] VARIANT_BOOL *pfSuccess);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_PROPERTYNAME)]
+    HRESULT propertyName([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_PROPERTYNAME)]
+    HRESULT propertyName([out, retval] BSTR *p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_BOOKMARKS)]
+    HRESULT bookmarks([in] IHTMLBookmarkCollection *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_BOOKMARKS)]
+    HRESULT bookmarks([out, retval] IHTMLBookmarkCollection **p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_RECORDSET)]
+    HRESULT recordset([in] IDispatch *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_RECORDSET)]
+    HRESULT recordset([out, retval] IDispatch **p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_DATAFLD)]
+    HRESULT dataFld([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_DATAFLD)]
+    HRESULT dataFld([out, retval] BSTR *p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_BOUNDELEMENTS)]
+    HRESULT boundElements([in] IHTMLElementCollection *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_BOUNDELEMENTS)]
+    HRESULT boundElements([out, retval] IHTMLElementCollection **p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_REPEAT)]
+    HRESULT repeat([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_REPEAT)]
+    HRESULT repeat([out, retval] VARIANT_BOOL *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_SRCURN)]
+    HRESULT srcUrn([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_SRCURN)]
+    HRESULT srcUrn([out, retval] BSTR *p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_SRCELEMENT)]
+    HRESULT srcElement([in] IHTMLElement *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_SRCELEMENT)]
+    HRESULT srcElement([out, retval] IHTMLElement **p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_ALTKEY)]
+    HRESULT altKey([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_ALTKEY)]
+    HRESULT altKey([out, retval] VARIANT_BOOL *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_CTRLKEY)]
+    HRESULT ctrlKey([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_CTRLKEY)]
+    HRESULT ctrlKey([out, retval] VARIANT_BOOL *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_SHIFTKEY)]
+    HRESULT shiftKey([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_SHIFTKEY)]
+    HRESULT shiftKey([out, retval] VARIANT_BOOL *p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_FROMELEMENT)]
+    HRESULT fromElement([in] IHTMLElement *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_FROMELEMENT)]
+    HRESULT fromElement([out, retval] IHTMLElement **p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_TOELEMENT)]
+    HRESULT toElement([in] IHTMLElement *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_TOELEMENT)]
+    HRESULT toElement([out, retval] IHTMLElement **p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_BUTTON)]
+    HRESULT button([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_BUTTON)]
+    HRESULT button([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_TYPE)]
+    HRESULT type([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_TYPE)]
+    HRESULT type([out, retval] BSTR *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_QUALIFIER)]
+    HRESULT qualifier([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_QUALIFIER)]
+    HRESULT qualifier([out, retval] BSTR *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_REASON)]
+    HRESULT reason([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_REASON)]
+    HRESULT reason([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_X)]
+    HRESULT x([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_X)]
+    HRESULT x([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_Y)]
+    HRESULT y([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_Y)]
+    HRESULT y([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_CLIENTX)]
+    HRESULT clientX([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_CLIENTX)]
+    HRESULT clientX([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_CLIENTY)]
+    HRESULT clientY([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_CLIENTY)]
+    HRESULT clientY([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_OFFSETX)]
+    HRESULT offsetX([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_OFFSETX)]
+    HRESULT offsetX([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_OFFSETY)]
+    HRESULT offsetY([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_OFFSETY)]
+    HRESULT offsetY([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_SCREENX)]
+    HRESULT screenX([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_SCREENX)]
+    HRESULT screenX([out, retval] long *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ2_SCREENY)]
+    HRESULT screenY([in] long v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_SCREENY)]
+    HRESULT screenY([out, retval] long *p);
+
+    [propputref, id(DISPID_IHTMLEVENTOBJ2_SRCFILTER)]
+    HRESULT srcFilter([in] IDispatch *v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_SRCFILTER)]
+    HRESULT srcFilter([out, retval] IDispatch **p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ2_DATATRANSFER)]
+    HRESULT dataTransfer([out, retval] IHTMLDataTransfer **p);
+}
+
+/*****************************************************************************
+ *    IHTMLEventObj3 interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(3050f680-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IHTMLEventObj3 : IDispatch
+{
+    [propget, id(DISPID_IHTMLEVENTOBJ3_CONTENTOVERFLOW)]
+    HRESULT contentOverflow([out, retval] VARIANT_BOOL *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ3_SHIFTLEFT)]
+    HRESULT shiftLeft([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_SHIFTLEFT)]
+    HRESULT shiftLeft([out, retval] VARIANT_BOOL *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ3_ALTLEFT)]
+    HRESULT altLeft([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_ALTLEFT)]
+    HRESULT altLeft([out, retval] VARIANT_BOOL *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ3_CTRLLEFT)]
+    HRESULT ctrlLeft([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_CTRLLEFT)]
+    HRESULT ctrlLeft([out, retval] VARIANT_BOOL *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_IMECOMPOSITIONCHANGE), hidden, restricted, nonbrowsable]
+    HRESULT imeCompositionChange([out, retval] LONG_PTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_IMENOTIFYCOMMAND), hidden, restricted, nonbrowsable]
+    HRESULT imeNotifyCommand([out, retval] LONG_PTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_IMENOTIFYDATA), hidden, restricted, nonbrowsable]
+    HRESULT imeNotifyData([out, retval] LONG_PTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_IMEREQUEST), hidden, restricted, nonbrowsable]
+    HRESULT imeRequest([out, retval] LONG_PTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_IMEREQUESTDATA), hidden, restricted, nonbrowsable]
+    HRESULT imeRequestData([out, retval] LONG_PTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_KEYBOARDLAYOUT), hidden, restricted, nonbrowsable]
+    HRESULT keyboardLayout([out, retval] LONG_PTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_BEHAVIORCOOKIE)]
+    HRESULT behaviorCookie([out, retval] long *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_BEHAVIORPART)]
+    HRESULT behaviorPart([out, retval] long *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ3_NEXTPAGE)]
+    HRESULT nextPage([out, retval] BSTR *p);
+}
+
+/*****************************************************************************
+ *    IHTMLEventObj4 interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(3050f814-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IHTMLEventObj4 : IDispatch
+{
+    [propget, id(DISPID_IHTMLEVENTOBJ4_WHEELDELTA)]
+    HRESULT wheelDelta([out, retval] long *p);
+}
+
+/*****************************************************************************
+ *    IHTMLEventObj5 interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(30510478-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IHTMLEventObj5 : IDispatch
+{
+    [propput, id(DISPID_IHTMLEVENTOBJ5_URL)]
+    HRESULT url([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_URL)]
+    HRESULT url([out, retval] BSTR *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_DATA)]
+    HRESULT data([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_DATA)]
+    HRESULT data([out, retval] BSTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_SOURCE)]
+    HRESULT source([out, retval] IDispatch **p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_ORIGIN)]
+    HRESULT origin([in] BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_ORIGIN)]
+    HRESULT origin([out, retval] BSTR *p);
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_ISSESSION), hidden, restricted, nonbrowsable]
+    HRESULT issession([in] VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_ISSESSION), hidden, restricted, nonbrowsable]
+    HRESULT issession([out, retval] VARIANT_BOOL *p);
+}
+
+/*****************************************************************************
+ *    IHTMLEventObj6 interface
+ */
+[
+    odl,
+    oleautomation,
+    dual,
+    uuid(30510734-98b5-11cf-bb82-00aa00bdce0b)
+]
+interface IHTMLEventObj6 : IDispatch
+{
+    [propget, id(DISPID_IHTMLEVENTOBJ6_ACTIONURL)]
+    HRESULT actionURL([out, retval] BSTR *p);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ6_BUTTONID)]
+    HRESULT buttonID([out, retval] long *p);
+}
+
 /*****************************************************************************
  *    DispCEventObj dispinterface
  */
@@ -19635,6 +19974,42 @@ methods:
 
     [propget, id(DISPID_IHTMLEVENTOBJ4_WHEELDELTA)]
     LONG wheelDelta();
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_URL)]
+    void url(BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_URL)]
+    BSTR url();
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_DATA)]
+    void data(BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_DATA)]
+    BSTR data();
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_SOURCE)]
+    IDispatch *source();
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_ORIGIN)]
+    void origin(BSTR v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_ORIGIN)]
+    BSTR origin();
+
+    [propput, id(DISPID_IHTMLEVENTOBJ5_ISSESSION), hidden, restricted, nonbrowsable]
+    void issession(VARIANT_BOOL v);
+
+    [propget, id(DISPID_IHTMLEVENTOBJ5_ISSESSION), hidden, restricted, nonbrowsable]
+    VARIANT_BOOL issession();
+
+    [propget, id(DISPID_IHTMLEVENTOBJ6_ACTIONURL)]
+    BSTR actionURL();
+
+    [propget, id(DISPID_IHTMLEVENTOBJ6_BUTTONID)]
+    long buttonID();
+
+    [propget, id(DISPID_IHTMLDOMCONSTRUCTOR_CONSTRUCTOR), hidden]
+    IDispatch *constructor();
 }
 
 /*****************************************************************************
diff --git a/include/msvcrt/assert.h b/include/msvcrt/assert.h
index 9a180f7e58d..26a9c0a7a5f 100644
--- a/include/msvcrt/assert.h
+++ b/include/msvcrt/assert.h
@@ -28,7 +28,7 @@ extern "C" {
 #ifdef NDEBUG
 #define assert(_expr) ((void)0)
 #else
-_ACRTIMP void __cdecl _assert(const char *, const char *, unsigned int);
+_ACRTIMP DECLSPEC_NORETURN void __cdecl _assert(const char *, const char *, unsigned int);
 #define assert(_expr) (void)((!!(_expr)) || (_assert(#_expr, __FILE__, __LINE__), 0))
 #endif
 
diff --git a/include/msvcrt/corecrt.h b/include/msvcrt/corecrt.h
index aba9bc9422e..bec9c8911c2 100644
--- a/include/msvcrt/corecrt.h
+++ b/include/msvcrt/corecrt.h
@@ -122,18 +122,6 @@
 # endif
 #endif
 
-#if (defined(__x86_64__) || (defined(__aarch64__) && __has_attribute(ms_abi))) && defined (__GNUC__)
-# include <stdarg.h>
-# undef va_list
-# undef va_start
-# undef va_end
-# undef va_copy
-# define va_list __builtin_ms_va_list
-# define va_start(list,arg) __builtin_ms_va_start(list,arg)
-# define va_end(list) __builtin_ms_va_end(list)
-# define va_copy(dest,src) __builtin_ms_va_copy(dest,src)
-#endif
-
 #ifndef WINAPIV
 # if defined(__arm__) && defined (__GNUC__) && !defined(__SOFTFP__) && !defined(__MINGW32__) && !defined(__CYGWIN__)
 #  define WINAPIV __attribute__((pcs("aapcs")))
@@ -342,4 +330,22 @@ typedef struct threadlocaleinfostruct {
 #define __WINE_CRT_SCANF_ATTR(fmt,args)
 #endif
 
+#if defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)))
+#define __WINE_ALLOC_SIZE(...) __attribute__((__alloc_size__(__VA_ARGS__)))
+#else
+#define __WINE_ALLOC_SIZE(...)
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ > 10)
+#define __WINE_DEALLOC(...) __attribute__((malloc (__VA_ARGS__)))
+#else
+#define __WINE_DEALLOC(...)
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ > 2)
+#define __WINE_MALLOC __attribute__((malloc))
+#else
+#define __WINE_MALLOC
+#endif
+
 #endif /* __WINE_CORECRT_H */
diff --git a/include/msvcrt/corecrt_malloc.h b/include/msvcrt/corecrt_malloc.h
index 4c0d35f7e08..ab3f03fcb04 100644
--- a/include/msvcrt/corecrt_malloc.h
+++ b/include/msvcrt/corecrt_malloc.h
@@ -30,16 +30,16 @@ _ACRTIMP void*  __cdecl calloc(size_t,size_t);
 _ACRTIMP void   __cdecl free(void*);
 _ACRTIMP void*  __cdecl malloc(size_t);
 _ACRTIMP void*  __cdecl realloc(void*,size_t);
-_ACRTIMP void*  __cdecl _recalloc(void*,size_t,size_t);
+_ACRTIMP void*  __cdecl _recalloc(void*,size_t,size_t) __WINE_ALLOC_SIZE(2,3) __WINE_DEALLOC(free);
 
 _ACRTIMP void*  __cdecl _expand(void*,size_t);
 _ACRTIMP size_t __cdecl _msize(void*);
 
 _ACRTIMP void   __cdecl _aligned_free(void*);
-_ACRTIMP void*  __cdecl _aligned_malloc(size_t,size_t);
-_ACRTIMP void*  __cdecl _aligned_offset_malloc(size_t,size_t,size_t);
-_ACRTIMP void*  __cdecl _aligned_realloc(void*,size_t,size_t);
-_ACRTIMP void*  __cdecl _aligned_offset_realloc(void*,size_t,size_t,size_t);
+_ACRTIMP void*  __cdecl _aligned_malloc(size_t,size_t) __WINE_ALLOC_SIZE(1) __WINE_DEALLOC(_aligned_free) __WINE_MALLOC;
+_ACRTIMP void*  __cdecl _aligned_offset_malloc(size_t,size_t,size_t) __WINE_ALLOC_SIZE(1) __WINE_DEALLOC(_aligned_free) __WINE_MALLOC;
+_ACRTIMP void*  __cdecl _aligned_realloc(void*,size_t,size_t) __WINE_ALLOC_SIZE(2) __WINE_DEALLOC(_aligned_free);
+_ACRTIMP void*  __cdecl _aligned_offset_realloc(void*,size_t,size_t,size_t) __WINE_ALLOC_SIZE(2) __WINE_DEALLOC(_aligned_free);
 
 #ifdef __cplusplus
 }
diff --git a/include/msvcrt/corecrt_wstring.h b/include/msvcrt/corecrt_wstring.h
index bcf9f947625..4d012800f65 100644
--- a/include/msvcrt/corecrt_wstring.h
+++ b/include/msvcrt/corecrt_wstring.h
@@ -7,6 +7,7 @@
 #define _WSTRING_DEFINED
 
 #include <corecrt.h>
+#include <corecrt_malloc.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -29,7 +30,7 @@ static inline void* memccpy(void *s1, const void *s2, int c, size_t n) { return
 
 _ACRTIMP void*   __cdecl memmove(void*,const void*,size_t);
 
-_ACRTIMP wchar_t* __cdecl _wcsdup(const wchar_t*);
+_ACRTIMP wchar_t* __cdecl _wcsdup(const wchar_t*) __WINE_DEALLOC(free) __WINE_MALLOC;
 _ACRTIMP int      __cdecl _wcsicmp(const wchar_t*,const wchar_t*);
 _ACRTIMP int      __cdecl _wcsicoll(const wchar_t*,const wchar_t*);
 _ACRTIMP int      __cdecl _wcsicoll_l(const wchar_t*, const wchar_t*, _locale_t);
diff --git a/include/msvcrt/math.h b/include/msvcrt/math.h
index dba2b07be37..26abbae2a59 100644
--- a/include/msvcrt/math.h
+++ b/include/msvcrt/math.h
@@ -342,6 +342,34 @@ static inline int __signbit(double x)
 
 #endif
 
+#ifdef _UCRT
+
+ _ACRTIMP int __cdecl _dpcomp(double, double);
+ _ACRTIMP int __cdecl _fdpcomp(float, float);
+
+#define _FP_LT  1
+#define _FP_EQ  2
+#define _FP_GT  4
+
+#ifdef __GNUC__
+# define isgreater(x, y)      __builtin_isgreater(x, y)
+# define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
+# define isless(x, y)         __builtin_isless(x, y)
+# define islessequal(x, y)    __builtin_islessequal(x, y)
+# define islessgreater(x, y)  __builtin_islessgreater(x, y)
+# define isunordered(x, y)    __builtin_isunordered(x, y)
+#else
+# define __FP_COMPARE(x,y) (sizeof(x) == sizeof(float) && sizeof(y) == sizeof(float) ? _fdpcomp(x,y) : _dpcomp(x,y))
+# define isgreater(x, y)      ((__FP_COMPARE(x, y) & _FP_GT) != 0)
+# define isgreaterequal(x, y) ((__FP_COMPARE(x, y) & (_FP_GT|_FP_EQ)) != 0)
+# define isless(x, y)         ((__FP_COMPARE(x, y) & _FP_LT) != 0)
+# define islessequal(x, y)    ((__FP_COMPARE(x, y) & (_FP_LT|_FP_EQ)) != 0)
+# define islessgreater(x, y)  ((__FP_COMPARE(x, y) & (_FP_LT|_FP_GT)) != 0)
+# define isunordered(x, y)    (!__FP_COMPARE(x, y))
+#endif
+
+#endif /* _UCRT */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/msvcrt/string.h b/include/msvcrt/string.h
index 5e3d51076c6..18d424b1e6a 100644
--- a/include/msvcrt/string.h
+++ b/include/msvcrt/string.h
@@ -8,6 +8,7 @@
 #ifndef __WINE_STRING_H
 #define __WINE_STRING_H
 
+#include <corecrt_malloc.h>
 #include <corecrt_wstring.h>
 
 #ifndef _NLSCMP_DEFINED
@@ -22,7 +23,7 @@ extern "C" {
 _ACRTIMP size_t __cdecl __strncnt(const char*,size_t);
 _ACRTIMP int   __cdecl _strcmpi(const char*,const char*);
 _ACRTIMP int   __cdecl _strcoll_l(const char*, const char*, _locale_t);
-_ACRTIMP char* __cdecl _strdup(const char*);
+_ACRTIMP char* __cdecl _strdup(const char*) __WINE_DEALLOC(free) __WINE_MALLOC;
 _ACRTIMP char* __cdecl _strerror(const char*);
 _ACRTIMP errno_t __cdecl strerror_s(char*,size_t,int);
 _ACRTIMP int   __cdecl _stricmp(const char*,const char*);
diff --git a/include/msvcrt/time.h b/include/msvcrt/time.h
index c0db38ff7a3..e1d914fea0d 100644
--- a/include/msvcrt/time.h
+++ b/include/msvcrt/time.h
@@ -74,7 +74,9 @@ _ACRTIMP void        __cdecl _tzset(void);
 _ACRTIMP char*       __cdecl asctime(const struct tm*);
 _ACRTIMP clock_t     __cdecl clock(void);
 _ACRTIMP char*       __cdecl _ctime32(const __time32_t*);
+_ACRTIMP errno_t     __cdecl _ctime32_s(char*,size_t,const __time32_t*);
 _ACRTIMP char*       __cdecl _ctime64(const __time64_t*);
+_ACRTIMP errno_t     __cdecl _ctime64_s(char*,size_t,const __time64_t*);
 _ACRTIMP double      __cdecl _difftime32(__time32_t,__time32_t);
 _ACRTIMP double      __cdecl _difftime64(__time64_t,__time64_t);
 _ACRTIMP struct tm*  __cdecl _gmtime32(const __time32_t*);
@@ -91,16 +93,20 @@ _ACRTIMP __time64_t  __cdecl _time64(__time64_t*);
 
 #ifndef _USE_32BIT_TIME_T
 static inline char* ctime(const time_t *t) { return _ctime64(t); }
+static inline errno_t ctime_s(char *res, size_t len, const __time64_t *t) { return _ctime64_s(res, len, t); }
 static inline double difftime(time_t t1, time_t t2) { return _difftime64(t1, t2); }
 static inline struct tm* gmtime(const time_t *t) { return _gmtime64(t); }
 static inline struct tm* localtime(const time_t *t) { return _localtime64(t); }
+static inline errno_t localtime_s(struct tm *res, const time_t *t) { return _localtime64_s(res, t); }
 static inline time_t mktime(struct tm *tm) { return _mktime64(tm); }
 static inline time_t time(time_t *t) { return _time64(t); }
 #elif defined(_UCRT)
 static inline char* ctime(const time_t *t) { return _ctime32(t); }
+static inline errno_t ctime_s(char *res, size_t len, const __time32_t *t) { return _ctime32_s(res, len, t); }
 static inline double difftime(time_t t1, time_t t2) { return _difftime32(t1, t2); }
 static inline struct tm* gmtime(const time_t *t) { return _gmtime32(t); }
 static inline struct tm* localtime(const time_t *t) { return _localtime32(t); }
+static inline errno_t localtime_s(struct tm *res, const time_t *t) { return _localtime32_s(res, t); }
 static inline time_t mktime(struct tm *tm) { return _mktime32(tm); }
 static inline time_t time(time_t *t) { return _time32(t); }
 #endif
diff --git a/include/msvcrt/vadefs.h b/include/msvcrt/vadefs.h
index 2a612fc055c..462c2d6815f 100644
--- a/include/msvcrt/vadefs.h
+++ b/include/msvcrt/vadefs.h
@@ -27,7 +27,15 @@
 #define _ADDRESSOF(v) (&(v))
 #endif
 
-#if defined(__GNUC__) || defined(__clang__)
+#if defined (__GNUC__) && (defined(__x86_64__) || (defined(__aarch64__) && __has_attribute(ms_abi)))
+
+typedef __builtin_ms_va_list va_list;
+#define _crt_va_start(v,l)  __builtin_ms_va_start(v,l)
+#define _crt_va_arg(v,l)    __builtin_va_arg(v,l)
+#define _crt_va_end(v)      __builtin_ms_va_end(v)
+#define _crt_va_copy(d,s)   __builtin_ms_va_copy(d,s)
+
+#elif defined(__GNUC__) || defined(__clang__)
 
 typedef __builtin_va_list va_list;
 #define _crt_va_start(v,l)  __builtin_va_start(v,l)
diff --git a/include/msxml6.idl b/include/msxml6.idl
index 458c43e389d..d4a5c490243 100644
--- a/include/msxml6.idl
+++ b/include/msxml6.idl
@@ -256,6 +256,20 @@ typedef enum _SCHEMATYPEVARIETY
 } SCHEMATYPEVARIETY;
 cpp_quote("#endif /* __msxml_som_enums__ */")
 
+typedef [v1_enum] enum _XHR_CRED_PROMPT
+{
+    XHR_CRED_PROMPT_ALL,
+    XHR_CRED_PROMPT_NONE,
+    XHR_CRED_PROMPT_PROXY
+} XHR_CRED_PROMPT;
+
+typedef [v1_enum] enum _XHR_AUTH
+{
+    XHR_AUTH_ALL,
+    XHR_AUTH_NONE,
+    XHR_AUTH_PROXY
+} XHR_AUTH;
+
 typedef [v1_enum] enum _XHR_PROPERTY
 {
     XHR_PROP_NO_CRED_PROMPT,
diff --git a/include/ntdef.h b/include/ntdef.h
index 92366c3f3bb..8d04f83da5d 100644
--- a/include/ntdef.h
+++ b/include/ntdef.h
@@ -84,4 +84,6 @@ typedef struct _RTL_BALANCED_NODE
 
 #define RTL_BALANCED_NODE_RESERVED_PARENT_MASK 3
 
+#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof(s[0]), sizeof(s), (void*)s }
+
 #endif /* _NTDEF_ */
diff --git a/include/ntuser.h b/include/ntuser.h
index 7bbe7037f20..3b821f0c9fe 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -701,6 +701,7 @@ BOOL    WINAPI NtUserDrawIconEx( HDC hdc, INT x0, INT y0, HICON icon, INT width,
 DWORD   WINAPI NtUserDrawMenuBarTemp( HWND hwnd, HDC hdc, RECT *rect, HMENU handle, HFONT font );
 BOOL    WINAPI NtUserEmptyClipboard(void);
 BOOL    WINAPI NtUserEnableMenuItem( HMENU handle, UINT id, UINT flags );
+BOOL    WINAPI NtUserEnableMouseInPointer( BOOL );
 BOOL    WINAPI NtUserEnableScrollBar( HWND hwnd, UINT bar, UINT flags );
 BOOL    WINAPI NtUserEndDeferWindowPosEx( HDWP hdwp, BOOL async );
 BOOL    WINAPI NtUserEndMenu(void);
@@ -760,6 +761,8 @@ int     WINAPI NtUserGetMouseMovePointsEx( UINT size, MOUSEMOVEPOINT *ptin, MOUS
 BOOL    WINAPI NtUserGetObjectInformation( HANDLE handle, INT index, void *info,
                                            DWORD len, DWORD *needed );
 HWND    WINAPI NtUserGetOpenClipboardWindow(void);
+BOOL    WINAPI NtUserGetPointerInfoList( UINT32 id, POINTER_INPUT_TYPE type, UINT_PTR, UINT_PTR, SIZE_T size,
+                                         UINT32 *entry_count, UINT32 *pointer_count, void *pointer_info );
 INT     WINAPI NtUserGetPriorityClipboardFormat( UINT *list, INT count );
 HWINSTA WINAPI NtUserGetProcessWindowStation(void);
 HANDLE  WINAPI NtUserGetProp( HWND hwnd, const WCHAR *str );
@@ -789,6 +792,7 @@ NTSTATUS WINAPI NtUserInitializeClientPfnArrays( const struct user_client_procs
 HICON   WINAPI NtUserInternalGetWindowIcon( HWND hwnd, UINT type );
 INT     WINAPI NtUserInternalGetWindowText( HWND hwnd, WCHAR *text, INT count );
 BOOL    WINAPI NtUserIsClipboardFormatAvailable( UINT format );
+BOOL    WINAPI NtUserIsMouseInPointerEnabled(void);
 BOOL    WINAPI NtUserInvalidateRect( HWND hwnd, const RECT *rect, BOOL erase );
 BOOL    WINAPI NtUserInvalidateRgn( HWND hwnd, HRGN hrgn, BOOL erase );
 BOOL    WINAPI NtUserKillTimer( HWND hwnd, UINT_PTR id );
diff --git a/include/propvarutil.h b/include/propvarutil.h
index b82c3d90274..575c498b230 100644
--- a/include/propvarutil.h
+++ b/include/propvarutil.h
@@ -81,6 +81,7 @@ HRESULT WINAPI VariantToGUID(const VARIANT *pvar, GUID *guid);
 INT WINAPI PropVariantCompareEx(REFPROPVARIANT propvar1, REFPROPVARIANT propvar2,
                                 PROPVAR_COMPARE_UNIT uint, PROPVAR_COMPARE_FLAGS flags);
 HRESULT WINAPI InitPropVariantFromFileTime(const FILETIME *pftIn, PROPVARIANT *ppropvar);
+HRESULT WINAPI InitPropVariantFromStringVector(PCWSTR *strs, ULONG count, PROPVARIANT *ppropvar);
 
 HRESULT WINAPI PropVariantToDouble(REFPROPVARIANT propvarIn, double *ret);
 HRESULT WINAPI PropVariantToInt16(REFPROPVARIANT propvarIn, SHORT *ret);
diff --git a/include/psapi.h b/include/psapi.h
index 66e660b2435..6dcb783934e 100644
--- a/include/psapi.h
+++ b/include/psapi.h
@@ -137,6 +137,12 @@ extern "C" {
 #define GetProcessImageFileNameW    K32GetProcessImageFileNameW
 #endif
 
+/* filter flags for EnumProcessModulesEx */
+#define LIST_MODULES_32BIT   0x01
+#define LIST_MODULES_64BIT   0x02
+#define LIST_MODULES_ALL     0x03
+#define LIST_MODULES_DEFAULT 0x00
+
 BOOL  WINAPI EnumProcesses(DWORD*, DWORD, DWORD*);
 BOOL  WINAPI EnumProcessModules(HANDLE, HMODULE*, DWORD, LPDWORD);
 BOOL  WINAPI EnumProcessModulesEx(HANDLE, HMODULE*, DWORD, LPDWORD, DWORD);
diff --git a/include/realtimeapiset.h b/include/realtimeapiset.h
new file mode 100644
index 00000000000..124a7987c8c
--- /dev/null
+++ b/include/realtimeapiset.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef _REALTIMEAPISET_H_
+#define _REALTIMEAPISET_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+WINBASEAPI HRESULT WINAPI ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG,ULONGLONG*,ULONGLONG*);
+WINBASEAPI HRESULT WINAPI ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG,ULONGLONG*,ULONGLONG*);
+WINBASEAPI HRESULT WINAPI QueryAuxiliaryCounterFrequency(ULONGLONG*);
+WINBASEAPI BOOL    WINAPI QueryIdleProcessorCycleTime(ULONG*,PULONG64*);
+WINBASEAPI BOOL    WINAPI QueryIdleProcessorCycleTimeEx(USHORT,ULONG*,ULONG64*);
+WINBASEAPI VOID    WINAPI QueryInterruptTime(ULONGLONG*);
+WINBASEAPI VOID    WINAPI QueryInterruptTimePrecise(ULONGLONG*);
+WINBASEAPI BOOL    WINAPI QueryProcessCycleTime(HANDLE,ULONG64*);
+WINBASEAPI BOOL    WINAPI QueryThreadCycleTime(HANDLE,ULONG64*);
+WINBASEAPI BOOL    WINAPI QueryUnbiasedInterruptTime(ULONGLONG*);
+WINBASEAPI VOID    WINAPI QueryUnbiasedInterruptTimePrecise(ULONGLONG*);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _REALTIMEAPISET_H_ */
diff --git a/include/shellapi.h b/include/shellapi.h
index a00e1037bd8..ff36803fa19 100644
--- a/include/shellapi.h
+++ b/include/shellapi.h
@@ -671,7 +671,7 @@ typedef struct _SHSTOCKICONINFO
 #define SHGSI_SHELLICONSIZE SHGFI_SHELLICONSIZE
 
 WINSHELLAPI HRESULT     WINAPI SHGetStockIconInfo(SHSTOCKICONID, UINT, SHSTOCKICONINFO*);
-WINSHELLAPI LPWSTR*     WINAPI CommandLineToArgvW(LPCWSTR,int*);
+WINSHELLAPI WCHAR**     WINAPI CommandLineToArgvW(const WCHAR*,int*) __WINE_DEALLOC(LocalFree);
 WINSHELLAPI HICON       WINAPI ExtractIconA(HINSTANCE,LPCSTR,UINT);
 WINSHELLAPI HICON       WINAPI ExtractIconW(HINSTANCE,LPCWSTR,UINT);
 #define                        ExtractIcon WINELIB_NAME_AW(ExtractIcon)
diff --git a/include/sqlucode.h b/include/sqlucode.h
index f1eaace87c1..a4721b04208 100644
--- a/include/sqlucode.h
+++ b/include/sqlucode.h
@@ -32,6 +32,9 @@ extern "C" {
 #define SQL_WVARCHAR          (-9)
 #define SQL_WLONGVARCHAR      (-10)
 
+SQLRETURN WINAPI SQLColAttributesW(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLUSMALLINT fDescType,
+            SQLPOINTER rgbDesc, SQLSMALLINT cbDescMax, SQLSMALLINT *pcbDesc, SQLLEN *pfDesc);
+
 SQLRETURN WINAPI SQLConnectW(SQLHDBC ConnectionHandle,
            SQLWCHAR *ServerName, SQLSMALLINT NameLength1,
            SQLWCHAR *UserName, SQLSMALLINT NameLength2,
@@ -43,6 +46,11 @@ SQLRETURN WINAPI SQLDescribeColW(SQLHSTMT StatementHandle,
            SQLSMALLINT *DataType, SQLULEN *ColumnSize,
            SQLSMALLINT *DecimalDigits, SQLSMALLINT *Nullable);
 
+SQLRETURN WINAPI SQLDriverConnectW(SQLHDBC ConnectionHandle,
+           SQLHWND WindowHandle, WCHAR *InConnectionString,
+           SQLSMALLINT Length, WCHAR *OutConnectionString, SQLSMALLINT BufferLength,
+           SQLSMALLINT *Length2, SQLUSMALLINT DriverCompletion);
+
 SQLRETURN WINAPI SQLExecDirectW(SQLHSTMT StatementHandle,
            SQLWCHAR *StatementText, SQLINTEGER TextLength);
 
diff --git a/include/threadpoolapiset.h b/include/threadpoolapiset.h
index 6d8ac44a058..73203f413ee 100644
--- a/include/threadpoolapiset.h
+++ b/include/threadpoolapiset.h
@@ -33,17 +33,17 @@ WINBASEAPI void        WINAPI CloseThreadpoolIo(TP_IO*);
 WINBASEAPI void        WINAPI CloseThreadpoolTimer(PTP_TIMER);
 WINBASEAPI void        WINAPI CloseThreadpoolWait(PTP_WAIT);
 WINBASEAPI void        WINAPI CloseThreadpoolWork(PTP_WORK);
-WINBASEAPI TP_POOL*    WINAPI CreateThreadpool(void*) __WINE_DEALLOC(CloseThreadpool) __WINE_MALLOC;
+WINBASEAPI TP_POOL*    WINAPI CreateThreadpool(void*) __WINE_DEALLOC(CloseThreadpool);
 WINBASEAPI TP_CLEANUP_GROUP* WINAPI CreateThreadpoolCleanupGroup(void)
-                                    __WINE_DEALLOC(CloseThreadpoolCleanupGroup) __WINE_MALLOC;
+                                    __WINE_DEALLOC(CloseThreadpoolCleanupGroup);
 WINBASEAPI TP_IO*      WINAPI CreateThreadpoolIo(HANDLE,PTP_WIN32_IO_CALLBACK,void*,TP_CALLBACK_ENVIRON*)
-                              __WINE_DEALLOC(CloseThreadpoolIo) __WINE_MALLOC;
+                              __WINE_DEALLOC(CloseThreadpoolIo);
 WINBASEAPI TP_TIMER*   WINAPI CreateThreadpoolTimer(PTP_TIMER_CALLBACK,void*,TP_CALLBACK_ENVIRON*)
-                              __WINE_DEALLOC(CloseThreadpoolTimer) __WINE_MALLOC;
+                              __WINE_DEALLOC(CloseThreadpoolTimer);
 WINBASEAPI TP_WAIT*    WINAPI CreateThreadpoolWait(PTP_WAIT_CALLBACK,void*,TP_CALLBACK_ENVIRON*)
-                              __WINE_DEALLOC(CloseThreadpoolWait) __WINE_MALLOC;
+                              __WINE_DEALLOC(CloseThreadpoolWait);
 WINBASEAPI TP_WORK*    WINAPI CreateThreadpoolWork(PTP_WORK_CALLBACK,void*,TP_CALLBACK_ENVIRON*)
-                              __WINE_DEALLOC(CloseThreadpoolWork) __WINE_MALLOC;
+                              __WINE_DEALLOC(CloseThreadpoolWork);
 WINBASEAPI void        WINAPI DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE);
 WINBASEAPI void        WINAPI FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE,HMODULE);
 WINBASEAPI BOOL        WINAPI IsThreadpoolTimerSet(PTP_TIMER);
diff --git a/include/uiautomationclient.idl b/include/uiautomationclient.idl
index ffef7b840fb..7a0b50288d4 100644
--- a/include/uiautomationclient.idl
+++ b/include/uiautomationclient.idl
@@ -69,6 +69,7 @@ typedef void * UIA_HWND;
 [
     uuid(944de083-8fb8-45cf-bcb7-c477acb2f897),
     lcid(0),
+    id(2),
     version(1.0)
 ]
 library UIAutomationClient {
@@ -156,6 +157,8 @@ library UIAutomationClient {
         const long UIA_DropTarget_DroppedEventId = 20031;
         const long UIA_TextEdit_TextChangedEventId = 20032;
         const long UIA_TextEdit_ConversionTargetChangedEventId = 20033;
+        const long UIA_ChangesEventId = 20034;
+        const long UIA_NotificationEventId = 20035;
     /*
     };
     */
@@ -622,25 +625,298 @@ library UIAutomationClient {
                 [in] int changesCount);
     }
 
-    interface IUIAutomationNotificationEventHandler;
+    [
+        object,
+        uuid(c7cb2637-e6c2-4d0c-85de-4948c02175c7),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationNotificationEventHandler : IUnknown
+    {
+        HRESULT HandleNotificationEvent(
+                [in] IUIAutomationElement *sender,
+                enum NotificationKind notificationKind,
+                enum NotificationProcessing notificationProcessing,
+                [in] BSTR displayString,
+                [in] BSTR activityId);
+    }
+
+    [
+        object,
+        uuid(fb377fbe-8ea6-46d5-9c73-6499642d3059),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationInvokePattern : IUnknown
+    {
+        HRESULT Invoke();
+    }
+
+    [
+        object,
+        uuid(fde5ef97-1464-48f6-90bf-43d0948e86ec),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationDockPattern : IUnknown
+    {
+        HRESULT SetDockPosition([in] enum DockPosition dockPos);
+        [propget] HRESULT CurrentDockPosition([out, retval] enum DockPosition *retVal);
+        [propget] HRESULT CachedDockPosition([out, retval] enum DockPosition *retVal);
+    }
+
+    [
+        object,
+        uuid(619be086-1f4e-4ee4-bafa-210128738730),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationExpandCollapsePattern : IUnknown
+    {
+        HRESULT Expand();
+        HRESULT Collapse();
+        [propget] HRESULT CurrentExpandCollapseState([out, retval] enum ExpandCollapseState *retVal);
+        [propget] HRESULT CachedExpandCollapseState([out, retval] enum ExpandCollapseState *retVal);
+    }
+
+    [
+        object,
+        uuid(414c3cdc-856b-4f5b-8538-3131c6302550),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationGridPattern : IUnknown
+    {
+        HRESULT GetItem(
+                [in] int row,
+                [in] int column,
+                [out, retval] IUIAutomationElement **element);
+
+        [propget] HRESULT CurrentRowCount([out, retval] int *retVal);
+        [propget] HRESULT CurrentColumnCount([out, retval] int *retVal);
+        [propget] HRESULT CachedRowCount([out, retval] int *retVal);
+        [propget] HRESULT CachedColumnCount([out, retval] int *retVal);
+    }
+
+    [
+        object,
+        uuid(78f8ef57-66c3-4e09-bd7c-e79b2004894d),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationGridItemPattern : IUnknown
+    {
+        [propget] HRESULT CurrentContainingGrid([out, retval] IUIAutomationElement **retVal);
+        [propget] HRESULT CurrentRow([out, retval] int *retVal);
+        [propget] HRESULT CurrentColumn([out, retval] int *retVal);
+        [propget] HRESULT CurrentRowSpan([out, retval] int *retVal);
+        [propget] HRESULT CurrentColumnSpan([out, retval] int *retVal);
+        [propget] HRESULT CachedContainingGrid([out, retval] IUIAutomationElement **retVal);
+        [propget] HRESULT CachedRow([out, retval] int *retVal);
+        [propget] HRESULT CachedColumn([out, retval] int *retVal);
+        [propget] HRESULT CachedRowSpan([out, retval] int *retVal);
+        [propget] HRESULT CachedColumnSpan([out, retval] int *retVal);
+    }
+
+    [
+        object,
+        uuid(8d253c91-1dc5-4bb5-b18f-ade16fa495e8),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationMultipleViewPattern : IUnknown
+    {
+        HRESULT GetViewName(
+                [in] int view,
+                [out, retval] BSTR *name);
+
+        HRESULT SetCurrentView([in] int view);
+
+        [propget] HRESULT CurrentCurrentView([out, retval] int *retVal);
+        HRESULT GetCurrentSupportedViews([out, retval] SAFEARRAY(int) *retVal);
+
+        [propget] HRESULT CachedCurrentView([out, retval] int *retVal);
+        HRESULT GetCachedSupportedViews([out, retval] SAFEARRAY(int) *retVal);
+    }
+
+    [
+        object,
+        uuid(71c284b3-c14d-4d14-981e-19751b0d756d),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationObjectModelPattern : IUnknown
+    {
+        HRESULT GetUnderlyingObjectModel([out, retval] IUnknown **retVal);
+    }
+
+    [
+        object,
+        uuid(59213f4f-7346-49e5-b120-80555987a148),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationRangeValuePattern : IUnknown
+    {
+        HRESULT SetValue([in] double val);
+
+        [propget] HRESULT CurrentValue([out, retval] double *retVal);
+        [propget] HRESULT CurrentIsReadOnly([out, retval] BOOL *retVal);
+        [propget] HRESULT CurrentMaximum([out, retval] double *retVal);
+        [propget] HRESULT CurrentMinimum([out, retval] double *retVal);
+        [propget] HRESULT CurrentLargeChange([out, retval] double *retVal);
+        [propget] HRESULT CurrentSmallChange([out, retval] double *retVal);
 
-    interface IUIAutomationInvokePattern;
-    interface IUIAutomationDockPattern;
-    interface IUIAutomationExpandCollapsePattern;
-    interface IUIAutomationGridPattern;
-    interface IUIAutomationGridItemPattern;
-    interface IUIAutomationMultipleViewPattern;
-    interface IUIAutomationObjectModelPattern;
-    interface IUIAutomationRangeValuePattern;
-    interface IUIAutomationScrollPattern;
-    interface IUIAutomationScrollItemPattern;
-    interface IUIAutomationSelectionPattern;
-    interface IUIAutomationSelectionItemPattern;
-    interface IUIAutomationSynchronizedInputPattern;
-    interface IUIAutomationTablePattern;
-    interface IUIAutomationTableItemPattern;
-    interface IUIAutomationTogglePattern;
-    interface IUIAutomationTransformPattern;
+        [propget] HRESULT CachedValue([out, retval] double *retVal);
+        [propget] HRESULT CachedIsReadOnly([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedMaximum([out, retval] double *retVal);
+        [propget] HRESULT CachedMinimum([out, retval] double *retVal);
+        [propget] HRESULT CachedLargeChange([out, retval] double *retVal);
+        [propget] HRESULT CachedSmallChange([out, retval] double *retVal);
+    }
+
+    [
+        object,
+        uuid(88f4d42a-e881-459d-a77c-73bbbb7e02dc),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationScrollPattern : IUnknown
+    {
+        HRESULT Scroll(
+                [in] enum ScrollAmount horizontalAmount,
+                [in] enum ScrollAmount verticalAmount);
+        HRESULT SetScrollPercent(
+                [in] double horizontalPercent,
+                [in] double verticalPercent);
+
+        [propget] HRESULT CurrentHorizontalScrollPercent([out, retval] double *retVal);
+        [propget] HRESULT CurrentVerticalScrollPercent([out, retval] double *retVal);
+        [propget] HRESULT CurrentHorizontalViewSize([out, retval] double *retVal);
+        [propget] HRESULT CurrentVerticalViewSize([out, retval] double *retVal);
+        [propget] HRESULT CurrentHorizontallyScrollable([out, retval] BOOL *retVal);
+        [propget] HRESULT CurrentVerticallyScrollable([out, retval] BOOL *retVal);
+
+        [propget] HRESULT CachedHorizontalScrollPercent([out, retval] double *retVal);
+        [propget] HRESULT CachedVerticalScrollPercent([out, retval] double *retVal);
+        [propget] HRESULT CachedHorizontalViewSize([out, retval] double *retVal);
+        [propget] HRESULT CachedVerticalViewSize([out, retval] double *retVal);
+        [propget] HRESULT CachedHorizontallyScrollable([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedVerticallyScrollable([out, retval] BOOL *retVal);
+    }
+
+    [
+        object,
+        uuid(b488300f-d015-4f19-9c29-bb595e3645ef),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationScrollItemPattern : IUnknown
+    {
+        HRESULT ScrollIntoView();
+    }
+
+    [
+        object,
+        uuid(5ed5202e-b2ac-47a6-b638-4b0bf140d78e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSelectionPattern : IUnknown
+    {
+        HRESULT GetCurrentSelection([out, retval] IUIAutomationElementArray **retVal);
+        [propget] HRESULT CurrentCanSelectMultiple([out, retval] BOOL *retVal);
+        [propget] HRESULT CurrentIsSelectionRequired([out, retval] BOOL *retVal);
+
+        HRESULT GetCachedSelection([out, retval] IUIAutomationElementArray **retVal);
+        [propget] HRESULT CachedCanSelectMultiple([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedIsSelectionRequired([out, retval] BOOL *retVal);
+    }
+
+    [
+        object,
+        uuid(a8efa66a-0fda-421a-9194-38021f3578ea),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSelectionItemPattern : IUnknown
+    {
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+
+        [propget] HRESULT CurrentIsSelected([out, retval] BOOL *retVal);
+        [propget] HRESULT CurrentSelectionContainer([out, retval] IUIAutomationElement **retVal);
+
+        [propget] HRESULT CachedIsSelected([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedSelectionContainer([out, retval] IUIAutomationElement **retVal);
+    }
+
+    [
+        object,
+        uuid(2233be0b-afb7-448b-9fda-3b378aa5eae1),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSynchronizedInputPattern : IUnknown
+    {
+        HRESULT StartListening([in] enum SynchronizedInputType inputType);
+        HRESULT Cancel();
+    }
+
+    [
+        object,
+        uuid(620e691c-ea96-4710-a850-754b24ce2417),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTablePattern : IUnknown
+    {
+        HRESULT GetCurrentRowHeaders([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCurrentColumnHeaders([out, retval] IUIAutomationElementArray **retVal);
+        [propget] HRESULT CurrentRowOrColumnMajor([out, retval] enum RowOrColumnMajor *retVal);
+
+        HRESULT GetCachedRowHeaders([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCachedColumnHeaders([out, retval] IUIAutomationElementArray **retVal);
+        [propget] HRESULT CachedRowOrColumnMajor([out, retval] enum RowOrColumnMajor *retVal);
+    }
+
+    [
+        object,
+        uuid(0b964eb3-ef2e-4464-9c79-61d61737a27e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTableItemPattern : IUnknown
+    {
+        HRESULT GetCurrentRowHeaderItems([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCurrentColumnHeaderItems([out, retval] IUIAutomationElementArray **retVal);
+
+        HRESULT GetCachedRowHeaderItems([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCachedColumnHeaderItems([out, retval] IUIAutomationElementArray **retVal);
+    }
+
+    [
+        object,
+        uuid(94cf8058-9b8d-4ab9-8bfd-4cd0a33c8c70),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTogglePattern : IUnknown
+    {
+        HRESULT Toggle();
+
+        [propget] HRESULT CurrentToggleState([out, retval] enum ToggleState *retVal);
+        [propget] HRESULT CachedToggleState([out, retval] enum ToggleState *retVal);
+    }
+
+    [
+        object,
+        uuid(a9b55844-a55d-4ef0-926d-569c16ff89bb),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTransformPattern : IUnknown
+    {
+        HRESULT Move(
+                [in] double x,
+                [in] double y);
+        HRESULT Resize(
+                [in] double width,
+                [in] double height);
+        HRESULT Rotate([in] double degrees);
+
+        [propget] HRESULT CurrentCanMove([out, retval] BOOL *retVal);
+        [propget] HRESULT CurrentCanResize([out, retval] BOOL *retVal);
+        [propget] HRESULT CurrentCanRotate([out, retval] BOOL *retVal);
+
+        [propget] HRESULT CachedCanMove([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedCanResize([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedCanRotate([out, retval] BOOL *retVal);
+    }
 
     [
         object,
@@ -685,14 +961,162 @@ library UIAutomationClient {
         [propget] HRESULT CachedWindowInteractionState([out, retval] enum WindowInteractionState *retVal);
     }
 
-    interface IUIAutomationTextRange;
-    interface IUIAutomationTextRange2;
-    interface IUIAutomationTextRangeArray;
-    interface IUIAutomationTextPattern;
-    interface IUIAutomationTextPattern2;
-    interface IUIAutomationTextEditPattern;
-    interface IUIAutomationCustomNavigationPattern;
-    interface IUIAutomationActiveTextPositionChangedEventHandler;
+    [
+        object,
+        uuid(a543cc6a-f4ae-494b-8239-c814481187a8),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextRange : IUnknown
+    {
+        HRESULT Clone([out, retval] IUIAutomationTextRange **clonedRange);
+        HRESULT Compare(
+                [in] IUIAutomationTextRange *range,
+                [out, retval] BOOL *areSame);
+        HRESULT CompareEndpoints(
+                [in] enum TextPatternRangeEndpoint srcEndPoint,
+                [in] IUIAutomationTextRange *range,
+                [in] enum TextPatternRangeEndpoint targetEndPoint,
+                [out, retval] int *compValue);
+
+        HRESULT ExpandToEnclosingUnit([in] enum TextUnit textUnit);
+
+        HRESULT FindAttribute(
+                [in] TEXTATTRIBUTEID attr,
+                [in] VARIANT val,
+                [in] BOOL backward,
+                [out, retval] IUIAutomationTextRange **found);
+        HRESULT FindText(
+                [in] BSTR text,
+                [in] BOOL backward,
+                [in] BOOL ignoreCase,
+                [out, retval] IUIAutomationTextRange **found);
+
+        HRESULT GetAttributeValue(
+                [in] TEXTATTRIBUTEID attr,
+                [out, retval] VARIANT *value);
+        HRESULT GetBoundingRectangles([out, retval] SAFEARRAY(double) *boundingRects);
+        HRESULT GetEnclosingElement([out, retval] IUIAutomationElement **enclosingElement);
+        HRESULT GetText(
+                [in] int maxLength,
+                [out, retval] BSTR *text);
+
+        HRESULT Move(
+                [in] enum TextUnit unit,
+                [in] int count,
+                [out, retval] int *moved);
+        HRESULT MoveEndpointByUnit(
+                [in] enum TextPatternRangeEndpoint endpoint,
+                [in] enum TextUnit unit,
+                [in] int count,
+                [out, retval] int *moved);
+        HRESULT MoveEndpointByRange(
+                [in] enum TextPatternRangeEndpoint srcEndPoint,
+                [in] IUIAutomationTextRange *range,
+                [in] enum TextPatternRangeEndpoint targetEndPoint);
+
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection( );
+        HRESULT ScrollIntoView([in] BOOL alignToTop);
+
+        HRESULT GetChildren([out, retval] IUIAutomationElementArray **children);
+    }
+
+    [
+        object,
+        uuid(bb9b40e0-5e04-46bd-9be0-4b601b9afad4),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextRange2 : IUIAutomationTextRange
+    {
+        HRESULT ShowContextMenu();
+    }
+
+    [
+        object,
+        uuid(ce4ae76a-e717-4c98-81ea-47371d028eb6),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextRangeArray : IUnknown
+    {
+        [propget] HRESULT Length([out, retval] int *length);
+        HRESULT GetElement(
+                [in] int index,
+                [out, retval] IUIAutomationTextRange **element);
+    }
+
+    [
+        object,
+        uuid(32eba289-3583-42c9-9c59-3b6d9a1e9b6a),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextPattern : IUnknown
+    {
+        HRESULT RangeFromPoint(
+                [in] POINT pt,
+                [out, retval] IUIAutomationTextRange **range);
+        HRESULT RangeFromChild(
+                [in] IUIAutomationElement *child,
+                [out, retval] IUIAutomationTextRange **range);
+
+        HRESULT GetSelection([out, retval] IUIAutomationTextRangeArray **ranges);
+        HRESULT GetVisibleRanges([out, retval] IUIAutomationTextRangeArray **ranges);
+        [propget] HRESULT DocumentRange([out, retval] IUIAutomationTextRange **range);
+        [propget] HRESULT SupportedTextSelection([out, retval] enum SupportedTextSelection *supportedTextSelection);
+
+    }
+
+    [
+        object,
+        uuid(506a921a-fcc9-409f-b23b-37eb74106872),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextPattern2 : IUIAutomationTextPattern
+    {
+        HRESULT RangeFromAnnotation(
+                [in] IUIAutomationElement *annotation,
+                [out, retval] IUIAutomationTextRange **range);
+
+        HRESULT GetCaretRange(
+                [out] BOOL *isActive,
+                [out, retval] IUIAutomationTextRange **range);
+    }
+
+    [
+        object,
+        uuid(17e21576-996c-4870-99d9-bff323380c06),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextEditPattern : IUIAutomationTextPattern
+    {
+        HRESULT GetActiveComposition([out, retval] IUIAutomationTextRange **range);
+        HRESULT GetConversionTarget([out, retval] IUIAutomationTextRange **range);
+    }
+
+    [
+        object,
+        uuid(01ea217a-1766-47ed-a6cc-acf492854b1f),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationCustomNavigationPattern : IUnknown
+    {
+        HRESULT Navigate(
+                [in] enum NavigateDirection direction,
+                [out, retval] IUIAutomationElement **pRetVal);
+    }
+
+    [
+        object,
+        uuid(f97933b0-8dae-4496-8997-5ba015fe0d82),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationActiveTextPositionChangedEventHandler : IUnknown
+    {
+        HRESULT HandleActiveTextPositionChangedEvent(
+                [in] IUIAutomationElement *sender,
+                [in] IUIAutomationTextRange *range);
+    }
 
     [
         object,
@@ -730,16 +1154,175 @@ library UIAutomationClient {
         HRESULT GetIAccessible([out, retval] IAccessible **ppAccessible);
     };
 
-    interface IUIAutomationItemContainerPattern;
-    interface IUIAutomationVirtualizedItemPattern;
-    interface IUIAutomationAnnotationPattern;
-    interface IUIAutomationStylesPattern;
-    interface IUIAutomationSpreadsheetPattern;
-    interface IUIAutomationSpreadsheetItemPattern;
-    interface IUIAutomationTransformPattern2;
-    interface IUIAutomationTextChildPattern;
-    interface IUIAutomationDragPattern;
-    interface IUIAutomationDropTargetPattern;
+    [
+        object,
+        uuid(c690fdb2-27a8-423c-812d-429773c9084e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationItemContainerPattern : IUnknown
+    {
+        HRESULT FindItemByProperty(
+                [in] IUIAutomationElement *pStartAfter,
+                [in] PROPERTYID propertyId,
+                [in] VARIANT value,
+                [out, retval] IUIAutomationElement **pFound);
+    };
+
+    [
+        object,
+        uuid(6ba3d7a6-04cf-4f11-8793-a8d1cde9969f),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationVirtualizedItemPattern : IUnknown
+    {
+        HRESULT Realize();
+    };
+
+    [
+        object,
+        uuid(9a175b21-339e-41b1-8e8b-623f6b681098),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationAnnotationPattern : IUnknown
+    {
+        [propget] HRESULT CurrentAnnotationTypeId([out, retval] int *retVal);
+        [propget] HRESULT CurrentAnnotationTypeName([out, retval] BSTR *retVal);
+        [propget] HRESULT CurrentAuthor( [out, retval] BSTR *retVal);
+        [propget] HRESULT CurrentDateTime( [out, retval] BSTR *retVal);
+        [propget] HRESULT CurrentTarget( [out, retval] IUIAutomationElement **retVal);
+
+        [propget] HRESULT CachedAnnotationTypeId([out, retval] int *retVal);
+        [propget] HRESULT CachedAnnotationTypeName([out, retval] BSTR *retVal);
+        [propget] HRESULT CachedAuthor( [out, retval] BSTR *retVal);
+        [propget] HRESULT CachedDateTime( [out, retval] BSTR *retVal);
+        [propget] HRESULT CachedTarget( [out, retval] IUIAutomationElement **retVal);
+    };
+
+    [
+        object,
+        uuid(85b5f0a2-bd79-484a-ad2b-388c9838d5fb),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationStylesPattern : IUnknown
+    {
+        [propget] HRESULT CurrentStyleId([out, retval] int *retVal);
+        [propget] HRESULT CurrentStyleName([out, retval] BSTR *retVal);
+        [propget] HRESULT CurrentFillColor([out, retval] int *retVal);
+        [propget] HRESULT CurrentFillPatternStyle([out, retval] BSTR *retVal);
+        [propget] HRESULT CurrentShape([out, retval] BSTR *retVal);
+        [propget] HRESULT CurrentFillPatternColor([out, retval] int *retVal);
+        [propget] HRESULT CurrentExtendedProperties([out, retval] BSTR *retVal);
+        HRESULT GetCurrentExtendedPropertiesAsArray(
+                [out, size_is( ,*propertyCount)] struct ExtendedProperty **propertyArray,
+                [out] int *propertyCount);
+
+        [propget] HRESULT CachedStyleId([out, retval] int *retVal);
+        [propget] HRESULT CachedStyleName([out, retval] BSTR *retVal);
+        [propget] HRESULT CachedFillColor([out, retval] int *retVal);
+        [propget] HRESULT CachedFillPatternStyle([out, retval] BSTR *retVal);
+        [propget] HRESULT CachedShape([out, retval] BSTR *retVal);
+        [propget] HRESULT CachedFillPatternColor([out, retval] int *retVal);
+        [propget] HRESULT CachedExtendedProperties([out, retval] BSTR *retVal);
+        HRESULT GetCachedExtendedPropertiesAsArray(
+                [out, size_is( ,*propertyCount)] struct ExtendedProperty **propertyArray,
+                [out] int *propertyCount);
+    };
+
+    [
+        object,
+        uuid(7517a7c8-faae-4de9-9f08-29b91e8595c1),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSpreadsheetPattern : IUnknown
+    {
+        HRESULT GetItemByName(
+                [in] BSTR name,
+                [out, retval] IUIAutomationElement **element);
+    };
+
+    [
+        object,
+        uuid(7d4fb86c-8d34-40e1-8e83-62c15204e335),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSpreadsheetItemPattern : IUnknown
+    {
+        [propget] HRESULT CurrentFormula([out, retval] BSTR *retVal);
+        HRESULT GetCurrentAnnotationObjects([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCurrentAnnotationTypes([out, retval] SAFEARRAY(int) *retVal);
+
+        [propget] HRESULT CachedFormula([out, retval] BSTR *retVal);
+        HRESULT GetCachedAnnotationObjects([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCachedAnnotationTypes([out, retval] SAFEARRAY(int) *retVal);
+    };
+
+    [
+        object,
+        uuid(6d74d017-6ecb-4381-b38b-3c17a48ff1c2),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTransformPattern2 : IUIAutomationTransformPattern
+    {
+        HRESULT Zoom([in] double zoomValue);
+        HRESULT ZoomByUnit([in] enum ZoomUnit zoomUnit);
+
+        [propget] HRESULT CurrentCanZoom([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedCanZoom([out, retval] BOOL *retVal);
+
+        [propget] HRESULT CurrentZoomLevel([out, retval] double *retVal);
+        [propget] HRESULT CachedZoomLevel([out, retval] double *retVal);
+
+        [propget] HRESULT CurrentZoomMinimum([out, retval] double *retVal);
+        [propget] HRESULT CachedZoomMinimum([out, retval] double *retVal);
+
+        [propget] HRESULT CurrentZoomMaximum([out, retval] double *retVal);
+        [propget] HRESULT CachedZoomMaximum([out, retval] double *retVal);
+    }
+
+    [
+        object,
+        uuid(6552b038-ae05-40c8-abfd-aa08352aab86),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextChildPattern : IUnknown
+    {
+        [propget] HRESULT TextContainer([out, retval] IUIAutomationElement **container);
+        [propget] HRESULT TextRange([out, retval] IUIAutomationTextRange **range);
+    }
+
+    [
+        object,
+        uuid(1dc7b570-1f54-4bad-bcda-d36a722fb7bd),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationDragPattern : IUnknown
+    {
+        [propget] HRESULT CurrentIsGrabbed([out, retval] BOOL *retVal);
+        [propget] HRESULT CachedIsGrabbed([out, retval] BOOL *retVal);
+
+        [propget] HRESULT CurrentDropEffect([out, retval] BSTR *retVal);
+        [propget] HRESULT CachedDropEffect([out, retval] BSTR *retVal);
+
+        [propget] HRESULT CurrentDropEffects([out, retval] SAFEARRAY(BSTR) *retVal);
+        [propget] HRESULT CachedDropEffects([out, retval] SAFEARRAY(BSTR) *retVal);
+
+        HRESULT GetCurrentGrabbedItems([out, retval] IUIAutomationElementArray **retVal);
+        HRESULT GetCachedGrabbedItems([out, retval] IUIAutomationElementArray **retVal);
+    }
+
+    [
+        object,
+        uuid(69a095f7-eee4-430e-a46b-fb73b1ae39a5),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationDropTargetPattern : IUnknown
+    {
+        [propget] HRESULT CurrentDropTargetEffect([out, retval] BSTR *retVal);
+        [propget] HRESULT CachedDropTargetEffect([out, retval] BSTR *retVal);
+
+        [propget] HRESULT CurrentDropTargetEffects([out, retval] SAFEARRAY(BSTR) *retVal);
+        [propget] HRESULT CachedDropTargetEffects([out, retval] SAFEARRAY(BSTR) *retVal);
+    }
 
     [
         object,
@@ -1033,9 +1616,79 @@ library UIAutomationClient {
                 [out, retval] IUIAutomationElement **element);
     }
 
-    interface IUIAutomationProxyFactory;
-    interface IUIAutomationProxyFactoryEntry;
-    interface IUIAutomationProxyFactoryMapping;
+    [
+        object,
+        uuid(85b94ecd-849d-42b6-b94d-d6db23fdf5a4),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationProxyFactory : IUnknown
+    {
+        HRESULT CreateProvider(
+                [in] UIA_HWND hwnd,
+                [in] LONG idObject,
+                [in] LONG idChild,
+                [out, retval] IRawElementProviderSimple **provider);
+
+        [propget] HRESULT ProxyFactoryId([out, retval] BSTR *factoryId);
+    }
+
+    [
+        object,
+        uuid(d50e472e-b64b-490c-bca1-d30696f9f289),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationProxyFactoryEntry : IUnknown
+    {
+        [propget] HRESULT ProxyFactory([out, retval] IUIAutomationProxyFactory **factory);
+
+        [propget] HRESULT ClassName([out, retval] BSTR *className);
+        [propget] HRESULT ImageName([out, retval] BSTR *imageName);
+        [propget] HRESULT AllowSubstringMatch([out, retval] BOOL *allowSubstringMatch);
+        [propget] HRESULT CanCheckBaseClass([out, retval] BOOL *canCheckBaseClass);
+        [propget] HRESULT NeedsAdviseEvents([out, retval] BOOL *adviseEvents);
+
+        [propput] HRESULT ClassName([in] LPCWSTR className);
+        [propput] HRESULT ImageName([in] LPCWSTR imageName);
+        [propput] HRESULT AllowSubstringMatch([in] BOOL allowSubstringMatch);
+        [propput] HRESULT CanCheckBaseClass([in] BOOL canCheckBaseClass);
+        [propput] HRESULT NeedsAdviseEvents([in] BOOL adviseEvents);
+
+        HRESULT SetWinEventsForAutomationEvent(
+                [in] EVENTID eventId,
+                [in] PROPERTYID propertyId,
+                [in] SAFEARRAY(UINT) winEvents);
+        HRESULT GetWinEventsForAutomationEvent(
+                [in] EVENTID eventId,
+                [in] PROPERTYID propertyId,
+                [out, retval] SAFEARRAY(UINT) *winEvents);
+    }
+
+    [
+        object,
+        uuid(09e31e18-872d-4873-93d1-1e541ec133fd),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationProxyFactoryMapping : IUnknown
+    {
+        [propget] HRESULT Count([out, retval] UINT *count);
+
+        HRESULT GetTable([out, retval] SAFEARRAY(IUIAutomationProxyFactoryEntry) *table);
+        HRESULT GetEntry(
+                [in] UINT index,
+                [out, retval] IUIAutomationProxyFactoryEntry **entry);
+
+        HRESULT SetTable([in] SAFEARRAY(IUIAutomationProxyFactoryEntry) factoryList);
+        HRESULT InsertEntries(
+                [in] UINT before,
+                [in] SAFEARRAY(IUIAutomationProxyFactoryEntry) factoryList);
+        HRESULT InsertEntry(
+                [in] UINT before,
+                [in] IUIAutomationProxyFactoryEntry *factory);
+
+        HRESULT RemoveEntry([in] UINT index);
+        HRESULT ClearTable();
+        HRESULT RestoreDefaultTable();
+    }
 
     [
         object,
diff --git a/include/uiautomationcore.idl b/include/uiautomationcore.idl
index 98894407441..319bc7be475 100644
--- a/include/uiautomationcore.idl
+++ b/include/uiautomationcore.idl
@@ -63,12 +63,59 @@ enum OrientationType {
     OrientationType_Vertical   = 0x0002,
 };
 
+enum DockPosition {
+    DockPosition_Top    = 0x0000,
+    DockPosition_Left   = 0x0001,
+    DockPosition_Bottom = 0x0002,
+    DockPosition_Right  = 0x0003,
+    DockPosition_Fill   = 0x0004,
+    DockPosition_None   = 0x0005,
+};
+
+enum ExpandCollapseState {
+    ExpandCollapseState_Collapsed         = 0x0000,
+    ExpandCollapseState_Expanded          = 0x0001,
+    ExpandCollapseState_PartiallyExpanded = 0x0002,
+    ExpandCollapseState_LeafNode          = 0x0003,
+};
+
+enum ScrollAmount {
+    ScrollAmount_LargeDecrement = 0x0000,
+    ScrollAmount_SmallDecrement = 0x0001,
+    ScrollAmount_NoAmount       = 0x0002,
+    ScrollAmount_LargeIncrement = 0x0003,
+    ScrollAmount_SmallIncrement = 0x0004,
+};
+
+enum RowOrColumnMajor {
+    RowOrColumnMajor_RowMajor      = 0x0000,
+    RowOrColumnMajor_ColumnMajor   = 0x0001,
+    RowOrColumnMajor_Indeterminate = 0x0002,
+};
+
+enum ToggleState {
+    ToggleState_Off           = 0x0000,
+    ToggleState_On            = 0x0001,
+    ToggleState_Indeterminate = 0x0002,
+};
+
 enum WindowVisualState {
     WindowVisualState_Normal    = 0x0000,
     WindowVisualState_Maximized = 0x0001,
     WindowVisualState_Minimized = 0x0002,
 };
 
+enum SynchronizedInputType {
+    SynchronizedInputType_KeyUp          = 0x0001,
+    SynchronizedInputType_KeyDown        = 0x0002,
+    SynchronizedInputType_LeftMouseUp    = 0x0004,
+    SynchronizedInputType_LeftMouseDown  = 0x0008,
+    SynchronizedInputType_RightMouseUp   = 0x0010,
+    SynchronizedInputType_RightMouseDown = 0x0020,
+};
+
+cpp_quote("DEFINE_ENUM_FLAG_OPERATORS(SynchronizedInputType)")
+
 enum WindowInteractionState {
     WindowInteractionState_Running                 = 0x0000,
     WindowInteractionState_Closing                 = 0x0001,
@@ -77,12 +124,57 @@ enum WindowInteractionState {
     WindowInteractionState_NotResponding           = 0x0004,
 };
 
+enum TextUnit {
+    TextUnit_Character = 0x0000,
+    TextUnit_Format    = 0x0001,
+    TextUnit_Word      = 0x0002,
+    TextUnit_Line      = 0x0003,
+    TextUnit_Paragraph = 0x0004,
+    TextUnit_Page      = 0x0005,
+    TextUnit_Document  = 0x0006,
+};
+
+enum TextPatternRangeEndpoint {
+    TextPatternRangeEndpoint_Start = 0x0000,
+    TextPatternRangeEndpoint_End   = 0x0001,
+};
+
+enum SupportedTextSelection {
+    SupportedTextSelection_None     = 0x0000,
+    SupportedTextSelection_Single   = 0x0001,
+    SupportedTextSelection_Multiple = 0x0002,
+};
+
 enum LiveSetting {
     Off       = 0x0000,
     Polite    = 0x0001,
     Assertive = 0x0002,
 };
 
+enum ZoomUnit {
+    ZoomUnit_NoAmount       = 0x0000,
+    ZoomUnit_LargeDecrement = 0x0001,
+    ZoomUnit_SmallDecrement = 0x0002,
+    ZoomUnit_LargeIncrement = 0x0003,
+    ZoomUnit_SmallIncrement = 0x0004,
+};
+
+enum NotificationProcessing {
+    NotificationProcessing_ImportantAll          = 0x0000,
+    NotificationProcessing_ImportantMostRecent   = 0x0001,
+    NotificationProcessing_All                   = 0x0002,
+    NotificationProcessing_MostRecent            = 0x0003,
+    NotificationProcessing_CurrentThenMostRecent = 0x0004,
+};
+
+enum NotificationKind {
+    NotificationKind_ItemAdded       = 0x0000,
+    NotificationKind_ItemRemoved     = 0x0001,
+    NotificationKind_ActionCompleted = 0x0002,
+    NotificationKind_ActionAborted   = 0x0003,
+    NotificationKind_Other           = 0x0004,
+};
+
 typedef int PROPERTYID;
 typedef int PATTERNID;
 typedef int EVENTID;
@@ -99,6 +191,11 @@ struct UiaRect {
     double height;
 };
 
+struct UiaPoint {
+    double x;
+    double y;
+};
+
 struct UiaChangeInfo {
     int     uiaId;
     VARIANT payload;
@@ -109,6 +206,7 @@ struct UiaChangeInfo {
     version(1.0),
     uuid(930299ce-9965-4dec-b0f4-a54848d4b667),
     lcid(0),
+    id(3),
     hidden
 ]
 library UIA
@@ -249,6 +347,602 @@ library UIA
         [propget] HRESULT DefaultAction([out, retval] BSTR *pszDefaultAction);
     }
 
+    [
+        object,
+        uuid(159bc72c-4ad3-485e-9637-d7052edf0146),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IDockProvider : IUnknown
+    {
+        HRESULT SetDockPosition([in] enum DockPosition dockPosition);
+        [propget] HRESULT DockPosition([out, retval] enum DockPosition *pRetVal);
+    };
+
+    [
+        object,
+        uuid(d847d3a5-cab0-4a98-8c32-ecb45c59ad24),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IExpandCollapseProvider : IUnknown
+    {
+        HRESULT Expand();
+        HRESULT Collapse();
+        [propget] HRESULT ExpandCollapseState([out, retval] enum ExpandCollapseState *pRetVal);
+    };
+
+    [
+        object,
+        uuid(b17d6187-0907-464b-a168-0ef17a1572b1),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IGridProvider : IUnknown
+    {
+        HRESULT GetItem(
+                [in] int row,
+                [in] int column,
+                [out, retval] IRawElementProviderSimple **pRetVal);
+
+        [propget] HRESULT RowCount([out, retval] int *pRetVal);
+        [propget] HRESULT ColumnCount([out, retval] int *pRetVal);
+    };
+
+    [
+        object,
+        uuid(d02541f1-fb81-4d64-ae32-f520f8a6dbd1),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IGridItemProvider : IUnknown
+    {
+        [propget] HRESULT Row([out, retval] int *pRetVal);
+        [propget] HRESULT Column([out, retval] int *pRetVal);
+        [propget] HRESULT RowSpan([out, retval] int *pRetVal);
+        [propget] HRESULT ColumnSpan([out, retval] int *pRetVal);
+        [propget] HRESULT ContainingGrid([out, retval] IRawElementProviderSimple **pRetVal);
+    };
+
+    [
+        object,
+        uuid(54fcb24b-e18e-47a2-b4d3-eccbe77599a2),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IInvokeProvider : IUnknown
+    {
+        HRESULT Invoke();
+    };
+
+    [
+        object,
+        uuid(6278cab1-b556-4a1a-b4e0-418acc523201),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IMultipleViewProvider : IUnknown
+    {
+        HRESULT GetViewName(
+                [in] int viewId,
+                [out, retval] BSTR *pRetVal);
+
+        HRESULT SetCurrentView([in] int viewId);
+        [propget] HRESULT CurrentView([out, retval] int *pRetVal);
+        HRESULT GetSupportedViews([out, retval] SAFEARRAY(int) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(36dc7aef-33e6-4691-afe1-2be7274b3d33),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IRangeValueProvider : IUnknown
+    {
+        HRESULT SetValue([in] double val);
+        [propget] HRESULT Value([out, retval] double *pRetVal);
+        [propget] HRESULT IsReadOnly([out, retval] BOOL *pRetVal);
+        [propget] HRESULT Maximum([out, retval] double *pRetVal);
+        [propget] HRESULT Minimum([out, retval] double *pRetVal);
+        [propget] HRESULT LargeChange([out, retval] double *pRetVal);
+        [propget] HRESULT SmallChange([out, retval] double *pRetVal);
+    };
+
+    [
+        object,
+        uuid(2360c714-4bf1-4b26-ba65-9b21316127eb),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IScrollItemProvider : IUnknown
+    {
+        HRESULT ScrollIntoView();
+    };
+
+    [
+        object,
+        uuid(fb8b03af-3bdf-48d4-bd36-1a65793be168),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISelectionProvider : IUnknown
+    {
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(IRawElementProviderSimple *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetSelection([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+        [propget] HRESULT CanSelectMultiple([out, retval] BOOL *pRetVal);
+        [propget] HRESULT IsSelectionRequired([out, retval] BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(b38b8077-1fc3-42a5-8cae-d40c2215055a),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IScrollProvider : IUnknown
+    {
+        HRESULT Scroll(
+                [in] enum ScrollAmount horizontalAmount,
+                [in] enum ScrollAmount verticalAmount);
+        HRESULT SetScrollPercent(
+                [in] double horizontalPercent,
+                [in] double verticalPercent);
+
+        [propget] HRESULT HorizontalScrollPercent([out, retval] double *pRetVal);
+        [propget] HRESULT VerticalScrollPercent([out, retval] double *pRetVal);
+        [propget] HRESULT HorizontalViewSize([out, retval] double *pRetVal);
+        [propget] HRESULT VerticalViewSize([out, retval] double *pRetVal);
+        [propget] HRESULT HorizontallyScrollable([out, retval] BOOL *pRetVal);
+        [propget] HRESULT VerticallyScrollable([out, retval] BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(2acad808-b2d4-452d-a407-91ff1ad167b2),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISelectionItemProvider : IUnknown
+    {
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+        [propget] HRESULT IsSelected([out, retval] BOOL *pRetVal);
+        [propget] HRESULT SelectionContainer([out, retval] IRawElementProviderSimple **pRetVal);
+    };
+
+    [
+        object,
+        uuid(29db1a06-02ce-4cf7-9b42-565d4fab20ee),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISynchronizedInputProvider : IUnknown
+    {
+        HRESULT StartListening([in] enum SynchronizedInputType inputType);
+        HRESULT Cancel();
+    };
+
+    [
+        object,
+        uuid(9c860395-97b3-490a-b52a-858cc22af166),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITableProvider : IUnknown
+    {
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(IRawElementProviderSimple *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetRowHeaders([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetColumnHeaders([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+        [propget] HRESULT RowOrColumnMajor([out, retval] enum RowOrColumnMajor *pRetVal);
+    };
+
+    [
+        object,
+        uuid(b9734fa6-771f-4d78-9c90-2517999349cd),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITableItemProvider : IUnknown
+    {
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(IRawElementProviderSimple *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetRowHeaderItems([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetColumnHeaderItems([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(56d00bd0-c4f4-433c-a836-1a52a57e0892),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IToggleProvider : IUnknown
+    {
+        HRESULT Toggle();
+        [propget] HRESULT ToggleState([out, retval] enum ToggleState *pRetVal);
+    };
+
+    [
+        object,
+        uuid(6829ddc4-4f91-4ffa-b86f-bd3e2987cb4c),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITransformProvider : IUnknown
+    {
+        HRESULT Move(
+                [in] double x,
+                [in] double y);
+        HRESULT Resize(
+                [in] double width,
+                [in] double height);
+
+        HRESULT Rotate([in] double degrees);
+        [propget] HRESULT CanMove([out, retval] BOOL *pRetVal);
+        [propget] HRESULT CanResize([out, retval] BOOL *pRetVal);
+        [propget] HRESULT CanRotate([out, retval] BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(c7935180-6fb3-4201-b174-7df73adbf64a),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IValueProvider : IUnknown
+    {
+        HRESULT SetValue([in] LPCWSTR val);
+        [propget] HRESULT Value([out, retval] BSTR *pRetVal);
+        [propget] HRESULT IsReadOnly([out, retval] BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(987df77b-db06-4d77-8f8a-86a9c3bb90b9),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IWindowProvider : IUnknown
+    {
+        HRESULT SetVisualState([in] enum WindowVisualState state);
+        HRESULT Close();
+
+        HRESULT WaitForInputIdle(
+                [in] int milliseconds,
+                [out, retval] BOOL *pRetVal);
+
+        [propget] HRESULT CanMaximize([out, retval] BOOL *pRetVal);
+        [propget] HRESULT CanMinimize([out, retval] BOOL *pRetVal);
+        [propget] HRESULT IsModal([out, retval] BOOL *pRetVal);
+        [propget] HRESULT WindowVisualState([out, retval] enum WindowVisualState *pRetVal);
+        [propget] HRESULT WindowInteractionState([out, retval] enum WindowInteractionState *pRetVal);
+        [propget] HRESULT IsTopmost([out, retval] BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(e747770b-39ce-4382-ab30-d8fb3f336f24),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IItemContainerProvider : IUnknown
+    {
+        HRESULT FindItemByProperty(
+                [in] IRawElementProviderSimple *pStartAfter,
+                [in] PROPERTYID propertyId,
+                [in] VARIANT value,
+                [out, retval] IRawElementProviderSimple **pFound);
+    };
+
+    [
+        object,
+        uuid(cb98b665-2d35-4fac-ad35-f3c60d0c0b8b),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IVirtualizedItemProvider : IUnknown
+    {
+        HRESULT Realize();
+    };
+
+    [
+        object,
+        uuid(3ad86ebd-f5ef-483d-bb18-b1042a475d64),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IObjectModelProvider : IUnknown
+    {
+        HRESULT GetUnderlyingObjectModel([out, retval] IUnknown **ppUnknown);
+    };
+
+    [
+        object,
+        uuid(f95c7e80-bd63-4601-9782-445ebff011fc),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IAnnotationProvider : IUnknown
+    {
+        [propget] HRESULT AnnotationTypeId([out, retval] int *retVal);
+        [propget] HRESULT AnnotationTypeName([out, retval] BSTR *retVal);
+        [propget] HRESULT Author([out, retval] BSTR *retVal);
+        [propget] HRESULT DateTime([out, retval] BSTR *retVal);
+        [propget] HRESULT Target([out, retval] IRawElementProviderSimple **retVal);
+    };
+
+    [
+        object,
+        uuid(19b6b649-f5d7-4a6d-bdcb-129252be588a),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IStylesProvider : IUnknown
+    {
+        [propget] HRESULT StyleId([out, retval] int *retVal);
+        [propget] HRESULT StyleName([out, retval] BSTR *retVal);
+        [propget] HRESULT FillColor([out, retval] int *retVal);
+        [propget] HRESULT FillPatternStyle([out, retval] BSTR *retVal);
+        [propget] HRESULT Shape([out, retval] BSTR *retVal);
+        [propget] HRESULT FillPatternColor([out, retval] int *retVal);
+        [propget] HRESULT ExtendedProperties([out, retval] BSTR *retVal);
+    };
+
+    [
+        object,
+        uuid(6f6b5d35-5525-4f80-b758-85473832ffc7),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISpreadsheetProvider : IUnknown
+    {
+        HRESULT GetItemByName(
+                [in] LPCWSTR name,
+                [out, retval] IRawElementProviderSimple **pRetVal);
+    };
+
+    [
+        object,
+        uuid(eaed4660-7b3d-4879-a2e6-365ce603f3d0),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISpreadsheetItemProvider : IUnknown
+    {
+        [propget] HRESULT Formula([out, retval] BSTR *pRetVal);
+
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(IRawElementProviderSimple *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetAnnotationObjects([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetAnnotationTypes([out, retval] SAFEARRAY(int) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(4758742f-7ac2-460c-bc48-09fc09308a93),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITransformProvider2 : ITransformProvider
+    {
+        HRESULT Zoom([in] double zoom);
+        [propget] HRESULT CanZoom([out, retval] BOOL *pRetVal);
+        [propget] HRESULT ZoomLevel([out, retval] double *pRetVal);
+        [propget] HRESULT ZoomMinimum([out, retval] double *pRetVal);
+        [propget] HRESULT ZoomMaximum([out, retval] double *pRetVal);
+        HRESULT ZoomByUnit([in] enum ZoomUnit zoomUnit);
+    }
+
+    [
+        object,
+        uuid(6aa7bbbb-7ff9-497d-904f-d20b897929d8),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IDragProvider : IUnknown
+    {
+        [propget] HRESULT IsGrabbed([out, retval] BOOL *pRetVal);
+        [propget] HRESULT DropEffect([out, retval] BSTR *pRetVal);
+        [propget] HRESULT DropEffects([out, retval] SAFEARRAY(BSTR) *pRetVal);
+
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(IRawElementProviderSimple *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetGrabbedItems([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(bae82bfd-358a-481c-85a0-d8b4d90a5d61),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IDropTargetProvider : IUnknown
+    {
+        [propget] HRESULT DropTargetEffect([out, retval] BSTR *pRetVal);
+        [propget] HRESULT DropTargetEffects([out, retval] SAFEARRAY(BSTR) *pRetVal);
+    };
+
+    interface ITextRangeProvider;
+    [
+        object,
+        uuid(3589c92c-63f3-4367-99bb-ada653b77cf2),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextProvider : IUnknown
+    {
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(ITextRangeProvider *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetSelection([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetVisibleRanges([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+
+        HRESULT RangeFromChild(
+                [in] IRawElementProviderSimple *childElement,
+                [out, retval] ITextRangeProvider **pRetVal);
+        HRESULT RangeFromPoint(
+                [in] struct UiaPoint point,
+                [out, retval] ITextRangeProvider **pRetVal);
+
+        [propget] HRESULT DocumentRange([out, retval] ITextRangeProvider **pRetVal);
+        [propget] HRESULT SupportedTextSelection([out, retval] enum SupportedTextSelection *pRetVal);
+    };
+
+    [
+        object,
+        uuid(0dc5e6ed-3e16-4bf1-8f9a-a979878bc195),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextProvider2 : ITextProvider
+    {
+        HRESULT RangeFromAnnotation(
+                [in] IRawElementProviderSimple *annotationElement,
+                [out, retval] ITextRangeProvider **pRetVal);
+        HRESULT GetCaretRange(
+                [out] BOOL *isActive,
+                [out, retval] ITextRangeProvider **pRetVal);
+    }
+
+    [
+        object,
+        uuid(ea3605b4-3a05-400e-b5f9-4e91b40f6176),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextEditProvider : ITextProvider
+    {
+        HRESULT GetActiveComposition([out, retval] ITextRangeProvider **pRetVal);
+        HRESULT GetConversionTarget([out, retval] ITextRangeProvider **pRetVal);
+    }
+
+    [
+        object,
+        uuid(5347ad7b-c355-46f8-aff5-909033582f63),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextRangeProvider : IUnknown
+    {
+        HRESULT Clone([out, retval] ITextRangeProvider **pRetVal);
+
+        HRESULT Compare(
+                [in] ITextRangeProvider *range,
+                [out, retval] BOOL *pRetVal);
+        HRESULT CompareEndpoints(
+                [in] enum TextPatternRangeEndpoint endpoint,
+                [in] ITextRangeProvider *targetRange,
+                [in] enum TextPatternRangeEndpoint targetEndpoint,
+                [out, retval] int *pRetVal);
+
+        HRESULT ExpandToEnclosingUnit([in] enum TextUnit unit);
+
+        HRESULT FindAttribute(
+                [in] TEXTATTRIBUTEID attributeId,
+                [in] VARIANT val,
+                [in] BOOL backward,
+                [out, retval] ITextRangeProvider **pRetVal);
+        HRESULT FindText(
+                [in] BSTR text,
+                [in] BOOL backward,
+                [in] BOOL ignoreCase,
+                [out, retval] ITextRangeProvider **pRetVal);
+
+        HRESULT GetAttributeValue(
+                [in] TEXTATTRIBUTEID attributeId,
+                [out, retval] VARIANT *pRetVal);
+
+        HRESULT GetBoundingRectangles([out, retval] SAFEARRAY(double) *pRetVal);
+        HRESULT GetEnclosingElement([out, retval] IRawElementProviderSimple **pRetVal);
+
+        HRESULT GetText(
+                [in] int maxLength,
+                [out, retval] BSTR *pRetVal);
+
+        HRESULT Move(
+                [in] enum TextUnit unit,
+                [in] int count,
+                [out, retval] int *pRetVal);
+        HRESULT MoveEndpointByUnit(
+                [in] enum TextPatternRangeEndpoint endpoint,
+                [in] enum TextUnit unit,
+                [in] int count,
+                [out, retval] int *pRetVal);
+        HRESULT MoveEndpointByRange(
+                [in] enum TextPatternRangeEndpoint endpoint,
+                [in] ITextRangeProvider *targetRange,
+                [in] enum TextPatternRangeEndpoint targetEndpoint);
+
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+        HRESULT ScrollIntoView([in] BOOL alignToTop);
+
+        /*
+         * FIXME: Current versions of Windows SDK use
+         * SAFEARRAY(IRawElementProviderSimple *) instead of
+         * SAFEARRAY(VARIANT).
+         */
+        HRESULT GetChildren([out, retval] SAFEARRAY(VARIANT) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(9bbce42c-1921-4f18-89ca-dba1910a0386),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextRangeProvider2 : ITextRangeProvider
+    {
+        HRESULT ShowContextMenu();
+    }
+
+    [
+        object,
+        uuid(4c2de2b9-c88f-4f88-a111-f1d336b7d1a9),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextChildProvider : IUnknown
+    {
+        [propget] HRESULT TextContainer([out, retval] IRawElementProviderSimple **pRetVal);
+        [propget] HRESULT TextRange([out, retval] ITextRangeProvider **pRetVal);
+    };
+
+    [
+        object,
+        uuid(2062a28a-8c07-4b94-8e12-7037c622aeb8),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ICustomNavigationProvider : IUnknown
+    {
+        HRESULT Navigate(
+                [in] enum NavigateDirection direction,
+                [out, retval] IRawElementProviderSimple **pRetVal);
+    }
+
     enum UIAutomationType {
         UIAutomationType_Int     = 0x01,
         UIAutomationType_Bool    = 0x02,
diff --git a/include/uiautomationcoreapi.h b/include/uiautomationcoreapi.h
index ef94c72d162..1d78113e1fd 100644
--- a/include/uiautomationcoreapi.h
+++ b/include/uiautomationcoreapi.h
@@ -221,6 +221,128 @@ DEFINE_GUID(Selection2_ItemCount_Property_GUID,                0xbb49eb9f,0x456d
 DEFINE_GUID(HeadingLevel_Property_GUID,                        0x29084272,0xaaaf,0x4a30,0x87,0x96,0x3c,0x12,0xf6,0x2b,0x6b,0xbb);
 DEFINE_GUID(IsDialog_Property_GUID,                            0x9d0dfb9b,0x8436,0x4501,0xbb,0xbb,0xe5,0x34,0xa4,0xfb,0x3b,0x3f);
 
+/*
+ * AutomationIdentifierType_Event GUIDs.
+ */
+DEFINE_GUID(ToolTipOpened_Event_GUID,                                  0x3f4b97ff,0x2edc,0x451d,0xbc,0xa4,0x95,0xa3,0x18,0x8d,0x5b,0x03);
+DEFINE_GUID(ToolTipClosed_Event_GUID,                                  0x276d71ef,0x24a9,0x49b6,0x8e,0x97,0xda,0x98,0xb4,0x01,0xbb,0xcd);
+DEFINE_GUID(StructureChanged_Event_GUID,                               0x59977961,0x3edd,0x4b11,0xb1,0x3b,0x67,0x6b,0x2a,0x2a,0x6c,0xa9);
+DEFINE_GUID(MenuOpened_Event_GUID,                                     0xebe2e945,0x66ca,0x4ed1,0x9f,0xf8,0x2a,0xd7,0xdf,0x0a,0x1b,0x08);
+DEFINE_GUID(AutomationPropertyChanged_Event_GUID,                      0x2527fba1,0x8d7a,0x4630,0xa4,0xcc,0xe6,0x63,0x15,0x94,0x2f,0x52);
+DEFINE_GUID(AutomationFocusChanged_Event_GUID,                         0xb68a1f17,0xf60d,0x41a7,0xa3,0xcc,0xb0,0x52,0x92,0x15,0x5f,0xe0);
+DEFINE_GUID(AsyncContentLoaded_Event_GUID,                             0x5fdee11c,0xd2fa,0x4fb9,0x90,0x4e,0x5c,0xbe,0xe8,0x94,0xd5,0xef);
+DEFINE_GUID(MenuClosed_Event_GUID,                                     0x3cf1266e,0x1582,0x4041,0xac,0xd7,0x88,0xa3,0x5a,0x96,0x52,0x97);
+DEFINE_GUID(LayoutInvalidated_Event_GUID,                              0xed7d6544,0xa6bd,0x4595,0x9b,0xae,0x3d,0x28,0x94,0x6c,0xc7,0x15);
+DEFINE_GUID(Invoke_Invoked_Event_GUID,                                 0xdfd699f0,0xc915,0x49dd,0xb4,0x22,0xdd,0xe7,0x85,0xc3,0xd2,0x4b);
+DEFINE_GUID(SelectionItem_ElementAddedToSelectionEvent_Event_GUID,     0x3c822dd1,0xc407,0x4dba,0x91,0xdd,0x79,0xd4,0xae,0xd0,0xae,0xc6);
+DEFINE_GUID(SelectionItem_ElementRemovedFromSelectionEvent_Event_GUID, 0x097fa8a9,0x7079,0x41af,0x8b,0x9c,0x09,0x34,0xd8,0x30,0x5e,0x5c);
+DEFINE_GUID(SelectionItem_ElementSelectedEvent_Event_GUID,             0xb9c7dbfb,0x4ebe,0x4532,0xaa,0xf4,0x00,0x8c,0xf6,0x47,0x23,0x3c);
+DEFINE_GUID(Selection_InvalidatedEvent_Event_GUID,                     0xcac14904,0x16b4,0x4b53,0x8e,0x47,0x4c,0xb1,0xdf,0x26,0x7b,0xb7);
+DEFINE_GUID(Text_TextSelectionChangedEvent_Event_GUID,                 0x918edaa1,0x71b3,0x49ae,0x97,0x41,0x79,0xbe,0xb8,0xd3,0x58,0xf3);
+DEFINE_GUID(Text_TextChangedEvent_Event_GUID,                          0x4a342082,0xf483,0x48c4,0xac,0x11,0xa8,0x4b,0x43,0x5e,0x2a,0x84);
+DEFINE_GUID(Window_WindowOpened_Event_GUID,                            0xd3e81d06,0xde45,0x4f2f,0x96,0x33,0xde,0x9e,0x02,0xfb,0x65,0xaf);
+DEFINE_GUID(Window_WindowClosed_Event_GUID,                            0xedf141f8,0xfa67,0x4e22,0xbb,0xf7,0x94,0x4e,0x05,0x73,0x5e,0xe2);
+DEFINE_GUID(MenuModeStart_Event_GUID,                                  0x18d7c631,0x166a,0x4ac9,0xae,0x3b,0xef,0x4b,0x54,0x20,0xe6,0x81);
+DEFINE_GUID(MenuModeEnd_Event_GUID,                                    0x9ecd4c9f,0x80dd,0x47b8,0x82,0x67,0x5a,0xec,0x06,0xbb,0x2c,0xff);
+DEFINE_GUID(InputReachedTarget_Event_GUID,                             0x93ed549a,0x0549,0x40f0,0xbe,0xdb,0x28,0xe4,0x4f,0x7d,0xe2,0xa3);
+DEFINE_GUID(InputReachedOtherElement_Event_GUID,                       0xed201d8a,0x4e6c,0x415e,0xa8,0x74,0x24,0x60,0xc9,0xb6,0x6b,0xa8);
+DEFINE_GUID(InputDiscarded_Event_GUID,                                 0x7f36c367,0x7b18,0x417c,0x97,0xe3,0x9d,0x58,0xdd,0xc9,0x44,0xab);
+DEFINE_GUID(SystemAlert_Event_GUID,                                    0xd271545d,0x7a3a,0x47a7,0x84,0x74,0x81,0xd2,0x9a,0x24,0x51,0xc9);
+DEFINE_GUID(LiveRegionChanged_Event_GUID,                              0x102d5e90,0xe6a9,0x41b6,0xb1,0xc5,0xa9,0xb1,0x92,0x9d,0x95,0x10);
+DEFINE_GUID(HostedFragmentRootsInvalidated_Event_GUID,                 0xe6bdb03e,0x0921,0x4ec5,0x8d,0xcf,0xea,0xe8,0x77,0xb0,0x42,0x6b);
+DEFINE_GUID(Drag_DragStart_Event_GUID,                                 0x883a480b,0x3aa9,0x429d,0x95,0xe4,0xd9,0xc8,0xd0,0x11,0xf0,0xdd);
+DEFINE_GUID(Drag_DragCancel_Event_GUID,                                0xc3ede6fa,0x3451,0x4e0f,0x9e,0x71,0xdf,0x9c,0x28,0x0a,0x46,0x57);
+DEFINE_GUID(Drag_DragComplete_Event_GUID,                              0x38e96188,0xef1f,0x463e,0x91,0xca,0x3a,0x77,0x92,0xc2,0x9c,0xaf);
+DEFINE_GUID(DropTarget_DragEnter_Event_GUID,                           0xaad9319b,0x032c,0x4a88,0x96,0x1d,0x1c,0xf5,0x79,0x58,0x1e,0x34);
+DEFINE_GUID(DropTarget_DragLeave_Event_GUID,                           0x0f82eb15,0x24a2,0x4988,0x92,0x17,0xde,0x16,0x2a,0xee,0x27,0x2b);
+DEFINE_GUID(DropTarget_Dropped_Event_GUID,                             0x622cead8,0x1edb,0x4a3d,0xab,0xbc,0xbe,0x22,0x11,0xff,0x68,0xb5);
+DEFINE_GUID(TextEdit_TextChanged_Event_GUID,                           0x120b0308,0xec22,0x4eb8,0x9c,0x98,0x98,0x67,0xcd,0xa1,0xb1,0x65);
+DEFINE_GUID(TextEdit_ConversionTargetChanged_Event_GUID,               0x3388c183,0xed4f,0x4c8b,0x9b,0xaa,0x36,0x4d,0x51,0xd8,0x84,0x7f);
+DEFINE_GUID(Changes_Event_GUID,                                        0x7df26714,0x614f,0x4e05,0x94,0x88,0x71,0x6c,0x5b,0xa1,0x94,0x36);
+DEFINE_GUID(Notification_Event_GUID,                                   0x72c5a2f7,0x9788,0x480f,0xb8,0xeb,0x4d,0xee,0x00,0xf6,0x18,0x6f);
+
+/*
+ * AutomationIdentifierType_Pattern GUIDs.
+ */
+DEFINE_GUID(Invoke_Pattern_GUID,            0xd976c2fc,0x66ea,0x4a6e,0xb2,0x8f,0xc2,0x4c,0x75,0x46,0xad,0x37);
+DEFINE_GUID(Selection_Pattern_GUID,         0x66e3b7e8,0xd821,0x4d25,0x87,0x61,0x43,0x5d,0x2c,0x8b,0x25,0x3f);
+DEFINE_GUID(Value_Pattern_GUID,             0x17faad9e,0xc877,0x475b,0xb9,0x33,0x77,0x33,0x27,0x79,0xb6,0x37);
+DEFINE_GUID(RangeValue_Pattern_GUID,        0x18b00d87,0xb1c9,0x476a,0xbf,0xbd,0x5f,0x0b,0xdb,0x92,0x6f,0x63);
+DEFINE_GUID(Scroll_Pattern_GUID,            0x895fa4b4,0x759d,0x4c50,0x8e,0x15,0x03,0x46,0x06,0x72,0x00,0x3c);
+DEFINE_GUID(ExpandCollapse_Pattern_GUID,    0xae05efa2,0xf9d1,0x428a,0x83,0x4c,0x53,0xa5,0xc5,0x2f,0x9b,0x8b);
+DEFINE_GUID(Grid_Pattern_GUID,              0x260a2ccb,0x93a8,0x4e44,0xa4,0xc1,0x3d,0xf3,0x97,0xf2,0xb0,0x2b);
+DEFINE_GUID(GridItem_Pattern_GUID,          0xf2d5c877,0xa462,0x4957,0xa2,0xa5,0x2c,0x96,0xb3,0x03,0xbc,0x63);
+DEFINE_GUID(MultipleView_Pattern_GUID,      0x547a6ae4,0x113f,0x47c4,0x85,0x0f,0xdb,0x4d,0xfa,0x46,0x6b,0x1d);
+DEFINE_GUID(Window_Pattern_GUID,            0x27901735,0xc760,0x4994,0xad,0x11,0x59,0x19,0xe6,0x06,0xb1,0x10);
+DEFINE_GUID(SelectionItem_Pattern_GUID,     0x9bc64eeb,0x87c7,0x4b28,0x94,0xbb,0x4d,0x9f,0xa4,0x37,0xb6,0xef);
+DEFINE_GUID(Dock_Pattern_GUID,              0x9cbaa846,0x83c8,0x428d,0x82,0x7f,0x7e,0x60,0x63,0xfe,0x06,0x20);
+DEFINE_GUID(Table_Pattern_GUID,             0xc415218e,0xa028,0x461e,0xaa,0x92,0x8f,0x92,0x5c,0xf7,0x93,0x51);
+DEFINE_GUID(TableItem_Pattern_GUID,         0xdf1343bd,0x1888,0x4a29,0xa5,0x0c,0xb9,0x2e,0x6d,0xe3,0x7f,0x6f);
+DEFINE_GUID(Text_Pattern_GUID,              0x8615f05d,0x7de5,0x44fd,0xa6,0x79,0x2c,0xa4,0xb4,0x60,0x33,0xa8);
+DEFINE_GUID(Toggle_Pattern_GUID,            0x0b419760,0xe2f4,0x43ff,0x8c,0x5f,0x94,0x57,0xc8,0x2b,0x56,0xe9);
+DEFINE_GUID(Transform_Pattern_GUID,         0x24b46fdb,0x587e,0x49f1,0x9c,0x4a,0xd8,0xe9,0x8b,0x66,0x4b,0x7b);
+DEFINE_GUID(ScrollItem_Pattern_GUID,        0x4591d005,0xa803,0x4d5c,0xb4,0xd5,0x8d,0x28,0x00,0xf9,0x06,0xa7);
+DEFINE_GUID(LegacyIAccessible_Pattern_GUID, 0x54cc0a9f,0x3395,0x48af,0xba,0x8d,0x73,0xf8,0x56,0x90,0xf3,0xe0);
+DEFINE_GUID(ItemContainer_Pattern_GUID,     0x3d13da0f,0x8b9a,0x4a99,0x85,0xfa,0xc5,0xc9,0xa6,0x9f,0x1e,0xd4);
+DEFINE_GUID(VirtualizedItem_Pattern_GUID,   0xf510173e,0x2e71,0x45e9,0xa6,0xe5,0x62,0xf6,0xed,0x82,0x89,0xd5);
+DEFINE_GUID(SynchronizedInput_Pattern_GUID, 0x05c288a6,0xc47b,0x488b,0xb6,0x53,0x33,0x97,0x7a,0x55,0x1b,0x8b);
+DEFINE_GUID(ObjectModel_Pattern_GUID,       0x3e04acfe,0x08fc,0x47ec,0x96,0xbc,0x35,0x3f,0xa3,0xb3,0x4a,0xa7);
+DEFINE_GUID(Annotation_Pattern_GUID,        0xf6c72ad7,0x356c,0x4850,0x92,0x91,0x31,0x6f,0x60,0x8a,0x8c,0x84);
+DEFINE_GUID(Text_Pattern2_GUID,             0x498479a2,0x5b22,0x448d,0xb6,0xe4,0x64,0x74,0x90,0x86,0x06,0x98);
+DEFINE_GUID(Styles_Pattern_GUID,            0x1ae62655,0xda72,0x4d60,0xa1,0x53,0xe5,0xaa,0x69,0x88,0xe3,0xbf);
+DEFINE_GUID(Spreadsheet_Pattern_GUID,       0x6a5b24c9,0x9d1e,0x4b85,0x9e,0x44,0xc0,0x2e,0x31,0x69,0xb1,0x0b);
+DEFINE_GUID(SpreadsheetItem_Pattern_GUID,   0x32cf83ff,0xf1a8,0x4a8c,0x86,0x58,0xd4,0x7b,0xa7,0x4e,0x20,0xba);
+DEFINE_GUID(Tranform_Pattern2_GUID,         0x8afcfd07,0xa369,0x44de,0x98,0x8b,0x2f,0x7f,0xf4,0x9f,0xb8,0xa8);
+DEFINE_GUID(TextChild_Pattern_GUID,         0x7533cab7,0x3bfe,0x41ef,0x9e,0x85,0xe2,0x63,0x8c,0xbe,0x16,0x9e);
+DEFINE_GUID(Drag_Pattern_GUID,              0xc0bee21f,0xccb3,0x4fed,0x99,0x5b,0x11,0x4f,0x6e,0x3d,0x27,0x28);
+DEFINE_GUID(DropTarget_Pattern_GUID,        0x0bcbec56,0xbd34,0x4b7b,0x9f,0xd5,0x26,0x59,0x90,0x5e,0xa3,0xdc);
+DEFINE_GUID(TextEdit_Pattern_GUID,          0x69f3ff89,0x5af9,0x4c75,0x93,0x40,0xf2,0xde,0x29,0x2e,0x45,0x91);
+DEFINE_GUID(CustomNavigation_Pattern_GUID,  0xafea938a,0x621e,0x4054,0xbb,0x2c,0x2f,0x46,0x11,0x4d,0xac,0x3f);
+
+/*
+ * AutomationIdentifierType_ControlType GUIDs.
+ */
+DEFINE_GUID(Button_Control_GUID,       0x5a78e369,0xc6a1,0x4f33,0xa9,0xd7,0x79,0xf2,0x0d,0x0c,0x78,0x8e);
+DEFINE_GUID(Calendar_Control_GUID,     0x8913eb88,0x00e5,0x46bc,0x8e,0x4e,0x14,0xa7,0x86,0xe1,0x65,0xa1);
+DEFINE_GUID(CheckBox_Control_GUID,     0xfb50f922,0xa3db,0x49c0,0x8b,0xc3,0x06,0xda,0xd5,0x57,0x78,0xe2);
+DEFINE_GUID(ComboBox_Control_GUID,     0x54cb426c,0x2f33,0x4fff,0xaa,0xa1,0xae,0xf6,0x0d,0xac,0x5d,0xeb);
+DEFINE_GUID(Edit_Control_GUID,         0x6504a5c8,0x2c86,0x4f87,0xae,0x7b,0x1a,0xbd,0xdc,0x81,0x0c,0xf9);
+DEFINE_GUID(Hyperlink_Control_GUID,    0x8a56022c,0xb00d,0x4d15,0x8f,0xf0,0x5b,0x6b,0x26,0x6e,0x5e,0x02);
+DEFINE_GUID(Image_Control_GUID,        0x2d3736e4,0x6b16,0x4c57,0xa9,0x62,0xf9,0x32,0x60,0xa7,0x52,0x43);
+DEFINE_GUID(ListItem_Control_GUID,     0x7b3717f2,0x44d1,0x4a58,0x98,0xa8,0xf1,0x2a,0x9b,0x8f,0x78,0xe2);
+DEFINE_GUID(List_Control_GUID,         0x9b149ee1,0x7cca,0x4cfc,0x9a,0xf1,0xca,0xc7,0xbd,0xdd,0x30,0x31);
+DEFINE_GUID(Menu_Control_GUID,         0x2e9b1440,0x0ea8,0x41fd,0xb3,0x74,0xc1,0xea,0x6f,0x50,0x3c,0xd1);
+DEFINE_GUID(MenuBar_Control_GUID,      0xcc384250,0x0e7b,0x4ae8,0x95,0xae,0xa0,0x8f,0x26,0x1b,0x52,0xee);
+DEFINE_GUID(MenuItem_Control_GUID,     0xf45225d3,0xd0a0,0x49d8,0x98,0x34,0x9a,0x00,0x0d,0x2a,0xed,0xdc);
+DEFINE_GUID(ProgressBar_Control_GUID,  0x228c9f86,0xc36c,0x47bb,0x9f,0xb6,0xa5,0x83,0x4b,0xfc,0x53,0xa4);
+DEFINE_GUID(RadioButton_Control_GUID,  0x3bdb49db,0xfe2c,0x4483,0xb3,0xe1,0xe5,0x7f,0x21,0x94,0x40,0xc6);
+DEFINE_GUID(ScrollBar_Control_GUID,    0xdaf34b36,0x5065,0x4946,0xb2,0x2f,0x92,0x59,0x5f,0xc0,0x75,0x1a);
+DEFINE_GUID(Slider_Control_GUID,       0xb033c24b,0x3b35,0x4cea,0xb6,0x09,0x76,0x36,0x82,0xfa,0x66,0x0b);
+DEFINE_GUID(Spinner_Control_GUID,      0x60cc4b38,0x3cb1,0x4161,0xb4,0x42,0xc6,0xb7,0x26,0xc1,0x78,0x25);
+DEFINE_GUID(StatusBar_Control_GUID,    0xd45e7d1b,0x5873,0x475f,0x95,0xa4,0x04,0x33,0xe1,0xf1,0xb0,0x0a);
+DEFINE_GUID(Tab_Control_GUID,          0x38cd1f2d,0x337a,0x4bd2,0xa5,0xe3,0xad,0xb4,0x69,0xe3,0x0b,0xd3);
+DEFINE_GUID(TabItem_Control_GUID,      0x2c6a634f,0x921b,0x4e6e,0xb2,0x6e,0x08,0xfc,0xb0,0x79,0x8f,0x4c);
+DEFINE_GUID(Text_Control_GUID,         0xae9772dc,0xd331,0x4f09,0xbe,0x20,0x7e,0x6d,0xfa,0xf0,0x7b,0x0a);
+DEFINE_GUID(ToolBar_Control_GUID,      0x8f06b751,0xe182,0x4e98,0x88,0x93,0x22,0x84,0x54,0x3a,0x7d,0xce);
+DEFINE_GUID(ToolTip_Control_GUID,      0x05ddc6d1,0x2137,0x4768,0x98,0xea,0x73,0xf5,0x2f,0x71,0x34,0xf3);
+DEFINE_GUID(Tree_Control_GUID,         0x7561349c,0xd241,0x43f4,0x99,0x08,0xb5,0xf0,0x91,0xbe,0xe6,0x11);
+DEFINE_GUID(TreeItem_Control_GUID,     0x62c9feb9,0x8ffc,0x4878,0xa3,0xa4,0x96,0xb0,0x30,0x31,0x5c,0x18);
+DEFINE_GUID(Custom_Control_GUID,       0xf29ea0c3,0xadb7,0x430a,0xba,0x90,0xe5,0x2c,0x73,0x13,0xe6,0xed);
+DEFINE_GUID(Group_Control_GUID,        0xad50aa1c,0xe8c8,0x4774,0xae,0x1b,0xdd,0x86,0xdf,0x0b,0x3b,0xdc);
+DEFINE_GUID(Thumb_Control_GUID,        0x701ca877,0xe310,0x4dd6,0xb6,0x44,0x79,0x7e,0x4f,0xae,0xa2,0x13);
+DEFINE_GUID(DataGrid_Control_GUID,     0x84b783af,0xd103,0x4b0a,0x84,0x15,0xe7,0x39,0x42,0x41,0x0f,0x4b);
+DEFINE_GUID(DataItem_Control_GUID,     0xa0177842,0xd94f,0x42a5,0x81,0x4b,0x60,0x68,0xad,0xdc,0x8d,0xa5);
+DEFINE_GUID(Document_Control_GUID,     0x3cd6bb6f,0x6f08,0x4562,0xb2,0x29,0xe4,0xe2,0xfc,0x7a,0x9e,0xb4);
+DEFINE_GUID(SplitButton_Control_GUID,  0x7011f01f,0x4ace,0x4901,0xb4,0x61,0x92,0x0a,0x6f,0x1c,0xa6,0x50);
+DEFINE_GUID(Window_Control_GUID,       0xe13a7242,0xf462,0x4f4d,0xae,0xc1,0x53,0xb2,0x8d,0x6c,0x32,0x90);
+DEFINE_GUID(Pane_Control_GUID,         0x5c2b3f5b,0x9182,0x42a3,0x8d,0xec,0x8c,0x04,0xc1,0xee,0x63,0x4d);
+DEFINE_GUID(Header_Control_GUID,       0x5b90cbce,0x78fb,0x4614,0x82,0xb6,0x55,0x4d,0x74,0x71,0x8e,0x67);
+DEFINE_GUID(HeaderItem_Control_GUID,   0xe6bc12cb,0x7c8e,0x49cf,0xb1,0x68,0x4a,0x93,0xa3,0x2b,0xeb,0xb0);
+DEFINE_GUID(Table_Control_GUID,        0x773bfa0e,0x5bc4,0x4deb,0x92,0x1b,0xde,0x7b,0x32,0x06,0x22,0x9e);
+DEFINE_GUID(TitleBar_Control_GUID,     0x98aa55bf,0x3bb0,0x4b65,0x83,0x6e,0x2e,0xa3,0x0d,0xbc,0x17,0x1f);
+DEFINE_GUID(Separator_Control_GUID,    0x8767eba3,0x2a63,0x4ab0,0xac,0x8d,0xaa,0x50,0xe2,0x3d,0xe9,0x78);
+DEFINE_GUID(SemanticZoom_Control_GUID, 0x5fd34a43,0x061e,0x42c8,0xb5,0x89,0x9d,0xcc,0xf7,0x4b,0xc4,0x3a);
+DEFINE_GUID(AppBar_Control_GUID,       0x6114908d,0xcc02,0x4d37,0x87,0x5b,0xb5,0x30,0xc7,0x13,0x95,0x54);
 
 enum AutomationIdentifierType
 {
@@ -399,8 +521,18 @@ HRESULT WINAPI UiaGetReservedMixedAttributeValue(IUnknown **value);
 HRESULT WINAPI UiaGetReservedNotSupportedValue(IUnknown **value);
 int WINAPI UiaLookupId(enum AutomationIdentifierType type, const GUID *guid);
 BOOL WINAPI UiaPatternRelease(HUIAPATTERNOBJECT hobj);
+HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple *provider,
+        enum AsyncContentLoadedState async_content_loaded_state, double percent_complete);
 HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple *provider, EVENTID id);
 HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple *, PROPERTYID, VARIANT, VARIANT);
+HRESULT WINAPI UiaRaiseChangesEvent(IRawElementProviderSimple *provider, int event_id_count,
+        struct UiaChangeInfo *uia_changes);
+HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *provider, enum NotificationKind notification_kind,
+        enum NotificationProcessing notification_processing, BSTR display_str, BSTR activity_id);
+HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
+        int *runtime_id, int runtime_id_len);
+HRESULT WINAPI UiaRaiseTextEditTextChangedEvent(IRawElementProviderSimple *provider, enum TextEditChangeType text_edit_change_type,
+        SAFEARRAY *changed_data);
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *pCallback);
 LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *elprov);
 BOOL WINAPI UiaTextRangeRelease(HUIATEXTRANGE hobj);
diff --git a/include/uiviewsettingsinterop.idl b/include/uiviewsettingsinterop.idl
new file mode 100644
index 00000000000..81cfc0e9dd9
--- /dev/null
+++ b/include/uiviewsettingsinterop.idl
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2022 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "inspectable.idl";
+
+[
+    uuid(3694dbf9-8f68-44be-8ff5-195c98ede8a6),
+]
+interface IUIViewSettingsInterop : IInspectable
+{
+    HRESULT GetForWindow([in] HWND hwnd, [in] REFIID riid, [out, retval, iid_is(riid)] void **ppv);
+}
diff --git a/include/winbase.h b/include/winbase.h
index 45492782cd5..6b3048f795e 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -46,6 +46,7 @@ extern "C" {
 #include <synchapi.h>
 #include <threadpoolapiset.h>
 #include <memoryapi.h>
+#include <realtimeapiset.h>
 
   /* Windows Exit Procedure flag values */
 #define	WEP_FREE_DLL        0
@@ -2605,7 +2606,6 @@ WINBASEAPI BOOL        WINAPI QueryInformationJobObject(HANDLE,JOBOBJECTINFOCLAS
 WINBASEAPI BOOL        WINAPI QueryMemoryResourceNotification(HANDLE,PBOOL);
 WINBASEAPI BOOL        WINAPI QueryPerformanceCounter(LARGE_INTEGER*);
 WINBASEAPI BOOL        WINAPI QueryPerformanceFrequency(LARGE_INTEGER*);
-WINBASEAPI BOOL        WINAPI QueryThreadCycleTime(HANDLE,PULONG64);
 WINBASEAPI BOOL        WINAPI QueryUmsThreadInformation(PUMS_CONTEXT,UMS_THREAD_INFO_CLASS,PVOID,ULONG,PULONG);
 WINBASEAPI DWORD       WINAPI QueueUserAPC(PAPCFUNC,HANDLE,ULONG_PTR);
 WINBASEAPI BOOL        WINAPI QueueUserWorkItem(LPTHREAD_START_ROUTINE,PVOID,ULONG);
diff --git a/include/winber.h b/include/winber.h
index 83055fa8c72..cb4f8e3ff54 100644
--- a/include/winber.h
+++ b/include/winber.h
@@ -29,12 +29,12 @@ typedef unsigned int ber_len_t;
 void CDECL ber_free( BerElement *, int );
 void CDECL ber_bvfree( BERVAL * );
 
-BerElement * CDECL ber_alloc_t( int ) __WINE_DEALLOC(ber_free) __WINE_MALLOC;
-BERVAL * CDECL ber_bvdup( BERVAL * ) __WINE_DEALLOC(ber_bvfree) __WINE_MALLOC;
+BerElement * CDECL ber_alloc_t( int ) __WINE_DEALLOC(ber_free);
+BERVAL * CDECL ber_bvdup( BERVAL * ) __WINE_DEALLOC(ber_bvfree);
 void CDECL ber_bvecfree( BERVAL ** );
 ULONG CDECL ber_first_element( BerElement *, ULONG *, char ** );
 int CDECL ber_flatten( BerElement *, BERVAL ** );
-BerElement * CDECL ber_init( BERVAL * ) __WINE_DEALLOC(ber_free) __WINE_MALLOC;
+BerElement * CDECL ber_init( BERVAL * ) __WINE_DEALLOC(ber_free);
 ULONG CDECL ber_next_element( BerElement *, ULONG *, char * );
 ULONG CDECL ber_peek_tag( BerElement *, ULONG * );
 int WINAPIV ber_printf( BerElement *, char *, ... );
diff --git a/include/windows.foundation.collections.idl b/include/windows.foundation.collections.idl
index 395adad27aa..680d7803cc8 100644
--- a/include/windows.foundation.collections.idl
+++ b/include/windows.foundation.collections.idl
@@ -23,7 +23,8 @@
 import "inspectable.idl";
 import "asyncinfo.idl";
 import "windowscontracts.idl";
-/* import "eventtoken.idl"; */
+import "eventtoken.idl";
+import "ivectorchangedeventargs.idl";
 
 namespace Windows {
     namespace Foundation {
@@ -67,6 +68,62 @@ cpp_quote("#endif")
             HRESULT GetResults([out, retval] TResult *results);
         }
 
+        interface IAsyncActionWithProgress<TProgress>;
+
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(6d844858-0cff-4590-ae89-95a5a5c8b4b8)
+        ]
+        delegate HRESULT AsyncActionProgressHandler<TProgress>([in] Windows.Foundation.IAsyncActionWithProgress<TProgress> *info,
+                                                               [in] TProgress progress);
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(9c029f91-cc84-44fd-ac26-0a6c4e555281)
+        ]
+        delegate HRESULT AsyncActionWithProgressCompletedHandler<TProgress>([in] Windows.Foundation.IAsyncActionWithProgress<TProgress> *info,
+                                                                            [in] AsyncStatus status);
+
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(1f6db258-e803-48a1-9546-eb7353398884)
+        ]
+        interface IAsyncActionWithProgress<TProgress> : IInspectable
+        {
+            [propput] HRESULT Progress([in] Windows.Foundation.AsyncActionProgressHandler<TProgress> *handler);
+            [propget] HRESULT Progress([out, retval] Windows.Foundation.AsyncActionProgressHandler<TProgress> **handler);
+            [propput] HRESULT Completed([in] Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> *handler);
+            [propget] HRESULT Completed([out, retval] Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress> **handler);
+            HRESULT GetResults();
+        }
+
+        interface IAsyncOperationWithProgress<TResult, TProgress>;
+
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(55690902-0aab-421a-8778-f8ce5026d758)
+        ]
+        delegate HRESULT AsyncOperationProgressHandler<TResult, TProgress>([in] Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress> *info,
+                                                                           [in] TProgress progress);
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(e85df41d-6aa7-46e3-a8e2-f009d840c627)
+        ]
+        delegate HRESULT AsyncOperationWithProgressCompletedHandler<TResult, TProgress>([in] Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress> *info,
+                                                                                        [in] AsyncStatus status);
+
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(b5d036d7-e297-498f-ba60-0289e76e23dd)
+        ]
+        interface IAsyncOperationWithProgress<TResult, TProgress> : IInspectable
+        {
+            [propput] HRESULT Progress([in] Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> *handler);
+            [propget] HRESULT Progress([out, retval] Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress> **handler);
+            [propput] HRESULT Completed([in] Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> *handler);
+            [propget] HRESULT Completed([out, retval] Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress> **handler);
+            HRESULT GetResults([out, retval] TResult *results);
+        }
+
         [
             contract(Windows.Foundation.FoundationContract, 1.0),
             uuid(9de1c534-6ae1-11e0-84e1-18a905bcc53f)
@@ -105,6 +162,25 @@ cpp_quote("#endif")
                 HRESULT First([out, retval] Windows.Foundation.Collections.IIterator<T> **value);
             }
 
+            [
+                contract(Windows.Foundation.FoundationContract, 1.0),
+                uuid(9939f4df-050a-4c0f-aa60-77075f9c4777)
+            ]
+            interface IMapChangedEventArgs<T> : IInspectable
+            {
+                [propget] HRESULT CollectionChanged([out, retval] Windows.Foundation.Collections.CollectionChange *value);
+                [propget] HRESULT Key([out, retval] T *key);
+            }
+
+            interface IObservableMap<K, V>;
+
+            [
+                contract(Windows.Foundation.FoundationContract, 1.0),
+                uuid(179517f3-94ee-41f8-bddc-768a895544f3)
+            ]
+            delegate HRESULT MapChangedEventHandler<K, V>([in] Windows.Foundation.Collections.IObservableMap<K, V> *sender,
+                                                          [in] Windows.Foundation.Collections.IMapChangedEventArgs<K> *args);
+
             [
                 contract(Windows.Foundation.FoundationContract, 1.0),
                 uuid(02b51929-c1c4-4a7e-8940-0312b5c18500)
@@ -129,6 +205,43 @@ cpp_quote("#endif")
                               [out] Windows.Foundation.Collections.IMapView<K, V> **second);
             }
 
+            [
+                contract(Windows.Foundation.FoundationContract, 1.0),
+                uuid(3c2925fe-8519-45c1-aa79-197b6718c1c1)
+            ]
+            interface IMap<K, V> : IInspectable
+                requires Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K, V> *>
+            {
+                HRESULT Lookup([in] K key, [out, retval] V *value);
+                [propget] HRESULT Size([out, retval] unsigned int *size);
+                HRESULT HasKey([in] K key, [out, retval] boolean *found);
+                HRESULT GetView([out, retval] Windows.Foundation.Collections.IMapView<K, V> **view);
+                HRESULT Insert([in] K key, [in] V value, [out, retval] boolean *replaced);
+                HRESULT Remove([in] K key);
+                HRESULT Clear();
+            }
+
+            [
+                contract(Windows.Foundation.FoundationContract, 1.0),
+                uuid(65df2bf5-bf39-41b5-aebc-5a9d865e472b)
+            ]
+            interface IObservableMap<K, V> : IInspectable
+                requires Windows.Foundation.Collections.IMap<K, V>
+            {
+                [eventadd] HRESULT MapChanged([in] Windows.Foundation.Collections.MapChangedEventHandler<K, V> *handler,
+                                              [out, retval] EventRegistrationToken *token);
+                [eventremove] HRESULT MapChanged([in] EventRegistrationToken token);
+            }
+
+            interface IObservableVector<T>;
+
+            [
+                contract(Windows.Foundation.FoundationContract, 1.0),
+                uuid(0c051752-9fbf-4c70-aa0c-0e4c82d9a761)
+            ]
+            delegate HRESULT VectorChangedEventHandler<T>([in] Windows.Foundation.Collections.IObservableVector<T> *sender,
+                                                          [in] Windows.Foundation.Collections.IVectorChangedEventArgs *args);
+
             [
                 contract(Windows.Foundation.FoundationContract, 1.0),
                 uuid(bbe1fa4c-b0e3-4583-baef-1f1b2e483e56)
@@ -162,6 +275,18 @@ cpp_quote("#endif")
                 HRESULT GetMany([in] UINT32 start_index, [in] UINT32 items_size, [out] T *items, [out, retval] UINT32 *value);
                 HRESULT ReplaceAll([in] UINT32 count, [in] T *items);
             }
+
+            [
+                contract(Windows.Foundation.FoundationContract, 1.0),
+                uuid(5917eb53-50b4-4a0d-b309-65862b3f1dbc)
+            ]
+            interface IObservableVector<T> : IInspectable
+                requires Windows.Foundation.Collections.IVector<T>
+            {
+                [eventadd] HRESULT VectorChanged([in] Windows.Foundation.Collections.VectorChangedEventHandler<T> *handler,
+                                              [out, retval] EventRegistrationToken *token);
+                [eventremove] HRESULT VectorChanged([in] EventRegistrationToken token);
+            }
         }
 #endif
     }
diff --git a/include/windows.foundation.idl b/include/windows.foundation.idl
index cdc603f8e84..96bdd1167e6 100644
--- a/include/windows.foundation.idl
+++ b/include/windows.foundation.idl
@@ -27,6 +27,32 @@ import "eventtoken.idl";
 /* import "ivectorchangedeventargs.idl"; */
 import "windows.foundation.collections.idl";
 
+namespace Windows.Foundation.Collections {
+    interface IPropertySet;
+
+    declare {
+        interface Windows.Foundation.Collections.IKeyValuePair<HSTRING, IInspectable *>;
+        interface Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<HSTRING, IInspectable *> *>;
+        interface Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<HSTRING, IInspectable *> *>;
+        interface Windows.Foundation.Collections.IMapChangedEventArgs<HSTRING>;
+        interface Windows.Foundation.Collections.MapChangedEventHandler<HSTRING, IInspectable *>;
+        interface Windows.Foundation.Collections.IMap<HSTRING, IInspectable *>;
+        interface Windows.Foundation.Collections.IMapView<HSTRING, IInspectable *>;
+        interface Windows.Foundation.Collections.IObservableMap<HSTRING, IInspectable *>;
+    }
+
+    [
+        contract(Windows.Foundation.FoundationContract, 1.0),
+        uuid(8a43ed9f-f4e6-4421-acf9-1dab2986820c)
+    ]
+    interface IPropertySet : IInspectable
+        requires Windows.Foundation.Collections.IObservableMap<HSTRING, IInspectable *>,
+                 Windows.Foundation.Collections.IMap<HSTRING, IInspectable *>,
+                 Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<HSTRING, IInspectable *> *>
+    {
+    }
+}
+
 namespace Windows.Foundation {
     typedef enum PropertyType PropertyType;
     typedef struct Point Point;
diff --git a/include/windows.globalization.idl b/include/windows.globalization.idl
index 03c44703b7e..639d0d24411 100644
--- a/include/windows.globalization.idl
+++ b/include/windows.globalization.idl
@@ -20,11 +20,13 @@
 #pragma winrt ns_prefix
 #endif
 
+#ifndef DO_NO_IMPORTS
 import "inspectable.idl";
 import "asyncinfo.idl";
 import "eventtoken.idl";
 import "windowscontracts.idl";
 import "windows.foundation.idl";
+#endif
 
 namespace Windows {
     namespace Globalization {
diff --git a/include/windows.security.credentials.idl b/include/windows.security.credentials.idl
new file mode 100644
index 00000000000..ca682baaf0e
--- /dev/null
+++ b/include/windows.security.credentials.idl
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+/* import "windows.security.cryptography.core.idl"; */
+import "windows.storage.streams.idl";
+import "windows.system.idl";
+
+namespace Windows.Security.Credentials {
+    typedef enum KeyCredentialCreationOption KeyCredentialCreationOption;
+    typedef enum KeyCredentialStatus KeyCredentialStatus;
+
+    interface IKeyCredential;
+    interface IKeyCredentialManagerStatics;
+    interface IKeyCredentialRetrievalResult;
+
+    runtimeclass KeyCredential;
+    runtimeclass KeyCredentialManager;
+    runtimeclass KeyCredentialRetrievalResult;
+
+    declare {
+        interface Windows.Foundation.AsyncOperationCompletedHandler<Windows.Security.Credentials.KeyCredentialRetrievalResult *>;
+        interface Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.KeyCredentialRetrievalResult *>;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum KeyCredentialCreationOption
+    {
+        ReplaceExisting = 0,
+        FailIfExists    = 1,
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum KeyCredentialStatus
+    {
+        Success                 = 0,
+        UnknownError            = 1,
+        NotFound                = 2,
+        UserCanceled            = 3,
+        UserPrefersPassword     = 4,
+        CredentialAlreadyExists = 5,
+        SecurityDeviceLocked    = 6,
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.Security.Credentials.KeyCredentialManager),
+        uuid(6aac468b-0ef1-4ce0-8290-4106da6a63b5)
+    ]
+    interface IKeyCredentialManagerStatics : IInspectable
+    {
+        HRESULT IsSupportedAsync([out, retval] Windows.Foundation.IAsyncOperation<boolean> **value);
+        HRESULT RenewAttestationAsync([out, retval] Windows.Foundation.IAsyncAction **operation);
+        HRESULT RequestCreateAsync(HSTRING name, Windows.Security.Credentials.KeyCredentialCreationOption option,
+                                   [out, retval] Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.KeyCredentialRetrievalResult *> **value);
+        HRESULT OpenAsync(HSTRING name, [out, retval] Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.KeyCredentialRetrievalResult *> **value);
+        HRESULT DeleteAsync(HSTRING name, [out, retval] Windows.Foundation.IAsyncAction **operation);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.Security.Credentials.KeyCredentialRetrievalResult),
+        uuid(58cd7703-8d87-4249-9b58-f6598cc9644e)
+    ]
+    interface IKeyCredentialRetrievalResult : IInspectable
+    {
+        [propget] HRESULT Credential([out, retval] Windows.Security.Credentials.KeyCredential **value);
+        [propget] HRESULT Status([out, retval] Windows.Security.Credentials.KeyCredentialStatus *value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass KeyCredential
+    {
+        [default] interface Windows.Security.Credentials.IKeyCredential;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile),
+        static(Windows.Security.Credentials.IKeyCredentialManagerStatics, Windows.Foundation.UniversalApiContract, 1.0),
+        threading(both)
+    ]
+    runtimeclass KeyCredentialManager
+    {
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass KeyCredentialRetrievalResult
+    {
+        [default] interface Windows.Security.Credentials.IKeyCredentialRetrievalResult;
+    }
+}
diff --git a/include/windows.system.profile.systemmanufacturers.idl b/include/windows.system.profile.systemmanufacturers.idl
new file mode 100644
index 00000000000..644a664020b
--- /dev/null
+++ b/include/windows.system.profile.systemmanufacturers.idl
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+namespace Windows.System.Profile.SystemManufacturers
+{
+    apicontract SystemManufacturersContract;
+    interface ISmbiosInformationStatics;
+    runtimeclass SmbiosInformation;
+
+    [
+        contractversion(3.0)
+    ]
+    apicontract SystemManufacturersContract
+    {
+    }
+
+    [
+        contract(Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0),
+        exclusiveto(Windows.System.Profile.SystemManufacturers.SmbiosInformation),
+        uuid(080cca7c-637c-48c4-b728-f9273812db8e)
+    ]
+    interface ISmbiosInformationStatics : IInspectable
+    {
+        [propget] HRESULT SerialNumber([out, retval] HSTRING *value);
+    }
+
+    [
+        contract(Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0),
+        marshaling_behavior(agile),
+        static(Windows.System.Profile.SystemManufacturers.ISmbiosInformationStatics, Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0)
+    ]
+    runtimeclass SmbiosInformation
+    {
+    }
+}
diff --git a/include/windows.system.userprofile.idl b/include/windows.system.userprofile.idl
index 4a066c9ae8b..65a334b97f8 100644
--- a/include/windows.system.userprofile.idl
+++ b/include/windows.system.userprofile.idl
@@ -20,12 +20,14 @@
 #pragma winrt ns_prefix
 #endif
 
+#ifndef DO_NO_IMPORTS
 import "inspectable.idl";
 import "asyncinfo.idl";
 import "eventtoken.idl";
 import "windowscontracts.idl";
 import "windows.foundation.idl";
 import "windows.globalization.idl";
+#endif
 
 namespace Windows {
     namespace System {
diff --git a/include/windows.ui.viewmanagement.idl b/include/windows.ui.viewmanagement.idl
new file mode 100644
index 00000000000..e7a90646338
--- /dev/null
+++ b/include/windows.ui.viewmanagement.idl
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2023 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+import "windows.devices.enumeration.idl";
+/* import "windows.phone.idl"; */
+import "windows.ui.idl";
+/* import "windows.ui.core.idl"; */
+/* import "windows.ui.popups.idl"; */
+/* import "windows.ui.windowmanagement.idl"; */
+
+namespace Windows.UI.ViewManagement
+{
+    typedef enum HandPreference HandPreference;
+    typedef enum UIColorType UIColorType;
+    typedef enum UIElementType UIElementType;
+
+    interface IUISettings;
+    interface IUISettings3;
+
+    runtimeclass UISettings;
+
+    declare {
+        interface Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings *, IInspectable *>;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum HandPreference
+    {
+        LeftHanded  = 0,
+        RightHanded = 1,
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum UIColorType
+    {
+        Background   = 0,
+        Foreground   = 1,
+        AccentDark3  = 2,
+        AccentDark2  = 3,
+        AccentDark1  = 4,
+        Accent       = 5,
+        AccentLight1 = 6,
+        AccentLight2 = 7,
+        AccentLight3 = 8,
+        Complement   = 9,
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0)
+    ]
+    enum UIElementType
+    {
+        ActiveCaption        = 0,
+        Background           = 1,
+        ButtonFace           = 2,
+        ButtonText           = 3,
+        CaptionText          = 4,
+        GrayText             = 5,
+        Highlight            = 6,
+        HighlightText        = 7,
+        Hotlight             = 8,
+        InactiveCaption      = 9,
+        InactiveCaptionText  = 10,
+        Window               = 11,
+        WindowText           = 12,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        AccentColor          = 1000,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        TextHigh             = 1001,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        TextMedium           = 1002,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        TextLow              = 1003,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        TextContrastWithHigh = 1004,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        NonTextHigh          = 1005,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        NonTextMediumHigh    = 1006,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        NonTextMedium        = 1007,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        NonTextMediumLow     = 1008,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        NonTextLow           = 1009,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        PageBackground       = 1010,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        PopupBackground      = 1011,
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+        OverlayOutsidePopup  = 1012,
+    };
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.ViewManagement.UISettings),
+        uuid(85361600-1c63-4627-bcb1-3a89e0bc9c55)
+    ]
+    interface IUISettings : IInspectable
+    {
+        [propget] HRESULT HandPreference([out, retval] Windows.UI.ViewManagement.HandPreference *value);
+        [propget] HRESULT CursorSize([out, retval] Windows.Foundation.Size *value);
+        [propget] HRESULT ScrollBarSize([out, retval] Windows.Foundation.Size *value);
+        [propget] HRESULT ScrollBarArrowSize([out, retval] Windows.Foundation.Size *value);
+        [propget] HRESULT ScrollBarThumbBoxSize([out, retval] Windows.Foundation.Size *value);
+        [propget] HRESULT MessageDuration([out, retval] UINT32 *value);
+        [propget] HRESULT AnimationsEnabled([out, retval] boolean *value);
+        [propget] HRESULT CaretBrowsingEnabled([out, retval] boolean *value);
+        [propget] HRESULT CaretBlinkRate([out, retval] UINT32 *value);
+        [propget] HRESULT CaretWidth([out, retval] UINT32 *value);
+        [propget] HRESULT DoubleClickTime([out, retval] UINT32 *value);
+        [propget] HRESULT MouseHoverTime([out, retval] UINT32 *value);
+        HRESULT UIElementColor([in] Windows.UI.ViewManagement.UIElementType element, [out, retval] Windows.UI.Color *value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        exclusiveto(Windows.UI.ViewManagement.UISettings),
+        uuid(03021be4-5254-4781-8194-5168f7d06d7b)
+    ]
+    interface IUISettings3 : IInspectable
+    {
+        HRESULT GetColorValue([in] Windows.UI.ViewManagement.UIColorType color, [out, retval] Windows.UI.Color *value);
+        [eventadd] HRESULT ColorValuesChanged([in] Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings *, IInspectable *> *handler,
+                                              [out, retval] EventRegistrationToken *cookie);
+        [eventremove] HRESULT ColorValuesChanged([in] EventRegistrationToken cookie);
+    }
+
+    [
+        activatable(Windows.Foundation.UniversalApiContract, 1.0),
+        contract(Windows.Foundation.UniversalApiContract, 1.0),
+        marshaling_behavior(agile)
+    ]
+    runtimeclass UISettings
+    {
+        [default] interface Windows.UI.ViewManagement.IUISettings;
+        [contract(Windows.Foundation.UniversalApiContract, 1.0)] interface Windows.UI.ViewManagement.IUISettings3;
+    }
+}
diff --git a/include/wine/asm.h b/include/wine/asm.h
index 2448f591189..61e197d9586 100644
--- a/include/wine/asm.h
+++ b/include/wine/asm.h
@@ -27,6 +27,12 @@
 # define __ASM_NAME(name) name
 #endif
 
+#if defined(__APPLE__)
+# define __ASM_LOCAL_LABEL(label) "L" label
+#else
+# define __ASM_LOCAL_LABEL(label) ".L" label
+#endif
+
 #if defined(__WINE_PE_BUILD) && defined(__i386__)
 # define __ASM_STDCALL(name,args)  "_" name "@" #args
 # define __ASM_FASTCALL(name,args) "@" name "@" #args
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 3db3d0d6af3..dca03934a44 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -217,6 +217,7 @@ struct window_surface
     struct list                        entry; /* entry in global list managed by user32 */
     LONG                               ref;   /* reference count */
     RECT                               rect;  /* constant, no locking needed */
+    DWORD                              draw_start_ticks; /* start ticks of fresh draw */
     /* driver-specific fields here */
 };
 
@@ -253,7 +254,6 @@ struct gdi_adapter
 
 struct gdi_monitor
 {
-    WCHAR name[128];      /* name */
     RECT rc_monitor;      /* RcMonitor in MONITORINFO struct */
     RECT rc_work;         /* RcWork in MONITORINFO struct */
     DWORD state_flags;    /* StateFlags in DISPLAY_DEVICE struct */
@@ -308,7 +308,7 @@ struct user_driver_funcs
     void    (*pDestroyWindow)(HWND);
     void    (*pFlashWindowEx)(FLASHWINFO*);
     void    (*pGetDC)(HDC,HWND,HWND,const RECT *,const RECT *,DWORD);
-    NTSTATUS (*pMsgWaitForMultipleObjectsEx)(DWORD,const HANDLE*,const LARGE_INTEGER*,DWORD,DWORD);
+    BOOL    (*pProcessEvents)(DWORD);
     void    (*pReleaseDC)(HWND,HDC);
     BOOL    (*pScrollDC)(HDC,INT,INT,HRGN);
     void    (*pSetCapture)(HWND,UINT);
diff --git a/include/wine/mscvpdb.h b/include/wine/mscvpdb.h
index 90adc3ee465..29dd83e73b9 100644
--- a/include/wine/mscvpdb.h
+++ b/include/wine/mscvpdb.h
@@ -43,30 +43,29 @@
  *
  * Regarding PDB files:
  * -------------------
- * They are implemented as a set of internal files (as a small file
- * system). The file is split into blocks, an internal file is made
- * of a set of blocks. Internal files are accessed through
- * numbers. For example,
- * 1/ is the ROOT (basic information on the file)
- * 2/ is the Symbol information (global symbols, local variables...)
- * 3/ is the Type internal file (each the symbols can have type
+ * They are implemented as a set of internal streams (as a small file
+ * system). The file is split into blocks, an internal stream is made of a set
+ * of blocks, that can be non continuous. The table of contents gives the set of
+ * blocks for a given stream.
+ * Some internal streams are accessed through numbers. For example,
+ * #1 is the ROOT (basic information on the file)
+ * #2 is the Symbol information (global symbols, local variables...)
+ * #3 is the Type internal stream (each the symbols can have type
  * information associated with it).
  *
  * Over the years, three formats existed for the PDB:
- * - ?? was rather linked to 16 bit code (our support shall be rather
- *   bad)
- * - JG: it's the signature embedded in the file header. This format
- *   has been used in MSVC 2.0 => 5.0.
- * - DS: it's the signature embedded in the file header. It's the
- *   current format supported my MS.
+ * - ?? was rather linked to 16 bit code (our support shall be rather bad)
+ * - JG: it's the signature embedded in the file header. This format has been
+ *   used in MSVC 2.0 => 5.0.
+ * - DS: it's the signature embedded in the file header. It's the current format
+ *   supported my MS.
  *
- * Types internal stream
+ * Types internal stream (aka TPI)
  * ---------------------
- * Types (from the Type internal file) have existed in three flavors
- * (note that those flavors came as historical evolution, but there
- * isn't a one to one link between types evolution and PDB formats'
- * evolutions:
- * - the first flavor (suffixed by V1 in this file), where the types
+ * Types (from the Type internal stream) have existed in three flavors (note
+ * that those flavors came as historical evolution, but there isn't a one to one
+ * link between types evolution and PDB formats' evolutions:
+ * - the first flavor (suffixed by V1 in mscvpdb.h), where the types
  *   and subtypes are 16 bit entities; and where strings are in Pascal
  *   format (first char is their length and are not 0 terminated)
  * - the second flavor (suffixed by V2) differs from first flavor with
@@ -2376,7 +2375,7 @@ struct startend
  * ======================================== */
 
 
-struct PDB_FILE
+struct PDB_JG_STREAM
 {
     unsigned int        size;
     unsigned int        unknown;
@@ -2387,9 +2386,9 @@ struct PDB_JG_HEADER
     char                ident[40];
     unsigned int        signature;
     unsigned int        block_size;
-    unsigned short      free_list;
+    unsigned short      free_list_block;
     unsigned short      total_alloc;
-    struct PDB_FILE     toc;
+    struct PDB_JG_STREAM toc;
     unsigned short      toc_block[1];
 };
 
@@ -2397,23 +2396,23 @@ struct PDB_DS_HEADER
 {
     char                signature[32];
     unsigned int        block_size;
-    unsigned int        unknown1;
-    unsigned int        num_pages;
+    unsigned int        free_list_block;
+    unsigned int        num_blocks;
     unsigned int        toc_size;
     unsigned int        unknown2;
-    unsigned int        toc_page;
+    unsigned int        toc_block;
 };
 
 struct PDB_JG_TOC
 {
-    unsigned int        num_files;
-    struct PDB_FILE     file[1];
+    unsigned int        num_streams;
+    struct PDB_JG_STREAM streams[1];
 };
 
 struct PDB_DS_TOC
 {
-    unsigned int        num_files;
-    unsigned int        file_size[1];
+    unsigned int        num_streams;
+    unsigned int        stream_size[1];
 };
 
 struct PDB_JG_ROOT
@@ -2441,7 +2440,7 @@ typedef struct _PDB_TYPES_OLD
     unsigned short first_index;
     unsigned short last_index;
     unsigned int   type_size;
-    unsigned short hash_file;
+    unsigned short hash_stream;
     unsigned short pad;
 } PDB_TYPES_OLD, *PPDB_TYPES_OLD;
 
@@ -2452,16 +2451,16 @@ typedef struct _PDB_TYPES
     unsigned int   first_index;
     unsigned int   last_index;
     unsigned int   type_size;
-    unsigned short hash_file;
+    unsigned short hash_stream;
     unsigned short pad;
-    unsigned int   hash_size;
+    unsigned int   hash_value_size;
     unsigned int   hash_num_buckets;
     unsigned int   hash_offset;
-    unsigned int   hash_len;
+    unsigned int   hash_size;
     unsigned int   search_offset;
-    unsigned int   search_len;
+    unsigned int   search_size;
     unsigned int   type_remap_offset;
-    unsigned int   type_remap_len;
+    unsigned int   type_remap_size;
 } PDB_TYPES, *PPDB_TYPES;
 
 typedef struct _PDB_SYMBOL_RANGE
@@ -2493,7 +2492,7 @@ typedef struct _PDB_SYMBOL_FILE
     unsigned int     unknown1;
     PDB_SYMBOL_RANGE range;
     unsigned short   flag;
-    unsigned short   file;
+    unsigned short   stream;
     unsigned int     symbol_size;
     unsigned int     lineno_size;
     unsigned int     lineno2_size;
@@ -2507,7 +2506,7 @@ typedef struct _PDB_SYMBOL_FILE_EX
     unsigned int        unknown1;
     PDB_SYMBOL_RANGE_EX range;
     unsigned short      flag;
-    unsigned short      file;
+    unsigned short      stream;
     unsigned int        symbol_size;
     unsigned int        lineno_size;
     unsigned int        lineno2_size;
@@ -2535,13 +2534,13 @@ typedef struct _PDB_SYMBOL_IMPORT
 
 typedef struct _PDB_SYMBOLS_OLD
 {
-    unsigned short global_hash_file;
-    unsigned short public_file;
-    unsigned short gsym_file;
+    unsigned short global_hash_stream;
+    unsigned short public_stream;
+    unsigned short gsym_stream;
     unsigned short pad;
     unsigned int   module_size;
-    unsigned int   offset_size;
-    unsigned int   hash_size;
+    unsigned int   sectcontrib_size;
+    unsigned int   segmap_size;
     unsigned int   srcmodule_size;
 } PDB_SYMBOLS_OLD, *PPDB_SYMBOLS_OLD;
 
@@ -2550,15 +2549,15 @@ typedef struct _PDB_SYMBOLS
     unsigned int   signature;
     unsigned int   version;
     unsigned int   age;
-    unsigned short global_hash_file;
+    unsigned short global_hash_stream;
     unsigned short flags;
-    unsigned short public_file;
+    unsigned short public_stream;
     unsigned short bldVer;
-    unsigned short gsym_file;
+    unsigned short gsym_stream;
     unsigned short rbldVer;
     unsigned int   module_size;
-    unsigned int   offset_size;
-    unsigned int   hash_size;
+    unsigned int   sectcontrib_size;
+    unsigned int   segmap_size;
     unsigned int   srcmodule_size;
     unsigned int   pdbimport_size;
     unsigned int   resvd0;
@@ -2576,7 +2575,7 @@ typedef struct
     unsigned short unk1;
     unsigned short unk2;
     unsigned short unk3;
-    unsigned short segments;
+    unsigned short sections_stream;
 } PDB_STREAM_INDEXES_OLD;
 
 typedef struct
@@ -2586,7 +2585,7 @@ typedef struct
     unsigned short unk1;
     unsigned short unk2;
     unsigned short unk3;
-    unsigned short segments;
+    unsigned short sections_stream;
     unsigned short unk4;
     unsigned short unk5;
     unsigned short unk6;
@@ -2631,11 +2630,11 @@ typedef struct
 {
     unsigned signature;
     unsigned version;
-    unsigned size_hash_records;
+    unsigned hash_records_size;
     unsigned unknown;
 } DBI_HASH_HEADER;
 /* This header is followed by:
- * - DBI_HASH_RECORDS (on hdr:size_hash_records bytes)
+ * - DBI_HASH_RECORDS (on hdr:hash_records_size bytes)
  * - a bitmap of DBI_MAX_HASH + 1 entries (on DBI_BITMAP_HASH_SIZE bytes)
  * - a table (one entry per present bit in bitmap) as index into hdr:num_records
  */
@@ -2657,11 +2656,11 @@ typedef struct
     unsigned hash_size;
     unsigned address_map_size;
     unsigned num_thunks;
-    unsigned size_thunk;
+    unsigned thunk_size;
     unsigned short section_thunk_table;
     unsigned short _pad0;
     unsigned offset_thunk_table;
-    unsigned num_sects;
+    unsigned num_sections;
 } DBI_PUBLIC_HEADER;
 
 #include "poppack.h"
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 472c0ea709d..c5e0182f42a 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -3073,10 +3073,10 @@ struct create_named_pipe_request
     unsigned int   access;
     unsigned int   options;
     unsigned int   sharing;
+    unsigned int   disposition;
     unsigned int   maxinstances;
     unsigned int   outsize;
     unsigned int   insize;
-    char __pad_36[4];
     timeout_t      timeout;
     unsigned int   flags;
     /* VARARG(objattr,object_attributes); */
@@ -3086,7 +3086,7 @@ struct create_named_pipe_reply
 {
     struct reply_header __header;
     obj_handle_t   handle;
-    char __pad_12[4];
+    int            created;
 };
 
 
@@ -6356,7 +6356,7 @@ union generic_reply
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 758
+#define SERVER_PROTOCOL_VERSION 760
 
 /* ### protocol_version end ### */
 
diff --git a/include/wine/vulkan.h b/include/wine/vulkan.h
index 77c5cc02ae7..b7c94c5463c 100644
--- a/include/wine/vulkan.h
+++ b/include/wine/vulkan.h
@@ -150,10 +150,14 @@
 #define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
+#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
 #define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
+#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
 #define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
 #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
 #define VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION 2
@@ -186,6 +190,8 @@
 #define VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME "VK_EXT_depth_clip_enable"
 #define VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION 4
 #define VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME "VK_EXT_swapchain_colorspace"
+#define VK_EXT_HDR_METADATA_SPEC_VERSION 2
+#define VK_EXT_HDR_METADATA_EXTENSION_NAME "VK_EXT_hdr_metadata"
 #define VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION 1
 #define VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME "VK_KHR_imageless_framebuffer"
 #define VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION 1
@@ -194,6 +200,8 @@
 #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
 #define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
+#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
 #define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
 #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
 #define VK_KHR_MAINTENANCE2_SPEC_VERSION VK_KHR_MAINTENANCE_2_SPEC_VERSION
@@ -204,6 +212,8 @@
 #define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"
 #define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
 #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
+#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
+#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
 #define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
@@ -248,6 +258,8 @@
 #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
 #define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
 #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
+#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 2
+#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
 #define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
 #define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
 #define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
@@ -524,6 +536,8 @@
 #define VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME "VK_EXT_opacity_micromap"
 #define VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION 1
 #define VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME "VK_EXT_load_store_op_none"
+#define VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION 1
+#define VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME "VK_HUAWEI_cluster_culling_shader"
 #define VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION 1
 #define VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME "VK_EXT_border_color_swizzle"
 #define VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION 1
@@ -572,6 +586,8 @@
 #define VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME "VK_EXT_mutable_descriptor_type"
 #define VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION 2
 #define VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME "VK_ARM_shader_core_builtins"
+#define VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION 1
+#define VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME "VK_EXT_pipeline_library_group_handles"
 #define VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION 13
 #define VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME "VK_KHR_acceleration_structure"
 #define VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION 1
@@ -596,7 +612,7 @@
 #define VK_API_VERSION_1_1 VK_MAKE_API_VERSION(0, 1, 1, 0)
 #define VK_API_VERSION_1_2 VK_MAKE_API_VERSION(0, 1, 2, 0)
 #define VK_API_VERSION_1_3 VK_MAKE_API_VERSION(0, 1, 3, 0)
-#define VK_HEADER_VERSION 237
+#define VK_HEADER_VERSION 240
 #define VK_HEADER_VERSION_COMPLETE VK_MAKE_API_VERSION(0, 1, 3, VK_HEADER_VERSION)
 #define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;
 #define VK_USE_64_BIT_PTR_DEFINES 0
@@ -869,7 +885,7 @@ typedef VkFlags VkVideoCodingControlFlagsKHR;
 typedef VkFlags VkVideoComponentBitDepthFlagsKHR;
 typedef VkFlags VkVideoDecodeCapabilityFlagsKHR;
 typedef VkFlags VkVideoDecodeFlagsKHR;
-typedef VkFlags VkVideoDecodeH264PictureLayoutFlagsEXT;
+typedef VkFlags VkVideoDecodeH264PictureLayoutFlagsKHR;
 typedef VkFlags VkVideoDecodeUsageFlagsKHR;
 typedef VkFlags VkVideoEncodeCapabilityFlagsKHR;
 typedef VkFlags VkVideoEncodeContentFlagsKHR;
@@ -1701,6 +1717,7 @@ typedef enum VkDriverId
     VK_DRIVER_ID_MESA_VENUS = 22,
     VK_DRIVER_ID_MESA_DOZEN = 23,
     VK_DRIVER_ID_MESA_NVK = 24,
+    VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
     VK_DRIVER_ID_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY,
     VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE,
     VK_DRIVER_ID_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV,
@@ -1859,6 +1876,7 @@ typedef enum VkExternalMemoryHandleTypeFlagBits
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
@@ -2444,6 +2462,10 @@ typedef enum VkImageAspectFlagBits
     VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
     VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
     VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
     VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
     VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
     VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
@@ -2559,6 +2581,7 @@ typedef enum VkImageTiling
 {
     VK_IMAGE_TILING_OPTIMAL = 0,
     VK_IMAGE_TILING_LINEAR = 1,
+    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
     VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
 } VkImageTiling;
 
@@ -3226,6 +3249,7 @@ static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHAD
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 0x4000000000ull;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 0x8000000000ull;
 static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 0x10000000000ull;
+static const VkPipelineStageFlagBits2 VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = 0x20000000000ull;
 typedef VkPipelineStageFlagBits2 VkPipelineStageFlagBits2KHR;
 
 typedef enum VkPointClippingBehavior
@@ -3316,6 +3340,7 @@ typedef enum VkQueryPipelineStatisticFlagBits
     VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
     VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x00000800,
     VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x00001000,
+    VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x00002000,
     VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7fffffff,
 } VkQueryPipelineStatisticFlagBits;
 
@@ -3446,6 +3471,7 @@ typedef enum VkResult
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
     VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
     VK_ERROR_FRAGMENTATION = -1000161000,
+    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
     VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
     VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
     VK_ERROR_INVALID_SHADER_NV = -1000012000,
@@ -3654,6 +3680,7 @@ typedef enum VkShaderStageFlagBits
     VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x00001000,
     VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x00002000,
     VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x00004000,
+    VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x00080000,
     VK_SHADER_STAGE_RAYGEN_BIT_NV = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
     VK_SHADER_STAGE_ANY_HIT_BIT_NV = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
     VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
@@ -3859,9 +3886,14 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
     VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
     VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
+    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
+    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
+    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
     VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
     VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
+    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
+    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
@@ -3879,6 +3911,7 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
     VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
+    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
     VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
     VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
@@ -3893,6 +3926,8 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
     VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
     VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
+    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
+    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
@@ -3969,6 +4004,12 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
     VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
     VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
+    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
+    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
     VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
     VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
@@ -4256,6 +4297,8 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
     VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
     VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
     VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
@@ -4306,6 +4349,7 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
     VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
@@ -5842,6 +5886,36 @@ typedef struct VkDrawMeshTasksIndirectCommandNV
     uint32_t firstTask;
 } VkDrawMeshTasksIndirectCommandNV;
 
+typedef struct VkDrmFormatModifierProperties2EXT
+{
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags2 WINE_VK_ALIGN(8) drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierProperties2EXT;
+
+typedef struct VkDrmFormatModifierPropertiesEXT
+{
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierPropertiesEXT;
+
+typedef struct VkDrmFormatModifierPropertiesList2EXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t drmFormatModifierCount;
+    VkDrmFormatModifierProperties2EXT *pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesList2EXT;
+
+typedef struct VkDrmFormatModifierPropertiesListEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t drmFormatModifierCount;
+    VkDrmFormatModifierPropertiesEXT *pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesListEXT;
+
 typedef struct VkEventCreateInfo
 {
     VkStructureType sType;
@@ -5952,6 +6026,14 @@ typedef struct VkFenceCreateInfo
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo;
 
+typedef struct VkFenceGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence WINE_VK_ALIGN(8) fence;
+    VkExternalFenceHandleTypeFlagBits handleType;
+} VkFenceGetFdInfoKHR;
+
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
 {
     VkStructureType sType;
@@ -6126,6 +6208,21 @@ typedef struct VkImageCreateInfo
     VkImageLayout initialLayout;
 } VkImageCreateInfo;
 
+typedef struct VkImageDrmFormatModifierListCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t drmFormatModifierCount;
+    const uint64_t *pDrmFormatModifiers;
+} VkImageDrmFormatModifierListCreateInfoEXT;
+
+typedef struct VkImageDrmFormatModifierPropertiesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+} VkImageDrmFormatModifierPropertiesEXT;
+
 typedef struct VkImageFormatListCreateInfo
 {
     VkStructureType sType;
@@ -6280,6 +6377,24 @@ typedef struct VkImageViewUsageCreateInfo
 } VkImageViewUsageCreateInfo;
 typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;
 
+typedef struct VkImportFenceFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence WINE_VK_ALIGN(8) fence;
+    VkFenceImportFlags flags;
+    VkExternalFenceHandleTypeFlagBits handleType;
+    int fd;
+} VkImportFenceFdInfoKHR;
+
+typedef struct VkImportMemoryFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+} VkImportMemoryFdInfoKHR;
+
 typedef struct VkImportMemoryHostPointerInfoEXT
 {
     VkStructureType sType;
@@ -6297,6 +6412,16 @@ typedef struct VkImportMemoryWin32HandleInfoKHR
     LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR;
 
+typedef struct VkImportSemaphoreFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore WINE_VK_ALIGN(8) semaphore;
+    VkSemaphoreImportFlags flags;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+    int fd;
+} VkImportSemaphoreFdInfoKHR;
+
 typedef struct VkIndirectCommandsLayoutTokenNV
 {
     VkStructureType sType;
@@ -6420,6 +6545,21 @@ typedef struct VkMemoryDedicatedRequirements
 } VkMemoryDedicatedRequirements;
 typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;
 
+typedef struct VkMemoryFdPropertiesKHR
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t memoryTypeBits;
+} VkMemoryFdPropertiesKHR;
+
+typedef struct VkMemoryGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkDeviceMemory WINE_VK_ALIGN(8) memory;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+} VkMemoryGetFdInfoKHR;
+
 typedef struct VkMemoryGetWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -6832,6 +6972,23 @@ typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
 } VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
 typedef VkPhysicalDeviceBufferDeviceAddressFeaturesEXT VkPhysicalDeviceBufferAddressFeaturesEXT;
 
+typedef struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
+{
+    VkStructureType sType;
+    void *pNext;
+    VkBool32 clustercullingShader;
+    VkBool32 multiviewClusterCullingShader;
+} VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
+
+typedef struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t maxWorkGroupCount[3];
+    uint32_t maxWorkGroupSize[3];
+    uint32_t maxOutputClusterCount;
+} VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI;
+
 typedef struct VkPhysicalDeviceCoherentMemoryFeaturesAMD
 {
     VkStructureType sType;
@@ -7560,6 +7717,16 @@ typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
     VkBool32 imageCompressionControlSwapchain;
 } VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
 
+typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    VkSharingMode sharingMode;
+    uint32_t queueFamilyIndexCount;
+    const uint32_t *pQueueFamilyIndices;
+} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
+
 typedef struct VkPhysicalDeviceImageFormatInfo2
 {
     VkStructureType sType;
@@ -8099,6 +8266,13 @@ typedef struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
     VkBool32 pipelineExecutableInfo;
 } VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
 
+typedef struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    VkBool32 pipelineLibraryGroupHandles;
+} VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;
+
 typedef struct VkPhysicalDevicePipelinePropertiesFeaturesEXT
 {
     VkStructureType sType;
@@ -9907,6 +10081,14 @@ typedef struct VkSemaphoreCreateInfo
     VkSemaphoreCreateFlags flags;
 } VkSemaphoreCreateInfo;
 
+typedef struct VkSemaphoreGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore WINE_VK_ALIGN(8) semaphore;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+} VkSemaphoreGetFdInfoKHR;
+
 typedef struct VkSemaphoreSignalInfo
 {
     VkStructureType sType;
@@ -10553,6 +10735,12 @@ typedef struct VkWriteDescriptorSetInlineUniformBlock
 } VkWriteDescriptorSetInlineUniformBlock;
 typedef VkWriteDescriptorSetInlineUniformBlock VkWriteDescriptorSetInlineUniformBlockEXT;
 
+typedef struct VkXYColorEXT
+{
+    float x;
+    float y;
+} VkXYColorEXT;
+
 typedef struct VkAccelerationStructureGeometryAabbsDataKHR
 {
     VkStructureType sType;
@@ -10941,6 +11129,20 @@ typedef struct VkGeometryNV
     VkGeometryFlagsKHR flags;
 } VkGeometryNV;
 
+typedef struct VkHdrMetadataEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkXYColorEXT displayPrimaryRed;
+    VkXYColorEXT displayPrimaryGreen;
+    VkXYColorEXT displayPrimaryBlue;
+    VkXYColorEXT whitePoint;
+    float maxLuminance;
+    float minLuminance;
+    float maxContentLightLevel;
+    float maxFrameAverageLightLevel;
+} VkHdrMetadataEXT;
+
 typedef struct VkImageBlit
 {
     VkImageSubresourceLayers srcSubresource;
@@ -10981,6 +11183,15 @@ typedef struct VkImageCopy2
 } VkImageCopy2;
 typedef VkImageCopy2 VkImageCopy2KHR;
 
+typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    const VkSubresourceLayout *pPlaneLayouts;
+} VkImageDrmFormatModifierExplicitCreateInfoEXT;
+
 typedef struct VkImageMemoryBarrier
 {
     VkStructureType sType;
@@ -11648,6 +11859,8 @@ typedef void (VKAPI_PTR *PFN_vkCmdDispatchBase)(VkCommandBuffer, uint32_t, uint3
 typedef void (VKAPI_PTR *PFN_vkCmdDispatchBaseKHR)(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);
 typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer, VkBuffer, VkDeviceSize);
 typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t);
+typedef void (VKAPI_PTR *PFN_vkCmdDrawClusterHUAWEI)(VkCommandBuffer, uint32_t, uint32_t, uint32_t);
+typedef void (VKAPI_PTR *PFN_vkCmdDrawClusterIndirectHUAWEI)(VkCommandBuffer, VkBuffer, VkDeviceSize);
 typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer, uint32_t, uint32_t, uint32_t, int32_t, uint32_t);
 typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer, VkBuffer, VkDeviceSize, uint32_t, uint32_t);
 typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCount)(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t);
@@ -11962,9 +12175,11 @@ typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue2)(VkDevice, const VkDeviceQueueInf
 typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)(VkDevice, VkRenderPass, VkExtent2D *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice, const VkRenderingInfo *, VkTilePropertiesQCOM *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice, VkEvent);
+typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice, VkFence);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV *, VkMemoryRequirements2 *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice, VkImage, VkMemoryRequirements *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
@@ -11978,6 +12193,8 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewAddressNVX)(VkDevice, VkImageView
 typedef uint32_t (VKAPI_PTR *PFN_vkGetImageViewHandleNVX)(VkDevice, const VkImageViewHandleInfoNVX *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)(VkDevice, const VkImageViewCaptureDescriptorDataInfoEXT *, void *);
 typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance, const char *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice, const VkMemoryGetFdInfoKHR *, int *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, int, VkMemoryFdPropertiesKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryHostPointerPropertiesEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice, const VkMemoryGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, VkMemoryWin32HandlePropertiesKHR *);
@@ -12045,11 +12262,14 @@ typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice, VkRenderPass,
 typedef VkResult (VKAPI_PTR *PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)(VkDevice, const VkSamplerCaptureDescriptorDataInfoEXT *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice, VkSemaphore, uint64_t *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice, VkSemaphore, uint64_t *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice, const VkSemaphoreGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, size_t *, void *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice, const VkShaderModuleCreateInfo *, VkShaderModuleIdentifierEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleIdentifierEXT)(VkDevice, VkShaderModule, VkShaderModuleIdentifierEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
+typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR *);
+typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
 typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice, uint32_t, const VkMappedMemoryRange *);
 typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, void **);
@@ -12079,6 +12299,7 @@ typedef VkResult (VKAPI_PTR *PFN_vkSetDebugUtilsObjectNameEXT)(VkDevice, const V
 typedef VkResult (VKAPI_PTR *PFN_vkSetDebugUtilsObjectTagEXT)(VkDevice, const VkDebugUtilsObjectTagInfoEXT *);
 typedef void (VKAPI_PTR *PFN_vkSetDeviceMemoryPriorityEXT)(VkDevice, VkDeviceMemory, float);
 typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice, VkEvent);
+typedef void (VKAPI_PTR *PFN_vkSetHdrMetadataEXT)(VkDevice, uint32_t, const VkSwapchainKHR *, const VkHdrMetadataEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkSetPrivateData)(VkDevice, VkObjectType, uint64_t, VkPrivateDataSlot, uint64_t);
 typedef VkResult (VKAPI_PTR *PFN_vkSetPrivateDataEXT)(VkDevice, VkObjectType, uint64_t, VkPrivateDataSlot, uint64_t);
 typedef VkResult (VKAPI_PTR *PFN_vkSignalSemaphore)(VkDevice, const VkSemaphoreSignalInfo *);
@@ -12182,6 +12403,8 @@ void VKAPI_CALL vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGr
 void VKAPI_CALL vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
 void VKAPI_CALL vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
 void VKAPI_CALL vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
+void VKAPI_CALL vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
+void VKAPI_CALL vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
 void VKAPI_CALL vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
 void VKAPI_CALL vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
 void VKAPI_CALL vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
@@ -12496,9 +12719,11 @@ void VKAPI_CALL vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQu
 VkResult VKAPI_CALL vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize);
 VkResult VKAPI_CALL vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties);
 VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event);
+VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence);
 VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties);
 void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
@@ -12512,6 +12737,8 @@ VkResult VKAPI_CALL vkGetImageViewAddressNVX(VkDevice device, VkImageView imageV
 uint32_t VKAPI_CALL vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo);
 VkResult VKAPI_CALL vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(VkInstance instance, const char *pName);
+VkResult VKAPI_CALL vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd);
+VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties);
 VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties);
 VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties);
@@ -12579,11 +12806,14 @@ void VKAPI_CALL vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderP
 VkResult VKAPI_CALL vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
+VkResult VKAPI_CALL vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo);
 void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier);
 void VKAPI_CALL vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier);
 VkResult VKAPI_CALL vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages);
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
+VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo);
+VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo);
 VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo);
 VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges);
 VkResult VKAPI_CALL vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData);
@@ -12613,6 +12843,7 @@ VkResult VKAPI_CALL vkSetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugU
 VkResult VKAPI_CALL vkSetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo);
 void VKAPI_CALL vkSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority);
 VkResult VKAPI_CALL vkSetEvent(VkDevice device, VkEvent event);
+void VKAPI_CALL vkSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata);
 VkResult VKAPI_CALL vkSetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data);
 VkResult VKAPI_CALL vkSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data);
 VkResult VKAPI_CALL vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo);
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index f5269d554fb..99d301061aa 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,9 +21,12 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
+    VkResult (*p_vkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
+    void (*p_vkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
     void (*p_vkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
     void (*p_vkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
     void (*p_vkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
@@ -55,8 +58,12 @@ static inline void *get_vulkan_driver_device_proc_addr(
 
     name += 2;
 
+    if (!strcmp(name, "AcquireNextImageKHR"))
+        return vulkan_funcs->p_vkAcquireNextImageKHR;
     if (!strcmp(name, "CreateSwapchainKHR"))
         return vulkan_funcs->p_vkCreateSwapchainKHR;
+    if (!strcmp(name, "DestroyDevice"))
+        return vulkan_funcs->p_vkDestroyDevice;
     if (!strcmp(name, "DestroySwapchainKHR"))
         return vulkan_funcs->p_vkDestroySwapchainKHR;
     if (!strcmp(name, "GetDeviceGroupSurfacePresentModesKHR"))
@@ -85,6 +92,8 @@ static inline void *get_vulkan_driver_instance_proc_addr(
 
     if (!instance) return NULL;
 
+    if (!strcmp(name, "CreateDevice"))
+        return vulkan_funcs->p_vkCreateDevice;
     if (!strcmp(name, "CreateWin32SurfaceKHR"))
         return vulkan_funcs->p_vkCreateWin32SurfaceKHR;
     if (!strcmp(name, "DestroyInstance"))
diff --git a/include/wine/winbase16.h b/include/wine/winbase16.h
index 1d052130e33..28cde59f9b3 100644
--- a/include/wine/winbase16.h
+++ b/include/wine/winbase16.h
@@ -402,8 +402,8 @@ WORD        WINAPI LocalHeapSize16(void);
 BOOL16      WINAPI LocalInit16(HANDLE16,WORD,WORD);
 FARPROC16   WINAPI LocalNotify16(FARPROC16);
 HTASK16     WINAPI LockCurrentTask16(BOOL16);
-DWORD       WINAPI MapLS(LPCVOID);
-LPVOID      WINAPI MapSL(DWORD);
+SEGPTR      WINAPI MapLS(void*);
+LPVOID      WINAPI MapSL(SEGPTR);
 VOID        WINAPI OldYield16(void);
 VOID        WINAPI WIN32_OldYield16(void);
 VOID        WINAPI PostEvent16(HTASK16);
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index f4ec2470bba..5d8a1156b21 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -2857,6 +2857,7 @@ struct wined3d_resource * __cdecl wined3d_texture_get_resource(struct wined3d_te
 HRESULT __cdecl wined3d_texture_get_sub_resource_desc(const struct wined3d_texture *texture,
         unsigned int sub_resource_idx, struct wined3d_sub_resource_desc *desc);
 void * __cdecl wined3d_texture_get_sub_resource_parent(struct wined3d_texture *texture, unsigned int sub_resource_idx);
+struct wined3d_swapchain * __cdecl wined3d_texture_get_swapchain(struct wined3d_texture *texture);
 ULONG __cdecl wined3d_texture_incref(struct wined3d_texture *texture);
 HRESULT __cdecl wined3d_texture_release_dc(struct wined3d_texture *texture, unsigned int sub_resource_idx, HDC dc);
 HRESULT __cdecl wined3d_texture_set_color_key(struct wined3d_texture *texture,
diff --git a/include/winerror.h b/include/winerror.h
index fb44eaacbed..ccb58199101 100644
--- a/include/winerror.h
+++ b/include/winerror.h
@@ -4023,6 +4023,10 @@ static inline HRESULT HRESULT_FROM_WIN32(unsigned int x)
 #define DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY               _HRESULT_TYPEDEF_(0x887a0030)
 #define DXGI_ERROR_MODE_CHANGE_IN_PROGRESS                 _HRESULT_TYPEDEF_(0x887a0025)
 
+#define DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED         _HRESULT_TYPEDEF_(0x88980800)
+#define DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED          _HRESULT_TYPEDEF_(0x88980801)
+#define DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED      _HRESULT_TYPEDEF_(0x88980802)
+
 #define ERROR_AUDITING_DISABLED                            _HRESULT_TYPEDEF_(0xC0090001)
 #define ERROR_ALL_SIDS_FILTERED                            _HRESULT_TYPEDEF_(0xC0090002)
 
diff --git a/include/winnt.h b/include/winnt.h
index f40136a2003..04c2e96d1e1 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -3603,50 +3603,116 @@ typedef struct _FPO_DATA {
   WORD  cbFrame  : 2;
 } FPO_DATA, *PFPO_DATA;
 
+typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY
+{
+  WORD    Flags;
+  WORD    Catalog;
+  DWORD   CatalogOffset;
+  DWORD   Reserved;
+} IMAGE_LOAD_CONFIG_CODE_INTEGRITY, *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY;
+
 typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
-  DWORD     Size;
+  DWORD     Size;                                 /* 000 */
   DWORD     TimeDateStamp;
   WORD      MajorVersion;
   WORD      MinorVersion;
   DWORD     GlobalFlagsClear;
-  DWORD     GlobalFlagsSet;
+  DWORD     GlobalFlagsSet;                       /* 010 */
   DWORD     CriticalSectionDefaultTimeout;
   ULONGLONG DeCommitFreeBlockThreshold;
-  ULONGLONG DeCommitTotalFreeThreshold;
+  ULONGLONG DeCommitTotalFreeThreshold;           /* 020 */
   ULONGLONG LockPrefixTable;
-  ULONGLONG MaximumAllocationSize;
+  ULONGLONG MaximumAllocationSize;                /* 030 */
   ULONGLONG VirtualMemoryThreshold;
-  ULONGLONG ProcessAffinityMask;
+  ULONGLONG ProcessAffinityMask;                  /* 040 */
   DWORD     ProcessHeapFlags;
   WORD      CSDVersion;
-  WORD      Reserved1;
-  ULONGLONG EditList;
+  WORD      DependentLoadFlags;
+  ULONGLONG EditList;                             /* 050 */
   ULONGLONG SecurityCookie;
-  ULONGLONG SEHandlerTable;
+  ULONGLONG SEHandlerTable;                       /* 060 */
   ULONGLONG SEHandlerCount;
+  ULONGLONG GuardCFCheckFunctionPointer;          /* 070 */
+  ULONGLONG GuardCFDispatchFunctionPointer;
+  ULONGLONG GuardCFFunctionTable;                 /* 080 */
+  ULONGLONG GuardCFFunctionCount;
+  DWORD     GuardFlags;                           /* 090 */
+  IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
+  ULONGLONG GuardAddressTakenIatEntryTable;       /* 0a0 */
+  ULONGLONG GuardAddressTakenIatEntryCount;
+  ULONGLONG GuardLongJumpTargetTable;             /* 0b0 */
+  ULONGLONG GuardLongJumpTargetCount;
+  ULONGLONG DynamicValueRelocTable;               /* 0c0 */
+  ULONGLONG CHPEMetadataPointer;
+  ULONGLONG GuardRFFailureRoutine;                /* 0d0 */
+  ULONGLONG GuardRFFailureRoutineFunctionPointer;
+  DWORD     DynamicValueRelocTableOffset;         /* 0e0 */
+  WORD      DynamicValueRelocTableSection;
+  WORD      Reserved2;
+  ULONGLONG GuardRFVerifyStackPointerFunctionPointer;
+  DWORD     HotPatchTableOffset;                  /* 0f0 */
+  DWORD     Reserved3;
+  ULONGLONG EnclaveConfigurationPointer;
+  ULONGLONG VolatileMetadataPointer;              /* 100 */
+  ULONGLONG GuardEHContinuationTable;
+  ULONGLONG GuardEHContinuationCount;             /* 110 */
+  ULONGLONG GuardXFGCheckFunctionPointer;
+  ULONGLONG GuardXFGDispatchFunctionPointer;      /* 120 */
+  ULONGLONG GuardXFGTableDispatchFunctionPointer;
+  ULONGLONG CastGuardOsDeterminedFailureMode;     /* 130 */
+  ULONGLONG GuardMemcpyFunctionPointer;
 } IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;
 
 typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
-  DWORD Size;
+  DWORD Size;                                     /* 000 */
   DWORD TimeDateStamp;
   WORD  MajorVersion;
   WORD  MinorVersion;
   DWORD GlobalFlagsClear;
-  DWORD GlobalFlagsSet;
+  DWORD GlobalFlagsSet;                           /* 010 */
   DWORD CriticalSectionDefaultTimeout;
   DWORD DeCommitFreeBlockThreshold;
   DWORD DeCommitTotalFreeThreshold;
-  PVOID LockPrefixTable;
+  DWORD LockPrefixTable;                          /* 020 */
   DWORD MaximumAllocationSize;
   DWORD VirtualMemoryThreshold;
   DWORD ProcessHeapFlags;
-  DWORD ProcessAffinityMask;
+  DWORD ProcessAffinityMask;                      /* 030 */
   WORD  CSDVersion;
-  WORD  Reserved1;
-  PVOID EditList;
+  WORD  DependentLoadFlags;
+  DWORD EditList;
   DWORD SecurityCookie;
-  DWORD SEHandlerTable;
+  DWORD SEHandlerTable;                           /* 040 */
   DWORD SEHandlerCount;
+  DWORD GuardCFCheckFunctionPointer;
+  DWORD GuardCFDispatchFunctionPointer;
+  DWORD GuardCFFunctionTable;                     /* 050 */
+  DWORD GuardCFFunctionCount;
+  DWORD GuardFlags;
+  IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
+  DWORD GuardAddressTakenIatEntryTable;
+  DWORD GuardAddressTakenIatEntryCount;
+  DWORD GuardLongJumpTargetTable;                 /* 070 */
+  DWORD GuardLongJumpTargetCount;
+  DWORD DynamicValueRelocTable;
+  DWORD CHPEMetadataPointer;
+  DWORD GuardRFFailureRoutine;                    /* 080 */
+  DWORD GuardRFFailureRoutineFunctionPointer;
+  DWORD DynamicValueRelocTableOffset;
+  WORD  DynamicValueRelocTableSection;
+  WORD  Reserved2;
+  DWORD GuardRFVerifyStackPointerFunctionPointer; /* 090 */
+  DWORD HotPatchTableOffset;
+  DWORD Reserved3;
+  DWORD EnclaveConfigurationPointer;
+  DWORD VolatileMetadataPointer;                  /* 0a0 */
+  DWORD GuardEHContinuationTable;
+  DWORD GuardEHContinuationCount;
+  DWORD GuardXFGCheckFunctionPointer;
+  DWORD GuardXFGDispatchFunctionPointer;          /* 0b0 */
+  DWORD GuardXFGTableDispatchFunctionPointer;
+  DWORD CastGuardOsDeterminedFailureMode;
+  DWORD GuardMemcpyFunctionPointer;
 } IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;
 
 #ifdef _WIN64
@@ -3657,6 +3723,65 @@ typedef IMAGE_LOAD_CONFIG_DIRECTORY32   IMAGE_LOAD_CONFIG_DIRECTORY;
 typedef PIMAGE_LOAD_CONFIG_DIRECTORY32  PIMAGE_LOAD_CONFIG_DIRECTORY;
 #endif
 
+typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE
+{
+    DWORD     Version;
+    DWORD     Size;
+} IMAGE_DYNAMIC_RELOCATION_TABLE, *PIMAGE_DYNAMIC_RELOCATION_TABLE;
+
+#include <pshpack1.h>
+
+typedef struct _IMAGE_DYNAMIC_RELOCATION32
+{
+    DWORD     Symbol;
+    DWORD     BaseRelocSize;
+} IMAGE_DYNAMIC_RELOCATION32, *PIMAGE_DYNAMIC_RELOCATION32;
+
+typedef struct _IMAGE_DYNAMIC_RELOCATION64
+{
+    ULONGLONG Symbol;
+    DWORD     BaseRelocSize;
+} IMAGE_DYNAMIC_RELOCATION64, *PIMAGE_DYNAMIC_RELOCATION64;
+
+typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2
+{
+    DWORD     HeaderSize;
+    DWORD     FixupInfoSize;
+    DWORD     Symbol;
+    DWORD     SymbolGroup;
+    DWORD     Flags;
+} IMAGE_DYNAMIC_RELOCATION32_V2, *PIMAGE_DYNAMIC_RELOCATION32_V2;
+
+typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2
+{
+    DWORD     HeaderSize;
+    DWORD     FixupInfoSize;
+    ULONGLONG Symbol;
+    DWORD     SymbolGroup;
+    DWORD     Flags;
+} IMAGE_DYNAMIC_RELOCATION64_V2, *PIMAGE_DYNAMIC_RELOCATION64_V2;
+
+#include <poppack.h>
+
+#ifdef _WIN64
+typedef IMAGE_DYNAMIC_RELOCATION64     IMAGE_DYNAMIC_RELOCATION;
+typedef PIMAGE_DYNAMIC_RELOCATION64    PIMAGE_DYNAMIC_RELOCATION;
+typedef IMAGE_DYNAMIC_RELOCATION64_V2  IMAGE_DYNAMIC_RELOCATION_V2;
+typedef PIMAGE_DYNAMIC_RELOCATION64_V2 PIMAGE_DYNAMIC_RELOCATION_V2;
+#else
+typedef IMAGE_DYNAMIC_RELOCATION32     IMAGE_DYNAMIC_RELOCATION;
+typedef PIMAGE_DYNAMIC_RELOCATION32    PIMAGE_DYNAMIC_RELOCATION;
+typedef IMAGE_DYNAMIC_RELOCATION32_V2  IMAGE_DYNAMIC_RELOCATION_V2;
+typedef PIMAGE_DYNAMIC_RELOCATION32_V2 PIMAGE_DYNAMIC_RELOCATION_V2;
+#endif
+
+#define IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE             1
+#define IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE             2
+#define IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER 3
+#define IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER  4
+#define IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH      5
+#define IMAGE_DYNAMIC_RELOCATION_ARM64X                        6
+
 typedef struct _IMAGE_FUNCTION_ENTRY {
   DWORD StartingAddress;
   DWORD EndingAddress;
diff --git a/include/winscard.h b/include/winscard.h
index 5aee1b3e548..0ce473b6bf1 100644
--- a/include/winscard.h
+++ b/include/winscard.h
@@ -85,6 +85,15 @@ DECL_WINELIB_TYPE_AW(LPSCARD_READERSTATE)
 #define SCARD_STATE_MUTE        0x00000200
 #define SCARD_STATE_UNPOWERED   0x00000400
 
+#define SCARD_SHARE_EXCLUSIVE 1
+#define SCARD_SHARE_SHARED    2
+#define SCARD_SHARE_DIRECT    3
+
+#define SCARD_LEAVE_CARD   0
+#define SCARD_RESET_CARD   1
+#define SCARD_UNPOWER_CARD 2
+#define SCARD_EJECT_CARD   3
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/include/winsmcrd.h b/include/winsmcrd.h
index 60fdd3e492c..15c427c48da 100644
--- a/include/winsmcrd.h
+++ b/include/winsmcrd.h
@@ -27,6 +27,32 @@
 #define SCARD_PROTOCOL_DEFAULT          0x80000000
 #define SCARD_PROTOCOL_Tx               (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)
 
+#define SCARD_UNKNOWN    0
+#define SCARD_ABSENT     1
+#define SCARD_PRESENT    2
+#define SCARD_SWALLOWED  3
+#define SCARD_POWERED    4
+#define SCARD_NEGOTIABLE 5
+#define SCARD_SPECIFIC   6
+
+#define SCARD_ATTR_VALUE(class, tag) ((((ULONG)(class)) << 16) | ((ULONG)(tag)))
+
+#define SCARD_CLASS_VENDOR_INFO    1
+#define SCARD_CLASS_COMMUNICATIONS 2
+#define SCARD_CLASS_PROTOCOL       3
+#define SCARD_CLASS_POWER_MGMT     4
+#define SCARD_CLASS_SECURITY       5
+#define SCARD_CLASS_MECHANICAL     6
+#define SCARD_CLASS_VENDOR_DEFINED 7
+#define SCARD_CLASS_IFD_PROTOCOL   8
+#define SCARD_CLASS_ICC_STATE      9
+#define SCARD_CLASS_PERF           0x7ffe
+#define SCARD_CLASS_SYSTEM         0x7fff
+
+#define SCARD_ATTR_VENDOR_NAME SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_INFO, 0x0100)
+
+#define SCARD_CTL_CODE(code) CTL_CODE(FILE_DEVICE_SMARTCARD, (code), METHOD_BUFFERED, FILE_ANY_ACCESS)
+
 typedef struct _SCARD_IO_REQUEST
 {
     DWORD dwProtocol;
diff --git a/include/winternl.h b/include/winternl.h
index c720d962933..3a6c89a5f7a 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -1574,6 +1574,7 @@ typedef enum _PROCESSINFOCLASS {
     ProcessConsoleHostProcess = 49,
     ProcessWindowInformation = 50,
     ProcessHandleInformation = 51,
+    ProcessHandleTable = 58,
     ProcessPowerThrottlingState = 77,
     ProcessLeapSecondInformation = 97,
     MaxProcessInfoClass,
@@ -2271,6 +2272,11 @@ typedef struct _PROCESS_PRIORITY_CLASS {
     UCHAR       PriorityClass;
 } PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;
 
+typedef struct _PROCESS_CYCLE_TIME_INFORMATION {
+    ULONGLONG   AccumulatedCycles;
+    ULONGLONG   CurrentCycleCount;
+} PROCESS_CYCLE_TIME_INFORMATION, *PPROCESS_CYCLE_TIME_INFORMATION;
+
 typedef struct _PROCESS_STACK_ALLOCATION_INFORMATION
 {
     SIZE_T ReserveSize;
@@ -3983,6 +3989,7 @@ NTSYSAPI NTSTATUS  WINAPI NtCancelTimer(HANDLE, BOOLEAN*);
 NTSYSAPI NTSTATUS  WINAPI NtClearEvent(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtClose(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtCloseObjectAuditAlarm(PUNICODE_STRING,HANDLE,BOOLEAN);
+NTSYSAPI NTSTATUS  WINAPI NtCommitTransaction(HANDLE,BOOLEAN);
 NTSYSAPI NTSTATUS  WINAPI NtCompareObjects(HANDLE,HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtCompleteConnectPort(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtConnectPort(PHANDLE,PUNICODE_STRING,PSECURITY_QUALITY_OF_SERVICE,PLPC_SECTION_WRITE,PLPC_SECTION_READ,PULONG,PVOID,PULONG);
@@ -4012,6 +4019,7 @@ NTSYSAPI NTSTATUS  WINAPI NtCreateThread(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,
 NTSYSAPI NTSTATUS  WINAPI NtCreateThreadEx(HANDLE*,ACCESS_MASK,OBJECT_ATTRIBUTES*,HANDLE,PRTL_THREAD_START_ROUTINE,void*,ULONG,ULONG_PTR,SIZE_T,SIZE_T,PS_ATTRIBUTE_LIST*);
 NTSYSAPI NTSTATUS  WINAPI NtCreateTimer(HANDLE*, ACCESS_MASK, const OBJECT_ATTRIBUTES*, TIMER_TYPE);
 NTSYSAPI NTSTATUS  WINAPI NtCreateToken(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,TOKEN_TYPE,PLUID,PLARGE_INTEGER,PTOKEN_USER,PTOKEN_GROUPS,PTOKEN_PRIVILEGES,PTOKEN_OWNER,PTOKEN_PRIMARY_GROUP,PTOKEN_DEFAULT_DACL,PTOKEN_SOURCE);
+NTSYSAPI NTSTATUS  WINAPI NtCreateTransaction(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,LPGUID,HANDLE,ULONG,ULONG,ULONG,PLARGE_INTEGER,PUNICODE_STRING);
 NTSYSAPI NTSTATUS  WINAPI NtCreateUserProcess(HANDLE*,HANDLE*,ACCESS_MASK,ACCESS_MASK,OBJECT_ATTRIBUTES*,OBJECT_ATTRIBUTES*,ULONG,ULONG,RTL_USER_PROCESS_PARAMETERS*,PS_CREATE_INFO*,PS_ATTRIBUTE_LIST*);
 NTSYSAPI NTSTATUS  WINAPI NtDebugActiveProcess(HANDLE,HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtDebugContinue(HANDLE,CLIENT_ID*,NTSTATUS);
@@ -4159,6 +4167,7 @@ NTSYSAPI NTSTATUS  WINAPI NtResetWriteWatch(HANDLE,PVOID,SIZE_T);
 NTSYSAPI NTSTATUS  WINAPI NtRestoreKey(HANDLE,HANDLE,ULONG);
 NTSYSAPI NTSTATUS  WINAPI NtResumeProcess(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtResumeThread(HANDLE,PULONG);
+NTSYSAPI NTSTATUS  WINAPI NtRollbackTransaction(HANDLE,BOOLEAN);
 NTSYSAPI NTSTATUS  WINAPI NtSaveKey(HANDLE,HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtSecureConnectPort(PHANDLE,PUNICODE_STRING,PSECURITY_QUALITY_OF_SERVICE,PLPC_SECTION_WRITE,PSID,PLPC_SECTION_READ,PULONG,PVOID,PULONG);
 NTSYSAPI NTSTATUS  WINAPI NtSetContextThread(HANDLE,const CONTEXT*);
@@ -4251,6 +4260,7 @@ NTSYSAPI NTSTATUS  WINAPI RtlAddAuditAccessObjectAce(PACL,DWORD,DWORD,DWORD,GUID
 NTSYSAPI NTSTATUS  WINAPI RtlAddMandatoryAce(PACL,DWORD,DWORD,DWORD,DWORD,PSID);
 NTSYSAPI void      WINAPI RtlAddRefActivationContext(HANDLE);
 NTSYSAPI PVOID     WINAPI RtlAddVectoredExceptionHandler(ULONG,PVECTORED_EXCEPTION_HANDLER);
+NTSYSAPI PVOID     WINAPI RtlAddressInSectionTable(const IMAGE_NT_HEADERS*,HMODULE,DWORD);
 NTSYSAPI NTSTATUS  WINAPI RtlAdjustPrivilege(ULONG,BOOLEAN,BOOLEAN,PBOOLEAN);
 NTSYSAPI NTSTATUS  WINAPI RtlAllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY,BYTE,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,PSID *);
 NTSYSAPI RTL_HANDLE * WINAPI RtlAllocateHandle(RTL_HANDLE_TABLE *,ULONG *);
@@ -4513,7 +4523,7 @@ NTSYSAPI NTSTATUS  WINAPI RtlQueryTimeZoneInformation(RTL_TIME_ZONE_INFORMATION*
 NTSYSAPI BOOL      WINAPI RtlQueryUnbiasedInterruptTime(ULONGLONG*);
 NTSYSAPI NTSTATUS  WINAPI RtlQueueWorkItem(PRTL_WORK_ITEM_ROUTINE,PVOID,ULONG);
 NTSYSAPI void      WINAPI RtlRaiseException(PEXCEPTION_RECORD);
-NTSYSAPI void      WINAPI RtlRaiseStatus(NTSTATUS);
+NTSYSAPI void      DECLSPEC_NORETURN WINAPI RtlRaiseStatus(NTSTATUS);
 NTSYSAPI ULONG     WINAPI RtlRandom(PULONG);
 NTSYSAPI PVOID     WINAPI RtlReAllocateHeap(HANDLE,ULONG,PVOID,SIZE_T) __WINE_ALLOC_SIZE(4) __WINE_DEALLOC(RtlFreeHeap,3);
 NTSYSAPI NTSTATUS  WINAPI RtlRegisterWait(PHANDLE,HANDLE,RTL_WAITORTIMERCALLBACKFUNC,PVOID,ULONG,ULONG);
diff --git a/include/winuser.h b/include/winuser.h
index d1e03461d07..90a1901182f 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4766,6 +4766,9 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+WINUSERAPI LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                               UINT msg, WPARAM wparam, LPARAM lparam,
+                                                               UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 
 /* Uxtheme hook functions and struct */
 
diff --git a/loader/preloader_mac.c b/loader/preloader_mac.c
index 5df185d0960..ce7a14e17ae 100644
--- a/loader/preloader_mac.c
+++ b/loader/preloader_mac.c
@@ -619,25 +619,22 @@ static inline void get_dyld_func( const char *name, void **func )
 static void fixup_stack( void *stack )
 {
     int *pargc;
-    char **argv, **env, **apple, **apple_end;
+    char **argv, **env_new;
+    static char dummyvar[] = "WINEPRELOADERDUMMYVAR=1";
 
     pargc = stack;
     argv = (char **)pargc + 1;
-    env = &argv[*pargc-1] + 2;
-
-    apple = env;
-    while (*apple)
-        apple++;
-    apple++;
-
-    apple_end = apple;
-    while (*apple_end)
-        apple_end++;
-    apple_end++;
 
-    /* decrement argc, and move all the data between &argv[1] and apple_end down to start at &argv[0] */
+    /* decrement argc, and "remove" argv[0] */
     *pargc = *pargc - 1;
-    memmove(&argv[0], &argv[1], (char *)apple_end - (char *)&argv[1]);
+    memmove( &argv[0], &argv[1], (*pargc + 1) * sizeof(char *) );
+
+    env_new = &argv[*pargc-1] + 2;
+    /* In the launched binary on some OSes, _NSGetEnviron() returns
+     * the original 'environ' pointer, so env_new[0] would be ignored.
+     * Put a dummy variable in env_new[0], so nothing is lost in this case.
+     */
+    env_new[0] = dummyvar;
 }
 
 static void set_program_vars( void *stack, void *mod )
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index f1525c4f6dd..1f5138051c9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -171,6 +171,7 @@ AddService=EventLog,0x800,EventLogService
 AddService=HTTP,0,HTTPService
 AddService=MSIServer,0,MSIService
 AddService=RpcSs,0,RpcSsService
+AddService=scardsvr,0,ScardSvrService
 AddService=Spooler,0,SpoolerService
 AddService=StiSvc,0,StiService
 AddService=TermService,0,TerminalServices
@@ -190,6 +191,7 @@ AddService=EventLog,0x800,EventLogService
 AddService=HTTP,0,HTTPService
 AddService=MSIServer,0,MSIService
 AddService=RpcSs,0,RpcSsService
+AddService=scardsvr,0,ScardSvrService
 AddService=Spooler,0,SpoolerService
 AddService=StiSvc,0,StiService
 AddService=TermService,0,TerminalServices
@@ -209,6 +211,7 @@ AddService=EventLog,0x800,EventLogService
 AddService=HTTP,0,HTTPService
 AddService=MSIServer,0,MSIService
 AddService=RpcSs,0,RpcSsService
+AddService=scardsvr,0,ScardSvrService
 AddService=Spooler,0,SpoolerService
 AddService=StiSvc,0,StiService
 AddService=TermService,0,TerminalServices
@@ -228,6 +231,7 @@ AddService=EventLog,0x800,EventLogService
 AddService=HTTP,0,HTTPService
 AddService=MSIServer,0,MSIService
 AddService=RpcSs,0,RpcSsService
+AddService=scardsvr,0,ScardSvrService
 AddService=Spooler,0,SpoolerService
 AddService=StiSvc,0,StiService
 AddService=TermService,0,TerminalServices
@@ -2238,7 +2242,7 @@ system.ini, drivers32,,"msacm.msgsm610=msgsm32.acm"
 system.ini, drivers32,,"vidc.mrle=msrle32.dll"
 system.ini, drivers32,,"vidc.msvc=msvidc32.dll"
 system.ini, drivers32,,"vidc.cvid=iccvid.dll"
-system.ini, drivers32,,"; vidc.IV50=ir50_32.dll"
+system.ini, drivers32,,"vidc.IV50=ir50_32.dll"
 system.ini, drivers32,,"; vidc.IV31=ir32_32.dll"
 system.ini, drivers32,,"; vidc.IV32=ir32_32.dll"
 
@@ -2321,6 +2325,19 @@ ServiceType=32
 StartType=3
 ErrorControl=1
 
+[ScardSvrService]
+AddReg=ScardSvrServiceKeys
+DisplayName="Smart card server"
+ServiceBinary="%11%\svchost.exe -k netsvcs"
+ServiceType=32
+StartType=3
+ErrorControl=1
+
+[ScardSvrServiceKeys]
+HKR,Parameters,"ServiceDll",,"%11%\scardsvr.dll"
+HKR,Parameters,"ServiceMain",,"CalaisMain"
+HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"scardsvr"
+
 [SpoolerService]
 AddReg=SpoolerServiceKeys
 Description="Loads files to memory for later printing"
@@ -2370,15 +2387,15 @@ ErrorControl=1
 
 [BITSServiceKeys]
 HKR,Parameters,"ServiceDll",,"%11%\qmgr.dll"
-HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010000,"BITS"
+HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"BITS"
 
 [EventLogServiceKeys]
 HKR,Parameters,"ServiceDll",,"%11%\wevtsvc.dll"
-HKLM,%CurrentVersionNT%\SvcHost,"LocalServiceNetworkRestricted",0x00010000,"EventLog"
+HKLM,%CurrentVersionNT%\SvcHost,"LocalServiceNetworkRestricted",0x00010008,"EventLog"
 
 [StiServiceKeys]
 HKR,Parameters,"ServiceDll",,"%11%\wiaservc.dll"
-HKLM,%CurrentVersionNT%\SvcHost,"imgsvc",0x00010000,"StiSvc"
+HKLM,%CurrentVersionNT%\SvcHost,"imgsvc",0x00010008,"StiSvc"
 
 [PlugPlayService]
 Description="Enables automatic configuration of devices"
@@ -2453,13 +2470,12 @@ HKLM,"System\CurrentControlSet\Services\Winsock\Parameters",,16
 HKLM,"System\CurrentControlSet\Services\Winsock2\Parameters\Protocol_Catalog9\Catalog_Entries",,16
 
 [VersionInfo]
-HKLM,%CurrentVersionNT%,"CurrentVersion",2,"6.1"
-HKLM,%CurrentVersionNT%,"CurrentMajorVersionNumber",0x10001,6
-HKLM,%CurrentVersionNT%,"CurrentMinorVersionNumber",0x10001,1
-HKLM,%CurrentVersionNT%,"CSDVersion",2,"Service Pack 1"
-HKLM,%CurrentVersionNT%,"CurrentBuild",2,"7601"
-HKLM,%CurrentVersionNT%,"CurrentBuildNumber",2,"7601"
-HKLM,%CurrentVersionNT%,"CurrentType",2,"Uniprocessor Free"
+HKLM,%CurrentVersionNT%,"CurrentVersion",2,"6.3"
+HKLM,%CurrentVersionNT%,"CurrentMajorVersionNumber",0x10001,10
+HKLM,%CurrentVersionNT%,"CurrentMinorVersionNumber",0x10001,0
+HKLM,%CurrentVersionNT%,"CurrentBuild",2,"18362"
+HKLM,%CurrentVersionNT%,"CurrentBuildNumber",2,"18362"
+HKLM,%CurrentVersionNT%,"CurrentType",2,"Multiprocessor Free"
 HKLM,%CurrentVersionNT%,"DigitalProductId",1,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
@@ -2467,17 +2483,18 @@ HKLM,%CurrentVersionNT%,"DigitalProductId",1,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
-HKLM,%CurrentVersionNT%,"ProductName",2,"Microsoft Windows 7"
+HKLM,%CurrentVersionNT%,"ProductName",2,"Windows 10 Pro"
 HKLM,%Control%\ProductOptions,"ProductType",2,"WinNT"
-HKLM,%Control%\Windows,"CSDVersion",0x10003,0x100
+HKLM,%Control%\Windows,"CSDVersion",0x10003,0
 HKLM,%Control%\Session Manager\Environment,"OS",2,"Windows_NT"
 
 [VersionInfo.ntamd64]
-HKLM,%CurrentVersionNT%,"CurrentVersion",2,"6.1"
-HKLM,%CurrentVersionNT%,"CSDVersion",2,"Service Pack 1"
-HKLM,%CurrentVersionNT%,"CurrentBuild",2,"7601"
-HKLM,%CurrentVersionNT%,"CurrentBuildNumber",2,"7601"
-HKLM,%CurrentVersionNT%,"CurrentType",2,"Uniprocessor Free"
+HKLM,%CurrentVersionNT%,"CurrentVersion",2,"6.3"
+HKLM,%CurrentVersionNT%,"CurrentMajorVersionNumber",0x10001,10
+HKLM,%CurrentVersionNT%,"CurrentMinorVersionNumber",0x10001,0
+HKLM,%CurrentVersionNT%,"CurrentBuild",2,"18362"
+HKLM,%CurrentVersionNT%,"CurrentBuildNumber",2,"18362"
+HKLM,%CurrentVersionNT%,"CurrentType",2,"Multiprocessor Free"
 HKLM,%CurrentVersionNT%,"DigitalProductId",1,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
@@ -2485,9 +2502,9 @@ HKLM,%CurrentVersionNT%,"DigitalProductId",1,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
-HKLM,%CurrentVersionNT%,"ProductName",2,"Microsoft Windows 7"
+HKLM,%CurrentVersionNT%,"ProductName",2,"Windows 10 Pro"
 HKLM,%Control%\ProductOptions,"ProductType",2,"WinNT"
-HKLM,%Control%\Windows,"CSDVersion",0x10003,0x100
+HKLM,%Control%\Windows,"CSDVersion",0x10003,0
 HKLM,%Control%\Session Manager\Environment,"OS",2,"Windows_NT"
 
 [Wow64]
diff --git a/loader/wine.man.in b/loader/wine.man.in
index ff37586d5fa..e04a76cd261 100644
--- a/loader/wine.man.in
+++ b/loader/wine.man.in
@@ -228,6 +228,18 @@ existing prefix, Wine will refuse to start if
 .B WINEARCH
 doesn't match the prefix architecture.
 .TP
+.B WINE_D3D_CONFIG
+Specifies Direct3D configuration options. It can be used instead of
+modifying the
+.B HKEY_CURRENT_USER\\\\Software\\\\Wine\\\\Direct3D
+registry key. The value is a comma- or semicolon-separated list
+of key-value pairs. For example:
+.IP
+WINE_D3D_CONFIG="renderer=vulkan;VideoPciVendorID=0xc0de"
+.IP
+If an individual setting is specified in both
+the environment variable and the registry, the former takes precedence.
+.TP
 .B DISPLAY
 Specifies the X11 display to use.
 .TP
diff --git a/po/ar.po b/po/ar.po
index 2888fed4538..cd62e2e0778 100644
--- a/po/ar.po
+++ b/po/ar.po
@@ -3732,6 +3732,18 @@ msgstr "زائد"
 msgid "High"
 msgstr "عالي"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "الفهرس"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "ترميز واين المرئي الأول"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "مقابض اللعب"
diff --git a/po/ast.po b/po/ast.po
index 8b505d8f5d9..a7eee717c32 100644
--- a/po/ast.po
+++ b/po/ast.po
@@ -3626,6 +3626,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/bg.po b/po/bg.po
index 3bc0e391cdb..a9e78c77521 100644
--- a/po/bg.po
+++ b/po/bg.po
@@ -3744,6 +3744,16 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+msgid "Indeo5"
+msgstr "&Съдържание"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine MS-RLE видео кодек"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/ca.po b/po/ca.po
index 591482a8c64..a430456bbcd 100644
--- a/po/ca.po
+++ b/po/ca.po
@@ -3724,6 +3724,18 @@ msgstr "Elevat"
 msgid "High"
 msgstr "Alt"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Índex"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Còdec de vídeo Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Palanques de control"
diff --git a/po/cs.po b/po/cs.po
index a453ec50c6e..d51e26c5b6a 100644
--- a/po/cs.po
+++ b/po/cs.po
@@ -3681,6 +3681,18 @@ msgstr "Zvýšená"
 msgid "High"
 msgstr "Vysoká"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Rejstřík"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Videokodek Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Pákové ovladače"
diff --git a/po/da.po b/po/da.po
index 970f7df80c3..b8de8dcdd7c 100644
--- a/po/da.po
+++ b/po/da.po
@@ -3763,6 +3763,18 @@ msgstr "Øget"
 msgid "High"
 msgstr "&Høj"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Indeks"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 videokodeks"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/de.po b/po/de.po
index 235569a0fab..20c8a6be64a 100644
--- a/po/de.po
+++ b/po/de.po
@@ -3714,6 +3714,18 @@ msgstr "Erhöht"
 msgid "High"
 msgstr "Hoch"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Index"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine-Video-1-Videocodec"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/el.po b/po/el.po
index 3a5c6aba714..58674907408 100644
--- a/po/el.po
+++ b/po/el.po
@@ -3661,6 +3661,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/en.po b/po/en.po
index 1664c52597b..1ed59037d4c 100644
--- a/po/en.po
+++ b/po/en.po
@@ -3707,6 +3707,14 @@ msgstr "Increased"
 msgid "High"
 msgstr "High"
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr "Indeo5"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Indeo Video Interactive version 5 video codec"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/en_US.po b/po/en_US.po
index c04161fe970..2fb6c765106 100644
--- a/po/en_US.po
+++ b/po/en_US.po
@@ -3707,6 +3707,14 @@ msgstr "Increased"
 msgid "High"
 msgstr "High"
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr "Indeo5"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Indeo Video Interactive version 5 video codec"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/eo.po b/po/eo.po
index 8776dd68b21..2e6483b907a 100644
--- a/po/eo.po
+++ b/po/eo.po
@@ -3649,6 +3649,16 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Indekso"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/es.po b/po/es.po
index fe577dd60e3..3332c8ae60d 100644
--- a/po/es.po
+++ b/po/es.po
@@ -3727,6 +3727,18 @@ msgstr "Aumentada"
 msgid "High"
 msgstr "Alta"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Índice"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Códec de vídeo Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Comando de juego"
diff --git a/po/fa.po b/po/fa.po
index 5388bf13738..5b3d791f4b5 100644
--- a/po/fa.po
+++ b/po/fa.po
@@ -3692,6 +3692,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/fi.po b/po/fi.po
index 793989e014a..b086164e67d 100644
--- a/po/fi.po
+++ b/po/fi.po
@@ -3701,6 +3701,18 @@ msgstr "Korotettu"
 msgid "High"
 msgstr "Korkea"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Sisällys"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Winen Video 1 -videokoodekki"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joystickit"
@@ -3743,25 +3755,23 @@ msgstr ""
 
 #: dlls/joy.cpl/joy.rc:55
 msgid "DInput"
-msgstr ""
+msgstr "DInput"
 
 #: dlls/joy.cpl/joy.rc:59
 msgid "Axes"
-msgstr ""
+msgstr "Akselit"
 
 #: dlls/joy.cpl/joy.rc:60
 msgid "POVs"
-msgstr ""
+msgstr "POV:t"
 
 #: dlls/joy.cpl/joy.rc:61
 msgid "Buttons"
 msgstr "Painikkeet"
 
 #: dlls/joy.cpl/joy.rc:62
-#, fuzzy
-#| msgid "Test Force Feedback"
 msgid "Force Feedback Effect"
-msgstr "Testaa voimapalautetta"
+msgstr "Voimapalautteen efekti"
 
 #: dlls/joy.cpl/joy.rc:64
 msgid ""
@@ -3773,60 +3783,60 @@ msgstr ""
 
 #: dlls/joy.cpl/joy.rc:70
 msgid "XInput"
-msgstr ""
+msgstr "XInput"
 
 #: dlls/joy.cpl/joy.rc:73
-#, fuzzy
-#| msgid "User"
 msgid "User #0"
-msgstr "Käyttäjä"
+msgstr "Käyttäjä #0"
 
 #: dlls/joy.cpl/joy.rc:74
-#, fuzzy
-#| msgid "User"
 msgid "User #1"
-msgstr "Käyttäjä"
+msgstr "Käyttäjä #1"
 
 #: dlls/joy.cpl/joy.rc:75
-#, fuzzy
-#| msgid "User"
 msgid "User #2"
-msgstr "Käyttäjä"
+msgstr "Käyttäjä #2"
 
 #: dlls/joy.cpl/joy.rc:76
-#, fuzzy
-#| msgid "User"
 msgid "User #3"
-msgstr "Käyttäjä"
+msgstr "Käyttäjä #3"
 
 #: dlls/joy.cpl/joy.rc:78
 msgid ""
 "No user detected on slot #0, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"Ei käyttäjää paikalla #0. Varmista, että ohjain on kytketty ja ettei sitä "
+"ole ohitettu DInput- tai Joystickit-välilehdellä."
 
 #: dlls/joy.cpl/joy.rc:82
 msgid ""
 "No user detected on slot #1, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"Ei käyttäjää paikalla #1. Varmista, että ohjain on kytketty ja ettei sitä "
+"ole ohitettu DInput- tai Joystickit-välilehdellä."
 
 #: dlls/joy.cpl/joy.rc:86
 msgid ""
 "No user detected on slot #2, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"Ei käyttäjää paikalla #2. Varmista, että ohjain on kytketty ja ettei sitä "
+"ole ohitettu DInput- tai Joystickit-välilehdellä."
 
 #: dlls/joy.cpl/joy.rc:90
 msgid ""
 "No user detected on slot #3, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"Ei käyttäjää paikalla #3. Varmista, että ohjain on kytketty ja ettei sitä "
+"ole ohitettu DInput- tai Joystickit-välilehdellä."
 
 #: dlls/joy.cpl/joy.rc:95 dlls/joy.cpl/joy.rc:96 dlls/joy.cpl/joy.rc:97
 #: dlls/joy.cpl/joy.rc:98
 msgid "Rumble"
-msgstr ""
+msgstr "Tärinä"
 
 #: dlls/joy.cpl/joy.rc:31
 msgid "Game Controllers"
diff --git a/po/fr.po b/po/fr.po
index b84024c5fea..bbbce1860d2 100644
--- a/po/fr.po
+++ b/po/fr.po
@@ -3732,6 +3732,18 @@ msgstr "Augmentée"
 msgid "High"
 msgstr "Haute"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Index"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Codec vidéo Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/he.po b/po/he.po
index fc504572108..a94aee1f02c 100644
--- a/po/he.po
+++ b/po/he.po
@@ -3727,6 +3727,18 @@ msgstr "מוגברת"
 msgid "High"
 msgstr "גבוהה"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "מפתח"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "מקודד הווידאו Video 1 של Wine"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/hi.po b/po/hi.po
index 03919a4a1ca..245b3e6c37d 100644
--- a/po/hi.po
+++ b/po/hi.po
@@ -3625,6 +3625,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/hr.po b/po/hr.po
index f9e965d2a08..8b664e48c20 100644
--- a/po/hr.po
+++ b/po/hr.po
@@ -3737,6 +3737,18 @@ msgstr "Povećane"
 msgid "High"
 msgstr "Visoke"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Indeks"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 video codec"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joystici"
diff --git a/po/hu.po b/po/hu.po
index aefd8906dfd..483ce7f0773 100644
--- a/po/hu.po
+++ b/po/hu.po
@@ -3779,6 +3779,18 @@ msgstr "Megnövelt"
 msgid "High"
 msgstr "Magas"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "&Témakörök"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 video kodek"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/it.po b/po/it.po
index 7c7e9c26e6a..2a8ffe830a8 100644
--- a/po/it.po
+++ b/po/it.po
@@ -3787,6 +3787,18 @@ msgstr "Aumentato"
 msgid "High"
 msgstr "Alta"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Indice"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Codec Video Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/ja.po b/po/ja.po
index 31e2e57eeb8..98969c70319 100644
--- a/po/ja.po
+++ b/po/ja.po
@@ -3699,6 +3699,18 @@ msgstr "中高"
 msgid "High"
 msgstr "高"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "索引"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine ビデオ 1 ビデオコーデック"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "ジョイスティック"
diff --git a/po/ko.po b/po/ko.po
index ff4d3f5e5dc..da9b570fe48 100644
--- a/po/ko.po
+++ b/po/ko.po
@@ -5,7 +5,7 @@ msgstr ""
 "Project-Id-Version: Wine\n"
 "Report-Msgid-Bugs-To: https://bugs.winehq.org\n"
 "POT-Creation-Date: N/A\n"
-"PO-Revision-Date: 2022-07-15 15:16+0900\n"
+"PO-Revision-Date: 2023-01-20 20:34+0900\n"
 "Last-Translator: Byeongsik Jeon <bsjeon@hanmail.net>\n"
 "Language-Team: Korean\n"
 "Language: ko\n"
@@ -1331,8 +1331,6 @@ msgid "Options"
 msgstr "옵션"
 
 #: dlls/compstui/compstui.rc:31
-#, fuzzy
-#| msgid "Defaults"
 msgid "Default"
 msgstr "기본값"
 
@@ -3691,6 +3689,18 @@ msgstr "증가"
 msgid "High"
 msgstr "높음"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "인덱스"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine 비디오 1 비디오 코덱"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "조이스틱"
@@ -3728,95 +3738,93 @@ msgid ""
 "After disabling or enabling a device, the connected joysticks won't be "
 "updated here until you restart this applet."
 msgstr ""
-"장치를 비활성화하거나 활성화한 후, 이 애플릿을 다시 시작할 때까지 연결된 조이"
-"스틱을 업데이트하지 않습니다."
+"장치를 비활성화하거나 활성화한 후에는, 이 애플릿을 다시 시작할 때까지 연결된 "
+"조이스틱이 업데이트되지 않습니다."
 
 #: dlls/joy.cpl/joy.rc:55
 msgid "DInput"
-msgstr ""
+msgstr "DInput"
 
 #: dlls/joy.cpl/joy.rc:59
 msgid "Axes"
-msgstr ""
+msgstr "축"
 
 #: dlls/joy.cpl/joy.rc:60
 msgid "POVs"
-msgstr ""
+msgstr "시점"
 
 #: dlls/joy.cpl/joy.rc:61
 msgid "Buttons"
 msgstr "버튼"
 
 #: dlls/joy.cpl/joy.rc:62
-#, fuzzy
-#| msgid "Test Force Feedback"
 msgid "Force Feedback Effect"
-msgstr "강제 피드백 테스트"
+msgstr "피드백 효과 강제"
 
 #: dlls/joy.cpl/joy.rc:64
 msgid ""
 "Press any button in the controller to activate the chosen effect. The effect "
 "direction can be changed with the controller axis."
 msgstr ""
-"컨트롤러의 아무 버튼이나 눌러 선택한 효과를 활성화합니다. 컨트롤러 축을 이용"
-"하여 효과 방향을 바꿀 수 있습니다."
+"선택한 효과를 활성화하려면 컨트롤러의 아무 버튼이나 누르십시오. 효과 방향은 "
+"컨트롤러 축으로 변경할 수 있습니다."
 
 #: dlls/joy.cpl/joy.rc:70
 msgid "XInput"
-msgstr ""
+msgstr "XInput"
 
 #: dlls/joy.cpl/joy.rc:73
-#, fuzzy
-#| msgid "User"
 msgid "User #0"
-msgstr "사용자"
+msgstr "사용자 #0"
 
 #: dlls/joy.cpl/joy.rc:74
-#, fuzzy
-#| msgid "User"
 msgid "User #1"
-msgstr "사용자"
+msgstr "사용자 #1"
 
 #: dlls/joy.cpl/joy.rc:75
-#, fuzzy
-#| msgid "User"
 msgid "User #2"
-msgstr "사용자"
+msgstr "사용자 #2"
 
 #: dlls/joy.cpl/joy.rc:76
-#, fuzzy
-#| msgid "User"
 msgid "User #3"
-msgstr "사용자"
+msgstr "사용자 #3"
 
 #: dlls/joy.cpl/joy.rc:78
 msgid ""
 "No user detected on slot #0, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"슬롯 #0 사용이 감지되지 않았습니다. 게임패드가 연결되어 있는지, 조이스틱 탭에"
+"서 DInput으로 재정의되지 않았는지 확인하십시오."
 
 #: dlls/joy.cpl/joy.rc:82
 msgid ""
 "No user detected on slot #1, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"슬롯 #1 사용이 감지되지 않았습니다. 게임패드가 연결되어 있는지, 조이스틱 탭에"
+"서 DInput으로 재정의되지 않았는지 확인하십시오."
 
 #: dlls/joy.cpl/joy.rc:86
 msgid ""
 "No user detected on slot #2, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"슬롯 #2 사용이 감지되지 않았습니다. 게임패드가 연결되어 있는지, 조이스틱 탭에"
+"서 DInput으로 재정의되지 않았는지 확인하십시오."
 
 #: dlls/joy.cpl/joy.rc:90
 msgid ""
 "No user detected on slot #3, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"슬롯 #3 사용이 감지되지 않았습니다. 게임패드가 연결되어 있는지, 조이스틱 탭에"
+"서 DInput으로 재정의되지 않았는지 확인하십시오."
 
 #: dlls/joy.cpl/joy.rc:95 dlls/joy.cpl/joy.rc:96 dlls/joy.cpl/joy.rc:97
 #: dlls/joy.cpl/joy.rc:98
 msgid "Rumble"
-msgstr ""
+msgstr "진동"
 
 #: dlls/joy.cpl/joy.rc:31
 msgid "Game Controllers"
@@ -15082,10 +15090,8 @@ msgid "&Replace...\tCtrl+H"
 msgstr "바꾸기(&R)...\tCtrl+H"
 
 #: programs/notepad/notepad.rc:59
-#, fuzzy
-#| msgid "&New...\tCtrl+N"
 msgid "&Go To...\tCtrl+G"
-msgstr "새 파일(&N)...\tCtrl+N"
+msgstr "이동(&G)...\tCtrl+G"
 
 #: programs/notepad/notepad.rc:63 programs/oleview/oleview.rc:68
 #: programs/oleview/oleview.rc:90 programs/winefile/winefile.rc:67
@@ -15128,17 +15134,15 @@ msgstr "위(&T):"
 
 #: programs/notepad/notepad.rc:132
 msgid "Go To Line"
-msgstr ""
+msgstr "줄 이동"
 
 #: programs/notepad/notepad.rc:134
-#, fuzzy
-#| msgid "CRL Number"
 msgid "&Line Number:"
-msgstr "CRL 번호"
+msgstr "줄 번호(&L):"
 
 #: programs/notepad/notepad.rc:137
 msgid "Go To"
-msgstr ""
+msgstr "이동"
 
 #: programs/notepad/notepad.rc:145
 msgid "Encoding:"
@@ -15204,7 +15208,7 @@ msgstr "Z"
 #: programs/notepad/notepad.rc:162
 msgctxt "accelerator GoTo"
 msgid "G"
-msgstr ""
+msgstr "G"
 
 #: programs/notepad/notepad.rc:74
 msgid "Page &p"
@@ -15281,7 +15285,7 @@ msgstr ""
 
 #: programs/notepad/notepad.rc:90
 msgid "Ln %ld, Col %ld"
-msgstr ""
+msgstr "Ln %ld, Col %ld"
 
 #: programs/oleview/oleview.rc:32
 msgid "&Bind to file..."
diff --git a/po/lt.po b/po/lt.po
index 4ef96a92e99..2e90152c5b3 100644
--- a/po/lt.po
+++ b/po/lt.po
@@ -5,7 +5,7 @@ msgstr ""
 "Project-Id-Version: Wine\n"
 "Report-Msgid-Bugs-To: https://bugs.winehq.org\n"
 "POT-Creation-Date: N/A\n"
-"PO-Revision-Date: 2022-12-01 23:35+0200\n"
+"PO-Revision-Date: 2023-02-13 23:59+0200\n"
 "Last-Translator: Aurimas Fišeras <aurimas@members.fsf.org>\n"
 "Language-Team: Lithuanian <komp_lt@konf.lt>\n"
 "Language: lt\n"
@@ -3710,6 +3710,14 @@ msgstr "Padidintos"
 msgid "High"
 msgstr "Aukštos"
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr "Indeo5"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Indeo Video 5 interaktyvus vaizdo kodekas"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Vairasvirtės"
diff --git a/po/ml.po b/po/ml.po
index 3b431aec552..176f27e3be5 100644
--- a/po/ml.po
+++ b/po/ml.po
@@ -3627,6 +3627,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/nb_NO.po b/po/nb_NO.po
index 01b12008f5c..f73e4ba73c0 100644
--- a/po/nb_NO.po
+++ b/po/nb_NO.po
@@ -3715,6 +3715,18 @@ msgstr "Økt"
 msgid "High"
 msgstr "Høy"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Innhold"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 videokodeks"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Styrespaker"
diff --git a/po/nl.po b/po/nl.po
index bc4e374862c..6daa1fb45c0 100644
--- a/po/nl.po
+++ b/po/nl.po
@@ -3720,6 +3720,18 @@ msgstr "Verhoogd"
 msgid "High"
 msgstr "Hoog"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Index"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 video codec"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/or.po b/po/or.po
index 0082689f58d..06b6e636225 100644
--- a/po/or.po
+++ b/po/or.po
@@ -3625,6 +3625,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/pa.po b/po/pa.po
index 4c3f431b746..2c52f97474c 100644
--- a/po/pa.po
+++ b/po/pa.po
@@ -3625,6 +3625,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/pl.po b/po/pl.po
index 583db3af500..fb41e7fc294 100644
--- a/po/pl.po
+++ b/po/pl.po
@@ -3726,6 +3726,18 @@ msgstr "Wysoki"
 msgid "High"
 msgstr "Najwyższy"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Indeks"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Kodek Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticki"
diff --git a/po/pt_BR.po b/po/pt_BR.po
index 2cfd2549ed6..b1c24d68075 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -3722,6 +3722,18 @@ msgstr "Elevada"
 msgid "High"
 msgstr "Alta"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Índice"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Codec de vídeo Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Controles"
diff --git a/po/pt_PT.po b/po/pt_PT.po
index 3eb5aaeea63..4a816399c67 100644
--- a/po/pt_PT.po
+++ b/po/pt_PT.po
@@ -3763,6 +3763,18 @@ msgstr "Aumentada"
 msgid "High"
 msgstr "Alta"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Índice"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "codec video Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/rm.po b/po/rm.po
index 33ee55775af..90aa8a8dd3e 100644
--- a/po/rm.po
+++ b/po/rm.po
@@ -3653,6 +3653,15 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+msgid "Indeo5"
+msgstr "&Cuntgn�"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/ro.po b/po/ro.po
index 68592b86328..7931f273f5a 100644
--- a/po/ro.po
+++ b/po/ro.po
@@ -3720,6 +3720,18 @@ msgstr "Mărit"
 msgid "High"
 msgstr "Înalt"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Index"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Codecul video Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joystick-uri"
diff --git a/po/ru.po b/po/ru.po
index d30632b6cef..fcc06c510e1 100644
--- a/po/ru.po
+++ b/po/ru.po
@@ -3725,6 +3725,18 @@ msgstr "Повышенный"
 msgid "High"
 msgstr "Высокий"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Указатель"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Видео кодек Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Джойстики"
diff --git a/po/si.po b/po/si.po
index 4e2270c3320..aecca20f418 100644
--- a/po/si.po
+++ b/po/si.po
@@ -3652,6 +3652,18 @@ msgstr ""
 msgid "High"
 msgstr "වැඩි"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "දර්ශකය"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine වීඩියෝ 1 වීඩියෝ කොඩෙක්"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "නියාමක යටි"
diff --git a/po/sk.po b/po/sk.po
index c2387d413c6..4d6695dbc60 100644
--- a/po/sk.po
+++ b/po/sk.po
@@ -3694,6 +3694,16 @@ msgstr "Zvýšené"
 msgid "High"
 msgstr "Vysoké"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Obsah"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/sl.po b/po/sl.po
index 2708682753e..7803831f3c0 100644
--- a/po/sl.po
+++ b/po/sl.po
@@ -3781,6 +3781,18 @@ msgstr "Povečano"
 msgid "High"
 msgstr "Visoka"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Kazalo"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 video kodek"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/sr_RS@cyrillic.po b/po/sr_RS@cyrillic.po
index 34cd34c3246..af99154f535 100644
--- a/po/sr_RS@cyrillic.po
+++ b/po/sr_RS@cyrillic.po
@@ -3762,6 +3762,17 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+msgid "Indeo5"
+msgstr "&Попис"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 видео кодек"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/sr_RS@latin.po b/po/sr_RS@latin.po
index ed7e9811776..6218024b27d 100644
--- a/po/sr_RS@latin.po
+++ b/po/sr_RS@latin.po
@@ -3846,6 +3846,18 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Index"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 video kodek"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/sv.po b/po/sv.po
index 5e52599bef0..9923505bebb 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -3742,6 +3742,18 @@ msgstr "Ökad"
 msgid "High"
 msgstr "Hög"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Index"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 videokodek"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Joysticks"
diff --git a/po/ta.po b/po/ta.po
index 368a3a2a2d4..e4fb8ceb940 100644
--- a/po/ta.po
+++ b/po/ta.po
@@ -1,42 +1,42 @@
 # Tamil translations for Wine
 #
+# Isira Seneviratne <isirasen96@gmail.com>, 2019
+# K.B.Dharun Krishna <kbdharunkrishna@gmail.com>, 2022
 msgid ""
 msgstr ""
 "Project-Id-Version: Wine\n"
 "Report-Msgid-Bugs-To: https://bugs.winehq.org\n"
 "POT-Creation-Date: N/A\n"
-"PO-Revision-Date: 2019-03-29 20:31+0530\n"
+"PO-Revision-Date: 2022-12-29 22:48+0530\n"
 "Last-Translator: Isira Seneviratne <isirasen96@gmail.com>\n"
 "Language-Team: Tamil\n"
 "Language: ta\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: Lokalize 18.12.3\n"
 "Plural-Forms: nplurals=2; plural=n != 1;\n"
+"X-Generator: Poedit 3.2.2\n"
 
 #: dlls/aclui/aclui.rc:29 dlls/inetcpl.cpl/inetcpl.rc:90
 #: programs/winefile/winefile.rc:114
 msgid "Security"
-msgstr ""
+msgstr "பாதுகாப்பு"
 
 #: dlls/aclui/aclui.rc:32
 msgid "&Group or user names:"
-msgstr ""
+msgstr "&குழு அல்லது பயனர் பெயர்கள்:"
 
 #: dlls/aclui/aclui.rc:38
-#, fuzzy
-#| msgid "Yellow"
 msgid "Allow"
-msgstr "மஞ்சள்"
+msgstr "அனுமதி"
 
 #: dlls/aclui/aclui.rc:39
 msgid "Deny"
-msgstr ""
+msgstr "மறுக்கவும்"
 
 #: dlls/aclui/aclui.rc:47
 msgid "Permissions for %1"
-msgstr ""
+msgstr "% 1க்கான அனுமதிகள்"
 
 #: dlls/appwiz.cpl/appwiz.rc:58
 msgid "Install/Uninstall"
@@ -47,10 +47,12 @@ msgid ""
 "To install a new program from a floppy disk, CD-ROM drive, or your hard "
 "drive, click Install."
 msgstr ""
+"ஃப்ளாப்பி டிஸ்க், சிடி-ரோம் (CD-ROM) டிரைவ் அல்லது உங்கள் ஹார்ட் டிரைவிலிருந்து புதிய "
+"நிரலை நிறுவ, நிறுவு என்பதைக் கிளிக் செய்யவும்."
 
 #: dlls/appwiz.cpl/appwiz.rc:62
 msgid "&Install..."
-msgstr "நிறுவு..."
+msgstr "நிறுவு... (&I)"
 
 #: dlls/appwiz.cpl/appwiz.rc:65
 msgid ""
@@ -58,6 +60,9 @@ msgid ""
 "to modify its installed components, select it from the list and click Modify/"
 "Remove."
 msgstr ""
+"பின்வரும் மென்பொருளை தானாக நீக்க முடியும். ஒரு நிரலை அகற்ற அல்லது அதன் நிறுவப்பட்ட "
+"கூறுகளை மாற்ற, பட்டியலிலிருந்து அதைத் தேர்ந்தெடுத்து, மாற்றவும்/நீக்கு என்பதைக் கிளிக் "
+"செய்யவும்."
 
 #: dlls/appwiz.cpl/appwiz.rc:67
 msgid "&Support Information"
@@ -66,7 +71,7 @@ msgstr "ஆதரவு தகவல் (&S)"
 #: dlls/appwiz.cpl/appwiz.rc:68 programs/regedit/regedit.rc:136
 #: programs/regedit/regedit.rc:237
 msgid "&Modify..."
-msgstr "திருத்து... (&M)"
+msgstr "மாற்று... (&M)"
 
 #: dlls/appwiz.cpl/appwiz.rc:69 dlls/appwiz.cpl/appwiz.rc:45
 #: dlls/cryptui/cryptui.rc:351 dlls/msacm32/msacm32.rc:40
@@ -118,7 +123,7 @@ msgstr "சரி"
 
 #: dlls/appwiz.cpl/appwiz.rc:79
 msgid "The following information can be used to get technical support for %s:"
-msgstr ""
+msgstr "%sக்கான தொழில்நுட்ப ஆதரவைப் பெற பின்வரும் தகவலைப் பயன்படுத்தலாம்:"
 
 #: dlls/appwiz.cpl/appwiz.rc:80
 msgid "Publisher:"
@@ -138,7 +143,7 @@ msgstr "ஆதரவு தகவல்:"
 
 #: dlls/appwiz.cpl/appwiz.rc:84
 msgid "Support Telephone:"
-msgstr ""
+msgstr "ஆதரவு தொலைபேசி:"
 
 #: dlls/appwiz.cpl/appwiz.rc:85
 msgid "Readme:"
@@ -146,15 +151,15 @@ msgstr "பயனர் உதவி:"
 
 #: dlls/appwiz.cpl/appwiz.rc:86
 msgid "Product Updates:"
-msgstr ""
+msgstr "தயாரிப்பு புதுப்பிப்புகள்:"
 
 #: dlls/appwiz.cpl/appwiz.rc:87
 msgid "Comments:"
-msgstr ""
+msgstr "கருத்துகள்:"
 
 #: dlls/appwiz.cpl/appwiz.rc:100
 msgid "Wine Gecko Installer"
-msgstr "Wine Gecko நிறுவி"
+msgstr "ஒயின் கெக்கோ நிறுவி"
 
 #: dlls/appwiz.cpl/appwiz.rc:103
 msgid ""
@@ -166,10 +171,16 @@ msgid ""
 "href=\"https://wiki.winehq.org/Gecko\">https://wiki.winehq.org/Gecko</a> for "
 "details."
 msgstr ""
+"HTML உட்பொதிக்கும் பயன்பாடுகள் சரியாக வேலை செய்வதற்குத் தேவையான கெக்கோ தொகுப்பை ஒயினால் "
+"கண்டுபிடிக்க முடியவில்லை. ஒயின் உங்களுக்காக தானாகவே பதிவிறக்கம் செய்து நிறுவும்.\n"
+"\n"
+"குறிப்பு: அதற்குப் பதிலாக உங்கள் விநியோகத் தொகுப்புகளைப் பயன்படுத்த "
+"பரிந்துரைக்கப்படுகிறது. விவரங்களுக்கு <a href=\"https://wiki.winehq.org/"
+"Gecko\">https://wiki.winehq.org/Gecko</a> ஐப் பார்க்கவும்."
 
 #: dlls/appwiz.cpl/appwiz.rc:109 dlls/appwiz.cpl/appwiz.rc:124
 msgid "&Install"
-msgstr "நிறுவு"
+msgstr "நிறுவு (&I)"
 
 #: dlls/appwiz.cpl/appwiz.rc:110 dlls/appwiz.cpl/appwiz.rc:125
 #: dlls/avifil32/avifil32.rc:55 dlls/browseui/browseui.rc:45
@@ -212,11 +223,11 @@ msgstr "நிறுவு"
 #: programs/wordpad/wordpad.rc:227 programs/wordpad/wordpad.rc:245
 #: programs/wordpad/wordpad.rc:258
 msgid "Cancel"
-msgstr "ரத்து"
+msgstr "ரத்துசெய்"
 
 #: dlls/appwiz.cpl/appwiz.rc:115
 msgid "Wine Mono Installer"
-msgstr "Wine Mono நிறுவி"
+msgstr "ஒயின் மோனோ நிறுவி"
 
 #: dlls/appwiz.cpl/appwiz.rc:118
 msgid ""
@@ -228,16 +239,24 @@ msgid ""
 "href=\"https://wiki.winehq.org/Mono\">https://wiki.winehq.org/Mono</a> for "
 "details."
 msgstr ""
+".NET பயன்பாடுகள் சரியாக வேலை செய்வதற்குத் தேவையான ஒயின்-மோனோ தொகுப்பை ஒயினால் "
+"கண்டுபிடிக்க முடியவில்லை. ஒயின் உங்களுக்காக தானாகவே பதிவிறக்கம் செய்து நிறுவும்.\n"
+"\n"
+"குறிப்பு: அதற்குப் பதிலாக உங்கள் விநியோகத் தொகுப்புகளைப் பயன்படுத்த "
+"பரிந்துரைக்கப்படுகிறது. விவரங்களுக்கு <a href=\"https://wiki.winehq.org/"
+"Mono\">https://wiki.winehq.org/Mono</a> ஐப் பார்க்கவும்."
 
 #: dlls/appwiz.cpl/appwiz.rc:31
 msgid "Add/Remove Programs"
-msgstr ""
+msgstr "நிரல்களைச் சேர்க்கவும்/அகற்றவும்"
 
 #: dlls/appwiz.cpl/appwiz.rc:32
 msgid ""
 "Allows you to install new software, or remove existing software from your "
 "computer."
 msgstr ""
+"புதிய மென்பொருளை நிறுவ அல்லது ஏற்கனவே உள்ள மென்பொருளை உங்கள் கணினியிலிருந்து அகற்ற "
+"உங்களை அனுமதிக்கிறது."
 
 #: dlls/appwiz.cpl/appwiz.rc:33 programs/taskmgr/taskmgr.rc:262
 #: programs/winecfg/winecfg.rc:32
@@ -249,10 +268,12 @@ msgid ""
 "Unable to execute the uninstaller, '%s'. Do you want to remove the uninstall "
 "entry for this program from the registry?"
 msgstr ""
+"நிறுவல் நீக்கியை இயக்க முடியவில்லை, '%s'. இந்த நிரலுக்கான நிறுவல் நீக்கம் உள்ளீட்டை "
+"பதிவேட்டில் இருந்து அகற்ற விரும்புகிறீர்களா?"
 
 #: dlls/appwiz.cpl/appwiz.rc:36
 msgid "Not specified"
-msgstr ""
+msgstr "குறிப்பிடப்படவில்லை"
 
 #: dlls/appwiz.cpl/appwiz.rc:38 dlls/oledb32/version.rc:38
 #: dlls/shell32/shell32.rc:144 dlls/shell32/shell32.rc:239
@@ -286,7 +307,7 @@ msgstr "அனைத்து கோப்புகள் (*.*)"
 
 #: dlls/appwiz.cpl/appwiz.rc:46
 msgid "&Modify/Remove"
-msgstr ""
+msgstr "மாற்று/நீக்கு (&M)"
 
 #: dlls/appwiz.cpl/appwiz.rc:51
 msgid "Downloading..."
@@ -301,14 +322,16 @@ msgid ""
 "Unexpected checksum of downloaded file. Aborting installation of corrupted "
 "file."
 msgstr ""
+"பதிவிறக்கம் செய்யப்பட்ட கோப்பின் எதிர்பாராத செக்சம். சிதைந்த கோப்பின் நிறுவலை "
+"நிறுத்துகிறது."
 
 #: dlls/avifil32/avifil32.rc:42
 msgid "Compress options"
-msgstr ""
+msgstr "சுருக்க விருப்பங்கள்"
 
 #: dlls/avifil32/avifil32.rc:45
 msgid "&Choose a stream:"
-msgstr ""
+msgstr "ஒரு ஓடையைத் தேர்ந்தெடுக்கவும் (&C):"
 
 #: dlls/avifil32/avifil32.rc:48 programs/wordpad/wordpad.rc:76
 msgid "&Options..."
@@ -316,15 +339,15 @@ msgstr "விருப்பங்கள்... (&O)"
 
 #: dlls/avifil32/avifil32.rc:49
 msgid "&Interleave every"
-msgstr ""
+msgstr "ஒவ்வொன்றையும் இடைவிடவும் (&I)"
 
 #: dlls/avifil32/avifil32.rc:51 dlls/msvfw32/msvfw32.rc:51
 msgid "frames"
-msgstr ""
+msgstr "பிரேம்கள்"
 
 #: dlls/avifil32/avifil32.rc:52
 msgid "Current format:"
-msgstr ""
+msgstr "தற்போதைய வடிவம்:"
 
 #: dlls/avifil32/avifil32.rc:30
 msgid "Waveform: %s"
@@ -336,7 +359,7 @@ msgstr "அலைவடிவம்"
 
 #: dlls/avifil32/avifil32.rc:32
 msgid "All multimedia files"
-msgstr ""
+msgstr "அனைத்து மல்டிமீடியா கோப்புகள்"
 
 #: dlls/avifil32/avifil32.rc:34
 msgid "video"
@@ -348,23 +371,23 @@ msgstr "ஆடியோ"
 
 #: dlls/avifil32/avifil32.rc:36
 msgid "Wine AVI-default-filehandler"
-msgstr ""
+msgstr "ஒயின் AVI-இயல்புநிலை-கோப்புகையாளுபவர்"
 
 #: dlls/avifil32/avifil32.rc:37
 msgid "uncompressed"
-msgstr ""
+msgstr "சுருக்கப்படாதவை"
 
 #: dlls/browseui/browseui.rc:28
 msgid "Canceling..."
-msgstr ""
+msgstr "ரத்துசெய்கிறது..."
 
 #: dlls/browseui/browseui.rc:29
 msgid "%1!u! %2 remaining"
-msgstr ""
+msgstr "%1!u! % 2 மீதமுள்ளது"
 
 #: dlls/browseui/browseui.rc:30
 msgid "%1!u! %2 and %3!u! %4 remaining"
-msgstr ""
+msgstr "%1!u! %2 மற்றும் %3!u! % 4 மீதமுள்ளது"
 
 #: dlls/browseui/browseui.rc:31
 msgid "seconds"
@@ -376,15 +399,15 @@ msgstr "நிமிடங்கள்"
 
 #: dlls/browseui/browseui.rc:33
 msgid "hours"
-msgstr "மணி"
+msgstr "மணிநேரம்"
 
 #: dlls/comctl32/comctl32.rc:68 programs/winefile/winefile.rc:156
 msgid "Properties for %s"
-msgstr ""
+msgstr "%sக்கான பண்புகள்"
 
 #: dlls/comctl32/comctl32.rc:73 dlls/comdlg32/comdlg32.rc:265
 msgid "&Apply"
-msgstr ""
+msgstr "விண்ணப்பிக்கவும் (&A)"
 
 #: dlls/comctl32/comctl32.rc:74 dlls/comctl32/comctl32.rc:88
 #: dlls/comdlg32/comdlg32.rc:309 dlls/user32/user32.rc:88
@@ -392,24 +415,25 @@ msgid "Help"
 msgstr "உதவி"
 
 #: dlls/comctl32/comctl32.rc:81
+#, fuzzy
 msgid "Wizard"
-msgstr ""
+msgstr "வழிகாட்டி"
 
 #: dlls/comctl32/comctl32.rc:84
 msgid "< &Back"
-msgstr ""
+msgstr "< திரும்பவும் (&B)"
 
 #: dlls/comctl32/comctl32.rc:85 dlls/oledb32/version.rc:61
 msgid "&Next >"
-msgstr ""
+msgstr "அடுத்து (&N)>"
 
 #: dlls/comctl32/comctl32.rc:86
 msgid "Finish"
-msgstr "முடிப்பு"
+msgstr "முடிக்கவும்"
 
 #: dlls/comctl32/comctl32.rc:97
 msgid "Customize Toolbar"
-msgstr ""
+msgstr "கருவிப்பட்டியைத் தனிப்பயனாக்கு"
 
 #: dlls/comctl32/comctl32.rc:100 dlls/comctl32/comctl32.rc:57
 #: dlls/cryptui/cryptui.rc:356 dlls/ieframe/ieframe.rc:43
@@ -421,7 +445,7 @@ msgstr "மூடு (&C)"
 
 #: dlls/comctl32/comctl32.rc:101
 msgid "R&eset"
-msgstr "மீட்டமை (&E)"
+msgstr "மீட்டமை (&e)"
 
 #: dlls/comctl32/comctl32.rc:102 dlls/comdlg32/comdlg32.rc:173
 #: dlls/comdlg32/comdlg32.rc:195 dlls/comdlg32/comdlg32.rc:266
@@ -445,19 +469,19 @@ msgstr "உதவி (&H)"
 
 #: dlls/comctl32/comctl32.rc:103
 msgid "Move &Up"
-msgstr ""
+msgstr "மேலே நகர்த்தவும் (&U)"
 
 #: dlls/comctl32/comctl32.rc:104
 msgid "Move &Down"
-msgstr ""
+msgstr "கீழே நகர்த்தவும் (&D)"
 
 #: dlls/comctl32/comctl32.rc:105
 msgid "A&vailable buttons:"
-msgstr ""
+msgstr "கிடைக்கும் பொத்தான்கள் (&v):"
 
 #: dlls/comctl32/comctl32.rc:107
 msgid "&Add ->"
-msgstr "சேர் (&A) ->"
+msgstr "சேர் (&A)->"
 
 #: dlls/comctl32/comctl32.rc:108
 msgid "<- &Remove"
@@ -465,7 +489,7 @@ msgstr "<- அகற்று (&R)"
 
 #: dlls/comctl32/comctl32.rc:109
 msgid "&Toolbar buttons:"
-msgstr ""
+msgstr "&கருவிப்பட்டி பொத்தான்கள்:"
 
 #: dlls/comctl32/comctl32.rc:42
 msgid "Separator"
@@ -474,7 +498,7 @@ msgstr "பிரிப்பான்"
 #: dlls/comctl32/comctl32.rc:47 programs/progman/progman.rc:81
 msgctxt "hotkey"
 msgid "None"
-msgstr ""
+msgstr "இல்லை"
 
 #: dlls/comctl32/comctl32.rc:52 dlls/shell32/shell32.rc:307
 #: dlls/shlwapi/shlwapi.rc:46 dlls/user32/user32.rc:79
@@ -488,15 +512,15 @@ msgstr "இல்லை (&N)"
 
 #: dlls/comctl32/comctl32.rc:54 dlls/user32/user32.rc:82
 msgid "&Retry"
-msgstr ""
+msgstr "மீண்டும் முயற்சிக்கவும் (&R)"
 
 #: dlls/comctl32/comctl32.rc:62
 msgid "Hide details"
-msgstr ""
+msgstr "விவரங்களை மறைக்கவும்"
 
 #: dlls/comctl32/comctl32.rc:63
 msgid "See details"
-msgstr ""
+msgstr "விவரங்களைப் பார்க்கவும்"
 
 #: dlls/comctl32/comctl32.rc:31 dlls/cryptui/cryptui.rc:235
 #: programs/regedit/regedit.rc:291 programs/taskmgr/taskmgr.rc:434
@@ -511,7 +535,7 @@ msgstr "இன்று:"
 
 #: dlls/comctl32/comctl32.rc:37
 msgid "Go to today"
-msgstr ""
+msgstr "இன்றைக்குச் செல்லுங்கள்"
 
 #: dlls/comdlg32/comdlg32.rc:158 dlls/comdlg32/comdlg32.rc:171
 #: dlls/comdlg32/comdlg32.rc:462 dlls/comdlg32/comdlg32.rc:487
@@ -522,25 +546,25 @@ msgstr "திற"
 
 #: dlls/comdlg32/comdlg32.rc:161 dlls/comdlg32/comdlg32.rc:183
 msgid "File &Name:"
-msgstr ""
+msgstr "கோப்பு (&N) பெயர்:"
 
 #: dlls/comdlg32/comdlg32.rc:164 dlls/comdlg32/comdlg32.rc:186
 msgid "&Directories:"
-msgstr ""
+msgstr "அடைவுகள் (&D):"
 
 #: dlls/comdlg32/comdlg32.rc:167 dlls/comdlg32/comdlg32.rc:189
 msgid "List Files of &Type:"
-msgstr ""
+msgstr "(&T) வகை கோப்புகளின் பட்டியல்:"
 
 #: dlls/comdlg32/comdlg32.rc:169 dlls/comdlg32/comdlg32.rc:191
 msgid "Dri&ves:"
-msgstr ""
+msgstr "இயக்கிகள் (&v):"
 
 #: dlls/comdlg32/comdlg32.rc:174 dlls/comdlg32/comdlg32.rc:196
 #: dlls/shell32/shell32.rc:368 dlls/shell32/shell32.rc:405
 #: programs/winefile/winefile.rc:172
 msgid "&Read Only"
-msgstr ""
+msgstr "படிக்க மட்டும் (&R)"
 
 #: dlls/comdlg32/comdlg32.rc:180
 msgid "Save As..."
@@ -554,100 +578,101 @@ msgstr "இவ்வாறு சேமி"
 #: dlls/comdlg32/comdlg32.rc:358 dlls/comdlg32/comdlg32.rc:55
 #: dlls/hhctrl.ocx/hhctrl.rc:49 programs/wordpad/wordpad.rc:173
 msgid "Print"
-msgstr ""
+msgstr "அச்சிடுக"
 
 #: dlls/comdlg32/comdlg32.rc:205
 msgid "Printer:"
-msgstr ""
+msgstr "அச்சுப்பொறி:"
 
 #: dlls/comdlg32/comdlg32.rc:207 dlls/comdlg32/comdlg32.rc:375
 msgid "Print range"
-msgstr ""
+msgstr "அச்சு வரம்பு:"
 
 #: dlls/comdlg32/comdlg32.rc:208 dlls/comdlg32/comdlg32.rc:376
 #: programs/regedit/regedit.rc:273
 msgid "&All"
-msgstr ""
+msgstr "அனைத்தும் (&A)"
 
 #: dlls/comdlg32/comdlg32.rc:209
 msgid "S&election"
-msgstr ""
+msgstr "தேர்வு (&e)"
 
 #: dlls/comdlg32/comdlg32.rc:210
 msgid "&Pages"
-msgstr ""
+msgstr "பக்கங்கள் (&P)"
 
 #: dlls/comdlg32/comdlg32.rc:213 dlls/comdlg32/comdlg32.rc:235
 msgid "&Setup"
-msgstr ""
+msgstr "அமைவு (&S)"
 
 #: dlls/comdlg32/comdlg32.rc:214
 msgid "&From:"
-msgstr ""
+msgstr "இருந்து (&F):"
 
 #: dlls/comdlg32/comdlg32.rc:215
 msgid "&To:"
-msgstr ""
+msgstr "பெறுநர் (&T):"
 
 #: dlls/comdlg32/comdlg32.rc:216 dlls/wineps.drv/wineps.rc:42
 msgid "Print &Quality:"
-msgstr ""
+msgstr "அச்சு தரம் (&Q):"
 
 #: dlls/comdlg32/comdlg32.rc:218
 msgid "Print to Fi&le"
-msgstr ""
+msgstr "கோப்பிற்கு அச்சிடவும் (&l)"
 
 #: dlls/comdlg32/comdlg32.rc:219
 msgid "Condensed"
-msgstr ""
+msgstr "ஒடுங்கியது"
 
 #: dlls/comdlg32/comdlg32.rc:225 dlls/comdlg32/comdlg32.rc:397
 msgid "Print Setup"
-msgstr ""
+msgstr "அச்சு அமைப்பு"
 
 #: dlls/comdlg32/comdlg32.rc:228 dlls/comdlg32/comdlg32.rc:361
 #: dlls/comdlg32/comdlg32.rc:400
 msgid "Printer"
-msgstr ""
+msgstr "அச்சுப்பொறி"
 
 #: dlls/comdlg32/comdlg32.rc:229
 msgid "&Default Printer"
-msgstr ""
+msgstr "இயல்புநிலை அச்சுப்பொறி (&D)"
 
 #: dlls/comdlg32/comdlg32.rc:230
 msgid "[none]"
-msgstr ""
+msgstr "[எதுவுமில்லை]"
 
 #: dlls/comdlg32/comdlg32.rc:231
 msgid "Specific &Printer"
-msgstr ""
+msgstr "குறிப்பிட்ட அச்சுப்பொறி (&P)"
 
 #: dlls/comdlg32/comdlg32.rc:236 dlls/comdlg32/comdlg32.rc:419
 #: dlls/comdlg32/comdlg32.rc:443 dlls/wineps.drv/wineps.rc:34
 msgid "Orientation"
-msgstr ""
+msgstr "நோக்குநிலை"
 
 #: dlls/comdlg32/comdlg32.rc:237
+#, fuzzy
 msgid "Po&rtrait"
-msgstr ""
+msgstr "உருவப்படம் (&r)"
 
 #: dlls/comdlg32/comdlg32.rc:238 dlls/comdlg32/comdlg32.rc:445
 #: dlls/wineps.drv/wineps.rc:37
 msgid "&Landscape"
-msgstr ""
+msgstr "நிலப்பரப்பு (&L)"
 
 #: dlls/comdlg32/comdlg32.rc:241 dlls/comdlg32/comdlg32.rc:413
 #: dlls/comdlg32/comdlg32.rc:438 dlls/wineps.drv/wineps.rc:28
 msgid "Paper"
-msgstr ""
+msgstr "காகிதம்"
 
 #: dlls/comdlg32/comdlg32.rc:242
 msgid "Si&ze"
-msgstr ""
+msgstr "அளவு (&z)"
 
 #: dlls/comdlg32/comdlg32.rc:243
 msgid "&Source"
-msgstr ""
+msgstr "மூல (&S)"
 
 #: dlls/comdlg32/comdlg32.rc:251 programs/conhost/conhost.rc:76
 msgid "Font"
@@ -659,24 +684,25 @@ msgstr "எழுத்துரு (&F):"
 
 #: dlls/comdlg32/comdlg32.rc:257
 msgid "Font St&yle:"
-msgstr ""
+msgstr "எழுத்துரு வகை (&y):"
 
 #: dlls/comdlg32/comdlg32.rc:260 dlls/comdlg32/comdlg32.rc:439
 #: programs/winecfg/winecfg.rc:292
 msgid "&Size:"
-msgstr ""
+msgstr "அளவு (&S):"
 
 #: dlls/comdlg32/comdlg32.rc:267
+#, fuzzy
 msgid "Effects"
-msgstr ""
+msgstr "விளைவுகள்"
 
 #: dlls/comdlg32/comdlg32.rc:268
 msgid "Stri&keout"
-msgstr ""
+msgstr "வேலைநிறுத்தம் (&k)"
 
 #: dlls/comdlg32/comdlg32.rc:269
 msgid "&Underline"
-msgstr ""
+msgstr "அடிக்கோடு (&U)"
 
 #: dlls/comdlg32/comdlg32.rc:270 programs/winecfg/winecfg.rc:290
 msgid "&Color:"
@@ -684,11 +710,11 @@ msgstr "நிறம் (&C):"
 
 #: dlls/comdlg32/comdlg32.rc:273
 msgid "Sample"
-msgstr ""
+msgstr "மாதிரி"
 
 #: dlls/comdlg32/comdlg32.rc:275
 msgid "Scr&ipt:"
-msgstr ""
+msgstr "ஸ்கிரிப்ட் (&i):"
 
 #: dlls/comdlg32/comdlg32.rc:283 dlls/comdlg32/comdlg32.rc:288
 msgid "Color"
@@ -696,15 +722,15 @@ msgstr "நிறம்"
 
 #: dlls/comdlg32/comdlg32.rc:286
 msgid "&Basic Colors:"
-msgstr ""
+msgstr "அடிப்படை நிறங்கள் (&B):"
 
 #: dlls/comdlg32/comdlg32.rc:287
 msgid "&Custom Colors:"
-msgstr ""
+msgstr "பிரத்தியேக நிறங்கள் (&C):"
 
 #: dlls/comdlg32/comdlg32.rc:289
 msgid "|S&olid"
-msgstr ""
+msgstr "|திடமான (&o)"
 
 #: dlls/comdlg32/comdlg32.rc:290
 msgid "&Red:"
@@ -716,96 +742,95 @@ msgstr "பச்சை (&G):"
 
 #: dlls/comdlg32/comdlg32.rc:294
 msgid "&Blue:"
-msgstr "நீல (&B):"
+msgstr "நீலம் (&B):"
 
 #: dlls/comdlg32/comdlg32.rc:296
 msgid "&Hue:"
-msgstr ""
+msgstr "சாயல் (&H):"
 
 #: dlls/comdlg32/comdlg32.rc:298
+#, fuzzy
 msgctxt "Saturation"
 msgid "&Sat:"
-msgstr ""
+msgstr "செறிவூட்டல் (&S):"
 
 #: dlls/comdlg32/comdlg32.rc:300
 msgctxt "Luminance"
 msgid "&Lum:"
-msgstr ""
+msgstr "ஒளிர்வு (&L):"
 
 #: dlls/comdlg32/comdlg32.rc:310
 msgid "&Add to Custom Colors"
-msgstr ""
+msgstr "தனிப்பயன் வண்ணங்களில் சேர்க்கவும் (&A)"
 
 #: dlls/comdlg32/comdlg32.rc:311
 msgid "&Define Custom Colors >>"
-msgstr ""
+msgstr "தனிப்பயன் நிறங்களை வரையறுக்கவும் (&D) >>"
 
 #: dlls/comdlg32/comdlg32.rc:312
-#, fuzzy
-#| msgid "&No"
 msgctxt "Solid"
 msgid "&o"
-msgstr "இல்லை (&N)"
+msgstr "&o"
 
 #: dlls/comdlg32/comdlg32.rc:318 programs/regedit/regedit.rc:280
 #: programs/regedit/regedit.rc:290
 msgid "Find"
-msgstr ""
+msgstr "கண்டுபிடி"
 
 #: dlls/comdlg32/comdlg32.rc:321 dlls/comdlg32/comdlg32.rc:340
 msgid "Fi&nd What:"
-msgstr ""
+msgstr "எதைக் கண்டுபிடி (&n):"
 
 #: dlls/comdlg32/comdlg32.rc:323 dlls/comdlg32/comdlg32.rc:344
 msgid "Match &Whole Word Only"
-msgstr ""
+msgstr "முழு (&W) வார்த்தையை மட்டும் பொருத்தவும்"
 
 #: dlls/comdlg32/comdlg32.rc:324 dlls/comdlg32/comdlg32.rc:345
 msgid "Match &Case"
-msgstr ""
+msgstr "பொருத்தம் கேஸ் (&C)"
 
 #: dlls/comdlg32/comdlg32.rc:325
 msgid "Direction"
-msgstr ""
+msgstr "திசை"
 
 #: dlls/comdlg32/comdlg32.rc:326 programs/view/view.rc:42
 msgid "&Up"
-msgstr ""
+msgstr "மேலே (&U)"
 
 #: dlls/comdlg32/comdlg32.rc:327 programs/view/view.rc:43
 msgid "&Down"
-msgstr ""
+msgstr "கீழே (&D)"
 
 #: dlls/comdlg32/comdlg32.rc:329 dlls/comdlg32/comdlg32.rc:347
 msgid "&Find Next"
-msgstr ""
+msgstr "அடுத்ததை தேடு (&F)"
 
 #: dlls/comdlg32/comdlg32.rc:337
 msgid "Replace"
-msgstr ""
+msgstr "மாற்றவும்"
 
 #: dlls/comdlg32/comdlg32.rc:342
 msgid "Re&place With:"
-msgstr ""
+msgstr "இதனுடன் மாற்றவும் (&p):"
 
 #: dlls/comdlg32/comdlg32.rc:348
 msgid "&Replace"
-msgstr ""
+msgstr "மாற்றவும் (&R)"
 
 #: dlls/comdlg32/comdlg32.rc:349
 msgid "Replace &All"
-msgstr ""
+msgstr "அனைத்தையும் மாற்று (&A)"
 
 #: dlls/comdlg32/comdlg32.rc:363 dlls/comdlg32/comdlg32.rc:403
 #: dlls/ieframe/ieframe.rc:42 dlls/shdoclc/shdoclc.rc:61
 #: dlls/shell32/shell32.rc:108 programs/clock/clock.rc:31
 #: programs/conhost/conhost.rc:34
 msgid "&Properties"
-msgstr ""
+msgstr "பண்புகள் (&P)"
 
 #: dlls/comdlg32/comdlg32.rc:364
 msgid "Print to fi&le"
-msgstr ""
+msgstr "கோப்பிற்கு அச்சிடவும் (&l)"
 
 #: dlls/comdlg32/comdlg32.rc:365 dlls/comdlg32/comdlg32.rc:401
 #: dlls/msacm32/msacm32.rc:34 programs/winefile/winefile.rc:137
@@ -814,111 +839,112 @@ msgstr "பெயர் (&N):"
 
 #: dlls/comdlg32/comdlg32.rc:366 dlls/comdlg32/comdlg32.rc:404
 msgid "Status:"
-msgstr ""
+msgstr "நிலை:"
 
 #: dlls/comdlg32/comdlg32.rc:368 dlls/comdlg32/comdlg32.rc:406
 msgid "Type:"
-msgstr ""
+msgstr "வகை:"
 
 #: dlls/comdlg32/comdlg32.rc:370 dlls/comdlg32/comdlg32.rc:408
 msgid "Where:"
-msgstr ""
+msgstr "எங்கே:"
 
 #: dlls/comdlg32/comdlg32.rc:372 dlls/comdlg32/comdlg32.rc:410
 msgid "Comment:"
-msgstr ""
+msgstr "கருத்து:"
 
 #: dlls/comdlg32/comdlg32.rc:377
 msgid "Pa&ges"
-msgstr ""
+msgstr "பக்கங்கள் (&g)"
 
 #: dlls/comdlg32/comdlg32.rc:378
 msgid "&Selection"
-msgstr ""
+msgstr "தேர்வு (&S)"
 
 #: dlls/comdlg32/comdlg32.rc:381
 msgid "&from:"
-msgstr ""
+msgstr "இருந்து (&f):"
 
 #: dlls/comdlg32/comdlg32.rc:382
 msgid "&to:"
-msgstr ""
+msgstr "பெறுநர் (&t):"
 
 #: dlls/comdlg32/comdlg32.rc:384
 msgid "Copies"
-msgstr ""
+msgstr "பிரதிகள்"
 
 #: dlls/comdlg32/comdlg32.rc:385
 msgid "Number of &copies:"
-msgstr ""
+msgstr "பிரதிகளின் (&c) எண்ணிக்கை:"
 
 #: dlls/comdlg32/comdlg32.rc:387
+#, fuzzy
 msgid "C&ollate"
-msgstr ""
+msgstr "தொகுக்கவும் (&o)"
 
 #: dlls/comdlg32/comdlg32.rc:414 programs/winecfg/winecfg.rc:298
 msgid "Si&ze:"
-msgstr ""
+msgstr "அளவு (&z):"
 
 #: dlls/comdlg32/comdlg32.rc:416
 msgid "&Source:"
-msgstr ""
+msgstr "&மூல (&S):"
 
 #: dlls/comdlg32/comdlg32.rc:421
 msgid "P&ortrait"
-msgstr ""
+msgstr "உருவப்படம் (&o)"
 
 #: dlls/comdlg32/comdlg32.rc:422
 msgid "L&andscape"
-msgstr ""
+msgstr "நிலப்பரப்பு (&a)"
 
 #: dlls/comdlg32/comdlg32.rc:432
 msgid "Setup Page"
-msgstr ""
+msgstr "அமைவு பக்கம்"
 
 #: dlls/comdlg32/comdlg32.rc:441
 msgid "&Tray:"
-msgstr ""
+msgstr "தட்டு (&T):"
 
 #: dlls/comdlg32/comdlg32.rc:444 dlls/wineps.drv/wineps.rc:35
 msgid "&Portrait"
-msgstr ""
+msgstr "உருவப்படம் (&P)"
 
 #: dlls/comdlg32/comdlg32.rc:447
 msgid "L&eft:"
-msgstr ""
+msgstr "இடது (&e):"
 
 #: dlls/comdlg32/comdlg32.rc:449 programs/notepad/notepad.rc:119
 msgid "&Right:"
-msgstr ""
+msgstr "வலது (&R):"
 
 #: dlls/comdlg32/comdlg32.rc:451
 msgid "T&op:"
-msgstr ""
+msgstr "மேலே (&o):"
 
 #: dlls/comdlg32/comdlg32.rc:453 programs/notepad/notepad.rc:121
 msgid "&Bottom:"
-msgstr ""
+msgstr "கீழே (&B):"
 
 #: dlls/comdlg32/comdlg32.rc:457
 msgid "P&rinter..."
-msgstr ""
+msgstr "அச்சுப்பொறி(&r)..."
 
 #: dlls/comdlg32/comdlg32.rc:465 dlls/comdlg32/comdlg32.rc:490
 msgid "Look &in:"
-msgstr ""
+msgstr "பாருங்கள் (&i):"
 
 #: dlls/comdlg32/comdlg32.rc:471 dlls/comdlg32/comdlg32.rc:497
 msgid "File &name:"
-msgstr ""
+msgstr "கோப்பு பெயர் (&n):"
 
 #: dlls/comdlg32/comdlg32.rc:475 dlls/comdlg32/comdlg32.rc:501
 msgid "Files of &type:"
-msgstr ""
+msgstr "(&t) வகை கோப்புகள்:"
 
 #: dlls/comdlg32/comdlg32.rc:478 dlls/comdlg32/comdlg32.rc:504
 msgid "Open as &read-only"
-msgstr ""
+msgstr "படிக்க-மட்டுமே (&r) எனத் திறக்கவும்"
 
 #: dlls/comdlg32/comdlg32.rc:480 dlls/comdlg32/comdlg32.rc:506
 #: dlls/comdlg32/comdlg32.rc:524 dlls/shdoclc/shdoclc.rc:127
@@ -928,89 +954,95 @@ msgstr "திற (&O)"
 
 #: dlls/comdlg32/comdlg32.rc:517
 msgid "File name:"
-msgstr ""
+msgstr "கோப்பு பெயர்:"
 
 #: dlls/comdlg32/comdlg32.rc:520
 msgid "Files of type:"
-msgstr ""
+msgstr "வகையின் கோப்புக்கள்:"
 
 #: dlls/comdlg32/comdlg32.rc:33 dlls/vbscript/vbscript.rc:35
 msgid "File not found"
-msgstr ""
+msgstr "கோப்பு கிடைக்கவில்லை"
 
 #: dlls/comdlg32/comdlg32.rc:34
 msgid "Please verify that the correct file name was given"
-msgstr ""
+msgstr "சரியான கோப்பு பெயர் கொடுக்கப்பட்டுள்ளதா என்பதை சரிபார்க்கவும்"
 
 #: dlls/comdlg32/comdlg32.rc:35
 msgid ""
 "File does not exist.\n"
 "Do you want to create file?"
 msgstr ""
+"கோப்பு எதுவும் இல்லை\n"
+"கோப்பை உருவாக்க விரும்புகிறீர்களா?"
 
 #: dlls/comdlg32/comdlg32.rc:36
 msgid ""
 "File already exists.\n"
 "Do you want to replace it?"
 msgstr ""
+"கோப்பு ஏற்கனவே உள்ளது.\n"
+"நீங்கள் அதை மாற்ற விரும்புகிறீர்களா?"
 
 #: dlls/comdlg32/comdlg32.rc:37
 msgid "Invalid character(s) in path"
-msgstr ""
+msgstr "பாதையில் தவறான எழுத்து(கள்)."
 
 #: dlls/comdlg32/comdlg32.rc:38
 msgid ""
 "A filename cannot contain any of the following characters:\n"
 "                          / : < > |"
 msgstr ""
+"ஒரு கோப்புப் பெயரில் பின்வரும் எழுத்துக்கள் எதுவும் இருக்கக்கூடாது:\n"
+"                           / : < > |"
 
 #: dlls/comdlg32/comdlg32.rc:39
 msgid "Path does not exist"
-msgstr ""
+msgstr "பாதை இல்லை"
 
 #: dlls/comdlg32/comdlg32.rc:40
 msgid "File does not exist"
-msgstr ""
+msgstr "கோப்பு இல்லை"
 
 #: dlls/comdlg32/comdlg32.rc:41
 msgid "The selection contains a non-folder object"
-msgstr ""
+msgstr "தேர்வில் கோப்புறை அல்லாத பொருள் உள்ளது"
 
 #: dlls/comdlg32/comdlg32.rc:46
 msgid "Up One Level"
-msgstr ""
+msgstr "ஒரு நிலை வரை"
 
 #: dlls/comdlg32/comdlg32.rc:47
 msgid "Create New Folder"
-msgstr ""
+msgstr "புதிய கோப்புறையை உருவாக்கவும்"
 
 #: dlls/comdlg32/comdlg32.rc:48
 msgid "List"
-msgstr ""
+msgstr "பட்டியல்"
 
 #: dlls/comdlg32/comdlg32.rc:49 dlls/cryptui/cryptui.rc:201
 msgid "Details"
-msgstr ""
+msgstr "விவரங்கள்"
 
 #: dlls/comdlg32/comdlg32.rc:50
 msgid "Browse to Desktop"
-msgstr ""
+msgstr "டெஸ்க்டாப்பில் உலாவவும்"
 
 #: dlls/comdlg32/comdlg32.rc:114
 msgid "Regular"
-msgstr ""
+msgstr "வழக்கமான"
 
 #: dlls/comdlg32/comdlg32.rc:115
 msgid "Bold"
-msgstr ""
+msgstr "தடித்த"
 
 #: dlls/comdlg32/comdlg32.rc:116
 msgid "Italic"
-msgstr ""
+msgstr "சாய்வு"
 
 #: dlls/comdlg32/comdlg32.rc:117
 msgid "Bold Italic"
-msgstr ""
+msgstr "தடித்த சாய்வு"
 
 #: dlls/comdlg32/comdlg32.rc:122 programs/wordpad/wordpad.rc:125
 msgid "Black"
@@ -1079,67 +1111,76 @@ msgstr "வெள்ளை"
 
 #: dlls/comdlg32/comdlg32.rc:57
 msgid "Unreadable Entry"
-msgstr ""
+msgstr "படிக்க முடியாத பதிவு"
 
 #: dlls/comdlg32/comdlg32.rc:59
 msgid ""
 "This value does not lie within the page range.\n"
 "Please enter a value between %1!d! and %2!d!."
 msgstr ""
+"இந்த மதிப்பு பக்க வரம்பிற்குள் இல்லை.\n"
+"% 1!d க்கு இடையில் மதிப்பை உள்ளிடவும்! மற்றும் %2!d!."
 
 #: dlls/comdlg32/comdlg32.rc:61
+#, fuzzy
 msgid "The 'from' entry cannot exceed the 'to' entry."
-msgstr ""
+msgstr "'இருந்து' உள்ளீடு 'வரை' உள்ளீட்டை விட அதிகமாக இருக்கக்கூடாது."
 
 #: dlls/comdlg32/comdlg32.rc:63
 msgid ""
 "Margins overlap or fall outside Paper boundaries.\n"
 "Please reenter margins."
 msgstr ""
+"விளிம்புகள் ஒன்றுடன் ஒன்று அல்லது காகித எல்லைகளுக்கு வெளியே விழும்.\n"
+"விளிம்புகளை மீண்டும் உள்ளிடவும்."
 
 #: dlls/comdlg32/comdlg32.rc:65
 msgid "The 'Number of copies' field cannot be empty."
-msgstr ""
+msgstr "'நகல்களின் எண்ணிக்கை' புலம் காலியாக இருக்கக்கூடாது."
 
 #: dlls/comdlg32/comdlg32.rc:67
 msgid ""
 "This large number of copies is not supported by your printer.\n"
 "Please enter a value between 1 and %d."
 msgstr ""
+"இந்த அதிக எண்ணிக்கையிலான நகல்களை உங்கள் அச்சுப்பொறி ஆதரிக்கவில்லை.\n"
+"1 மற்றும் %d இடையே உள்ள மதிப்பை உள்ளிடவும்."
 
 #: dlls/comdlg32/comdlg32.rc:68
 msgid "A printer error occurred."
-msgstr ""
+msgstr "அச்சுப்பொறி பிழை ஏற்பட்டது."
 
 #: dlls/comdlg32/comdlg32.rc:69
 msgid "No default printer defined."
-msgstr ""
+msgstr "இயல்புநிலை அச்சுப்பொறி வரையறுக்கப்படவில்லை."
 
 #: dlls/comdlg32/comdlg32.rc:70
 msgid "Cannot find the printer."
-msgstr ""
+msgstr "அச்சுப்பொறியைக் கண்டறிய முடியவில்லை."
 
 #: dlls/comdlg32/comdlg32.rc:71 programs/progman/progman.rc:76
 msgid "Out of memory."
-msgstr ""
+msgstr "நினைவகம் இல்லை."
 
 #: dlls/comdlg32/comdlg32.rc:72
 msgid "An error occurred."
-msgstr ""
+msgstr "பிழை ஏற்பட்டது."
 
 #: dlls/comdlg32/comdlg32.rc:73
 msgid "Unknown printer driver."
-msgstr ""
+msgstr "தெரியாத அச்சுப்பொறி இயக்கி."
 
 #: dlls/comdlg32/comdlg32.rc:76
 msgid ""
 "Before you can perform printer-related tasks such as page setup or printing "
 "a document, you need to install a printer. Please install one and retry."
 msgstr ""
+"பக்க அமைவு அல்லது ஆவணத்தை அச்சிடுதல் போன்ற அச்சுப்பொறி தொடர்பான பணிகளைச் செய்வதற்கு முன், "
+"நீங்கள் ஒரு பிரிண்டரை நிறுவ வேண்டும். ஒன்றை நிறுவி மீண்டும் முயற்சிக்கவும்."
 
 #: dlls/comdlg32/comdlg32.rc:142
 msgid "Select a font size between %1!d! and %2!d! points."
-msgstr ""
+msgstr "%1!d! மற்றும் %2!d! புள்ளிகளுக்கு இடைப்பட்ட எழுத்துரு அளவைத் தேர்ந்தெடுக்கவும்!."
 
 #: dlls/comdlg32/comdlg32.rc:143 dlls/ieframe/ieframe.rc:35
 msgid "&Save"
@@ -1147,7 +1188,7 @@ msgstr "சேமி (&S)"
 
 #: dlls/comdlg32/comdlg32.rc:144
 msgid "Save &in:"
-msgstr ""
+msgstr "இதில் (&i) சேமி:"
 
 #: dlls/comdlg32/comdlg32.rc:145
 msgid "Save"
@@ -1155,23 +1196,23 @@ msgstr "சேமி"
 
 #: dlls/comdlg32/comdlg32.rc:147
 msgid "Open File"
-msgstr ""
+msgstr "கோப்பைத் திறக்கவும்"
 
 #: dlls/comdlg32/comdlg32.rc:148
 msgid "Select Folder"
-msgstr ""
+msgstr "கோப்புறையைத் தேர்ந்தெடுக்கவும்"
 
 #: dlls/comdlg32/comdlg32.rc:149
 msgid "Font size has to be a number."
-msgstr ""
+msgstr "எழுத்துரு அளவு ஒரு எண்ணாக இருக்க வேண்டும்."
 
 #: dlls/comdlg32/comdlg32.rc:84 programs/oleview/oleview.rc:98
 msgid "Ready"
-msgstr ""
+msgstr "தயார்"
 
 #: dlls/comdlg32/comdlg32.rc:85
 msgid "Paused; "
-msgstr ""
+msgstr "இடைநிறுத்தப்பட்டது; "
 
 #: dlls/comdlg32/comdlg32.rc:86
 msgid "Error; "
@@ -1179,160 +1220,163 @@ msgstr "பிழை; "
 
 #: dlls/comdlg32/comdlg32.rc:87
 msgid "Pending deletion; "
-msgstr ""
+msgstr "நிலுவையில் உள்ள நீக்கம்; "
 
 #: dlls/comdlg32/comdlg32.rc:88
 msgid "Paper jam; "
-msgstr ""
+msgstr "காகித ஜாம்; "
 
 #: dlls/comdlg32/comdlg32.rc:89
 msgid "Out of paper; "
-msgstr ""
+msgstr "அச்சுத்தாள் தீர்ந்து விட்டது; "
 
 #: dlls/comdlg32/comdlg32.rc:90
 msgid "Feed paper manual; "
-msgstr ""
+msgstr "காகிதத்தை கைமுறையாக ஊட்டவும்; "
 
 #: dlls/comdlg32/comdlg32.rc:91
 msgid "Paper problem; "
-msgstr ""
+msgstr "காகித பிரச்சனை; "
 
 #: dlls/comdlg32/comdlg32.rc:92
 msgid "Printer offline; "
-msgstr ""
+msgstr "அச்சுப்பொறி ஆஃப்லைன்;"
 
 #: dlls/comdlg32/comdlg32.rc:93
 msgid "I/O Active; "
-msgstr ""
+msgstr "I/O செயலில்; "
 
 #: dlls/comdlg32/comdlg32.rc:94
+#, fuzzy
 msgid "Busy; "
-msgstr ""
+msgstr "பரபரப்பு; "
 
 #: dlls/comdlg32/comdlg32.rc:95
 msgid "Printing; "
-msgstr ""
+msgstr "அச்சிடுதல்; "
 
 #: dlls/comdlg32/comdlg32.rc:96
 msgid "Output tray is full; "
-msgstr ""
+msgstr "வெளியீட்டு தட்டு நிரம்பியுள்ளது; "
 
 #: dlls/comdlg32/comdlg32.rc:97
 msgid "Not available; "
-msgstr ""
+msgstr "கிடைக்கவில்லை; "
 
 #: dlls/comdlg32/comdlg32.rc:98
 msgid "Waiting; "
-msgstr ""
+msgstr "காத்திருக்கிறது; "
 
 #: dlls/comdlg32/comdlg32.rc:99
 msgid "Processing; "
-msgstr ""
+msgstr "செயலாக்குகிறது; "
 
 #: dlls/comdlg32/comdlg32.rc:100
 msgid "Initializing; "
-msgstr ""
+msgstr "துவக்குகிறது; "
 
 #: dlls/comdlg32/comdlg32.rc:101
 msgid "Warming up; "
-msgstr ""
+msgstr "வெப்பமடைகிறது; "
 
 #: dlls/comdlg32/comdlg32.rc:102
 msgid "Toner low; "
-msgstr ""
+msgstr "டோனர் குறைவாக உள்ளது;  "
 
 #: dlls/comdlg32/comdlg32.rc:103
 msgid "No toner; "
-msgstr ""
+msgstr "டோனர் இல்லை;"
 
 #: dlls/comdlg32/comdlg32.rc:104
 msgid "Page punt; "
-msgstr ""
+msgstr "பக்கம் பண்ட்; "
 
 #: dlls/comdlg32/comdlg32.rc:105
 msgid "Interrupted by user; "
-msgstr ""
+msgstr "பயனரால் குறுக்கிடப்பட்டது; "
 
 #: dlls/comdlg32/comdlg32.rc:106
 msgid "Out of memory; "
-msgstr ""
+msgstr "நினைவகம் இல்லை; "
 
 #: dlls/comdlg32/comdlg32.rc:107
 msgid "The printer door is open; "
-msgstr ""
+msgstr "அச்சுப்பொறி கதவு திறந்திருக்கிறது; "
 
 #: dlls/comdlg32/comdlg32.rc:108
 msgid "Print server unknown; "
-msgstr ""
+msgstr "அச்சு சேவையகம் தெரியவில்லை; "
 
 #: dlls/comdlg32/comdlg32.rc:109
 msgid "Power save mode; "
-msgstr ""
+msgstr "மின்ஆற்றல் சேமிப்பு நிலை; "
 
 #: dlls/comdlg32/comdlg32.rc:78
 msgid "Default Printer; "
-msgstr ""
+msgstr "இயல்புநிலை அச்சுப்பொறி; "
 
 #: dlls/comdlg32/comdlg32.rc:79
 msgid "There are %d documents in the queue"
-msgstr ""
+msgstr "வரிசையில் %d ஆவணங்கள் உள்ளன"
 
 #: dlls/comdlg32/comdlg32.rc:80
 msgid "Margins [inches]"
-msgstr ""
+msgstr "விளிம்புகள் [அங்குலங்கள்]"
 
 #: dlls/comdlg32/comdlg32.rc:81
 msgid "Margins [mm]"
-msgstr ""
+msgstr "விளிம்புகள் [மில்லிமீட்டர்]"
 
 #: dlls/comdlg32/comdlg32.rc:82 dlls/sane.ds/sane.rc:33
 msgctxt "unit: millimeters"
 msgid "mm"
-msgstr ""
+msgstr "மில்லிமீட்டர்"
 
 #: dlls/compstui/compstui.rc:29 dlls/shell32/shell32.rc:74
 msgid "Properties"
-msgstr ""
+msgstr "பண்புகள்"
 
 #: dlls/compstui/compstui.rc:30 dlls/hhctrl.ocx/hhctrl.rc:50
 #: programs/conhost/conhost.rc:51 programs/wordpad/wordpad.rc:166
 msgid "Options"
-msgstr ""
+msgstr "விருப்பங்கள்"
 
 #: dlls/compstui/compstui.rc:31
 msgid "Default"
-msgstr ""
+msgstr "இயல்புநிலை"
 
 #: dlls/credui/credui.rc:45
 msgid "&User name:"
-msgstr ""
+msgstr "பயனர் பெயர் (&U):"
 
 #: dlls/credui/credui.rc:48 dlls/cryptui/cryptui.rc:402
 #: dlls/oledb32/version.rc:81
 msgid "&Password:"
-msgstr ""
+msgstr "கடவுச்சொல் (&P):"
 
 #: dlls/credui/credui.rc:50
 msgid "&Remember my password"
-msgstr ""
+msgstr "எனது கடவுச்சொல்லை (&R) நினைவில் கொள்க"
 
 #: dlls/credui/credui.rc:30
 msgid "Connect to %s"
-msgstr ""
+msgstr "%s உடன் இணைக்கவும்"
 
 #: dlls/credui/credui.rc:31
 msgid "Connecting to %s"
-msgstr ""
+msgstr "%s உடன் இணைக்கிறது"
 
 #: dlls/credui/credui.rc:32
 msgid "Logon unsuccessful"
-msgstr ""
+msgstr "உள்நுழைவு தோல்வியடைந்தது"
 
 #: dlls/credui/credui.rc:33
 msgid ""
 "Make sure that your user name\n"
 "and password are correct."
 msgstr ""
+"உறுதிப்படுத்தவும் உங்கள் பயனர்பெயர் \n"
+"மற்றும் கடவுச்சொல் சரியாக உள்ளதா என்பதை."
 
 #: dlls/credui/credui.rc:35
 msgid ""
@@ -1341,227 +1385,231 @@ msgid ""
 "Press the Caps Lock key on your keyboard to turn off Caps Lock before\n"
 "entering your password."
 msgstr ""
+"Caps Lock ஆன் செய்யப்பட்டிருந்தால், உங்கள் கடவுச்சொல்லை தவறாக உள்ளிடலாம்.\n"
+"\n"
+"Caps Lock கை ஆஃப் செய்ய உங்கள் விசைப்பலகையில் உள்ள Caps Lock கீயை அழுத்தவும்\n"
+"உங்கள் கடவுச்சொல்லை உள்ளிடுவதற்கு முன்."
 
 #: dlls/credui/credui.rc:34
 msgid "Caps Lock is On"
-msgstr ""
+msgstr "Caps Lock இயக்கத்தில் உள்ளது"
 
 #: dlls/crypt32/crypt32.rc:30
 msgid "Authority Key Identifier"
-msgstr ""
+msgstr "அதிகாரச் சாவி அடையாளங்காட்டி"
 
 #: dlls/crypt32/crypt32.rc:31
 msgid "Key Attributes"
-msgstr ""
+msgstr "சாவி பண்புக்கூறுகள்"
 
 #: dlls/crypt32/crypt32.rc:32
 msgid "Key Usage Restriction"
-msgstr ""
+msgstr "சாவி பயன்பாட்டு கட்டுப்பாடு"
 
 #: dlls/crypt32/crypt32.rc:33
 msgid "Subject Alternative Name"
-msgstr ""
+msgstr "பொருள் மாற்று பெயர்"
 
 #: dlls/crypt32/crypt32.rc:34
 msgid "Issuer Alternative Name"
-msgstr ""
+msgstr "வழங்குபவரின் மாற்று பெயர்"
 
 #: dlls/crypt32/crypt32.rc:35
 msgid "Basic Constraints"
-msgstr ""
+msgstr "அடிப்படை கட்டுப்பாடுகள்"
 
 #: dlls/crypt32/crypt32.rc:36
 msgid "Key Usage"
-msgstr ""
+msgstr "சாவி பயன்பாடு"
 
 #: dlls/crypt32/crypt32.rc:37
 msgid "Certificate Policies"
-msgstr ""
+msgstr "சான்றிதழ் கொள்கைகள்"
 
 #: dlls/crypt32/crypt32.rc:38
 msgid "Subject Key Identifier"
-msgstr ""
+msgstr "பொருள் விசை அடையாளங்காட்டி"
 
 #: dlls/crypt32/crypt32.rc:39
 msgid "CRL Reason Code"
-msgstr ""
+msgstr "CRL காரணக் குறியீடு"
 
 #: dlls/crypt32/crypt32.rc:40
 msgid "CRL Distribution Points"
-msgstr ""
+msgstr "CRL விநியோக புள்ளிகள்"
 
 #: dlls/crypt32/crypt32.rc:41
 msgid "Enhanced Key Usage"
-msgstr ""
+msgstr "மேம்படுத்தப்பட்ட முக்கிய பயன்பாடு"
 
 #: dlls/crypt32/crypt32.rc:42
 msgid "Authority Information Access"
-msgstr ""
+msgstr "அதிகாரசபை தகவல் அணுகல்"
 
 #: dlls/crypt32/crypt32.rc:43
 msgid "Certificate Extensions"
-msgstr ""
+msgstr "சான்றிதழ் நீட்டிப்புகள்"
 
 #: dlls/crypt32/crypt32.rc:44
 msgid "Next Update Location"
-msgstr ""
+msgstr "அடுத்த புதுப்பிப்பு இருப்பிடம்"
 
 #: dlls/crypt32/crypt32.rc:45
 msgid "Yes or No Trust"
-msgstr ""
+msgstr "ஆம் அல்லது இல்லை நம்பிக்கை"
 
 #: dlls/crypt32/crypt32.rc:46
 msgid "Email Address"
-msgstr ""
+msgstr "மின்னஞ்சல் முகவரி"
 
 #: dlls/crypt32/crypt32.rc:47
 msgid "Unstructured Name"
-msgstr ""
+msgstr "கட்டமைக்கப்படாத பெயர்"
 
 #: dlls/crypt32/crypt32.rc:48
 msgid "Content Type"
-msgstr ""
+msgstr "உள்ளடக்க வகை"
 
 #: dlls/crypt32/crypt32.rc:49
 msgid "Message Digest"
-msgstr ""
+msgstr "செய்தி டிஜஸ்ட்"
 
 #: dlls/crypt32/crypt32.rc:50
 msgid "Signing Time"
-msgstr ""
+msgstr "கையொப்பமிடும் நேரம்"
 
 #: dlls/crypt32/crypt32.rc:51
 msgid "Counter Sign"
-msgstr ""
+msgstr "எதிர் கையெழுத்து"
 
 #: dlls/crypt32/crypt32.rc:52
 msgid "Challenge Password"
-msgstr ""
+msgstr "சவால் கடவுச்சொல்"
 
 #: dlls/crypt32/crypt32.rc:53
 msgid "Unstructured Address"
-msgstr ""
+msgstr "கட்டமைக்கப்படாத முகவரி"
 
 #: dlls/crypt32/crypt32.rc:54
 msgid "S/MIME Capabilities"
-msgstr ""
+msgstr "S/MIME திறன்கள்"
 
 #: dlls/crypt32/crypt32.rc:55
 msgid "Prefer Signed Data"
-msgstr ""
+msgstr "கையொப்பமிடப்பட்ட தரவை விரும்பு"
 
 #: dlls/crypt32/crypt32.rc:56 dlls/cryptdlg/cryptdlg.rc:34
 msgctxt "Certification Practice Statement"
 msgid "CPS"
-msgstr ""
+msgstr "CPS (சிபிஎஸ்)"
 
 #: dlls/crypt32/crypt32.rc:57 dlls/cryptdlg/cryptdlg.rc:35
 msgid "User Notice"
-msgstr ""
+msgstr "பயனர் அறிவிப்பு"
 
 #: dlls/crypt32/crypt32.rc:58
 msgid "On-line Certificate Status Protocol"
-msgstr ""
+msgstr "ஆன்-லைன் சான்றிதழ் நிலை நெறிமுறை"
 
 #: dlls/crypt32/crypt32.rc:59
 msgid "Certification Authority Issuer"
-msgstr ""
+msgstr "சான்றிதழ் ஆணையம் வழங்குபவர்"
 
 #: dlls/crypt32/crypt32.rc:60
 msgid "Certification Template Name"
-msgstr ""
+msgstr "சான்றிதழ் டெம்ப்ளேட் பெயர்"
 
 #: dlls/crypt32/crypt32.rc:61
 msgid "Certificate Type"
-msgstr ""
+msgstr "சான்றிதழ் வகை"
 
 #: dlls/crypt32/crypt32.rc:62
 msgid "Certificate Manifold"
-msgstr ""
+msgstr "சான்றிதழ் பன்மடங்கு"
 
 #: dlls/crypt32/crypt32.rc:63
 msgid "Netscape Cert Type"
-msgstr ""
+msgstr "நெட்ஸ்கேப் சான்றிதழ் வகை"
 
 #: dlls/crypt32/crypt32.rc:64
 msgid "Netscape Base URL"
-msgstr ""
+msgstr "நெட்ஸ்கேப் அடிப்படை URL"
 
 #: dlls/crypt32/crypt32.rc:65
 msgid "Netscape Revocation URL"
-msgstr ""
+msgstr "நெட்ஸ்கேப் திரும்பப்பெறுதல் URL"
 
 #: dlls/crypt32/crypt32.rc:66
 msgid "Netscape CA Revocation URL"
-msgstr ""
+msgstr "Netscape CA திரும்பப்பெறுதல் URL"
 
 #: dlls/crypt32/crypt32.rc:67
 msgid "Netscape Cert Renewal URL"
-msgstr ""
+msgstr "நெட்ஸ்கேப் சான்றிதழின் புதுப்பித்தல் URL"
 
 #: dlls/crypt32/crypt32.rc:68
 msgid "Netscape CA Policy URL"
-msgstr ""
+msgstr "நெட்ஸ்கேப் CA கொள்கை URL"
 
 #: dlls/crypt32/crypt32.rc:69
 msgid "Netscape SSL ServerName"
-msgstr ""
+msgstr "நெட்ஸ்கேப் SSL சர்வர் பெயர்"
 
 #: dlls/crypt32/crypt32.rc:70
 msgid "Netscape Comment"
-msgstr ""
+msgstr "நெட்ஸ்கேப் கருத்து"
 
 #: dlls/crypt32/crypt32.rc:71
 msgid "Country/Region"
-msgstr ""
+msgstr "நாடு/பிராந்தியம்"
 
 #: dlls/crypt32/crypt32.rc:72
 msgid "Organization"
-msgstr ""
+msgstr "அமைப்பு/நிறுவனம்"
 
 #: dlls/crypt32/crypt32.rc:73
 msgid "Organizational Unit"
-msgstr ""
+msgstr "நிறுவன அலகு"
 
 #: dlls/crypt32/crypt32.rc:74
 msgid "Common Name"
-msgstr ""
+msgstr "பொது பெயர்"
 
 #: dlls/crypt32/crypt32.rc:75
 msgid "Locality"
-msgstr ""
+msgstr "உள்ளூர்"
 
 #: dlls/crypt32/crypt32.rc:76
 msgid "State or Province"
-msgstr ""
+msgstr "மாநிலம் அல்லது பிராந்தியம்"
 
 #: dlls/crypt32/crypt32.rc:77
 msgid "Title"
-msgstr ""
+msgstr "தலைப்பு"
 
 #: dlls/crypt32/crypt32.rc:78
 msgid "Given Name"
-msgstr ""
+msgstr "கொடுக்கப்பட்ட பெயர்"
 
 #: dlls/crypt32/crypt32.rc:79
 msgid "Initials"
-msgstr ""
+msgstr "முதலெழுத்துக்கள்"
 
 #: dlls/crypt32/crypt32.rc:80
 msgid "Surname"
-msgstr ""
+msgstr "இயற்பெயர்"
 
 #: dlls/crypt32/crypt32.rc:81
 msgid "Domain Component"
-msgstr ""
+msgstr "டொமைன் கூறு"
 
 #: dlls/crypt32/crypt32.rc:82
 msgid "Street Address"
-msgstr ""
+msgstr "தெரு முகவரி"
 
 #: dlls/crypt32/crypt32.rc:83
 msgid "Serial Number"
-msgstr ""
+msgstr "வரிசை எண்"
 
 #: dlls/crypt32/crypt32.rc:84
 msgid "CA Version"
@@ -1569,195 +1617,195 @@ msgstr "CA பதிப்பு"
 
 #: dlls/crypt32/crypt32.rc:85
 msgid "Cross CA Version"
-msgstr ""
+msgstr "குறுக்கு CA பதிப்பு"
 
 #: dlls/crypt32/crypt32.rc:86
 msgid "Serialized Signature Serial Number"
-msgstr ""
+msgstr "வரிசைப்படுத்தப்பட்ட கையொப்ப வரிசை எண்"
 
 #: dlls/crypt32/crypt32.rc:87
 msgid "Principal Name"
-msgstr ""
+msgstr "முதன்மை பெயர்"
 
 #: dlls/crypt32/crypt32.rc:88
 msgid "Windows Product Update"
-msgstr ""
+msgstr "விண்டோஸ் தயாரிப்பு புதுப்பிப்பு"
 
 #: dlls/crypt32/crypt32.rc:89
 msgid "Enrollment Name Value Pair"
-msgstr ""
+msgstr "பதிவு பெயர் மதிப்பு ஜோடி"
 
 #: dlls/crypt32/crypt32.rc:90
 msgid "OS Version"
-msgstr ""
+msgstr "OS பதிப்பு"
 
 #: dlls/crypt32/crypt32.rc:91
 msgid "Enrollment CSP"
-msgstr ""
+msgstr "பதிவு CSP"
 
 #: dlls/crypt32/crypt32.rc:92
 msgid "CRL Number"
-msgstr ""
+msgstr "CRL எண்"
 
 #: dlls/crypt32/crypt32.rc:93
 msgid "Delta CRL Indicator"
-msgstr ""
+msgstr "டெல்டா CRL காட்டி"
 
 #: dlls/crypt32/crypt32.rc:94
 msgid "Issuing Distribution Point"
-msgstr ""
+msgstr "விநியோக புள்ளியை வழங்குதல்"
 
 #: dlls/crypt32/crypt32.rc:95
 msgid "Freshest CRL"
-msgstr ""
+msgstr "புதிதான CRL"
 
 #: dlls/crypt32/crypt32.rc:96
 msgid "Name Constraints"
-msgstr ""
+msgstr "பெயர் கட்டுப்பாடுகள்"
 
 #: dlls/crypt32/crypt32.rc:97
 msgid "Policy Mappings"
-msgstr ""
+msgstr "கொள்கை வரைபடங்கள்"
 
 #: dlls/crypt32/crypt32.rc:98
 msgid "Policy Constraints"
-msgstr ""
+msgstr "கொள்கைக் கட்டுப்பாடுகள்"
 
 #: dlls/crypt32/crypt32.rc:99
 msgid "Cross-Certificate Distribution Points"
-msgstr ""
+msgstr "குறுக்கு-சான்றிதழ் விநியோக புள்ளிகள்"
 
 #: dlls/crypt32/crypt32.rc:100
 msgid "Application Policies"
-msgstr ""
+msgstr "பயன்பாட்டுக் கொள்கைகள்"
 
 #: dlls/crypt32/crypt32.rc:101
 msgid "Application Policy Mappings"
-msgstr ""
+msgstr "பயன்பாட்டுக் கொள்கை வரைபடங்கள்"
 
 #: dlls/crypt32/crypt32.rc:102
 msgid "Application Policy Constraints"
-msgstr ""
+msgstr "பயன்பாட்டுக் கொள்கைக் கட்டுப்பாடுகள்"
 
 #: dlls/crypt32/crypt32.rc:103
 msgid "CMC Data"
-msgstr ""
+msgstr "CMC தரவு"
 
 #: dlls/crypt32/crypt32.rc:104
 msgid "CMC Response"
-msgstr ""
+msgstr "CMC பதில்"
 
 #: dlls/crypt32/crypt32.rc:105
 msgid "Unsigned CMC Request"
-msgstr ""
+msgstr "கையொப்பமிடாத CMC கோரிக்கை"
 
 #: dlls/crypt32/crypt32.rc:106
 msgid "CMC Status Info"
-msgstr ""
+msgstr "CMC நிலை தகவல்"
 
 #: dlls/crypt32/crypt32.rc:107
 msgid "CMC Extensions"
-msgstr ""
+msgstr "CMC நீட்டிப்புகள்"
 
 #: dlls/crypt32/crypt32.rc:108
 msgid "CMC Attributes"
-msgstr ""
+msgstr "CMC பண்புக்கூறுகள்"
 
 #: dlls/crypt32/crypt32.rc:109
 msgid "PKCS 7 Data"
-msgstr ""
+msgstr "PKCS 7 தரவு"
 
 #: dlls/crypt32/crypt32.rc:110
 msgid "PKCS 7 Signed"
-msgstr ""
+msgstr "PKCS 7 கையொப்பமிடப்பட்டது"
 
 #: dlls/crypt32/crypt32.rc:111
 msgid "PKCS 7 Enveloped"
-msgstr ""
+msgstr "PKCS 7 உறையிடப்பட்டது"
 
 #: dlls/crypt32/crypt32.rc:112
 msgid "PKCS 7 Signed Enveloped"
-msgstr ""
+msgstr "PKCS 7 கையொப்பமிடப்பட்டு உறையிடப்பட்டது"
 
 #: dlls/crypt32/crypt32.rc:113
 msgid "PKCS 7 Digested"
-msgstr ""
+msgstr "PKCS 7 செரிக்கப்பட்டது"
 
 #: dlls/crypt32/crypt32.rc:114
 msgid "PKCS 7 Encrypted"
-msgstr ""
+msgstr "PKCS 7 குறியாக்கம் செய்யப்பட்டது"
 
 #: dlls/crypt32/crypt32.rc:115
 msgid "Previous CA Certificate Hash"
-msgstr ""
+msgstr "முந்தைய CA சான்றிதழ் ஹாஷ்"
 
 #: dlls/crypt32/crypt32.rc:116
 msgid "Virtual Base CRL Number"
-msgstr ""
+msgstr "மெய்நிகர் அடிப்படை CRL எண்"
 
 #: dlls/crypt32/crypt32.rc:117
 msgid "Next CRL Publish"
-msgstr ""
+msgstr "அடுத்த CRL வெளியீடு"
 
 #: dlls/crypt32/crypt32.rc:118
 msgid "CA Encryption Certificate"
-msgstr ""
+msgstr "CA குறியாக்கச் சான்றிதழ்"
 
 #: dlls/crypt32/crypt32.rc:119 dlls/cryptui/cryptui.rc:148
 msgid "Key Recovery Agent"
-msgstr ""
+msgstr "விசை மீட்பு முகவர்"
 
 #: dlls/crypt32/crypt32.rc:120
 msgid "Certificate Template Information"
-msgstr ""
+msgstr "சான்றிதழ் வார்ப்புரு தகவல்"
 
 #: dlls/crypt32/crypt32.rc:121
 msgid "Enterprise Root OID"
-msgstr ""
+msgstr "எண்டர்பிரைஸ் ரூட் OID"
 
 #: dlls/crypt32/crypt32.rc:122
 msgid "Dummy Signer"
-msgstr ""
+msgstr "போலி கையொப்பம் செய்பவர்"
 
 #: dlls/crypt32/crypt32.rc:123
 msgid "Encrypted Private Key"
-msgstr ""
+msgstr "மறைகுறியாக்கப்பட்ட தனிப்பட்ட விசை"
 
 #: dlls/crypt32/crypt32.rc:124
 msgid "Published CRL Locations"
-msgstr ""
+msgstr "வெளியிடப்பட்ட CRL இருப்பிடங்கள்"
 
 #: dlls/crypt32/crypt32.rc:125
 msgid "Enforce Certificate Chain Policy"
-msgstr ""
+msgstr "சான்றிதழ் சங்கிலிக் கொள்கையைச் செயல்படுத்தவும்"
 
 #: dlls/crypt32/crypt32.rc:126
 msgid "Transaction Id"
-msgstr ""
+msgstr "பரிவர்த்தனை ஐடி"
 
 #: dlls/crypt32/crypt32.rc:127
 msgid "Sender Nonce"
-msgstr ""
+msgstr "அனுப்பியவர் நோன்ஸ"
 
 #: dlls/crypt32/crypt32.rc:128
 msgid "Recipient Nonce"
-msgstr ""
+msgstr "பெறுநர் நோன்ஸ்"
 
 #: dlls/crypt32/crypt32.rc:129
 msgid "Reg Info"
-msgstr ""
+msgstr "பதிவு தகவல்"
 
 #: dlls/crypt32/crypt32.rc:130
 msgid "Get Certificate"
-msgstr ""
+msgstr "சான்றிதழைப் பெறுங்கள்"
 
 #: dlls/crypt32/crypt32.rc:131
 msgid "Get CRL"
-msgstr ""
+msgstr "CRL ஐப் பெறவும்"
 
 #: dlls/crypt32/crypt32.rc:132
 msgid "Revoke Request"
-msgstr ""
+msgstr "கோரிக்கையை திரும்பப் பெறவும்"
 
 #: dlls/crypt32/crypt32.rc:133
 msgid "Query Pending"
@@ -3589,6 +3637,16 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine வீடியோ 1 வீடியோ கோடெக்"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/te.po b/po/te.po
index 25980d922a7..c56da2da337 100644
--- a/po/te.po
+++ b/po/te.po
@@ -3625,6 +3625,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/th.po b/po/th.po
index b8a67e4c1a1..a235b30eb44 100644
--- a/po/th.po
+++ b/po/th.po
@@ -3680,6 +3680,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/tr.po b/po/tr.po
index 4b8b1c096fd..ead4e260bae 100644
--- a/po/tr.po
+++ b/po/tr.po
@@ -3716,6 +3716,18 @@ msgstr "Arttırılmış"
 msgid "High"
 msgstr "Yüksek"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "İçindekiler"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 video çözücü"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Oyun Kolları"
diff --git a/po/uk.po b/po/uk.po
index fdce4739263..5ee39714a38 100644
--- a/po/uk.po
+++ b/po/uk.po
@@ -3713,6 +3713,18 @@ msgstr "Збільшені"
 msgid "High"
 msgstr "Високі"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "Вказівник"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Відео кодек Wine Video 1"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "Джойстик"
diff --git a/po/wa.po b/po/wa.po
index cd0417b2569..34673cb6aa8 100644
--- a/po/wa.po
+++ b/po/wa.po
@@ -3688,6 +3688,15 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+msgid "Indeo5"
+msgstr "Å&dvins"
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/wine.pot b/po/wine.pot
index 266b26e4acb..4d92ac2a36b 100644
--- a/po/wine.pot
+++ b/po/wine.pot
@@ -3580,6 +3580,14 @@ msgstr ""
 msgid "High"
 msgstr ""
 
+#: dlls/ir50_32/ir50_32.rc:28
+msgid "Indeo5"
+msgstr ""
+
+#: dlls/ir50_32/ir50_32.rc:29
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr ""
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr ""
diff --git a/po/zh_CN.po b/po/zh_CN.po
index 012cce496b1..7c479a3d466 100644
--- a/po/zh_CN.po
+++ b/po/zh_CN.po
@@ -5,7 +5,7 @@ msgstr ""
 "Project-Id-Version: Wine\n"
 "Report-Msgid-Bugs-To: https://bugs.winehq.org\n"
 "POT-Creation-Date: N/A\n"
-"PO-Revision-Date: 2022-01-05 12:09+0800\n"
+"PO-Revision-Date: 2023-01-16 12:26+0800\n"
 "Last-Translator: Jactry Zeng <jzeng@codeweavers.com>\n"
 "Language-Team: Chinese (PRC)\n"
 "Language: zh_CN\n"
@@ -1319,10 +1319,8 @@ msgid "Options"
 msgstr "选项"
 
 #: dlls/compstui/compstui.rc:31
-#, fuzzy
-#| msgid "Defaults"
 msgid "Default"
-msgstr "默认值"
+msgstr "默认"
 
 #: dlls/credui/credui.rc:45
 msgid "&User name:"
@@ -3659,6 +3657,18 @@ msgstr "较高"
 msgid "High"
 msgstr "高"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "索引"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine Video 1 视频编解码器"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "操纵杆"
@@ -3701,25 +3711,23 @@ msgstr ""
 
 #: dlls/joy.cpl/joy.rc:55
 msgid "DInput"
-msgstr ""
+msgstr "DInput"
 
 #: dlls/joy.cpl/joy.rc:59
 msgid "Axes"
-msgstr ""
+msgstr "坐标轴"
 
 #: dlls/joy.cpl/joy.rc:60
 msgid "POVs"
-msgstr ""
+msgstr "帽子开关"
 
 #: dlls/joy.cpl/joy.rc:61
 msgid "Buttons"
 msgstr "按钮"
 
 #: dlls/joy.cpl/joy.rc:62
-#, fuzzy
-#| msgid "Test Force Feedback"
 msgid "Force Feedback Effect"
-msgstr "测试力反馈"
+msgstr "力反馈效果"
 
 #: dlls/joy.cpl/joy.rc:64
 msgid ""
@@ -3729,60 +3737,60 @@ msgstr "在控制器上按任意键以激活选中的效果。可根据控制器
 
 #: dlls/joy.cpl/joy.rc:70
 msgid "XInput"
-msgstr ""
+msgstr "XInput"
 
 #: dlls/joy.cpl/joy.rc:73
-#, fuzzy
-#| msgid "User"
 msgid "User #0"
-msgstr "用户名"
+msgstr "用户 #0"
 
 #: dlls/joy.cpl/joy.rc:74
-#, fuzzy
-#| msgid "User"
 msgid "User #1"
-msgstr "用户名"
+msgstr "用户 #1"
 
 #: dlls/joy.cpl/joy.rc:75
-#, fuzzy
-#| msgid "User"
 msgid "User #2"
-msgstr "用户名"
+msgstr "用户 #2"
 
 #: dlls/joy.cpl/joy.rc:76
-#, fuzzy
-#| msgid "User"
 msgid "User #3"
-msgstr "用户名"
+msgstr "用户 #3"
 
 #: dlls/joy.cpl/joy.rc:78
 msgid ""
 "No user detected on slot #0, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"插槽 #0 未检测到用户，请确认您的游戏手柄已插入，并且没有覆盖“操纵杆”选项卡中"
+"的 DInput。"
 
 #: dlls/joy.cpl/joy.rc:82
 msgid ""
 "No user detected on slot #1, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"插槽 #1 未检测到用户，请确认您的游戏手柄已插入，并且没有覆盖“操纵杆”选项卡中"
+"的 DInput。"
 
 #: dlls/joy.cpl/joy.rc:86
 msgid ""
 "No user detected on slot #2, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"插槽 #2 未检测到用户，请确认您的游戏手柄已插入，并且没有覆盖“操纵杆”选项卡中"
+"的 DInput。"
 
 #: dlls/joy.cpl/joy.rc:90
 msgid ""
 "No user detected on slot #3, make sure your gamepad is plugged in, and not "
 "overridden for DInput in the Joysticks tab."
 msgstr ""
+"插槽 #3 未检测到用户，请确认您的游戏手柄已插入，并且没有覆盖“操纵杆”选项卡中"
+"的 DInput。"
 
 #: dlls/joy.cpl/joy.rc:95 dlls/joy.cpl/joy.rc:96 dlls/joy.cpl/joy.rc:97
 #: dlls/joy.cpl/joy.rc:98
 msgid "Rumble"
-msgstr ""
+msgstr "震动"
 
 #: dlls/joy.cpl/joy.rc:31
 msgid "Game Controllers"
@@ -3992,13 +4000,11 @@ msgstr "无法在此对象上更改属性描述符中的“writable”属性为
 
 #: dlls/jscript/jscript.rc:74
 msgid "Cyclic __proto__ value"
-msgstr ""
+msgstr "循环的 __proto__ 值"
 
 #: dlls/jscript/jscript.rc:75
-#, fuzzy
-#| msgid "Cannot define property '|': object is not extensible"
 msgid "Cannot create property for a non-extensible object"
-msgstr "无法定义属性 '|': 对象不可扩展"
+msgstr "无法为不可扩展对象创建属性"
 
 #: dlls/jscript/jscript.rc:76
 msgid "Cannot define property '|': object is not extensible"
@@ -4013,10 +4019,8 @@ msgid "Cannot modify non-writable property '|'"
 msgstr "无法更改不可写的属性 '|'"
 
 #: dlls/jscript/jscript.rc:79
-#, fuzzy
-#| msgid "'this' is not a Map object"
 msgid "'this' is not a | object"
-msgstr "'this' 不是 Map 对象"
+msgstr "'this' 不是 | 对象"
 
 #: dlls/jscript/jscript.rc:80
 msgid "Property cannot have both accessors and a value"
@@ -4033,45 +4037,39 @@ msgstr "Wine"
 
 #: dlls/kernelbase/kernelbase.rc:29
 msgid "Western Europe and United States"
-msgstr ""
+msgstr "西欧和美国"
 
 #: dlls/kernelbase/kernelbase.rc:30
-#, fuzzy
-#| msgid "Central European"
 msgid "Central Europe"
-msgstr "中欧语言"
+msgstr "中欧"
 
 #: dlls/kernelbase/kernelbase.rc:34
-#, fuzzy
-#| msgid "Turkish"
 msgid "Turkic"
-msgstr "土耳其语"
+msgstr "突厥语"
 
 #: dlls/kernelbase/kernelbase.rc:36
 msgid "Korean"
-msgstr ""
+msgstr "韩语"
 
 #: dlls/kernelbase/kernelbase.rc:37
-#, fuzzy
-#| msgid "Operation Ceased"
 msgid "Traditional Chinese"
-msgstr "操作已停止"
+msgstr "繁体中文"
 
 #: dlls/kernelbase/kernelbase.rc:38
 msgid "Simplified Chinese"
-msgstr ""
+msgstr "简体中文"
 
 #: dlls/kernelbase/kernelbase.rc:43
 msgid "Indic"
-msgstr ""
+msgstr "印度语"
 
 #: dlls/kernelbase/kernelbase.rc:44
 msgid "Georgian"
-msgstr ""
+msgstr "格鲁吉亚语"
 
 #: dlls/kernelbase/kernelbase.rc:45
 msgid "Armenian"
-msgstr ""
+msgstr "亚美尼亚语"
 
 #: dlls/kernelbase/winerror.mc:28
 msgid "Success.\n"
@@ -7030,54 +7028,40 @@ msgid "This network connection does not exist.\n"
 msgstr "该网络连接不存在。\n"
 
 #: dlls/kernelbase/winerror.mc:3748
-#, fuzzy
-#| msgid "Invalid at interrupt time.\n"
 msgid "Call interrupted.\n"
-msgstr "中断时间无效。\n"
+msgstr "调用已中断。\n"
 
 #: dlls/kernelbase/winerror.mc:3753
-#, fuzzy
-#| msgid "Invalid handle.\n"
 msgid "Invalid file handle.\n"
-msgstr "无效的句柄。\n"
+msgstr "无效的文件句柄。\n"
 
 #: dlls/kernelbase/winerror.mc:3763
-#, fuzzy
-#| msgid "Invalid network address.\n"
 msgid "Invalid pointer address.\n"
-msgstr "无效的网络地址。\n"
+msgstr "无效的指针地址。\n"
 
 #: dlls/kernelbase/winerror.mc:3768
-#, fuzzy
-#| msgid "Invalid name.\n"
 msgid "Invalid argument.\n"
-msgstr "无效名字。\n"
+msgstr "无效的参数。\n"
 
 #: dlls/kernelbase/winerror.mc:3778
 msgid "Connection reset by peer.\n"
 msgstr "连接被重置。\n"
 
 #: dlls/kernelbase/winerror.mc:3788
-#, fuzzy
-#| msgid "Point not found.\n"
 msgid "Host not found.\n"
-msgstr "未找到点。\n"
+msgstr "未找到主机。\n"
 
 #: dlls/kernelbase/winerror.mc:3793
-#, fuzzy
-#| msgid "Attribute is not found.\n"
 msgid "Nonauthoritative host not found.\n"
-msgstr "未找到属性。\n"
+msgstr "未找到非授权主机。\n"
 
 #: dlls/kernelbase/winerror.mc:3798
-#, fuzzy
-#| msgid "Unrecoverable error occurred.\n"
 msgid "Nonrecoverable error.\n"
-msgstr "发生致命错误。\n"
+msgstr "不可恢复错误。\n"
 
 #: dlls/kernelbase/winerror.mc:3803
 msgid "Name valid, no data record.\n"
-msgstr ""
+msgstr "名称无效，没有数据记录。\n"
 
 #: dlls/kernelbase/winerror.mc:3817
 msgid "Not implemented.\n"
@@ -14942,10 +14926,8 @@ msgid "&Replace...\tCtrl+H"
 msgstr "替换(&R)...\tCtrl+H"
 
 #: programs/notepad/notepad.rc:59
-#, fuzzy
-#| msgid "&New...\tCtrl+N"
 msgid "&Go To...\tCtrl+G"
-msgstr "新建(&N)...\tCtrl+N"
+msgstr "跳转到(&G)...\tCtrl+G"
 
 #: programs/notepad/notepad.rc:63 programs/oleview/oleview.rc:68
 #: programs/oleview/oleview.rc:90 programs/winefile/winefile.rc:67
@@ -14988,17 +14970,15 @@ msgstr "上(&T):"
 
 #: programs/notepad/notepad.rc:132
 msgid "Go To Line"
-msgstr ""
+msgstr "跳转到行"
 
 #: programs/notepad/notepad.rc:134
-#, fuzzy
-#| msgid "CRL Number"
 msgid "&Line Number:"
-msgstr "CRL 号码"
+msgstr "行号(&L):"
 
 #: programs/notepad/notepad.rc:137
 msgid "Go To"
-msgstr ""
+msgstr "跳转到"
 
 #: programs/notepad/notepad.rc:145
 msgid "Encoding:"
@@ -15064,7 +15044,7 @@ msgstr "Z"
 #: programs/notepad/notepad.rc:162
 msgctxt "accelerator GoTo"
 msgid "G"
-msgstr ""
+msgstr "G"
 
 #: programs/notepad/notepad.rc:74
 msgid "Page &p"
@@ -15139,7 +15119,7 @@ msgstr ""
 
 #: programs/notepad/notepad.rc:90
 msgid "Ln %ld, Col %ld"
-msgstr ""
+msgstr "%ld 行，%ld 列"
 
 #: programs/oleview/oleview.rc:32
 msgid "&Bind to file..."
@@ -15746,56 +15726,6 @@ msgstr ""
 "\n"
 
 #: programs/reg/reg.rc:67
-#, fuzzy
-#| msgid ""
-#| "REG ADD <key> [/v value_name | /ve] [/t type] [/s separator] [/d data] [/"
-#| "f]\n"
-#| "\n"
-#| "  Adds a key to the registry or adds a new value to a given registry "
-#| "key.\n"
-#| "\n"
-#| "  <key>\n"
-#| "     The registry key to add or, if either [/v] or [/ve] is specified,\n"
-#| "     the key in which to add the new registry data.\n"
-#| "\n"
-#| "     Format: ROOT\\Subkey\n"
-#| "\n"
-#| "     ROOT: A predefined registry key. This must be one of the following:\n"
-#| "\n"
-#| "         HKEY_LOCAL_MACHINE  | HKLM\n"
-#| "         HKEY_CURRENT_USER   | HKCU\n"
-#| "         HKEY_CLASSES_ROOT   | HKCR\n"
-#| "         HKEY_USERS          | HKU\n"
-#| "         HKEY_CURRENT_CONFIG | HKCC\n"
-#| "\n"
-#| "     Subkey: The full path to a registry key under a given ROOT key.\n"
-#| "\n"
-#| "  /v <value_name>\n"
-#| "     The name of the registry value to add.\n"
-#| "\n"
-#| "  /ve\n"
-#| "     Add an unnamed registry value. This option modifies the (Default)\n"
-#| "     registry value.\n"
-#| "\n"
-#| "  /t <type>\n"
-#| "     The type of data to add to the registry. If [/t] is specified,\n"
-#| "     <type> must be one of the following:\n"
-#| "\n"
-#| "         REG_SZ    | REG_MULTI_SZ | REG_EXPAND_SZ\n"
-#| "         REG_DWORD | REG_BINARY   | REG_NONE\n"
-#| "\n"
-#| "     If [/t] is not specified, the default data type is REG_SZ.\n"
-#| "\n"
-#| "  /s <separator>\n"
-#| "     The character used to separate strings in REG_MULTI_SZ data.\n"
-#| "     If [/s] is not specified, the default separator is \\0.\n"
-#| "\n"
-#| "  /d <data>\n"
-#| "     The data to add to the new registry value.\n"
-#| "\n"
-#| "  /f\n"
-#| "     Modify the registry without prompting for confirmation.\n"
-#| "\n"
 msgid ""
 "REG ADD <key> [/v value_name | /ve] [/t type] [/s separator] [/d data] [/f]\n"
 "\n"
@@ -15875,7 +15805,7 @@ msgstr ""
 "     <类型> 应为以下的其中一个:\n"
 "\n"
 "         REG_SZ    | REG_MULTI_SZ | REG_EXPAND_SZ\n"
-"         REG_DWORD | REG_BINARY   | REG_NONE\n"
+"         REG_DWORD | REG_QWORD    | REG_BINARY   | REG_NONE\n"
 "\n"
 "     如果未指定 [/t] 选项，默认的数据类型是 REG_SZ。\n"
 "\n"
@@ -16307,14 +16237,12 @@ msgstr "二进制值(&B)"
 #: programs/regedit/regedit.rc:51 programs/regedit/regedit.rc:104
 #: programs/regedit/regedit.rc:127
 msgid "&DWORD Value"
-msgstr "整数值(&D)"
+msgstr "DWORD 值(&D)"
 
 #: programs/regedit/regedit.rc:52 programs/regedit/regedit.rc:105
 #: programs/regedit/regedit.rc:128
-#, fuzzy
-#| msgid "&DWORD Value"
 msgid "&QWORD Value"
-msgstr "整数值(&D)"
+msgstr "QWORD 值(&Q)"
 
 #: programs/regedit/regedit.rc:53 programs/regedit/regedit.rc:106
 #: programs/regedit/regedit.rc:129
@@ -16429,7 +16357,7 @@ msgstr "值数据:"
 
 #: programs/regedit/regedit.rc:331
 msgid "Edit DWORD"
-msgstr "编辑整数"
+msgstr "编辑 DWORD"
 
 #: programs/regedit/regedit.rc:338
 msgid "Base"
@@ -16862,16 +16790,12 @@ msgid "Collapse"
 msgstr "收起"
 
 #: programs/regedit/regedit.rc:178
-#, fuzzy
-#| msgid "Adds a new 32-bit value"
 msgid "Adds a new 64-bit value"
-msgstr "添加新 32 位值"
+msgstr "添加新 64 位值"
 
 #: programs/regedit/regedit.rc:221
-#, fuzzy
-#| msgid "Edit DWORD"
 msgid "Edit QWORD"
-msgstr "编辑整数"
+msgstr "编辑 QWORD"
 
 #: programs/regsvr32/regsvr32.rc:33
 msgid ""
diff --git a/po/zh_TW.po b/po/zh_TW.po
index 1def9b22a99..12ecea535b7 100644
--- a/po/zh_TW.po
+++ b/po/zh_TW.po
@@ -3663,6 +3663,18 @@ msgstr "稍高"
 msgid "High"
 msgstr "高"
 
+#: dlls/ir50_32/ir50_32.rc:28
+#, fuzzy
+#| msgid "Index"
+msgid "Indeo5"
+msgstr "索引"
+
+#: dlls/ir50_32/ir50_32.rc:29
+#, fuzzy
+#| msgid "Wine Video 1 video codec"
+msgid "Indeo Video Interactive version 5 video codec"
+msgstr "Wine 視訊 1 視訊編碼解碼器"
+
 #: dlls/joy.cpl/joy.rc:37
 msgid "Joysticks"
 msgstr "搖桿"
diff --git a/programs/conhost/conhost.c b/programs/conhost/conhost.c
index 800e8bab822..1bed7b8a03c 100644
--- a/programs/conhost/conhost.c
+++ b/programs/conhost/conhost.c
@@ -1463,6 +1463,29 @@ static NTSTATUS read_console( struct console *console, unsigned int ioctl, size_
     return process_console_input( console );
 }
 
+static BOOL map_to_ctrlevent( struct console *console, const INPUT_RECORD *record,
+                              unsigned int* event)
+{
+    if (record->EventType == KEY_EVENT)
+    {
+        if (record->Event.KeyEvent.uChar.UnicodeChar == 'C' - 64 &&
+            !(record->Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
+        {
+            *event = CTRL_C_EVENT;
+            return TRUE;
+        }
+        /* we want to get ctrl-pause/break, but it's already translated by user32 into VK_CANCEL */
+        if (record->Event.KeyEvent.uChar.UnicodeChar == 0 &&
+            record->Event.KeyEvent.wVirtualKeyCode == VK_CANCEL &&
+            record->Event.KeyEvent.dwControlKeyState == LEFT_CTRL_PRESSED)
+        {
+            *event = CTRL_BREAK_EVENT;
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
 /* add input events to a console input queue */
 NTSTATUS write_console_input( struct console *console, const INPUT_RECORD *records,
                               unsigned int count, BOOL flush )
@@ -1485,9 +1508,9 @@ NTSTATUS write_console_input( struct console *console, const INPUT_RECORD *recor
         unsigned int i = 0;
         while (i < count)
         {
-            if (records[i].EventType == KEY_EVENT &&
-		records[i].Event.KeyEvent.uChar.UnicodeChar == 'C' - 64 &&
-		!(records[i].Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
+            unsigned int event;
+
+            if (map_to_ctrlevent(console, &records[i], &event))
             {
                 if (i != count - 1)
                     memcpy( &console->records[console->record_count + i],
@@ -1499,7 +1522,7 @@ NTSTATUS write_console_input( struct console *console, const INPUT_RECORD *recor
                     struct condrv_ctrl_event ctrl_event;
                     IO_STATUS_BLOCK io;
 
-                    ctrl_event.event = CTRL_C_EVENT;
+                    ctrl_event.event = event;
                     ctrl_event.group_id = 0;
                     NtDeviceIoControlFile( console->server, NULL, NULL, NULL, &io, IOCTL_CONDRV_CTRL_EVENT,
                                            &ctrl_event, sizeof(ctrl_event), NULL, 0 );
@@ -1755,6 +1778,12 @@ static DWORD WINAPI tty_input( void *param )
             case 0x1b:
                 i += process_input_escape( console, buf + i + 1, count - i - 1 );
                 break;
+            case 0x1c: /* map ctrl-\ unix-ism into ctrl-break/pause windows-ism for unix consoles */
+                if (console->is_unix)
+                    key_press( console, 0, VK_CANCEL, LEFT_CTRL_PRESSED );
+                else
+                    char_key_press( console, ch, 0 );
+                break;
             case 0x7f:
                 key_press( console, '\b', VK_BACK, 0 );
                 break;
diff --git a/programs/conhost/window.c b/programs/conhost/window.c
index 0a44186beb1..0d6036f07d7 100644
--- a/programs/conhost/window.c
+++ b/programs/conhost/window.c
@@ -932,6 +932,8 @@ void update_console_font( struct console *console, const WCHAR *face_name, size_
 {
     LOGFONTW lf;
 
+    if (!console->window) return;
+
     fill_logfont( &lf, face_name, face_name_size, height, weight );
 
     set_console_font( console, &lf );
@@ -1547,7 +1549,7 @@ static BOOL select_font( struct dialog_info *di )
     args[0] = di->config.cell_width;
     args[1] = di->config.cell_height;
     FormatMessageW( FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                    fmt, 0, 0, buf, ARRAY_SIZE(buf), (__ms_va_list*)args );
+                    fmt, 0, 0, buf, ARRAY_SIZE(buf), (va_list *)args );
 
     SendDlgItemMessageW( di->dialog, IDC_FNT_FONT_INFO, WM_SETTEXT, 0, (LPARAM)buf );
     return TRUE;
diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 96673adc254..afa711a8dbf 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -40,7 +40,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(explorer);
 #define DESKTOP_CLASS_ATOM ((LPCWSTR)MAKEINTATOM(32769))
 #define DESKTOP_ALL_ACCESS 0x01ff
 
-static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',0};
+static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',',','w','a','y','l','a','n','d',0};
 
 static BOOL using_root;
 
diff --git a/programs/notepad/dialog.c b/programs/notepad/dialog.c
index c4e99013fe6..d9269b31b93 100644
--- a/programs/notepad/dialog.c
+++ b/programs/notepad/dialog.c
@@ -169,7 +169,7 @@ static int AlertUnicodeCharactersLost(LPCWSTR szFileName)
     load_encoding_name(ENCODING_ANSI, szEnc, ARRAY_SIZE(szEnc));
     args[0] = (DWORD_PTR)szFileName;
     args[1] = (DWORD_PTR)szEnc;
-    FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY, szMsgFormat, 0, 0, (LPWSTR)&szMsg, 0, (__ms_va_list*)args);
+    FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY, szMsgFormat, 0, 0, (LPWSTR)&szMsg, 0, (va_list *)args);
     rc = MessageBoxW(Globals.hMainWnd, szMsg, szCaption,
                      MB_OKCANCEL|MB_ICONEXCLAMATION);
     LocalFree(szMsg);
diff --git a/programs/notepad/main.c b/programs/notepad/main.c
index 930884d144f..829cd7af33b 100644
--- a/programs/notepad/main.c
+++ b/programs/notepad/main.c
@@ -441,10 +441,10 @@ static LPWSTR NOTEPAD_StrRStr(LPWSTR pszSource, LPWSTR pszLast, LPWSTR pszSrch)
  */
 void NOTEPAD_DoFind(FINDREPLACEW *fr)
 {
-    LPWSTR content;
+    LPWSTR content, found;
     int len = lstrlenW(fr->lpstrFindWhat);
     int fileLen;
-    SIZE_T pos;
+    DWORD pos;
 
     fileLen = GetWindowTextLengthW(Globals.hEdit) + 1;
     content = HeapAlloc(GetProcessHeap(), 0, fileLen * sizeof(WCHAR));
@@ -455,27 +455,24 @@ void NOTEPAD_DoFind(FINDREPLACEW *fr)
     switch (fr->Flags & (FR_DOWN|FR_MATCHCASE))
     {
         case 0:
-            pos = StrRStrIW(content, content+pos-len, fr->lpstrFindWhat) - content;
-            if (pos == -(SIZE_T)content) pos = ~(SIZE_T)0;
+            found = StrRStrIW(content, content+pos-len, fr->lpstrFindWhat);
             break;
         case FR_DOWN:
-            pos = StrStrIW(content+pos, fr->lpstrFindWhat) - content;
-            if (pos == -(SIZE_T)content) pos = ~(SIZE_T)0;
+            found = StrStrIW(content+pos, fr->lpstrFindWhat);
             break;
         case FR_MATCHCASE:
-            pos = NOTEPAD_StrRStr(content, content+pos-len, fr->lpstrFindWhat) - content;
-            if (pos == -(SIZE_T)content) pos = ~(SIZE_T)0;
+            found = NOTEPAD_StrRStr(content, content+pos-len, fr->lpstrFindWhat);
             break;
         case FR_DOWN|FR_MATCHCASE:
-            pos = StrStrW(content+pos, fr->lpstrFindWhat) - content;
-            if (pos == -(SIZE_T)content) pos = ~(SIZE_T)0;
+            found = StrStrW(content+pos, fr->lpstrFindWhat);
             break;
         default:    /* shouldn't happen */
             return;
     }
+    pos = found - content;
     HeapFree(GetProcessHeap(), 0, content);
 
-    if (pos == ~(SIZE_T)0)
+    if (!found)
     {
         DIALOG_StringMsgBox(Globals.hFindReplaceDlg, STRING_NOTFOUND, fr->lpstrFindWhat,
             MB_ICONINFORMATION|MB_OK);
diff --git a/programs/oleview/typelib.c b/programs/oleview/typelib.c
index 19f902a0659..ce420b0404a 100644
--- a/programs/oleview/typelib.c
+++ b/programs/oleview/typelib.c
@@ -1116,7 +1116,7 @@ static int PopulateTree(void)
         args[0] = (DWORD_PTR)typelib.wszFileName;
         args[1] = hRes;
         FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                       wszError, 0, 0, wszMessage, ARRAY_SIZE(wszMessage), (__ms_va_list*)args);
+                       wszError, 0, 0, wszMessage, ARRAY_SIZE(wszMessage), (va_list *)args);
         MessageBoxW(globals.hMainWnd, wszMessage, NULL, MB_OK|MB_ICONEXCLAMATION);
         return 1;
     }
diff --git a/programs/services/rpc.c b/programs/services/rpc.c
index de918d33b1f..e56d25ea1af 100644
--- a/programs/services/rpc.c
+++ b/programs/services/rpc.c
@@ -102,6 +102,8 @@ static void sc_notify_release(struct sc_notify_handle *notify)
     if (r == 0)
     {
         CloseHandle(notify->event);
+        if (notify->params_list)
+            free(notify->params_list->NotifyParamsArray[0].params);
         free(notify->params_list);
         free(notify);
     }
@@ -841,11 +843,14 @@ static void fill_notify(struct sc_notify_handle *notify, struct service_entry *s
     SC_RPC_NOTIFY_PARAMS_LIST *list;
     SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2 *cparams;
 
-    list = calloc(1, sizeof(SC_RPC_NOTIFY_PARAMS_LIST) + sizeof(SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2));
+    list = calloc(1, sizeof(SC_RPC_NOTIFY_PARAMS_LIST));
     if (!list)
         return;
-
-    cparams = (SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2 *)(list + 1);
+    if (!(cparams = calloc(1, sizeof(SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2))))
+    {
+        free(list);
+        return;
+    }
 
     cparams->dwNotifyMask = notify->notify_mask;
     fill_status_process(&cparams->ServiceStatus, service);
diff --git a/programs/services/services.c b/programs/services/services.c
index 6bda0a4008b..8a3ff754329 100644
--- a/programs/services/services.c
+++ b/programs/services/services.c
@@ -1074,9 +1074,9 @@ found:
         CreateEnvironmentBlock(&environment, token, FALSE);
         if (GetEnvironmentVariableW( L"WINEBOOTSTRAPMODE", val, ARRAY_SIZE(val) ))
         {
-            UNICODE_STRING name, value;
+            UNICODE_STRING name = RTL_CONSTANT_STRING(L"WINEBOOTSTRAPMODE");
+            UNICODE_STRING value;
 
-            RtlInitUnicodeString( &name, L"WINEBOOTSTRAPMODE" );
             RtlInitUnicodeString( &value, val );
             RtlSetEnvironmentVariable( (WCHAR **)&environment, &name, &value );
         }
diff --git a/programs/start/start.c b/programs/start/start.c
index 62804917941..4fd6cfc4481 100644
--- a/programs/start/start.c
+++ b/programs/start/start.c
@@ -77,7 +77,7 @@ static void fatal_error(const WCHAR *msg, DWORD error_code, const WCHAR *filenam
     output(L": ");
     args[0] = (DWORD_PTR)filename;
     status = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                            NULL, error_code, 0, (LPWSTR)&lpMsgBuf, 0, (__ms_va_list *)args );
+                            NULL, error_code, 0, (LPWSTR)&lpMsgBuf, 0, (va_list *)args );
     if (!status)
     {
         WINE_ERR("FormatMessage failed\n");
@@ -99,7 +99,7 @@ static void fatal_string_error(int which, DWORD error_code, const WCHAR *filenam
 
 	fatal_error(msg, error_code, filename);
 }
-	
+
 static void fatal_string(int which)
 {
 	WCHAR msg[2048];
diff --git a/programs/taskkill/taskkill.c b/programs/taskkill/taskkill.c
index 2904e64f40a..424e87b9a44 100644
--- a/programs/taskkill/taskkill.c
+++ b/programs/taskkill/taskkill.c
@@ -341,7 +341,7 @@ static int terminate_processes(void)
                 continue;
             }
 
-            if (!TerminateProcess(process, 0))
+            if (!TerminateProcess(process, 1))
             {
                 taskkill_message_printfW(STRING_TERMINATE_FAILED, task_list[i]);
                 status_code = 1;
@@ -381,7 +381,7 @@ static int terminate_processes(void)
                         continue;
                     }
 
-                    if (!TerminateProcess(process, 0))
+                    if (!TerminateProcess(process, 1))
                     {
                         taskkill_message_printfW(STRING_TERMINATE_FAILED, task_list[i]);
                         status_code = 1;
diff --git a/programs/taskmgr/endproc.c b/programs/taskmgr/endproc.c
index 498186212b7..0d2752be9ac 100644
--- a/programs/taskmgr/endproc.c
+++ b/programs/taskmgr/endproc.c
@@ -83,7 +83,7 @@ void ProcessPage_OnEndProcess(void)
         return;
     }
 
-    if (!TerminateProcess(hProcess, 0))
+    if (!TerminateProcess(hProcess, 1))
     {
         GetLastErrorText(wstrErrorText, ARRAY_SIZE(wstrErrorText));
         MessageBoxW(hMainWnd, wstrErrorText,wszUnable2Terminate, MB_OK|MB_ICONSTOP);
@@ -133,7 +133,7 @@ void ProcessPage_OnEndProcessTree(void)
         return;
     }
 
-    if (!TerminateProcess(hProcess, 0))
+    if (!TerminateProcess(hProcess, 1))
     {
         GetLastErrorText(wstrErrorText, ARRAY_SIZE(wstrErrorText));
         MessageBoxW(hMainWnd, wstrErrorText,wszUnable2Terminate, MB_OK|MB_ICONSTOP);
diff --git a/programs/taskmgr/perfpage.c b/programs/taskmgr/perfpage.c
index 4689d4e3312..505846e3b4f 100644
--- a/programs/taskmgr/perfpage.c
+++ b/programs/taskmgr/perfpage.c
@@ -188,8 +188,7 @@ static DWORD WINAPI PerformancePageRefreshThread(void *lpParameter)
 			args[0] = CommitChargeTotal;
 			args[1] = CommitChargeLimit;
 			FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-			               wszMemUsage, 0, 0, Text,
-                                       ARRAY_SIZE(Text), (__ms_va_list*)args);
+			               wszMemUsage, 0, 0, Text, ARRAY_SIZE(Text), (va_list *)args);
 			SendMessageW(hStatusWnd, SB_SETTEXTW, 2, (LPARAM)Text);
 
 			/* 
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 4de20705224..117fd4caf9b 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -257,11 +257,10 @@ static void create_user_shared_data(void)
     SYSTEM_BASIC_INFORMATION sbi;
     BOOLEAN *features;
     OBJECT_ATTRIBUTES attr = {sizeof(attr)};
-    UNICODE_STRING name;
+    UNICODE_STRING name = RTL_CONSTANT_STRING( L"\\KernelObjects\\__wine_user_shared_data" );
     NTSTATUS status;
     HANDLE handle;
 
-    RtlInitUnicodeString( &name, L"\\KernelObjects\\__wine_user_shared_data" );
     InitializeObjectAttributes( &attr, &name, OBJ_OPENIF, NULL, NULL );
     if ((status = NtOpenSection( &handle, SECTION_ALL_ACCESS, &attr )))
     {
@@ -1609,7 +1608,7 @@ int __cdecl main( int argc, char *argv[] )
     BOOL end_session, force, init, kill, restart, shutdown, update;
     HANDLE event;
     OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
+    UNICODE_STRING nameW = RTL_CONSTANT_STRING( L"\\KernelObjects\\__wineboot_event" );
     BOOL is_wow64;
 
     end_session = force = init = kill = restart = shutdown = update = FALSE;
@@ -1690,7 +1689,6 @@ int __cdecl main( int argc, char *argv[] )
 
     /* create event to be inherited by services.exe */
     InitializeObjectAttributes( &attr, &nameW, OBJ_OPENIF | OBJ_INHERIT, 0, NULL );
-    RtlInitUnicodeString( &nameW, L"\\KernelObjects\\__wineboot_event" );
     NtCreateEvent( &event, EVENT_ALL_ACCESS, &attr, NotificationEvent, 0 );
 
     ResetEvent( event );  /* in case this is a restart */
diff --git a/programs/winecfg/appdefaults.c b/programs/winecfg/appdefaults.c
index 9e43eeb51c8..b7a2dc44038 100644
--- a/programs/winecfg/appdefaults.c
+++ b/programs/winecfg/appdefaults.c
@@ -37,6 +37,7 @@ struct win_version
 {
     const WCHAR *szVersion;
     const WCHAR *szDescription;
+    const WCHAR *szCurrentVersion;
     DWORD        dwMajorVersion;
     DWORD        dwMinorVersion;
     DWORD        dwBuildNumber;
@@ -49,39 +50,51 @@ struct win_version
 
 static const struct win_version win_versions[] =
 {
-    { L"win10",     L"Windows 10",       10,  0, 18362, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win81",     L"Windows 8.1",       6,  3,  9600, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win8",      L"Windows 8",         6,  2,  9200, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win2008r2", L"Windows 2008 R2",   6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"ServerNT"},
-    { L"win7",      L"Windows 7",         6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"WinNT"},
-    { L"win2008",   L"Windows 2008",      6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
-    { L"vista",     L"Windows Vista",     6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
-    { L"win2003",   L"Windows 2003",      5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
+    { L"win11",     L"Windows 11",      L"6.3", 10,  0, 22000, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win10",     L"Windows 10",      L"6.3", 10,  0, 18362, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win81",     L"Windows 8.1",     NULL,    6,  3,  9600, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win8",      L"Windows 8",       NULL,    6,  2,  9200, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win2008r2", L"Windows 2008 R2", NULL,    6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"ServerNT"},
+    { L"win7",      L"Windows 7",       NULL,    6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"WinNT"},
+    { L"win2008",   L"Windows 2008",    NULL,    6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
+    { L"vista",     L"Windows Vista",   NULL,    6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
+    { L"win2003",   L"Windows 2003",    NULL,    5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
 #ifdef _WIN64
-    { L"winxp64",   L"Windows XP",        5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
+    { L"winxp64",   L"Windows XP",      NULL,    5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
 #else
-    { L"winxp",     L"Windows XP",        5,  1,  2600, VER_PLATFORM_WIN32_NT, L"Service Pack 3", 3, 0, L"WinNT"},
-    { L"win2k",     L"Windows 2000",      5,  0,  2195, VER_PLATFORM_WIN32_NT, L"Service Pack 4", 4, 0, L"WinNT"},
-    { L"winme",     L"Windows ME",        4, 90,  3000, VER_PLATFORM_WIN32_WINDOWS, L" ", 0, 0, L""},
-    { L"win98",     L"Windows 98",        4, 10,  2222, VER_PLATFORM_WIN32_WINDOWS, L" A ", 0, 0, L""},
-    { L"win95",     L"Windows 95",        4,  0,   950, VER_PLATFORM_WIN32_WINDOWS, L"", 0, 0, L""},
-    { L"nt40",      L"Windows NT 4.0",    4,  0,  1381, VER_PLATFORM_WIN32_NT, L"Service Pack 6a", 6, 0, L"WinNT"},
-    { L"nt351",     L"Windows NT 3.51",   3, 51,  1057, VER_PLATFORM_WIN32_NT, L"Service Pack 5", 5, 0, L"WinNT"},
-    { L"win31",     L"Windows 3.1",       3, 10,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
-    { L"win30",     L"Windows 3.0",       3,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
-    { L"win20",     L"Windows 2.0",       2,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""}
+    { L"winxp",     L"Windows XP",      NULL,    5,  1,  2600, VER_PLATFORM_WIN32_NT, L"Service Pack 3", 3, 0, L"WinNT"},
+    { L"win2k",     L"Windows 2000",    NULL,    5,  0,  2195, VER_PLATFORM_WIN32_NT, L"Service Pack 4", 4, 0, L"WinNT"},
+    { L"winme",     L"Windows ME",      NULL,    4, 90,  3000, VER_PLATFORM_WIN32_WINDOWS, L" ", 0, 0, L""},
+    { L"win98",     L"Windows 98",      NULL,    4, 10,  2222, VER_PLATFORM_WIN32_WINDOWS, L" A ", 0, 0, L""},
+    { L"win95",     L"Windows 95",      NULL,    4,  0,   950, VER_PLATFORM_WIN32_WINDOWS, L"", 0, 0, L""},
+    { L"nt40",      L"Windows NT 4.0",  NULL,    4,  0,  1381, VER_PLATFORM_WIN32_NT, L"Service Pack 6a", 6, 0, L"WinNT"},
+    { L"nt351",     L"Windows NT 3.51", NULL,    3, 51,  1057, VER_PLATFORM_WIN32_NT, L"Service Pack 5", 5, 0, L"WinNT"},
+    { L"win31",     L"Windows 3.1",     NULL,    3, 10,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
+    { L"win30",     L"Windows 3.0",     NULL,    3,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
+    { L"win20",     L"Windows 2.0",     NULL,    2,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""}
 #endif
 };
 
-#define DEFAULT_WIN_VERSION   L"win7"
+#define DEFAULT_WIN_VERSION   L"win10"
 
 static const WCHAR szKey9x[] = L"Software\\Microsoft\\Windows\\CurrentVersion";
 static const WCHAR szKeyNT[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion";
 static const WCHAR szKeyProdNT[] = L"System\\CurrentControlSet\\Control\\ProductOptions";
 
+static DWORD get_reg_dword( HKEY root, const WCHAR *subkey, const WCHAR *value )
+{
+    HKEY hkey;
+    DWORD ret, len = sizeof(ret), type;
+
+    if (RegOpenKeyExW( root, subkey, 0, KEY_QUERY_VALUE, &hkey )) return 0;
+    if (RegQueryValueExW( hkey, value, NULL, &type, (BYTE *)&ret, &len ) || type != REG_DWORD) ret = 0;
+    RegCloseKey( hkey );
+    return ret;
+}
+
 static int get_registry_version(void)
 {
-    int i, best = -1, platform, major, minor = 0, build = 0;
+    int i, best = -1, platform, major = 0, minor = 0, build = 0;
     WCHAR *p, *ver, *type = NULL;
 
     if ((ver = get_reg_key( HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentVersion", NULL )))
@@ -90,6 +103,9 @@ static int get_registry_version(void)
 
         platform = VER_PLATFORM_WIN32_NT;
 
+        major = get_reg_dword( HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMajorVersionNumber" );
+        minor = get_reg_dword( HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMinorVersionNumber" );
+
         build_str = get_reg_key( HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentBuildNumber", NULL );
         build = wcstol(build_str, NULL, 10);
 
@@ -100,19 +116,22 @@ static int get_registry_version(void)
     else
         return -1;
 
-    if ((p = wcschr( ver, '.' )))
+    if (!major)
     {
-        WCHAR *minor_str = p;
-        *minor_str++ = 0;
-        if ((p = wcschr( minor_str, '.' )))
+        if ((p = wcschr( ver, '.' )))
         {
-            WCHAR *build_str = p;
-            *build_str++ = 0;
-            build = wcstol(build_str, NULL, 10);
+            WCHAR *minor_str = p;
+            *minor_str++ = 0;
+            if ((p = wcschr( minor_str, '.' )))
+            {
+                WCHAR *build_str = p;
+                *build_str++ = 0;
+                build = wcstol(build_str, NULL, 10);
+            }
+            minor = wcstol(minor_str, NULL, 10);
         }
-        minor = wcstol(minor_str, NULL, 10);
+        major = wcstol(ver, NULL, 10);
     }
-    major = wcstol(ver, NULL, 10);
 
     for (i = 0; i < ARRAY_SIZE(win_versions); i++)
     {
@@ -427,9 +446,13 @@ static void set_winver(const struct win_version *version)
             break;
 
         case VER_PLATFORM_WIN32_NT:
-            swprintf(buffer, ARRAY_SIZE(buffer), L"%d.%d", version->dwMajorVersion,
-                        version->dwMinorVersion);
-            set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentVersion", buffer);
+            if (version->szCurrentVersion)
+                set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentVersion", version->szCurrentVersion);
+            else
+            {
+                swprintf(buffer, ARRAY_SIZE(buffer), L"%d.%d", version->dwMajorVersion, version->dwMinorVersion);
+                set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentVersion", buffer);
+            }
             set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMajorVersionNumber", version->dwMajorVersion);
             set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMinorVersionNumber", version->dwMinorVersion);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CSDVersion", version->szCSDVersion);
diff --git a/programs/winedbg/dbg.y b/programs/winedbg/dbg.y
index df1e3461032..f46e665e6b9 100644
--- a/programs/winedbg/dbg.y
+++ b/programs/winedbg/dbg.y
@@ -59,7 +59,7 @@ static void parser(const char*);
 %token <integer> tNUM tFORMAT
 %token <type> tTYPEDEF
 %token tSYMBOLFILE tRUN tATTACH tDETACH tKILL tMAINTENANCE tTYPE tMINIDUMP
-%token tNOPROCESS
+%token tNOPROCESS tWOW
 
 /* can be prefixed by module name */
 %token <string> tVOID tCHAR tWCHAR tSHORT tINT tLONG tFLOAT tDOUBLE tUNSIGNED tSIGNED
@@ -269,8 +269,9 @@ display_command:
 
 info_command:
       tINFO tBREAK              { break_info(); }
-    | tINFO tSHARE     		{ info_win32_module(0); }
-    | tINFO tSHARE expr_rvalue  { info_win32_module($3); }
+    | tINFO tSHARE              { info_win32_module(0, FALSE); }
+    | tINFO tWOW tSHARE         { info_win32_module(0, TRUE); }
+    | tINFO tSHARE expr_rvalue  { info_win32_module($3, FALSE); }
     | tINFO tREGS               { dbg_curr_process->be_cpu->print_context(dbg_curr_thread->handle, &dbg_context, 0); }
     | tINFO tALLREGS            { dbg_curr_process->be_cpu->print_context(dbg_curr_thread->handle, &dbg_context, 1); }
     | tINFO tSEGMENTS expr_rvalue { info_win32_segments($3 >> 3, 1); }
diff --git a/programs/winedbg/debug.l b/programs/winedbg/debug.l
index be528fed986..0b76ba74329 100644
--- a/programs/winedbg/debug.l
+++ b/programs/winedbg/debug.l
@@ -216,6 +216,7 @@ STRING     \"(\\[^\n]|[^\\"\n])*\"
 <INITIAL>show|sho|sh			{ BEGIN(SHOW_CMD); return tSHOW; }
 <INITIAL,NOPROCESS>source|sourc|sour|src { BEGIN(PATH_EXPECTED); return tSOURCE; }
 <INITIAL>symbolfile|symbols|symbol|sf   { BEGIN(PATH_EXPECTED); return tSYMBOLFILE; }
+<INITIAL,INFO_CMD>wow                   { return tWOW; }
 
 <INITIAL,INFO_CMD,BD_CMD>break|brea|bre|br|b	{ BEGIN(PATH_ACCEPTED); return tBREAK; }
 <INITIAL,INFO_CMD,BD_CMD>hbreak|hbrea|hbre|hbr|hb { BEGIN(PATH_ACCEPTED); return tHBREAK; }
diff --git a/programs/winedbg/debugger.h b/programs/winedbg/debugger.h
index c4c0402ef5f..6a313efbb5e 100644
--- a/programs/winedbg/debugger.h
+++ b/programs/winedbg/debugger.h
@@ -246,6 +246,13 @@ struct dbg_thread
     BOOL                        suspended;
 };
 
+struct dbg_module
+{
+    struct list                 entry;
+    DWORD_PTR                   base;
+    DWORD_PTR                   tls_index_offset;
+};
+
 struct dbg_delayed_bp
 {
     BOOL                        is_symbol;
@@ -271,6 +278,7 @@ struct dbg_process
     void*                       pio_data;
     const WCHAR*		imageName;
     struct list           	threads;
+    struct list                 modules;
     struct backend_cpu*         be_cpu;
     HANDLE                      event_on_first_exception;
     BOOL                        active_debuggee;
@@ -379,7 +387,7 @@ extern BOOL             expr_print(const struct expr* exp);
   /* info.c */
 extern void             print_help(void);
 extern void             info_help(void);
-extern void             info_win32_module(DWORD64 mod);
+extern void             info_win32_module(DWORD64 mod, BOOL multi_machine);
 extern void             info_win32_class(HWND hWnd, const char* clsName);
 extern void             info_win32_window(HWND hWnd, BOOL detailed);
 extern void             info_win32_processes(void);
@@ -503,7 +511,7 @@ extern BOOL             types_is_integral_type(const struct dbg_lvalue*);
 extern BOOL             types_is_float_type(const struct dbg_lvalue*);
 extern BOOL             types_is_pointer_type(const struct dbg_lvalue*);
 extern BOOL             types_find_basic(const WCHAR*, const char*, struct dbg_type* type);
-extern BOOL             types_unload_module(DWORD_PTR linear);
+extern BOOL             types_unload_module(struct dbg_process* pcs, DWORD_PTR linear);
 
   /* winedbg.c */
 #ifdef __GNUC__
@@ -524,6 +532,9 @@ extern struct dbg_thread* dbg_get_thread(struct dbg_process* p, DWORD tid);
 extern void             dbg_del_thread(struct dbg_thread* t);
 extern BOOL             dbg_init(HANDLE hProc, const WCHAR* in, BOOL invade);
 extern BOOL             dbg_load_module(HANDLE hProc, HANDLE hFile, const WCHAR* name, DWORD_PTR base, DWORD size);
+extern struct dbg_module* dbg_get_module(struct dbg_process* pcs, DWORD_PTR base);
+extern void             dbg_del_module(struct dbg_module* mod);
+extern BOOL             dbg_unload_module(struct dbg_process* pcs, DWORD_PTR base);
 extern void             dbg_set_option(const char*, const char*);
 extern void             dbg_start_interactive(const char*, HANDLE hFile);
 extern void             dbg_init_console(void);
diff --git a/programs/winedbg/gdbproxy.c b/programs/winedbg/gdbproxy.c
index 6b523b30337..8fab5c0cd39 100644
--- a/programs/winedbg/gdbproxy.c
+++ b/programs/winedbg/gdbproxy.c
@@ -1692,7 +1692,9 @@ static BOOL CALLBACK packet_query_libraries_cb(PCSTR mod_name, DWORD64 base, PVO
     char buffer[0x400];
 
     mod.SizeOfStruct = sizeof(mod);
-    SymGetModuleInfo64(gdbctx->process->handle, base, &mod);
+    if (!SymGetModuleInfo64(gdbctx->process->handle, base, &mod) ||
+        mod.MachineType != gdbctx->process->be_cpu->machine)
+        return TRUE;
 
     reply_buffer_append_str(reply, "<library name=\"");
     if (strcmp(mod.LoadedImageName, "[vdso].so") == 0)
@@ -1765,7 +1767,7 @@ static BOOL CALLBACK packet_query_libraries_cb(PCSTR mod_name, DWORD64 base, PVO
 static enum packet_return packet_query_libraries(struct gdb_context* gdbctx)
 {
     struct reply_buffer* reply = &gdbctx->qxfer_buffer;
-    BOOL opt;
+    BOOL opt_native, opt_real_path;
 
     if (!gdbctx->process) return packet_error;
 
@@ -1776,9 +1778,12 @@ static enum packet_return packet_query_libraries(struct gdb_context* gdbctx)
     SymLoadModule(gdbctx->process->handle, 0, 0, 0, 0, 0);
 
     reply_buffer_append_str(reply, "<library-list>");
-    opt = SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, TRUE);
+    /* request also ELF modules, and also real path to loaded modules */
+    opt_native = SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, TRUE);
+    opt_real_path = SymSetExtendedOption(SYMOPT_EX_WINE_MODULE_REAL_PATH, TRUE);
     SymEnumerateModules64(gdbctx->process->handle, packet_query_libraries_cb, gdbctx);
-    SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, opt);
+    SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, opt_native);
+    SymSetExtendedOption(SYMOPT_EX_WINE_MODULE_REAL_PATH, opt_real_path);
     reply_buffer_append_str(reply, "</library-list>");
 
     return packet_send_buffer;
diff --git a/programs/winedbg/info.c b/programs/winedbg/info.c
index 5d6b45d715f..6ffcf99392a 100644
--- a/programs/winedbg/info.c
+++ b/programs/winedbg/info.c
@@ -166,12 +166,33 @@ struct info_modules
     unsigned            num_used;
 };
 
-static void module_print_info(const struct info_module *module, BOOL is_embedded)
+static const char* get_machine_str(DWORD machine)
 {
-    dbg_printf("%*.*I64x-%*.*I64x\t%-16s%s\n",
-               ADDRWIDTH, ADDRWIDTH, module->mi.BaseOfImage,
-               ADDRWIDTH, ADDRWIDTH, module->mi.BaseOfImage + module->mi.ImageSize,
-               is_embedded ? "\\" : get_symtype_str(&module->mi), module->name);
+    static char tmp[32];
+    switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_AMD64: return "x86_64";
+    case IMAGE_FILE_MACHINE_I386:  return "i386";
+    case IMAGE_FILE_MACHINE_ARM64: return "arm64";
+    case IMAGE_FILE_MACHINE_ARM:
+    case IMAGE_FILE_MACHINE_ARMNT: return "arm";
+    default: sprintf(tmp, "<%lx>", machine); return tmp;
+    }
+}
+
+static void module_print_info(const struct info_module *module, BOOL is_embedded, BOOL multi_machine)
+{
+    if (multi_machine)
+        dbg_printf("%16I64x-%16I64x\t%s\t%-16s%s\n",
+                   module->mi.BaseOfImage,
+                   module->mi.BaseOfImage + module->mi.ImageSize,
+                   get_machine_str(module->mi.MachineType),
+                   is_embedded ? "\\" : get_symtype_str(&module->mi), module->name);
+    else
+        dbg_printf("%*.*I64x-%*.*I64x\t%-16s%s\n",
+                   ADDRWIDTH, ADDRWIDTH, module->mi.BaseOfImage,
+                   ADDRWIDTH, ADDRWIDTH, module->mi.BaseOfImage + module->mi.ImageSize,
+                   is_embedded ? "\\" : get_symtype_str(&module->mi), module->name);
 }
 
 static int __cdecl module_compare(const void* p1, const void* p2)
@@ -220,11 +241,12 @@ static BOOL CALLBACK info_mod_cb(PCSTR mod_name, DWORD64 base, PVOID ctx)
  *
  * Display information about a given module (DLL or EXE), or about all modules
  */
-void info_win32_module(DWORD64 base)
+void info_win32_module(DWORD64 base, BOOL multi_machine)
 {
     struct info_modules im;
     UINT                i, j, num_printed = 0;
     BOOL                opt;
+    DWORD               machine;
 
     if (!dbg_curr_process)
     {
@@ -242,27 +264,42 @@ void info_win32_module(DWORD64 base)
     SymEnumerateModules64(dbg_curr_process->handle, info_mod_cb, &im);
     SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, opt);
 
+    if (!im.num_used) return;
+
     qsort(im.modules, im.num_used, sizeof(im.modules[0]), module_compare);
+    machine = im.modules[0].mi.MachineType;
 
-    dbg_printf("Module\tAddress\t\t\t%sDebug info\tName (%d modules)\n",
-	       ADDRWIDTH == 16 ? "\t\t" : "", im.num_used);
+    if (multi_machine)
+        dbg_printf("Module\tAddress\t\t\t\t\tMachine\tDebug info\tName (%d modules)\n", im.num_used);
+    else
+    {
+        unsigned same_machine = 0;
+        for (i = 0; i < im.num_used; i++)
+            if (machine == im.modules[i].mi.MachineType) same_machine++;
+        dbg_printf("Module\tAddress\t\t\t%sDebug info\tName (%d modules",
+                   ADDRWIDTH == 16 ? "\t\t" : "", same_machine);
+        if (same_machine != im.num_used)
+            dbg_printf(", %u for wow64 not listed", im.num_used - same_machine);
+        dbg_printf(")\n");
+    }
 
     for (i = 0; i < im.num_used; i++)
     {
-        if (base && 
+        if (base &&
             (base < im.modules[i].mi.BaseOfImage || base >= im.modules[i].mi.BaseOfImage + im.modules[i].mi.ImageSize))
             continue;
+        if (!multi_machine && machine != im.modules[i].mi.MachineType) continue;
         if (strstr(im.modules[i].name, "<elf>"))
         {
             dbg_printf("ELF\t");
-            module_print_info(&im.modules[i], FALSE);
+            module_print_info(&im.modules[i], FALSE, multi_machine);
             /* print all modules embedded in this one */
             for (j = 0; j < im.num_used; j++)
             {
                 if (!strstr(im.modules[j].name, "<elf>") && module_is_container(&im.modules[i], &im.modules[j]))
                 {
                     dbg_printf("  \\-PE\t");
-                    module_print_info(&im.modules[j], TRUE);
+                    module_print_info(&im.modules[j], TRUE, multi_machine);
                 }
             }
         }
@@ -279,7 +316,7 @@ void info_win32_module(DWORD64 base)
                 dbg_printf("ELF\t");
             else
                 dbg_printf("PE\t");
-            module_print_info(&im.modules[i], FALSE);
+            module_print_info(&im.modules[i], FALSE, multi_machine);
         }
         num_printed++;
     }
diff --git a/programs/winedbg/memory.c b/programs/winedbg/memory.c
index c1a714626b2..8237e719dae 100644
--- a/programs/winedbg/memory.c
+++ b/programs/winedbg/memory.c
@@ -248,13 +248,13 @@ void memory_examine(const struct dbg_lvalue *lvalue, int count, char format)
     case 'd': DO_DUMP(unsigned int, 4, " %4.4d"); break;
     case 'w': DO_DUMP(unsigned short, 8, " %04x"); break;
     case 'a':
-        if (sizeof(DWORD_PTR) == 4)
+        if (ADDRSIZE == 4)
         {
-            DO_DUMP(DWORD_PTR, 4, " %8.8Ix");
+            DO_DUMP(DWORD, 4, " %8.8lx");
         }
         else
         {
-            DO_DUMP(DWORD_PTR, 2, " %16.16Ix");
+            DO_DUMP(DWORD64, 2, " %16.16I64x");
         }
         break;
     case 'c': DO_DUMP2(char, 32, " %c", (_v < 0x20) ? ' ' : _v); break;
diff --git a/programs/winedbg/symbol.c b/programs/winedbg/symbol.c
index 961dc95585a..22c34033752 100644
--- a/programs/winedbg/symbol.c
+++ b/programs/winedbg/symbol.c
@@ -61,6 +61,43 @@ static BOOL symbol_get_debug_start(const struct dbg_type* func, ULONG64* start)
     return FALSE;
 }
 
+static BOOL fetch_tls_lvalue(const SYMBOL_INFO* sym, struct dbg_lvalue* lvalue)
+{
+    struct dbg_module*        mod = dbg_get_module(dbg_curr_process, sym->ModBase);
+    unsigned                  tlsindex;
+    struct dbg_lvalue         lv_teb_tls, lv_index_addr, lv_module_tls;
+    dbg_lgint_t               teb_tls_addr, index_addr, tls_module_addr;
+    char*                     teb_tls_storage;
+
+    if (!mod || !mod->tls_index_offset || !dbg_curr_thread)
+        return FALSE;
+    /* get ThreadLocalStoragePointer offset depending on debuggee bitness */
+    teb_tls_storage = (char*)dbg_curr_thread->teb;
+    if (ADDRSIZE == sizeof(void*))
+        /* debugger and debuggee have same bitness */
+        teb_tls_storage += offsetof(TEB, ThreadLocalStoragePointer);
+    else
+        /* debugger is 64bit, while debuggee is 32bit */
+        teb_tls_storage += 0x2000 /* TEB64 => TEB32 */ + offsetof(TEB32, ThreadLocalStoragePointer);
+    init_lvalue(&lv_teb_tls, TRUE, teb_tls_storage);
+
+    if (!memory_fetch_integer(&lv_teb_tls, ADDRSIZE, FALSE, &teb_tls_addr))
+        return FALSE;
+
+    init_lvalue(&lv_index_addr, TRUE, (void*)(DWORD_PTR)(sym->ModBase + mod->tls_index_offset));
+    if (!memory_fetch_integer(&lv_index_addr, ADDRSIZE, FALSE, &index_addr))
+        return FALSE;
+
+    if (!dbg_read_memory((const char*)(DWORD_PTR)index_addr, &tlsindex, sizeof(tlsindex)))
+        return FALSE;
+
+    init_lvalue(&lv_module_tls, TRUE, (void*)(DWORD_PTR)(teb_tls_addr + tlsindex * ADDRSIZE));
+    if (!memory_fetch_integer(&lv_module_tls, ADDRSIZE, FALSE, &tls_module_addr))
+        return FALSE;
+    init_lvalue(lvalue, TRUE, (void*)(DWORD_PTR)(tls_module_addr + sym->Address));
+    return TRUE;
+}
+
 static BOOL fill_sym_lvalue(const SYMBOL_INFO* sym, ULONG_PTR base,
                             struct dbg_lvalue* lvalue, char* buffer, size_t sz)
 {
@@ -128,46 +165,11 @@ static BOOL fill_sym_lvalue(const SYMBOL_INFO* sym, ULONG_PTR base,
     }
     else if (sym->Flags & SYMFLAG_TLSREL)
     {
-        PROCESS_BASIC_INFORMATION pbi;
-        THREAD_BASIC_INFORMATION  tbi;
-        DWORD_PTR                 addr;
-        PEB                       peb;
-        PEB_LDR_DATA              ldr_data;
-        PLIST_ENTRY               head, current;
-        LDR_DATA_TABLE_ENTRY      ldr_module;
-        unsigned                  tlsindex = -1;
-
-        if (NtQueryInformationProcess(dbg_curr_process->handle, ProcessBasicInformation,
-                                      &pbi, sizeof(pbi), NULL) ||
-            NtQueryInformationThread(dbg_curr_thread->handle, ThreadBasicInformation,
-                                     &tbi, sizeof(tbi), NULL))
+        if (!fetch_tls_lvalue(sym, lvalue))
         {
-        tls_error:
             if (buffer) snprintf(buffer, sz, "Cannot read TLS address\n");
             return FALSE;
         }
-        addr = (DWORD_PTR)&(((TEB*)tbi.TebBaseAddress)->ThreadLocalStoragePointer);
-        if (!dbg_read_memory((void*)addr, &addr, sizeof(addr)) ||
-            !dbg_read_memory(pbi.PebBaseAddress, &peb, sizeof(peb)) ||
-            !dbg_read_memory(peb.LdrData, &ldr_data, sizeof(ldr_data)))
-            goto tls_error;
-        current = ldr_data.InLoadOrderModuleList.Flink;
-        head = &((PEB_LDR_DATA*)peb.LdrData)->InLoadOrderModuleList;
-        do
-        {
-            if (!dbg_read_memory(CONTAINING_RECORD(current, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks),
-                                 &ldr_module, sizeof(ldr_module))) goto tls_error;
-            if ((DWORD_PTR)ldr_module.DllBase == sym->ModBase)
-            {
-                tlsindex = ldr_module.TlsIndex;
-                break;
-            }
-            current = ldr_module.InLoadOrderLinks.Flink;
-        } while (current != head);
-
-        addr += tlsindex * sizeof(DWORD_PTR);
-        if (!dbg_read_memory((void*)addr, &addr, sizeof(addr))) goto tls_error;
-        init_lvalue(lvalue, TRUE, (void*)(DWORD_PTR)(addr + sym->Address));
     }
     else
     {
diff --git a/programs/winedbg/tgt_active.c b/programs/winedbg/tgt_active.c
index 9e130038f22..0d5ae754af5 100644
--- a/programs/winedbg/tgt_active.c
+++ b/programs/winedbg/tgt_active.c
@@ -501,8 +501,7 @@ static unsigned dbg_handle_debug_event(DEBUG_EVENT* de)
                    de->dwProcessId, de->dwThreadId,
                    de->u.UnloadDll.lpBaseOfDll);
         break_delete_xpoints_from_module((DWORD_PTR)de->u.UnloadDll.lpBaseOfDll);
-        types_unload_module((DWORD_PTR)de->u.UnloadDll.lpBaseOfDll);
-        SymUnloadModule64(dbg_curr_process->handle, (DWORD_PTR)de->u.UnloadDll.lpBaseOfDll);
+        dbg_unload_module(dbg_curr_process, (DWORD_PTR)de->u.UnloadDll.lpBaseOfDll);
         break;
 
     case OUTPUT_DEBUG_STRING_EVENT:
diff --git a/programs/winedbg/types.c b/programs/winedbg/types.c
index 5f5f1346c67..44872a7edad 100644
--- a/programs/winedbg/types.c
+++ b/programs/winedbg/types.c
@@ -1205,16 +1205,16 @@ BOOL types_get_info(const struct dbg_type* type, IMAGEHLP_SYMBOL_TYPE_INFO ti, v
     return TRUE;
 }
 
-BOOL types_unload_module(DWORD_PTR linear)
+BOOL types_unload_module(struct dbg_process* pcs, DWORD_PTR linear)
 {
     unsigned i;
-    if (!dbg_curr_process) return FALSE;
-    for (i = 0; i < dbg_curr_process->num_synthetized_types; i++)
+    if (!pcs) return FALSE;
+    for (i = 0; i < pcs->num_synthetized_types; i++)
     {
-        if (dbg_curr_process->synthetized_types[i].module == linear)
+        if (pcs->synthetized_types[i].module == linear)
         {
-            dbg_curr_process->synthetized_types[i].module = 0;
-            dbg_curr_process->synthetized_types[i].id = dbg_itype_none;
+            pcs->synthetized_types[i].module = 0;
+            pcs->synthetized_types[i].id = dbg_itype_none;
         }
     }
     return TRUE;
diff --git a/programs/winedbg/winedbg.c b/programs/winedbg/winedbg.c
index 84ec7802396..9815ed4a046 100644
--- a/programs/winedbg/winedbg.c
+++ b/programs/winedbg/winedbg.c
@@ -273,6 +273,7 @@ struct dbg_process*	dbg_add_process(const struct be_process_io* pio, DWORD pid,
     p->pio_data = NULL;
     p->imageName = NULL;
     list_init(&p->threads);
+    list_init(&p->modules);
     p->event_on_first_exception = NULL;
     p->active_debuggee = FALSE;
     p->next_bp = 1;  /* breakpoint 0 is reserved for step-over */
@@ -316,11 +317,16 @@ void dbg_del_process(struct dbg_process* p)
 {
     struct dbg_thread*  t;
     struct dbg_thread*  t2;
+    struct dbg_module*  mod;
+    struct dbg_module*  mod2;
     int	i;
 
     LIST_FOR_EACH_ENTRY_SAFE(t, t2, &p->threads, struct dbg_thread, entry)
         dbg_del_thread(t);
 
+    LIST_FOR_EACH_ENTRY_SAFE(mod, mod2, &p->modules, struct dbg_module, entry)
+        dbg_del_module(mod);
+
     for (i = 0; i < p->num_delayed_bp; i++)
         if (p->delayed_bp[i].is_symbol)
             free(p->delayed_bp[i].u.symbol.name);
@@ -377,15 +383,85 @@ BOOL dbg_init(HANDLE hProc, const WCHAR* in, BOOL invade)
 
 BOOL dbg_load_module(HANDLE hProc, HANDLE hFile, const WCHAR* name, DWORD_PTR base, DWORD size)
 {
-    BOOL ret = SymLoadModuleExW(hProc, NULL, name, NULL, base, size, NULL, 0);
-    if (ret)
+    struct dbg_process* pcs = dbg_get_process_h(hProc);
+    struct dbg_module* mod;
+    IMAGEHLP_MODULEW64 info;
+    HANDLE hMap;
+    void* image;
+
+    if (!pcs) return FALSE;
+    mod = malloc(sizeof(struct dbg_module));
+    if (!mod) return FALSE;
+    if (!SymLoadModuleExW(hProc, hFile, name, NULL, base, size, NULL, 0))
     {
-        IMAGEHLP_MODULEW64      ihm;
-        ihm.SizeOfStruct = sizeof(ihm);
-        if (SymGetModuleInfoW64(hProc, base, &ihm) && (ihm.PdbUnmatched || ihm.DbgUnmatched))
-            dbg_printf("Loaded unmatched debug information for %s\n", wine_dbgstr_w(name));
+        free(mod);
+        return FALSE;
     }
-    return ret;
+    mod->base = base;
+    list_add_head(&pcs->modules, &mod->entry);
+
+    mod->tls_index_offset = 0;
+    if ((hMap = CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL)))
+    {
+        if ((image = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0)))
+        {
+            IMAGE_NT_HEADERS* nth = RtlImageNtHeader(image);
+            const void* tlsdir;
+            ULONG sz;
+
+            tlsdir = RtlImageDirectoryEntryToData(image, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &sz);
+            switch (nth->OptionalHeader.Magic)
+            {
+            case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
+                if (tlsdir && sz >= sizeof(IMAGE_TLS_DIRECTORY32))
+                    mod->tls_index_offset = (const char*)tlsdir - (const char*)image +
+                        offsetof(IMAGE_TLS_DIRECTORY32, AddressOfIndex);
+                break;
+            case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
+                if (tlsdir && sz >= sizeof(IMAGE_TLS_DIRECTORY64))
+                    mod->tls_index_offset = (const char*)tlsdir - (const char*)image +
+                        offsetof(IMAGE_TLS_DIRECTORY64, AddressOfIndex);
+                break;
+            }
+            UnmapViewOfFile(image);
+        }
+        CloseHandle(hMap);
+    }
+    info.SizeOfStruct = sizeof(info);
+    if (SymGetModuleInfoW64(hProc, base, &info))
+    if (info.PdbUnmatched || info.DbgUnmatched)
+        dbg_printf("Loaded unmatched debug information for %s\n", wine_dbgstr_w(name));
+
+    return TRUE;
+}
+
+void dbg_del_module(struct dbg_module* mod)
+{
+    list_remove(&mod->entry);
+    free(mod);
+}
+
+struct dbg_module* dbg_get_module(struct dbg_process* pcs, DWORD_PTR base)
+{
+    struct dbg_module* mod;
+
+    if (!pcs)
+        return NULL;
+    LIST_FOR_EACH_ENTRY(mod, &pcs->modules, struct dbg_module, entry)
+        if (mod->base == base)
+            return mod;
+    return NULL;
+}
+
+BOOL dbg_unload_module(struct dbg_process* pcs, DWORD_PTR base)
+{
+    struct dbg_module* mod = dbg_get_module(pcs, base);
+
+    types_unload_module(pcs, base);
+    SymUnloadModule64(pcs->handle, base);
+    dbg_del_module(mod);
+
+    return !!mod;
 }
 
 struct dbg_thread* dbg_get_thread(struct dbg_process* p, DWORD tid)
diff --git a/programs/winefile/winefile.c b/programs/winefile/winefile.c
index 8ad785b924a..6d18954e05a 100644
--- a/programs/winefile/winefile.c
+++ b/programs/winefile/winefile.c
@@ -2405,8 +2405,7 @@ static void set_space_status(void)
 		args[1] = (DWORD_PTR)StrFormatByteSizeW(ulTotalBytes.QuadPart, b2, ARRAY_SIZE(b2));
 
 		FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-				RS(fmt,IDS_FREE_SPACE_FMT), 0, 0, buffer, ARRAY_SIZE(buffer),
-				(__ms_va_list*)args);
+				RS(fmt,IDS_FREE_SPACE_FMT), 0, 0, buffer, ARRAY_SIZE(buffer), (va_list *)args);
 	} else
 		lstrcpyW(buffer, sQMarks);
 
diff --git a/programs/winetest/main.c b/programs/winetest/main.c
index 74b596b237b..a939034e8b9 100644
--- a/programs/winetest/main.c
+++ b/programs/winetest/main.c
@@ -583,6 +583,7 @@ static void print_language(void)
         xprintf ("    UserDefaultUILanguage=%04x\n", pGetUserDefaultUILanguage());
     if (pGetThreadUILanguage)
         xprintf ("    ThreadUILanguage=%04x\n", pGetThreadUILanguage());
+    xprintf ("    KeyboardLayout=%p\n", GetKeyboardLayout(0));
     xprintf ("    Country=%d\n", GetUserGeoID(GEOCLASS_NATION));
     xprintf ("    ACP=%d\n", GetACP());
 }
@@ -1122,7 +1123,7 @@ run_tests (char *logname, char *outdir)
         logfile = create_temp_file( tmpname );
         logname = tmpname;
     }
-    report (R_OUT, logname);
+    report (R_OUT, "%s", logname);
 
     if (logfile == INVALID_HANDLE_VALUE)
         report (R_FATAL, "Could not open logfile: %u", GetLastError());
@@ -1148,7 +1149,7 @@ run_tests (char *logname, char *outdir)
     if (!newdir && (!outdir || GetLastError() != ERROR_ALREADY_EXISTS))
         report (R_FATAL, "Could not create directory %s (%d)", tempdir, GetLastError());
 
-    report (R_DIR, tempdir);
+    report (R_DIR, "%s", tempdir);
 
     xprintf ("Version 4\n");
     xprintf ("Tests from build %s\n", build_id[0] ? build_id : "-" );
diff --git a/programs/winetest/util.c b/programs/winetest/util.c
index a1320005841..bd5b584c3c4 100644
--- a/programs/winetest/util.c
+++ b/programs/winetest/util.c
@@ -56,6 +56,7 @@ static char *vstrfmtmake (size_t *lenp, const char *fmt, va_list ap)
     char *p;
     int n;
 
+    if (!fmt) fmt = "";
     p = xalloc(size);
     while (1) {
         n = vsnprintf (p, size, fmt, ap);
diff --git a/programs/winhlp32/hlpfile.c b/programs/winhlp32/hlpfile.c
index e8ae723cff0..4fb6853cfe6 100644
--- a/programs/winhlp32/hlpfile.c
+++ b/programs/winhlp32/hlpfile.c
@@ -966,6 +966,7 @@ static BOOL HLPFILE_RtfAddBitmap(struct RtfData* rd, HLPFILE* file, const BYTE*
     const BYTE*         pict_beg;
     BYTE*               alloc = NULL;
     BITMAPINFO*         bi;
+    BITMAPINFO*         new_bi;
     ULONG               off, csz;
     unsigned            nc = 0;
     BOOL                clrImportant = FALSE;
@@ -1013,8 +1014,13 @@ static BOOL HLPFILE_RtfAddBitmap(struct RtfData* rd, HLPFILE* file, const BYTE*
         if (!nc && bi->bmiHeader.biBitCount <= 8)
             nc = 1 << bi->bmiHeader.biBitCount;
 
-        bi = realloc(bi, sizeof(*bi) + nc * sizeof(RGBQUAD));
-        if (!bi) return FALSE;
+        new_bi = realloc(bi, sizeof(*bi) + nc * sizeof(RGBQUAD));
+        if (!new_bi)
+        {
+            free(bi);
+            return FALSE;
+        }
+        bi = new_bi;
         for (i = 0; i < nc; i++)
         {
             bi->bmiColors[i].rgbBlue     = ptr[0];
diff --git a/server/console.c b/server/console.c
index 5f3f50d006f..b64283baf4a 100644
--- a/server/console.c
+++ b/server/console.c
@@ -694,14 +694,16 @@ static void propagate_console_signal( struct console *console,
         set_error( STATUS_INVALID_PARAMETER );
         return;
     }
-    /* FIXME: should support the other events (like CTRL_BREAK) */
-    if (sig != CTRL_C_EVENT)
+    switch (sig)
     {
+    case CTRL_C_EVENT:     csi.signal = SIGINT; break;
+    case CTRL_BREAK_EVENT: csi.signal = SIGQUIT; break;
+    default:
+        /* FIXME: should support the other events */
         set_error( STATUS_NOT_IMPLEMENTED );
         return;
     }
     csi.console = console;
-    csi.signal  = SIGINT;
     csi.group   = group_id;
 
     enum_processes(propagate_console_signal_cb, &csi);
@@ -1181,7 +1183,7 @@ static void console_server_ioctl( struct fd *fd, ioctl_code_t code, struct async
                 return;
             }
             term = server->termios;
-            term.c_lflag &= ~(ECHO | ECHONL | ICANON | IEXTEN);
+            term.c_lflag &= ~(ECHO | ECHONL | ICANON | IEXTEN | ISIG);
             term.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
             term.c_cflag &= ~(CSIZE | PARENB);
             term.c_cflag |= CS8;
diff --git a/server/mach.c b/server/mach.c
index 6051396a1bf..3852bb3ee5b 100644
--- a/server/mach.c
+++ b/server/mach.c
@@ -31,6 +31,9 @@
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
 #endif
+#ifdef HAVE_SYS_SYSCTL_H
+#include <sys/sysctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -74,6 +77,25 @@ static mach_port_t get_process_port( struct process *process )
     return process->trace_data;
 }
 
+static int is_rosetta( void )
+{
+    static int rosetta_status, did_check = 0;
+    if (!did_check)
+    {
+        /* returns 0 for native process or on error, 1 for translated */
+        int ret = 0;
+        size_t size = sizeof(ret);
+        if (sysctlbyname( "sysctl.proc_translated", &ret, &size, NULL, 0 ) == -1)
+            rosetta_status = 0;
+        else
+            rosetta_status = ret;
+
+        did_check = 1;
+    }
+
+    return rosetta_status;
+}
+
 /* initialize the process control mechanism */
 void init_tracing_mechanism(void)
 {
@@ -165,6 +187,14 @@ void get_thread_context( struct thread *thread, context_t *context, unsigned int
     /* all other regs are handled on the client side */
     assert( flags == SERVER_CTX_DEBUG_REGISTERS );
 
+    if (is_rosetta())
+    {
+        /* getting debug registers of a translated process is not supported cross-process, return all zeroes */
+        memset( &context->debug, 0, sizeof(context->debug) );
+        context->flags |= SERVER_CTX_DEBUG_REGISTERS;
+        return;
+    }
+
     if (thread->unix_pid == -1 || !process_port ||
         mach_port_extract_right( process_port, thread->unix_tid,
                                  MACH_MSG_TYPE_COPY_SEND, &port, &type ))
@@ -251,6 +281,15 @@ void set_thread_context( struct thread *thread, const context_t *context, unsign
         return;
     }
 
+    if (is_rosetta())
+    {
+        /* Setting debug registers of a translated process is not supported cross-process
+         * (and even in-process, setting debug registers never has the desired effect).
+         */
+        set_error( STATUS_UNSUCCESSFUL );
+        return;
+    }
+
     /* get the debug state to determine which flavor to use */
     ret = thread_get_state(port, x86_DEBUG_STATE, (thread_state_t)&state, &count);
     if (ret)
diff --git a/server/mapping.c b/server/mapping.c
index 8d4332d240f..ed81a718bbe 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -1212,7 +1212,7 @@ DECL_HANDLER(map_view)
     if (!req->mapping)  /* image mapping for a .so dll */
     {
         if (get_req_data_size() > sizeof(view->image)) namelen = get_req_data_size() - sizeof(view->image);
-        if (!(view = mem_alloc( offsetof( struct memory_view, name[namelen] )))) return;
+        if (!(view = mem_alloc( sizeof(struct memory_view) + namelen * sizeof(WCHAR) ))) return;
         memset( view, 0, sizeof(*view) );
         view->base    = req->base;
         view->size    = req->size;
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 3e6cf09d4f2..9a10c2bf041 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -1403,12 +1403,25 @@ DECL_HANDLER(create_named_pipe)
         if (!(root = get_handle_obj( current->process, objattr->rootdir, 0, NULL ))) return;
     }
 
-    pipe = create_named_object( root, &named_pipe_ops, &name, objattr->attributes | OBJ_OPENIF, NULL );
+    switch (req->disposition)
+    {
+    case FILE_OPEN:
+        pipe = open_named_object( root, &named_pipe_ops, &name, objattr->attributes );
+        break;
+    case FILE_CREATE:
+    case FILE_OPEN_IF:
+        pipe = create_named_object( root, &named_pipe_ops, &name, objattr->attributes | OBJ_OPENIF, NULL );
+        break;
+    default:
+        pipe = NULL;
+        set_error( STATUS_INVALID_PARAMETER );
+        break;
+    }
 
     if (root) release_object( root );
     if (!pipe) return;
 
-    if (get_error() != STATUS_OBJECT_NAME_EXISTS)
+    if (get_error() != STATUS_OBJECT_NAME_EXISTS && req->disposition != FILE_OPEN)
     {
         /* initialize it if it didn't already exist */
         pipe->instances = 0;
@@ -1424,6 +1437,7 @@ DECL_HANDLER(create_named_pipe)
                                                 GROUP_SECURITY_INFORMATION |
                                                 DACL_SECURITY_INFORMATION |
                                                 SACL_SECURITY_INFORMATION );
+        reply->created = 1;
     }
     else
     {
@@ -1433,7 +1447,7 @@ DECL_HANDLER(create_named_pipe)
             release_object( pipe );
             return;
         }
-        if (pipe->sharing != req->sharing)
+        if (pipe->sharing != req->sharing || req->disposition == FILE_CREATE)
         {
             set_error( STATUS_ACCESS_DENIED );
             release_object( pipe );
diff --git a/server/protocol.def b/server/protocol.def
index 8c2fbeb4afe..69888fa643e 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2270,6 +2270,7 @@ enum message_type
     unsigned int   access;
     unsigned int   options;
     unsigned int   sharing;
+    unsigned int   disposition;
     unsigned int   maxinstances;
     unsigned int   outsize;
     unsigned int   insize;
@@ -2278,6 +2279,7 @@ enum message_type
     VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
     obj_handle_t   handle;       /* handle to the pipe */
+    int            created;
 @END
 
 /* flags in create_named_pipe and get_named_pipe_info */
diff --git a/server/request.h b/server/request.h
index 089af79e199..10b877b1deb 100644
--- a/server/request.h
+++ b/server/request.h
@@ -1451,13 +1451,15 @@ C_ASSERT( sizeof(struct set_irp_result_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, options) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, sharing) == 20 );
-C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, maxinstances) == 24 );
-C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, outsize) == 28 );
-C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, insize) == 32 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, disposition) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, maxinstances) == 28 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, outsize) == 32 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, insize) == 36 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, timeout) == 40 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, flags) == 48 );
 C_ASSERT( sizeof(struct create_named_pipe_request) == 56 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_reply, created) == 12 );
 C_ASSERT( sizeof(struct create_named_pipe_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_named_pipe_info_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_named_pipe_info_request, flags) == 16 );
diff --git a/server/sock.c b/server/sock.c
index a64cb22404e..088e6d63079 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -39,6 +39,9 @@
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
+#ifdef HAVE_NETINET_TCP_H
+# include <netinet/tcp.h>
+#endif
 #include <poll.h>
 #include <sys/time.h>
 #include <sys/types.h>
@@ -1921,9 +1924,12 @@ static int init_socket( struct sock *sock, int family, int type, int protocol )
 
     if (is_tcp_socket( sock ))
     {
-        int reuse = 1;
-
-        setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse) );
+        value = 1;
+        setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &value, sizeof(value) );
+#ifdef TCP_SYNCNT
+        value = 4;
+        setsockopt( sockfd, IPPROTO_TCP, TCP_SYNCNT, &value, sizeof(value) );
+#endif
     }
 
     if (sock->fd)
@@ -2602,6 +2608,17 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
             unix_addr.in.sin_addr.s_addr = htonl( INADDR_LOOPBACK );
 
         ret = connect( unix_fd, &unix_addr.addr, unix_len );
+        if (ret < 0 && errno == ECONNABORTED)
+        {
+            /* On Linux with nonblocking socket if the previous connect() failed for any reason (including
+             * timeout), next connect will fail. If the error code was queried by getsockopt( SO_ERROR )
+             * the error code returned now is ECONNABORTED (otherwise that is the actual connect() failure
+             * error code). If we got here after previous connect attempt on the socket that means
+             * we already queried SO_ERROR in sock_error(), so retrying on ECONNABORTED only is
+             * sufficient. */
+            ret = connect( unix_fd, &unix_addr.addr, unix_len );
+        }
+
         if (ret < 0 && errno != EINPROGRESS)
         {
             set_error( sock_get_ntstatus( errno ) );
diff --git a/server/trace.c b/server/trace.c
index a0076d5449b..b63bc386ee8 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -2861,6 +2861,7 @@ static void dump_create_named_pipe_request( const struct create_named_pipe_reque
     fprintf( stderr, " access=%08x", req->access );
     fprintf( stderr, ", options=%08x", req->options );
     fprintf( stderr, ", sharing=%08x", req->sharing );
+    fprintf( stderr, ", disposition=%08x", req->disposition );
     fprintf( stderr, ", maxinstances=%08x", req->maxinstances );
     fprintf( stderr, ", outsize=%08x", req->outsize );
     fprintf( stderr, ", insize=%08x", req->insize );
@@ -2872,6 +2873,7 @@ static void dump_create_named_pipe_request( const struct create_named_pipe_reque
 static void dump_create_named_pipe_reply( const struct create_named_pipe_reply *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", created=%d", req->created );
 }
 
 static void dump_set_named_pipe_info_request( const struct set_named_pipe_info_request *req )
diff --git a/tools/gitlab/build-linux b/tools/gitlab/build-linux
index 659ff0a0c17..d77ca9cdb8e 100755
--- a/tools/gitlab/build-linux
+++ b/tools/gitlab/build-linux
@@ -7,7 +7,7 @@ set -Eeuxo pipefail
 
 ./tools/make_requests
 ./tools/make_makefiles
-autoreconf
+autoreconf -f
 
 cd build64
 ../configure -q -C --enable-win64 --enable-werror --with-mingw
diff --git a/tools/gitlab/build-mac b/tools/gitlab/build-mac
index 20c1054150e..5c37aa6bcc9 100755
--- a/tools/gitlab/build-mac
+++ b/tools/gitlab/build-mac
@@ -7,7 +7,7 @@ set -Eeuxo pipefail
 
 ./tools/make_requests
 ./tools/make_makefiles
-autoreconf
+autoreconf -f
 
 cd build64
 ../configure -C --enable-win64 --with-mingw BISON=/usr/local/opt/bison/bin/bison
diff --git a/tools/gitlab/release.yml b/tools/gitlab/release.yml
index 9a09e654513..b7af1daa86a 100644
--- a/tools/gitlab/release.yml
+++ b/tools/gitlab/release.yml
@@ -17,6 +17,5 @@ create-release:
     - release-cli create
         --name "Wine $VERSION"
         --tag-name "$CI_COMMIT_TAG"
-        --released-at "$CI_COMMIT_TIMESTAMP"
         --description announce.md
         --assets-link "{\"name\":\"Source code\",\"url\":\"$URL\",\"link_type\":\"other\",\"filepath\":\"$FILEPATH\"}"
diff --git a/tools/gitlab/test.yml b/tools/gitlab/test.yml
index da34390bc1f..808c825eae9 100644
--- a/tools/gitlab/test.yml
+++ b/tools/gitlab/test.yml
@@ -42,6 +42,18 @@
     - wine wineboot.exe -u
     - wineserver -w
 
+test-linux-64:
+  extends: .wine-test
+  variables:
+    INCLUDE_TESTS: "dinput"
+  rules:
+    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
+  needs:
+    - job: build-linux
+  script:
+    - export WINETEST_COLOR=1
+    - wine usr/local/lib/wine/x86_64-windows/winetest.exe -q -q -o - -t gitlab -u $CI_JOB_URL $INCLUDE_TESTS
+
 test-linux-32:
   extends: .wine-test
   variables:
diff --git a/tools/make_xftmpl.c b/tools/make_xftmpl.c
index d707dc06cd2..087020cdb99 100644
--- a/tools/make_xftmpl.c
+++ b/tools/make_xftmpl.c
@@ -20,7 +20,6 @@
 
 #include "config.h"
 
-#include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -478,11 +477,7 @@ int main(int argc, char **argv)
     } else {
         output_file = option_outfile_name;
         atexit(cleanup_files);
-        signal(SIGTERM, exit_on_signal);
-        signal(SIGINT, exit_on_signal);
-#ifdef SIGHUP
-        signal(SIGHUP, exit_on_signal);
-#endif
+        init_signals( exit_on_signal );
         if (!(outfile = fopen(output_file, "wb"))) {
             perror(option_outfile_name);
             goto error;
diff --git a/tools/makedep.c b/tools/makedep.c
index 6379b5b69d9..b632cb68978 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -27,7 +27,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
-#include <signal.h>
 #include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -158,6 +157,7 @@ static const char *icotool;
 static const char *msgfmt;
 static const char *ln_s;
 static const char *sed_cmd;
+static const char *wayland_scanner;
 /* per-architecture global variables */
 static const char *arch_dirs[MAX_ARCHS];
 static const char *arch_pe_dirs[MAX_ARCHS];
@@ -472,6 +472,15 @@ static char *replace_filename( const char *path, const char *name )
     return ret;
 }
 
+/*******************************************************************
+ *         get_filename
+ */
+static char *get_filename( const char *name )
+{
+    char *filename = strrchr( name, '/' );
+    if (!filename) return xstrdup( name );
+    return xstrdup( filename + 1 );
+}
 
 /*******************************************************************
  *         replace_substr
@@ -1391,6 +1400,35 @@ static struct file *open_src_file( const struct makefile *make, struct incl_file
     return file;
 }
 
+/*******************************************************************
+ *         open_wayland_protocol_file
+ */
+static struct file *open_wayland_protocol_file( const struct makefile *make,
+                                                struct incl_file *pFile )
+{
+    char *proto_filename;
+    struct incl_file *incl_file;
+    struct file *ret_file = NULL;
+
+    if (!strendswith( pFile->name, "-client-protocol.h" )) return NULL;
+
+    proto_filename = replace_extension( pFile->name, "-client-protocol.h", ".xml" );
+
+    LIST_FOR_EACH_ENTRY( incl_file, &make->sources, struct incl_file, entry )
+    {
+        if (strendswith( incl_file->name, proto_filename ))
+        {
+            pFile->sourcename = incl_file->filename;
+            pFile->filename = obj_dir_path( make, pFile->name );
+            ret_file = incl_file->file;
+            break;
+        }
+    }
+
+    free( proto_filename );
+
+    return ret_file;
+}
 
 /*******************************************************************
  *         find_importlib_module
@@ -1430,6 +1468,7 @@ static struct file *open_include_file( const struct makefile *make, struct incl_
         if ((file = open_local_generated_file( make, pFile, ".cur", ".svg" ))) return file;
         if ((file = open_local_generated_file( make, pFile, ".ico", ".svg" ))) return file;
     }
+    if ((file = open_wayland_protocol_file( make, pFile ))) return file;
 
     /* check for extra targets */
     if (strarray_exists( &make->extra_targets, pFile->name ))
@@ -1804,6 +1843,15 @@ static struct makefile *parse_makefile( const char *path )
     return make;
 }
 
+/*******************************************************************
+ *         is_wayland_protocol
+ */
+static int is_wayland_protocol( struct incl_file *source )
+{
+    return strendswith( source->name, ".xml" ) &&
+           (strstr( source->name, "stable/" ) || strstr( source->name, "unstable/" ) ||
+            strstr( source->name, "staging/" ));
+}
 
 /*******************************************************************
  *         add_generated_sources
@@ -1917,6 +1965,23 @@ static void add_generated_sources( struct makefile *make )
             strarray_addall_uniq( &make->extra_imports,
                                   get_expanded_file_local_var( make, obj, "IMPORTS" ));
         }
+        if (is_wayland_protocol( source ))
+        {
+            char *filename = get_filename( source->name );
+            char *code_filename = replace_extension ( filename , ".xml", "-protocol.c" );
+            char *header_filename = replace_extension ( filename , ".xml", "-client-protocol.h" );
+
+            file = add_generated_source( make, code_filename, NULL, 0 );
+            file->file->flags |= FLAG_C_UNIX;
+            file->use_msvcrt = 0;
+            file = add_generated_source( make, header_filename, NULL, 0 );
+            file->file->flags |= FLAG_C_UNIX;
+            file->use_msvcrt = 0;
+
+            free( filename );
+            free( code_filename );
+            free( header_filename );
+        }
     }
     if (make->testdll)
     {
@@ -2745,7 +2810,8 @@ static void output_source_rc( struct makefile *make, struct incl_file *source, c
     if (source->file->flags & FLAG_RC_HEADER) return;
     if (source->file->flags & FLAG_GENERATED) strarray_add( &make->clean_files, source->name );
     if (linguas.count && (source->file->flags & FLAG_RC_PO)) po_dir = "po";
-    for (arch = 0; arch < archs.count; arch++) strarray_add( &make->res_files[arch], res_file );
+    for (arch = 0; arch < archs.count; arch++)
+        if (!make->disabled[arch]) strarray_add( &make->res_files[arch], res_file );
     if (source->file->flags & FLAG_RC_PO)
     {
         strarray_add( &make->pot_files, strmake( "%s.pot", obj ));
@@ -2782,7 +2848,8 @@ static void output_source_mc( struct makefile *make, struct incl_file *source, c
     char *obj_path = obj_dir_path( make, obj );
     char *res_file = strmake( "%s.res", obj );
 
-    for (arch = 0; arch < archs.count; arch++) strarray_add( &make->res_files[arch], res_file );
+    for (arch = 0; arch < archs.count; arch++)
+        if (!make->disabled[arch]) strarray_add( &make->res_files[arch], res_file );
     strarray_add( &make->pot_files, strmake( "%s.pot", obj ));
     output( "%s.pot %s.res: %s", obj_path, obj_path, source->filename );
     output_filename( tools_path( make, "wmc" ));
@@ -2807,6 +2874,7 @@ static void output_source_mc( struct makefile *make, struct incl_file *source, c
  */
 static void output_source_res( struct makefile *make, struct incl_file *source, const char *obj )
 {
+    if (make->disabled[source->arch]) return;
     strarray_add( &make->res_files[source->arch], source->name );
 }
 
@@ -2818,6 +2886,7 @@ static void output_source_idl( struct makefile *make, struct incl_file *source,
 {
     struct strarray defines = get_source_defines( make, source, obj );
     struct strarray headers = empty_strarray;
+    struct strarray deps = empty_strarray;
     struct strarray multiarch_targets[MAX_ARCHS] = { empty_strarray };
     const char *dest;
     unsigned int i, arch;
@@ -2847,6 +2916,7 @@ static void output_source_idl( struct makefile *make, struct incl_file *source,
         for (arch = 0; arch < archs.count; arch++)
         {
             if (!is_multiarch( arch )) continue;
+            if (make->disabled[arch]) continue;
             dest = strmake( "%s%s%s", arch_dirs[arch], obj, idl_outputs[i].ext );
             if (!find_src_file( make, dest )) strarray_add( &make->clean_files, dest );
             strarray_add( &multiarch_targets[arch], dest );
@@ -2855,9 +2925,12 @@ static void output_source_idl( struct makefile *make, struct incl_file *source,
 
     for (arch = 0; arch < archs.count; arch++)
     {
-        if (multiarch_targets[arch].count + (arch ? 0 : headers.count) == 0) continue;
-        if (!arch) output_filenames_obj_dir( make, headers );
-        output_filenames_obj_dir( make, multiarch_targets[arch] );
+        struct strarray arch_deps = empty_strarray;
+
+        if (!arch) strarray_addall( &arch_deps, headers );
+        strarray_addall( &arch_deps, multiarch_targets[arch] );
+        if (!arch_deps.count) continue;
+        output_filenames_obj_dir( make, arch_deps );
         output( ":\n" );
         output( "\t%s%s -o $@", cmd_prefix( "WIDL" ), tools_path( make, "widl" ) );
         output_filenames( target_flags[arch] );
@@ -2868,15 +2941,18 @@ static void output_source_idl( struct makefile *make, struct incl_file *source,
         output_filenames( get_expanded_file_local_var( make, obj, "EXTRAIDLFLAGS" ));
         output_filename( source->filename );
         output( "\n" );
+        strarray_addall( &deps, arch_deps );
     }
 
-    output_filenames_obj_dir( make, headers );
-    for (arch = 0; arch < archs.count; arch++) output_filenames_obj_dir( make, multiarch_targets[arch] );
-    output( ":" );
-    output_filename( tools_path( make, "widl" ));
-    output_filename( source->filename );
-    output_filenames( source->dependencies );
-    output( "\n" );
+    if (deps.count)
+    {
+        output_filenames_obj_dir( make, deps );
+        output( ":" );
+        output_filename( tools_path( make, "widl" ));
+        output_filename( source->filename );
+        output_filenames( source->dependencies );
+        output( "\n" );
+    }
 
     if (source->importlibdeps.count)
     {
@@ -3115,6 +3191,19 @@ static void output_source_spec( struct makefile *make, struct incl_file *source,
     }
 }
 
+static void output_source_xml( struct makefile *make, struct incl_file *source, const char *obj )
+{
+    char *base;
+
+    if (!is_wayland_protocol( source )) return;
+
+    base = get_filename( obj );
+    output( "%s-protocol.c: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s private-code $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner );
+    output( "%s-client-protocol.h: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s client-header $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner);
+    free( base );
+}
 
 /*******************************************************************
  *         output_source_one_arch
@@ -3125,6 +3214,8 @@ static void output_source_one_arch( struct makefile *make, struct incl_file *sou
 {
     const char *obj_name;
 
+    if (make->disabled[arch] && !(source->file->flags & FLAG_C_IMPLIB)) return;
+
     if (arch)
     {
         if (source->file->flags & FLAG_C_UNIX) return;
@@ -3252,6 +3343,7 @@ static const struct
     { "in", output_source_in },
     { "x", output_source_x },
     { "spec", output_source_spec },
+    { "xml", output_source_xml },
     { NULL, output_source_default }
 };
 
@@ -3264,6 +3356,8 @@ static void output_fake_module( struct makefile *make )
     unsigned int arch = 0;  /* fake modules are always native */
     const char *spec_file = NULL, *name = strmake( "%s%s", arch_pe_dirs[arch], make->module );
 
+    if (make->disabled[arch]) return;
+
     if (!make->is_exe) spec_file = src_dir_path( make, replace_extension( make->module, ".dll", ".spec" ));
 
     strarray_add( &make->all_targets[arch], name );
@@ -3302,6 +3396,8 @@ static void output_module( struct makefile *make, unsigned int arch )
     char *spec_file = NULL;
     unsigned int i;
 
+    if (make->disabled[arch]) return;
+
     if (!make->is_exe) spec_file = src_dir_path( make, replace_extension( make->module, ".dll", ".spec" ));
 
     if (!make->data_only)
@@ -3407,6 +3503,8 @@ static void output_unix_lib( struct makefile *make )
     struct strarray unix_libs = add_unix_libraries( make, &unix_deps );
     unsigned int arch = 0;  /* unix libs are always native */
 
+    if (make->disabled[arch]) return;
+
     strarray_add( &make->all_targets[arch], make->unixlib );
     add_install_rule( make, make->module, arch, make->unixlib,
                       strmake( "p%s%s", arch_install_dirs[arch], make->unixlib ));
@@ -3540,6 +3638,11 @@ static void output_test_module( struct makefile *make, unsigned int arch )
     output( "\t%secho \"%s_test.exe TESTRES \\\"%s\\\"\" | %s -u -o $@\n", cmd_prefix( "WRC" ),
             basemodule, obj_dir_path( make, stripped ), tools_path( make, "wrc" ));
 
+    if (make->disabled[arch] || (parent && parent->disabled[arch]))
+    {
+        make->ok_files = empty_strarray;
+        return;
+    }
     output_filenames_obj_dir( make, make->ok_files );
     output( ": %s", obj_dir_path( make, testmodule ));
     if (parent)
@@ -3550,8 +3653,7 @@ static void output_test_module( struct makefile *make, unsigned int arch )
     }
     output( "\n" );
     output( "%s %s:", obj_dir_path( make, "check" ), obj_dir_path( make, "test" ));
-    if (!make->disabled[arch] && parent && !parent->disabled[arch])
-        output_filenames_obj_dir( make, make->ok_files );
+    output_filenames_obj_dir( make, make->ok_files );
     output( "\n" );
     strarray_add_uniq( &make->phony_targets, obj_dir_path( make, "check" ));
     strarray_add_uniq( &make->phony_targets, obj_dir_path( make, "test" ));
@@ -4041,16 +4143,6 @@ static void output_stub_makefile( struct makefile *make )
     const char *make_var = strarray_get_value( &top_makefile->vars, "MAKE" );
     unsigned int i, arch;
 
-    if (make->obj_dir) create_dir( make->obj_dir );
-
-    output_file_name = obj_dir_path( make, "Makefile" );
-    output_file = create_temp_file( output_file_name );
-
-    output( "# Auto-generated stub makefile; all rules forward to the top-level makefile\n\n" );
-
-    if (make_var) output( "MAKE = %s\n\n", make_var );
-    output( "all:\n" );
-
     for (arch = 0; arch < archs.count; arch++)
         if (make->all_targets[arch].count) strarray_add_uniq( &targets, "all" );
 
@@ -4068,6 +4160,16 @@ static void output_stub_makefile( struct makefile *make )
         strarray_add( &targets, "testclean" );
     }
 
+    if (!targets.count && !make->clean_files.count) return;
+
+    output_file_name = obj_dir_path( make, "Makefile" );
+    output_file = create_temp_file( output_file_name );
+
+    output( "# Auto-generated stub makefile; all rules forward to the top-level makefile\n\n" );
+
+    if (make_var) output( "MAKE = %s\n\n", make_var );
+
+    output( "all:\n" );
     output_filenames( targets );
     output_filenames( make->clean_files );
     output( ":\n" );
@@ -4099,6 +4201,7 @@ static void output_silent_rules(void)
         "MSG",
         "SED",
         "TEST",
+        "WAYLAND_SCANNER",
         "WIDL",
         "WMC",
         "WRC"
@@ -4198,6 +4301,7 @@ static void load_sources( struct makefile *make )
         "IN_SRCS",
         "PO_SRCS",
         "MANPAGES",
+        "WAYLAND_PROTOCOL_SRCS",
         NULL
     };
     const char **var;
@@ -4395,11 +4499,7 @@ int main( int argc, char *argv[] )
     if (argc > 1) fatal_error( "Directory arguments not supported in this mode\n" );
 
     atexit( cleanup_files );
-    signal( SIGTERM, exit_on_signal );
-    signal( SIGINT, exit_on_signal );
-#ifdef SIGHUP
-    signal( SIGHUP, exit_on_signal );
-#endif
+    init_signals( exit_on_signal );
 
     for (i = 0; i < HASH_SIZE; i++) list_init( &files[i] );
     for (i = 0; i < HASH_SIZE; i++) list_init( &global_includes[i] );
@@ -4433,6 +4533,7 @@ int main( int argc, char *argv[] )
     msgfmt             = get_expanded_make_variable( top_makefile, "MSGFMT" );
     sed_cmd            = get_expanded_make_variable( top_makefile, "SED_CMD" );
     ln_s               = get_expanded_make_variable( top_makefile, "LN_S" );
+    wayland_scanner    = get_expanded_make_variable( top_makefile, "WAYLAND_SCANNER" );
 
     if (root_src_dir && !strcmp( root_src_dir, "." )) root_src_dir = NULL;
     if (tools_dir && !strcmp( tools_dir, "." )) tools_dir = NULL;
diff --git a/tools/sfnt2fon/sfnt2fon.c b/tools/sfnt2fon/sfnt2fon.c
index b5a2086cac1..2c307dcce8a 100644
--- a/tools/sfnt2fon/sfnt2fon.c
+++ b/tools/sfnt2fon/sfnt2fon.c
@@ -23,7 +23,6 @@
 #include <assert.h>
 #include <ctype.h>
 #include <errno.h>
-#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 
@@ -912,11 +911,7 @@ int main(int argc, char **argv)
     font_off = (fontdir_off + fontdir_len + 15) & ~0x0f;
 
     atexit( cleanup );
-    signal( SIGTERM, exit_on_signal );
-    signal( SIGINT, exit_on_signal );
-#ifdef SIGHUP
-    signal( SIGHUP, exit_on_signal );
-#endif
+    init_signals( exit_on_signal );
 
     if (!output_name)  /* build a default output name */
         output_name = strmake( "%s%s", get_basename_noext( input_file ),
diff --git a/tools/tools.h b/tools/tools.h
index 456633e4277..fa459994eb3 100644
--- a/tools/tools.h
+++ b/tools/tools.h
@@ -21,15 +21,24 @@
 #ifndef __WINE_TOOLS_H
 #define __WINE_TOOLS_H
 
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <signal.h>
 #include <fcntl.h>
 #include <time.h>
 #include <errno.h>
+#ifdef HAVE_SYS_SYSCTL_H
+# include <sys/sysctl.h>
+#endif
 
 #ifdef _WIN32
 # include <direct.h>
@@ -322,6 +331,7 @@ static inline char *replace_extension( const char *name, const char *old_ext, co
 /* temp files management */
 
 extern const char *temp_dir;
+extern struct strarray temp_files;
 
 static inline char *make_temp_dir(void)
 {
@@ -348,10 +358,11 @@ static inline char *make_temp_dir(void)
     exit(1);
 }
 
-static inline int make_temp_file( const char *prefix, const char *suffix, char **name )
+static inline char *make_temp_file( const char *prefix, const char *suffix )
 {
     static unsigned int value;
     int fd, count;
+    char *name;
 
     if (!temp_dir) temp_dir = make_temp_dir();
     if (!suffix) suffix = "";
@@ -360,15 +371,50 @@ static inline int make_temp_file( const char *prefix, const char *suffix, char *
 
     for (count = 0; count < 0x8000; count++)
     {
-        *name = strmake( "%s/%s-%08x%s", temp_dir, prefix, value++, suffix );
-        fd = open( *name, O_RDWR | O_CREAT | O_EXCL, 0600 );
-        if (fd >= 0) return fd;
-        free( *name );
+        name = strmake( "%s/%s-%08x%s", temp_dir, prefix, value++, suffix );
+        fd = open( name, O_RDWR | O_CREAT | O_EXCL, 0600 );
+        if (fd >= 0)
+        {
+#ifdef HAVE_SIGPROCMASK /* block signals while manipulating the temp files list */
+            sigset_t mask_set, old_set;
+
+            sigemptyset( &mask_set );
+            sigaddset( &mask_set, SIGHUP );
+            sigaddset( &mask_set, SIGTERM );
+            sigaddset( &mask_set, SIGINT );
+            sigprocmask( SIG_BLOCK, &mask_set, &old_set );
+            strarray_add( &temp_files, name );
+            sigprocmask( SIG_SETMASK, &old_set, NULL );
+#else
+            strarray_add( &temp_files, name );
+#endif
+            close( fd );
+            return name;
+        }
+        free( name );
     }
     fprintf( stderr, "failed to create temp file for %s%s in %s\n", prefix, suffix, temp_dir );
     exit(1);
 }
 
+static inline void remove_temp_files(void)
+{
+    unsigned int i;
+
+    for (i = 0; i < temp_files.count; i++) if (temp_files.str[i]) unlink( temp_files.str[i] );
+    if (temp_dir) rmdir( temp_dir );
+}
+
+
+static inline void init_signals( void (*cleanup)(int) )
+{
+    signal( SIGTERM, cleanup );
+    signal( SIGINT, cleanup );
+#ifdef SIGHUP
+    signal( SIGHUP, cleanup );
+#endif
+}
+
 
 static inline void *read_file( const char *name, size_t *size )
 {
@@ -603,6 +649,29 @@ static inline struct target init_argv0_target( const char *argv0 )
 }
 
 
+static inline char *get_argv0_dir( const char *argv0 )
+{
+#ifndef _WIN32
+    char *dir = NULL;
+
+#if defined(__linux__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
+    dir = realpath( "/proc/self/exe", NULL );
+#elif defined (__FreeBSD__) || defined(__DragonFly__)
+    static int pathname[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+    size_t path_size = PATH_MAX;
+    char *path = xmalloc( path_size );
+    if (!sysctl( pathname, ARRAY_SIZE(pathname), path, &path_size, NULL, 0 ))
+        dir = realpath( path, NULL );
+    free( path );
+#endif
+    if (!dir && !(dir = realpath( argv0, NULL ))) return NULL;
+    return get_dirname( dir );
+#else
+    return get_dirname( argv0 );
+#endif
+}
+
+
 /* output buffer management */
 
 extern unsigned char *output_buffer;
diff --git a/tools/widl/parser.l b/tools/widl/parser.l
index 9286a494d4d..8412ca7c64e 100644
--- a/tools/widl/parser.l
+++ b/tools/widl/parser.l
@@ -509,11 +509,6 @@ void pop_import(void)
 	fclose(yyin);
 	yy_delete_buffer( YY_CURRENT_BUFFER );
 	yy_switch_to_buffer( import_stack[ptr].state );
-	if (temp_name) {
-		unlink(temp_name);
-		free(temp_name);
-	}
-	temp_name = import_stack[ptr].temp_name;
 	input_name = import_stack[ptr].input_name;
 	line_number = import_stack[ptr].line_number;
 	import_stack_ptr--;
@@ -530,7 +525,7 @@ int do_import(char *fname)
     char *path, *name;
     struct imports *import;
     int ptr = import_stack_ptr;
-    int ret, fd;
+    int ret;
 
     import = first_import;
     while (import && strcmp(import->name, fname))
@@ -552,24 +547,22 @@ int do_import(char *fname)
     if (import_stack_ptr == MAX_IMPORT_DEPTH)
         error_loc("Exceeded max import depth\n");
 
-    import_stack[ptr].temp_name = temp_name;
     import_stack[ptr].input_name = input_name;
     import_stack[ptr].line_number = line_number;
     import_stack_ptr++;
     input_name = path;
     line_number = 1;
 
-    fd = make_temp_file( "widl-pp", NULL, &name );
-    temp_name = name;
-    if (!(f = fdopen(fd, "wt")))
+    name = make_temp_file( "widl-pp", NULL );
+    if (!(f = fopen(name, "wt")))
         error("Could not open fd %s for writing\n", name);
 
     ret = wpp_parse( path, f );
     fclose( f );
     if (ret) exit(1);
 
-    if((f = fopen(temp_name, "r")) == NULL)
-        error_loc("Unable to open %s\n", temp_name);
+    if((f = fopen(name, "r")) == NULL)
+        error_loc("Unable to open %s\n", name);
 
     import_stack[ptr].state = YY_CURRENT_BUFFER;
     yy_switch_to_buffer(yy_create_buffer(f, YY_BUF_SIZE));
@@ -587,7 +580,7 @@ void abort_import(void)
 static void switch_to_acf(void)
 {
     int ptr = import_stack_ptr;
-    int ret, fd;
+    int ret;
     char *name;
     FILE *f;
 
@@ -597,17 +590,16 @@ static void switch_to_acf(void)
     acf_name = NULL;
     line_number = 1;
 
-    fd = make_temp_file( "widl-acf", NULL, &name );
-    temp_name = name;
-    if (!(f = fdopen(fd, "wt")))
+    name = make_temp_file( "widl-acf", NULL );
+    if (!(f = fopen(name, "wt")))
         error("Could not open fd %s for writing\n", name);
 
     ret = wpp_parse(input_name, f);
     fclose(f);
     if (ret) exit(1);
 
-    if((f = fopen(temp_name, "r")) == NULL)
-        error_loc("Unable to open %s\n", temp_name);
+    if((f = fopen(name, "r")) == NULL)
+        error_loc("Unable to open %s\n", name);
 
     import_stack[ptr].state = YY_CURRENT_BUFFER;
     yy_switch_to_buffer(yy_create_buffer(f, YY_BUF_SIZE));
diff --git a/tools/widl/widl.c b/tools/widl/widl.c
index 79d895b52bf..7d3fa26f8d0 100644
--- a/tools/widl/widl.c
+++ b/tools/widl/widl.c
@@ -28,12 +28,8 @@
 #include <string.h>
 #include <assert.h>
 #include <ctype.h>
-#include <signal.h>
 #include <limits.h>
 #include <sys/types.h>
-#ifdef HAVE_SYS_SYSCTL_H
-# include <sys/sysctl.h>
-#endif
 
 #include "widl.h"
 #include "utils.h"
@@ -134,7 +130,7 @@ char *server_token;
 char *regscript_name;
 char *regscript_token;
 static char *idfile_name;
-char *temp_name;
+struct strarray temp_files = { 0 };
 const char *temp_dir = NULL;
 const char *prefix_client = "";
 const char *prefix_server = "";
@@ -482,25 +478,11 @@ void write_id_data(const statement_list_t *stmts)
 
 static void init_argv0_dir( const char *argv0 )
 {
-#ifndef _WIN32
-    char *dir;
-
-#if defined(__linux__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
-    dir = realpath( "/proc/self/exe", NULL );
-#elif defined (__FreeBSD__) || defined(__DragonFly__)
-    static int pathname[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
-    size_t path_size = PATH_MAX;
-    char *path = xmalloc( path_size );
-    if (!sysctl( pathname, ARRAY_SIZE(pathname), path, &path_size, NULL, 0 ))
-        dir = realpath( path, NULL );
-    free( path );
-#else
-    dir = realpath( argv0, NULL );
-#endif
+    char *dir = get_argv0_dir( argv0 );
+
     if (!dir) return;
-    includedir = strmake( "%s/%s", get_dirname( dir ), BIN_TO_INCLUDEDIR );
-    dlldir = strmake( "%s/%s", get_dirname( dir ), BIN_TO_DLLDIR );
-#endif
+    includedir = strmake( "%s/%s", dir, BIN_TO_INCLUDEDIR );
+    dlldir = strmake( "%s/%s", dir, BIN_TO_DLLDIR );
 }
 
 static void option_callback( int optc, char *optarg )
@@ -719,12 +701,9 @@ int main(int argc,char *argv[])
   int i;
   int ret = 0;
   struct strarray files;
+  char *input;
 
-  signal( SIGTERM, exit_on_signal );
-  signal( SIGINT, exit_on_signal );
-#ifdef SIGHUP
-  signal( SIGHUP, exit_on_signal );
-#endif
+  init_signals( exit_on_signal );
   init_argv0_dir( argv[0] );
   target = init_argv0_target( argv[0] );
 
@@ -856,6 +835,7 @@ int main(int argc,char *argv[])
   wpp_add_cmdline_define("_WIN32=1");
 
   atexit(rm_tempfile);
+  input = input_name;
   if (!no_preprocess)
   {
     chat("Starting preprocess\n");
@@ -863,16 +843,14 @@ int main(int argc,char *argv[])
     if (!preprocess_only)
     {
         FILE *output;
-        int fd;
-        char *name;
+        char *name = make_temp_file( header_name, NULL );
 
-        fd = make_temp_file( header_name, NULL, &name );
-        temp_name = name;
-        if (!(output = fdopen(fd, "wt")))
+        if (!(output = fopen(name, "wt")))
             error("Could not open fd %s for writing\n", name);
 
         ret = wpp_parse( input_name, output );
         fclose( output );
+        input = name;
     }
     else
     {
@@ -881,16 +859,11 @@ int main(int argc,char *argv[])
 
     if(ret) exit(1);
     if(preprocess_only) exit(0);
-    if(!(parser_in = fopen(temp_name, "r"))) {
-      fprintf(stderr, "Could not open %s for input\n", temp_name);
-      return 1;
-    }
   }
-  else {
-    if(!(parser_in = fopen(input_name, "r"))) {
-      fprintf(stderr, "Could not open %s for input\n", input_name);
-      return 1;
-    }
+
+  if(!(parser_in = fopen(input, "r"))) {
+    fprintf(stderr, "Could not open %s for input\n", input);
+    return 1;
   }
 
   header_token = make_token(header_name);
@@ -914,8 +887,6 @@ int main(int argc,char *argv[])
 static void rm_tempfile(void)
 {
   abort_import();
-  if(temp_name)
-    unlink(temp_name);
   if (do_header)
     unlink(header_name);
   if (local_stubs_name)
@@ -932,6 +903,5 @@ static void rm_tempfile(void)
     unlink(proxy_name);
   if (do_typelib)
     unlink(typelib_name);
-  if (temp_dir)
-    rmdir(temp_dir);
+  remove_temp_files();
 }
diff --git a/tools/winebuild/build.h b/tools/winebuild/build.h
index 3b5ba0fff2a..733cd34e614 100644
--- a/tools/winebuild/build.h
+++ b/tools/winebuild/build.h
@@ -23,10 +23,6 @@
 #ifndef __WINE_BUILD_H
 #define __WINE_BUILD_H
 
-#ifndef __WINE_CONFIG_H
-# error You must include config.h to use this header
-#endif
-
 #include <stdio.h>
 #include <stdlib.h>
 #include "../tools.h"
@@ -260,8 +256,6 @@ extern struct strarray find_link_tool(void);
 extern struct strarray get_as_command(void);
 extern struct strarray get_ld_command(void);
 extern const char *get_nm_command(void);
-extern void cleanup_tmp_files(void);
-extern char *get_temp_file_name( const char *prefix, const char *suffix );
 extern void output_standard_file_header(void);
 extern FILE *open_input_file( const char *srcdir, const char *name );
 extern void close_input_file( FILE *file );
diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
index ee3c310546b..0c1cd291d21 100644
--- a/tools/winebuild/import.c
+++ b/tools/winebuild/import.c
@@ -28,8 +28,8 @@
 #include <string.h>
 #include <stdarg.h>
 
-#include "wine/list.h"
 #include "build.h"
+#include "wine/list.h"
 
 /* standard C functions that are also exported from ntdll */
 static const char *stdc_names[] =
@@ -627,7 +627,7 @@ static char *create_undef_symbols_file( DLLSPEC *spec )
     output_gnu_stack_note();
     fclose( output_file );
 
-    obj_file = get_temp_file_name( output_file_name, ".o" );
+    obj_file = make_temp_file( output_file_name, ".o" );
     assemble_file( as_file, obj_file );
     return obj_file;
 }
@@ -640,7 +640,7 @@ static const char *ldcombine_files( DLLSPEC *spec, struct strarray files )
     struct strarray args = get_ld_command();
 
     undef_file = create_undef_symbols_file( spec );
-    ld_tmp_file = get_temp_file_name( output_file_name, ".o" );
+    ld_tmp_file = make_temp_file( output_file_name, ".o" );
 
     strarray_add( &args, "-r" );
     strarray_add( &args, "-o" );
@@ -1566,7 +1566,7 @@ static void assemble_files( const char *prefix )
 
     for (i = 0; i < as_files.count; i++)
     {
-        char *obj = get_temp_file_name( prefix, ".o" );
+        char *obj = make_temp_file( prefix, ".o" );
         assemble_file( as_files.str[i], obj );
         as_files.str[i] = obj;
     }
diff --git a/tools/winebuild/main.c b/tools/winebuild/main.c
index aae223f9e57..f216e4bf35d 100644
--- a/tools/winebuild/main.c
+++ b/tools/winebuild/main.c
@@ -26,7 +26,6 @@
 
 #include <assert.h>
 #include <stdio.h>
-#include <signal.h>
 #include <errno.h>
 #include <string.h>
 #include <stdarg.h>
@@ -174,7 +173,7 @@ static void set_target( const char *name )
     target_alias = xstrdup( name );
 
     if (!parse_target( name, &target )) fatal_error( "Unrecognized target '%s'\n", name );
-    if (target.cpu == CPU_ARM && is_pe()) thumb_mode = 1;
+    thumb_mode = target.cpu == CPU_ARM && is_pe();
     if (is_pe()) unwind_tables = 1;
 }
 
@@ -182,6 +181,7 @@ static void set_target( const char *name )
 static void cleanup(void)
 {
     if (output_file_name) unlink( output_file_name );
+    if (!save_temps) remove_temp_files();
 }
 
 /* clean things up when aborting on a signal */
@@ -618,12 +618,7 @@ int main(int argc, char **argv)
     struct strarray files;
     DLLSPEC *spec = main_spec = alloc_dll_spec();
 
-#ifdef SIGHUP
-    signal( SIGHUP, exit_on_signal );
-#endif
-    signal( SIGTERM, exit_on_signal );
-    signal( SIGINT, exit_on_signal );
-
+    init_signals( exit_on_signal );
     target = init_argv0_target( argv[0] );
     if (target.platform == PLATFORM_CYGWIN) target.platform = PLATFORM_MINGW;
     if (is_pe()) unwind_tables = 1;
@@ -631,7 +626,6 @@ int main(int argc, char **argv)
     files = parse_options( argc, argv, short_options, long_options, 0, option_callback );
 
     atexit( cleanup );  /* make sure we remove the output file on exit */
-    if (!save_temps) atexit( cleanup_tmp_files );
 
     if (spec->file_name && !strchr( spec->file_name, '.' ))
         strcat( spec->file_name, exec_mode == MODE_EXE ? ".exe" : ".dll" );
diff --git a/tools/winebuild/res32.c b/tools/winebuild/res32.c
index 80890f55458..676693e178d 100644
--- a/tools/winebuild/res32.c
+++ b/tools/winebuild/res32.c
@@ -44,6 +44,8 @@ struct resource
 {
     struct string_id type;
     struct string_id name;
+    const char      *input_name;
+    unsigned int     input_offset;
     const void      *data;
     unsigned int     data_size;
     unsigned int     data_offset;
@@ -156,28 +158,6 @@ static void put_string( const struct string_id *str )
     }
 }
 
-static void dump_res_data( const struct resource *res )
-{
-    unsigned int i = 0;
-    unsigned int size = (res->data_size + 3) & ~3;
-
-    if (!size) return;
-
-    input_buffer = res->data;
-    input_buffer_pos  = 0;
-    input_buffer_size = size;
-
-    output( "\t.long " );
-    while (size > 4)
-    {
-        if ((i++ % 16) == 15) output( "0x%08x\n\t.long ", get_dword() );
-        else output( "0x%08x,", get_dword() );
-        size -= 4;
-    }
-    output( "0x%08x\n", get_dword() );
-    assert( input_buffer_pos == input_buffer_size );
-}
-
 /* check the file header */
 /* all values must be zero except header size */
 static int check_header(void)
@@ -199,7 +179,7 @@ static int check_header(void)
 }
 
 /* load the next resource from the current file */
-static void load_next_resource( DLLSPEC *spec )
+static void load_next_resource( DLLSPEC *spec, const char *name )
 {
     unsigned int hdr_size;
     struct resource *res = add_resource( spec );
@@ -209,6 +189,9 @@ static void load_next_resource( DLLSPEC *spec )
     if (hdr_size & 3) fatal_error( "%s header size not aligned\n", input_buffer_filename );
     if (hdr_size < 32) fatal_error( "%s invalid header size %u\n", input_buffer_filename, hdr_size );
 
+    res->input_name = xstrdup( name );
+    res->input_offset = input_buffer_pos - 2*sizeof(unsigned int) + hdr_size;
+
     res->data = input_buffer + input_buffer_pos - 2*sizeof(unsigned int) + hdr_size;
     if ((const unsigned char *)res->data < input_buffer ||
         (const unsigned char *)res->data >= input_buffer + input_buffer_size)
@@ -237,7 +220,7 @@ int load_res32_file( const char *name, DLLSPEC *spec )
 
     if ((ret = check_header()))
     {
-        while (input_buffer_pos < input_buffer_size) load_next_resource( spec );
+        while (input_buffer_pos < input_buffer_size) load_next_resource( spec, name );
     }
     return ret;
 }
@@ -490,7 +473,7 @@ void output_resources( DLLSPEC *spec )
     {
         output( "\n\t.align %d\n", get_alignment(4) );
         output( ".L__wine_spec_res_%d:\n", i );
-        dump_res_data( res );
+        output( "\t.incbin \"%s\",%d,%d\n", res->input_name, res->input_offset, res->data_size );
     }
 
     if (!is_pe())
@@ -671,7 +654,7 @@ void output_res_o_file( DLLSPEC *spec )
         return;
     }
 
-    res_file = get_temp_file_name( output_file_name, ".res" );
+    res_file = make_temp_file( output_file_name, ".res" );
     flush_output_buffer( res_file );
 
     args = find_tool( "windres", NULL );
diff --git a/tools/winebuild/utils.c b/tools/winebuild/utils.c
index 22eb60236b0..523f1af7118 100644
--- a/tools/winebuild/utils.c
+++ b/tools/winebuild/utils.c
@@ -30,18 +30,9 @@
 #include "build.h"
 
 const char *temp_dir = NULL;
-static struct strarray tmp_files;
+struct strarray temp_files = { 0 };
 static const char *output_file_source_name;
 
-/* atexit handler to clean tmp files */
-void cleanup_tmp_files(void)
-{
-    unsigned int i;
-    for (i = 0; i < tmp_files.count; i++) if (tmp_files.str[i]) unlink( tmp_files.str[i] );
-    if (temp_dir) rmdir( temp_dir );
-}
-
-
 char *strupper(char *s)
 {
     char *p;
@@ -194,7 +185,7 @@ void spawn( struct strarray args )
 
 static const char *find_clang_tool( struct strarray clang, const char *tool )
 {
-    const char *out = get_temp_file_name( "print_tool", ".out" );
+    const char *out = make_temp_file( "print_tool", ".out" );
     struct strarray args = empty_strarray;
     int sout = -1;
     char *path, *p;
@@ -406,18 +397,6 @@ const char *get_nm_command(void)
     return nm_command.str[0];
 }
 
-/* get a name for a temp file, automatically cleaned up on exit */
-char *get_temp_file_name( const char *prefix, const char *suffix )
-{
-    char *name;
-    int fd;
-
-    if (prefix) prefix = get_basename_noext( prefix );
-    fd = make_temp_file( prefix, suffix, &name );
-    close( fd );
-    strarray_add( &tmp_files, name );
-    return name;
-}
 
 /*******************************************************************
  *         buffer management
@@ -592,7 +571,7 @@ void close_output_file(void)
  */
 char *open_temp_output_file( const char *suffix )
 {
-    char *tmp_file = get_temp_file_name( output_file_name, suffix );
+    char *tmp_file = make_temp_file( output_file_name, suffix );
     if (!(output_file = fopen( tmp_file, "w" )))
         fatal_error( "Unable to create output file '%s'\n", tmp_file );
     return tmp_file;
diff --git a/tools/winedump/emfspool.c b/tools/winedump/emfspool.c
index 7d6344facd1..d0c90b2236b 100644
--- a/tools/winedump/emfspool.c
+++ b/tools/winedump/emfspool.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
 #include "winedump.h"
 
 #define EMFSPOOL_VERSION 0x10000
diff --git a/tools/winedump/lib.c b/tools/winedump/lib.c
index cd306c15828..86b1e86ca37 100644
--- a/tools/winedump/lib.c
+++ b/tools/winedump/lib.c
@@ -243,7 +243,7 @@ void lib_dump(void)
 
             if (globals.do_dumpheader)
             {
-                dump_file_header(fh);
+                dump_file_header(fh, FALSE);
                 if (fh->SizeOfOptionalHeader)
                 {
                     const IMAGE_OPTIONAL_HEADER32 *oh = (const IMAGE_OPTIONAL_HEADER32 *)((const char *)fh + sizeof(*fh));
diff --git a/tools/winedump/main.c b/tools/winedump/main.c
index f9557983465..f0668ec0b4f 100644
--- a/tools/winedump/main.c
+++ b/tools/winedump/main.c
@@ -169,7 +169,23 @@ static void do_dumphead (const char *arg)
 
 static void do_dumpsect (const char* arg)
 {
-    globals.dumpsect = arg;
+    unsigned count = 2;
+    char* p;
+    const char** out;
+
+    for (p = (char*)arg; (p = strchr(p, ',')) != NULL; p++, count++);
+    out = malloc(count * sizeof(char*));
+    globals.dumpsect = out;
+    count = 0;
+    p = strdup(arg);
+    for (;;)
+    {
+        out[count++] = p;
+        p = strchr(p, ',');
+        if (!p) break;
+        *p++ = '\0';
+    }
+    out[count] = NULL;
 }
 
 static void do_rawdebug (const char *arg)
@@ -182,7 +198,7 @@ static void do_dumpall(const char *arg)
     globals.do_dumpheader = TRUE;
     globals.do_dump_rawdata = TRUE;
     globals.do_symbol_table = TRUE;
-    globals.dumpsect = "ALL";
+    do_dumpsect ("ALL");
 }
 
 static void do_symtable(const char* arg)
@@ -207,8 +223,12 @@ static const struct my_option option_table[] = {
   {"-C",    DUMP, 0, do_symdmngl, "-C              Turn on symbol demangling"},
   {"-f",    DUMP, 0, do_dumphead, "-f              Dump file header information"},
   {"-G",    DUMP, 0, do_rawdebug, "-G              Dump raw debug information"},
-  {"-j",    DUMP, 1, do_dumpsect, "-j <sect_name>  Dump only the content of section 'sect_name'\n"
-                            "                        (import, export, debug, resource, tls, loadcfg, clr, reloc, except, apiset)"},
+  {"-j",    DUMP, 1, do_dumpsect, "-j <sect_name>  Dump the content of section 'sect_name'\n"
+                                  "                        (use '-j sect_name,sect_name2' to dump several sections)\n"
+                                  "                        for NE: export, resource\n"
+                                  "                        for PE: import, export, debug, resource, tls, loadcfg, clr, reloc, dynreloc, except, apiset\n"
+                                  "                        for PDB: PDB, TPI, DBI, IPI, public, image\n"
+                                  "                                 and suboptions: hash (PDB, TPI, TPI, DBI, public) and line (DBI)"},
   {"-t",    DUMP, 0, do_symtable, "-t              Dump symbol table"},
   {"-x",    DUMP, 0, do_dumpall,  "-x              Dump everything"},
   {"sym",   DMGL, 0, do_demangle, "sym <sym>       Demangle C++ symbol <sym> and exit"},
@@ -370,6 +390,16 @@ static BOOL symbol_finish(void)
     return started;
 }
 
+BOOL globals_dump_sect(const char* s)
+{
+    const char** sect;
+
+    if (!s || !globals.dumpsect) return FALSE;
+    for (sect = globals.dumpsect; *sect; sect++)
+        if (!strcmp(*sect, s) || !strcmp(*sect, "ALL")) return TRUE;
+    return FALSE;
+}
+
 /*******************************************************************
  *         main
  */
diff --git a/tools/winedump/msc.c b/tools/winedump/msc.c
index 561d3ca98ca..cb5fbb0b9ad 100644
--- a/tools/winedump/msc.c
+++ b/tools/winedump/msc.c
@@ -461,7 +461,7 @@ static const char* get_callconv(unsigned cc)
     case CV_CALL_RESERVED:      callconv = "reserved"; break;
     default:
         {
-            static char tmp[16];
+            static char tmp[20];
             sprintf(tmp, "callconv=%x", cc);
             callconv = tmp;
         }
diff --git a/tools/winedump/ne.c b/tools/winedump/ne.c
index 9b4ede6c86e..c27d7d6a9b7 100644
--- a/tools/winedump/ne.c
+++ b/tools/winedump/ne.c
@@ -429,15 +429,11 @@ void ne_dump( void )
         dump_ne_header( ne );
     if (globals.do_dumpheader)
         dump_ne_names( ne );
-    if (globals.dumpsect)
-    {
-        BOOL	all = strcmp(globals.dumpsect, "ALL") == 0;
 
-        if (all || !strcmp(globals.dumpsect, "resource"))
-            dump_ne_resources( ne );
-        if (all || !strcmp(globals.dumpsect, "export"))
-            dump_ne_exports( ne );
-    }
+    if (globals_dump_sect("resource"))
+        dump_ne_resources( ne );
+    if (globals_dump_sect("export"))
+        dump_ne_exports( ne );
     if (globals.do_dumpheader)
         for (i = 1; i <= ne->ne_cseg; i++) dump_ne_segment( ne, i );
 }
diff --git a/tools/winedump/pdb.c b/tools/winedump/pdb.c
index ab844fd8555..c76c19fec89 100644
--- a/tools/winedump/pdb.c
+++ b/tools/winedump/pdb.c
@@ -47,23 +47,24 @@ struct pdb_reader
             const struct PDB_DS_ROOT*   root;
         } ds;
     } u;
-    void*       (*read_file)(struct pdb_reader*, DWORD);
-    DWORD       file_used[1024];
+    void*       (*read_stream)(struct pdb_reader*, DWORD);
+    DWORD       stream_used[1024];
+    PDB_STRING_TABLE* global_string_table;
 };
 
-static inline BOOL has_file_been_read(struct pdb_reader* reader, unsigned file_nr)
+static inline BOOL has_stream_been_read(struct pdb_reader* reader, unsigned stream_nr)
 {
-    return reader->file_used[file_nr / 32] & (1 << (file_nr % 32));
+    return reader->stream_used[stream_nr / 32] & (1 << (stream_nr % 32));
 }
 
-static inline void mark_file_been_read(struct pdb_reader* reader, unsigned file_nr)
+static inline void mark_stream_been_read(struct pdb_reader* reader, unsigned stream_nr)
 {
-    reader->file_used[file_nr / 32] |= 1 << (file_nr % 32);
+    reader->stream_used[stream_nr / 32] |= 1 << (stream_nr % 32);
 }
 
-static inline void clear_file_been_read(struct pdb_reader* reader, unsigned file_nr)
+static inline void clear_stream_been_read(struct pdb_reader* reader, unsigned stream_nr)
 {
-    reader->file_used[file_nr / 32] &= ~(1 << (file_nr % 32));
+    reader->stream_used[stream_nr / 32] &= ~(1 << (stream_nr % 32));
 }
 
 static void* pdb_jg_read(const struct PDB_JG_HEADER* pdb, const WORD* block_list, int size)
@@ -83,72 +84,79 @@ static void* pdb_jg_read(const struct PDB_JG_HEADER* pdb, const WORD* block_list
     return buffer;
 }
 
-static void* pdb_jg_read_file(struct pdb_reader* reader, DWORD file_nr)
+static void* pdb_jg_read_stream(struct pdb_reader* reader, DWORD stream_nr)
 {
     const WORD*         block_list;
     DWORD               i;
 
-    if (!reader->u.jg.toc || file_nr >= reader->u.jg.toc->num_files) return NULL;
+    if (!reader->u.jg.toc || stream_nr >= reader->u.jg.toc->num_streams) return NULL;
 
-    mark_file_been_read(reader, file_nr);
-    if (reader->u.jg.toc->file[file_nr].size == 0 ||
-        reader->u.jg.toc->file[file_nr].size == 0xFFFFFFFF)
+    mark_stream_been_read(reader, stream_nr);
+    if (reader->u.jg.toc->streams[stream_nr].size == 0 ||
+        reader->u.jg.toc->streams[stream_nr].size == 0xFFFFFFFF)
         return NULL;
-    block_list = (const WORD*) &reader->u.jg.toc->file[reader->u.jg.toc->num_files];
-    for (i = 0; i < file_nr; i++)
-        block_list += (reader->u.jg.toc->file[i].size +
+    block_list = (const WORD*) &reader->u.jg.toc->streams[reader->u.jg.toc->num_streams];
+    for (i = 0; i < stream_nr; i++)
+        block_list += (reader->u.jg.toc->streams[i].size +
                        reader->u.jg.header->block_size - 1) / reader->u.jg.header->block_size;
 
     return pdb_jg_read(reader->u.jg.header, block_list,
-                       reader->u.jg.toc->file[file_nr].size);
+                       reader->u.jg.toc->streams[stream_nr].size);
 }
 
-static void pdb_jg_init(struct pdb_reader* reader)
+static BOOL pdb_jg_init(struct pdb_reader* reader)
 {
     reader->u.jg.header = PRD(0, sizeof(struct PDB_JG_HEADER));
-    reader->read_file = pdb_jg_read_file;
-    reader->u.jg.toc = pdb_jg_read(reader->u.jg.header, 
+    if (!reader->u.jg.header) return FALSE;
+    reader->read_stream = pdb_jg_read_stream;
+    reader->u.jg.toc = pdb_jg_read(reader->u.jg.header,
                                    reader->u.jg.header->toc_block,
                                    reader->u.jg.header->toc.size);
-    memset(reader->file_used, 0, sizeof(reader->file_used));
+    memset(reader->stream_used, 0, sizeof(reader->stream_used));
+    reader->u.jg.root = reader->read_stream(reader, 1);
+    if (!reader->u.jg.root) return FALSE;
+    return TRUE;
 }
 
-static DWORD    pdb_get_num_files(const struct pdb_reader* reader)
+static DWORD    pdb_get_num_streams(const struct pdb_reader* reader)
 {
-    if (reader->read_file == pdb_jg_read_file)
-        return reader->u.jg.toc->num_files;
+    if (reader->read_stream == pdb_jg_read_stream)
+        return reader->u.jg.toc->num_streams;
     else
-        return reader->u.ds.toc->num_files;
+        return reader->u.ds.toc->num_streams;
 }
 
-static DWORD    pdb_get_file_size(const struct pdb_reader* reader, unsigned idx)
+static DWORD    pdb_get_stream_size(const struct pdb_reader* reader, unsigned idx)
 {
-    if (reader->read_file == pdb_jg_read_file)
-        return reader->u.jg.toc->file[idx].size;
+    if (reader->read_stream == pdb_jg_read_stream)
+        return reader->u.jg.toc->streams[idx].size;
     else
-        return reader->u.ds.toc->file_size[idx];
+        return reader->u.ds.toc->stream_size[idx];
 }
 
 static void pdb_exit(struct pdb_reader* reader)
 {
     unsigned            i, size;
-    unsigned char*      file;
+    unsigned char*      stream;
 
-    for (i = 0; i < pdb_get_num_files(reader); i++)
+    if (globals_dump_sect("ALL")) /* otherwise we won't have loaded all streams */
     {
-        if (has_file_been_read(reader, i)) continue;
+        for (i = 0; i < pdb_get_num_streams(reader); i++)
+        {
+            if (has_stream_been_read(reader, i)) continue;
 
-        file = reader->read_file(reader, i);
-        if (!file) continue;
+            stream = reader->read_stream(reader, i);
+            if (!stream) continue;
 
-        size = pdb_get_file_size(reader, i);
+            size = pdb_get_stream_size(reader, i);
 
-        printf("File --unused-- #%d (%x)\n", i, size);
-        dump_data(file, size, "    ");
-        free(file);
+            printf("Stream --unused-- #%d (%x)\n", i, size);
+            dump_data(stream, size, "    ");
+            free(stream);
+        }
     }
-
-    if (reader->read_file == pdb_jg_read_file)
+    free(reader->global_string_table);
+    if (reader->read_stream == pdb_jg_read_stream)
     {
         free((char*)reader->u.jg.root);
         free((char*)reader->u.jg.toc);
@@ -160,6 +168,11 @@ static void pdb_exit(struct pdb_reader* reader)
     }
 }
 
+/* forward declarations */
+static void pdb_dump_fpo(struct pdb_reader* reader, unsigned stream_idx);
+static void pdb_dump_fpo_ext(struct pdb_reader* reader, unsigned stream_idx);
+static void pdb_dump_sections(struct pdb_reader* reader, unsigned stream_idx);
+
 static unsigned get_stream_by_name(struct pdb_reader* reader, const char* name)
 {
     DWORD*      pdw;
@@ -169,7 +182,7 @@ static unsigned get_stream_by_name(struct pdb_reader* reader, const char* name)
     unsigned    i;
     const char* str;
 
-    if (reader->read_file == pdb_jg_read_file)
+    if (reader->read_stream == pdb_jg_read_stream)
     {
         str = reader->u.jg.root->names;
         cbstr = reader->u.jg.root->cbNames;
@@ -205,6 +218,46 @@ static unsigned get_stream_by_name(struct pdb_reader* reader, const char* name)
     return -1;
 }
 
+static void dump_string_table(const PDB_STRING_TABLE* strtable, const char* name, const char* pfx)
+{
+    const char* end;
+    const char* ptr;
+    unsigned* table;
+    unsigned num_buckets;
+    unsigned i;
+
+    if (!strtable)
+    {
+        printf("%sString table (%s) isn't present\n", pfx, name);
+        return;
+    }
+    printf("%sString table (%s)\n"
+           "%s\tHeader:       %08x\n"
+           "%s\tLength:       %08x\n"
+           "%s\tHash version: %u\n",
+           pfx, name, pfx, strtable->magic, pfx, strtable->length, pfx, strtable->hash_version);
+    ptr = (const char*)(strtable + 1);
+    end = ptr + strtable->length;
+    while (ptr < end)
+    {
+        printf("%s\t%zu]     %s\n", pfx, ptr - (const char*)(strtable + 1), ptr);
+        ptr += strlen(ptr) + 1;
+    }
+    table = (unsigned *)((char*)(strtable + 1) + strtable->length);
+    num_buckets = *table++;
+
+    if (globals_dump_sect("hash"))
+    {
+        printf("%s\tHash:\n"
+               "%s\t\tnum_strings: %x\n"
+               "%s\t\tnum_buckets: %x\n",
+               pfx, pfx, table[num_buckets], pfx, num_buckets);
+
+        for (i = 0; i < num_buckets; i++)
+            printf("%s\t\t%x] %x\n", pfx, i, table[i]);
+    }
+}
+
 static PDB_STRING_TABLE* read_string_table(struct pdb_reader* reader)
 {
     unsigned            stream_idx;
@@ -213,9 +266,10 @@ static PDB_STRING_TABLE* read_string_table(struct pdb_reader* reader)
 
     stream_idx = get_stream_by_name(reader, "/names");
     if (stream_idx == -1) return NULL;
-    ret = reader->read_file(reader, stream_idx);
+    ret = reader->read_stream(reader, stream_idx);
     if (!ret) return NULL;
-    stream_size = pdb_get_file_size(reader, stream_idx);
+    stream_size = pdb_get_stream_size(reader, stream_idx);
+    if (globals_dump_sect("PDB")) dump_string_table(ret, "Global", "    ");
     if (ret->magic == 0xeffeeffe && sizeof(*ret) + ret->length < stream_size) return ret;
     printf("Improper string table header (magic=%x)\n", ret->magic);
     dump_data((const unsigned char*)ret, stream_size, "    ");
@@ -233,6 +287,7 @@ const char* pdb_get_string_table_entry(const PDB_STRING_TABLE* table, unsigned o
 
 static void dump_dbi_hash_table(const BYTE* root, unsigned size, const char* name, const char* pfx)
 {
+    if (!globals_dump_sect("hash")) return;
     if (size >= sizeof(DBI_HASH_HEADER))
     {
         const DBI_HASH_HEADER* hdr = (const DBI_HASH_HEADER*)root;
@@ -240,25 +295,28 @@ static void dump_dbi_hash_table(const BYTE* root, unsigned size, const char* nam
         printf("%s%s symbols hash:\n", pfx, name);
         printf("%s\tSignature: 0x%x\n", pfx, hdr->signature);
         printf("%s\tVersion: 0x%x (%u)\n", pfx, hdr->version, hdr->version - 0xeffe0000);
-        printf("%s\tSize of hash records: %u\n", pfx, hdr->size_hash_records);
+        printf("%s\tSize of hash records: %u\n", pfx, hdr->hash_records_size);
         printf("%s\tUnknown: %u\n", pfx, hdr->unknown);
 
         if (hdr->signature != 0xFFFFFFFF ||
             hdr->version != 0xeffe0000 + 19990810 ||
-            (hdr->size_hash_records % sizeof(DBI_HASH_RECORD)) != 0 ||
-            sizeof(DBI_HASH_HEADER) + hdr->size_hash_records + DBI_BITMAP_HASH_SIZE > size ||
-            (size - (sizeof(DBI_HASH_HEADER) + hdr->size_hash_records + DBI_BITMAP_HASH_SIZE)) % sizeof(unsigned))
+            (hdr->hash_records_size % sizeof(DBI_HASH_RECORD)) != 0 ||
+            sizeof(DBI_HASH_HEADER) + hdr->hash_records_size + DBI_BITMAP_HASH_SIZE > size ||
+            (size - (sizeof(DBI_HASH_HEADER) + hdr->hash_records_size + DBI_BITMAP_HASH_SIZE)) % sizeof(unsigned))
         {
-            printf("%s\t\tIncorrect hash structure\n", pfx);
+            if (size >= sizeof(DBI_HASH_HEADER) && !hdr->hash_records_size)
+                printf("%s\t\tEmpty hash structure\n", pfx);
+            else
+                printf("%s\t\tIncorrect hash structure\n", pfx);
         }
         else
         {
             unsigned i;
-            unsigned num_hash_records = hdr->size_hash_records / sizeof(DBI_HASH_RECORD);
+            unsigned num_hash_records = hdr->hash_records_size / sizeof(DBI_HASH_RECORD);
             const DBI_HASH_RECORD* hr = (const DBI_HASH_RECORD*)(hdr + 1);
-            unsigned* bitmap = (unsigned*)((char*)(hdr + 1) + hdr->size_hash_records);
-            unsigned* buckets = (unsigned*)((char*)(hdr + 1) + hdr->size_hash_records + DBI_BITMAP_HASH_SIZE);
-            unsigned index, last_index = (size - (sizeof(DBI_HASH_HEADER) + hdr->size_hash_records + DBI_BITMAP_HASH_SIZE)) / sizeof(unsigned);
+            unsigned* bitmap = (unsigned*)((char*)(hdr + 1) + hdr->hash_records_size);
+            unsigned* buckets = (unsigned*)((char*)(hdr + 1) + hdr->hash_records_size + DBI_BITMAP_HASH_SIZE);
+            unsigned index, last_index = (size - (sizeof(DBI_HASH_HEADER) + hdr->hash_records_size + DBI_BITMAP_HASH_SIZE)) / sizeof(unsigned);
 
             /* Yes, offsets for accessiong hr[] are stored as multiple of 12; and not
              * as multiple of sizeof(*hr) = 8 as one might expect.
@@ -279,10 +337,10 @@ static void dump_dbi_hash_table(const BYTE* root, unsigned size, const char* nam
                     printf("%s\t[%u] <<empty>>\n", pfx, i);
             }
             /* shouldn't happen */
-            if (sizeof(DBI_HASH_HEADER) + hdr->size_hash_records + DBI_BITMAP_HASH_SIZE + index * sizeof(unsigned) > size)
+            if (sizeof(DBI_HASH_HEADER) + hdr->hash_records_size + DBI_BITMAP_HASH_SIZE + index * sizeof(unsigned) > size)
             {
                 printf("%s-- left over %u bytes\n", pfx,
-                       size - (unsigned)(sizeof(DBI_HASH_HEADER) + hdr->size_hash_records + DBI_BITMAP_HASH_SIZE + index * sizeof(unsigned)));
+                       size - (unsigned)(sizeof(DBI_HASH_HEADER) + hdr->hash_records_size + DBI_BITMAP_HASH_SIZE + index * sizeof(unsigned)));
             }
         }
     }
@@ -290,126 +348,279 @@ static void dump_dbi_hash_table(const BYTE* root, unsigned size, const char* nam
         printf("%sNo header in symbols hash\n", pfx);
 }
 
-static void dump_global_symbol(struct pdb_reader* reader, unsigned file)
+static void dump_global_symbol(struct pdb_reader* reader, unsigned stream)
 {
     void*  global = NULL;
     DWORD  size;
 
-    global = reader->read_file(reader, file);
+    global = reader->read_stream(reader, stream);
     if (!global) return;
 
-    size = pdb_get_file_size(reader, file);
+    size = pdb_get_stream_size(reader, stream);
 
     dump_dbi_hash_table(global, size, "Global", "");
     free(global);
 }
 
-static void dump_public_symbol(struct pdb_reader* reader, unsigned file)
+static void dump_public_symbol(struct pdb_reader* reader, unsigned stream)
 {
     unsigned            size;
     DBI_PUBLIC_HEADER*  hdr;
+    const BYTE*         ptr;
+    unsigned            i;
 
-    hdr = reader->read_file(reader, file);
+    if (!globals_dump_sect("public")) return;
+    hdr = reader->read_stream(reader, stream);
     if (!hdr) return;
 
-    size = pdb_get_file_size(reader, file);
+    size = pdb_get_stream_size(reader, stream);
 
     printf("Public symbols table: (%u)\n", size);
 
     printf("\tHash size:              %u\n", hdr->hash_size);
     printf("\tAddress map size:       %u\n", hdr->address_map_size);
     printf("\tNumber of thunks:       %u\n", hdr->num_thunks);
-    printf("\tSize of thunk:          %u\n", hdr->size_thunk);
+    printf("\tSize of thunk map:      %u\n", hdr->thunk_size);
     printf("\tSection of thunk table: %u\n", hdr->section_thunk_table);
     printf("\tOffset of thunk table:  %u\n", hdr->offset_thunk_table);
-    printf("\tNumber of sections:     %u\n", hdr->num_sects);
+    printf("\tNumber of sections:     %u\n", hdr->num_sections);
+
+    ptr = (const BYTE*)(hdr + 1);
+    dump_dbi_hash_table(ptr, hdr->hash_size, "Public", "\t");
 
-    dump_dbi_hash_table((const BYTE*)(hdr + 1), hdr->hash_size, "Public", "\t");
+    ptr += hdr->hash_size;
+    printf("\tAddress map:\n");
+    for (i = 0; i < hdr->address_map_size / sizeof(unsigned); i++)
+        printf("\t\t%u]     %08x\n", i, ((const unsigned*)ptr)[i]);
+
+    ptr += hdr->address_map_size;
+    printf("\tThunk map:\n");
+    for (i = 0; i < hdr->num_thunks; i++)
+        printf("\t\t%u]      %08x\n", i, ((const unsigned*)ptr)[i]);
+
+    ptr += hdr->num_thunks * sizeof(unsigned);
+    printf("\tSection map:\n");
+    for (i = 0; i < hdr->num_sections; i++)
+        printf("\t\t%u]      %04x:%08x\n", i, (unsigned short)((const unsigned*)ptr)[2 * i + 1], ((const unsigned*)ptr)[2 * i + 0]);
+
+    if (ptr + hdr->num_sections * 8 != ((const BYTE*)hdr) + size)
+        printf("Incorrect stream\n");
     free(hdr);
 }
 
-static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx)
+static const void* pdb_dump_dbi_module(struct pdb_reader* reader, const PDB_SYMBOL_FILE_EX* sym_file,
+                                       const char* file_name)
+{
+    const char* lib_name;
+    unsigned char* modimage;
+    BOOL new_format = !file_name;
+
+    if (new_format) file_name = sym_file->filename;
+    printf("\t--------symbol file-----------\n");
+    printf("\tName: %s\n", file_name);
+    lib_name = file_name + strlen(file_name) + 1;
+    if (strcmp(file_name, lib_name)) printf("\tLibrary: %s\n", lib_name);
+    printf("\t\tunknown1:   %08x\n"
+           "\t\trange\n"
+           "\t\t\tsegment:         %04x\n"
+           "\t\t\tpad1:            %04x\n"
+           "\t\t\toffset:          %08x\n"
+           "\t\t\tsize:            %08x\n"
+           "\t\t\tcharacteristics: %08x",
+           sym_file->unknown1,
+           sym_file->range.segment,
+           sym_file->range.pad1,
+           sym_file->range.offset,
+           sym_file->range.size,
+           sym_file->range.characteristics);
+    dump_section_characteristics(sym_file->range.characteristics, " ");
+    printf("\n"
+           "\t\t\tindex:           %04x\n"
+           "\t\t\tpad2:            %04x\n",
+           sym_file->range.index,
+           sym_file->range.pad2);
+    if (new_format)
+        printf("\t\t\ttimestamp:       %08x\n"
+               "\t\t\tunknown:         %08x\n",
+               sym_file->range.timestamp,
+               sym_file->range.unknown);
+    printf("\t\tflag:       %04x\n"
+           "\t\tstream:     %04x\n"
+           "\t\tsymb size:  %08x\n"
+           "\t\tline size:  %08x\n"
+           "\t\tline2 size: %08x\n"
+           "\t\tnSrcFiles:  %08x\n"
+           "\t\tattribute:  %08x\n",
+           sym_file->flag,
+           sym_file->stream,
+           sym_file->symbol_size,
+           sym_file->lineno_size,
+           sym_file->lineno2_size,
+           sym_file->nSrcFiles,
+           sym_file->attribute);
+    if (new_format)
+        printf("\t\treserved/0: %08x\n"
+               "\t\treserved/1: %08x\n",
+               sym_file->reserved[0],
+               sym_file->reserved[1]);
+
+    modimage = reader->read_stream(reader, sym_file->stream);
+    if (modimage)
+    {
+        int total_size = pdb_get_stream_size(reader, sym_file->stream);
+
+        if (sym_file->symbol_size)
+            codeview_dump_symbols((const char*)modimage, sizeof(DWORD), sym_file->symbol_size);
+
+        /* line number info */
+        if (sym_file->lineno_size)
+            codeview_dump_linetab((const char*)modimage + sym_file->symbol_size, TRUE, "        ");
+        else if (sym_file->lineno2_size) /* actually, only one of the 2 lineno should be present */
+            codeview_dump_linetab2((const char*)modimage + sym_file->symbol_size, sym_file->lineno2_size,
+                                   reader->global_string_table, "        ");
+        /* what's that part ??? */
+        if (0)
+            dump_data(modimage + sym_file->symbol_size + sym_file->lineno_size + sym_file->lineno2_size,
+                      total_size - (sym_file->symbol_size + sym_file->lineno_size + sym_file->lineno2_size), "    ");
+        free(modimage);
+    }
+    return (const void*)((DWORD_PTR)(lib_name + strlen(lib_name) + 1 + 3) & ~3);
+}
+
+static void pdb_dump_symbols(struct pdb_reader* reader)
 {
     PDB_SYMBOLS*        symbols;
     unsigned char*      modimage;
     const char*         file;
-    PDB_STRING_TABLE*   filesimage;
     char                tcver[32];
+    PDB_STREAM_INDEXES  sidx;
 
-    sidx->FPO = sidx->unk0 = sidx->unk1 = sidx->unk2 = sidx->unk3 = sidx->segments =
-        sidx->unk4 = sidx->unk5 = sidx->unk6 = sidx->FPO_EXT = sidx->unk7 = -1;
+    sidx.FPO = sidx.unk0 = sidx.unk1 = sidx.unk2 = sidx.unk3 = sidx.sections_stream =
+        sidx.unk4 = sidx.unk5 = sidx.unk6 = sidx.FPO_EXT = sidx.unk7 = -1;
 
-    symbols = reader->read_file(reader, 3);
+    symbols = reader->read_stream(reader, 3);
     if (!symbols) return;
 
-    switch (symbols->version)
+    if (globals_dump_sect("DBI"))
     {
-    case 0:            /* VC 4.0 */
-    case 19960307:     /* VC 5.0 */
-    case 19970606:     /* VC 6.0 */
-    case 19990903:     /* VC 7.0 */
-        break;
-    default:
-        printf("-Unknown symbol info version %d\n", symbols->version);
+        switch (symbols->version)
+        {
+        case 0:            /* VC 4.0 */
+        case 19960307:     /* VC 5.0 */
+        case 19970606:     /* VC 6.0 */
+        case 19990903:     /* VC 7.0 */
+            break;
+        default:
+            printf("-Unknown symbol info version %d\n", symbols->version);
+        }
+        if (symbols->flags & 0x8000) /* new */
+            sprintf(tcver, "%u.%u", (symbols->flags >> 8) & 0x7f, symbols->flags & 0xff);
+        else
+            sprintf(tcver, "old-%x", symbols->flags);
+        printf("Symbols:\n"
+               "\tsignature:          %08x\n"
+               "\tversion:            %u\n"
+               "\tage:                %08x\n"
+               "\tglobal_hash_stream: %u\n"
+               "\tbuilder:            %s\n"
+               "\tpublic_stream:      %u\n"
+               "\tbldVer:             %u\n"
+               "\tgsym_stream:        %u\n"
+               "\trbldVer:            %u\n"
+               "\tmodule_size:        %08x\n"
+               "\tsectcontrib_size:   %08x\n"
+               "\tsegmap_size:        %08x\n"
+               "\tsrc_module_size:    %08x\n"
+               "\tpdbimport_size:     %08x\n"
+               "\tresvd0:             %08x\n"
+               "\tstream_idx_size:    %08x\n"
+               "\tunknown2_size:      %08x\n"
+               "\tresvd3:             %04x\n"
+               "\tmachine:            %s\n"
+               "\tresvd4              %08x\n",
+               symbols->signature,
+               symbols->version,
+               symbols->age,
+               symbols->global_hash_stream,
+               tcver, /* from symbols->flags */
+               symbols->public_stream,
+               symbols->bldVer,
+               symbols->gsym_stream,
+               symbols->rbldVer,
+               symbols->module_size,
+               symbols->sectcontrib_size,
+               symbols->segmap_size,
+               symbols->srcmodule_size,
+               symbols->pdbimport_size,
+               symbols->resvd0,
+               symbols->stream_index_size,
+               symbols->unknown2_size,
+               symbols->resvd3,
+               get_machine_str( symbols->machine ),
+               symbols->resvd4);
     }
-    if (symbols->flags & 0x8000) /* new */
-        sprintf(tcver, "%u.%u", (symbols->flags >> 8) & 0x7f, symbols->flags & 0xff);
-    else
-        sprintf(tcver, "old-%x", symbols->flags);
-    printf("Symbols:\n"
-           "\tsignature:        %08x\n"
-           "\tversion:          %u\n"
-           "\tage:              %08x\n"
-           "\tglobal_hash_file: %u\n"
-           "\tbuilder:          %s\n"
-           "\tpublic_file:      %u\n"
-           "\tbldVer:           %u\n"
-           "\tgsym_file:        %u\n"
-           "\trbldVer:          %u\n"
-           "\tmodule_size:      %08x\n"
-           "\toffset_size:      %08x\n"
-           "\thash_size:        %08x\n"
-           "\tsrc_module_size:  %08x\n"
-           "\tpdbimport_size:   %08x\n"
-           "\tresvd0:           %08x\n"
-           "\tstream_idx_size:  %08x\n"
-           "\tunknown2_size:    %08x\n"
-           "\tresvd3:           %04x\n"
-           "\tmachine:          %s\n"
-           "\tresvd4            %08x\n",
-           symbols->signature,
-           symbols->version,
-           symbols->age,
-           symbols->global_hash_file,
-           tcver, /* from symbols->flags */
-           symbols->public_file,
-           symbols->bldVer,
-           symbols->gsym_file,
-           symbols->rbldVer,
-           symbols->module_size,
-           symbols->offset_size,
-           symbols->hash_size,
-           symbols->srcmodule_size,
-           symbols->pdbimport_size,
-           symbols->resvd0,
-           symbols->stream_index_size,
-           symbols->unknown2_size,
-           symbols->resvd3,
-           get_machine_str( symbols->machine ),
-           symbols->resvd4);
-
-    if (symbols->offset_size)
-    {
-        const BYTE*                 src;
 
-        printf("\t----------offsets------------\n");
-        src = (const BYTE*)((const char*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size);
-        dump_data(src, symbols->offset_size, "    ");
+    if (symbols->sectcontrib_size && globals_dump_sect("image"))
+    {
+        const BYTE*                 src = (const BYTE*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size;
+        const BYTE*                 last = src + symbols->sectcontrib_size;
+        unsigned                    version, size;
+
+        printf("\t----------section contrib------------\n");
+        version = *(unsigned*)src;
+        printf("\tVersion:      %#x (%d)\n", version, version - 0xeffe0000);
+        switch (version)
+        {
+        case 0xeffe0000 + 19970605: size = sizeof(PDB_SYMBOL_RANGE_EX); break;
+        case 0xeffe0000 + 20140516: size = sizeof(PDB_SYMBOL_RANGE_EX) + sizeof(unsigned); break;
+        default: printf("\t\tUnsupported version number\n"); size = 0;
+        }
+        if (size)
+        {
+            const PDB_SYMBOL_RANGE_EX* range;
+
+            if ((symbols->sectcontrib_size - sizeof(unsigned)) % size)
+                printf("Incoherent size: %zu = %zu * %u + %zu\n",
+                       symbols->sectcontrib_size - sizeof(unsigned),
+                       (symbols->sectcontrib_size - sizeof(unsigned)) / size,
+                       size,
+                       (symbols->sectcontrib_size - sizeof(unsigned)) % size);
+            if ((symbols->sectcontrib_size - sizeof(unsigned)) % size)
+            if ((symbols->sectcontrib_size - sizeof(unsigned)) % size)
+            src += sizeof(unsigned);
+            while (src + size <= last)
+            {
+                range = (const PDB_SYMBOL_RANGE_EX*)(src + sizeof(unsigned));
+                printf("\tRange #%tu\n",
+                       ((const BYTE*)range - ((const BYTE*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size)) / size);
+                printf("\t\tsegment:         %04x\n"
+                       "\t\tpad1:            %04x\n"
+                       "\t\toffset:          %08x\n"
+                       "\t\tsize:            %08x\n"
+                       "\t\tcharacteristics: %08x",
+                       range->segment,
+                       range->pad1,
+                       range->offset,
+                       range->size,
+                       range->characteristics);
+                dump_section_characteristics(range->characteristics, " ");
+                printf("\n"
+                       "\t\tindex:           %04x\n"
+                       "\t\tpad2:            %04x\n"
+                       "\t\ttimestamp:       %08x\n"
+                       "\t\tunknown:         %08x\n",
+                       range->index,
+                       range->pad2,
+                       range->timestamp,
+                       range->unknown);
+                if (version == 0xeffe0000 + 20140516)
+                    printf("\t\tcoff_section:    %08x\n", *(unsigned*)(range + 1));
+                src += size;
+            }
+        }
     }
 
-    if (!(filesimage = read_string_table(reader))) printf("string table not found\n");
-
-    if (symbols->srcmodule_size)
+    if (symbols->srcmodule_size && globals_dump_sect("DBI"))
     {
         const PDB_SYMBOL_SOURCE*src;
         int                     i, j, cfile;
@@ -419,8 +630,8 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
         const char*             cstr;
 
         printf("\t----------src module------------\n");
-        src = (const PDB_SYMBOL_SOURCE*)((const char*)symbols + sizeof(PDB_SYMBOLS) + 
-                                         symbols->module_size + symbols->offset_size + symbols->hash_size);
+        src = (const PDB_SYMBOL_SOURCE*)((const char*)symbols + sizeof(PDB_SYMBOLS) +
+                                         symbols->module_size + symbols->sectcontrib_size + symbols->segmap_size);
         printf("\tSource Modules\n"
                "\t\tnModules:         %u\n"
                "\t\tnSrcFiles:        %u\n",
@@ -457,7 +668,7 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
             }
         }
     }
-    if (symbols->pdbimport_size)
+    if (symbols->pdbimport_size && globals_dump_sect("PDB"))
     {
         const PDB_SYMBOL_IMPORT*  imp;
         const char* first;
@@ -465,9 +676,9 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
         const char* ptr;
 
         printf("\t------------import--------------\n");
-        imp = (const PDB_SYMBOL_IMPORT*)((const char*)symbols + sizeof(PDB_SYMBOLS) + 
-                                         symbols->module_size + symbols->offset_size + 
-                                         symbols->hash_size + symbols->srcmodule_size);
+        imp = (const PDB_SYMBOL_IMPORT*)((const char*)symbols + sizeof(PDB_SYMBOLS) +
+                                         symbols->module_size + symbols->sectcontrib_size +
+                                         symbols->segmap_size + symbols->srcmodule_size);
         first = (const char*)imp;
         last = (const char*)imp + symbols->pdbimport_size;
         while (imp < (const PDB_SYMBOL_IMPORT*)last)
@@ -490,7 +701,46 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
             imp = (const PDB_SYMBOL_IMPORT*)(first + ((ptr - first + strlen(ptr) + 1 + 3) & ~3));
         }
     }
-    if (symbols->stream_index_size)
+    if (symbols->segmap_size && globals_dump_sect("image"))
+    {
+        const struct OMFSegMap* segmap = (const struct OMFSegMap*)((const BYTE*)symbols + sizeof(PDB_SYMBOLS) +
+                                                                   symbols->module_size + symbols->sectcontrib_size);
+        const struct OMFSegMapDesc* desc = (const struct OMFSegMapDesc*)(segmap + 1);
+
+        printf("\t--------------segment map----------------\n");
+        printf("\tNumber of segments: %x\n", segmap->cSeg);
+        printf("\tNumber of logical segments: %x\n", segmap->cSegLog);
+        /* FIXME check mapping old symbols */
+        for (; (const BYTE*)(desc + 1) <= ((const BYTE*)(segmap + 1) + symbols->segmap_size); desc++)
+        {
+            printf("\t\tSegment descriptor #%tu\n", desc - (const struct OMFSegMapDesc*)(segmap + 1));
+            printf("\t\t\tFlags: %04x (%c%c%c%s%s%s%s)\n",
+                   desc->flags,
+                   (desc->flags & 0x01) ? 'R' : '-',
+                   (desc->flags & 0x02) ? 'W' : '-',
+                   (desc->flags & 0x04) ? 'X' : '-',
+                   (desc->flags & 0x08) ? " 32bit-linear" : "",
+                   (desc->flags & 0x100) ? " selector" : "",
+                   (desc->flags & 0x200) ? " absolute" : "",
+                   (desc->flags & 0x400) ? " group" : "");
+            printf("\t\t\tOverlay: %04x\n", desc->ovl);
+            printf("\t\t\tGroup: %04x\n", desc->group);
+            printf("\t\t\tFrame: %04x\n", desc->frame);
+            printf("\t\t\tSegment name: %s\n", desc->iSegName == 0xffff ? "none" : pdb_get_string_table_entry(reader->global_string_table, desc->iSegName));
+            printf("\t\t\tClass name: %s\n",  desc->iClassName == 0xffff ? "none" : pdb_get_string_table_entry(reader->global_string_table, desc->iClassName));
+            printf("\t\t\tOffset: %08x\n", desc->offset);
+            printf("\t\t\tSize: %04x\n", desc->cbSeg);
+        }
+    }
+    if (symbols->unknown2_size && globals_dump_sect("PDB"))
+    {
+        const char* ptr = (const char*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size +
+            symbols->sectcontrib_size + symbols->segmap_size + symbols->srcmodule_size +
+            symbols->pdbimport_size;
+        printf("\t------------Unknown2--------------\n");
+        dump_string_table((const PDB_STRING_TABLE*)ptr, "Unknown from DBI", "\t");
+    }
+    if (symbols->stream_index_size && globals_dump_sect("image"))
     {
         printf("\t------------stream indexes--------------\n");
         switch (symbols->stream_index_size)
@@ -499,9 +749,9 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
             /* PDB_STREAM_INDEXES is a superset of PDB_STREAM_INDEX_OLD
              * FIXME: to be confirmed when all fields are fully understood
              */
-            memcpy(sidx,
+            memcpy(&sidx,
                    (const char*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size +
-                   symbols->offset_size + symbols->hash_size + symbols->srcmodule_size +
+                   symbols->sectcontrib_size + symbols->segmap_size + symbols->srcmodule_size +
                    symbols->pdbimport_size + symbols->unknown2_size,
                    sizeof(PDB_STREAM_INDEXES_OLD));
             printf("\tFPO:                  %04x\n"
@@ -509,30 +759,30 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
-                   "\tSegments:             %04x\n",
-                   sidx->FPO, sidx->unk0, sidx->unk1, sidx->unk2, sidx->unk3,
-                   sidx->segments);
+                   "\tSections stream:      %04x\n",
+                   sidx.FPO, sidx.unk0, sidx.unk1, sidx.unk2, sidx.unk3,
+                   sidx.sections_stream);
             break;
         case sizeof(PDB_STREAM_INDEXES):
-            memcpy(sidx,
+            memcpy(&sidx,
                    (const char*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size +
-                   symbols->offset_size + symbols->hash_size + symbols->srcmodule_size +
+                   symbols->sectcontrib_size + symbols->segmap_size + symbols->srcmodule_size +
                    symbols->pdbimport_size + symbols->unknown2_size,
-                   sizeof(*sidx));
+                   sizeof(sidx));
             printf("\tFPO:                  %04x\n"
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
-                   "\tSegments:             %04x\n"
+                   "\tSection stream:       %04x\n"
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
                    "\t?:                    %04x\n"
                    "\tFPO-ext:              %04x\n"
                    "\t?:                    %04x\n",
-                   sidx->FPO, sidx->unk0, sidx->unk1, sidx->unk2, sidx->unk3,
-                   sidx->segments, sidx->unk4, sidx->unk5, sidx->unk6, sidx->FPO_EXT,
-                   sidx->unk7);
+                   sidx.FPO, sidx.unk0, sidx.unk1, sidx.unk2, sidx.unk3,
+                   sidx.sections_stream, sidx.unk4, sidx.unk5, sidx.unk6, sidx.FPO_EXT,
+                   sidx.unk7);
             break;
         default:
             printf("unexpected size for stream index %d\n", symbols->stream_index_size);
@@ -541,147 +791,63 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
     }
 
     /* Read global symbol table */
-    modimage = reader->read_file(reader, symbols->gsym_file);
-    if (modimage)
+    modimage = reader->read_stream(reader, symbols->gsym_stream);
+    if (modimage && globals_dump_sect("DBI"))
     {
-        printf("\t------------globals-------------\n"); 
-        codeview_dump_symbols(modimage, 0, pdb_get_file_size(reader, symbols->gsym_file));
+        printf("\t------------globals-------------\n");
+        codeview_dump_symbols(modimage, 0, pdb_get_stream_size(reader, symbols->gsym_stream));
         free(modimage);
     }
 
     /* Read per-module symbol / linenumber tables */
-    file = (const char*)symbols + sizeof(PDB_SYMBOLS);
-    while (file - (const char*)symbols < sizeof(PDB_SYMBOLS) + symbols->module_size)
+    if (symbols->module_size && globals_dump_sect("DBI"))
     {
-        int file_nr, symbol_size, lineno_size, lineno2_size;
-        const char* file_name;
-        const char* lib_name;
+        SIZE_T module_header_size = symbols->version < 19970000 ? sizeof(PDB_SYMBOL_FILE) : sizeof(PDB_SYMBOL_FILE_EX);
 
-        if (symbols->version < 19970000)
-        {
-            const PDB_SYMBOL_FILE*      sym_file = (const PDB_SYMBOL_FILE*) file;
-            file_nr     = sym_file->file;
-            file_name   = sym_file->filename;
-            lib_name    = file_name + strlen(file_name) + 1;
-            symbol_size = sym_file->symbol_size;
-            lineno_size = sym_file->lineno_size;
-            lineno2_size = sym_file->lineno2_size;
-            printf("\t--------symbol file-----------\n");
-            printf("\tName: %s\n", file_name);
-            if (strcmp(file_name, lib_name)) printf("\tLibrary: %s\n", lib_name);
-            printf("\t\tunknown1:   %08x\n"
-                   "\t\trange\n"
-                   "\t\t\tsegment:         %04x\n"
-                   "\t\t\tpad1:            %04x\n"
-                   "\t\t\toffset:          %08x\n"
-                   "\t\t\tsize:            %08x\n"
-                   "\t\t\tcharacteristics: %08x\n"
-                   "\t\t\tindex:           %04x\n"
-                   "\t\t\tpad2:            %04x\n"
-                   "\t\tflag:       %04x\n"
-                   "\t\tfile:       %04x\n"
-                   "\t\tsymb size:  %08x\n"
-                   "\t\tline size:  %08x\n"
-                   "\t\tline2 size:  %08x\n"
-                   "\t\tnSrcFiles:  %08x\n"
-                   "\t\tattribute:  %08x\n",
-                   sym_file->unknown1,
-                   sym_file->range.segment,
-                   sym_file->range.pad1,
-                   sym_file->range.offset,
-                   sym_file->range.size,
-                   sym_file->range.characteristics,
-                   sym_file->range.index,
-                   sym_file->range.pad2,
-                   sym_file->flag,
-                   sym_file->file,
-                   sym_file->symbol_size,
-                   sym_file->lineno_size,
-                   sym_file->lineno2_size,
-                   sym_file->nSrcFiles,
-                   sym_file->attribute);
-        }
-        else
-        {
-            const PDB_SYMBOL_FILE_EX*   sym_file = (const PDB_SYMBOL_FILE_EX*) file;
-
-            file_nr     = sym_file->file;
-            file_name   = sym_file->filename;
-            lib_name    = file_name + strlen(file_name) + 1;
-            symbol_size = sym_file->symbol_size;
-            lineno_size = sym_file->lineno_size;
-            lineno2_size = sym_file->lineno2_size;
-            printf("\t--------symbol file-----------\n");
-            printf("\tName: %s\n", file_name);
-            if (strcmp(file_name, lib_name)) printf("\tLibrary: %s\n", lib_name);
-            printf("\t\tunknown1:   %08x\n"
-                   "\t\trange\n"
-                   "\t\t\tsegment:         %04x\n"
-                   "\t\t\tpad1:            %04x\n"
-                   "\t\t\toffset:          %08x\n"
-                   "\t\t\tsize:            %08x\n"
-                   "\t\t\tcharacteristics: %08x\n"
-                   "\t\t\tindex:           %04x\n"
-                   "\t\t\tpad2:            %04x\n"
-                   "\t\t\ttimestamp:       %08x\n"
-                   "\t\t\tunknown:         %08x\n"
-                   "\t\tflag:       %04x\n"
-                   "\t\tfile:       %04x\n"
-                   "\t\tsymb size:  %08x\n"
-                   "\t\tline size:  %08x\n"
-                   "\t\tline2 size: %08x\n"
-                   "\t\tnSrcFiles:  %08x\n"
-                   "\t\tattribute:  %08x\n"
-                   "\t\treserved/0: %08x\n"
-                   "\t\treserved/1: %08x\n",
-                   sym_file->unknown1,
-                   sym_file->range.segment,
-                   sym_file->range.pad1,
-                   sym_file->range.offset,
-                   sym_file->range.size,
-                   sym_file->range.characteristics,
-                   sym_file->range.index,
-                   sym_file->range.pad2,
-                   sym_file->range.timestamp,
-                   sym_file->range.unknown,
-                   sym_file->flag,
-                   sym_file->file,
-                   sym_file->symbol_size,
-                   sym_file->lineno_size,
-                   sym_file->lineno2_size,
-                   sym_file->nSrcFiles,
-                   sym_file->attribute,
-                   sym_file->reserved[0],
-                   sym_file->reserved[1]);
-        }
-        modimage = reader->read_file(reader, file_nr);
-        if (modimage)
+        file = (const char*)symbols + sizeof(PDB_SYMBOLS);
+        while (file + module_header_size <= (const char*)symbols + sizeof(PDB_SYMBOLS) + symbols->module_size)
         {
-            int total_size = pdb_get_file_size(reader, file_nr);
-
-            if (symbol_size)
-                codeview_dump_symbols((const char*)modimage, sizeof(DWORD), symbol_size);
-
-            /* line number info */
-            if (lineno_size)
-                codeview_dump_linetab((const char*)modimage + symbol_size, TRUE, "        ");
-            else if (lineno2_size) /* actually, only one of the 2 lineno should be present */
-                codeview_dump_linetab2((const char*)modimage + symbol_size, lineno2_size,
-                                       filesimage, "        ");
-            /* what's that part ??? */
-            if (0)
-                dump_data(modimage + symbol_size + lineno_size + lineno2_size,
-                          total_size - (symbol_size + lineno_size + lineno2_size), "    ");
-            free(modimage);
+            if (symbols->version < 19970000)
+            {
+                PDB_SYMBOL_FILE_EX copy;
+                const PDB_SYMBOL_FILE* sym_file = (const PDB_SYMBOL_FILE*)file;
+
+                copy.unknown1 = sym_file->unknown1;
+                copy.range.segment = sym_file->range.segment;
+                copy.range.pad1 = sym_file->range.pad1;
+                copy.range.offset = sym_file->range.offset;
+                copy.range.size = sym_file->range.size;
+                copy.range.characteristics = sym_file->range.characteristics;
+                copy.range.index = sym_file->range.index;
+                copy.range.pad2 = sym_file->range.pad2;
+                copy.range.timestamp = 0;
+                copy.range.unknown = 0;
+                copy.flag = sym_file->flag;
+                copy.stream = sym_file->stream;
+                copy.symbol_size = sym_file->symbol_size;
+                copy.lineno_size = sym_file->lineno_size;
+                copy.lineno2_size = sym_file->lineno2_size;
+                copy.nSrcFiles = sym_file->nSrcFiles;
+                copy.attribute = sym_file->attribute;
+                copy.reserved[0] = 0;
+                copy.reserved[1] = 0;
+                file = pdb_dump_dbi_module(reader, &copy, sym_file->filename);
+            }
+            else
+                file = pdb_dump_dbi_module(reader, (const PDB_SYMBOL_FILE_EX*)file, NULL);
         }
+    }
+    dump_global_symbol(reader, symbols->global_hash_stream);
+    dump_public_symbol(reader, symbols->public_stream);
 
-        file = (char*)((DWORD_PTR)(lib_name + strlen(lib_name) + 1 + 3) & ~3);
+    if (globals_dump_sect("image"))
+    {
+        pdb_dump_fpo(reader, sidx.FPO);
+        pdb_dump_fpo_ext(reader, sidx.FPO_EXT);
+        pdb_dump_sections(reader, sidx.sections_stream);
     }
-    dump_global_symbol(reader, symbols->global_hash_file);
-    dump_public_symbol(reader, symbols->public_file);
 
     free(symbols);
-    free(filesimage);
 }
 
 static BOOL is_bit_set(const unsigned* dw, unsigned len, unsigned i)
@@ -720,17 +886,18 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
     void*  hash = NULL;
     unsigned i, strmsize;
     const unsigned* table;
-    PDB_STRING_TABLE* strbase;
     unsigned *collision;
-    hash = reader->read_file(reader, types->hash_file);
+
+    if (!globals_dump_sect("hash")) return;
+    hash = reader->read_stream(reader, types->hash_stream);
     if (!hash) return;
 
     printf("Types (%s) hash:\n", strmname);
-    strmsize = pdb_get_file_size(reader, types->hash_file);
-    if (types->hash_offset + types->hash_len > strmsize ||
-        (types->last_index - types->first_index) * types->hash_size != types->hash_len ||
-        types->search_offset + types->search_len > strmsize ||
-        types->type_remap_offset + types->type_remap_len > strmsize)
+    strmsize = pdb_get_stream_size(reader, types->hash_stream);
+    if (types->hash_offset + types->hash_size > strmsize ||
+        (types->last_index - types->first_index) * types->hash_value_size != types->hash_size ||
+        types->search_offset + types->search_size > strmsize ||
+        types->type_remap_offset + types->type_remap_size > strmsize)
     {
         printf("\nIncoherent sizes... skipping\n");
         return;
@@ -739,7 +906,7 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
     for (i = types->first_index; i < types->last_index; i++)
     {
         printf("\t\t%08x => ", i);
-        pdb_dump_hash_value((const BYTE*)hash + types->hash_offset + (i - types->first_index) * types->hash_size, types->hash_size);
+        pdb_dump_hash_value((const BYTE*)hash + types->hash_offset + (i - types->first_index) * types->hash_value_size, types->hash_value_size);
         printf("\n");
     }
     /* print collisions in hash table (if any) */
@@ -749,7 +916,7 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
         unsigned head_printed = 0;
 
         collision_arg.hash = (const BYTE*)hash + types->hash_offset;
-        collision_arg.hash_size = types->hash_size;
+        collision_arg.hash_size = types->hash_value_size;
 
         for (i = 0; i < types->last_index - types->first_index; i++) collision[i] = i;
         qsort(collision, types->last_index - types->first_index, sizeof(unsigned), collision_compar);
@@ -757,9 +924,9 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
         {
             unsigned j;
             for (j = i + 1; j < types->last_index - types->first_index; j++)
-                if (memcmp((const BYTE*)hash + types->hash_offset + collision[i] * types->hash_size,
-                           (const BYTE*)hash + types->hash_offset + collision[j] * types->hash_size,
-                           types->hash_size))
+                if (memcmp((const BYTE*)hash + types->hash_offset + collision[i] * types->hash_value_size,
+                           (const BYTE*)hash + types->hash_offset + collision[j] * types->hash_value_size,
+                           types->hash_value_size))
                     break;
             if (j > i + 1)
             {
@@ -770,7 +937,7 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
                     head_printed = 1;
                 }
                 printf("\t\t\tHash ");
-                pdb_dump_hash_value((const BYTE*)hash + types->hash_offset + collision[i] * types->hash_size, types->hash_size);
+                pdb_dump_hash_value((const BYTE*)hash + types->hash_offset + collision[i] * types->hash_value_size, types->hash_value_size);
                 printf(":");
                 for (k = i; k < j; k++)
                     printf(" %x", types->first_index + collision[k]);
@@ -782,11 +949,12 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
     }
     printf("\n\tIndexes => offsets:\n");
     table = (const unsigned*)((const BYTE*)hash + types->search_offset);
-    for (i = 0; i < types->search_len / (2 * sizeof(unsigned)); i += 2)
+    for (i = 0; i < types->search_size / (2 * sizeof(unsigned)); i += 2)
     {
         printf("\t\t%08x => %08x\n", table[2 * i + 0], table[2 * i + 1]);
     }
-    if (types->type_remap_len && (strbase = read_string_table(reader)))
+
+    if (types->type_remap_size)
     {
         unsigned num, capa, count_present, count_deleted;
         const unsigned* present_bitset;
@@ -822,13 +990,12 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
                    is_bit_set(deleted_bitset, count_deleted, i) ? 'D' : '_');
             if (is_bit_set(present_bitset, count_present, i))
             {
-                printf(" %s => ", pdb_get_string_table_entry(strbase, *table++));
-                pdb_dump_hash_value((const BYTE*)table, types->hash_size);
-                table = (const unsigned*)((const BYTE*)table + types->hash_size);
+                printf(" %s => ", pdb_get_string_table_entry(reader->global_string_table, *table++));
+                pdb_dump_hash_value((const BYTE*)table, types->hash_value_size);
+                table = (const unsigned*)((const BYTE*)table + types->hash_value_size);
             }
             printf("\n");
         }
-        free(strbase);
         printf("\n");
     }
     free(hash);
@@ -838,15 +1005,16 @@ static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* type
 static void pdb_dump_types(struct pdb_reader* reader, unsigned strmidx, const char* strmname)
 {
     PDB_TYPES*  types = NULL;
-    BOOL used = has_file_been_read(reader, strmidx);
+    BOOL used = has_stream_been_read(reader, strmidx);
 
-    if (pdb_get_file_size(reader, strmidx) < sizeof(*types))
+    if (!globals_dump_sect(strmidx == 2 ? "TPI" : "IPI")) return;
+    if (pdb_get_stream_size(reader, strmidx) < sizeof(*types))
     {
         if (strmidx == 2)
             printf("-Too small type header\n");
         return;
     }
-    types = reader->read_file(reader, strmidx);
+    types = reader->read_stream(reader, strmidx);
     if (!types) return;
 
     switch (types->version)
@@ -862,7 +1030,7 @@ static void pdb_dump_types(struct pdb_reader* reader, unsigned strmidx, const ch
         if (strmidx == 2)
             printf("-Unknown type info version %d\n", types->version);
         free(types);
-        if (used) clear_file_been_read(reader, strmidx);
+        if (used) clear_stream_been_read(reader, strmidx);
         return;
     }
 
@@ -873,32 +1041,32 @@ static void pdb_dump_types(struct pdb_reader* reader, unsigned strmidx, const ch
            "\tfirst_index:       %x\n"
            "\tlast_index:        %x\n"
            "\ttype_size:         %x\n"
-           "\thash_file:         %x\n"
+           "\thash_stream:       %x\n"
            "\tpad:               %x\n"
-           "\thash_size:         %x\n"
+           "\thash_value_size:   %x\n"
            "\thash_buckets       %x\n"
            "\thash_offset:       %x\n"
-           "\thash_len:          %x\n"
+           "\thash_size:         %x\n"
            "\tsearch_offset:     %x\n"
-           "\tsearch_len:        %x\n"
+           "\tsearch_size:       %x\n"
            "\ttype_remap_offset: %x\n"
-           "\ttype_remap_len:    %x\n",
+           "\ttype_remap_size:   %x\n",
            strmname,
            types->version,
            types->type_offset,
            types->first_index,
            types->last_index,
            types->type_size,
-           types->hash_file,
+           types->hash_stream,
            types->pad,
-           types->hash_size,
+           types->hash_value_size,
            types->hash_num_buckets,
            types->hash_offset,
-           types->hash_len,
+           types->hash_size,
            types->search_offset,
-           types->search_len,
+           types->search_size,
            types->type_remap_offset,
-           types->type_remap_len);
+           types->type_remap_size);
     codeview_dump_types_from_block((const char*)types + types->type_offset, types->type_size);
     pdb_dump_types_hash(reader, types, strmname);
     free(types);
@@ -911,8 +1079,8 @@ static void pdb_dump_fpo(struct pdb_reader* reader, unsigned stream_idx)
     const char*         frame_type[4] = {"Fpo", "Trap", "Tss", "NonFpo"};
 
     if (stream_idx == (WORD)-1) return;
-    fpo = reader->read_file(reader, stream_idx);
-    size = pdb_get_file_size(reader, stream_idx);
+    fpo = reader->read_stream(reader, stream_idx);
+    size = pdb_get_stream_size(reader, stream_idx);
     if (fpo && (size % sizeof(*fpo)) == 0)
     {
         size /= sizeof(*fpo);
@@ -932,14 +1100,11 @@ static void pdb_dump_fpo_ext(struct pdb_reader* reader, unsigned stream_idx)
 {
     PDB_FPO_DATA*       fpoext;
     unsigned            i, size;
-    PDB_STRING_TABLE*   strbase;
 
     if (stream_idx == (WORD)-1) return;
-    strbase = read_string_table(reader);
-    if (!strbase) return;
 
-    fpoext = reader->read_file(reader, stream_idx);
-    size = pdb_get_file_size(reader, stream_idx);
+    fpoext = reader->read_stream(reader, stream_idx);
+    size = pdb_get_stream_size(reader, stream_idx);
     if (fpoext && (size % sizeof(*fpoext)) == 0)
     {
         size /= sizeof(*fpoext);
@@ -950,132 +1115,117 @@ static void pdb_dump_fpo_ext(struct pdb_reader* reader, unsigned stream_idx)
             printf("\t%08x %08x %8x %8x %8x %6x   %8x %08x %s\n",
                    fpoext[i].start, fpoext[i].func_size, fpoext[i].locals_size, fpoext[i].params_size,
                    fpoext[i].maxstack_size, fpoext[i].prolog_size, fpoext[i].savedregs_size, fpoext[i].flags,
-                   pdb_get_string_table_entry(strbase, fpoext[i].str_offset));
+                   pdb_get_string_table_entry(reader->global_string_table, fpoext[i].str_offset));
         }
     }
     free(fpoext);
-    free(strbase);
 }
 
-static void pdb_dump_segments(struct pdb_reader* reader, unsigned stream_idx)
+static void pdb_dump_sections(struct pdb_reader* reader, unsigned stream_idx)
 {
-    const char* segs;
-    DWORD       size;
-    const char* ptr;
+    const char*                 segs;
+    DWORD                       size;
+    const IMAGE_SECTION_HEADER* sect_hdr;
 
     if (stream_idx == (WORD)-1) return;
-    segs = reader->read_file(reader, stream_idx);
+    segs = reader->read_stream(reader, stream_idx);
 
     if (segs)
     {
-        size = pdb_get_file_size(reader, stream_idx);
-        for (ptr = segs; ptr < segs + size; )
+        printf("Sections:\n");
+        size = pdb_get_stream_size(reader, stream_idx);
+        for (sect_hdr = (const IMAGE_SECTION_HEADER*)segs; (const char*)sect_hdr < segs + size; sect_hdr++)
         {
-            printf("Segment %s\n", ptr);
-            ptr += (strlen(ptr) + 1 + 3) & ~3;
-            printf("\tdword[0]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[1]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[2]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[3]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[4]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[5]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[6]: %08x\n", *(UINT *)ptr); ptr += 4;
-            printf("\tdword[7]: %08x\n", *(UINT *)ptr); ptr += 4;
+            printf("\tSection:                %-8.8s\n", sect_hdr->Name);
+            printf("\t\tVirtual size:         %08x\n",   (unsigned)sect_hdr->Misc.VirtualSize);
+            printf("\t\tVirtualAddress:       %08x\n",   (unsigned)sect_hdr->VirtualAddress);
+            printf("\t\tSizeOfRawData:        %08x\n",   (unsigned)sect_hdr->SizeOfRawData);
+            printf("\t\tPointerToRawData:     %08x\n",   (unsigned)sect_hdr->PointerToRawData);
+            printf("\t\tPointerToRelocations: %08x\n",   (unsigned)sect_hdr->PointerToRelocations);
+            printf("\t\tPointerToLinenumbers: %08x\n",   (unsigned)sect_hdr->PointerToLinenumbers);
+            printf("\t\tNumberOfRelocations:  %u\n",     (unsigned)sect_hdr->NumberOfRelocations);
+            printf("\t\tNumberOfLinenumbers:  %u\n",     (unsigned)sect_hdr->NumberOfLinenumbers);
+            printf("\t\tCharacteristics:      %08x",     (unsigned)sect_hdr->Characteristics);
+            dump_section_characteristics(sect_hdr->Characteristics, " ");
+            printf("\n");
         }
         free((char*)segs);
-    } else printf("nosdfsdffd\n");
+    }
 }
 
 static const char       pdb2[] = "Microsoft C/C++ program database 2.00";
 
-static void pdb_jg_dump(void)
+static void pdb_jg_dump_header_root(struct pdb_reader* reader)
 {
-    struct pdb_reader   reader;
+    UINT *pdw, *ok_bits;
+    UINT i, numok, count;
+
+    if (!globals_dump_sect("PDB")) return;
 
-    /*
-     * Read in TOC and well-known files
-     */
-    pdb_jg_init(&reader);
     printf("Header (JG):\n"
-           "\tident:      %.*s\n"
-           "\tsignature:  %08x\n"
-           "\tblock_size: %08x\n"
-           "\tfree_list:  %04x\n"
-           "\ttotal_alloc:%04x\n",
-           (int)sizeof(pdb2) - 1, reader.u.jg.header->ident,
-           reader.u.jg.header->signature,
-           reader.u.jg.header->block_size,
-           reader.u.jg.header->free_list,
-           reader.u.jg.header->total_alloc);
-
-    reader.u.jg.root = reader.read_file(&reader, 1);
-    if (reader.u.jg.root)
-    {
-        UINT *pdw, *ok_bits;
-        UINT i, numok, count;
-        PDB_STREAM_INDEXES sidx;
-
-        printf("Root:\n"
-               "\tVersion:       %u\n"
-               "\tTimeDateStamp: %08x\n"
-               "\tAge:           %08x\n"
-               "\tnames:         %d\n",
-               reader.u.jg.root->Version,
-               reader.u.jg.root->TimeDateStamp,
-               reader.u.jg.root->Age,
-               (unsigned)reader.u.jg.root->cbNames);
-
-        pdw = (UINT *)(reader.u.jg.root->names + reader.u.jg.root->cbNames);
-        numok = *pdw++;
-        count = *pdw++;
-        printf("\tStreams directory:\n"
-               "\t\tok:        %08x\n"
-               "\t\tcount:     %08x\n"
-               "\t\ttable:\n",
-               numok, count);
-
-        /* bitfield: first dword is len (in dword), then data */
-        ok_bits = pdw;
-        pdw += *ok_bits++ + 1;
-        if (*pdw++ != 0)
-        {
-            printf("unexpected value\n");
-            return;
-        }
+           "\tident:             %.*s\n"
+           "\tsignature:         %08x\n"
+           "\tblock_size:        %08x\n"
+           "\tfree_list_block:   %04x\n"
+           "\ttotal_alloc:       %04x\n",
+           (int)sizeof(pdb2) - 1, reader->u.jg.header->ident,
+           reader->u.jg.header->signature,
+           reader->u.jg.header->block_size,
+           reader->u.jg.header->free_list_block,
+           reader->u.jg.header->total_alloc);
+
+    printf("Root:\n"
+           "\tVersion:       %u\n"
+           "\tTimeDateStamp: %08x\n"
+           "\tAge:           %08x\n"
+           "\tnames:         %d\n",
+           reader->u.jg.root->Version,
+           reader->u.jg.root->TimeDateStamp,
+           reader->u.jg.root->Age,
+           (unsigned)reader->u.jg.root->cbNames);
+
+    pdw = (UINT *)(reader->u.jg.root->names + reader->u.jg.root->cbNames);
+    numok = *pdw++;
+    count = *pdw++;
+    printf("\tStreams directory:\n"
+           "\t\tok:        %08x\n"
+           "\t\tcount:     %08x\n"
+           "\t\ttable:\n",
+           numok, count);
 
-        for (i = 0; i < count; i++)
-        {
-            if (ok_bits[i / 32] & (1 << (i % 32)))
-            {
-                UINT string_idx, stream_idx;
-                string_idx = *pdw++;
-                stream_idx = *pdw++;
-                printf("\t\t\t%2d) %-20s => %x\n", i, &reader.u.jg.root->names[string_idx], stream_idx);
-                numok--;
-            }
-        }
-        if (numok) printf(">>> unmatched present field with found\n");
+    /* bitfield: first dword is len (in dword), then data */
+    ok_bits = pdw;
+    pdw += *ok_bits++ + 1;
+    if (*pdw++ != 0)
+    {
+        printf("unexpected value\n");
+        return;
+    }
 
-        /* Check for unknown versions */
-        switch (reader.u.jg.root->Version)
+    for (i = 0; i < count; i++)
+    {
+        if (ok_bits[i / 32] & (1 << (i % 32)))
         {
-        case 19950623:      /* VC 4.0 */
-        case 19950814:
-        case 19960307:      /* VC 5.0 */
-        case 19970604:      /* VC 6.0 */
-            break;
-        default:
-            printf("-Unknown root block version %d\n", reader.u.jg.root->Version);
+            UINT string_idx, stream_idx;
+            string_idx = *pdw++;
+            stream_idx = *pdw++;
+            printf("\t\t\t%2d) %-20s => %x\n", i, &reader->u.jg.root->names[string_idx], stream_idx);
+            numok--;
         }
-        pdb_dump_types(&reader, 2, "TPI");
-        pdb_dump_types(&reader, 4, "IPI");
-        pdb_dump_symbols(&reader, &sidx);
-        pdb_dump_fpo(&reader, sidx.FPO);
-        pdb_dump_segments(&reader, sidx.segments);
     }
-    else printf("-Unable to get root\n");
+    if (numok) printf(">>> unmatched present field with found\n");
 
-    pdb_exit(&reader);
+    /* Check for unknown versions */
+    switch (reader->u.jg.root->Version)
+    {
+    case 19950623:      /* VC 4.0 */
+    case 19950814:
+    case 19960307:      /* VC 5.0 */
+    case 19970604:      /* VC 6.0 */
+        break;
+    default:
+        printf("-Unknown root block version %d\n", reader->u.jg.root->Version);
+    }
 }
 
 static void* pdb_ds_read(const struct PDB_DS_HEADER* header, const UINT *block_list, int size)
@@ -1095,135 +1245,151 @@ static void* pdb_ds_read(const struct PDB_DS_HEADER* header, const UINT *block_l
     return buffer;
 }
 
-static void* pdb_ds_read_file(struct pdb_reader* reader, DWORD file_number)
+static void* pdb_ds_read_stream(struct pdb_reader* reader, DWORD stream_number)
 {
     const UINT *block_list;
     UINT i;
 
-    if (!reader->u.ds.toc || file_number >= reader->u.ds.toc->num_files) return NULL;
+    if (!reader->u.ds.toc || stream_number >= reader->u.ds.toc->num_streams) return NULL;
 
-    mark_file_been_read(reader, file_number);
-    if (reader->u.ds.toc->file_size[file_number] == 0 ||
-        reader->u.ds.toc->file_size[file_number] == 0xFFFFFFFF)
+    mark_stream_been_read(reader, stream_number);
+    if (reader->u.ds.toc->stream_size[stream_number] == 0 ||
+        reader->u.ds.toc->stream_size[stream_number] == 0xFFFFFFFF)
         return NULL;
-    block_list = reader->u.ds.toc->file_size + reader->u.ds.toc->num_files;
-    for (i = 0; i < file_number; i++)
-        block_list += (reader->u.ds.toc->file_size[i] + reader->u.ds.header->block_size - 1) /
+    block_list = reader->u.ds.toc->stream_size + reader->u.ds.toc->num_streams;
+    for (i = 0; i < stream_number; i++)
+        block_list += (reader->u.ds.toc->stream_size[i] + reader->u.ds.header->block_size - 1) /
             reader->u.ds.header->block_size;
 
-    return pdb_ds_read(reader->u.ds.header, block_list, reader->u.ds.toc->file_size[file_number]);
+    return pdb_ds_read(reader->u.ds.header, block_list, reader->u.ds.toc->stream_size[stream_number]);
 }
 
 static BOOL pdb_ds_init(struct pdb_reader* reader)
 {
     reader->u.ds.header = PRD(0, sizeof(*reader->u.ds.header));
     if (!reader->u.ds.header) return FALSE;
-    reader->read_file = pdb_ds_read_file;
+    reader->read_stream = pdb_ds_read_stream;
     reader->u.ds.toc = pdb_ds_read(reader->u.ds.header,
-                                   (const UINT *)((const char*)reader->u.ds.header + reader->u.ds.header->toc_page * reader->u.ds.header->block_size),
+                                   (const UINT *)((const char*)reader->u.ds.header + reader->u.ds.header->toc_block * reader->u.ds.header->block_size),
                                    reader->u.ds.header->toc_size);
-    memset(reader->file_used, 0, sizeof(reader->file_used));
+    memset(reader->stream_used, 0, sizeof(reader->stream_used));
+    reader->u.ds.root = reader->read_stream(reader, 1);
+    if (!reader->u.ds.root) return FALSE;
     return TRUE;
 }
 
 static const char       pdb7[] = "Microsoft C/C++ MSF 7.00";
 
-static void pdb_ds_dump(void)
+static void pdb_ds_dump_header_root(struct pdb_reader* reader)
 {
-    struct pdb_reader   reader;
+    unsigned int i, j, ofs;
+    const UINT *block_list;
+    UINT *pdw, *ok_bits;
+    UINT numok, count;
+    unsigned strmsize;
 
-    pdb_ds_init(&reader);
+    if (!globals_dump_sect("PDB")) return;
+    strmsize = pdb_get_stream_size(reader, 1);
     printf("Header (DS)\n"
            "\tsignature:        %.*s\n"
            "\tblock_size:       %08x\n"
-           "\tunknown1:         %08x\n"
-           "\tnum_pages:        %08x\n"
+           "\tfree_list_block:  %08x\n"
+           "\tnum_blocks:       %08x\n"
            "\ttoc_size:         %08x\n"
            "\tunknown2:         %08x\n"
-           "\ttoc_page:         %08x\n",
-           (int)sizeof(pdb7) - 1, reader.u.ds.header->signature,
-           reader.u.ds.header->block_size,
-           reader.u.ds.header->unknown1,
-           reader.u.ds.header->num_pages,
-           reader.u.ds.header->toc_size,
-           reader.u.ds.header->unknown2,
-           reader.u.ds.header->toc_page);
-
-    /* files with static indexes:
-     *  0: JG says old toc pages
-     *  1: root structure
-     *  2: types
-     *  3: modules
-     *  4: types (second stream)
-     * other known streams:
-     * - string table: its index is in the stream table from ROOT object under "/names"
-     * - type hash table: its index is in the types header (2 and 4)
-     * - global and public streams: from symbol stream header
-     * those streams get their indexes out of the PDB_STREAM_INDEXES object
-     * - FPO data
-     * - segments
-     * - extended FPO data
-     */
-    mark_file_been_read(&reader, 0); /* mark stream #0 as read */
-    reader.u.ds.root = reader.read_file(&reader, 1);
-    if (reader.u.ds.root)
+           "\ttoc_block:        %08x\n",
+           (int)sizeof(pdb7) - 1, reader->u.ds.header->signature,
+           reader->u.ds.header->block_size,
+           reader->u.ds.header->free_list_block,
+           reader->u.ds.header->num_blocks,
+           reader->u.ds.header->toc_size,
+           reader->u.ds.header->unknown2,
+           reader->u.ds.header->toc_block);
+
+    block_list = reader->u.ds.toc->stream_size + reader->u.ds.toc->num_streams;
+    printf("\t\tnum_streams:    %u\n", reader->u.ds.toc->num_streams);
+    for (ofs = i = 0; i < reader->u.ds.toc->num_streams; i++)
     {
-        UINT *pdw, *ok_bits;
-        UINT i, numok, count;
-        PDB_STREAM_INDEXES sidx;
-
-        printf("Root:\n"
-               "\tVersion:              %u\n"
-               "\tTimeDateStamp:        %08x\n"
-               "\tAge:                  %08x\n"
-               "\tguid                  %s\n"
-               "\tcbNames:              %08x\n",
-               reader.u.ds.root->Version,
-               reader.u.ds.root->TimeDateStamp,
-               reader.u.ds.root->Age,
-               get_guid_str(&reader.u.ds.root->guid),
-               reader.u.ds.root->cbNames);
-        pdw = (UINT *)(reader.u.ds.root->names + reader.u.ds.root->cbNames);
-        numok = *pdw++;
-        count = *pdw++;
-        printf("\tStreams directory:\n"
-               "\t\tok:        %08x\n"
-               "\t\tcount:     %08x\n"
-               "\t\ttable:\n",
-               numok, count);
-
-        /* bitfield: first dword is len (in dword), then data */
-        ok_bits = pdw;
-        pdw += *ok_bits++ + 1;
-        if (*pdw++ != 0)
+        unsigned int nblk = (reader->u.ds.toc->stream_size[i] + reader->u.ds.header->block_size - 1) / reader->u.ds.header->block_size;
+        printf("\t\tstream[%#x]:\tsize: %u\n", i, reader->u.ds.toc->stream_size[i]);
+        if (nblk)
         {
-            printf("unexpected value\n");
-            return;
+            for (j = 0; j < nblk; j++)
+            {
+                if (j % 16 == 0) printf("\t\t\t");
+                printf("%4x ", block_list[ofs + j]);
+                if (j % 16 == 15 || (j + 1 == nblk)) printf("\n");
+            }
+            ofs += nblk;
         }
+    }
 
-        for (i = 0; i < count; i++)
+    printf("Root:\n"
+           "\tVersion:              %u\n"
+           "\tTimeDateStamp:        %08x\n"
+           "\tAge:                  %08x\n"
+           "\tguid                  %s\n"
+           "\tcbNames:              %08x\n",
+           reader->u.ds.root->Version,
+           reader->u.ds.root->TimeDateStamp,
+           reader->u.ds.root->Age,
+           get_guid_str(&reader->u.ds.root->guid),
+           reader->u.ds.root->cbNames);
+    pdw = (UINT *)(reader->u.ds.root->names + reader->u.ds.root->cbNames);
+    numok = *pdw++;
+    count = *pdw++;
+    printf("\tStreams directory:\n"
+           "\t\tok:        %08x\n"
+           "\t\tcount:     %08x\n"
+           "\t\ttable:\n",
+           numok, count);
+
+    /* bitfield: first dword is len (in dword), then data */
+    ok_bits = pdw;
+    pdw += *ok_bits++ + 1;
+    if (*pdw++ != 0)
+    {
+        printf("unexpected value\n");
+        return;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        if (ok_bits[i / 32] & (1 << (i % 32)))
         {
-            if (ok_bits[i / 32] & (1 << (i % 32)))
+            UINT string_idx, stream_idx;
+            string_idx = *pdw++;
+            stream_idx = *pdw++;
+            printf("\t\t\t%2d) %-20s => %x\n", i, &reader->u.ds.root->names[string_idx], stream_idx);
+            numok--;
+        }
+    }
+    if (numok) printf(">>> unmatched present field with found\n");
+    if (*pdw++ != 0)
+    {
+        printf("unexpected value\n");
+        return;
+    }
+
+    if (pdw + 1 <= (UINT*)((char*)reader->u.ds.root + strmsize))
+    {
+        /* extra information (version reference and features) */
+        printf("\tVersion and features\n");
+        while (pdw + 1 <= (UINT*)((char*)reader->u.ds.root + strmsize))
+        {
+            switch (*pdw)
             {
-                UINT string_idx, stream_idx;
-                string_idx = *pdw++;
-                stream_idx = *pdw++;
-                printf("\t\t\t%2d) %-20s => %x\n", i, &reader.u.ds.root->names[string_idx], stream_idx);
-                numok--;
+            /* version reference */
+            case 20091201:              printf("\t\tVC110\n"); break;
+            case 20140508:              printf("\t\tVC140\n"); break;
+            /* features */
+            case 0x4D544F4E /* NOTM */: printf("\t\tNo type merge\n"); break;
+            case 0x494E494D /* MINI */: printf("\t\tMinimal debug info\n"); break;
+            default:                    printf("\t\tUnknown value %x\n", *pdw);
             }
+            pdw++;
         }
-        if (numok) printf(">>> unmatched present field with found\n");
-
-        pdb_dump_types(&reader, 2, "TPI");
-        pdb_dump_types(&reader, 4, "IPI");
-        pdb_dump_symbols(&reader, &sidx);
-        pdb_dump_fpo(&reader, sidx.FPO);
-        pdb_dump_fpo_ext(&reader, sidx.FPO_EXT);
-        pdb_dump_segments(&reader, sidx.segments);
     }
-    else printf("-Unable to get root\n");
-
-    pdb_exit(&reader);
 }
 
 enum FileSig get_kind_pdb(void)
@@ -1241,20 +1407,41 @@ enum FileSig get_kind_pdb(void)
 
 void pdb_dump(void)
 {
-    const char* head;
+    const BYTE* head;
+    const char** saved_dumpsect = globals.dumpsect;
+    static const char* default_dumpsect[] = {"DBI", "TPI", "IPI", NULL};
+    struct pdb_reader reader;
 
-/*    init_types(); */
-    head = PRD(0, sizeof(pdb2) - 1);
-    if (head && !memcmp(head, pdb2, sizeof(pdb2) - 1))
+    if (!globals.dumpsect) globals.dumpsect = default_dumpsect;
+
+    if ((head = PRD(0, sizeof(pdb2) - 1)) && !memcmp(head, pdb2, sizeof(pdb2) - 1))
     {
-        pdb_jg_dump();
-        return;
+        if (!pdb_jg_init(&reader))
+        {
+            printf("Unable to get header information\n");
+            return;
+        }
+
+        pdb_jg_dump_header_root(&reader);
     }
-    head = PRD(0, sizeof(pdb7) - 1);
-    if (head && !memcmp(head, pdb7, sizeof(pdb7) - 1))
+    else if ((head = PRD(0, sizeof(pdb7) - 1)) && !memcmp(head, pdb7, sizeof(pdb7) - 1))
     {
-        pdb_ds_dump();
-        return;
+        if (!pdb_ds_init(&reader))
+        {
+            printf("Unable to get header information\n");
+            return;
+        }
+        pdb_ds_dump_header_root(&reader);
     }
-    printf("Unrecognized header %s\n", head);
+    mark_stream_been_read(&reader, 0); /* mark stream #0 (old TOC) as read */
+
+    reader.global_string_table = read_string_table(&reader);
+
+    pdb_dump_types(&reader, 2, "TPI");
+    pdb_dump_types(&reader, 4, "IPI");
+    pdb_dump_symbols(&reader);
+
+    pdb_exit(&reader);
+
+    globals.dumpsect = saved_dumpsect;
 }
diff --git a/tools/winedump/pe.c b/tools/winedump/pe.c
index 7ec378a19b8..34b34217d17 100644
--- a/tools/winedump/pe.c
+++ b/tools/winedump/pe.c
@@ -33,6 +33,7 @@
 #define IMAGE_DLLCHARACTERISTICS_PREFER_NATIVE 0x0010 /* Wine extension */
 
 static const IMAGE_NT_HEADERS32*        PE_nt_headers;
+static const IMAGE_NT_HEADERS32*        PE_alt_headers;  /* alternative headers for hybrid dlls */
 
 static const char builtin_signature[] = "Wine builtin DLL";
 static const char fakedll_signature[] = "Wine placeholder DLL";
@@ -105,11 +106,11 @@ void print_fake_dll( void )
     }
 }
 
-static const void *get_dir_and_size(unsigned int idx, unsigned int *size)
+static const void *get_data_dir(const IMAGE_NT_HEADERS32 *hdr, unsigned int idx, unsigned int *size)
 {
-    if(PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+    if(hdr->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
     {
-        const IMAGE_OPTIONAL_HEADER64 *opt = (const IMAGE_OPTIONAL_HEADER64*)&PE_nt_headers->OptionalHeader;
+        const IMAGE_OPTIONAL_HEADER64 *opt = (const IMAGE_OPTIONAL_HEADER64*)&hdr->OptionalHeader;
         if (idx >= opt->NumberOfRvaAndSizes)
             return NULL;
         if(size)
@@ -119,7 +120,7 @@ static const void *get_dir_and_size(unsigned int idx, unsigned int *size)
     }
     else
     {
-        const IMAGE_OPTIONAL_HEADER32 *opt = (const IMAGE_OPTIONAL_HEADER32*)&PE_nt_headers->OptionalHeader;
+        const IMAGE_OPTIONAL_HEADER32 *opt = (const IMAGE_OPTIONAL_HEADER32*)&hdr->OptionalHeader;
         if (idx >= opt->NumberOfRvaAndSizes)
             return NULL;
         if(size)
@@ -129,11 +130,25 @@ static const void *get_dir_and_size(unsigned int idx, unsigned int *size)
     }
 }
 
+static const void *get_dir_and_size(unsigned int idx, unsigned int *size)
+{
+    return get_data_dir( PE_nt_headers, idx, size );
+}
+
 static	const void*	get_dir(unsigned idx)
 {
     return get_dir_and_size(idx, 0);
 }
 
+static const void *get_alt_dir_and_size(unsigned int idx, unsigned int *size)
+{
+    const void *dir;
+    if (!PE_alt_headers) return NULL;
+    dir = get_data_dir( PE_alt_headers, idx, size );
+    if (dir == get_dir(idx)) return NULL;
+    return dir;
+}
+
 static const char * const DirectoryNames[16] = {
     "EXPORT",		"IMPORT",	"RESOURCE", 	"EXCEPTION",
     "SECURITY", 	"BASERELOC", 	"DEBUG", 	"ARCHITECTURE",
@@ -154,6 +169,39 @@ static const char *get_magic_type(WORD magic)
     return "???";
 }
 
+static const void *get_hybrid_metadata(void)
+{
+    unsigned int size;
+
+    if (PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+    {
+        const IMAGE_LOAD_CONFIG_DIRECTORY64 *cfg = get_dir_and_size(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, &size);
+        if (!cfg) return 0;
+        size = min( size, cfg->Size );
+        if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, CHPEMetadataPointer )) return 0;
+        return RVA( cfg->CHPEMetadataPointer - ((const IMAGE_OPTIONAL_HEADER64 *)&PE_nt_headers->OptionalHeader)->ImageBase, 1 );
+    }
+    else
+    {
+        const IMAGE_LOAD_CONFIG_DIRECTORY32 *cfg = get_dir_and_size(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, &size);
+        if (!cfg) return 0;
+        size = min( size, cfg->Size );
+        if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, CHPEMetadataPointer )) return 0;
+        return RVA( cfg->CHPEMetadataPointer - PE_nt_headers->OptionalHeader.ImageBase, 1 );
+    }
+}
+
+static inline const char *longlong_str( ULONGLONG value )
+{
+    static char buffer[20];
+
+    if (sizeof(value) > sizeof(unsigned long) && value >> 32)
+        sprintf(buffer, "%lx%08lx", (unsigned long)(value >> 32), (unsigned long)value);
+    else
+        sprintf(buffer, "%lx", (unsigned long)value);
+    return buffer;
+}
+
 static inline void print_word(const char *title, WORD value)
 {
     printf("  %-34s 0x%-4X         %u\n", title, value, value);
@@ -166,11 +214,7 @@ static inline void print_dword(const char *title, UINT value)
 
 static inline void print_longlong(const char *title, ULONGLONG value)
 {
-    printf("  %-34s 0x", title);
-    if (sizeof(value) > sizeof(unsigned long) && value >> 32)
-        printf("%lx%08lx\n", (unsigned long)(value >> 32), (unsigned long)value);
-    else
-        printf("%lx\n", (unsigned long)value);
+    printf("  %-34s 0x%s\n", title, longlong_str(value));
 }
 
 static inline void print_ver(const char *title, BYTE major, BYTE minor)
@@ -340,16 +384,25 @@ void dump_optional_header(const IMAGE_OPTIONAL_HEADER32 *optionalHeader, UINT he
     }
 }
 
-void dump_file_header(const IMAGE_FILE_HEADER *fileHeader)
+void dump_file_header(const IMAGE_FILE_HEADER *fileHeader, BOOL is_hybrid)
 {
+    const char *name = get_machine_str(fileHeader->Machine);
+
     printf("File Header\n");
 
-    printf("  Machine:                      %04X (%s)\n",
-	   fileHeader->Machine, get_machine_str(fileHeader->Machine));
+    if (is_hybrid)
+    {
+        switch (fileHeader->Machine)
+        {
+        case IMAGE_FILE_MACHINE_I386: name = "CHPE"; break;
+        case IMAGE_FILE_MACHINE_AMD64: name = "ARM64EC"; break;
+        case IMAGE_FILE_MACHINE_ARM64: name = "ARM64X"; break;
+        }
+    }
+    printf("  Machine:                      %04X (%s)\n", fileHeader->Machine, name);
     printf("  Number of Sections:           %d\n", fileHeader->NumberOfSections);
-    printf("  TimeDateStamp:                %08X (%s) offset %lu\n",
-	   (UINT)fileHeader->TimeDateStamp, get_time_str(fileHeader->TimeDateStamp),
-	   Offset(&(fileHeader->TimeDateStamp)));
+    printf("  TimeDateStamp:                %08X (%s)\n",
+	   (UINT)fileHeader->TimeDateStamp, get_time_str(fileHeader->TimeDateStamp));
     printf("  PointerToSymbolTable:         %08X\n", (UINT)fileHeader->PointerToSymbolTable);
     printf("  NumberOfSymbols:              %08X\n", (UINT)fileHeader->NumberOfSymbols);
     printf("  SizeOfOptionalHeader:         %04X\n", (UINT)fileHeader->SizeOfOptionalHeader);
@@ -377,31 +430,19 @@ void dump_file_header(const IMAGE_FILE_HEADER *fileHeader)
 
 static	void	dump_pe_header(void)
 {
-    dump_file_header(&PE_nt_headers->FileHeader);
-    dump_optional_header((const IMAGE_OPTIONAL_HEADER32*)&PE_nt_headers->OptionalHeader, PE_nt_headers->FileHeader.SizeOfOptionalHeader);
+    dump_file_header(&PE_nt_headers->FileHeader, get_hybrid_metadata() != NULL);
+    dump_optional_header((const IMAGE_OPTIONAL_HEADER32*)&PE_nt_headers->OptionalHeader,
+                         PE_nt_headers->FileHeader.SizeOfOptionalHeader);
+    if (!PE_alt_headers) return;
+    printf( "Alternate Headers\n\n");
+    dump_file_header(&PE_alt_headers->FileHeader, FALSE);
+    dump_optional_header((const IMAGE_OPTIONAL_HEADER32*)&PE_alt_headers->OptionalHeader,
+                         PE_alt_headers->FileHeader.SizeOfOptionalHeader);
 }
 
-void dump_section(const IMAGE_SECTION_HEADER *sectHead, const char* strtable)
+void dump_section_characteristics(DWORD characteristics, const char* sep)
 {
-        unsigned offset;
-
-        /* long section name ? */
-        if (strtable && sectHead->Name[0] == '/' &&
-            ((offset = atoi((const char*)sectHead->Name + 1)) < *(const DWORD*)strtable))
-            printf("  %.8s (%s)", sectHead->Name, strtable + offset);
-        else
-	    printf("  %-8.8s", sectHead->Name);
-	printf("   VirtSize: 0x%08x  VirtAddr:  0x%08x\n",
-               (UINT)sectHead->Misc.VirtualSize, (UINT)sectHead->VirtualAddress);
-	printf("    raw data offs:   0x%08x  raw data size: 0x%08x\n",
-	       (UINT)sectHead->PointerToRawData, (UINT)sectHead->SizeOfRawData);
-	printf("    relocation offs: 0x%08x  relocations:   0x%08x\n",
-	       (UINT)sectHead->PointerToRelocations, (UINT)sectHead->NumberOfRelocations);
-	printf("    line # offs:     %-8u  line #'s:      %-8u\n",
-	       (UINT)sectHead->PointerToLinenumbers, (UINT)sectHead->NumberOfLinenumbers);
-	printf("    characteristics: 0x%08x\n", (UINT)sectHead->Characteristics);
-	printf("    ");
-#define X(b,s)	if (sectHead->Characteristics & b) printf("  " s)
+#define X(b,s)	if (characteristics & b) printf("%s%s", sep, s)
 /* #define IMAGE_SCN_TYPE_REG			0x00000000 - Reserved */
 /* #define IMAGE_SCN_TYPE_DSECT			0x00000001 - Reserved */
 /* #define IMAGE_SCN_TYPE_NOLOAD		0x00000002 - Reserved */
@@ -409,57 +450,81 @@ void dump_section(const IMAGE_SECTION_HEADER *sectHead, const char* strtable)
 /* #define IMAGE_SCN_TYPE_NO_PAD		0x00000008 - Reserved */
 /* #define IMAGE_SCN_TYPE_COPY			0x00000010 - Reserved */
 
-	X(IMAGE_SCN_CNT_CODE, 			"CODE");
-	X(IMAGE_SCN_CNT_INITIALIZED_DATA, 	"INITIALIZED_DATA");
-	X(IMAGE_SCN_CNT_UNINITIALIZED_DATA, 	"UNINITIALIZED_DATA");
+    X(IMAGE_SCN_CNT_CODE, 		"CODE");
+    X(IMAGE_SCN_CNT_INITIALIZED_DATA, 	"INITIALIZED_DATA");
+    X(IMAGE_SCN_CNT_UNINITIALIZED_DATA, "UNINITIALIZED_DATA");
 
-	X(IMAGE_SCN_LNK_OTHER, 			"LNK_OTHER");
-	X(IMAGE_SCN_LNK_INFO, 			"LNK_INFO");
+    X(IMAGE_SCN_LNK_OTHER, 		"LNK_OTHER");
+    X(IMAGE_SCN_LNK_INFO, 		"LNK_INFO");
 /* #define	IMAGE_SCN_TYPE_OVER		0x00000400 - Reserved */
-	X(IMAGE_SCN_LNK_REMOVE, 		"LNK_REMOVE");
-	X(IMAGE_SCN_LNK_COMDAT, 		"LNK_COMDAT");
-
-/* 						0x00002000 - Reserved */
-/* #define IMAGE_SCN_MEM_PROTECTED 		0x00004000 - Obsolete */
-	X(IMAGE_SCN_MEM_FARDATA, 		"MEM_FARDATA");
-
-/* #define IMAGE_SCN_MEM_SYSHEAP		0x00010000 - Obsolete */
-	X(IMAGE_SCN_MEM_PURGEABLE, 		"MEM_PURGEABLE");
-	X(IMAGE_SCN_MEM_16BIT, 			"MEM_16BIT");
-	X(IMAGE_SCN_MEM_LOCKED, 		"MEM_LOCKED");
-	X(IMAGE_SCN_MEM_PRELOAD, 		"MEM_PRELOAD");
-
-        switch (sectHead->Characteristics & IMAGE_SCN_ALIGN_MASK)
-        {
-#define X2(b,s)	case b: printf("  " s); break
-        X2(IMAGE_SCN_ALIGN_1BYTES, 		"ALIGN_1BYTES");
-        X2(IMAGE_SCN_ALIGN_2BYTES, 		"ALIGN_2BYTES");
-        X2(IMAGE_SCN_ALIGN_4BYTES, 		"ALIGN_4BYTES");
-        X2(IMAGE_SCN_ALIGN_8BYTES, 		"ALIGN_8BYTES");
-        X2(IMAGE_SCN_ALIGN_16BYTES, 		"ALIGN_16BYTES");
-        X2(IMAGE_SCN_ALIGN_32BYTES, 		"ALIGN_32BYTES");
-        X2(IMAGE_SCN_ALIGN_64BYTES, 		"ALIGN_64BYTES");
-        X2(IMAGE_SCN_ALIGN_128BYTES, 		"ALIGN_128BYTES");
-        X2(IMAGE_SCN_ALIGN_256BYTES, 		"ALIGN_256BYTES");
-        X2(IMAGE_SCN_ALIGN_512BYTES, 		"ALIGN_512BYTES");
-        X2(IMAGE_SCN_ALIGN_1024BYTES, 		"ALIGN_1024BYTES");
-        X2(IMAGE_SCN_ALIGN_2048BYTES, 		"ALIGN_2048BYTES");
-        X2(IMAGE_SCN_ALIGN_4096BYTES, 		"ALIGN_4096BYTES");
-        X2(IMAGE_SCN_ALIGN_8192BYTES, 		"ALIGN_8192BYTES");
+    X(IMAGE_SCN_LNK_REMOVE, 		"LNK_REMOVE");
+    X(IMAGE_SCN_LNK_COMDAT, 		"LNK_COMDAT");
+
+/* 					0x00002000 - Reserved */
+/* #define IMAGE_SCN_MEM_PROTECTED 	0x00004000 - Obsolete */
+    X(IMAGE_SCN_MEM_FARDATA, 		"MEM_FARDATA");
+
+/* #define IMAGE_SCN_MEM_SYSHEAP	0x00010000 - Obsolete */
+    X(IMAGE_SCN_MEM_PURGEABLE, 		"MEM_PURGEABLE");
+    X(IMAGE_SCN_MEM_16BIT, 		"MEM_16BIT");
+    X(IMAGE_SCN_MEM_LOCKED, 		"MEM_LOCKED");
+    X(IMAGE_SCN_MEM_PRELOAD, 		"MEM_PRELOAD");
+
+    switch (characteristics & IMAGE_SCN_ALIGN_MASK)
+    {
+#define X2(b,s)	case b: printf("%s%s", sep, s); break
+        X2(IMAGE_SCN_ALIGN_1BYTES, 	"ALIGN_1BYTES");
+        X2(IMAGE_SCN_ALIGN_2BYTES, 	"ALIGN_2BYTES");
+        X2(IMAGE_SCN_ALIGN_4BYTES, 	"ALIGN_4BYTES");
+        X2(IMAGE_SCN_ALIGN_8BYTES, 	"ALIGN_8BYTES");
+        X2(IMAGE_SCN_ALIGN_16BYTES, 	"ALIGN_16BYTES");
+        X2(IMAGE_SCN_ALIGN_32BYTES, 	"ALIGN_32BYTES");
+        X2(IMAGE_SCN_ALIGN_64BYTES, 	"ALIGN_64BYTES");
+        X2(IMAGE_SCN_ALIGN_128BYTES, 	"ALIGN_128BYTES");
+        X2(IMAGE_SCN_ALIGN_256BYTES, 	"ALIGN_256BYTES");
+        X2(IMAGE_SCN_ALIGN_512BYTES, 	"ALIGN_512BYTES");
+        X2(IMAGE_SCN_ALIGN_1024BYTES, 	"ALIGN_1024BYTES");
+        X2(IMAGE_SCN_ALIGN_2048BYTES, 	"ALIGN_2048BYTES");
+        X2(IMAGE_SCN_ALIGN_4096BYTES, 	"ALIGN_4096BYTES");
+        X2(IMAGE_SCN_ALIGN_8192BYTES, 	"ALIGN_8192BYTES");
 #undef X2
-        }
+    }
 
-	X(IMAGE_SCN_LNK_NRELOC_OVFL, 		"LNK_NRELOC_OVFL");
+    X(IMAGE_SCN_LNK_NRELOC_OVFL, 	"LNK_NRELOC_OVFL");
 
-	X(IMAGE_SCN_MEM_DISCARDABLE, 		"MEM_DISCARDABLE");
-	X(IMAGE_SCN_MEM_NOT_CACHED, 		"MEM_NOT_CACHED");
-	X(IMAGE_SCN_MEM_NOT_PAGED, 		"MEM_NOT_PAGED");
-	X(IMAGE_SCN_MEM_SHARED, 		"MEM_SHARED");
-	X(IMAGE_SCN_MEM_EXECUTE, 		"MEM_EXECUTE");
-	X(IMAGE_SCN_MEM_READ, 			"MEM_READ");
-	X(IMAGE_SCN_MEM_WRITE, 			"MEM_WRITE");
+    X(IMAGE_SCN_MEM_DISCARDABLE, 	"MEM_DISCARDABLE");
+    X(IMAGE_SCN_MEM_NOT_CACHED, 	"MEM_NOT_CACHED");
+    X(IMAGE_SCN_MEM_NOT_PAGED, 		"MEM_NOT_PAGED");
+    X(IMAGE_SCN_MEM_SHARED, 		"MEM_SHARED");
+    X(IMAGE_SCN_MEM_EXECUTE, 		"MEM_EXECUTE");
+    X(IMAGE_SCN_MEM_READ, 		"MEM_READ");
+    X(IMAGE_SCN_MEM_WRITE, 		"MEM_WRITE");
 #undef X
-	printf("\n\n");
+}
+
+void dump_section(const IMAGE_SECTION_HEADER *sectHead, const char* strtable)
+{
+    unsigned offset;
+
+    /* long section name ? */
+    if (strtable && sectHead->Name[0] == '/' &&
+        ((offset = atoi((const char*)sectHead->Name + 1)) < *(const DWORD*)strtable))
+        printf("  %.8s (%s)", sectHead->Name, strtable + offset);
+    else
+        printf("  %-8.8s", sectHead->Name);
+    printf("   VirtSize: 0x%08x  VirtAddr:  0x%08x\n",
+           (UINT)sectHead->Misc.VirtualSize, (UINT)sectHead->VirtualAddress);
+    printf("    raw data offs:   0x%08x  raw data size: 0x%08x\n",
+           (UINT)sectHead->PointerToRawData, (UINT)sectHead->SizeOfRawData);
+    printf("    relocation offs: 0x%08x  relocations:   0x%08x\n",
+           (UINT)sectHead->PointerToRelocations, (UINT)sectHead->NumberOfRelocations);
+    printf("    line # offs:     %-8u  line #'s:      %-8u\n",
+           (UINT)sectHead->PointerToLinenumbers, (UINT)sectHead->NumberOfLinenumbers);
+    printf("    characteristics: 0x%08x\n", (UINT)sectHead->Characteristics);
+    printf("    ");
+    dump_section_characteristics(sectHead->Characteristics, "  ");
+
+    printf("\n\n");
 }
 
 static void dump_sections(const void *base, const void* addr, unsigned num_sect)
@@ -596,58 +661,65 @@ static void dump_section_apiset(void)
 
 static	void	dump_dir_exported_functions(void)
 {
-    unsigned int size = 0;
-    const IMAGE_EXPORT_DIRECTORY*exportDir = get_dir_and_size(IMAGE_FILE_EXPORT_DIRECTORY, &size);
-    UINT i, *funcs;
+    unsigned int size[2] = { 0 };
+    const IMAGE_EXPORT_DIRECTORY *dirs[2];
+    UINT dir, i, *funcs;
     const UINT *pFunc;
     const UINT *pName;
     const WORD *pOrdl;
 
-    if (!exportDir) return;
+    dirs[0] = get_dir_and_size(IMAGE_FILE_EXPORT_DIRECTORY, &size[0]);
+    if (!dirs[0]) return;
+    dirs[1] = get_alt_dir_and_size(IMAGE_FILE_EXPORT_DIRECTORY, &size[1]);
 
-    printf("Exports table:\n");
-    printf("\n");
-    printf("  Name:            %s\n", (const char*)RVA(exportDir->Name, sizeof(DWORD)));
-    printf("  Characteristics: %08x\n", (UINT)exportDir->Characteristics);
-    printf("  TimeDateStamp:   %08X %s\n",
-           (UINT)exportDir->TimeDateStamp, get_time_str(exportDir->TimeDateStamp));
-    printf("  Version:         %u.%02u\n", exportDir->MajorVersion, exportDir->MinorVersion);
-    printf("  Ordinal base:    %u\n", (UINT)exportDir->Base);
-    printf("  # of functions:  %u\n", (UINT)exportDir->NumberOfFunctions);
-    printf("  # of Names:      %u\n", (UINT)exportDir->NumberOfNames);
-    printf("Addresses of functions: %08X\n", (UINT)exportDir->AddressOfFunctions);
-    printf("Addresses of name ordinals: %08X\n", (UINT)exportDir->AddressOfNameOrdinals);
-    printf("Addresses of names: %08X\n", (UINT)exportDir->AddressOfNames);
-    printf("\n");
-    printf("  Entry Pt  Ordn  Name\n");
+    for (dir = 0; dir < 2 && dirs[dir]; dir++)
+    {
+        if (dir) printf("Alternate (%s) exports table:\n",
+                        get_machine_str(PE_alt_headers->FileHeader.Machine));
+        else printf("Exports table:\n");
+        printf("\n");
+        printf("  Name:            %s\n", (const char*)RVA(dirs[dir]->Name, sizeof(DWORD)));
+        printf("  Characteristics: %08x\n", (UINT)dirs[dir]->Characteristics);
+        printf("  TimeDateStamp:   %08X %s\n",
+               (UINT)dirs[dir]->TimeDateStamp, get_time_str(dirs[dir]->TimeDateStamp));
+        printf("  Version:         %u.%02u\n", dirs[dir]->MajorVersion, dirs[dir]->MinorVersion);
+        printf("  Ordinal base:    %u\n", (UINT)dirs[dir]->Base);
+        printf("  # of functions:  %u\n", (UINT)dirs[dir]->NumberOfFunctions);
+        printf("  # of Names:      %u\n", (UINT)dirs[dir]->NumberOfNames);
+        printf("Addresses of functions: %08X\n", (UINT)dirs[dir]->AddressOfFunctions);
+        printf("Addresses of name ordinals: %08X\n", (UINT)dirs[dir]->AddressOfNameOrdinals);
+        printf("Addresses of names: %08X\n", (UINT)dirs[dir]->AddressOfNames);
+        printf("\n");
+        printf("  Entry Pt  Ordn  Name\n");
 
-    pFunc = RVA(exportDir->AddressOfFunctions, exportDir->NumberOfFunctions * sizeof(DWORD));
-    if (!pFunc) {printf("Can't grab functions' address table\n"); return;}
-    pName = RVA(exportDir->AddressOfNames, exportDir->NumberOfNames * sizeof(DWORD));
-    pOrdl = RVA(exportDir->AddressOfNameOrdinals, exportDir->NumberOfNames * sizeof(WORD));
+        pFunc = RVA(dirs[dir]->AddressOfFunctions, dirs[dir]->NumberOfFunctions * sizeof(DWORD));
+        if (!pFunc) {printf("Can't grab functions' address table\n"); return;}
+        pName = RVA(dirs[dir]->AddressOfNames, dirs[dir]->NumberOfNames * sizeof(DWORD));
+        pOrdl = RVA(dirs[dir]->AddressOfNameOrdinals, dirs[dir]->NumberOfNames * sizeof(WORD));
 
-    funcs = calloc( exportDir->NumberOfFunctions, sizeof(*funcs) );
-    if (!funcs) fatal("no memory");
+        funcs = calloc( dirs[dir]->NumberOfFunctions, sizeof(*funcs) );
+        if (!funcs) fatal("no memory");
 
-    for (i = 0; i < exportDir->NumberOfNames; i++) funcs[pOrdl[i]] = pName[i];
+        for (i = 0; i < dirs[dir]->NumberOfNames; i++) funcs[pOrdl[i]] = pName[i];
 
-    for (i = 0; i < exportDir->NumberOfFunctions; i++)
-    {
-        if (!pFunc[i]) continue;
-        printf("  %08X %5u ", pFunc[i], (UINT)exportDir->Base + i);
-        if (funcs[i])
-            printf("%s", get_symbol_str((const char*)RVA(funcs[i], sizeof(DWORD))));
-        else
-            printf("<by ordinal>");
+        for (i = 0; i < dirs[dir]->NumberOfFunctions; i++)
+        {
+            if (!pFunc[i]) continue;
+            printf("  %08X %5u ", pFunc[i], (UINT)dirs[dir]->Base + i);
+            if (funcs[i])
+                printf("%s", get_symbol_str((const char*)RVA(funcs[i], sizeof(DWORD))));
+            else
+                printf("<by ordinal>");
 
-        /* check for forwarded function */
-        if ((const char *)RVA(pFunc[i],1) >= (const char *)exportDir &&
-            (const char *)RVA(pFunc[i],1) < (const char *)exportDir + size)
-            printf(" (-> %s)", (const char *)RVA(pFunc[i],1));
+            /* check for forwarded function */
+            if ((const char *)RVA(pFunc[i],1) >= (const char *)dirs[dir] &&
+                (const char *)RVA(pFunc[i],1) < (const char *)dirs[dir] + size[dir])
+                printf(" (-> %s)", (const char *)RVA(pFunc[i],1));
+            printf("\n");
+        }
+        free(funcs);
         printf("\n");
     }
-    free(funcs);
-    printf("\n");
 }
 
 
@@ -1607,33 +1679,42 @@ static void dump_arm64_unwind_info( const struct runtime_function_arm64 *func )
 
 static void dump_dir_exceptions(void)
 {
-    unsigned int i, size = 0;
-    const void *funcs = get_dir_and_size(IMAGE_FILE_EXCEPTION_DIRECTORY, &size);
-    const IMAGE_FILE_HEADER *file_header = &PE_nt_headers->FileHeader;
+    unsigned int i, dir, size, sizes[2] = { 0 };
+    const void *funcs[2];
+    const IMAGE_FILE_HEADER *file_header;
 
-    if (!funcs) return;
+    funcs[0] = get_dir_and_size(IMAGE_FILE_EXCEPTION_DIRECTORY, &sizes[0]);
+    if (!funcs[0]) return;
+    funcs[1] = get_alt_dir_and_size(IMAGE_FILE_EXCEPTION_DIRECTORY, &sizes[1]);
 
-    switch (file_header->Machine)
+    for (dir = 0; dir < 2 && funcs[dir]; dir++)
     {
-    case IMAGE_FILE_MACHINE_AMD64:
-        size /= sizeof(struct runtime_function_x86_64);
-        printf( "Exception info (%u functions):\n", size );
-        for (i = 0; i < size; i++) dump_x86_64_unwind_info( (struct runtime_function_x86_64*)funcs + i );
-        break;
-    case IMAGE_FILE_MACHINE_ARMNT:
-        size /= sizeof(struct runtime_function_armnt);
-        printf( "Exception info (%u functions):\n", size );
-        for (i = 0; i < size; i++) dump_armnt_unwind_info( (struct runtime_function_armnt*)funcs + i );
-        break;
-    case IMAGE_FILE_MACHINE_ARM64:
-        size /= sizeof(struct runtime_function_arm64);
-        printf( "Exception info (%u functions):\n", size );
-        for (i = 0; i < size; i++) dump_arm64_unwind_info( (struct runtime_function_arm64*)funcs + i );
-        break;
-    default:
-        printf( "Exception information not supported for %s binaries\n",
-                 get_machine_str(file_header->Machine));
-        break;
+        size = sizes[dir];
+        file_header = dir ? &PE_alt_headers->FileHeader : &PE_nt_headers->FileHeader;
+
+        switch (file_header->Machine)
+        {
+        case IMAGE_FILE_MACHINE_AMD64:
+            size /= sizeof(struct runtime_function_x86_64);
+            printf( "%s exception info (%u functions):\n", get_machine_str( file_header->Machine ), size );
+            for (i = 0; i < size; i++) dump_x86_64_unwind_info( (struct runtime_function_x86_64*)funcs[dir] + i );
+            break;
+        case IMAGE_FILE_MACHINE_ARMNT:
+            size /= sizeof(struct runtime_function_armnt);
+            printf( "%s exception info (%u functions):\n", get_machine_str( file_header->Machine ), size );
+            for (i = 0; i < size; i++) dump_armnt_unwind_info( (struct runtime_function_armnt*)funcs[dir] + i );
+            break;
+        case IMAGE_FILE_MACHINE_ARM64:
+            size /= sizeof(struct runtime_function_arm64);
+            printf( "%s exception info (%u functions):\n", get_machine_str( file_header->Machine ), size );
+            for (i = 0; i < size; i++) dump_arm64_unwind_info( (struct runtime_function_arm64*)funcs[dir] + i );
+            break;
+        default:
+            printf( "Exception information not supported for %s binaries\n",
+                    get_machine_str(file_header->Machine));
+            break;
+        }
+        printf( "\n" );
     }
 }
 
@@ -1718,50 +1799,253 @@ static	void	dump_dir_imported_functions(void)
     printf("\n");
 }
 
-static void dump_dir_loadconfig(void)
+static void dump_hybrid_metadata(void)
 {
-    const IMAGE_LOAD_CONFIG_DIRECTORY32 *loadcfg32 = get_dir(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG);
-    const IMAGE_LOAD_CONFIG_DIRECTORY64 *loadcfg64 = (void*)loadcfg32;
+    unsigned int i;
+    const struct
+    {
+        unsigned int version;
+        unsigned int code_map;
+        unsigned int code_map_count;
+        unsigned int code_ranges_to_ep;
+        unsigned int redir_metadata;
+        unsigned int __os_arm64x_dispatch_call_no_redirect;
+        unsigned int __os_arm64x_dispatch_ret;
+        unsigned int __os_arm64x_check_call;
+        unsigned int __os_arm64x_check_icall;
+        unsigned int __os_arm64x_check_icall_cfg;
+        unsigned int alt_entry;
+        unsigned int aux_iat;
+        unsigned int code_ranges_to_ep_count;
+        unsigned int redir_metadata_count;
+        unsigned int __os_arm64x_get_x64_information;
+        unsigned int __os_arm64x_set_x64_information;
+        unsigned int except_data;
+        unsigned int except_data_size;
+        unsigned int __os_arm64x_jump;
+        unsigned int aux_iat_copy;
+    } *data = get_hybrid_metadata();
+
+    if (!data) return;
+    printf( "Hybrid metadata\n" );
+    print_dword( "Version", data->version );
+    print_dword( "Code map", data->code_map );
+    print_dword( "Code map count", data->code_map_count );
+    print_dword( "Code ranges to entry points", data->code_ranges_to_ep );
+    print_dword( "Redirection metadata", data->redir_metadata );
+    print_dword( "__os_arm64x_dispatch_call_no_redirect", data->__os_arm64x_dispatch_call_no_redirect );
+    print_dword( "__os_arm64x_dispatch_ret", data->__os_arm64x_dispatch_ret );
+    print_dword( "__os_arm64x_check_call", data->__os_arm64x_check_call );
+    print_dword( "__os_arm64x_check_icall", data->__os_arm64x_check_icall );
+    print_dword( "__os_arm64x_check_icall_cfg", data->__os_arm64x_check_icall_cfg );
+    print_dword( "Alternate entry point", data->alt_entry );
+    print_dword( "Auxiliary IAT", data->aux_iat );
+    print_dword( "Code ranges to entry points count", data->code_ranges_to_ep_count );
+    print_dword( "Redirection metadata count", data->redir_metadata_count );
+    print_dword( "__os_arm64x_get_x64_information", data->__os_arm64x_get_x64_information );
+    print_dword( "__os_arm64x_set_x64_information", data->__os_arm64x_set_x64_information );
+    print_dword( "Exception data", data->except_data );
+    print_dword( "Exception data size", data->except_data_size );
+    print_dword( "__os_arm64x_jump", data->__os_arm64x_jump );
+    print_dword( "Auxiliary IAT copy", data->aux_iat_copy );
+
+    if (data->code_map)
+    {
+        const struct
+        {
+            unsigned int start : 30;
+            unsigned int type : 2;
+            unsigned int len;
+        } *map = RVA( data->code_map, data->code_map_count * sizeof(*map) );
 
-    if (!loadcfg32) return;
+        printf( "\nCode ranges\n" );
+        for (i = 0; i < data->code_map_count; i++)
+        {
+            static const char *types[] = { "ARM64", "ARM64EC", "x64", "??" };
+            unsigned int start = map[i].start & ~0x3;
+            unsigned int type = map[i].start & 0x3;
+            printf(  "  %08x - %08x  %s\n", start, start + map[i].len, types[type] );
+        }
+    }
 
-    printf( "Loadconfig\n" );
-    print_dword( "Size",                                loadcfg32->Size );
-    print_dword( "TimeDateStamp",                       loadcfg32->TimeDateStamp );
-    print_word(  "MajorVersion",                        loadcfg32->MajorVersion );
-    print_word(  "MinorVersion",                        loadcfg32->MinorVersion );
-    print_dword( "GlobalFlagsClear",                    loadcfg32->GlobalFlagsClear );
-    print_dword( "GlobalFlagsSet",                      loadcfg32->GlobalFlagsSet );
-    print_dword( "CriticalSectionDefaultTimeout",       loadcfg32->CriticalSectionDefaultTimeout );
+    if (data->code_ranges_to_ep)
+    {
+        const struct
+        {
+            unsigned int start;
+            unsigned int end;
+            unsigned int func;
+        } *map = RVA( data->code_ranges_to_ep, data->code_ranges_to_ep_count * sizeof(*map) );
 
-    if(PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+        printf( "\nCode ranges to entry points\n" );
+        printf( "    Start  -   End      Entry point\n" );
+        for (i = 0; i < data->code_ranges_to_ep_count; i++)
+            printf(  "  %08x - %08x   %08x\n", map[i].start, map[i].end, map[i].func );
+    }
+
+    if (data->redir_metadata)
     {
-        print_longlong( "DeCommitFreeBlockThreshold",   loadcfg64->DeCommitFreeBlockThreshold );
-        print_longlong( "DeCommitTotalFreeThreshold",   loadcfg64->DeCommitTotalFreeThreshold );
-        print_longlong( "MaximumAllocationSize",        loadcfg64->MaximumAllocationSize );
-        print_longlong( "VirtualMemoryThreshold",       loadcfg64->VirtualMemoryThreshold );
-        print_dword(    "ProcessHeapFlags",             loadcfg64->ProcessHeapFlags );
-        print_longlong( "ProcessAffinityMask",          loadcfg64->ProcessAffinityMask );
-        print_word(     "CSDVersion",                   loadcfg64->CSDVersion );
-        print_word(     "Reserved",                     loadcfg64->Reserved1 );
-        print_longlong( "SecurityCookie",               loadcfg64->SecurityCookie );
-        print_longlong( "SEHandlerTable",               loadcfg64->SEHandlerTable );
-        print_longlong( "SEHandlerCount",               loadcfg64->SEHandlerCount );
+        const struct
+        {
+            unsigned int func;
+            unsigned int redir;
+        } *map = RVA( data->redir_metadata, data->redir_metadata_count * sizeof(*map) );
+
+        printf( "\nEntry point redirection\n" );
+        for (i = 0; i < data->redir_metadata_count; i++)
+            printf(  "  %08x -> %08x\n", map[i].func, map[i].redir );
     }
-    else
+}
+
+static void dump_dir_loadconfig(void)
+{
+    unsigned int dir, size, sizes[2];
+    const IMAGE_LOAD_CONFIG_DIRECTORY32 *dirs[2];
+
+    dirs[0] = get_dir_and_size(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, &sizes[0]);
+    if (!dirs[0]) return;
+    dirs[1] = get_alt_dir_and_size(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, &sizes[1]);
+
+    for (dir = 0; dir < 2 && dirs[dir]; dir++)
     {
-        print_dword( "DeCommitFreeBlockThreshold",      loadcfg32->DeCommitFreeBlockThreshold );
-        print_dword( "DeCommitTotalFreeThreshold",      loadcfg32->DeCommitTotalFreeThreshold );
-        print_dword( "MaximumAllocationSize",           loadcfg32->MaximumAllocationSize );
-        print_dword( "VirtualMemoryThreshold",          loadcfg32->VirtualMemoryThreshold );
-        print_dword( "ProcessHeapFlags",                loadcfg32->ProcessHeapFlags );
-        print_dword( "ProcessAffinityMask",             loadcfg32->ProcessAffinityMask );
-        print_word(  "CSDVersion",                      loadcfg32->CSDVersion );
-        print_word(  "Reserved",                        loadcfg32->Reserved1 );
-        print_dword( "SecurityCookie",                  loadcfg32->SecurityCookie );
-        print_dword( "SEHandlerTable",                  loadcfg32->SEHandlerTable );
-        print_dword( "SEHandlerCount",                  loadcfg32->SEHandlerCount );
+        const IMAGE_LOAD_CONFIG_DIRECTORY32 *loadcfg32 = dirs[dir];
+        const IMAGE_LOAD_CONFIG_DIRECTORY64 *loadcfg64 = (void*)loadcfg32;
+        size = min( sizes[dir], loadcfg32->Size );
+
+        if (dir)
+            printf( "\nAlternate (%s) loadconfig\n",
+                    get_machine_str( PE_alt_headers->FileHeader.Machine ));
+        else
+            printf( "Loadconfig\n" );
+        print_dword( "Size",                                loadcfg32->Size );
+        print_dword( "TimeDateStamp",                       loadcfg32->TimeDateStamp );
+        print_word(  "MajorVersion",                        loadcfg32->MajorVersion );
+        print_word(  "MinorVersion",                        loadcfg32->MinorVersion );
+        print_dword( "GlobalFlagsClear",                    loadcfg32->GlobalFlagsClear );
+        print_dword( "GlobalFlagsSet",                      loadcfg32->GlobalFlagsSet );
+        print_dword( "CriticalSectionDefaultTimeout",       loadcfg32->CriticalSectionDefaultTimeout );
+
+        if(PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+        {
+            print_longlong( "DeCommitFreeBlockThreshold",   loadcfg64->DeCommitFreeBlockThreshold );
+            print_longlong( "DeCommitTotalFreeThreshold",   loadcfg64->DeCommitTotalFreeThreshold );
+            print_longlong( "MaximumAllocationSize",        loadcfg64->MaximumAllocationSize );
+            print_longlong( "VirtualMemoryThreshold",       loadcfg64->VirtualMemoryThreshold );
+            print_dword(    "ProcessHeapFlags",             loadcfg64->ProcessHeapFlags );
+            print_longlong( "ProcessAffinityMask",          loadcfg64->ProcessAffinityMask );
+            print_word(     "CSDVersion",                   loadcfg64->CSDVersion );
+            print_word(     "DependentLoadFlags",           loadcfg64->DependentLoadFlags );
+            print_longlong( "SecurityCookie",               loadcfg64->SecurityCookie );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, SEHandlerTable )) return;
+            print_longlong( "SEHandlerTable",               loadcfg64->SEHandlerTable );
+            print_longlong( "SEHandlerCount",               loadcfg64->SEHandlerCount );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardCFCheckFunctionPointer )) return;
+            print_longlong( "GuardCFCheckFunctionPointer",  loadcfg64->GuardCFCheckFunctionPointer );
+            print_longlong( "GuardCFDispatchFunctionPointer", loadcfg64->GuardCFDispatchFunctionPointer );
+            print_longlong( "GuardCFFunctionTable",         loadcfg64->GuardCFFunctionTable );
+            print_longlong( "GuardCFFunctionCount",         loadcfg64->GuardCFFunctionCount );
+            print_dword(    "GuardFlags",                   loadcfg64->GuardFlags );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, CodeIntegrity )) return;
+            print_word(     "CodeIntegrity.Flags",          loadcfg64->CodeIntegrity.Flags );
+            print_word(     "CodeIntegrity.Catalog",        loadcfg64->CodeIntegrity.Catalog );
+            print_dword(    "CodeIntegrity.CatalogOffset",  loadcfg64->CodeIntegrity.CatalogOffset );
+            print_dword(    "CodeIntegrity.Reserved",       loadcfg64->CodeIntegrity.Reserved );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardAddressTakenIatEntryTable )) return;
+            print_longlong( "GuardAddressTakenIatEntryTable", loadcfg64->GuardAddressTakenIatEntryTable );
+            print_longlong( "GuardAddressTakenIatEntryCount", loadcfg64->GuardAddressTakenIatEntryCount );
+            print_longlong( "GuardLongJumpTargetTable",     loadcfg64->GuardLongJumpTargetTable );
+            print_longlong( "GuardLongJumpTargetCount",     loadcfg64->GuardLongJumpTargetCount );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, DynamicValueRelocTable )) return;
+            print_longlong( "DynamicValueRelocTable",       loadcfg64->DynamicValueRelocTable );
+            print_longlong( "CHPEMetadataPointer",          loadcfg64->CHPEMetadataPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardRFFailureRoutine )) return;
+            print_longlong( "GuardRFFailureRoutine",        loadcfg64->GuardRFFailureRoutine );
+            print_longlong( "GuardRFFailureRoutineFunctionPointer", loadcfg64->GuardRFFailureRoutineFunctionPointer );
+            print_dword(    "DynamicValueRelocTableOffset", loadcfg64->DynamicValueRelocTableOffset );
+            print_word(     "DynamicValueRelocTableSection",loadcfg64->DynamicValueRelocTableSection );
+            print_word(     "Reserved2",                    loadcfg64->Reserved2 );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardRFVerifyStackPointerFunctionPointer )) return;
+            print_longlong( "GuardRFVerifyStackPointerFunctionPointer", loadcfg64->GuardRFVerifyStackPointerFunctionPointer );
+            print_dword(    "HotPatchTableOffset",          loadcfg64->HotPatchTableOffset );
+            print_dword(    "Reserved3",                    loadcfg64->Reserved3 );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, EnclaveConfigurationPointer )) return;
+            print_longlong( "EnclaveConfigurationPointer",  loadcfg64->EnclaveConfigurationPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, VolatileMetadataPointer )) return;
+            print_longlong( "VolatileMetadataPointer",      loadcfg64->VolatileMetadataPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardEHContinuationTable )) return;
+            print_longlong( "GuardEHContinuationTable",     loadcfg64->GuardEHContinuationTable );
+            print_longlong( "GuardEHContinuationCount",     loadcfg64->GuardEHContinuationCount );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardXFGCheckFunctionPointer )) return;
+            print_longlong( "GuardXFGCheckFunctionPointer", loadcfg64->GuardXFGCheckFunctionPointer );
+            print_longlong( "GuardXFGDispatchFunctionPointer", loadcfg64->GuardXFGDispatchFunctionPointer );
+            print_longlong( "GuardXFGTableDispatchFunctionPointer", loadcfg64->GuardXFGTableDispatchFunctionPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, CastGuardOsDeterminedFailureMode )) return;
+            print_longlong( "CastGuardOsDeterminedFailureMode", loadcfg64->CastGuardOsDeterminedFailureMode );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, GuardMemcpyFunctionPointer )) return;
+            print_longlong( "GuardMemcpyFunctionPointer",   loadcfg64->GuardMemcpyFunctionPointer );
+        }
+        else
+        {
+            print_dword( "DeCommitFreeBlockThreshold",      loadcfg32->DeCommitFreeBlockThreshold );
+            print_dword( "DeCommitTotalFreeThreshold",      loadcfg32->DeCommitTotalFreeThreshold );
+            print_dword( "MaximumAllocationSize",           loadcfg32->MaximumAllocationSize );
+            print_dword( "VirtualMemoryThreshold",          loadcfg32->VirtualMemoryThreshold );
+            print_dword( "ProcessHeapFlags",                loadcfg32->ProcessHeapFlags );
+            print_dword( "ProcessAffinityMask",             loadcfg32->ProcessAffinityMask );
+            print_word(  "CSDVersion",                      loadcfg32->CSDVersion );
+            print_word(  "DependentLoadFlags",              loadcfg32->DependentLoadFlags );
+            print_dword( "SecurityCookie",                  loadcfg32->SecurityCookie );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, SEHandlerTable )) return;
+            print_dword( "SEHandlerTable",                  loadcfg32->SEHandlerTable );
+            print_dword( "SEHandlerCount",                  loadcfg32->SEHandlerCount );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardCFCheckFunctionPointer )) return;
+            print_dword( "GuardCFCheckFunctionPointer",     loadcfg32->GuardCFCheckFunctionPointer );
+            print_dword( "GuardCFDispatchFunctionPointer",  loadcfg32->GuardCFDispatchFunctionPointer );
+            print_dword( "GuardCFFunctionTable",            loadcfg32->GuardCFFunctionTable );
+            print_dword( "GuardCFFunctionCount",            loadcfg32->GuardCFFunctionCount );
+            print_dword( "GuardFlags",                      loadcfg32->GuardFlags );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, CodeIntegrity )) return;
+            print_word(  "CodeIntegrity.Flags",             loadcfg32->CodeIntegrity.Flags );
+            print_word(  "CodeIntegrity.Catalog",           loadcfg32->CodeIntegrity.Catalog );
+            print_dword( "CodeIntegrity.CatalogOffset",     loadcfg32->CodeIntegrity.CatalogOffset );
+            print_dword( "CodeIntegrity.Reserved",          loadcfg32->CodeIntegrity.Reserved );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardAddressTakenIatEntryTable )) return;
+            print_dword( "GuardAddressTakenIatEntryTable",  loadcfg32->GuardAddressTakenIatEntryTable );
+            print_dword( "GuardAddressTakenIatEntryCount",  loadcfg32->GuardAddressTakenIatEntryCount );
+            print_dword( "GuardLongJumpTargetTable",        loadcfg32->GuardLongJumpTargetTable );
+            print_dword( "GuardLongJumpTargetCount",        loadcfg32->GuardLongJumpTargetCount );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, DynamicValueRelocTable )) return;
+            print_dword( "DynamicValueRelocTable",          loadcfg32->DynamicValueRelocTable );
+            print_dword( "CHPEMetadataPointer",             loadcfg32->CHPEMetadataPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardRFFailureRoutine )) return;
+            print_dword( "GuardRFFailureRoutine",           loadcfg32->GuardRFFailureRoutine );
+            print_dword( "GuardRFFailureRoutineFunctionPointer", loadcfg32->GuardRFFailureRoutineFunctionPointer );
+            print_dword( "DynamicValueRelocTableOffset",    loadcfg32->DynamicValueRelocTableOffset );
+            print_word(  "DynamicValueRelocTableSection",   loadcfg32->DynamicValueRelocTableSection );
+            print_word(  "Reserved2",                       loadcfg32->Reserved2 );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardRFVerifyStackPointerFunctionPointer )) return;
+            print_dword( "GuardRFVerifyStackPointerFunctionPointer", loadcfg32->GuardRFVerifyStackPointerFunctionPointer );
+            print_dword( "HotPatchTableOffset",             loadcfg32->HotPatchTableOffset );
+            print_dword( "Reserved3",                       loadcfg32->Reserved3 );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, EnclaveConfigurationPointer )) return;
+            print_dword( "EnclaveConfigurationPointer",     loadcfg32->EnclaveConfigurationPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, VolatileMetadataPointer )) return;
+            print_dword( "VolatileMetadataPointer",         loadcfg32->VolatileMetadataPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardEHContinuationTable )) return;
+            print_dword( "GuardEHContinuationTable",        loadcfg32->GuardEHContinuationTable );
+            print_dword( "GuardEHContinuationCount",        loadcfg32->GuardEHContinuationCount );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardXFGCheckFunctionPointer )) return;
+            print_dword( "GuardXFGCheckFunctionPointer",    loadcfg32->GuardXFGCheckFunctionPointer );
+            print_dword( "GuardXFGDispatchFunctionPointer", loadcfg32->GuardXFGDispatchFunctionPointer );
+            print_dword( "GuardXFGTableDispatchFunctionPointer", loadcfg32->GuardXFGTableDispatchFunctionPointer );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, CastGuardOsDeterminedFailureMode )) return;
+            print_dword( "CastGuardOsDeterminedFailureMode", loadcfg32->CastGuardOsDeterminedFailureMode );
+            if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, GuardMemcpyFunctionPointer )) return;
+            print_dword( "GuardMemcpyFunctionPointer",      loadcfg32->GuardMemcpyFunctionPointer );
+        }
     }
+    printf( "\n" );
+    dump_hybrid_metadata();
 }
 
 static void dump_dir_delay_imported_functions(void)
@@ -1930,6 +2214,264 @@ static void dump_dir_clr_header(void)
     printf("\n");
 }
 
+static void dump_dynamic_relocs_arm64x( const IMAGE_BASE_RELOCATION *base_reloc, unsigned int size )
+{
+    unsigned int i;
+    const IMAGE_BASE_RELOCATION *base_end = (const IMAGE_BASE_RELOCATION *)((const char *)base_reloc + size);
+
+    printf( "Relocations ARM64X\n" );
+    while (base_reloc < base_end - 1 && base_reloc->SizeOfBlock)
+    {
+        const USHORT *rel = (const USHORT *)(base_reloc + 1);
+        const USHORT *end = (const USHORT *)base_reloc + base_reloc->SizeOfBlock / sizeof(USHORT);
+        printf( "  Page %x\n", (UINT)base_reloc->VirtualAddress );
+        while (rel < end && *rel)
+        {
+            USHORT offset = *rel & 0xfff;
+            USHORT type = (*rel >> 12) & 3;
+            USHORT arg = *rel >> 14;
+            rel++;
+            switch (type)
+            {
+            case 0:  /* zero-fill */
+                printf( "    off %04x zero-fill %u bytes\n", offset, 1 << arg );
+                break;
+            case 1:  /* set value */
+                printf( "    off %04x set %u bytes value ", offset, 1 << arg );
+                for (i = (1 << arg ) / sizeof(USHORT); i > 0; i--) printf( "%04x", rel[i - 1] );
+                rel += (1 << arg) / sizeof(USHORT);
+                printf( "\n" );
+                break;
+            case 2:  /* add value */
+                printf( "    off %04x add offset ", offset );
+                if (arg & 1) printf( "-" );
+                printf( "%08x\n", (UINT)*rel++ * ((arg & 2) ? 8 : 4) );
+                break;
+            default:
+                printf( "    off %04x unknown (arg %x)\n", offset, arg );
+                break;
+            }
+        }
+        base_reloc = (const IMAGE_BASE_RELOCATION *)end;
+    }
+}
+
+static void dump_dynamic_relocs( const char *ptr, unsigned int size, ULONGLONG symbol )
+{
+    switch (symbol)
+    {
+    case IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE:
+        printf( "Relocations GUARD_RF_PROLOGUE\n" );
+        break;
+    case IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE:
+        printf( "Relocations GUARD_RF_EPILOGUE\n" );
+        break;
+    case IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER:
+        printf( "Relocations GUARD_IMPORT_CONTROL_TRANSFER\n" );
+        break;
+    case IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER:
+        printf( "Relocations GUARD_INDIR_CONTROL_TRANSFER\n" );
+        break;
+    case IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH:
+        printf( "Relocations GUARD_SWITCHTABLE_BRANCH\n" );
+        break;
+    case IMAGE_DYNAMIC_RELOCATION_ARM64X:
+        dump_dynamic_relocs_arm64x( (const IMAGE_BASE_RELOCATION *)ptr, size );
+        break;
+    default:
+        printf( "Unknown relocation symbol %s\n", longlong_str(symbol) );
+        break;
+    }
+}
+
+static const IMAGE_DYNAMIC_RELOCATION_TABLE *get_dyn_reloc_table(void)
+{
+    unsigned int size, section, offset;
+    const IMAGE_SECTION_HEADER *sec;
+    const IMAGE_DYNAMIC_RELOCATION_TABLE *table;
+
+    if (PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+    {
+        const IMAGE_LOAD_CONFIG_DIRECTORY64 *cfg = get_dir_and_size(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, &size);
+        if (!cfg) return NULL;
+        size = min( size, cfg->Size );
+        if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY64, DynamicValueRelocTableSection )) return NULL;
+        offset = cfg->DynamicValueRelocTableOffset;
+        section = cfg->DynamicValueRelocTableSection;
+    }
+    else
+    {
+        const IMAGE_LOAD_CONFIG_DIRECTORY32 *cfg = get_dir_and_size(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, &size);
+        if (!cfg) return NULL;
+        size = min( size, cfg->Size );
+        if (size <= offsetof( IMAGE_LOAD_CONFIG_DIRECTORY32, DynamicValueRelocTableSection )) return NULL;
+        offset = cfg->DynamicValueRelocTableOffset;
+        section = cfg->DynamicValueRelocTableSection;
+    }
+    if (!section || section > PE_nt_headers->FileHeader.NumberOfSections) return NULL;
+    sec = IMAGE_FIRST_SECTION( PE_nt_headers ) + section - 1;
+    if (offset >= sec->SizeOfRawData) return NULL;
+    return PRD( sec->PointerToRawData + offset, sizeof(*table) );
+}
+
+static void dump_dir_dynamic_reloc(void)
+{
+    const char *ptr, *end;
+    const IMAGE_DYNAMIC_RELOCATION_TABLE *table = get_dyn_reloc_table();
+
+    if (!table) return;
+
+    printf( "Dynamic relocations (version %u)\n\n", (UINT)table->Version );
+    ptr = (const char *)(table + 1);
+    end = ptr + table->Size;
+    while (ptr < end)
+    {
+        switch (table->Version)
+        {
+        case 1:
+            if (PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+            {
+                const IMAGE_DYNAMIC_RELOCATION64 *reloc = (const IMAGE_DYNAMIC_RELOCATION64 *)ptr;
+                dump_dynamic_relocs( (const char *)(reloc + 1), reloc->BaseRelocSize, reloc->Symbol );
+                ptr += sizeof(*reloc) + reloc->BaseRelocSize;
+            }
+            else
+            {
+                const IMAGE_DYNAMIC_RELOCATION32 *reloc = (const IMAGE_DYNAMIC_RELOCATION32 *)ptr;
+                dump_dynamic_relocs( (const char *)(reloc + 1), reloc->BaseRelocSize, reloc->Symbol );
+                ptr += sizeof(*reloc) + reloc->BaseRelocSize;
+            }
+            break;
+        case 2:
+            if (PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+            {
+                const IMAGE_DYNAMIC_RELOCATION64_V2 *reloc = (const IMAGE_DYNAMIC_RELOCATION64_V2 *)ptr;
+                dump_dynamic_relocs( ptr + reloc->HeaderSize, reloc->FixupInfoSize, reloc->Symbol );
+                ptr += reloc->HeaderSize + reloc->FixupInfoSize;
+            }
+            else
+            {
+                const IMAGE_DYNAMIC_RELOCATION32_V2 *reloc = (const IMAGE_DYNAMIC_RELOCATION32_V2 *)ptr;
+                dump_dynamic_relocs( ptr + reloc->HeaderSize, reloc->FixupInfoSize, reloc->Symbol );
+                ptr += reloc->HeaderSize + reloc->FixupInfoSize;
+            }
+            break;
+        }
+    }
+    printf( "\n" );
+}
+
+static const IMAGE_BASE_RELOCATION *get_armx_relocs( unsigned int *size )
+{
+    const char *ptr, *end;
+    const IMAGE_DYNAMIC_RELOCATION_TABLE *table = get_dyn_reloc_table();
+
+    if (!table) return NULL;
+    ptr = (const char *)(table + 1);
+    end = ptr + table->Size;
+    while (ptr < end)
+    {
+        switch (table->Version)
+        {
+        case 1:
+            if (PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+            {
+                const IMAGE_DYNAMIC_RELOCATION64 *reloc = (const IMAGE_DYNAMIC_RELOCATION64 *)ptr;
+                if (reloc->Symbol == IMAGE_DYNAMIC_RELOCATION_ARM64X)
+                {
+                    *size = reloc->BaseRelocSize;
+                    return (const IMAGE_BASE_RELOCATION *)(reloc + 1);
+                }
+                ptr += sizeof(*reloc) + reloc->BaseRelocSize;
+            }
+            else
+            {
+                const IMAGE_DYNAMIC_RELOCATION32 *reloc = (const IMAGE_DYNAMIC_RELOCATION32 *)ptr;
+                if (reloc->Symbol == IMAGE_DYNAMIC_RELOCATION_ARM64X)
+                {
+                    *size = reloc->BaseRelocSize;
+                    return (const IMAGE_BASE_RELOCATION *)(reloc + 1);
+                }
+                ptr += sizeof(*reloc) + reloc->BaseRelocSize;
+            }
+            break;
+        case 2:
+            if (PE_nt_headers->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+            {
+                const IMAGE_DYNAMIC_RELOCATION64_V2 *reloc = (const IMAGE_DYNAMIC_RELOCATION64_V2 *)ptr;
+                if (reloc->Symbol == IMAGE_DYNAMIC_RELOCATION_ARM64X)
+                {
+                    *size = reloc->FixupInfoSize;
+                    return (const IMAGE_BASE_RELOCATION *)(reloc + 1);
+                }
+                ptr += reloc->HeaderSize + reloc->FixupInfoSize;
+            }
+            else
+            {
+                const IMAGE_DYNAMIC_RELOCATION32_V2 *reloc = (const IMAGE_DYNAMIC_RELOCATION32_V2 *)ptr;
+                if (reloc->Symbol == IMAGE_DYNAMIC_RELOCATION_ARM64X)
+                {
+                    *size = reloc->FixupInfoSize;
+                    return (const IMAGE_BASE_RELOCATION *)(reloc + 1);
+                }
+                ptr += reloc->HeaderSize + reloc->FixupInfoSize;
+            }
+            break;
+        }
+    }
+    return NULL;
+}
+
+static const IMAGE_NT_HEADERS32 *get_alt_header( void )
+{
+    unsigned int page_size, size;
+    const IMAGE_BASE_RELOCATION *end, *reloc = get_armx_relocs( &size );
+    char *alt_dos;
+    const IMAGE_NT_HEADERS32 *hdr;
+
+    if (!reloc) return NULL;
+    page_size = PE_nt_headers->OptionalHeader.SectionAlignment;
+    alt_dos = malloc( page_size );
+    memcpy( alt_dos, PRD(0, page_size), page_size );
+    end = (const IMAGE_BASE_RELOCATION *)((const char *)reloc + size);
+    hdr = (const IMAGE_NT_HEADERS32 *)(alt_dos + ((IMAGE_DOS_HEADER *)alt_dos)->e_lfanew);
+
+    while (reloc < end - 1 && reloc->SizeOfBlock)
+    {
+        const USHORT *rel = (const USHORT *)(reloc + 1);
+        const USHORT *rel_end = (const USHORT *)reloc + reloc->SizeOfBlock / sizeof(USHORT);
+
+        if (!reloc->VirtualAddress)  /* only apply relocs to page 0 */
+        {
+            while (rel < rel_end && *rel)
+            {
+                USHORT offset = *rel & 0xfff;
+                USHORT type = (*rel >> 12) & 3;
+                USHORT arg = *rel >> 14;
+                int val;
+                rel++;
+                switch (type)
+                {
+                case 0:  /* zero-fill */
+                    memset( alt_dos + offset, 0, 1 << arg );
+                    break;
+                case 1:  /* set value */
+                    memcpy( alt_dos + offset, rel, 1 << arg );
+                    rel += (1 << arg) / sizeof(USHORT);
+                    break;
+                case 2:  /* add value */
+                    val = (unsigned int)*rel++ * ((arg & 2) ? 8 : 4);
+                    if (arg & 1) val = -val;
+                    *(int *)(alt_dos + offset) += val;
+                    break;
+                }
+            }
+        }
+        reloc = (const IMAGE_BASE_RELOCATION *)rel_end;
+    }
+    return hdr;
+}
+
 static void dump_dir_reloc(void)
 {
     unsigned int i, size = 0;
@@ -2395,9 +2937,8 @@ enum FileSig get_kind_exec(void)
 
 void pe_dump(void)
 {
-    int	all = (globals.dumpsect != NULL) && strcmp(globals.dumpsect, "ALL") == 0;
-
     PE_nt_headers = get_nt_header();
+    PE_alt_headers = get_alt_header();
     print_fake_dll();
 
     if (globals.do_dumpheader)
@@ -2413,32 +2954,32 @@ void pe_dump(void)
 	dump_pe_header();
     }
 
-    if (globals.dumpsect)
-    {
-	if (all || !strcmp(globals.dumpsect, "import"))
-        {
-	    dump_dir_imported_functions();
-	    dump_dir_delay_imported_functions();
-        }
-	if (all || !strcmp(globals.dumpsect, "export"))
-	    dump_dir_exported_functions();
-	if (all || !strcmp(globals.dumpsect, "debug"))
-	    dump_dir_debug();
-	if (all || !strcmp(globals.dumpsect, "resource"))
-	    dump_dir_resource();
-	if (all || !strcmp(globals.dumpsect, "tls"))
-	    dump_dir_tls();
-	if (all || !strcmp(globals.dumpsect, "loadcfg"))
-	    dump_dir_loadconfig();
-	if (all || !strcmp(globals.dumpsect, "clr"))
-	    dump_dir_clr_header();
-	if (all || !strcmp(globals.dumpsect, "reloc"))
-	    dump_dir_reloc();
-	if (all || !strcmp(globals.dumpsect, "except"))
-	    dump_dir_exceptions();
-	if (all || !strcmp(globals.dumpsect, "apiset"))
-	    dump_section_apiset();
+    if (globals_dump_sect("import"))
+    {
+        dump_dir_imported_functions();
+        dump_dir_delay_imported_functions();
     }
+    if (globals_dump_sect("export"))
+        dump_dir_exported_functions();
+    if (globals_dump_sect("debug"))
+        dump_dir_debug();
+    if (globals_dump_sect("resource"))
+        dump_dir_resource();
+    if (globals_dump_sect("tls"))
+        dump_dir_tls();
+    if (globals_dump_sect("loadcfg"))
+        dump_dir_loadconfig();
+    if (globals_dump_sect("clr"))
+        dump_dir_clr_header();
+    if (globals_dump_sect("reloc"))
+        dump_dir_reloc();
+    if (globals_dump_sect("dynreloc"))
+        dump_dir_dynamic_reloc();
+    if (globals_dump_sect("except"))
+        dump_dir_exceptions();
+    if (globals_dump_sect("apiset"))
+        dump_section_apiset();
+
     if (globals.do_symbol_table)
         dump_symbol_table();
     if (globals.do_debug)
diff --git a/tools/winedump/winedump.h b/tools/winedump/winedump.h
index caa47392144..4561ca3751a 100644
--- a/tools/winedump/winedump.h
+++ b/tools/winedump/winedump.h
@@ -135,13 +135,15 @@ typedef struct __globals
   const char *uc_dll_name;       /* -o */
 
   /* Option arguments: dump mode */
-  const char *dumpsect;    /* -j */
+  const char **dumpsect;   /* -j */
 } _globals;
 
 extern _globals globals;
 extern void *dump_base;
 extern size_t dump_total_len;
 
+BOOL globals_dump_sect(const char*);
+
 /* Names to use for output DLL */
 #define OUTPUT_DLL_NAME \
           (globals.dll_name ? globals.dll_name : (globals.input_module ? globals.input_module : globals.input_name))
@@ -230,9 +232,10 @@ const char*     get_guid_str(const GUID* guid);
 const char*     get_unicode_str( const WCHAR *str, int len );
 const char*     get_symbol_str(const char* symname);
 void            print_fake_dll(void);
-void            dump_file_header(const IMAGE_FILE_HEADER *);
+void            dump_file_header(const IMAGE_FILE_HEADER *, BOOL);
 void            dump_optional_header(const IMAGE_OPTIONAL_HEADER32 *, UINT);
 void            dump_section(const IMAGE_SECTION_HEADER *, const char* strtable);
+void            dump_section_characteristics(DWORD characteristics, const char* sep);
 
 enum FileSig    get_kind_exec(void);
 void            dos_dump( void );
diff --git a/tools/winegcc/winegcc.c b/tools/winegcc/winegcc.c
index 2e656f7ea83..0770ccfbe2a 100644
--- a/tools/winegcc/winegcc.c
+++ b/tools/winegcc/winegcc.c
@@ -91,16 +91,12 @@
 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <signal.h>
 #include <stdarg.h>
 #include <string.h>
 #include <errno.h>
 #include <ctype.h>
 #include <limits.h>
 #include <sys/types.h>
-#ifdef HAVE_SYS_SYSCTL_H
-# include <sys/sysctl.h>
-#endif
 
 #include "utils.h"
 
@@ -148,10 +144,7 @@ static const char *output_debug_file;
 static const char *output_implib;
 static int keep_generated = 0;
 const char *temp_dir = NULL;
-static struct strarray tmp_files;
-#ifdef HAVE_SIGSET_T
-static sigset_t signal_mask;
-#endif
+struct strarray temp_files = { 0 };
 
 static const char *bindir;
 static const char *libdir;
@@ -217,13 +210,7 @@ static void cleanup_output_files(void)
 
 static void clean_temp_files(void)
 {
-    unsigned int i;
-
-    if (keep_generated) return;
-
-    for (i = 0; i < tmp_files.count; i++)
-	unlink(tmp_files.str[i]);
-    if (temp_dir) rmdir( temp_dir );
+    if (!keep_generated) remove_temp_files();
 }
 
 /* clean things up when aborting on a signal */
@@ -232,25 +219,6 @@ static void exit_on_signal( int sig )
     exit(1);  /* this will call the atexit functions */
 }
 
-static char* get_temp_file(const char* prefix, const char* suffix)
-{
-    int fd;
-    char *tmp;
-
-#ifdef HAVE_SIGPROCMASK
-    sigset_t old_set;
-    /* block signals while manipulating the temp files list */
-    sigprocmask( SIG_BLOCK, &signal_mask, &old_set );
-#endif
-    fd = make_temp_file( prefix, suffix, &tmp );
-    close( fd );
-    strarray_add(&tmp_files, tmp);
-#ifdef HAVE_SIGPROCMASK
-    sigprocmask( SIG_SETMASK, &old_set, NULL );
-#endif
-    return tmp;
-}
-
 static int is_pe_target( const struct options *opts )
 {
     switch (opts->target.platform)
@@ -360,9 +328,9 @@ static struct strarray get_translator(struct options *opts)
 
 static int try_link( struct strarray prefix, struct strarray link_tool, const char *cflags )
 {
-    const char *in = get_temp_file( "try_link", ".c" );
-    const char *out = get_temp_file( "try_link", ".out" );
-    const char *err = get_temp_file( "try_link", ".err" );
+    const char *in = make_temp_file( "try_link", ".c" );
+    const char *out = make_temp_file( "try_link", ".out" );
+    const char *err = make_temp_file( "try_link", ".err" );
     struct strarray link = empty_strarray;
     int sout = -1, serr = -1;
     int ret;
@@ -419,12 +387,11 @@ static struct strarray get_link_args( struct options *opts, const char *output_n
 
     case PLATFORM_SOLARIS:
         {
-            char *mapfile = get_temp_file( output_name, ".map" );
+            char *mapfile = make_temp_file( output_name, ".map" );
             const char *align = opts->section_align ? opts->section_align : "0x1000";
 
             create_file( mapfile, 0644, "text = A%s;\ndata = A%s;\n", align, align );
             strarray_add( &flags, strmake("-Wl,-M,%s", mapfile) );
-            strarray_add( &tmp_files, mapfile );
         }
         break;
 
@@ -646,26 +613,9 @@ static char *get_lib_dir( struct options *opts )
 
 static void init_argv0_dir( const char *argv0 )
 {
-#ifndef _WIN32
-    char *dir;
-
-#if defined(__linux__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
-    dir = realpath( "/proc/self/exe", NULL );
-#elif defined (__FreeBSD__) || defined(__DragonFly__)
-    static int pathname[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
-    size_t path_size = PATH_MAX;
-    char *path = xmalloc( path_size );
-    if (!sysctl( pathname, ARRAY_SIZE(pathname), path, &path_size, NULL, 0 ))
-        dir = realpath( path, NULL );
-    free( path );
-#else
-    dir = realpath( argv0, NULL );
-#endif
-    if (!dir) return;
-    bindir = get_dirname( dir );
+    if (!(bindir = get_argv0_dir( argv0 ))) return;
     includedir = strmake( "%s/%s", bindir, BIN_TO_INCLUDEDIR );
     libdir = strmake( "%s/%s", bindir, BIN_TO_LIBDIR );
-#endif
 }
 
 static void compile(struct options* opts, const char* lang)
@@ -850,7 +800,7 @@ static const char* compile_to_object(struct options* opts, const char* file, con
     /* make a copy so we don't change any of the initial stuff */
     /* a shallow copy is exactly what we want in this case */
     copts = *opts;
-    copts.output_name = get_temp_file(get_basename_noext(file), ".o");
+    copts.output_name = make_temp_file(get_basename_noext(file), ".o");
     copts.compile_only = 1;
     copts.files = empty_strarray;
     strarray_add(&copts.files, file);
@@ -924,8 +874,8 @@ static char *find_static_lib( const char *dll )
 
 static const char *find_libgcc(struct strarray prefix, struct strarray link_tool)
 {
-    const char *out = get_temp_file( "find_libgcc", ".out" );
-    const char *err = get_temp_file( "find_libgcc", ".err" );
+    const char *out = make_temp_file( "find_libgcc", ".out" );
+    const char *err = make_temp_file( "find_libgcc", ".err" );
     struct strarray link = empty_strarray;
     int sout = -1, serr = -1;
     char *libgcc, *p;
@@ -1014,7 +964,7 @@ static const char *build_spec_obj( struct options *opts, const char *spec_file,
         strarray_add( &spec_args, strmake( "--ld-cmd=%s", strarray_tostring( tool, " " )));
     }
 
-    spec_o_name = get_temp_file(output_name, ".spec.o");
+    spec_o_name = make_temp_file(output_name, ".spec.o");
     if (!is_pe)
     {
         if (opts->pic) strarray_add(&spec_args, "-fPIC");
@@ -1537,17 +1487,7 @@ int main(int argc, char **argv)
     char* lang = 0;
     char* str;
 
-#ifdef SIGHUP
-    signal( SIGHUP, exit_on_signal );
-#endif
-    signal( SIGTERM, exit_on_signal );
-    signal( SIGINT, exit_on_signal );
-#ifdef HAVE_SIGADDSET
-    sigemptyset( &signal_mask );
-    sigaddset( &signal_mask, SIGHUP );
-    sigaddset( &signal_mask, SIGTERM );
-    sigaddset( &signal_mask, SIGINT );
-#endif
+    init_signals( exit_on_signal );
     init_argv0_dir( argv[0] );
 
     /* setup tmp file removal at exit */
diff --git a/tools/wmc/lang.c b/tools/wmc/lang.c
index 7dd80d840e6..ff6fabc915b 100644
--- a/tools/wmc/lang.c
+++ b/tools/wmc/lang.c
@@ -17,6 +17,9 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
+
+#include "config.h"
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/tools/wmc/wmc.c b/tools/wmc/wmc.c
index 145acb5d718..e4f2377e772 100644
--- a/tools/wmc/wmc.c
+++ b/tools/wmc/wmc.c
@@ -23,12 +23,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <signal.h>
 #include <limits.h>
 #include <sys/types.h>
-#ifdef HAVE_SYS_SYSCTL_H
-# include <sys/sysctl.h>
-#endif
 
 #include "wmc.h"
 #include "utils.h"
@@ -149,28 +145,11 @@ static void exit_on_signal( int sig )
 
 static void init_argv0_dir( const char *argv0 )
 {
-#ifndef _WIN32
-    char *dir;
-
-#if defined(__linux__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
-    dir = realpath( "/proc/self/exe", NULL );
-#elif defined (__FreeBSD__) || defined(__DragonFly__)
-    static int pathname[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
-    size_t path_size = PATH_MAX;
-    char *path = xmalloc( path_size );
-    if (!sysctl( pathname, ARRAY_SIZE(pathname), path, &path_size, NULL, 0 ))
-        dir = realpath( path, NULL );
-    else
-        dir = NULL;
-    free( path );
-#else
-    dir = realpath( argv0, NULL );
-#endif
+    char *dir = get_argv0_dir( argv0 );
+
     if (!dir) return;
-    dir = get_dirname( dir );
     if (strendswith( dir, "/tools/wmc" )) nlsdirs[0] = strmake( "%s/../../nls", dir );
     else nlsdirs[0] = strmake( "%s/%s", dir, BIN_TO_NLSDIR );
-#endif
 }
 
 static void option_callback( int optc, char *optarg )
@@ -241,11 +220,7 @@ int main(int argc,char *argv[])
         struct strarray files;
 
 	atexit( cleanup_files );
-	signal( SIGTERM, exit_on_signal );
-	signal( SIGINT, exit_on_signal );
-#ifdef SIGHUP
-	signal( SIGHUP, exit_on_signal );
-#endif
+        init_signals( exit_on_signal );
         init_argv0_dir( argv[0] );
 
 	/* First rebuild the commandline to put in destination */
diff --git a/tools/wrc/wrc.c b/tools/wrc/wrc.c
index 9f231603ad4..48d5d2033d8 100644
--- a/tools/wrc/wrc.c
+++ b/tools/wrc/wrc.c
@@ -26,12 +26,8 @@
 #include <string.h>
 #include <assert.h>
 #include <ctype.h>
-#include <signal.h>
 #include <limits.h>
 #include <sys/types.h>
-#ifdef HAVE_SYS_SYSCTL_H
-# include <sys/sysctl.h>
-#endif
 
 #include "../tools.h"
 #include "wrc.h"
@@ -133,9 +129,9 @@ int check_utf8 = 1;  /* whether to check for valid utf8 */
 
 static char *output_name;	/* The name given by the -o option */
 const char *input_name = NULL;	/* The name given on the command-line */
-static char *temp_name = NULL;	/* Temporary file for preprocess pipe */
 static struct strarray input_files;
 const char *temp_dir = NULL;
+struct strarray temp_files = { 0 };
 
 static int stdinc = 1;
 static int po_mode;
@@ -236,7 +232,7 @@ static int load_file( const char *input_name, const char *output_name )
     if(!no_preprocess)
     {
         FILE *output;
-        int ret, fd;
+        int ret;
         char *name;
 
         /*
@@ -260,9 +256,8 @@ static int load_file( const char *input_name, const char *output_name )
             exit(0);
         }
 
-        fd = make_temp_file( output_name, "", &name );
-        temp_name = name;
-        if (!(output = fdopen(fd, "wt")))
+        name = make_temp_file( output_name, "" );
+        if (!(output = fopen(name, "wt")))
             error("Could not open fd %s for writing\n", name);
 
         ret = wpp_parse( input_name, output );
@@ -284,39 +279,17 @@ static int load_file( const char *input_name, const char *output_name )
     ret = parser_parse();
     fclose(parser_in);
     parser_lex_destroy();
-    if (temp_name)
-    {
-        unlink( temp_name );
-        temp_name = NULL;
-    }
     return ret;
 }
 
 static void init_argv0_dir( const char *argv0 )
 {
-#ifndef _WIN32
-    char *dir;
-
-#if defined(__linux__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
-    dir = realpath( "/proc/self/exe", NULL );
-#elif defined (__FreeBSD__) || defined(__DragonFly__)
-    static int pathname[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
-    size_t path_size = PATH_MAX;
-    char *path = xmalloc( path_size );
-    if (!sysctl( pathname, ARRAY_SIZE(pathname), path, &path_size, NULL, 0 ))
-        dir = realpath( path, NULL );
-    else
-        dir = NULL;
-    free( path );
-#else
-    dir = realpath( argv0, NULL );
-#endif
+    char *dir = get_argv0_dir( argv0 );
+
     if (!dir) return;
-    dir = get_dirname( dir );
     includedir = strmake( "%s/%s", dir, BIN_TO_INCLUDEDIR );
     if (strendswith( dir, "/tools/wrc" )) nlsdirs[0] = strmake( "%s/../../nls", dir );
     else nlsdirs[0] = strmake( "%s/%s", dir, BIN_TO_NLSDIR );
-#endif
 }
 
 static void option_callback( int optc, char *optarg )
@@ -422,11 +395,7 @@ int main(int argc,char *argv[])
 {
 	int i;
 
-        signal( SIGTERM, exit_on_signal );
-        signal( SIGINT, exit_on_signal );
-#ifdef SIGHUP
-        signal( SIGHUP, exit_on_signal );
-#endif
+        init_signals( exit_on_signal );
 	init_argv0_dir( argv[0] );
 
 	/* Set the default defined stuff */
@@ -521,6 +490,5 @@ int main(int argc,char *argv[])
 static void cleanup_files(void)
 {
 	if (output_name) unlink(output_name);
-	if (temp_name) unlink(temp_name);
-        if (temp_dir) rmdir(temp_dir);
+        remove_temp_files();
 }
