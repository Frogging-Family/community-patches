From bff6063ce6c92fbdd95b1df386a30b60ab03b2d4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 14:09:36 +0200
Subject: [PATCH 001/125] gdi32: Track ticks since draw start per
 window_surface.

Track ticks since draw start per window_surface, instead of per window
as is currently the case. This helps reduce visual glitches caused by
badly timed flushes in backends which use the same (parent)
window_surface for children windows.

For example, with a shared window_surface, and with the current scheme
of per window start_tick tracking, we may flush while drawing a child
when performing a redraw originating from the parent:

flush
Draw parent (bounds is empty so parent start_ticks is reset)
Draw child 1 (bounds possibly not empty, child1 start_ticks not reset,
              and, depending on when child 1 was drawn independently,
              this could lead to a flush during the draw)

With per surface draw ticks:

flush
Draw parent (bounds is empty so surface start_ticks is reset)
Draw child 1 (bounds possibly not empty, but since surface start_ticks
              was reset by the parent it's unlikely that we flush during
              this draw)

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/gdi32/dibdrv/dc.c    | 7 ++++---
 include/wine/gdi_driver.h | 1 +
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/dlls/gdi32/dibdrv/dc.c b/dlls/gdi32/dibdrv/dc.c
index 413ba8b8665..7dcc2905823 100644
--- a/dlls/gdi32/dibdrv/dc.c
+++ b/dlls/gdi32/dibdrv/dc.c
@@ -731,7 +731,6 @@ struct windrv_physdev
     struct gdi_physdev     dev;
     struct dibdrv_physdev *dibdrv;
     struct window_surface *surface;
-    DWORD                  start_ticks;
 };
 
 static const struct gdi_dc_funcs window_driver;
@@ -745,13 +744,15 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     GDI_CheckNotLock();
     dev->surface->funcs->lock( dev->surface );
-    if (is_rect_empty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (is_rect_empty( dev->dibdrv->bounds ) || dev->surface->draw_start_ticks == 0)
+        dev->surface->draw_start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
 {
+    BOOL should_flush = NtGetTickCount() - dev->surface->draw_start_ticks > FLUSH_PERIOD;
     dev->surface->funcs->unlock( dev->surface );
-    if (NtGetTickCount() - dev->start_ticks > FLUSH_PERIOD) dev->surface->funcs->flush( dev->surface );
+    if (should_flush) dev->surface->funcs->flush( dev->surface );
 }
 
 static void CDECL unlock_bits_surface( struct gdi_image_bits *bits )
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 2baad217787..2a1bbe883b5 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -213,6 +213,7 @@ struct window_surface
     struct list                        entry; /* entry in global list managed by user32 */
     LONG                               ref;   /* reference count */
     RECT                               rect;  /* constant, no locking needed */
+    DWORD                              draw_start_ticks; /* start ticks of fresh draw */
     /* driver-specific fields here */
 };
 
-- 
2.33.0


From ab6e43dc99fd769eb4527163e5b1b368b4a46d0b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 23 Jun 2021 17:22:20 +0300
Subject: [PATCH 002/125] user32: Expose function to send internal thread
 messages.

Expose a function to drivers so that they can send internal messages to
specific threads, without the need to target a specific HWND.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/user32/message.c   | 13 +++++++++++++
 dlls/user32/user32.spec |  1 +
 include/winuser.h       |  3 +++
 3 files changed, 17 insertions(+)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 6f0f58a5f3f..5c06220ee3e 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -3386,6 +3386,19 @@ LRESULT MSG_SendInternalMessageTimeout( DWORD dest_pid, DWORD dest_tid,
     return ret;
 }
 
+/***********************************************************************
+ *		__wine_send_internal_message_timeout  (USER32.@)
+ *
+ * Same as SendMessageTimeoutW but sends the message to a specific thread
+ * without requiring a window handle. Only works for internal Wine messages.
+ */
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    return MSG_SendInternalMessageTimeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                           flags, timeout, res_ptr );
+}
 
 /***********************************************************************
  *		SendMessageTimeoutW  (USER32.@)
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 8d3ac70210c..e0fdd23969d 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -837,3 +837,4 @@
 #
 @ cdecl __wine_send_input(long ptr ptr)
 @ cdecl __wine_set_pixel_format(long long)
+@ cdecl __wine_send_internal_message_timeout(long long long long long long long ptr)
diff --git a/include/winuser.h b/include/winuser.h
index 260024d7e91..7446f7f4b45 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4407,6 +4407,9 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 
 /* Uxtheme hook functions and struct */
 
-- 
2.33.0


From e6ac1b2f855b446954656bc46fed585f796e9ff8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 15:48:36 +0300
Subject: [PATCH 003/125] winewayland.drv: Add initial driver stub.

Add the initial driver stub for the Wayland driver and enable building
it with the '--with-wayland' configure flag.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                 | 20 +++++++++
 configure.ac                              |  6 +++
 dlls/winewayland.drv/Makefile.in          | 12 ++++++
 dlls/winewayland.drv/version.rc           | 22 ++++++++++
 dlls/winewayland.drv/waylanddrv.h         | 33 +++++++++++++++
 dlls/winewayland.drv/waylanddrv_main.c    | 51 +++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  0
 7 files changed, 144 insertions(+)
 create mode 100644 dlls/winewayland.drv/Makefile.in
 create mode 100644 dlls/winewayland.drv/version.rc
 create mode 100644 dlls/winewayland.drv/waylanddrv.h
 create mode 100644 dlls/winewayland.drv/waylanddrv_main.c
 create mode 100644 dlls/winewayland.drv/winewayland.drv.spec

diff --git a/configure.ac b/configure.ac
index c0a126293c4..faffbba2520 100644
--- a/configure.ac
+++ b/configure.ac
@@ -113,6 +113,7 @@ AC_ARG_WITH(xshm,      AS_HELP_STRING([--without-xshm],[do not use XShm (shared
 AC_ARG_WITH(xslt,      AS_HELP_STRING([--without-xslt],[do not use XSLT]))
 AC_ARG_WITH(xxf86vm,   AS_HELP_STRING([--without-xxf86vm],[do not use XFree video mode extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi])
+AC_ARG_WITH(wayland,   AS_HELP_STRING([--with-wayland],[build with wayland support]))
 
 AC_ARG_WITH(wine-tools,AS_HELP_STRING([--with-wine-tools=DIR],[use Wine tools from directory DIR]))
 AC_ARG_WITH(wine64,    AS_HELP_STRING([--with-wine64=DIR],[use the 64-bit Wine in DIR for a Wow64 build]))
@@ -1281,6 +1282,10 @@ else
                      [enable_winex11_drv])
 fi
 
+WINE_NOTICE_WITH(wayland, [false],
+                 [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
+                 [enable_winewayland_drv])
+
 dnl **** Check for OpenCL ****
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
@@ -3760,6 +3765,7 @@ WINE_CONFIG_MAKEFILE(dlls/winepulse.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineqtdecoder)
 WINE_CONFIG_MAKEFILE(dlls/wineusb.sys)
 WINE_CONFIG_MAKEFILE(dlls/winevulkan)
+WINE_CONFIG_MAKEFILE(dlls/winewayland.drv)
 WINE_CONFIG_MAKEFILE(dlls/winex11.drv)
 WINE_CONFIG_MAKEFILE(dlls/winexinput.sys)
 WINE_CONFIG_MAKEFILE(dlls/wing.dll16,enable_win16)
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
new file mode 100644
index 00000000000..3d55b385e95
--- /dev/null
+++ b/dlls/winewayland.drv/Makefile.in
@@ -0,0 +1,12 @@
+MODULE    = winewayland.drv
+CFLAGS = -std=c11 -Wno-declaration-after-statement
+EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
+CPPFLAGS = -std=c11 -Wno-declaration-after-statement
+EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
+
+EXTRADLLFLAGS = -mcygwin
+
+C_SRCS = \
+	waylanddrv_main.c \
+
+RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/version.rc b/dlls/winewayland.drv/version.rc
new file mode 100644
index 00000000000..2d99c24f99c
--- /dev/null
+++ b/dlls/winewayland.drv/version.rc
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine Wayland driver"
+#define WINE_FILENAME_STR "winewayland.drv"
+
+#include "wine/wine_common_ver.rc"
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
new file mode 100644
index 00000000000..726193b16de
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -0,0 +1,33 @@
+/*
+ * Wayland driver
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_H
+#define __WINE_WAYLANDDRV_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+
+#endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
new file mode 100644
index 00000000000..92ef39777bd
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -0,0 +1,51 @@
+/*
+ * WAYLANDDRV initialization code
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2020 Alexandre Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+/***********************************************************************
+ *           WAYLANDDRV process initialisation routine
+ */
+static BOOL process_attach(void)
+{
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLANDDRV initialisation routine
+ */
+BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)
+{
+    BOOL ret = TRUE;
+
+    switch(reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(hinst);
+        ret = process_attach();
+        break;
+    }
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
new file mode 100644
index 00000000000..e69de29bb2d
-- 
2.33.0


From 639e729c29b9a07b5e2b62c826528f4987d71d37 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 18:41:03 +0200
Subject: [PATCH 004/125] explorer: Add the Wayland driver to the default
 driver list.

Add the Wayland driver at the end of the default driver list. This
ensures that, by default, under Wayland compositors that support
Xwayland, the more mature X11 driver will be used. One can force using
the wayland driver by ensuring X11 is not accessible, e.g., by unsetting
the DISPLAY environment variable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 programs/explorer/desktop.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 2ba276f52cb..f9f7c708bd5 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -39,7 +39,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(explorer);
 #define DESKTOP_CLASS_ATOM ((LPCWSTR)MAKEINTATOM(32769))
 #define DESKTOP_ALL_ACCESS 0x01ff
 
-static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',0};
+static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',',','w','a','y','l','a','n','d',0};
 
 static BOOL using_root;
 
-- 
2.33.0


From e675a7db8cd089b2843b05453084f6ee3c74ff19 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:21:21 +0300
Subject: [PATCH 005/125] winewayland.drv: Perform basic per-process Wayland
 initialization.

Try to connect to the Wayland compositor, and fail driver initialization
if we are unable to do so.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                              | 88 +++++++++++++++++++++++++-
 configure.ac                           |  9 ++-
 dlls/winewayland.drv/Makefile.in       |  3 +
 dlls/winewayland.drv/wayland.c         | 38 +++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  9 +++
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 include/config.h.in                    |  3 +
 7 files changed, 150 insertions(+), 2 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland.c

diff --git a/configure.ac b/configure.ac
index faffbba2520..820485a7b02 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1282,7 +1282,14 @@ else
                      [enable_winex11_drv])
 fi
 
-WINE_NOTICE_WITH(wayland, [false],
+if test "x$with_wayland" = "xyes"
+then
+    WINE_PACKAGE_FLAGS(WAYLAND_CLIENT,[wayland-client],,,,
+        [AC_CHECK_HEADERS([wayland-client.h])
+         AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
+                      [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+fi
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS"],
                  [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 3d55b385e95..4057bbaa99d 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,4 +1,6 @@
 MODULE    = winewayland.drv
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
+EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -7,6 +9,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
+	wayland.c \
 	waylanddrv_main.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
new file mode 100644
index 00000000000..1a12d4fb9a4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland.c
@@ -0,0 +1,38 @@
+/*
+ * Wayland core handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+struct wl_display *process_wl_display = NULL;
+
+/**********************************************************************
+ *          wayland_process_init
+ *
+ *  Initialise the per process wayland objects.
+ *
+ */
+BOOL wayland_process_init(void)
+{
+    process_wl_display = wl_display_connect(NULL);
+    return process_wl_display != NULL;
+}
+
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 726193b16de..c7758a3d979 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -26,8 +26,17 @@
 #endif
 
 #include <stdarg.h>
+#include <wayland-client.h>
 
 #include "windef.h"
 #include "winbase.h"
 
+extern struct wl_display *process_wl_display;
+
+/**********************************************************************
+ *          Wayland initialisation
+ */
+
+BOOL wayland_process_init(void);
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 92ef39777bd..607a5770e0f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -29,6 +29,8 @@
  */
 static BOOL process_attach(void)
 {
+    if (!wayland_process_init()) return FALSE;
+
     return TRUE;
 }
 
diff --git a/include/config.h.in b/include/config.h.in
index f66444fd715..55264ce7393 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -908,6 +908,9 @@
 /* Define to 1 if you have the <valgrind/valgrind.h> header file. */
 #undef HAVE_VALGRIND_VALGRIND_H
 
+/* Define to 1 if you have the <wayland-client.h> header file. */
+#undef HAVE_WAYLAND_CLIENT_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.33.0


From e737cecabddc0b57f5d0085c5a3c8c2312bc6a44 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 17:16:12 +0300
Subject: [PATCH 006/125] winewayland.drv: Add stub for per-thread data.

Handle allocation and deallocation of per-thread data (currently without
any actual contents).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h         | 19 ++++++++++
 dlls/winewayland.drv/waylanddrv_main.c    | 44 +++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  3 ++
 3 files changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c7758a3d979..4e6a39aaf10 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -33,6 +33,25 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+ *          Wayland thread data
+ */
+
+struct wayland_thread_data
+{
+};
+
+extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
+extern DWORD thread_data_tls_index DECLSPEC_HIDDEN;
+
+static inline struct wayland_thread_data *wayland_thread_data(void)
+{
+    DWORD err = GetLastError();  /* TlsGetValue always resets last error */
+    struct wayland_thread_data *data = TlsGetValue(thread_data_tls_index);
+    SetLastError(err);
+    return data;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 607a5770e0f..cfa61436372 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -24,11 +24,55 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
+
+/***********************************************************************
+ *           Initialize per thread data
+ */
+struct wayland_thread_data *wayland_init_thread_data(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data) return data;
+
+    if (!(data = heap_alloc_zero(sizeof(*data))))
+    {
+        ERR("could not create data\n");
+        ExitProcess(1);
+    }
+
+    TlsSetValue(thread_data_tls_index, data);
+
+    return data;
+}
+
+/***********************************************************************
+ *           ThreadDetach (WAYLAND.@)
+ */
+void CDECL WAYLAND_ThreadDetach(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data)
+    {
+        heap_free(data);
+        /* clear data in case we get re-entered from user32 before the thread is truly dead */
+        TlsSetValue(thread_data_tls_index, NULL);
+    }
+}
+
 /***********************************************************************
  *           WAYLANDDRV process initialisation routine
  */
 static BOOL process_attach(void)
 {
+    if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
+
     if (!wayland_process_init()) return FALSE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index e69de29bb2d..c80959515a7 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -0,0 +1,3 @@
+# USER driver
+
+@ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From 8e350a32451b375bbc01f66a1b9a67e18bd89f48 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:53:51 +0300
Subject: [PATCH 007/125] winewayland.drv: Initialize basic per-thread Wayland
 instance.

Every thread that requires interaction with Wayland maintains its own
independent set of Wayland protocols objects. Events from Wayland
protocol objects are dispatched into a thread-specific Wayland event
queue.

This design simplifies synchronization, since there is no shared Wayland
state between threads, and will later make it easier to dispatch events
to the proper thread message queue. The downside is that there is some
duplication of event handling if multiple GUI threads are present.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 105 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |  18 +++++
 dlls/winewayland.drv/waylanddrv_main.c |  10 +++
 3 files changed, 132 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1a12d4fb9a4..c81a220ee27 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -22,8 +22,112 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
 struct wl_display *process_wl_display = NULL;
 
+/**********************************************************************
+ *          Registry handling
+ */
+
+static void registry_handle_global(void *data, struct wl_registry *registry,
+                                   uint32_t id, const char *interface,
+                                   uint32_t version)
+{
+    struct wayland *wayland = data;
+
+    TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
+
+    if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
+}
+
+static void registry_handle_global_remove(void *data, struct wl_registry *registry,
+                                          uint32_t id)
+{
+    TRACE("id=%d\n", id);
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+
+/**********************************************************************
+ *          wayland_init
+ *
+ *  Initialise a wayland instance.
+ */
+BOOL wayland_init(struct wayland *wayland)
+{
+    TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
+
+    wayland->process_id = GetCurrentProcessId();
+    wayland->thread_id = GetCurrentThreadId();
+    wayland->wl_display = process_wl_display;
+
+    if (!wayland->wl_display)
+    {
+        ERR("Failed to connect to wayland compositor\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create event queue\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_registry = wl_display_get_registry(wayland->wl_display)))
+    {
+        ERR("Failed to get to wayland registry\n");
+        return FALSE;
+    }
+    wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
+
+    /* Populate registry */
+    wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
+
+    /* We need three roundtrips. One to get and bind globals, one to handle all
+     * initial events produced from registering the globals and one more to
+     * handle potential third-order registrations. */
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
+    wayland->initialized = TRUE;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_deinit
+ *
+ *  Deinitialise a wayland instance, releasing all associated resources.
+ */
+void wayland_deinit(struct wayland *wayland)
+{
+    TRACE("%p\n", wayland);
+
+    if (wayland->wl_compositor)
+        wl_compositor_destroy(wayland->wl_compositor);
+
+    if (wayland->wl_registry)
+        wl_registry_destroy(wayland->wl_registry);
+
+    if (wayland->wl_event_queue)
+        wl_event_queue_destroy(wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    memset(wayland, 0, sizeof(*wayland));
+}
+
 /**********************************************************************
  *          wayland_process_init
  *
@@ -35,4 +139,3 @@ BOOL wayland_process_init(void)
     process_wl_display = wl_display_connect(NULL);
     return process_wl_display != NULL;
 }
-
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4e6a39aaf10..9728811c313 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -33,12 +33,28 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+ *          Definitions for wayland types
+ */
+
+struct wayland
+{
+    BOOL initialized;
+    DWORD process_id;
+    DWORD thread_id;
+    struct wl_display *wl_display;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_registry *wl_registry;
+    struct wl_compositor *wl_compositor;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
 
 struct wayland_thread_data
 {
+    struct wayland wayland;
 };
 
 extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
@@ -57,5 +73,7 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
  */
 
 BOOL wayland_process_init(void);
+BOOL wayland_init(struct wayland *wayland);
+void wayland_deinit(struct wayland *wayland);
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index cfa61436372..5748afaabeb 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -28,6 +28,7 @@
 #include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 
@@ -46,6 +47,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    if (!wayland_init(&data->wayland))
+    {
+        ERR_(winediag)("waylanddrv: Can't open wayland display. Please ensure "
+                       "that your wayland server is running and that "
+                       "$WAYLAND_DISPLAY is set correctly.\n");
+        ExitProcess(1);
+    }
+
     TlsSetValue(thread_data_tls_index, data);
 
     return data;
@@ -60,6 +69,7 @@ void CDECL WAYLAND_ThreadDetach(void)
 
     if (data)
     {
+        wayland_deinit(&data->wayland);
         heap_free(data);
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
         TlsSetValue(thread_data_tls_index, NULL);
-- 
2.33.0


From b4e48943423710550674901707d7b2ee6bdaa764 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 17:39:54 +0300
Subject: [PATCH 008/125] winewayland.drv: Initialize Wayland thread data for
 desktop window thread.

Having access to the Wayland thread data will allow the desktop process
to eventually access information that requires interaction with the
Wayland compositor. A prime example is accessing display information.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in          |  2 +
 dlls/winewayland.drv/window.c             | 49 +++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 3 files changed, 52 insertions(+)
 create mode 100644 dlls/winewayland.drv/window.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4057bbaa99d..450b43af5d1 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,4 +1,5 @@
 MODULE    = winewayland.drv
+IMPORTS   = user32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -11,5 +12,6 @@ EXTRADLLFLAGS = -mcygwin
 C_SRCS = \
 	wayland.c \
 	waylanddrv_main.c \
+	window.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
new file mode 100644
index 00000000000..66e5c632ed8
--- /dev/null
+++ b/dlls/winewayland.drv/window.c
@@ -0,0 +1,49 @@
+/*
+ * Window related functions
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *           WAYLAND_CreateWindow
+ */
+BOOL CDECL WAYLAND_CreateWindow(HWND hwnd)
+{
+    TRACE("%p\n", hwnd);
+
+    if (hwnd == GetDesktopWindow())
+    {
+        /* Initialize wayland so that the desktop process has access
+         * to all the wayland related information (e.g., displays). */
+        wayland_init_thread_data();
+    }
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index c80959515a7..9528d7bc6ef 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -1,3 +1,4 @@
 # USER driver
 
+@ cdecl CreateWindow(long) WAYLAND_CreateWindow
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From 30c46f13c41f3d046fe2abe632a35e62b698a079 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 14:04:43 +0300
Subject: [PATCH 009/125] tools: Support building Wayland protocol source
 files.

Wayland protocol descriptions are distributed as source XML files that
need to be transformed to C source and header files with a version of
the wayland-scanner tool compatible with the used libwayland library.

This commit enhances the makedep build tool to support building such
Wayland protocol XML files. Components can use the WAYLAND_PROTOCOL_SRCS
build variable to add protocol XML files to their build.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 Makefile.in     |  1 +
 configure       | 83 +++++++++++++++++++++++++++++++++++++++++++++++--
 configure.ac    | 13 ++++++--
 tools/makedep.c | 39 +++++++++++++++++++++++
 4 files changed, 130 insertions(+), 6 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 42f161e3af9..8cf58d4f972 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,6 +89,7 @@ DISABLED_SUBDIRS    = @DISABLED_SUBDIRS@
 CONFIGURE_TARGETS   = @CONFIGURE_TARGETS@
 TOP_INSTALL_LIB     = @TOP_INSTALL_LIB@
 TOP_INSTALL_DEV     = @TOP_INSTALL_DEV@
+WAYLAND_SCANNER     = @WAYLAND_SCANNER@
 @ALL_VARS_RULES@
 @SET_MAKE@
 
diff --git a/configure.ac b/configure.ac
index 820485a7b02..028f7d18cf1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1288,9 +1288,16 @@ then
         [AC_CHECK_HEADERS([wayland-client.h])
          AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
                       [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_PROTOCOLS, [wayland-protocols],,,,
+         [AC_SUBST(WAYLAND_PROTOCOLS_DATADIR,
+                   `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
+    AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
+                 [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
 fi
-WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS"],
-                 [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER"],
+                 [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
 dnl **** Check for OpenCL ****
@@ -2667,7 +2674,7 @@ AC_CONFIG_COMMANDS([include/stamp-h], [echo timestamp > include/stamp-h])
 AS_ECHO_N("creating Makefile rules...") >&AS_MESSAGE_FD
 
 AC_SUBST([ALL_VARS_RULES],
-"m4_set_foreach([_AC_SUBST_VARS],[var],[m4_if(m4_bregexp(m4_defn([var]),[\(_CFLAGS\|_LIBS\)$]),-1,,[var = $var
+"m4_set_foreach([_AC_SUBST_VARS],[var],[m4_if(m4_bregexp(m4_defn([var]),[\(_CFLAGS\|_LIBS\|_DATADIR\)$]),-1,,[var = $var
 ])])")
 
 makedep_flags=""
diff --git a/tools/makedep.c b/tools/makedep.c
index 6e10e4d3be4..58aa427d981 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -176,6 +176,7 @@ static const char *msgfmt;
 static const char *ln_s;
 static const char *sed_cmd;
 static const char *delay_load_flag;
+static const char *wayland_scanner;
 
 struct makefile
 {
@@ -662,6 +663,15 @@ static char *replace_filename( const char *path, const char *name )
     return ret;
 }
 
+/*******************************************************************
+ *         get_filename
+ */
+static char *get_filename( const char *name )
+{
+    char *filename = strrchr( name, '/' );
+    if (!filename) return strdup( name );
+    return strdup( filename + 1 );
+}
 
 /*******************************************************************
  *         strarray_replace_extension
@@ -1491,6 +1501,9 @@ static struct file *open_include_file( const struct makefile *make, struct incl_
         return file;
     }
 
+    /* TODO: check for corresponding wayland protocol .xml file */
+    if (strendswith( pFile->name, "-client-protocol.h" )) return NULL;
+
     /* check for extra targets */
     if (strarray_exists( &make->extra_targets, pFile->name ))
     {
@@ -1976,6 +1989,19 @@ static void add_generated_sources( struct makefile *make )
             strarray_addall_uniq( &make->extra_imports,
                                   get_expanded_file_local_var( make, obj, "IMPORTS" ));
         }
+        if (strendswith( source->name, ".xml" ))
+        {
+            char *filename = get_filename( source->name );
+            char *code_filename = replace_extension ( filename , ".xml", "-protocol.c" );
+            char *header_filename = replace_extension ( filename , ".xml", "-client-protocol.h" );
+
+            add_generated_source( make, code_filename, NULL );
+            add_generated_source( make, header_filename, NULL );
+
+            free( filename );
+            free( code_filename );
+            free( header_filename );
+        }
     }
     if (make->testdll)
     {
@@ -3127,6 +3153,15 @@ static void output_source_spec( struct makefile *make, struct incl_file *source,
     output( "\n" );
 }
 
+static void output_source_xml( struct makefile *make, struct incl_file *source, const char *obj )
+{
+    char *base = get_filename( obj );
+    output( "%s-protocol.c: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s private-code $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner );
+    output( "%s-client-protocol.h: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s client-header $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner);
+    free( base );
+}
 
 /*******************************************************************
  *         output_source_default
@@ -3239,6 +3274,7 @@ static const struct
     { "in", output_source_in },
     { "x", output_source_x },
     { "spec", output_source_spec },
+    { "xml", output_source_xml },
     { NULL, output_source_default }
 };
 
@@ -4137,6 +4173,7 @@ static void output_silent_rules(void)
         "MSG",
         "SED",
         "TEST",
+        "WAYLAND_SCANNER",
         "WIDL",
         "WMC",
         "WRC"
@@ -4229,6 +4266,7 @@ static void load_sources( struct makefile *make )
         "IN_SRCS",
         "PO_SRCS",
         "MANPAGES",
+        "WAYLAND_PROTOCOL_SRCS",
         NULL
     };
     const char **var;
@@ -4456,6 +4494,7 @@ int main( int argc, char *argv[] )
     msgfmt             = get_expanded_make_variable( top_makefile, "MSGFMT" );
     sed_cmd            = get_expanded_make_variable( top_makefile, "SED_CMD" );
     ln_s               = get_expanded_make_variable( top_makefile, "LN_S" );
+    wayland_scanner    = get_expanded_make_variable( top_makefile, "WAYLAND_SCANNER" );
 
     if (root_src_dir && !strcmp( root_src_dir, "." )) root_src_dir = NULL;
     if (tools_dir && !strcmp( tools_dir, "." )) tools_dir = NULL;
-- 
2.33.0


From a96e3845de3f7b1f2d5a84e83d733ed582c69ecf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 18:21:04 +0300
Subject: [PATCH 010/125] winewayland.drv: Handle Wayland output global events.

The wl_output global objects are dynamically created and destroyed by
the Wayland compositor to convey information about the display outputs.
This commit handles the creation and removal of wl_output objects as
well as related informational events to maintain a complete per-thread
display output state.

In addition to the core wl_output protocol object, the
xdg-output-unstable-v1 extension is used, if present, to get additional
information about the outputs, including their unique name and logical
coordinates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   4 +
 dlls/winewayland.drv/wayland.c        |  41 +++
 dlls/winewayland.drv/wayland_output.c | 448 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  38 +++
 4 files changed, 531 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_output.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 450b43af5d1..f1e1d1cc655 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,7 +11,11 @@ EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	wayland.c \
+	wayland_output.c \
 	waylanddrv_main.c \
 	window.c \
 
+WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
+
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c81a220ee27..f2d2063d059 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -23,6 +23,7 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
@@ -45,12 +46,42 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_output") == 0)
+    {
+        if (!wayland_output_create(wayland, id, version))
+            ERR("Failed to create wayland_output for global id=%u\n", id);
+    }
+    else if (strcmp(interface, "zxdg_output_manager_v1") == 0)
+    {
+        struct wayland_output *output;
+
+        wayland->zxdg_output_manager_v1 =
+            wl_registry_bind(registry, id, &zxdg_output_manager_v1_interface,
+                             version < 3 ? version : 3);
+
+        /* Add zxdg_output_v1 to existing outputs. */
+        wl_list_for_each(output, &wayland->output_list, link)
+            wayland_output_use_xdg_extension(output);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
                                           uint32_t id)
 {
+    struct wayland *wayland = data;
+    struct wayland_output *output, *tmp;
+
     TRACE("id=%d\n", id);
+
+    wl_list_for_each_safe(output, tmp, &wayland->output_list, link)
+    {
+        if (output->global_id == id)
+        {
+            TRACE("removing output->name=%s\n", output->name);
+            wayland_output_destroy(output);
+            return;
+        }
+    }
 }
 
 static const struct wl_registry_listener registry_listener = {
@@ -90,6 +121,8 @@ BOOL wayland_init(struct wayland *wayland)
     }
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
+    wl_list_init(&wayland->output_list);
+
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
 
@@ -112,8 +145,16 @@ BOOL wayland_init(struct wayland *wayland)
  */
 void wayland_deinit(struct wayland *wayland)
 {
+    struct wayland_output *output, *output_tmp;
+
     TRACE("%p\n", wayland);
 
+    wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
+        wayland_output_destroy(output);
+
+    if (wayland->zxdg_output_manager_v1)
+        zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
+
     if (wayland->wl_compositor)
         wl_compositor_destroy(wayland->wl_compositor);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
new file mode 100644
index 00000000000..4f7ce760ed2
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -0,0 +1,448 @@
+/*
+ * Wayland output handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct default_mode { int32_t width; int32_t height; };
+struct default_mode default_modes[] = {
+    /* 4:3 */
+    { 320,  240},
+    { 400,  300},
+    { 512,  384},
+    { 640,  480},
+    { 768,  576},
+    { 800,  600},
+    {1024,  768},
+    {1152,  864},
+    {1280,  960},
+    {1400, 1050},
+    {1600, 1200},
+    {2048, 1536},
+    /* 5:4 */
+    {1280, 1024},
+    {2560, 2048},
+    /* 16:9 */
+    {1280,  720},
+    {1366,  768},
+    {1600,  900},
+    {1920, 1080},
+    {2560, 1440},
+    {3200, 1800},
+    {3840, 2160},
+    /* 16:10 */
+    { 320,  200},
+    { 640,  400},
+    {1280,  800},
+    {1440,  900},
+    {1680, 1050},
+    {1920, 1200},
+    {2560, 1600},
+    {3840, 2400}
+};
+
+/**********************************************************************
+ *          Output handling
+ */
+
+static void wayland_output_add_mode(struct wayland_output *output,
+                                    int32_t width, int32_t height,
+                                    int32_t refresh, int bpp,
+                                    BOOL current, BOOL native)
+{
+    struct wayland_output_mode *mode;
+
+    /* Update mode if already in list */
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        if (mode->width == width && mode->height == height &&
+            mode->refresh == refresh && mode->bpp == bpp)
+        {
+            /* Upgrade modes from virtual to native, never the reverse. */
+            if (native) mode->native = TRUE;
+            if (current)
+                output->current_mode = mode;
+            return;
+        }
+    }
+
+    mode = heap_alloc_zero(sizeof(*mode));
+
+    mode->width = width;
+    mode->height = height;
+    mode->refresh = refresh;
+    mode->bpp = bpp;
+    mode->native = native;
+
+    if (current)
+        output->current_mode = mode;
+
+    wl_list_insert(&output->mode_list, &mode->link);
+}
+
+static void wayland_output_add_mode_all_bpp(struct wayland_output *output,
+                                            int32_t width, int32_t height,
+                                            int32_t refresh, BOOL current,
+                                            BOOL native)
+{
+    wayland_output_add_mode(output, width, height, refresh, 32, current, native);
+    wayland_output_add_mode(output, width, height, refresh, 16, FALSE, FALSE);
+    wayland_output_add_mode(output, width, height, refresh, 8, FALSE, FALSE);
+}
+
+static void wayland_output_add_default_modes(struct wayland_output *output)
+{
+    int i;
+    struct wayland_output_mode *mode, *tmp;
+    int32_t max_width = 0;
+    int32_t max_height = 0;
+
+    /* Remove all existing virtual modes and get the maximum native
+     * mode size. */
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        if (!mode->native)
+        {
+            wl_list_remove(&mode->link);
+            heap_free(mode);
+        }
+        else
+        {
+            max_width = mode->width > max_width ? mode->width : max_width;
+            max_height = mode->height > max_height ? mode->height : max_height;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(default_modes); i++)
+    {
+        int32_t width = default_modes[i].width;
+        int32_t height = default_modes[i].height;
+
+        /* Skip if this mode is larger than the largest native mode. */
+        if (width > max_width || height > max_height)
+        {
+            TRACE("Skipping mode %dx%d (max: %dx%d)\n",
+                    width, height, max_width, max_height);
+            continue;
+        }
+
+        wayland_output_add_mode_all_bpp(output, width, height, 60000, FALSE, FALSE);
+    }
+}
+
+static struct wayland_output **
+wayland_output_array_append(struct wayland_output **array, int size,
+                            struct wayland_output *output)
+{
+    struct wayland_output **realloc_array;
+
+    realloc_array = heap_realloc(array, sizeof(*array) * size);
+    if (!realloc_array)
+    {
+        heap_free(array);
+        return NULL;
+    }
+
+    realloc_array[size - 1] = output;
+
+    return realloc_array;
+}
+
+static void wayland_output_update_physical_coords(struct wayland_output *output)
+{
+    struct wayland_output *o;
+    struct wayland_output **changed = NULL;
+    int changed_size = 0;
+    int changed_i = 0;
+
+    /* Set some default values. */
+    output->x = output->logical_x;
+    output->y = output->logical_y;
+
+    /* Update output->x,y based on other outputs that are to
+     * to the left or above. */
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (o == output || o->logical_w == 0 || o->logical_h == 0) continue;
+        if (output->logical_x == o->logical_x + o->logical_w)
+            output->x = o->x + o->current_mode->width;
+        if (output->logical_y == o->logical_y + o->logical_h)
+            output->y = o->y + o->current_mode->height;
+    }
+
+    changed = wayland_output_array_append(changed, ++changed_size, output);
+    if (!changed) { ERR("memory allocation failed"); return; }
+
+    /* Update the x,y of other outputs that are to the right or below and are
+     * directly or indirectly affected by the change output->x,y.
+     */
+    for (changed_i = 0; changed_i < changed_size; changed_i++)
+    {
+        struct wayland_output *cur = changed[changed_i];
+        wl_list_for_each(o, &output->wayland->output_list, link)
+        {
+            if (o == cur || o->logical_w == 0 || o->logical_h == 0) continue;
+            if (o->logical_x == cur->logical_x + cur->logical_w)
+            {
+                o->x = cur->x + cur->current_mode->width;
+                changed = wayland_output_array_append(changed, ++changed_size, o);
+                if (!changed) { ERR("memory allocation failed"); return; }
+            }
+            if (o->logical_y == cur->logical_y + cur->logical_h)
+            {
+                o->y = cur->y + cur->current_mode->height;
+                changed = wayland_output_array_append(changed, ++changed_size, o);
+                if (!changed) { ERR("memory allocation failed"); return; }
+            }
+        }
+    }
+
+    heap_free(changed);
+}
+
+static void wayland_output_clear_modes(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode, *tmp;
+
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        wl_list_remove(&mode->link);
+        heap_free(mode);
+    }
+}
+
+static void wayland_output_done(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode;
+    struct wayland_output *o;
+
+    TRACE("output->name=%s\n", output->name);
+
+    wayland_output_add_default_modes(output);
+    wayland_output_update_physical_coords(output);
+
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        TRACE("mode %dx%d @ %d %s\n",
+              mode->width, mode->height, mode->refresh,
+              output->current_mode == mode ? "*" : "");
+    }
+
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (!o->current_mode) continue;
+        TRACE("output->name=%s logical=%d,%d+%dx%d physical=%d,%d+%dx%d\n",
+              o->name,
+              o->logical_x, output->logical_y, o->logical_w, o->logical_h,
+              o->x, o->y, o->current_mode->width, o->current_mode->height);
+    }
+}
+
+static void output_handle_geometry(void *data, struct wl_output *wl_output,
+                                   int32_t x, int32_t y,
+                                   int32_t physical_width, int32_t physical_height,
+                                   int32_t subpixel,
+                                   const char *make, const char *model,
+                                   int32_t output_transform)
+{
+}
+
+static void output_handle_mode(void *data, struct wl_output *wl_output,
+                               uint32_t flags, int32_t width, int32_t height,
+                               int32_t refresh)
+{
+    struct wayland_output *output = data;
+
+    wayland_output_add_mode_all_bpp(output, width, height, refresh,
+                                    (flags & WL_OUTPUT_MODE_CURRENT),
+                                    TRUE);
+}
+
+static void output_handle_done(void *data, struct wl_output *wl_output)
+{
+    struct wayland_output *output = data;
+    if (!output->zxdg_output_v1 ||
+        zxdg_output_v1_get_version(output->zxdg_output_v1) >= 3)
+    {
+        wayland_output_done(output);
+    }
+}
+
+static void output_handle_scale(void *data, struct wl_output *wl_output,
+                                int32_t scale)
+{
+    struct wayland_output *output = data;
+    TRACE("output=%p scale=%d\n", output, scale);
+    output->scale = scale;
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale
+};
+
+static void zxdg_output_v1_handle_logical_position(void *data,
+                                                   struct zxdg_output_v1 *zxdg_output_v1,
+                                                   int32_t x,
+                                                   int32_t y)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_x=%d logical_y=%d\n", x, y);
+    output->logical_x = x;
+    output->logical_y = y;
+}
+
+static void zxdg_output_v1_handle_logical_size(void *data,
+                                               struct zxdg_output_v1 *zxdg_output_v1,
+                                               int32_t width,
+                                               int32_t height)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_w=%d logical_h=%d\n", width, height);
+    output->logical_w = width;
+    output->logical_h = height;
+}
+
+static void zxdg_output_v1_handle_done(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1)
+{
+    if (zxdg_output_v1_get_version(zxdg_output_v1) < 3)
+    {
+        struct wayland_output *output = data;
+        wayland_output_done(output);
+    }
+}
+
+static void zxdg_output_v1_handle_name(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1,
+                                       const char *name)
+{
+    struct wayland_output *output = data;
+
+    free(output->name);
+    output->name = strdup(name);
+}
+
+static void zxdg_output_v1_handle_description(void *data,
+                                              struct zxdg_output_v1 *zxdg_output_v1,
+                                              const char *description)
+{
+}
+
+static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
+    zxdg_output_v1_handle_logical_position,
+    zxdg_output_v1_handle_logical_size,
+    zxdg_output_v1_handle_done,
+    zxdg_output_v1_handle_name,
+    zxdg_output_v1_handle_description,
+};
+
+/**********************************************************************
+ *          wayland_output_create
+ *
+ *  Creates a wayland_output and adds it to the output list.
+ */
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version)
+{
+    struct wayland_output *output = heap_alloc_zero(sizeof(*output));
+
+    if (!output)
+    {
+        ERR("Couldn't allocate space for wayland_output\n");
+        goto err;
+    }
+
+    output->wayland = wayland;
+    output->wl_output = wl_registry_bind(wayland->wl_registry, id,
+                                         &wl_output_interface,
+                                         version < 2 ? version : 2);
+    output->global_id = id;
+    wl_output_add_listener(output->wl_output, &output_listener, output);
+
+    wl_list_init(&output->mode_list);
+    wl_list_init(&output->link);
+
+    output->scale = 1;
+
+    /* Have a fallback in case xdg_output is not supported or name is not sent. */
+    output->name = malloc(20);
+    if (output->name)
+    {
+        snprintf(output->name, 20, "WaylandOutput%d",
+                 wayland->next_fallback_output_id++);
+    }
+    else
+    {
+        ERR("Couldn't allocate space for output name\n");
+        goto err;
+    }
+
+    if (wayland->zxdg_output_manager_v1)
+        wayland_output_use_xdg_extension(output);
+
+    wl_list_insert(output->wayland->output_list.prev, &output->link);
+
+    return TRUE;
+
+err:
+    if (output) wayland_output_destroy(output);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_output_destroy
+ *
+ *  Destroys a wayland_output.
+ */
+void wayland_output_destroy(struct wayland_output *output)
+{
+    wayland_output_clear_modes(output);
+    wl_list_remove(&output->link);
+    free(output->name);
+    if (output->zxdg_output_v1)
+        zxdg_output_v1_destroy(output->zxdg_output_v1);
+    wl_output_destroy(output->wl_output);
+
+    heap_free(output);
+}
+
+/**********************************************************************
+ *          wayland_output_use_xdg_extension
+ *
+ *  Use the zxdg_output_v1 extension to get output information.
+ */
+void wayland_output_use_xdg_extension(struct wayland_output *output)
+{
+    output->zxdg_output_v1 =
+        zxdg_output_manager_v1_get_xdg_output(output->wayland->zxdg_output_manager_v1,
+                                              output->wl_output);
+    zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
+                                output);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9728811c313..99db87cf44b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -27,6 +27,7 @@
 
 #include <stdarg.h>
 #include <wayland-client.h>
+#include "xdg-output-unstable-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -46,6 +47,35 @@ struct wayland
     struct wl_event_queue *wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
+    uint32_t next_fallback_output_id;
+    struct wl_list output_list;
+};
+
+struct wayland_output_mode
+{
+    struct wl_list link;
+    int32_t width;
+    int32_t height;
+    int32_t refresh;
+    int bpp;
+    BOOL native;
+};
+
+struct wayland_output
+{
+    struct wl_list link;
+    struct wayland *wayland;
+    struct wl_output *wl_output;
+    struct zxdg_output_v1 *zxdg_output_v1;
+    struct wl_list mode_list;
+    struct wayland_output_mode *current_mode;
+    int logical_x, logical_y;  /* logical position */
+    int logical_w, logical_h;  /* logical size */
+    int x, y;  /* position in native pixel coordinate space */
+    int scale; /* wayland output scale factor for hidpi */
+    char *name;
+    uint32_t global_id;
 };
 
 /**********************************************************************
@@ -76,4 +106,12 @@ BOOL wayland_process_init(void);
 BOOL wayland_init(struct wayland *wayland);
 void wayland_deinit(struct wayland *wayland);
 
+/**********************************************************************
+ *          Wayland output
+ */
+
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version);
+void wayland_output_destroy(struct wayland_output *output);
+void wayland_output_use_xdg_extension(struct wayland_output *output);
+
 #endif /* __WINE_WAYLANDDRV_H */
-- 
2.33.0


From c485558f405a83e0cc1fec188999587b49ba67ce Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:28:21 +0300
Subject: [PATCH 011/125] winewayland.drv: Update Windows monitor information
 on Wayland changes.

Whenever the Wayland output display state changes (including during
initialization), update the monitor information on the Windows side to
reflect these changes.

We currently support a single GPU, and a single monitor for each
adapter.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   3 +-
 dlls/winewayland.drv/display.c        | 529 ++++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c        |   1 +
 dlls/winewayland.drv/wayland_output.c |   2 +
 dlls/winewayland.drv/waylanddrv.h     |   1 +
 5 files changed, 535 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/display.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f1e1d1cc655..cc7ff17dd5f 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = user32
+IMPORTS   = advapi32 rpcrt4 setupapi user32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -10,6 +10,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
+	display.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..7c7909864e0
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,529 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+#include "rpc.h"
+#include "winreg.h"
+#include "initguid.h"
+#include "devguid.h"
+#include "devpkey.h"
+#include "setupapi.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+DEFINE_DEVPROPKEY(DEVPROPKEY_GPU_LUID, 0x60b193cb, 0x5276, 0x4d0f, 0x96, 0xfc, 0xf1, 0x73, 0xab, 0xad, 0x3e, 0xc6, 2);
+DEFINE_DEVPROPKEY(DEVPROPKEY_MONITOR_GPU_LUID, 0xca085853, 0x16ce, 0x48aa, 0xb1, 0x14, 0xde, 0x9c, 0x72, 0x33, 0x42, 0x23, 1);
+DEFINE_DEVPROPKEY(DEVPROPKEY_MONITOR_OUTPUT_ID, 0xca085853, 0x16ce, 0x48aa, 0xb1, 0x14, 0xde, 0x9c, 0x72, 0x33, 0x42, 0x23, 2);
+
+/* Wine specific properties */
+DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_GPU_VULKAN_UUID, 0x233a9ef3, 0xafc4, 0x4abd, 0xb5, 0x64, 0xc3, 0x2f, 0x21, 0xf1, 0x53, 0x5c, 2);
+DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_MONITOR_STATEFLAGS, 0x233a9ef3, 0xafc4, 0x4abd, 0xb5, 0x64, 0xc3, 0x2f, 0x21, 0xf1, 0x53, 0x5b, 2);
+DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_MONITOR_RCMONITOR, 0x233a9ef3, 0xafc4, 0x4abd, 0xb5, 0x64, 0xc3, 0x2f, 0x21, 0xf1, 0x53, 0x5b, 3);
+DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_MONITOR_RCWORK, 0x233a9ef3, 0xafc4, 0x4abd, 0xb5, 0x64, 0xc3, 0x2f, 0x21, 0xf1, 0x53, 0x5b, 4);
+DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_MONITOR_ADAPTERNAME, 0x233a9ef3, 0xafc4, 0x4abd, 0xb5, 0x64, 0xc3, 0x2f, 0x21, 0xf1, 0x53, 0x5b, 5);
+
+static const WCHAR driver_date_dataW[] = {'D','r','i','v','e','r','D','a','t','e','D','a','t','a',0};
+static const WCHAR driver_descW[] = {'D','r','i','v','e','r','D','e','s','c',0};
+static const WCHAR displayW[] = {'D','I','S','P','L','A','Y',0};
+static const WCHAR pciW[] = {'P','C','I',0};
+static const WCHAR video_idW[] = {'V','i','d','e','o','I','D',0};
+static const WCHAR symbolic_link_valueW[]= {'S','y','m','b','o','l','i','c','L','i','n','k','V','a','l','u','e',0};
+static const WCHAR gpu_idW[] = {'G','P','U','I','D',0};
+static const WCHAR mointor_id_fmtW[] = {'M','o','n','i','t','o','r','I','D','%','d',0};
+static const WCHAR adapter_name_fmtW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0};
+static const WCHAR state_flagsW[] = {'S','t','a','t','e','F','l','a','g','s',0};
+static const WCHAR guid_fmtW[] = {
+    '{','%','0','8','x','-','%','0','4','x','-','%','0','4','x','-','%','0','2','x','%','0','2','x','-',
+    '%','0','2','x','%','0','2','x','%','0','2','x','%','0','2','x','%','0','2','x','%','0','2','x','}',0};
+static const WCHAR gpu_instance_fmtW[] = {
+    'P','C','I','\\',
+    'V','E','N','_','%','0','4','X','&',
+    'D','E','V','_','%','0','4','X','&',
+    'S','U','B','S','Y','S','_','%','0','8','X','&',
+    'R','E','V','_','%','0','2','X','\\',
+    '%','0','8','X',0};
+static const WCHAR gpu_hardware_id_fmtW[] = {
+    'P','C','I','\\',
+    'V','E','N','_','%','0','4','X','&',
+    'D','E','V','_','%','0','4','X','&',
+    'S','U','B','S','Y','S','_','0','0','0','0','0','0','0','0','&',
+    'R','E','V','_','0','0',0};
+static const WCHAR video_keyW[] = {
+    'H','A','R','D','W','A','R','E','\\',
+    'D','E','V','I','C','E','M','A','P','\\',
+    'V','I','D','E','O',0};
+static const WCHAR adapter_key_fmtW[] = {
+    'S','y','s','t','e','m','\\',
+    'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+    'C','o','n','t','r','o','l','\\',
+    'V','i','d','e','o','\\',
+    '%','s','\\',
+    '%','0','4','x',0};
+static const WCHAR device_video_fmtW[] = {
+    '\\','D','e','v','i','c','e','\\',
+    'V','i','d','e','o','%','d',0};
+static const WCHAR machine_prefixW[] = {
+    '\\','R','e','g','i','s','t','r','y','\\',
+    'M','a','c','h','i','n','e','\\',0};
+static const WCHAR nt_classW[] = {
+    '\\','R','e','g','i','s','t','r','y','\\',
+    'M','a','c','h','i','n','e','\\',
+    'S','y','s','t','e','m','\\',
+    'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+    'C','o','n','t','r','o','l','\\',
+    'C','l','a','s','s','\\',0};
+static const WCHAR monitor_instance_fmtW[] = {
+    'D','I','S','P','L','A','Y','\\',
+    'D','e','f','a','u','l','t','_','M','o','n','i','t','o','r','\\',
+    '%','0','4','X','&','%','0','4','X',0};
+static const WCHAR monitor_hardware_idW[] = {
+    'M','O','N','I','T','O','R','\\',
+    'D','e','f','a','u','l','t','_','M','o','n','i','t','o','r',0,0};
+
+/* Represent a physical GPU in the PCI slots */
+struct waylanddrv_gpu
+{
+    /* ID to uniquely identify a GPU in handler */
+    ULONG_PTR id;
+    /* Name */
+    WCHAR name[128];
+    /* PCI ID */
+    UINT vendor_id;
+    UINT device_id;
+    UINT subsys_id;
+    UINT revision_id;
+    /* Vulkan device UUID */
+    GUID vulkan_uuid;
+};
+
+HANDLE acquire_display_devices_init_mutex(void)
+{
+    static const WCHAR init_mutexW[] = {'d','i','s','p','l','a','y','_','d','e','v','i','c','e','_','i','n','i','t',0};
+    HANDLE mutex = CreateMutexW(NULL, FALSE, init_mutexW);
+
+    WaitForSingleObject(mutex, INFINITE);
+    return mutex;
+}
+
+void release_display_devices_init_mutex(HANDLE mutex)
+{
+    ReleaseMutex(mutex);
+    CloseHandle(mutex);
+}
+
+/* Initialize a GPU instance.
+ * Return its GUID string in guid_string, driver value in driver parameter and LUID in gpu_luid */
+static BOOL wayland_init_gpu(HDEVINFO devinfo, const struct waylanddrv_gpu *gpu, INT gpu_index, WCHAR *guid_string,
+                             WCHAR *driver, LUID *gpu_luid)
+{
+    static const BOOL present = TRUE;
+    SP_DEVINFO_DATA device_data = {sizeof(device_data)};
+    WCHAR instanceW[MAX_PATH];
+    DEVPROPTYPE property_type;
+    WCHAR bufferW[1024];
+    HKEY hkey = NULL;
+    GUID guid;
+    LUID luid;
+    INT written;
+    DWORD size;
+    BOOL ret = FALSE;
+    FILETIME filetime;
+
+    TRACE("GPU id:0x%s name:%s.\n", wine_dbgstr_longlong(gpu->id), wine_dbgstr_w(gpu->name));
+
+    sprintfW(instanceW, gpu_instance_fmtW, gpu->vendor_id, gpu->device_id, gpu->subsys_id, gpu->revision_id, gpu_index);
+    if (!SetupDiOpenDeviceInfoW(devinfo, instanceW, NULL, 0, &device_data))
+    {
+        SetupDiCreateDeviceInfoW(devinfo, instanceW, &GUID_DEVCLASS_DISPLAY, gpu->name, NULL, 0, &device_data);
+        if (!SetupDiRegisterDeviceInfo(devinfo, &device_data, 0, NULL, NULL, NULL))
+            goto done;
+    }
+
+    /* Write HardwareID registry property, REG_MULTI_SZ */
+    written = sprintfW(bufferW, gpu_hardware_id_fmtW, gpu->vendor_id, gpu->device_id);
+    bufferW[written + 1] = 0;
+    if (!SetupDiSetDeviceRegistryPropertyW(devinfo, &device_data, SPDRP_HARDWAREID, (const BYTE *)bufferW,
+                                           (written + 2) * sizeof(WCHAR)))
+        goto done;
+
+    /* Write DEVPKEY_Device_IsPresent property */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &DEVPKEY_Device_IsPresent, DEVPROP_TYPE_BOOLEAN,
+                                   (const BYTE *)&present, sizeof(present), 0))
+        goto done;
+
+    /* Write DEVPROPKEY_GPU_LUID property */
+    if (!SetupDiGetDevicePropertyW(devinfo, &device_data, &DEVPROPKEY_GPU_LUID, &property_type,
+                                   (BYTE *)&luid, sizeof(luid), NULL, 0))
+    {
+        if (!AllocateLocallyUniqueId(&luid))
+            goto done;
+
+        if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &DEVPROPKEY_GPU_LUID,
+                                       DEVPROP_TYPE_UINT64, (const BYTE *)&luid, sizeof(luid), 0))
+            goto done;
+    }
+    *gpu_luid = luid;
+    TRACE("LUID:%08x:%08x.\n", luid.HighPart, luid.LowPart);
+
+    /* Write WINE_DEVPROPKEY_GPU_VULKAN_UUID property */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &WINE_DEVPROPKEY_GPU_VULKAN_UUID,
+                                   DEVPROP_TYPE_GUID, (const BYTE *)&gpu->vulkan_uuid,
+                                   sizeof(gpu->vulkan_uuid), 0))
+        goto done;
+    TRACE("Vulkan UUID:%s.\n", wine_dbgstr_guid(&gpu->vulkan_uuid));
+
+    /* Open driver key.
+     * This is where HKLM\System\CurrentControlSet\Control\Video\{GPU GUID}\{Adapter Index} links to */
+    hkey = SetupDiCreateDevRegKeyW(devinfo, &device_data, DICS_FLAG_GLOBAL, 0, DIREG_DRV, NULL, NULL);
+
+    /* Write DriverDesc value */
+    if (RegSetValueExW(hkey, driver_descW, 0, REG_SZ, (const BYTE *)gpu->name,
+                       (strlenW(gpu->name) + 1) * sizeof(WCHAR)))
+        goto done;
+    /* Write DriverDateData value, using current time as driver date, needed by Evoland */
+    GetSystemTimeAsFileTime(&filetime);
+    if (RegSetValueExW(hkey, driver_date_dataW, 0, REG_BINARY, (BYTE *)&filetime, sizeof(filetime)))
+        goto done;
+
+    RegCloseKey(hkey);
+
+    /* Retrieve driver value for adapters */
+    if (!SetupDiGetDeviceRegistryPropertyW(devinfo, &device_data, SPDRP_DRIVER, NULL, (BYTE *)bufferW, sizeof(bufferW),
+                                           NULL))
+        goto done;
+    lstrcpyW(driver, nt_classW);
+    lstrcatW(driver, bufferW);
+
+    /* Write GUID in VideoID in .../instance/Device Parameters, reuse the GUID if it's existent */
+    hkey = SetupDiCreateDevRegKeyW(devinfo, &device_data, DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL);
+
+    size = sizeof(bufferW);
+    if (RegQueryValueExW(hkey, video_idW, 0, NULL, (BYTE *)bufferW, &size))
+    {
+        UuidCreate(&guid);
+        sprintfW(bufferW, guid_fmtW, guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], guid.Data4[2],
+                 guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
+        if (RegSetValueExW(hkey, video_idW, 0, REG_SZ, (const BYTE *)bufferW, (strlenW(bufferW) + 1) * sizeof(WCHAR)))
+            goto done;
+    }
+    lstrcpyW(guid_string, bufferW);
+
+    ret = TRUE;
+done:
+    RegCloseKey(hkey);
+    if (!ret)
+        ERR("Failed to initialize GPU\n");
+    return ret;
+}
+
+static BOOL wayland_init_adapter(HKEY video_hkey, INT video_index, INT gpu_index,
+                                 INT adapter_index, INT monitor_count,
+                                 const struct waylanddrv_gpu *gpu, const WCHAR *guid_string,
+                                 const WCHAR *gpu_driver)
+{
+    WCHAR adapter_keyW[MAX_PATH];
+    WCHAR key_nameW[MAX_PATH];
+    WCHAR bufferW[1024];
+    HKEY hkey = NULL;
+    BOOL ret = FALSE;
+    LSTATUS ls;
+    INT i;
+    DWORD state_flags = adapter_index == 0 ? DISPLAY_DEVICE_PRIMARY_DEVICE | DISPLAY_DEVICE_ATTACHED_TO_DESKTOP: 0;
+
+    sprintfW(key_nameW, device_video_fmtW, video_index);
+    lstrcpyW(bufferW, machine_prefixW);
+    sprintfW(adapter_keyW, adapter_key_fmtW, guid_string, adapter_index);
+    lstrcatW(bufferW, adapter_keyW);
+
+    /* Write value of \Device\Video? (adapter key) in HKLM\HARDWARE\DEVICEMAP\VIDEO\ */
+    if (RegSetValueExW(video_hkey, key_nameW, 0, REG_SZ, (const BYTE *)bufferW, (strlenW(bufferW) + 1) * sizeof(WCHAR)))
+        goto done;
+
+    /* Create HKLM\System\CurrentControlSet\Control\Video\{GPU GUID}\{Adapter Index} link to GPU driver */
+    ls = RegCreateKeyExW(HKEY_LOCAL_MACHINE, adapter_keyW, 0, NULL, REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
+                         KEY_ALL_ACCESS, NULL, &hkey, NULL);
+    if (ls == ERROR_ALREADY_EXISTS)
+        RegCreateKeyExW(HKEY_LOCAL_MACHINE, adapter_keyW, 0, NULL, REG_OPTION_VOLATILE | REG_OPTION_OPEN_LINK,
+                        KEY_ALL_ACCESS, NULL, &hkey, NULL);
+    if (RegSetValueExW(hkey, symbolic_link_valueW, 0, REG_LINK, (const BYTE *)gpu_driver,
+                       strlenW(gpu_driver) * sizeof(WCHAR)))
+        goto done;
+    RegCloseKey(hkey);
+    hkey = NULL;
+
+    /* FIXME:
+     * Following information is Wine specific, it doesn't really exist on Windows. It is used so that we can
+     * implement EnumDisplayDevices etc by querying registry only. This information is most likely reported by the
+     * device driver on Windows */
+    RegCreateKeyExW(HKEY_CURRENT_CONFIG, adapter_keyW, 0, NULL, REG_OPTION_VOLATILE, KEY_WRITE, NULL, &hkey, NULL);
+
+    /* Write GPU instance path so that we can find the GPU instance via adapters quickly. Another way is trying to match
+     * them via the GUID in Device Parameters/VideoID, but it would require enumerating all GPU instances */
+    sprintfW(bufferW, gpu_instance_fmtW, gpu->vendor_id, gpu->device_id, gpu->subsys_id, gpu->revision_id, gpu_index);
+    if (RegSetValueExW(hkey, gpu_idW, 0, REG_SZ, (const BYTE *)bufferW, (strlenW(bufferW) + 1) * sizeof(WCHAR)))
+        goto done;
+
+    /* Write all monitor instances paths under this adapter */
+    for (i = 0; i < monitor_count; i++)
+    {
+        sprintfW(key_nameW, mointor_id_fmtW, i);
+        sprintfW(bufferW, monitor_instance_fmtW, video_index, i);
+        if (RegSetValueExW(hkey, key_nameW, 0, REG_SZ, (const BYTE *)bufferW, (strlenW(bufferW) + 1) * sizeof(WCHAR)))
+            goto done;
+    }
+
+    /* Write StateFlags */
+    if (RegSetValueExW(hkey, state_flagsW, 0, REG_DWORD, (const BYTE *)&state_flags,
+                        sizeof(state_flags)))
+        goto done;
+
+    ret = TRUE;
+done:
+    RegCloseKey(hkey);
+    if (!ret)
+        ERR("Failed to initialize adapter\n");
+    return ret;
+}
+
+static BOOL wayland_init_monitor(HDEVINFO devinfo, struct wayland_output *output,
+                                 int monitor_index, int video_index, const LUID *gpu_luid,
+                                 UINT output_id)
+{
+    SP_DEVINFO_DATA device_data = {sizeof(SP_DEVINFO_DATA)};
+    WCHAR bufferW[MAX_PATH];
+    WCHAR output_name[128];
+    DWORD length;
+    HKEY hkey;
+    BOOL ret = FALSE;
+    DWORD state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+    RECT rc_mode;
+
+    SetRect(&rc_mode, output->x, output->y,
+            output->x + output->current_mode->width,
+            output->y + output->current_mode->height);
+
+    if (!MultiByteToWideChar(CP_UTF8, 0, output->name, -1, output_name, ARRAY_SIZE(output_name)))
+        output_name[0] = 0;
+
+    /* Create GUID_DEVCLASS_MONITOR instance */
+    sprintfW(bufferW, monitor_instance_fmtW, video_index, monitor_index);
+    SetupDiCreateDeviceInfoW(devinfo, bufferW, &GUID_DEVCLASS_MONITOR, output_name, NULL, 0, &device_data);
+    if (!SetupDiRegisterDeviceInfo(devinfo, &device_data, 0, NULL, NULL, NULL))
+        goto done;
+
+    /* Write HardwareID registry property */
+    if (!SetupDiSetDeviceRegistryPropertyW(devinfo, &device_data, SPDRP_HARDWAREID,
+                                           (const BYTE *)monitor_hardware_idW, sizeof(monitor_hardware_idW)))
+        goto done;
+
+    /* Write DEVPROPKEY_MONITOR_GPU_LUID */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &DEVPROPKEY_MONITOR_GPU_LUID,
+                                   DEVPROP_TYPE_INT64, (const BYTE *)gpu_luid, sizeof(*gpu_luid), 0))
+        goto done;
+
+    /* Write DEVPROPKEY_MONITOR_OUTPUT_ID */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &DEVPROPKEY_MONITOR_OUTPUT_ID,
+                                   DEVPROP_TYPE_UINT32, (const BYTE *)&output_id, sizeof(output_id), 0))
+        goto done;
+
+    /* Create driver key */
+    hkey = SetupDiCreateDevRegKeyW(devinfo, &device_data, DICS_FLAG_GLOBAL, 0, DIREG_DRV, NULL, NULL);
+    RegCloseKey(hkey);
+
+    /* FIXME:
+     * Following properties are Wine specific, see comments in wayland_init_adapter for details */
+    /* StateFlags */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &WINE_DEVPROPKEY_MONITOR_STATEFLAGS, DEVPROP_TYPE_UINT32,
+                                   (const BYTE *)&state_flags, sizeof(state_flags), 0))
+       goto done;
+    /* RcMonitor */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &WINE_DEVPROPKEY_MONITOR_RCMONITOR, DEVPROP_TYPE_BINARY,
+                                   (const BYTE *)&rc_mode, sizeof(rc_mode), 0))
+        goto done;
+    /* RcWork */
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &WINE_DEVPROPKEY_MONITOR_RCWORK, DEVPROP_TYPE_BINARY,
+                                   (const BYTE *)&rc_mode, sizeof(rc_mode), 0))
+        goto done;
+
+    /* Adapter name */
+    length = sprintfW(bufferW, adapter_name_fmtW, video_index + 1);
+    if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &WINE_DEVPROPKEY_MONITOR_ADAPTERNAME, DEVPROP_TYPE_STRING,
+                                   (const BYTE *)bufferW, (length + 1) * sizeof(WCHAR), 0))
+        goto done;
+
+    ret = TRUE;
+done:
+    if (!ret)
+        ERR("Failed to initialize monitor\n");
+    return ret;
+}
+
+static void prepare_devices(HKEY video_hkey)
+{
+    static const BOOL not_present = FALSE;
+    SP_DEVINFO_DATA device_data = {sizeof(device_data)};
+    HDEVINFO devinfo;
+    DWORD i = 0;
+
+    /* Remove all monitors */
+    devinfo = SetupDiGetClassDevsW(&GUID_DEVCLASS_MONITOR, displayW, NULL, 0);
+    while (SetupDiEnumDeviceInfo(devinfo, i++, &device_data))
+    {
+        if (!SetupDiRemoveDevice(devinfo, &device_data))
+            ERR("Failed to remove monitor\n");
+    }
+    SetupDiDestroyDeviceInfoList(devinfo);
+
+    /* Clean up old adapter keys for reinitialization */
+    RegDeleteTreeW(video_hkey, NULL);
+
+    /* FIXME:
+     * Currently SetupDiGetClassDevsW with DIGCF_PRESENT is unsupported, So we need to clean up not present devices in
+     * case application uses SetupDiGetClassDevsW to enumerate devices. Wrong devices could exist in registry as a result
+     * of prefix copying or having devices unplugged. But then we couldn't simply delete GPUs because we need to retain
+     * the same GUID for the same GPU. */
+    i = 0;
+    devinfo = SetupDiGetClassDevsW(&GUID_DEVCLASS_DISPLAY, pciW, NULL, 0);
+    while (SetupDiEnumDeviceInfo(devinfo, i++, &device_data))
+    {
+        if (!SetupDiSetDevicePropertyW(devinfo, &device_data, &DEVPKEY_Device_IsPresent, DEVPROP_TYPE_BOOLEAN,
+                                       (const BYTE *)&not_present, sizeof(not_present), 0))
+            ERR("Failed to set GPU present property\n");
+    }
+    SetupDiDestroyDeviceInfoList(devinfo);
+}
+
+static void cleanup_devices(void)
+{
+    SP_DEVINFO_DATA device_data = {sizeof(device_data)};
+    HDEVINFO devinfo;
+    DWORD type;
+    DWORD i = 0;
+    BOOL present;
+
+    devinfo = SetupDiGetClassDevsW(&GUID_DEVCLASS_DISPLAY, pciW, NULL, 0);
+    while (SetupDiEnumDeviceInfo(devinfo, i++, &device_data))
+    {
+        present = FALSE;
+        SetupDiGetDevicePropertyW(devinfo, &device_data, &DEVPKEY_Device_IsPresent, &type, (BYTE *)&present,
+                                  sizeof(present), NULL, 0);
+        if (!present && !SetupDiRemoveDevice(devinfo, &device_data))
+            ERR("Failed to remove GPU\n");
+    }
+    SetupDiDestroyDeviceInfoList(devinfo);
+}
+
+static void wayland_init_display_devices_internal(struct wayland *wayland, BOOL force_send_change)
+{
+    HANDLE mutex;
+    HDEVINFO gpu_devinfo = NULL, monitor_devinfo = NULL;
+    HKEY video_hkey = NULL;
+    INT gpu_index = 0;
+    INT output_index = 0;
+    DWORD disposition = 0;
+    WCHAR gpu_guidW[40];
+    WCHAR driverW[1024];
+    LUID gpu_luid;
+    UINT output_id = 0;
+    struct wayland_output *output;
+    struct waylanddrv_gpu gpu = { 0 };
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    mutex = acquire_display_devices_init_mutex();
+
+    if (RegCreateKeyExW(HKEY_LOCAL_MACHINE, video_keyW, 0, NULL, REG_OPTION_VOLATILE,
+                        KEY_ALL_ACCESS, NULL, &video_hkey,
+                        &disposition))
+    {
+        ERR("Failed to create video device key\n");
+        goto done;
+    }
+
+    prepare_devices(video_hkey);
+
+    gpu_devinfo = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_DISPLAY, NULL);
+    monitor_devinfo = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_MONITOR, NULL);
+
+    /* TODO: Support multiple GPUs. Note that wayland doesn't currently expose GPU info. */
+    if (!wayland_init_gpu(gpu_devinfo, &gpu, gpu_index, gpu_guidW, driverW, &gpu_luid))
+        goto done;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_mode) continue;
+
+        /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+        if (!wayland_init_adapter(video_hkey, output_index, gpu_index, output_index, 1,
+                                  &gpu, gpu_guidW, driverW))
+            goto done;
+
+        if (!wayland_init_monitor(monitor_devinfo, output, output_index, output_index,
+                                  &gpu_luid, output_id++))
+            goto done;
+
+        output_index++;
+    }
+
+done:
+    cleanup_devices();
+    SetupDiDestroyDeviceInfoList(monitor_devinfo);
+    SetupDiDestroyDeviceInfoList(gpu_devinfo);
+    RegCloseKey(video_hkey);
+    release_display_devices_init_mutex(mutex);
+
+    /* During thread wayland initialization we will get our initial output
+     * information and init the display devices. There is no need to send out
+     * WM_DISPLAYCHANGE in this case, since this is the initial display state.
+     * Additionally, thread initialization may occur in a context that has
+     * acquired the internal Wine user32 lock, and sending messages would lead
+     * to an internal user32 lock error. */
+    if (wayland->initialized &&
+        (force_send_change ||
+         GetCurrentThreadId() == GetWindowThreadProcessId(GetDesktopWindow(), NULL)))
+    {
+        /* The first valid output is the primary. */
+        wl_list_for_each(output, &wayland->output_list, link)
+        {
+            if (!output->current_mode) continue;
+
+            SendMessageTimeoutW(HWND_BROADCAST, WM_DISPLAYCHANGE, 32,
+                                MAKELPARAM(output->current_mode->width,
+                                           output->current_mode->height),
+                                SMTO_ABORTIFHUNG, 2000, NULL);
+            break;
+        }
+    }
+}
+
+void wayland_init_display_devices(struct wayland *wayland)
+{
+    wayland_init_display_devices_internal(wayland, FALSE);
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f2d2063d059..817569766cb 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -79,6 +79,7 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
         {
             TRACE("removing output->name=%s\n", output->name);
             wayland_output_destroy(output);
+            wayland_init_display_devices(wayland);
             return;
         }
     }
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 4f7ce760ed2..010081db8f7 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -261,6 +261,8 @@ static void wayland_output_done(struct wayland_output *output)
               o->logical_x, output->logical_y, o->logical_w, o->logical_h,
               o->x, o->y, o->current_mode->width, o->current_mode->height);
     }
+
+    wayland_init_display_devices(output->wayland);
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 99db87cf44b..74a784b5ae8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -105,6 +105,7 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
 BOOL wayland_process_init(void);
 BOOL wayland_init(struct wayland *wayland);
 void wayland_deinit(struct wayland *wayland);
+void wayland_init_display_devices(struct wayland *wayland);
 
 /**********************************************************************
  *          Wayland output
-- 
2.33.0


From 7fd9a9bd4db2cfe80b5a19193bd7141299478116 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:34:01 +0300
Subject: [PATCH 012/125] winewayland.drv: Implement EnumDisplaySettingsEx.

Implement EnumDisplaySettingsEx by using the Wayland display output
information stored in the current thread. Since there is no guarantee
that EnumDisplaySettingsEx is going to be called in full initialized
GUI thread, thread that we force initialization of Wayland thread data
on function entry.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c            | 207 ++++++++++++++++++++++
 dlls/winewayland.drv/wayland_output.c     |  20 +++
 dlls/winewayland.drv/waylanddrv.h         |   8 +
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 4 files changed, 236 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 7c7909864e0..0232cfeceb1 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -492,6 +492,16 @@ static void wayland_init_display_devices_internal(struct wayland *wayland, BOOL
         output_index++;
     }
 
+    /* Set wine name in wayland_output so that we can look it up. */
+    output_index = 0;
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        snprintfW(output->wine_name, ARRAY_SIZE(output->wine_name),
+                  adapter_name_fmtW, output_index + 1);
+        TRACE("name=%s wine_name=%s\n", output->name, wine_dbgstr_w(output->wine_name));
+        output_index++;
+    }
+
 done:
     cleanup_devices();
     SetupDiDestroyDeviceInfoList(monitor_devinfo);
@@ -527,3 +537,200 @@ void wayland_init_display_devices(struct wayland *wayland)
 {
     wayland_init_display_devices_internal(wayland, FALSE);
 }
+
+static BOOL get_display_device_reg_key(const WCHAR *device_name, WCHAR *key, unsigned len)
+{
+    static const WCHAR display[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    static const WCHAR video_value_fmt[] = {'\\','D','e','v','i','c','e','\\',
+                                            'V','i','d','e','o','%','d',0};
+    static const WCHAR video_key[] = {'H','A','R','D','W','A','R','E','\\',
+                                      'D','E','V','I','C','E','M','A','P','\\',
+                                      'V','I','D','E','O','\\',0};
+    WCHAR value_name[MAX_PATH], buffer[MAX_PATH], *end_ptr;
+    DWORD adapter_index, size;
+
+    /* Device name has to be \\.\DISPLAY%d */
+    if (strncmpiW(device_name, display, ARRAY_SIZE(display)))
+        return FALSE;
+
+    /* Parse \\.\DISPLAY* */
+    adapter_index = strtolW(device_name + ARRAY_SIZE(display), &end_ptr, 10) - 1;
+    if (*end_ptr)
+        return FALSE;
+
+    /* Open \Device\Video* in HKLM\HARDWARE\DEVICEMAP\VIDEO\ */
+    sprintfW(value_name, video_value_fmt, adapter_index);
+    size = sizeof(buffer);
+    if (RegGetValueW(HKEY_LOCAL_MACHINE, video_key, value_name, RRF_RT_REG_SZ, NULL, buffer, &size))
+        return FALSE;
+
+    if (len < lstrlenW(buffer + 18) + 1)
+        return FALSE;
+
+    /* Skip \Registry\Machine\ prefix */
+    lstrcpyW(key, buffer + 18);
+    TRACE("display device %s registry settings key %s.\n", wine_dbgstr_w(device_name), wine_dbgstr_w(key));
+    return TRUE;
+}
+
+static BOOL read_registry_settings(const WCHAR *device_name, DEVMODEW *dm)
+{
+    WCHAR display_device_reg_key[MAX_PATH];
+    HANDLE mutex;
+    HKEY hkey;
+    DWORD type, size;
+    BOOL ret = TRUE;
+
+    dm->dmFields = 0;
+
+    mutex = acquire_display_devices_init_mutex();
+    if (!get_display_device_reg_key(device_name, display_device_reg_key,
+                                    ARRAY_SIZE(display_device_reg_key)))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+    if (RegOpenKeyExW(HKEY_CURRENT_CONFIG, display_device_reg_key, 0, KEY_READ, &hkey))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+#define query_value(name, data) \
+    size = sizeof(DWORD); \
+    if (RegQueryValueExA(hkey, name, 0, &type, (LPBYTE)(data), &size) || \
+        type != REG_DWORD || size != sizeof(DWORD)) \
+        ret = FALSE
+
+    query_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    dm->dmFields |= DM_BITSPERPEL;
+    query_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    dm->dmFields |= DM_PELSWIDTH;
+    query_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    dm->dmFields |= DM_PELSHEIGHT;
+    query_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    dm->dmFields |= DM_DISPLAYFREQUENCY;
+    query_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    dm->dmFields |= DM_DISPLAYFLAGS;
+    query_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    query_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    dm->dmFields |= DM_POSITION;
+    query_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    dm->dmFields |= DM_DISPLAYORIENTATION;
+    query_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef query_value
+
+    RegCloseKey(hkey);
+
+done:
+    release_display_devices_init_mutex(mutex);
+    return ret;
+}
+
+static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
+{
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY | DM_POSITION;
+    mode->u1.s2.dmDisplayOrientation = DMDO_DEFAULT;
+    mode->u2.dmDisplayFlags = 0;
+    mode->u1.s2.dmPosition.x = 0;
+    mode->u1.s2.dmPosition.y = 0;
+    mode->dmBitsPerPel = output_mode->bpp;
+    mode->dmPelsWidth = output_mode->width;
+    mode->dmPelsHeight = output_mode->height;
+    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+}
+
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_mode)
+        return FALSE;
+
+    populate_devmode(output->current_mode, mode);
+
+    return TRUE;
+}
+
+static BOOL wayland_get_devmode(struct wayland *wayland, LPCWSTR name, DWORD n, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+    DWORD i = 0;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (i == n)
+        {
+            populate_devmode(output_mode, mode);
+            return TRUE;
+        }
+        i++;
+    }
+
+    return FALSE;
+}
+
+
+/***********************************************************************
+ *		EnumDisplaySettingsEx  (WAYLAND.@)
+ *
+ */
+BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags)
+{
+    static const WCHAR dev_name[CCHDEVICENAME] =
+        {'W','i','n','e',' ','W','a','y','l','a','n','d',' ','d','r','i','v','e','r',0};
+    struct wayland *wayland = thread_init_wayland();
+
+    TRACE("(%s,%d,%p,0x%08x) wayland=%p\n", debugstr_w(name), n, devmode, flags, wayland);
+
+    if (n == ENUM_REGISTRY_SETTINGS)
+    {
+        if (!read_registry_settings(name, devmode) &&
+            !wayland_get_current_devmode(wayland, name, devmode))
+        {
+            ERR("Failed to get %s registry display settings and native mode.\n",
+                wine_dbgstr_w(name));
+            return FALSE;
+        }
+        goto done;
+    }
+
+    if (n == ENUM_CURRENT_SETTINGS)
+    {
+        if (!wayland_get_current_devmode(wayland, name, devmode))
+        {
+            ERR("Failed to get %s current display settings.\n", wine_dbgstr_w(name));
+            return FALSE;
+        }
+        goto done;
+    }
+
+    if (!wayland_get_devmode(wayland, name, n, devmode))
+    {
+        ERR("Modes index out of range\n");
+        SetLastError(ERROR_NO_MORE_FILES);
+        return FALSE;
+    }
+
+done:
+    TRACE("=> %dx%d\n", devmode->dmPelsWidth, devmode->dmPelsHeight);
+    /* Set generic fields */
+    devmode->dmSize = FIELD_OFFSET(DEVMODEW, dmICMMethod);
+    devmode->dmDriverExtra = 0;
+    devmode->dmSpecVersion = DM_SPECVERSION;
+    devmode->dmDriverVersion = DM_SPECVERSION;
+    lstrcpyW(devmode->dmDeviceName, dev_name);
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 010081db8f7..087f7f9a5f6 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -448,3 +448,23 @@ void wayland_output_use_xdg_extension(struct wayland_output *output)
     zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
                                 output);
 }
+
+/**********************************************************************
+ *          wayland_output_get_by_wine_name
+ *
+ *  Returns the wayland_output with the specified Wine name (or NULL
+ *  if not present).
+ */
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!lstrcmpiW(wine_name, output->wine_name))
+            return output;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 74a784b5ae8..95e4b5dcda0 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -75,6 +75,7 @@ struct wayland_output
     int x, y;  /* position in native pixel coordinate space */
     int scale; /* wayland output scale factor for hidpi */
     char *name;
+    WCHAR wine_name[128];
     uint32_t global_id;
 };
 
@@ -98,6 +99,11 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
     return data;
 }
 
+static inline struct wayland *thread_init_wayland(void)
+{
+    return &wayland_init_thread_data()->wayland;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
@@ -114,5 +120,7 @@ void wayland_init_display_devices(struct wayland *wayland);
 BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version);
 void wayland_output_destroy(struct wayland_output *output);
 void wayland_output_use_xdg_extension(struct wayland_output *output);
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name);
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 9528d7bc6ef..56e9e5038d6 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -1,4 +1,5 @@
 # USER driver
 
 @ cdecl CreateWindow(long) WAYLAND_CreateWindow
+@ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From 96029913209c9fa6ed73033cc258149912cdb90c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:22:13 +0300
Subject: [PATCH 013/125] winewayland.drv: Introduce private driver window data
 structure.

Introduce a private driver window data structure and use it to keep
track of some basic window data. Access to the information is protected
for multithreaded access.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c             | 144 +++++++++++++++++++++-
 dlls/winewayland.drv/winewayland.drv.spec |   2 +
 2 files changed, 144 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 66e5c632ed8..ff194ce5c69 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -25,12 +25,113 @@
 
 #include "waylanddrv.h"
 
-#include "wine/debug.h"
-
+#include "wingdi.h"
 #include "winuser.h"
 
+#include "wine/debug.h"
+#include "wine/gdi_driver.h"
+#include "wine/heap.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* private window data */
+struct wayland_win_data
+{
+    /* hwnd that this private data belongs to */
+    HWND           hwnd;
+    /* parent hwnd for child windows */
+    HWND           parent;
+    /* USER window rectangle relative to parent */
+    RECT           window_rect;
+    /* client area relative to parent */
+    RECT           client_rect;
+};
+
+static CRITICAL_SECTION win_data_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &win_data_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": win_data_section") }
+};
+static CRITICAL_SECTION win_data_section = {&critsect_debug, -1, 0, 0, 0, 0};
+
+static struct wayland_win_data *win_data_context[32768];
+
+static inline int context_idx(HWND hwnd)
+{
+    return LOWORD(hwnd) >> 1;
+}
+
+/***********************************************************************
+ *           wayland_win_data_destroy
+ */
+static void wayland_win_data_destroy(struct wayland_win_data *data)
+{
+    TRACE("hwnd=%p\n", data->hwnd);
+    win_data_context[context_idx(data->hwnd)] = NULL;
+
+    heap_free(data);
+
+    LeaveCriticalSection(&win_data_section);
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+static struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    if (!hwnd) return NULL;
+
+    EnterCriticalSection(&win_data_section);
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data;
+    LeaveCriticalSection(&win_data_section);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_release
+ *
+ * Release the data returned by wayland_win_data_get.
+ */
+static void wayland_win_data_release(struct wayland_win_data *data)
+{
+    if (data) LeaveCriticalSection(&win_data_section);
+}
+
+/***********************************************************************
+ *           wayland_win_data_create
+ *
+ * Create a data window structure for an existing window.
+ */
+static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    HWND parent;
+
+    /* Don't create win data for desktop or HWND_MESSAGE windows. */
+    if (!(parent = GetAncestor(hwnd, GA_PARENT))) return NULL;
+    if (parent != GetDesktopWindow() && !GetAncestor(parent, GA_PARENT)) return NULL;
+
+    if (!(data = heap_alloc_zero(sizeof(*data))))
+        return NULL;
+
+    data->hwnd = hwnd;
+
+    EnterCriticalSection(&win_data_section);
+    win_data_context[context_idx(hwnd)] = data;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    return data;
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -47,3 +148,42 @@ BOOL CDECL WAYLAND_CreateWindow(HWND hwnd)
 
     return TRUE;
 }
+
+/***********************************************************************
+ *           WAYLAND_DestroyWindow
+ */
+void CDECL WAYLAND_DestroyWindow(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    TRACE("%p\n", hwnd);
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_win_data_destroy(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanging
+ */
+BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                     const RECT *window_rect, const RECT *client_rect,
+                                     RECT *visible_rect, struct window_surface **surface)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    BOOL exstyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
+    DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
+    HWND parent = GetAncestor(hwnd, GA_PARENT);
+
+    TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), style, exstyle, swp_flags, insert_after);
+
+    if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
+
+    data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
+    data->window_rect = *window_rect;
+    data->client_rect = *client_rect;
+
+    wayland_win_data_release(data);
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 56e9e5038d6..40cfc9ba432 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -1,5 +1,7 @@
 # USER driver
 
 @ cdecl CreateWindow(long) WAYLAND_CreateWindow
+@ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
+@ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
-- 
2.33.0


From c95a956d82c1d3741ef5749a03e2fc96b72b8a0c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 17:11:53 +0300
Subject: [PATCH 014/125] winewayland.drv: Support dispatch Wayland buffer
 events independently.

Introduce a mechanism to dispatch Wayland buffer events, using a
separate per-thread Wayland event queue. We need this since buffer
events (e.g., buffer releases) may need to be manually dispatched in
contexts where it's unsafe to dispatch other events (e.g., in threads
other than the Wayland owner thread).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 29 +++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  7 +++++++
 2 files changed, 36 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 817569766cb..8a35624ea58 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -115,6 +115,12 @@ BOOL wayland_init(struct wayland *wayland)
         return FALSE;
     }
 
+    if (!(wayland->buffer_wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create buffer event queue\n");
+        return FALSE;
+    }
+
     if (!(wayland->wl_registry = wl_display_get_registry(wayland->wl_display)))
     {
         ERR("Failed to get to wayland registry\n");
@@ -165,6 +171,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_event_queue)
         wl_event_queue_destroy(wayland->wl_event_queue);
 
+    if (wayland->buffer_wl_event_queue)
+    {
+        wl_event_queue_destroy(wayland->buffer_wl_event_queue);
+        wayland->buffer_wl_event_queue = NULL;
+    }
+
     wl_display_flush(wayland->wl_display);
 
     memset(wayland, 0, sizeof(*wayland));
@@ -181,3 +193,20 @@ BOOL wayland_process_init(void)
     process_wl_display = wl_display_connect(NULL);
     return process_wl_display != NULL;
 }
+
+/**********************************************************************
+ *          wayland_dispatch_buffer
+ *
+ * Dispatch buffer related events for the specified wayland instance.
+ *
+ * Returns the number of events dispatched.
+ */
+int wayland_dispatch_buffer(struct wayland *wayland)
+{
+    TRACE("wayland=%p buffer_queue=%p\n", wayland, wayland->buffer_wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->buffer_wl_event_queue);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 95e4b5dcda0..1df554c5d43 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -45,6 +45,7 @@ struct wayland
     DWORD thread_id;
     struct wl_display *wl_display;
     struct wl_event_queue *wl_event_queue;
+    struct wl_event_queue *buffer_wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
@@ -123,4 +124,10 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name);
 
+/**********************************************************************
+ *          Wayland event dispatch
+ */
+
+int wayland_dispatch_buffer(struct wayland *wayland);
+
 #endif /* __WINE_WAYLANDDRV_H */
-- 
2.33.0


From 0335608062946af1503998521199f601633d05ef Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:56:28 +0300
Subject: [PATCH 015/125] winewayland.drv: Add infrastructure for Wayland SHM
 buffers.

Add the infrastructure and functions needed to manage Wayland SHM (i.e.,
software) buffers and their damage tracking.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in   |   3 +-
 dlls/winewayland.drv/wayland.c     |   7 +
 dlls/winewayland.drv/wayland_shm.c | 248 +++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h  |  27 ++++
 4 files changed, 284 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_shm.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index cc7ff17dd5f..c1ee074e7bd 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = advapi32 rpcrt4 setupapi user32
+IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -14,6 +14,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
+	wayland_shm.c \
 	window.c \
 
 WAYLAND_PROTOCOL_SRCS = \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 8a35624ea58..c14c4d57714 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -46,6 +46,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
     else if (strcmp(interface, "wl_output") == 0)
     {
         if (!wayland_output_create(wayland, id, version))
@@ -159,6 +163,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    if (wayland->wl_shm)
+        wl_shm_destroy(wayland->wl_shm);
+
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
new file mode 100644
index 00000000000..3d2e6e38f2c
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -0,0 +1,248 @@
+/*
+ * Wayland SHM buffers
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+/* For memfd_create */
+#define _GNU_SOURCE
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <sys/mman.h>
+
+#include "waylanddrv.h"
+#include "wine/heap.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static int fd_resize(int fd, off_t size)
+{
+    /*
+     * Filesystems that do support fallocate will return EINVAL or
+     * EOPNOTSUPP. In this case we need to fall back to ftruncate
+     */
+    errno = posix_fallocate(fd, 0, size);
+    if (errno == 0)
+        return 0;
+    else if (errno != EINVAL && errno != EOPNOTSUPP)
+        return -1;
+    if (ftruncate(fd, size) < 0)
+        return -1;
+
+    return 0;
+}
+
+static int shm_fd_create(off_t size)
+{
+    int fd;
+
+    fd = memfd_create("wayland-shm", MFD_CLOEXEC | MFD_ALLOW_SEALING);
+    if (fd >= 0)
+    {
+        /* We can add this seal before calling posix_fallocate(), as
+         * the file is currently zero-sized anyway.
+         *
+         * There is also no need to check for the return value, we
+         * couldn't do anything with it anyway.
+         */
+        fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_SEAL);
+    }
+
+    while (TRUE)
+    {
+        int ret = fd_resize(fd, size);
+        if (ret == 0) break;
+        if (ret < 0 && errno == EINTR) continue;
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_create
+ *
+ * Creates a SHM buffer with the specified width, height and format.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format)
+{
+    struct wayland_shm_buffer *shm_buffer;
+    struct wl_shm_pool *pool;
+    int fd = -1, size, stride;
+    void *data;
+
+    shm_buffer = heap_alloc_zero(sizeof(*shm_buffer));
+    if (!shm_buffer)
+        goto err;
+
+    wl_list_init(&shm_buffer->link);
+
+    assert(format == WL_SHM_FORMAT_ARGB8888 || format == WL_SHM_FORMAT_XRGB8888);
+
+    stride = width * 4;
+    size = stride * height;
+
+    TRACE("%p %dx%d format=%d size=%d\n", shm_buffer, width, height, format, size);
+
+    if (size == 0)
+        return shm_buffer;
+
+    fd = shm_fd_create(size);
+    if (fd < 0)
+    {
+        ERR("creating a buffer fd size %d failed: %s\n", size, strerror(errno));
+        goto err;
+    }
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("mmap failed: %s size=%d\n", strerror(errno), size);
+        goto err;
+    }
+
+    pool = wl_shm_create_pool(wayland->wl_shm, fd, size);
+    shm_buffer->wl_buffer = wl_shm_pool_create_buffer(pool, 0, width, height,
+                                                      stride, format);
+    wl_shm_pool_destroy(pool);
+    close(fd);
+    fd = -1;
+
+    /* Buffer events go to their own queue so that we can dispatch them
+     * independently. */
+    wl_proxy_set_queue((struct wl_proxy *) shm_buffer->wl_buffer,
+                       wayland->buffer_wl_event_queue);
+
+    shm_buffer->width = width;
+    shm_buffer->height = height;
+    shm_buffer->stride = stride;
+    shm_buffer->format = format;
+    shm_buffer->map_data = data;
+    shm_buffer->map_size = size;
+    shm_buffer->damage_region = CreateRectRgn(0, 0, 0, 0);
+    if (!shm_buffer->damage_region)
+    {
+        ERR("failed to create buffer damage region\n");
+        goto err;
+    }
+
+    TRACE("%p %dx%d size=%d => map=%p\n", shm_buffer, width, height, size, data);
+
+    return shm_buffer;
+
+err:
+    if (fd >= 0)
+        close(fd);
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_destroy
+ *
+ * Destroys a SHM buffer.
+ */
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    TRACE("%p map=%p\n", shm_buffer, shm_buffer->map_data);
+
+    wl_list_remove(&shm_buffer->link);
+
+    if (shm_buffer->wl_buffer)
+        wl_buffer_destroy(shm_buffer->wl_buffer);
+    if (shm_buffer->map_data)
+        munmap(shm_buffer->map_data, shm_buffer->map_size);
+    if (shm_buffer->damage_region)
+        DeleteObject(shm_buffer->damage_region);
+
+    heap_free(shm_buffer);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_clear_damage
+ *
+ *  Clears all damage accumulated by a SHM buffer.
+ */
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer)
+{
+    SetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_add_damage
+ *
+ *  Adds damage (i.e., a region which needs update) to a SHM buffer.
+ */
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage)
+{
+    CombineRgn(shm_buffer->damage_region, shm_buffer->damage_region, damage, RGN_OR);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_get_damage_clipped
+ *
+ * Returns the damage region data for this buffer clipped within the
+ * provided clip region (if any).
+ *
+ * The returned RGNDATA* should be freed by the caller.
+ */
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+    HRGN damage_region;
+
+    if (clip)
+    {
+        damage_region = CreateRectRgn(0, 0, 0, 0);
+        if (!damage_region) goto err;
+        CombineRgn(damage_region, shm_buffer->damage_region, clip, RGN_AND);
+    }
+    else
+    {
+        damage_region = shm_buffer->damage_region;
+    }
+
+    if (!(size = GetRegionData( damage_region, 0, NULL ))) goto err;
+    if (!(data = heap_alloc_zero( size ))) goto err;
+    if (!GetRegionData( damage_region, size, data )) goto err;
+
+    if (damage_region != shm_buffer->damage_region)
+        DeleteObject(damage_region);
+
+    return data;
+
+err:
+    if (damage_region && damage_region != shm_buffer->damage_region)
+        DeleteObject(damage_region);
+    heap_free(data);
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1df554c5d43..316731c592d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,7 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h"
 
 extern struct wl_display *process_wl_display;
 
@@ -48,6 +49,7 @@ struct wayland
     struct wl_event_queue *buffer_wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -80,6 +82,18 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height, stride;
+    enum wl_shm_format format;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    HRGN damage_region;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -130,4 +144,17 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_buffer(struct wayland *wayland);
 
+/**********************************************************************
+ *          Wayland SHM buffer
+ */
+
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format);
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer);
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer);
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage);
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip);
+
 #endif /* __WINE_WAYLANDDRV_H */
-- 
2.33.0


From c30cdd1654e12d4c50cf9e7f01a73e7d3178b184 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 17:19:09 +0300
Subject: [PATCH 016/125] winewayland.drv: Add a Wayland SHM buffer queue.

Introduce a buffer queue object to handle a collection of Wayland SHM
buffers, including their acquisition by the driver and their release
by the Wayland compositor.

Each queue is initially empty, transparently and dynamically creating
up to 3 SHM buffers as needed.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in            |   1 +
 dlls/winewayland.drv/wayland_buffer_queue.c | 160 ++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h           |  21 +++
 3 files changed, 182 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_buffer_queue.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index c1ee074e7bd..308a7aa9480 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
+	wayland_buffer_queue.c \
 	wayland_shm.c \
 	window.c \
 
diff --git a/dlls/winewayland.drv/wayland_buffer_queue.c b/dlls/winewayland.drv/wayland_buffer_queue.c
new file mode 100644
index 00000000000..f07f64f89a9
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_buffer_queue.c
@@ -0,0 +1,160 @@
+/*
+ * Wayland buffer queue
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/unicode.h"
+#include "winuser.h"
+
+#include <errno.h>
+#include <assert.h>
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    shm_buffer->busy = FALSE;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+    buffer_release
+};
+
+/**********************************************************************
+ *          wayland_buffer_queue_create
+ *
+ * Creates a buffer queue containing buffers with the specified width, height
+ * and format.
+ */
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int height,
+                                                         enum wl_shm_format format)
+{
+    struct wayland_buffer_queue *queue;
+
+    queue = heap_alloc_zero(sizeof(*queue));
+    if (!queue)
+        return NULL;
+
+    queue->wayland = wayland;
+    queue->width = width;
+    queue->height = height;
+    queue->format = format;
+
+    wl_list_init(&queue->buffer_list);
+
+    return queue;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_destroy
+ *
+ * Destroys a buffer queue and any contained buffers.
+ */
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer, *next;
+
+    wl_list_for_each_safe(shm_buffer, next, &queue->buffer_list, link)
+        wayland_shm_buffer_destroy(shm_buffer);
+
+    heap_free(queue);
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_acquire_buffer
+ *
+ * Acquires a free buffer from the buffer queue. If no free buffers
+ * are available this function blocks until it can provide one.
+ *
+ * The returned buffer is marked as unavailable until committed to
+ * a surface and subsequently released by the compositor.
+ */
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    TRACE("queue=%p\n", queue);
+
+    while (TRUE)
+    {
+        int nbuffers = 0;
+
+        /* Search through our buffers to find an available one. */
+        wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        {
+            if (!shm_buffer->busy)
+            {
+                shm_buffer->busy = TRUE;
+                goto out;
+            }
+            nbuffers++;
+        }
+
+        /* Dynamically create up to 3 buffers. */
+        if (nbuffers < 3)
+        {
+            HRGN full_dmg = CreateRectRgn(0, 0, queue->width, queue->height);
+            shm_buffer = wayland_shm_buffer_create(queue->wayland, queue->width,
+                                                   queue->height, queue->format);
+            wl_buffer_add_listener(shm_buffer->wl_buffer, &buffer_listener, shm_buffer);
+            wl_list_insert(&queue->buffer_list, &shm_buffer->link);
+            wayland_shm_buffer_add_damage(shm_buffer, full_dmg);
+            shm_buffer->busy = TRUE;
+            DeleteObject(full_dmg);
+            goto out;
+        }
+
+        /* Keep dispatching buffer events to handle any pending buffer
+         * releases. If we have no events (and thus no newly available buffer),
+         * yield to allow other threads to perform work. */
+        while (wayland_dispatch_buffer(queue->wayland) == 0)
+            Sleep(0);
+    }
+
+out:
+    TRACE(" => %p %dx%d stride=%d map=[%p, %p)\n",
+          shm_buffer, shm_buffer->width, shm_buffer->height,
+          shm_buffer->stride, shm_buffer->map_data,
+          (unsigned char*)shm_buffer->map_data + shm_buffer->map_size);
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_add_damage
+ *
+ * Adds damage to all buffers in this queue.
+ */
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        wayland_shm_buffer_add_damage(shm_buffer, damage);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 316731c592d..f74c4cb6c50 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -82,6 +82,16 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_buffer_queue
+{
+    struct wayland *wayland;
+    struct wl_list buffer_list;
+    int width;
+    int height;
+    enum wl_shm_format format;
+    HRGN damage_region;
+};
+
 struct wayland_shm_buffer
 {
     struct wl_list link;
@@ -144,6 +154,17 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_buffer(struct wayland *wayland);
 
+/**********************************************************************
+ *          Wayland buffer queue
+ */
+
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int heigh,
+                                                         enum wl_shm_format format);
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue);
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage);
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue);
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
-- 
2.33.0


From 03cf52a44cfa5b8effaf9b1a7fb880f2ee5cff94 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 11:05:17 +0300
Subject: [PATCH 017/125] winewayland.drv: Introduce support for Wayland
 surfaces.

Introduce infrastructure to create, destroy and manage references to
Wayland surfaces.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   2 +
 dlls/winewayland.drv/wayland.c         |  30 ++++
 dlls/winewayland.drv/wayland_surface.c | 232 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  27 +++
 4 files changed, 291 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_surface.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 308a7aa9480..52eed209d45 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -16,9 +16,11 @@ C_SRCS = \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
 	wayland_shm.c \
+	wayland_surface.c \
 	window.c \
 
 WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c14c4d57714..db28b417b6f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -29,6 +29,19 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
 
+/**********************************************************************
+ *          xdg_wm_base handling
+ */
+
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *shell, uint32_t serial)
+{
+    xdg_wm_base_pong(shell, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
+};
+
 /**********************************************************************
  *          Registry handling
  */
@@ -46,6 +59,17 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_subcompositor") == 0)
+    {
+        wayland->wl_subcompositor =
+            wl_registry_bind(registry, id, &wl_subcompositor_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_wm_base") == 0)
+    {
+        wayland->xdg_wm_base = wl_registry_bind(registry, id,
+                &xdg_wm_base_interface, 1);
+        xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
+    }
     else if (strcmp(interface, "wl_shm") == 0)
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
@@ -169,6 +193,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
+    if (wayland->xdg_wm_base)
+        xdg_wm_base_destroy(wayland->xdg_wm_base);
+
+    if (wayland->wl_subcompositor)
+        wl_subcompositor_destroy(wayland->wl_subcompositor);
+
     if (wayland->wl_compositor)
         wl_compositor_destroy(wayland->wl_compositor);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
new file mode 100644
index 00000000000..8d80a9e08b8
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -0,0 +1,232 @@
+/*
+ * Wayland surfaces
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static struct wayland_surface *wayland_surface_create_common(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    surface = heap_alloc_zero(sizeof(*surface));
+    if (!surface)
+        goto err;
+
+    surface->wayland = wayland;
+
+    surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
+    if (!surface->wl_surface)
+        goto err;
+
+    wl_surface_set_user_data(surface->wl_surface, surface);
+
+    surface->ref = 1;
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_plain
+ *
+ * Creates a plain, role-less wayland surface.
+ */
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    TRACE("\n");
+
+    surface = wayland_surface_create_common(wayland);
+    if (!surface)
+        goto err;
+
+    wl_surface_commit(surface->wl_surface);
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_toplevel
+ *
+ * Creates a toplevel wayland surface, optionally associated with a parent
+ * surface.
+ */
+struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
+                                                        struct wayland_surface *parent)
+{
+    struct wayland_surface *surface;
+
+    TRACE("parent=%p\n", parent);
+
+    surface = wayland_surface_create_common(wayland);
+    if (!surface)
+        goto err;
+
+    surface->xdg_surface =
+        xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
+    if (!surface->xdg_surface)
+        goto err;
+
+    surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
+    if (!surface->xdg_toplevel)
+        goto err;
+
+    if (parent && parent->xdg_toplevel)
+        xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
+
+    wl_surface_commit(surface->wl_surface);
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_subsurface
+ *
+ * Creates a wayland subsurface with the specified parent.
+ */
+struct wayland_surface *wayland_surface_create_subsurface(struct wayland *wayland,
+                                                          struct wayland_surface *parent)
+{
+    struct wayland_surface *surface;
+
+    TRACE("parent=%p\n", parent);
+
+    surface = wayland_surface_create_common(wayland);
+    if (!surface)
+        goto err;
+
+    surface->parent = wayland_surface_ref(parent);
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    wl_surface_commit(surface->wl_surface);
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_destroy
+ *
+ * Destroys a wayland surface.
+ */
+void wayland_surface_destroy(struct wayland_surface *surface)
+{
+    TRACE("surface=%p\n", surface);
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    if (surface->wl_surface)
+    {
+        wl_surface_destroy(surface->wl_surface);
+        surface->wl_surface = NULL;
+    }
+
+    if (surface->parent)
+    {
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
+    /* Destroying the surface can lead to events that we need to handle
+     * immediately to get the latest state, so force a round trip, but only if
+     * we are in the same thread that handles the window (otherwise we will
+     * call wayland event handlers in an arbitrary thread, a scenario which we
+     * do not support). */
+    if (surface->wayland->thread_id == GetCurrentThreadId())
+    {
+        wl_display_roundtrip_queue(surface->wayland->wl_display,
+                                   surface->wayland->wl_event_queue);
+    }
+
+    heap_free(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ref
+ *
+ * Add a reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface)
+{
+    LONG ref = InterlockedIncrement(&surface->ref);
+    TRACE("surface=%p ref=%d->%d\n", surface, ref - 1, ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref
+ *
+ * Remove a reference to wayland_surface, potentially destroying it.
+ */
+void wayland_surface_unref(struct wayland_surface *surface)
+{
+    LONG ref = InterlockedDecrement(&surface->ref);
+
+    TRACE("surface=%p ref=%d->%d\n", surface, ref + 1, ref);
+
+    if (ref == 0)
+        wayland_surface_destroy(surface);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f74c4cb6c50..6f82de3cac4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -49,6 +50,8 @@ struct wayland
     struct wl_event_queue *buffer_wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_subcompositor *wl_subcompositor;
+    struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
@@ -82,6 +85,17 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface
+{
+    struct wayland *wayland;
+    struct wl_surface *wl_surface;
+    struct wl_subsurface *wl_subsurface;
+    struct xdg_surface *xdg_surface;
+    struct xdg_toplevel *xdg_toplevel;
+    struct wayland_surface *parent;
+    LONG ref;
+};
+
 struct wayland_buffer_queue
 {
     struct wayland *wayland;
@@ -165,6 +179,19 @@ void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue);
 void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage);
 struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue);
 
+/**********************************************************************
+ *          Wayland surface
+ */
+
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland);
+struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
+                                                        struct wayland_surface *parent);
+struct wayland_surface *wayland_surface_create_subsurface(struct wayland *wayland,
+                                                          struct wayland_surface *parent);
+void wayland_surface_destroy(struct wayland_surface *surface);
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
+void wayland_surface_unref(struct wayland_surface *surface);
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
-- 
2.33.0


From eae2aa9a6192c8c1049514a2b255bbe38cd91722 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 12:55:01 +0300
Subject: [PATCH 018/125] winewayland.drv: Basic handling of Wayland surface
 configure events.

Handle the initial configure event for top-level Wayland surfaces.  More
dynamic configure event handling will be implemented in future commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 91 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 23 +++++++
 2 files changed, 114 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 8d80a9e08b8..eeffa3bf994 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -26,6 +26,89 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
+                                         uint32_t serial)
+{
+    struct wayland_surface *surface = data;
+
+    TRACE("serial=%u\n", serial);
+
+    surface->pending.serial = serial;
+
+    wayland_surface_ack_pending_configure(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ack_pending_configure
+ *
+ * Acks the pending configure event, making it current.
+ */
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
+{
+    if (!surface->xdg_surface || !surface->pending.serial)
+        return;
+
+    TRACE("Setting current serial=%u size=%dx%d flags=%#x\n",
+          surface->pending.serial, surface->pending.width,
+          surface->pending.height, surface->pending.configure_flags);
+
+    surface->current = surface->pending;
+    xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_xdg_surface_configure,
+};
+
+static void handle_xdg_toplevel_configure(void *data,
+                                          struct xdg_toplevel *xdg_toplevel,
+                                          int32_t width, int32_t height,
+                                          struct wl_array *states)
+{
+    struct wayland_surface *surface = data;
+    uint32_t *state;
+    int flags = 0;
+
+    wl_array_for_each(state, states)
+    {
+        switch(*state)
+        {
+        case XDG_TOPLEVEL_STATE_MAXIMIZED:
+            flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+            break;
+        case XDG_TOPLEVEL_STATE_ACTIVATED:
+            flags |= WAYLAND_CONFIGURE_FLAG_ACTIVATED;
+            break;
+        case XDG_TOPLEVEL_STATE_RESIZING:
+            flags |= WAYLAND_CONFIGURE_FLAG_RESIZING;
+            break;
+        case XDG_TOPLEVEL_STATE_FULLSCREEN:
+            flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+            break;
+        default:
+            break;
+        }
+    }
+
+    surface->pending.width = width;
+    surface->pending.height = height;
+    surface->pending.configure_flags = flags;
+
+    TRACE("%dx%d flags=%#x\n", width, height, flags);
+}
+
+static void handle_xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    TRACE("\n");
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    handle_xdg_toplevel_configure,
+    handle_xdg_toplevel_close,
+};
+
 static struct wayland_surface *wayland_surface_create_common(struct wayland *wayland)
 {
     struct wayland_surface *surface;
@@ -98,16 +181,22 @@ struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
         goto err;
+    xdg_surface_add_listener(surface->xdg_surface, &xdg_surface_listener, surface);
 
     surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
     if (!surface->xdg_toplevel)
         goto err;
+    xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface);
 
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
 
     wl_surface_commit(surface->wl_surface);
 
+    /* Wait for the first configure event. */
+    while (!surface->current.serial)
+        wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
     return surface;
 
 err:
@@ -204,6 +293,8 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
+
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6f82de3cac4..5b513217c3d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -36,6 +36,18 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+ *          Internal messages and data
+ */
+
+enum wayland_configure_flags
+{
+    WAYLAND_CONFIGURE_FLAG_RESIZING   = (1 << 0),
+    WAYLAND_CONFIGURE_FLAG_ACTIVATED  = (1 << 1),
+    WAYLAND_CONFIGURE_FLAG_MAXIMIZED  = (1 << 2),
+    WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -85,6 +97,14 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface_configure
+{
+    int width;
+    int height;
+    enum wayland_configure_flags configure_flags;
+    uint32_t serial;
+};
+
 struct wayland_surface
 {
     struct wayland *wayland;
@@ -93,6 +113,8 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    struct wayland_surface_configure pending;
+    struct wayland_surface_configure current;
     LONG ref;
 };
 
@@ -189,6 +211,7 @@ struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
 struct wayland_surface *wayland_surface_create_subsurface(struct wayland *wayland,
                                                           struct wayland_surface *parent);
 void wayland_surface_destroy(struct wayland_surface *surface);
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 
-- 
2.33.0


From 457f9be9b9e4fb57bea61a970bb9ee1edba92093 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:03:11 +0300
Subject: [PATCH 019/125] winewayland.drv: Add functions to transform Wine
 coordinates to Wayland.

The functions are currently trivial, in the sense that they apply the
identity transformation. They will be enhanced as needed in future
commits to handle differences in the coordinate spaces, introduced, e.g,
by the use of scaling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 29 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++++
 2 files changed, 35 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index eeffa3bf994..2c81f5400ab 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -295,6 +295,35 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
 
 
+/**********************************************************************
+ *          wayland_surface_coords_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates.
+ */
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y)
+{
+    *wayland_x = wine_x;
+    *wayland_y = wine_y;
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_rounded_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates
+ * rounding to the closest integer value.
+ */
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y)
+{
+    double w_x, w_y;
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y, &w_x, &w_y);
+    *wayland_x = round(w_x);
+    *wayland_y = round(w_y);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5b513217c3d..478963a405f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -212,6 +212,12 @@ struct wayland_surface *wayland_surface_create_subsurface(struct wayland *waylan
                                                           struct wayland_surface *parent);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y);
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 
-- 
2.33.0


From fdfa44ab0f270ab6c3d63d7c33ba7048db31485a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:11:01 +0300
Subject: [PATCH 020/125] winewayland.drv: Add function to commit a buffer to a
 Wayland surface.

The buffer is committed along with damage information to allow the
Wayland compositor to potentially optimize presentation.

Some Wayland surface states, such as maximized and fullscreen, place
constraints on the effective surface size they accept. We honor
such constraints, not committing incompatible buffers, to avoid protocol
errors.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 125 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |   7 ++
 2 files changed, 130 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2c81f5400ab..fd0334b599d 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -52,9 +52,15 @@ void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
           surface->pending.serial, surface->pending.width,
           surface->pending.height, surface->pending.configure_flags);
 
+    /* Guard setting current config, so that we only commit acceptable
+     * buffers. Also see wayland_surface_commit_buffer(). */
+    EnterCriticalSection(&surface->crit);
+
     surface->current = surface->pending;
     xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
 
+    LeaveCriticalSection(&surface->crit);
+
     memset(&surface->pending, 0, sizeof(surface->pending));
 }
 
@@ -117,6 +123,9 @@ static struct wayland_surface *wayland_surface_create_common(struct wayland *way
     if (!surface)
         goto err;
 
+    InitializeCriticalSection(&surface->crit);
+    surface->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": wayland_surface");
+
     surface->wayland = wayland;
 
     surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
@@ -240,6 +249,117 @@ err:
     return NULL;
 }
 
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!(size = GetRegionData(region, 0, NULL))) goto err;
+    if (!(data = heap_alloc_zero(size))) goto err;
+
+    if (!GetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    heap_free(data);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_configure_is_compatible
+ *
+ * Checks whether a wayland_surface_configure object is compatible with the
+ * the provided arguments.
+ *
+ * If flags is zero, only the width and height are checked for compatibility,
+ * otherwise, the configure objects flags must also match the passed flags.
+ */
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags)
+{
+    BOOL compat_flags = flags ? (flags & conf->configure_flags) : TRUE;
+    BOOL compat_with_max =
+        !(conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+        (width == conf->width && height == conf->height);
+    BOOL compat_with_full =
+        !(conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) ||
+        (width <= conf->width && height <= conf->height);
+
+    return compat_flags && compat_with_max && compat_with_full;
+}
+
+/**********************************************************************
+ *          wayland_surface_commit_buffer
+ *
+ * Commits a SHM buffer on a wayland surface.
+ */
+void wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region)
+{
+    RGNDATA *surface_damage;
+    int wayland_width, wayland_height;
+
+    /* Since multiple threads can commit a buffer to a wayland surface
+     * (e.g., child windows in different threads), we guard this function
+     * to ensure we don't commit buffers that are not acceptable by the
+     * compositor (see below, and also wayland_surface_ack_configure()). */
+    EnterCriticalSection(&surface->crit);
+
+    TRACE("surface=%p (%dx%d) flags=%#x buffer=%p (%dx%d)\n", surface,
+            surface->current.width, surface->current.height,
+            surface->current.configure_flags,
+            shm_buffer, shm_buffer->width, shm_buffer->height);
+
+    wayland_surface_coords_rounded_from_wine(surface,
+                                             shm_buffer->width, shm_buffer->height,
+                                             &wayland_width, &wayland_height);
+
+    /* Maximized surfaces are very strict about the dimensions of buffers
+     * they accept. To avoid wayland protocol errors, drop buffers not matching
+     * the expected dimensions of maximized surfaces. This typically happens
+     * transiently during resizing operations. */
+    if (!wayland_surface_configure_is_compatible(&surface->current,
+                                                 wayland_width,
+                                                 wayland_height,
+                                                 surface->current.configure_flags))
+    {
+        LeaveCriticalSection(&surface->crit);
+        TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
+        shm_buffer->busy = FALSE;
+        return;
+    }
+
+    wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
+
+    /* Add surface damage, i.e., which parts of the surface have changed since
+     * the last surface commit. Note that this is different from the buffer
+     * damage returned by wayland_shm_buffer_get_damage(). */
+    surface_damage = get_region_data(surface_damage_region);
+    if (surface_damage)
+    {
+        RECT *rgn_rect = (RECT *)surface_damage->Buffer;
+        RECT *rgn_rect_end = rgn_rect + surface_damage->rdh.nCount;
+
+        for (;rgn_rect < rgn_rect_end; rgn_rect++)
+        {
+            wl_surface_damage_buffer(surface->wl_surface,
+                                     rgn_rect->left, rgn_rect->top,
+                                     rgn_rect->right - rgn_rect->left,
+                                     rgn_rect->bottom - rgn_rect->top);
+        }
+        heap_free(surface_damage);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    LeaveCriticalSection(&surface->crit);
+
+    wl_display_flush(surface->wayland->wl_display);
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
@@ -279,6 +399,9 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->parent = NULL;
     }
 
+    surface->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&surface->crit);
+
     /* Destroying the surface can lead to events that we need to handle
      * immediately to get the latest state, so force a round trip, but only if
      * we are in the same thread that handles the window (otherwise we will
@@ -293,8 +416,6 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
-
-
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 478963a405f..fe431b199e3 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -113,6 +113,7 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
     LONG ref;
@@ -210,6 +211,12 @@ struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
                                                         struct wayland_surface *parent);
 struct wayland_surface *wayland_surface_create_subsurface(struct wayland *wayland,
                                                           struct wayland_surface *parent);
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags);
+void wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
-- 
2.33.0


From 00fd65b46a11c994f9e4e6efc6afc8cece7eaf31 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:24:03 +0300
Subject: [PATCH 021/125] winewayland.drv: Add function to unmap a Wayland
 surface.

Keep track of whether a Wayland surface is mapped or not, and allow
unmapping (i.e., hiding) it.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 17 +++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index fd0334b599d..beabe5d1d8b 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -354,6 +354,7 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
     }
 
     wl_surface_commit(surface->wl_surface);
+    surface->mapped = TRUE;
 
     LeaveCriticalSection(&surface->crit);
 
@@ -416,6 +417,22 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_unmap
+ *
+ * Unmaps (i.e., hides) this surface.
+ */
+void wayland_surface_unmap(struct wayland_surface *surface)
+{
+    EnterCriticalSection(&surface->crit);
+
+    wl_surface_attach(surface->wl_surface, NULL, 0, 0);
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = FALSE;
+
+    LeaveCriticalSection(&surface->crit);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fe431b199e3..28d38c98eff 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -116,6 +116,7 @@ struct wayland_surface
     CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
+    BOOL mapped;
     LONG ref;
 };
 
@@ -218,6 +219,7 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
                                    struct wayland_shm_buffer *shm_buffer,
                                    HRGN surface_damage_region);
 void wayland_surface_destroy(struct wayland_surface *surface);
+void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
-- 
2.33.0


From 506e9295d55b1b0cc4e6c87dc2cfd76573129985 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:26:30 +0300
Subject: [PATCH 022/125] winewayland.drv: Allow associating a Wayland surface
 with a HWND.

There is no initial HWND association. It's the responsibility of the
surface creator to set it.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 4 ++--
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index beabe5d1d8b..81229054c67 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -31,7 +31,7 @@ static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_sur
 {
     struct wayland_surface *surface = data;
 
-    TRACE("serial=%u\n", serial);
+    TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
 
     surface->pending.serial = serial;
 
@@ -368,7 +368,7 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
-    TRACE("surface=%p\n", surface);
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
     if (surface->xdg_toplevel)
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 28d38c98eff..cfac7af3b4f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -113,6 +113,7 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    HWND hwnd;
     CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
-- 
2.33.0


From 0b44bdecef1c044a275263e48af96502ecbe2467 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 10:38:51 +0300
Subject: [PATCH 023/125] winewayland.drv: Create backing Wayland surfaces for
 windows.

Associate Wayland surfaces with windows that need to be displayed by
the native window system. This includes all kinds of top-level windows,
but not child windows, since children are rendered by Wine in the
window surface of their parent top-level.

As a special case, we use Wayland subsurfaces to display windows
that we believe are transient (e.g., popups) and need relative
positioning. We currently use a very simple heurestic to detect such
cases: windows that have an owner but no caption. Future commits
will refine this heurestic.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c             | 132 ++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 2 files changed, 133 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ff194ce5c69..2f6cd24a757 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -45,6 +45,12 @@ struct wayland_win_data
     RECT           window_rect;
     /* client area relative to parent */
     RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* whether this window is visible */
+    BOOL visible;
+    /* Whether a first wayland surface update is needed */
+    BOOL           wayland_surface_needs_first_update;
 };
 
 static CRITICAL_SECTION win_data_section;
@@ -71,6 +77,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     heap_free(data);
 
     LeaveCriticalSection(&win_data_section);
@@ -123,6 +130,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
         return NULL;
 
     data->hwnd = hwnd;
+    data->wayland_surface_needs_first_update = TRUE;
 
     EnterCriticalSection(&win_data_section);
     win_data_context[context_idx(hwnd)] = data;
@@ -132,6 +140,107 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
     return data;
 }
 
+/***********************************************************************
+ *           wayland_surface_for_hwnd_lock
+ *
+ *  Gets the wayland surface for HWND while locking the private window data.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+
+    if (data && data->wayland_surface)
+        return data->wayland_surface;
+
+    wayland_win_data_release(data);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlock
+ */
+static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+{
+    if (surface) LeaveCriticalSection(&win_data_section);
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_first_update)
+        return TRUE;
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland;
+    HWND effective_parent_hwnd;
+    struct wayland_surface *parent_surface;
+    DWORD style;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_first_update = FALSE;
+
+    wayland = thread_init_wayland();
+
+    if (data->wayland_surface)
+    {
+        wayland_surface_unref(data->wayland_surface);
+        data->wayland_surface = NULL;
+    }
+
+    /* Only create wayland surfaces for toplevel windows. Let Wine core handle
+     * the drawing of other windows in their corresponding top level window
+     * surface. */
+    if (data->parent) return;
+
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    effective_parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+    {
+        parent_surface = wayland_surface_for_hwnd_lock(effective_parent_hwnd);
+        wayland_surface_for_hwnd_unlock(parent_surface);
+    }
+
+    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Use wayland subsurfaces for owned win32 windows that are transient (i.e., don't have
+     * a titlebar). Otherwise, if the window is visible make it wayland toplevel. Finally,
+     * if the window is not visible create a plain (without a role) surface to avoid
+     * polluting the compositor with empty xdg_toplevels. */
+    if ((style & WS_CAPTION) != WS_CAPTION && parent_surface)
+        data->wayland_surface = wayland_surface_create_subsurface(wayland, parent_surface);
+    else if (data->visible)
+        data->wayland_surface = wayland_surface_create_toplevel(wayland, parent_surface);
+    else
+        data->wayland_surface = wayland_surface_create_plain(wayland);
+
+    if (data->wayland_surface)
+        data->wayland_surface->hwnd = data->hwnd;
+}
+
+static void update_wayland_state(struct wayland_win_data *data)
+{
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -183,7 +292,30 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
     wayland_win_data_release(data);
     return TRUE;
 }
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                    const RECT *window_rect, const RECT *client_rect,
+                                    const RECT *visible_rect, const RECT *valid_rects,
+                                    struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), GetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    update_wayland_state(data);
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 40cfc9ba432..48c3bb91cd3 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -5,3 +5,4 @@
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
+@ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) WAYLAND_WindowPosChanged
-- 
2.33.0


From 37df345143e54c9b4d917e84bb3c638a8b09389b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 13:49:48 +0300
Subject: [PATCH 024/125] winewayland.drv: Implement window_surface for
 Wayland.

Implement struct window_surface for windows backed by wayland surfaces.
Each window_surface uses a Wayland SHM buffer queue to manage a set of
XRGB8888 (for now) buffers used to display the window contents.

During flushing the contents of the window_surface bitmap are copied to
a available SHM buffer and committed to the associated Wayland surface.
Surface damage, and the cumulative buffer damage, is taken into account
to minimize the amount of pixel data that needs to be copied.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   1 +
 dlls/winewayland.drv/waylanddrv.h     |  10 +
 dlls/winewayland.drv/window.c         |  39 ++++
 dlls/winewayland.drv/window_surface.c | 320 ++++++++++++++++++++++++++
 4 files changed, 370 insertions(+)
 create mode 100644 dlls/winewayland.drv/window_surface.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 52eed209d45..2861fb3b96f 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -18,6 +18,7 @@ C_SRCS = \
 	wayland_shm.c \
 	wayland_surface.c \
 	window.c \
+	window_surface.c \
 
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index cfac7af3b4f..f759013e309 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -244,4 +244,14 @@ void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN d
 RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
                                                HRGN clip);
 
+/**********************************************************************
+ *          Wayland window surface
+ */
+
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect);
+void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
+BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
+void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
+                                                   struct wayland_surface *wayland_surface);
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2f6cd24a757..8ac41db3cf7 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -47,6 +47,8 @@ struct wayland_win_data
     RECT           client_rect;
     /* wayland surface (if any) representing this window on the wayland side */
     struct wayland_surface *wayland_surface;
+    /* wine window_surface backing this window */
+    struct window_surface *window_surface;
     /* whether this window is visible */
     BOOL visible;
     /* Whether a first wayland surface update is needed */
@@ -239,6 +241,14 @@ static void update_wayland_state(struct wayland_win_data *data)
 {
     if (wayland_win_data_wayland_surface_needs_update(data))
         wayland_win_data_update_wayland_surface(data);
+
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+        if (wayland_window_surface_needs_flush(data->window_surface))
+            wayland_window_surface_flush(data->window_surface);
+    }
 }
 
 /**********************************************************************
@@ -282,6 +292,7 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     BOOL exstyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
     DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
     HWND parent = GetAncestor(hwnd, GA_PARENT);
+    RECT surface_rect;
 
     TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
@@ -294,6 +305,30 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     data->client_rect = *client_rect;
     data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
+    /* Release the dummy surface wine provides for toplevels. */
+    if (*surface) window_surface_release(*surface);
+    *surface = NULL;
+
+    /* Check if we don't want a dedicated window surface. */
+    if (data->parent || (swp_flags & SWP_HIDEWINDOW) || !data->visible) goto done;
+
+    surface_rect = *window_rect;
+    OffsetRect(&surface_rect, -surface_rect.left, -surface_rect.top);
+
+    /* Check if we can reuse our current window surface. */
+    if (data->window_surface &&
+        EqualRect(&data->window_surface->rect, &surface_rect))
+    {
+        window_surface_add_ref(data->window_surface);
+        *surface = data->window_surface;
+        TRACE("reusing surface %p\n", *surface);
+        goto done;
+    }
+
+    /* Create new window surface. */
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect);
+
+done:
     wayland_win_data_release(data);
     return TRUE;
 }
@@ -315,6 +350,10 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
           wine_dbgstr_rect(visible_rect), GetWindowLongW(hwnd, GWL_STYLE),
           insert_after, swp_flags);
 
+    if (surface) window_surface_add_ref(surface);
+    if (data->window_surface) window_surface_release(data->window_surface);
+    data->window_surface = surface;
+
     update_wayland_state(data);
 
     wayland_win_data_release(data);
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
new file mode 100644
index 00000000000..cf76866dd7c
--- /dev/null
+++ b/dlls/winewayland.drv/window_surface.c
@@ -0,0 +1,320 @@
+/*
+ * Wayland window surface implementation
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include "winuser.h"
+
+#include "wine/debug.h"
+#include "wine/gdi_driver.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct wayland_window_surface
+{
+    struct window_surface header;
+    HWND                  hwnd;
+    struct wayland_surface *wayland_surface; /* Not owned by us */
+    struct wayland_buffer_queue *wayland_buffer_queue;
+    RECT                  bounds;
+    void                 *bits;
+    CRITICAL_SECTION      crit;
+    BOOL                  last_flush_missing_wayland;
+    BITMAPINFO            info;
+};
+
+static struct wayland_window_surface *wayland_window_surface_cast(
+    struct window_surface *window_surface)
+{
+    return (struct wayland_window_surface *)window_surface;
+}
+
+static inline int get_dib_stride(int width, int bpp)
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size(const BITMAPINFO *info)
+{
+    return get_dib_stride(info->bmiHeader.biWidth, info->bmiHeader.biBitCount) *
+           abs(info->bmiHeader.biHeight);
+}
+
+static inline void reset_bounds(RECT *bounds)
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_lock
+ */
+static void CDECL wayland_window_surface_lock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    EnterCriticalSection(&wws->crit);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_unlock
+ */
+static void CDECL wayland_window_surface_unlock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    LeaveCriticalSection(&wws->crit);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bitmap_info
+ */
+static void CDECL *wayland_window_surface_get_bitmap_info(struct window_surface *window_surface,
+                                                          BITMAPINFO *info)
+{
+    struct wayland_window_surface *surface = wayland_window_surface_cast(window_surface);
+    /* We don't store any additional information at the end of our BITMAPINFO, so
+     * just copy the structure itself. */
+    memcpy(info, &surface->info, sizeof(*info));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bounds
+ */
+static RECT CDECL *wayland_window_surface_get_bounds(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return &wws->bounds;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_region
+ */
+static void CDECL wayland_window_surface_set_region(struct window_surface *window_surface,
+                                                    HRGN region)
+{
+    /* TODO */
+}
+
+/***********************************************************************
+ *           wayland_window_surface_flush
+ */
+void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    struct wayland_shm_buffer *buffer;
+    RECT damage_rect;
+    BOOL needs_flush;
+    RGNDATA *buffer_damage;
+    HRGN surface_damage_region = NULL;
+    RECT *rgn_rect;
+    RECT *rgn_rect_end;
+
+    window_surface->funcs->lock(window_surface);
+
+    TRACE("hwnd=%p surface_rect=%s bounds=%s\n", wws->hwnd,
+          wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
+
+    needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush &&
+        (!wws->wayland_surface || !wws->wayland_buffer_queue))
+    {
+        TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
+              wws->wayland_surface, wws->wayland_buffer_queue);
+        wws->last_flush_missing_wayland = TRUE;
+        goto done;
+    }
+    wws->last_flush_missing_wayland = FALSE;
+
+    reset_bounds(&wws->bounds);
+    if (!needs_flush) goto done;
+
+    surface_damage_region = CreateRectRgnIndirect(&damage_rect);
+
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+          wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
+          wws->bits);
+
+    assert(wws->wayland_buffer_queue);
+
+    wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
+    buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+
+    rgn_rect = (RECT *)buffer_damage->Buffer;
+    rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
+
+    /* Flush damaged buffer region from window_surface bitmap to wayland SHM buffer. */
+    for (;rgn_rect < rgn_rect_end; rgn_rect++)
+    {
+        unsigned int *src, *dst;
+        int y, width, height;
+
+        TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
+
+        if (IsRectEmpty(rgn_rect))
+            continue;
+
+        src = (unsigned int *)wws->bits +
+              rgn_rect->top * wws->info.bmiHeader.biWidth +
+              rgn_rect->left;
+        dst = (unsigned int *)((unsigned char *)buffer->map_data +
+              rgn_rect->top * buffer->stride +
+              rgn_rect->left * 4);
+        width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
+        height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
+
+        /* Fast path for full width rectangles. */
+        if (width == buffer->width)
+        {
+            memcpy(dst, src, height * buffer->stride);
+            continue;
+        }
+
+        for (y = 0; y < height; y++)
+        {
+            memcpy(dst, src, width * 4);
+
+            src += wws->info.bmiHeader.biWidth;
+            dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
+        }
+    }
+
+    wayland_surface_commit_buffer(wws->wayland_surface, buffer, surface_damage_region);
+    wayland_shm_buffer_clear_damage(buffer);
+
+    heap_free(buffer_damage);
+
+done:
+    if (surface_damage_region) DeleteObject(surface_damage_region);
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_destroy
+ */
+static void CDECL wayland_window_surface_destroy(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("surface=%p\n", wws);
+
+    wws->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&wws->crit);
+    if (wws->wayland_buffer_queue)
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+    heap_free(wws->bits);
+    heap_free(wws);
+}
+
+static const struct window_surface_funcs wayland_window_surface_funcs =
+{
+    wayland_window_surface_lock,
+    wayland_window_surface_unlock,
+    wayland_window_surface_get_bitmap_info,
+    wayland_window_surface_get_bounds,
+    wayland_window_surface_set_region,
+    wayland_window_surface_flush,
+    wayland_window_surface_destroy
+};
+
+/***********************************************************************
+ *           wayland_window_surface_create
+ */
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect)
+{
+    struct wayland_window_surface *wws;
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+
+    TRACE("win %p rect %s\n", hwnd, wine_dbgstr_rect(rect));
+    wws = heap_alloc_zero(sizeof(*wws));
+    if (!wws) return NULL;
+    wws->info.bmiHeader.biSize = sizeof(wws->info.bmiHeader);
+    wws->info.bmiHeader.biClrUsed = 0;
+    wws->info.bmiHeader.biBitCount = 32;
+    wws->info.bmiHeader.biCompression = BI_RGB;
+    wws->info.bmiHeader.biWidth       = width;
+    wws->info.bmiHeader.biHeight      = -height; /* top-down */
+    wws->info.bmiHeader.biPlanes      = 1;
+    wws->info.bmiHeader.biSizeImage   = get_dib_image_size(&wws->info);
+
+    InitializeCriticalSection(&wws->crit);
+    wws->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": wws");
+
+    wws->header.funcs = &wayland_window_surface_funcs;
+    wws->header.rect  = *rect;
+    wws->header.ref   = 1;
+    wws->hwnd         = hwnd;
+    reset_bounds(&wws->bounds);
+
+    if (!(wws->bits = heap_alloc(wws->info.bmiHeader.biSizeImage)))
+        goto failed;
+
+    TRACE("created %p hwnd %p %s bits %p-%p compression %d\n", wws, hwnd, wine_dbgstr_rect(rect),
+           wws->bits, (char *)wws->bits + wws->info.bmiHeader.biSizeImage,
+           wws->info.bmiHeader.biCompression);
+
+    return &wws->header;
+
+failed:
+    wayland_window_surface_destroy(&wws->header);
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_needs_flush
+ */
+BOOL wayland_window_surface_needs_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return wws->last_flush_missing_wayland;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_wayland_surface
+ */
+void wayland_window_surface_update_wayland_surface(struct window_surface *window_surface,
+                                                   struct wayland_surface *wayland_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    wws->wayland_surface = wayland_surface;
+
+    if (!wws->wayland_buffer_queue && wws->wayland_surface)
+    {
+        wws->wayland_buffer_queue =
+            wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    WL_SHM_FORMAT_XRGB8888);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.33.0


From 5ea0d2d3a8e0ca48f743b244e922a75d04477ddd Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 14:37:22 +0300
Subject: [PATCH 025/125] winewayland.drv: Read and dispatch Wayland events.

Create a separate reader thread to read Wayland events from the compositor
and dispatch them to their appropriate queues. The reader thread
notifies all Wayland-enabled threads of possible new events by using
an unnamed pipe for each thread. The read end of the pipe is
used as the Wine driver queue fd for the respective thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 130 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |  48 +++++++++
 3 files changed, 181 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index db28b417b6f..3b7b67e4b43 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -19,16 +19,32 @@
  */
 
 #include "config.h"
+#include "wine/port.h"
 
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include <errno.h>
+#include <poll.h>
+#include <unistd.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
 
+static CRITICAL_SECTION thread_wayland_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &thread_wayland_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": thread_wayland_section") }
+};
+static CRITICAL_SECTION thread_wayland_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
+
 /**********************************************************************
  *          xdg_wm_base handling
  */
@@ -125,8 +141,14 @@ static const struct wl_registry_listener registry_listener = {
  */
 BOOL wayland_init(struct wayland *wayland)
 {
+    int flags;
+
     TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
 
+    wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
+
     wayland->process_id = GetCurrentProcessId();
     wayland->thread_id = GetCurrentThreadId();
     wayland->wl_display = process_wl_display;
@@ -168,6 +190,21 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
 
+    /* Thread wayland instances have notification pipes to inform them when
+     * there might be new events in their queues. The read part of the pipe
+     * is also used as the wine server queue fd. */
+    if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+        return FALSE;
+    /* Make just the read end non-blocking */
+    if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+        return FALSE;
+    if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+        return FALSE;
+    /* Keep a list of all thread wayland instances, so we can notify them. */
+    EnterCriticalSection(&thread_wayland_section);
+    wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+    LeaveCriticalSection(&thread_wayland_section);
+
     wayland->initialized = TRUE;
 
     return TRUE;
@@ -184,6 +221,15 @@ void wayland_deinit(struct wayland *wayland)
 
     TRACE("%p\n", wayland);
 
+    EnterCriticalSection(&thread_wayland_section);
+    wl_list_remove(&wayland->thread_link);
+    LeaveCriticalSection(&thread_wayland_section);
+
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
@@ -247,3 +293,87 @@ int wayland_dispatch_buffer(struct wayland *wayland)
     return wl_display_dispatch_queue_pending(wayland->wl_display,
                                              wayland->buffer_wl_event_queue);
 }
+
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    EnterCriticalSection(&thread_wayland_section);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    LeaveCriticalSection(&thread_wayland_section);
+}
+
+/**********************************************************************
+ *          wayland_read_events
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues and notify threads about the possibility of new events.
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events(void)
+{
+    struct pollfd pfd = {0};
+    int ret;
+
+    pfd.fd = wl_display_get_fd(process_wl_display);
+    pfd.events = POLLIN;
+
+    TRACE("waiting for events...\n");
+
+    /* In order to read events we need to prepare the read on some
+     * queue. We can safely use the default queue, since it's
+     * otherwise unused (all struct wayland instances dispatch to
+     * their own queues). */
+    while (wl_display_prepare_read(process_wl_display) != 0)
+    {
+        if (wl_display_dispatch_pending(process_wl_display) == -1)
+        {
+            TRACE("... failed wl_display_dispatch_pending errno=%d\n", errno);
+            return FALSE;
+        }
+    }
+
+    wl_display_flush(process_wl_display);
+
+    while ((ret = poll(&pfd, 1, -1)) == -1 && errno == EINTR) continue;
+
+    if (ret == -1 || !(pfd.revents & POLLIN))
+    {
+        TRACE("... failed poll errno=%d revents=0x%x\n",
+              ret == -1 ? errno : 0, pfd.revents);
+        wl_display_cancel_read(process_wl_display);
+        return FALSE;
+    }
+
+    if (wl_display_read_events(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_read_events errno=%d\n", errno);
+        return FALSE;
+    }
+
+    if (wl_display_dispatch_pending(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_dispatch_pending errno=%d\n", errno);
+        return FALSE;
+    }
+
+    wayland_notify_threads();
+
+    TRACE("... done\n");
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f759013e309..50ecba4d26f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -68,6 +68,8 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    int event_notification_pipe[2];
+    struct wl_list thread_link;
 };
 
 struct wayland_output_mode
@@ -192,6 +194,7 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 int wayland_dispatch_buffer(struct wayland *wayland);
+BOOL wayland_read_events(void);
 
 /**********************************************************************
  *          Wayland buffer queue
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5748afaabeb..582993044de 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -26,12 +26,54 @@
 
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 
+static DWORD WINAPI wayland_read_thread(void *arg)
+{
+    while (wayland_read_events()) continue;
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    exit(1);
+    return 0;
+}
+
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        ExitProcess(1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        ExitProcess(1);
+    }
+
+    CloseHandle(handle);
+}
+
 /***********************************************************************
  *           Initialize per thread data
  */
@@ -55,6 +97,7 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    set_queue_fd(&data->wayland);
     TlsSetValue(thread_data_tls_index, data);
 
     return data;
@@ -81,10 +124,15 @@ void CDECL WAYLAND_ThreadDetach(void)
  */
 static BOOL process_attach(void)
 {
+    DWORD id;
+
     if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
 
     if (!wayland_process_init()) return FALSE;
 
+    /* All reads of wayland events happen from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_thread, NULL, 0, &id);
+
     return TRUE;
 }
 
-- 
2.33.0


From 3452dcdc0d8ad007e6627aad753b375ddabb6357 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:37:15 +0300
Subject: [PATCH 026/125] winewayland.drv: Add functions to transform Wayland
 to Wine coordinates.

The functions are currently trivial, in the sense that they apply the
identity transformation. They will be enhanced as needed in upcoming
commits to handle differences in the coordinate spaces, introduced, e.g,
by the use of scaling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 40 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++
 2 files changed, 46 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 81229054c67..5a867520087 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -24,6 +24,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
@@ -433,6 +435,31 @@ void wayland_surface_unmap(struct wayland_surface *surface)
     LeaveCriticalSection(&surface->crit);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_to_screen
+ *
+ * Converts the surface-local coordinates to Windows screen coordinates.
+ */
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y)
+{
+    RECT window_rect = {0};
+    int wine_x, wine_y;
+
+    wayland_surface_coords_to_wine(surface, wayland_x, wayland_y,
+                                   &wine_x, &wine_y);
+
+    GetWindowRect(surface->hwnd, &window_rect);
+
+    *screen_x = wine_x + window_rect.left;
+    *screen_y = wine_y + window_rect.top;
+
+    TRACE("hwnd=%p wayland=%.2f,%.2f rect=%s => screen=%d,%d\n",
+          surface->hwnd, wayland_x, wayland_y, wine_dbgstr_rect(&window_rect),
+          *screen_x, *screen_y);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
@@ -462,6 +489,19 @@ void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
     *wayland_y = round(w_y);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_to_wine
+ *
+ * Converts the surface-local coordinates to wine windows-local coordinates.
+ */
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y)
+{
+    *wine_x = wayland_x;
+    *wine_y = wayland_y;
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 50ecba4d26f..65e84bd85a6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -225,12 +225,18 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y);
 void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
                                               int wine_x, int wine_y,
                                               int *wayland_x, int *wayland_y);
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 
-- 
2.33.0


From 2da5e658d200167a3af12b65d0a1b895b3429cf1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:49:33 +0300
Subject: [PATCH 027/125] winewayland.drv: Implement
 MsgWaitForMultipleObjectsEx.

Prepare for handling input events by dispatching (non-buffer) Wayland
events in MsgWaitForMultipleObjectsEx and tracking the types
events actually dispatched.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c            | 84 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  1 +
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 3 files changed, 86 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 3b7b67e4b43..9b99287d899 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -26,6 +26,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 #include <errno.h>
 #include <poll.h>
 #include <unistd.h>
@@ -277,6 +279,44 @@ BOOL wayland_process_init(void)
     return process_wl_display != NULL;
 }
 
+/**********************************************************************
+ *          wayland_dispatch_non_buffer
+ *
+ * Dispatch all non-buffer events for the specified wayland instance.
+ *
+ * Returns the number of events dispatched.
+ */
+int wayland_dispatch_non_buffer(struct wayland *wayland)
+{
+    char buf[64];
+
+    TRACE("wayland=%p queue=%p\n", wayland, wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    /* Consume notifications */
+    while (TRUE)
+    {
+        int ret = read(wayland->event_notification_pipe[0], buf, sizeof(buf));
+        if (ret > 0) continue;
+        if (ret == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EAGAIN) break; /* no data to read */
+            ERR("failed to read from notification pipe: %s\n", strerror(errno));
+            break;
+        }
+        if (ret == 0)
+        {
+            ERR("failed to read from notification pipe: pipe is closed\n");
+            break;
+        }
+    }
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->wl_event_queue);
+}
+
 /**********************************************************************
  *          wayland_dispatch_buffer
  *
@@ -377,3 +417,47 @@ BOOL wayland_read_events(void)
 
     return TRUE;
 }
+
+static BOOL process_wayland_events(DWORD mask)
+{
+    struct wayland *wayland = thread_wayland();
+    int dispatched;
+
+    if (!wayland)
+        return FALSE;
+
+    wayland->last_dispatch_mask = 0;
+
+    dispatched = wayland_dispatch_non_buffer(wayland);
+    if (dispatched)
+        wayland->last_dispatch_mask |= QS_SENDMESSAGE;
+
+    TRACE("dispatched=%d mask=%s%s%s%s%s%s%s\n",
+          dispatched,
+          (wayland->last_dispatch_mask & QS_KEY) ? "QS_KEY|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEMOVE) ? "QS_MOUSEMOVE|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEBUTTON) ? "QS_MOUSEBUTTON|" : "",
+          (wayland->last_dispatch_mask & QS_INPUT) ? "QS_INPUT|" : "",
+          (wayland->last_dispatch_mask & QS_PAINT) ? "QS_PAINT|" : "",
+          (wayland->last_dispatch_mask & QS_POSTMESSAGE) ? "QS_POSTMESSAGE|" : "",
+          (wayland->last_dispatch_mask & QS_SENDMESSAGE) ? "QS_SENDMESSAGE|" : "");
+
+    return wayland->last_dispatch_mask & mask;
+}
+
+/***********************************************************************
+ *           WAYLAND_MsgWaitForMultipleObjectsEx
+ */
+DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                                DWORD timeout, DWORD mask, DWORD flags)
+{
+    DWORD ret;
+
+    if (process_wayland_events(mask))
+        return count - 1;
+
+    ret = WaitForMultipleObjectsEx(count, handles, flags & MWMO_WAITALL,
+                                   timeout, flags & MWMO_ALERTABLE);
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 65e84bd85a6..e0a86d10b3b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -68,6 +68,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    DWORD last_dispatch_mask;
     int event_notification_pipe[2];
     struct wl_list thread_link;
 };
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 48c3bb91cd3..59aca639149 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -3,6 +3,7 @@
 @ cdecl CreateWindow(long) WAYLAND_CreateWindow
 @ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
+@ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
 @ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) WAYLAND_WindowPosChanged
-- 
2.33.0


From c69bf96cac6aae424171efc204412ebf984b2737 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:38:29 +0300
Subject: [PATCH 028/125] winewayland.drv: Pointer and cursor support.

TODO

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in          |   2 +
 dlls/winewayland.drv/wayland.c            |  40 +++
 dlls/winewayland.drv/wayland_cursor.c     | 327 ++++++++++++++++++++++
 dlls/winewayland.drv/wayland_pointer.c    | 231 +++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  41 +++
 dlls/winewayland.drv/waylanddrv_main.c    |   2 +
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 7 files changed, 644 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_cursor.c
 create mode 100644 dlls/winewayland.drv/wayland_pointer.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 2861fb3b96f..962f0c2cf77 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -15,6 +15,8 @@ C_SRCS = \
 	wayland_output.c \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
+	wayland_cursor.c \
+	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
 	window.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9b99287d899..021c39dd878 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -60,6 +60,34 @@ static const struct xdg_wm_base_listener xdg_wm_base_listener = {
     xdg_wm_base_ping,
 };
 
+/**********************************************************************
+ *          Seat handling
+ */
+
+static void seat_handle_capabilities(void *data, struct wl_seat *seat,
+                                     enum wl_seat_capability caps)
+{
+    struct wayland *wayland = data;
+
+    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_init(&wayland->pointer, wayland, wl_seat_get_pointer(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_deinit(&wayland->pointer);
+    }
+}
+
+static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
+{
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+    seat_handle_name,
+};
+
 /**********************************************************************
  *          Registry handling
  */
@@ -92,6 +120,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
     }
+    else if (strcmp(interface, "wl_seat") == 0)
+    {
+        wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
+                                            version < 5 ? version : 5);
+        wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
+    }
     else if (strcmp(interface, "wl_output") == 0)
     {
         if (!wayland_output_create(wayland, id, version))
@@ -235,6 +269,12 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    if (wayland->pointer.wl_pointer)
+        wayland_pointer_deinit(&wayland->pointer);
+
+    if (wayland->wl_seat)
+        wl_seat_destroy(wayland->wl_seat);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
new file mode 100644
index 00000000000..c0c301de27e
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -0,0 +1,327 @@
+/*
+ * Wayland cursor handling
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static HCURSOR last_cursor;
+static HCURSOR invalid_cursor;
+
+/***********************************************************************
+ *           create_mono_cursor_buffer
+ *
+ * Return a monochrome icon/cursor wl_shm_buffer
+ */
+static struct wayland_shm_buffer *create_mono_cursor_buffer(struct wayland *wayland,
+                                                            HBITMAP bmp)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    BITMAP bm;
+    char *mask = NULL;
+    unsigned int i, j, stride, mask_size, *ptr;
+
+    if (!GetObjectW(bmp, sizeof(bm), &bm)) return NULL;
+    stride = ((bm.bmWidth + 15) >> 3) & ~1;
+    mask_size = stride * bm.bmHeight;
+    if (!(mask = heap_alloc(mask_size))) return NULL;
+    if (!GetBitmapBits(bmp, mask_size, mask)) goto done;
+
+    bm.bmHeight /= 2;
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto done;
+
+    ptr = shm_buffer->map_data;
+    for (i = 0; i < bm.bmHeight; i++)
+    {
+        for (j = 0; j < bm.bmWidth; j++, ptr++)
+        {
+            int and = ((mask[i * stride + j / 8] << (j % 8)) & 0x80);
+            int xor = ((mask[(i + bm.bmHeight) * stride + j / 8] << (j % 8)) & 0x80);
+            if (!xor && and)
+                *ptr = 0;
+            else if (xor && !and)
+                *ptr = 0xffffffff;
+            else
+                /* we can't draw "invert" pixels, so render them as black instead */
+                *ptr = 0xff000000;
+        }
+    }
+
+done:
+    heap_free(mask);
+    return shm_buffer;
+}
+
+/***********************************************************************
+ *           get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icons and cursors.
+ */
+static struct wayland_shm_buffer *create_color_cursor_buffer(struct wayland *wayland,
+                                                             HDC hdc, HBITMAP color,
+                                                             HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!GetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!GetDIBits(hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS)) goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = heap_alloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!GetDIBits(hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS)) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        heap_free(mask_bits);
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    heap_free(mask_bits);
+    return NULL;
+}
+
+
+static struct wayland_cursor *
+wayland_cursor_from_win32(struct wayland_pointer *pointer, HCURSOR handle)
+{
+    ICONINFOEXW info;
+    struct wayland_cursor *wayland_cursor = NULL;
+
+    if (!handle) goto failed;
+
+    wayland_cursor = heap_alloc_zero(sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto failed;
+
+    info.cbSize = sizeof(info);
+    if (!GetIconInfoExW(handle, &info)) goto failed;
+
+    if (info.hbmColor)
+    {
+        HDC hdc = CreateCompatibleDC(0);
+        wayland_cursor->shm_buffer =
+            create_color_cursor_buffer(pointer->wayland, hdc, info.hbmColor, info.hbmMask);
+        DeleteDC(hdc);
+    }
+    else
+    {
+        wayland_cursor->shm_buffer =
+            create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+    }
+
+    if (!wayland_cursor->shm_buffer) goto failed;
+
+    /* make sure hotspot is valid */
+    if (info.xHotspot >= wayland_cursor->shm_buffer->width ||
+        info.yHotspot >= wayland_cursor->shm_buffer->height)
+    {
+        info.xHotspot = wayland_cursor->shm_buffer->width / 2;
+        info.yHotspot = wayland_cursor->shm_buffer->height / 2;
+    }
+
+    if (pointer->focused_surface)
+    {
+        wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                 info.xHotspot, info.yHotspot,
+                                                 &wayland_cursor->hotspot_x,
+                                                 &wayland_cursor->hotspot_y);
+    }
+    else
+    {
+        wayland_cursor->hotspot_x = info.xHotspot;
+        wayland_cursor->hotspot_y = info.yHotspot;
+    }
+
+    DeleteObject(info.hbmColor);
+    DeleteObject(info.hbmMask);
+
+    return wayland_cursor;
+
+failed:
+    if (wayland_cursor)
+        wayland_cursor_destroy(wayland_cursor);
+
+    return NULL;
+}
+
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
+{
+    if (!wayland_cursor)
+        return;
+
+    if (wayland_cursor->shm_buffer)
+        wayland_shm_buffer_destroy(wayland_cursor->shm_buffer);
+}
+
+static void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                                     HCURSOR handle)
+{
+    struct wayland_cursor *wayland_cursor = pointer->cursor;
+
+    if (!pointer->wl_pointer)
+        return;
+
+    if (pointer->hcursor != handle)
+    {
+        wayland_cursor = wayland_cursor_from_win32(pointer, handle);
+        /* If we can't create a cursor from a valid handle, better to keep the
+         * previous cursor than make it disappear completely. */
+        if (!wayland_cursor && handle)
+            return;
+
+        if (pointer->cursor)
+            wayland_cursor_destroy(pointer->cursor);
+    }
+
+    pointer->cursor = wayland_cursor;
+    pointer->hcursor = handle;
+
+    if (!pointer->cursor)
+    {
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  NULL, 0, 0);
+            return;
+    }
+
+    wl_surface_attach(pointer->cursor_wl_surface,
+                      pointer->cursor->shm_buffer->wl_buffer,
+                      0, 0);
+    wl_surface_damage_buffer(pointer->cursor_wl_surface,
+                             0, 0,
+                             wayland_cursor->shm_buffer->width,
+                             wayland_cursor->shm_buffer->height);
+
+    wl_surface_commit(pointer->cursor_wl_surface);
+
+    wl_pointer_set_cursor(pointer->wl_pointer,
+                          pointer->enter_serial,
+                          pointer->cursor_wl_surface,
+                          pointer->cursor->hotspot_x,
+                          pointer->cursor->hotspot_y);
+}
+
+/***********************************************************************
+ *           wayland_init_set_cursor
+ *
+ *  Initalize internal information, so that we can track the last set
+ *  cursor properly.
+ */
+BOOL wayland_init_set_cursor(void)
+{
+    /* Allocate a handle that we are going to treat as invalid. */
+    SERVER_START_REQ(alloc_user_handle)
+    {
+        if (!wine_server_call_err(req))
+            invalid_cursor = wine_server_ptr_handle(reply->handle);
+    }
+    SERVER_END_REQ;
+
+    TRACE("invalid_cursor=%p\n", invalid_cursor);
+
+    last_cursor = invalid_cursor;
+
+    return invalid_cursor != NULL;
+}
+
+/***********************************************************************
+ *           wayland_invalidate_set_cursor
+ *
+ *  Invalidate the cursor we consider to be set, effectively forcing
+ *  the application of next SetCursor call.
+ */
+void wayland_invalidate_set_cursor(void)
+{
+    InterlockedExchangePointer((void **)&last_cursor, invalid_cursor);
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursor
+ */
+void CDECL WAYLAND_SetCursor(HCURSOR handle)
+{
+    TRACE("hcursor=%p last_cursor=%p\n", handle, last_cursor);
+
+    if (InterlockedExchangePointer((void **)&last_cursor, handle) != handle)
+    {
+        struct wayland *wayland = thread_wayland();
+
+        /* If a non GUI thread calls SetCursor, just ignore it, since it doesn't
+         * have any wayland surfaces and thus changing the cursor will not have
+         * any effect. */
+        if (wayland)
+            wayland_pointer_update_cursor_from_win32(&wayland->pointer, handle);
+        else
+            wayland_invalidate_set_cursor();
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
new file mode 100644
index 00000000000..a7a23905526
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -0,0 +1,231 @@
+/*
+ * Wayland input handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <linux/input.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          Pointer handling
+ */
+
+static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointer,
+                                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    int screen_x, screen_y;
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_screen(wayland->pointer.focused_surface,
+                                     wl_fixed_to_double(sx),
+                                     wl_fixed_to_double(sy),
+                                     &screen_x, &screen_y);
+
+    TRACE("surface=%p hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_double(sx), wl_fixed_to_double(sy),
+          screen_x, screen_y);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = screen_x;
+    input.mi.dy          = screen_y;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
+                                  uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    pointer_handle_motion_internal(data, pointer, time, sx, sy);
+}
+
+static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface,
+                                 wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    if (wayland_surface && wayland_surface->hwnd) {
+        TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
+        wayland->pointer.focused_surface = wayland_surface;
+        wayland->pointer.enter_serial = serial;
+        /* Invalidate the set cursor cache, so that next update is
+         * unconditionally applied. */
+        wayland_invalidate_set_cursor();
+        /* Handle the enter as a motion, to account for cases where the
+         * window first appears beneath the pointer and won't get a separate
+         * motion event. */
+        pointer_handle_motion_internal(data, pointer, 0, sx, sy);
+    }
+}
+
+static void pointer_handle_leave(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+
+    if (wayland->pointer.focused_surface &&
+        wayland->pointer.focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n",
+              wayland->pointer.focused_surface,
+              wayland->pointer.focused_surface->hwnd);
+        wayland->pointer.focused_surface = NULL;
+        wayland->pointer.enter_serial = 0;
+    }
+}
+
+static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+                                  uint32_t serial, uint32_t time, uint32_t button,
+                                  uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("button=%#x state=%#x hwnd=%p\n", button, state, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (button)
+    {
+    case BTN_LEFT: input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN; break;
+    case BTN_RIGHT: input.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN; break;
+    case BTN_MIDDLE: input.mi.dwFlags = MOUSEEVENTF_MIDDLEDOWN; break;
+    default: break;
+    }
+
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+        input.mi.dwFlags <<= 1;
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+                                uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
+{
+}
+
+static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
+                                       uint32_t axis_source)
+{
+}
+
+static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
+                                     uint32_t time, uint32_t axis)
+{
+}
+
+static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+                                         uint32_t axis, int32_t discrete)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("axis=%#x discrete=%d hwnd=%p\n", axis, discrete, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+        input.mi.mouseData = -WHEEL_DELTA * discrete;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+        input.mi.mouseData = WHEEL_DELTA * discrete;
+        break;
+    default: break;
+    }
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,
+    pointer_handle_leave,
+    pointer_handle_motion,
+    pointer_handle_button,
+    pointer_handle_axis,
+    pointer_handle_frame,
+    pointer_handle_axis_source,
+    pointer_handle_axis_stop,
+    pointer_handle_axis_discrete,
+};
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer)
+{
+    wayland->pointer.wayland = wayland;
+    wayland->pointer.wl_pointer = wl_pointer;
+    wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+    wayland->pointer.cursor_wl_surface =
+        wl_compositor_create_surface(wayland->wl_compositor);
+}
+
+void wayland_pointer_deinit(struct wayland_pointer *pointer)
+{
+    if (pointer->wl_pointer)
+        wl_pointer_destroy(pointer->wl_pointer);
+
+    if (pointer->cursor_wl_surface)
+        wl_surface_destroy(pointer->cursor_wl_surface);
+
+    if (pointer->cursor)
+        wayland_cursor_destroy(pointer->cursor);
+
+    memset(pointer, 0, sizeof(*pointer));
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e0a86d10b3b..c40a9e03707 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -52,6 +52,27 @@ enum wayland_configure_flags
  *          Definitions for wayland types
  */
 
+struct wayland_surface;
+struct wayland_shm_buffer;
+
+struct wayland_cursor
+{
+    struct wayland_shm_buffer *shm_buffer;
+    int hotspot_x;
+    int hotspot_y;
+};
+
+struct wayland_pointer
+{
+    struct wayland *wayland;
+    struct wl_pointer *wl_pointer;
+    struct wayland_surface *focused_surface;
+    struct wl_surface *cursor_wl_surface;
+    uint32_t enter_serial;
+    struct wayland_cursor *cursor;
+    HCURSOR hcursor;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -65,9 +86,11 @@ struct wayland
     struct wl_subcompositor *wl_subcompositor;
     struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
+    struct wl_seat *wl_seat;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
     struct wl_list thread_link;
@@ -171,6 +194,13 @@ static inline struct wayland *thread_init_wayland(void)
     return &wayland_init_thread_data()->wayland;
 }
 
+static inline struct wayland *thread_wayland(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+    if (!data) return NULL;
+    return &data->wayland;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
@@ -264,4 +294,15 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
 
+/**********************************************************************
+ *          Wayland Pointer/Cursor
+ */
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer);
+void wayland_pointer_deinit(struct wayland_pointer *pointer);
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor);
+BOOL wayland_init_set_cursor(void);
+void wayland_invalidate_set_cursor(void);
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 582993044de..3dbe2840ce3 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -128,6 +128,8 @@ static BOOL process_attach(void)
 
     if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
 
+    if (!wayland_init_set_cursor()) return FALSE;
+
     if (!wayland_process_init()) return FALSE;
 
     /* All reads of wayland events happen from a dedicated thread. */
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 59aca639149..ba6147fd363 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -4,6 +4,7 @@
 @ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
+@ cdecl SetCursor(long) WAYLAND_SetCursor
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
 @ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) WAYLAND_WindowPosChanged
-- 
2.33.0


From 64d70fe7be5f534215873ae1c61389571d11cd56 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:24:54 +0300
Subject: [PATCH 029/125] winewayland.drv: Basic handling of Wayland keyboard
 events.

Handle Wayland keyboard events and translate them to Windows events,
currently using a hardcoded US key mapping.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                     |  86 ++++-
 configure.ac                                  |   6 +-
 dlls/winewayland.drv/Makefile.in              |   5 +-
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_keyboard.c       | 312 ++++++++++++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 287 ++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             |  28 ++
 include/config.h.in                           |   3 +
 8 files changed, 735 insertions(+), 4 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard.c
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.h

diff --git a/configure.ac b/configure.ac
index 028f7d18cf1..f8717f10d5c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1293,10 +1293,14 @@ then
                    `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
     AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
                  [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
+    WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
+        [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
+         AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
-                           test -z "$WAYLAND_SCANNER"],
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$XKBCOMMON_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 962f0c2cf77..d9110eb0590 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32
-EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
-EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(XKBCOMMON_CFLAGS)
+EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -16,6 +16,7 @@ C_SRCS = \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_keyboard.c \
 	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 021c39dd878..b44a494b161 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -77,6 +77,15 @@ static void seat_handle_capabilities(void *data, struct wl_seat *seat,
     {
         wayland_pointer_deinit(&wayland->pointer);
     }
+
+    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_init(&wayland->keyboard, wayland, wl_seat_get_keyboard(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_deinit(&wayland->keyboard);
+    }
 }
 
 static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
@@ -272,6 +281,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->pointer.wl_pointer)
         wayland_pointer_deinit(&wayland->pointer);
 
+    if (wayland->keyboard.wl_keyboard)
+        wayland_keyboard_deinit(&wayland->keyboard);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
new file mode 100644
index 00000000000..2e4314d457e
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -0,0 +1,312 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013 Alexandre Julliard
+ * Copyright 2015 Josh DuBois for CodeWeavers Inc.
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <unistd.h>
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
+                                      xkb_keycode_t xkb_keycode)
+{
+    /* Use linux input keycode as scan code for now. */
+    return xkb_keycode - 8;
+}
+
+static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                 xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
+           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+}
+
+/* xkb keycodes are offset by 8 from linux input keycodes. */
+static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
+{
+    return key + 8;
+}
+
+static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
+{
+    INPUT input;
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input(hwnd, &input, NULL);
+}
+
+/* Get the vkey corresponding to an xkb keycode, potentially translating it to
+ * take into account the current keyboard state. */
+static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                          xkb_keycode_t xkb_keycode)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    if (((vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9) ||
+          vkey == VK_SEPARATOR || vkey == VK_DECIMAL) &&
+        !xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                      XKB_STATE_MODS_EFFECTIVE))
+    {
+        switch (vkey)
+        {
+        case VK_NUMPAD0: vkey = VK_INSERT; break;
+        case VK_NUMPAD1: vkey = VK_END; break;
+        case VK_NUMPAD2: vkey = VK_DOWN; break;
+        case VK_NUMPAD3: vkey = VK_NEXT; break;
+        case VK_NUMPAD4: vkey = VK_LEFT; break;
+        case VK_NUMPAD5: vkey = 0; break;
+        case VK_NUMPAD6: vkey = VK_RIGHT; break;
+        case VK_NUMPAD7: vkey = VK_HOME; break;
+        case VK_NUMPAD8: vkey = VK_UP; break;
+        case VK_NUMPAD9: vkey = VK_PRIOR; break;
+        case VK_SEPARATOR: vkey = VK_DELETE; break;
+        case VK_DECIMAL: vkey = VK_DELETE; break;
+        default: break;
+        }
+    }
+    else if (vkey == VK_PAUSE &&
+             xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                          XKB_MOD_NAME_CTRL,
+                                          XKB_STATE_MODS_EFFECTIVE))
+    {
+        vkey = VK_CANCEL;
+    }
+
+    return vkey;
+}
+
+static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
+                                  uint32_t state, HWND hwnd)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+    UINT scan = _xkb_keycode_to_scancode(keyboard, xkb_keycode);
+    DWORD flags;
+
+    TRACE_(key)("xkb_keycode=%u vkey=0x%x scan=0x%x state=%d hwnd=%p\n",
+                xkb_keycode, vkey, scan, state, hwnd);
+
+    if (vkey == 0) return;
+
+    flags = 0;
+    if (state == WL_KEYBOARD_KEY_STATE_RELEASED) flags |= KEYEVENTF_KEYUP;
+    if (scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+
+    send_keyboard_input(hwnd, vkey, scan & 0xff, flags);
+}
+
+/**********************************************************************
+ *          Keyboard handling
+ */
+
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                                   uint32_t format, int fd, uint32_t size)
+{
+    close(fd);
+}
+
+static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                                  uint32_t serial, struct wl_surface *surface,
+                                  struct wl_array *keys)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    if (wayland_surface && wayland_surface->hwnd)
+    {
+        TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
+        wayland->keyboard.focused_surface = wayland_surface;
+        wayland->keyboard.enter_serial = serial;
+    }
+}
+
+static void keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+        uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+
+    if (wayland->keyboard.focused_surface &&
+        wayland->keyboard.focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n",
+              wayland->keyboard.focused_surface,
+              wayland->keyboard.focused_surface->hwnd);
+        KillTimer(wayland->keyboard.focused_surface->hwnd, (UINT_PTR)keyboard);
+        wayland->keyboard.focused_surface = NULL;
+        wayland->keyboard.enter_serial = 0;
+    }
+}
+
+static void CALLBACK repeat_key(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    if (wayland->keyboard.repeat_interval_ms > 0)
+    {
+        wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.pressed_key,
+                              WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
+
+        SetTimer(hwnd, timer_id, wayland->keyboard.repeat_interval_ms,
+                 repeat_key);
+    }
+}
+
+static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->keyboard.focused_surface ?
+                        wayland->keyboard.focused_surface->hwnd : 0;
+    UINT_PTR repeat_key_timer_id = (UINT_PTR)keyboard;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
+
+    wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+
+    wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd);
+
+    if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+    {
+        wayland->keyboard.pressed_key = key;
+        if (wayland->keyboard.repeat_interval_ms > 0)
+        {
+            SetTimer(focused_hwnd, repeat_key_timer_id, wayland->keyboard.repeat_delay_ms,
+                     repeat_key);
+        }
+    }
+    else
+    {
+        wayland->keyboard.pressed_key = 0;
+        KillTimer(focused_hwnd, repeat_key_timer_id);
+    }
+}
+
+static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched, uint32_t mods_locked,
+                                      uint32_t group)
+{
+    struct wayland *wayland = data;
+
+    TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
+          mods_depressed, mods_latched, mods_locked, group);
+
+    if (!wayland->keyboard.xkb_state) return;
+
+    xkb_state_update_mask(wayland->keyboard.xkb_state,
+                          mods_depressed, mods_latched, mods_locked, 0, 0, group);
+}
+
+static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
+                                        int rate, int delay)
+{
+    struct wayland *wayland = data;
+
+    TRACE("rate=%d delay=%d\n", rate, delay);
+
+    /* Handle non-negative rate values, ignore invalid (negative) values.  A
+     * rate of 0 disables repeat. Note that a requested rate value larger than
+     * 100 may not actually lead to the desired repeat rate, since we are
+     * constrained by the USER_TIMER_MINIMUM (=10ms) resolution of win32
+     * timers. */
+    if (rate > 1000)
+        wayland->keyboard.repeat_interval_ms = 1;
+    else if (rate > 0)
+        wayland->keyboard.repeat_interval_ms = 1000 / rate;
+    else if (rate == 0)
+        wayland->keyboard.repeat_interval_ms = 0;
+
+    wayland->keyboard.repeat_delay_ms = delay;
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+/***********************************************************************
+ *           wayland_keyboard_init
+ */
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard)
+{
+    keyboard->wl_keyboard = wl_keyboard;
+    /* Some sensible default values for the repeat rate and delay. */
+    keyboard->repeat_interval_ms = 40;
+    keyboard->repeat_delay_ms = 400;
+    keyboard->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (!keyboard->xkb_context)
+    {
+        ERR("Failed to create XKB context\n");
+        return;
+    }
+
+    wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
+}
+
+/***********************************************************************
+ *           wayland_keyboard_deinit
+ */
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
+{
+    if (keyboard->wl_keyboard)
+        wl_keyboard_destroy(keyboard->wl_keyboard);
+
+    xkb_state_unref(keyboard->xkb_state);
+    xkb_context_unref(keyboard->xkb_context);
+
+    memset(keyboard, 0, sizeof(*keyboard));
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
new file mode 100644
index 00000000000..58a14aac378
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -0,0 +1,287 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * This header file contains the tables used by keyboard_layout.c
+ * to perform layout mapping.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+#define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+
+static const UINT xkb_keycode_to_vkey_us[] =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,
+    0,                   /* KEY_RESERVED  0 */
+    VK_ESCAPE,           /* KEY_ESC   1 */
+    '1',                 /* KEY_1   2 */
+    '2',                 /* KEY_2   3 */
+    '3',                 /* KEY_3   4 */
+    '4',                 /* KEY_4   5 */
+    '5',                 /* KEY_5   6 */
+    '6',                 /* KEY_6   7 */
+    '7',                 /* KEY_7   8 */
+    '8',                 /* KEY_8   9 */
+    '9',                 /* KEY_9   10 */
+    '0',                 /* KEY_0   11 */
+    VK_OEM_MINUS,        /* KEY_MINUS  12 */
+    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
+    VK_BACK,             /* KEY_BACKSPACE 14 */
+    VK_TAB,              /* KEY_TAB   15 */
+    'Q',                 /* KEY_Q   16 */
+    'W',                 /* KEY_W   17 */
+    'E',                 /* KEY_E   18 */
+    'R',                 /* KEY_R   19 */
+    'T',                 /* KEY_T   20 */
+    'Y',                 /* KEY_Y   21 */
+    'U',                 /* KEY_U   22 */
+    'I',                 /* KEY_I   23 */
+    'O',                 /* KEY_O   24 */
+    'P',                 /* KEY_P   25 */
+    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
+    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
+    VK_RETURN,           /* KEY_ENTER  28 */
+    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
+    'A',                 /* KEY_A   30 */
+    'S',                 /* KEY_S   31 */
+    'D',                 /* KEY_D   32 */
+    'F',                 /* KEY_F   33 */
+    'G',                 /* KEY_G   34 */
+    'H',                 /* KEY_H   35 */
+    'J',                 /* KEY_J   36 */
+    'K',                 /* KEY_K   37 */
+    'L',                 /* KEY_L   38 */
+    VK_OEM_1,            /* KEY_SEMICOLON  39 */
+    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
+    VK_OEM_3,            /* KEY_GRAVE  41 */
+    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
+    VK_OEM_5,            /* KEY_BACKSLASH  43 */
+    'Z',                 /* KEY_Z   44 */
+    'X',                 /* KEY_X   45 */
+    'C',                 /* KEY_C   46 */
+    'V',                 /* KEY_V   47 */
+    'B',                 /* KEY_B   48 */
+    'N',                 /* KEY_N   49 */
+    'M',                 /* KEY_M   50 */
+    VK_OEM_COMMA,        /* KEY_COMMA  51 */
+    VK_OEM_PERIOD,       /* KEY_DOT   52 */
+    VK_OEM_2,            /* KEY_SLASH  53 */
+    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
+    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
+    VK_LMENU,            /* KEY_LEFTALT  56 */
+    VK_SPACE,            /* KEY_SPACE  57 */
+    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
+    VK_F1,               /* KEY_F1   59 */
+    VK_F2,               /* KEY_F2   60 */
+    VK_F3,               /* KEY_F3   61 */
+    VK_F4,               /* KEY_F4   62 */
+    VK_F5,               /* KEY_F5   63 */
+    VK_F6,               /* KEY_F6   64 */
+    VK_F7,               /* KEY_F7   65 */
+    VK_F8,               /* KEY_F8   66 */
+    VK_F9,               /* KEY_F9   67 */
+    VK_F10,              /* KEY_F10   68 */
+    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
+    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
+    VK_NUMPAD7,          /* KEY_KP7   71 */
+    VK_NUMPAD8,          /* KEY_KP8   72 */
+    VK_NUMPAD9,          /* KEY_KP9   73 */
+    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
+    VK_NUMPAD4,          /* KEY_KP4   75 */
+    VK_NUMPAD5,          /* KEY_KP5   76 */
+    VK_NUMPAD6,          /* KEY_KP6   77 */
+    VK_ADD,              /* KEY_KPPLUS  78 */
+    VK_NUMPAD1,          /* KEY_KP1   79 */
+    VK_NUMPAD2,          /* KEY_KP2   80 */
+    VK_NUMPAD3,          /* KEY_KP3   81 */
+    VK_NUMPAD0,          /* KEY_KP0   82 */
+    VK_DECIMAL,          /* KEY_KPDOT  83 */
+    0,                   /* 84 */
+    0,                   /* KEY_ZENKAKUHANKAKU 85 */
+    VK_OEM_102,          /* KEY_102ND  86 */
+    VK_F11,              /* KEY_F11   87 */
+    VK_F12,              /* KEY_F12   88 */
+    0,                   /* KEY_RO   89 */
+    0,                   /* KEY_KATAKANA  90 */
+    0,                   /* KEY_HIRAGANA  91 */
+    0,                   /* KEY_HENKAN  92 */
+    0,                   /* KEY_KATAKANAHIRAGANA 93 */
+    0,                   /* KEY_MUHENKAN  94 */
+    0,                   /* KEY_KPJPCOMMA  95 */
+    VK_RETURN,           /* KEY_KPENTER  96 */
+    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
+    VK_DIVIDE,           /* KEY_KPSLASH  98 */
+    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
+    VK_RMENU,            /* KEY_RIGHTALT  100 */
+    0,                   /* KEY_LINEFEED  101 */
+    VK_HOME,             /* KEY_HOME  102 */
+    VK_UP,               /* KEY_UP   103 */
+    VK_PRIOR,            /* KEY_PAGEUP  104 */
+    VK_LEFT,             /* KEY_LEFT  105 */
+    VK_RIGHT,            /* KEY_RIGHT  106 */
+    VK_END,              /* KEY_END   107 */
+    VK_DOWN,             /* KEY_DOWN  108 */
+    VK_NEXT,             /* KEY_PAGEDOWN  109 */
+    VK_INSERT,           /* KEY_INSERT  110 */
+    VK_DELETE,           /* KEY_DELETE  111 */
+    0,                   /* KEY_MACRO  112 */
+    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
+    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
+    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
+    0,                   /* KEY_POWER  116  */
+    0,                   /* KEY_KPEQUAL  117 */
+    0,                   /* KEY_KPPLUSMINUS  118 */
+    VK_PAUSE,            /* KEY_PAUSE  119 */
+    0,                   /* KEY_SCALE  120  */
+    0,                   /* KEY_KPCOMMA  121 */
+    0,                   /* KEY_HANGEUL  122 */
+    0,                   /* KEY_HANJA  123 */
+    0,                   /* KEY_YEN   124 */
+    VK_LWIN,             /* KEY_LEFTMETA  125 */
+    VK_RWIN,             /* KEY_RIGHTMETA  126 */
+    0,                   /* KEY_COMPOSE  127 */
+    0,                   /* KEY_STOP  128  */
+    0,                   /* KEY_AGAIN  129 */
+    0,                   /* KEY_PROPS  130  */
+    0,                   /* KEY_UNDO  131  */
+    0,                   /* KEY_FRONT  132 */
+    0,                   /* KEY_COPY  133  */
+    0,                   /* KEY_OPEN  134  */
+    0,                   /* KEY_PASTE  135  */
+    0,                   /* KEY_FIND  136  */
+    0,                   /* KEY_CUT   137  */
+    0,                   /* KEY_HELP  138  */
+    0,                   /* KEY_MENU  139  */
+    0,                   /* KEY_CALC  140  */
+    0,                   /* KEY_SETUP  141 */
+    0,                   /* KEY_SLEEP  142  */
+    0,                   /* KEY_WAKEUP  143  */
+    0,                   /* KEY_FILE  144  */
+    0,                   /* KEY_SENDFILE  145 */
+    0,                   /* KEY_DELETEFILE  146 */
+    0,                   /* KEY_XFER  147 */
+    0,                   /* KEY_PROG1  148 */
+    0,                   /* KEY_PROG2  149 */
+    0,                   /* KEY_WWW   150  */
+    0,                   /* KEY_MSDOS  151 */
+    0,                   /* KEY_COFFEE  152 */
+    0,                   /* KEY_ROTATE_DISPLAY 153  */
+    0,                   /* KEY_CYCLEWINDOWS 154 */
+    0,                   /* KEY_MAIL  155 */
+    0,                   /* KEY_BOOKMARKS  156  */
+    0,                   /* KEY_COMPUTER  157 */
+    0,                   /* KEY_BACK  158  */
+    0,                   /* KEY_FORWARD  159  */
+    0,                   /* KEY_CLOSECD  160 */
+    0,                   /* KEY_EJECTCD  161 */
+    0,                   /* KEY_EJECTCLOSECD 162 */
+    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
+    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
+    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
+    0,                   /* KEY_STOPCD  166 */
+    0,                   /* KEY_RECORD  167 */
+    0,                   /* KEY_REWIND  168 */
+    0,                   /* KEY_PHONE  169  */
+    0,                   /* KEY_ISO   170 */
+    0,                   /* KEY_CONFIG  171  */
+    0,                   /* KEY_HOMEPAGE  172  */
+    0,                   /* KEY_REFRESH  173  */
+    0,                   /* KEY_EXIT  174  */
+    0,                   /* KEY_MOVE  175 */
+    0,                   /* KEY_EDIT  176 */
+    0,                   /* KEY_SCROLLUP  177 */
+    0,                   /* KEY_SCROLLDOWN  178 */
+    0,                   /* KEY_KPLEFTPAREN  179 */
+    0,                   /* KEY_KPRIGHTPAREN 180 */
+    0,                   /* KEY_NEW   181  */
+    0,                   /* KEY_REDO  182  */
+    VK_F13,              /* KEY_F13   183 */
+    VK_F14,              /* KEY_F14   184 */
+    VK_F15,              /* KEY_F15   185 */
+    VK_F16,              /* KEY_F16   186 */
+    VK_F17,              /* KEY_F17   187 */
+    VK_F18,              /* KEY_F18   188 */
+    VK_F19,              /* KEY_F19   189 */
+    VK_F20,              /* KEY_F20   190 */
+    VK_F21,              /* KEY_F21   191 */
+    VK_F22,              /* KEY_F22   192 */
+    VK_F23,              /* KEY_F23   193 */
+    VK_F24,              /* KEY_F24   194 */
+    0,                   /* 195 */
+    0,                   /* 196 */
+    0,                   /* 197 */
+    0,                   /* 198 */
+    0,                   /* 199 */
+    0,                   /* KEY_PLAYCD  200 */
+    0,                   /* KEY_PAUSECD  201 */
+    0,                   /* KEY_PROG3  202 */
+    0,                   /* KEY_PROG4  203 */
+    0,                   /* KEY_DASHBOARD  204  */
+    0,                   /* KEY_SUSPEND  205 */
+    0,                   /* KEY_CLOSE  206  */
+    VK_PLAY,             /* KEY_PLAY  207 */
+    0,                   /* KEY_FASTFORWARD  208 */
+    0,                   /* KEY_BASSBOOST  209 */
+    VK_PRINT,            /* KEY_PRINT  210  */
+    0,                   /* KEY_HP   211 */
+    0,                   /* KEY_CAMERA  212 */
+    0,                   /* KEY_SOUND  213 */
+    0,                   /* KEY_QUESTION  214  */
+    0,                   /* KEY_EMAIL  215 */
+    0,                   /* KEY_CHAT  216 */
+    0,                   /* KEY_SEARCH  217 */
+    0,                   /* KEY_CONNECT  218 */
+    0,                   /* KEY_FINANCE  219  */
+    0,                   /* KEY_SPORT  220 */
+    0,                   /* KEY_SHOP  221 */
+    0,                   /* KEY_ALTERASE  222 */
+    0,                   /* KEY_CANCEL  223  */
+    0,                   /* KEY_BRIGHTNESSDOWN 224 */
+    0,                   /* KEY_BRIGHTNESSUP 225 */
+    0,                   /* KEY_MEDIA  226 */
+    0,                   /* KEY_SWITCHVIDEOMODE 227  */
+    0,                   /* KEY_KBDILLUMTOGGLE 228 */
+    0,                   /* KEY_KBDILLUMDOWN 229 */
+    0,                   /* KEY_KBDILLUMUP  230 */
+    0,                   /* KEY_SEND  231  */
+    0,                   /* KEY_REPLY  232  */
+    0,                   /* KEY_FORWARDMAIL  233  */
+    0,                   /* KEY_SAVE  234  */
+    0,                   /* KEY_DOCUMENTS  235 */
+    0,                   /* KEY_BATTERY  236 */
+    0,                   /* KEY_BLUETOOTH  237 */
+    0,                   /* KEY_WLAN  238 */
+    0,                   /* KEY_UWB   239  */
+    0,                   /* KEY_UNKNOWN  240 */
+    0,                   /* KEY_VIDEO_NEXT  241  */
+    0,                   /* KEY_VIDEO_PREV  242  */
+    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
+    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
+    0,                   /* KEY_DISPLAY_OFF  245  */
+    0,                   /* KEY_WWAN  246  */
+    0,                   /* KEY_RFKILL  247  */
+    0,                   /* KEY_MICMUTE  248  */
+};
+
+#endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c40a9e03707..aad3cf3025b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -27,6 +27,7 @@
 
 #include <stdarg.h>
 #include <wayland-client.h>
+#include <xkbcommon/xkbcommon.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -55,6 +56,18 @@ enum wayland_configure_flags
 struct wayland_surface;
 struct wayland_shm_buffer;
 
+struct wayland_keyboard
+{
+    struct wl_keyboard *wl_keyboard;
+    struct wayland_surface *focused_surface;
+    int repeat_interval_ms;
+    int repeat_delay_ms;
+    uint32_t pressed_key;
+    uint32_t enter_serial;
+    struct xkb_context *xkb_context;
+    struct xkb_state *xkb_state;
+};
+
 struct wayland_cursor
 {
     struct wayland_shm_buffer *shm_buffer;
@@ -90,6 +103,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
@@ -294,6 +308,14 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
 
+/**********************************************************************
+ *          Wayland Keyboard
+ */
+
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard);
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard);
+
 /**********************************************************************
  *          Wayland Pointer/Cursor
  */
@@ -305,4 +327,10 @@ void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor);
 BOOL wayland_init_set_cursor(void);
 void wayland_invalidate_set_cursor(void);
 
+/**********************************************************************
+ *          XKB helpers
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state);
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size);
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/include/config.h.in b/include/config.h.in
index 55264ce7393..d025830a82d 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -965,6 +965,9 @@
 /* Define if you have the XKB extension */
 #undef HAVE_XKB
 
+/* Define to 1 if you have the <xkbcommon/xkbcommon.h> header file. */
+#undef HAVE_XKBCOMMON_XKBCOMMON_H
+
 /* Define if libxml2 has the xmlDocProperties enum */
 #undef HAVE_XMLDOC_PROPERTIES
 
-- 
2.33.0


From 2b09338a23eb8ad24b61e731f07347627a33a159 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:55:18 +0300
Subject: [PATCH 030/125] winewayland.drv: Basic support for Wayland keymaps.

Handle the keymap information sent by the compositor, and try to match
the keycodes in the keymap to keys from a keyboard layout, in order to
be able to provide to virtual key and scan codes for each keycode.

Keyboard layouts are structures that contain information about the
virtual key code and scan code corresponding to each physical key, as
well as the xkb_keysym_t symbols emitted by each key for the normal and
shift states.

Each Wayland keycode is mapped to a layout key based on the similarity
of the symbols this keycode produces in the active Wayland keymap, to
the symbols for the key in the keyboard layout.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |   2 +
 dlls/winewayland.drv/wayland_keyboard.c       |  52 +-
 .../winewayland.drv/wayland_keyboard_layout.c | 205 ++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 446 ++++++++----------
 dlls/winewayland.drv/waylanddrv.h             |   3 +
 dlls/winewayland.drv/xkb_util.c               |  76 +++
 6 files changed, 527 insertions(+), 257 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.c
 create mode 100644 dlls/winewayland.drv/xkb_util.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d9110eb0590..df29e600695 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -17,11 +17,13 @@ C_SRCS = \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
 	wayland_keyboard.c \
+	wayland_keyboard_layout.c \
 	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
 	window.c \
 	window_surface.c \
+	xkb_util.c \
 
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 2e4314d457e..48141b04e71 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -38,25 +38,24 @@
 
 #include "winuser.h"
 
+#include <sys/mman.h>
 #include <unistd.h>
 
-#include "wayland_keyboard_layout.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
 static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
                                       xkb_keycode_t xkb_keycode)
 {
-    /* Use linux input keycode as scan code for now. */
-    return xkb_keycode - 8;
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode) ?
+           keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
 }
 
 static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
                                  xkb_keycode_t xkb_keycode)
 {
-    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
-           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey) ?
+           keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
 }
 
 /* xkb keycodes are offset by 8 from linux input keycodes. */
@@ -146,6 +145,40 @@ static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t ke
 static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
                                    uint32_t format, int fd, uint32_t size)
 {
+    struct wayland *wayland = data;
+    struct xkb_keymap *xkb_keymap = NULL;
+    struct xkb_state *xkb_state = NULL;
+    char *keymap_str;
+
+    TRACE("format=%d fd=%d size=%d\n", format, fd, size);
+
+    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 ||
+        !wayland->keyboard.xkb_context)
+        goto out;
+
+    keymap_str = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (!keymap_str)
+        goto out;
+
+    xkb_keymap = xkb_keymap_new_from_string(wayland->keyboard.xkb_context,
+                                            keymap_str,
+                                            XKB_KEYMAP_FORMAT_TEXT_V1,
+                                            0);
+    munmap(keymap_str, size);
+    if (!xkb_keymap)
+        goto out;
+
+    xkb_state = xkb_state_new(xkb_keymap);
+    xkb_keymap_unref(xkb_keymap);
+    if (!xkb_state)
+        goto out;
+
+    xkb_state_unref(wayland->keyboard.xkb_state);
+    wayland->keyboard.xkb_state = xkb_state;
+
+    wayland_keyboard_update_layout(&wayland->keyboard);
+
+out:
     close(fd);
 }
 
@@ -236,14 +269,21 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
                                       uint32_t group)
 {
     struct wayland *wayland = data;
+    uint32_t last_group;
 
     TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
           mods_depressed, mods_latched, mods_locked, group);
 
     if (!wayland->keyboard.xkb_state) return;
 
+    last_group = _xkb_state_get_active_layout(wayland->keyboard.xkb_state);
+
     xkb_state_update_mask(wayland->keyboard.xkb_state,
                           mods_depressed, mods_latched, mods_locked, 0, 0, group);
+
+    if (group != last_group)
+        wayland_keyboard_update_layout(&wayland->keyboard);
+
 }
 
 static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
new file mode 100644
index 00000000000..60786cce7d2
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -0,0 +1,205 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ime.h"
+#include "winuser.h"
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
+                         const xkb_keysym_t ref[MAIN_KEY_SYMBOLS_LEN])
+{
+    int score = 0, i;
+
+    for (i = 0; i < MAIN_KEY_SYMBOLS_LEN && ref[i]; i++)
+    {
+        if (ref[i] != sym[i]) return 0;
+        score++;
+    }
+
+    return score;
+}
+
+static void _xkb_keymap_populate_symbols_for_keycode(
+    struct xkb_keymap *xkb_keymap,
+    xkb_layout_index_t layout,
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+    if (max_xkb_keycode > 255) max_xkb_keycode = 255;
+
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        if (num_levels > MAIN_KEY_SYMBOLS_LEN) num_levels = MAIN_KEY_SYMBOLS_LEN;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+            if (nsyms)
+                symbols_for_keycode[xkb_keycode][level] = syms[0];
+        }
+    }
+}
+
+/* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
+ * the specified main_key layout (see wayland_keyboard_layout.h) and the
+ * xkb_keycode to xkb_keysym_t mappings which have been created from the
+ * currently active Wayland keymap. */
+static void populate_xkb_keycode_maps(struct wayland_keyboard *keyboard, int main_key_layout,
+                                      const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+    const xkb_keysym_t (*lsymbols)[MAIN_KEY_SYMBOLS_LEN] =
+        (*main_key_tab[main_key_layout].symbols);
+    const WORD *lvkey = (*main_key_tab[main_key_layout].vkey);
+    const WORD *lscan = (*main_key_tab[main_key_layout].scan);
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int max_key = -1;
+        int max_score = 0;
+        xkb_keysym_t xkb_keysym = symbols_for_keycode[xkb_keycode][0];
+        UINT vkey = 0;
+        WORD scan = 0;
+
+        /* Map keypad keys to their num-locked values (i.e., second level), to
+         * avoid confusion with the dedicated keys with the same functions. */
+        if (xkb_keysym >= XKB_KEY_KP_Home && xkb_keysym <= XKB_KEY_KP_Delete)
+            xkb_keysym = symbols_for_keycode[xkb_keycode][1];
+
+        if ((xkb_keysym >> 8) == 0xFF)
+        {
+            vkey = xkb_keysym_0xff00_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_0xff00_to_scan[xkb_keysym & 0xff];
+        }
+        else if ((xkb_keysym >> 8) == 0x1008FF)
+        {
+            vkey = xkb_keysym_xfree86_to_vkey[xkb_keysym & 0xff];
+            /* All vendor keys are extended with a scan code of 0 per testing
+             * on WinXP */
+            scan = 0x100;
+        }
+        else if (xkb_keysym == 0x20)
+        {
+            vkey = VK_SPACE;
+            scan = 0x39;
+        }
+        else
+        {
+            int key;
+
+            for (key = 0; key < MAIN_KEY_LEN; key++)
+            {
+                int score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                          lsymbols[key]);
+                /* Consider this key if it has a better score, or the same
+                 * score as a previous match that is already in use (in order
+                 * to prefer unused keys). */
+                if (score > max_score ||
+                    (max_key >= 0 && score == max_score && key_used[max_key]))
+                {
+                    max_key = key;
+                    max_score = score;
+                }
+            }
+
+            if (max_key >= 0)
+            {
+                vkey = lvkey[max_key];
+                scan = lscan[max_key];
+                key_used[max_key] = 1;
+            }
+        }
+
+        keyboard->xkb_keycode_to_vkey[xkb_keycode] = vkey;
+        keyboard->xkb_keycode_to_scancode[xkb_keycode] = scan;
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols_for_keycode[xkb_keycode],
+                                 MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("Mapped xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' => "
+                        "vkey=0x%x scan=0x%x\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, vkey, scan);
+        }
+    }
+}
+
+/***********************************************************************
+ *           wayland_keyboard_update_layout
+ *
+ * Updates the internal weston_keyboard layout information (xkb keycode
+ * mappings etc) based on the current XKB layout.
+ */
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
+{
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = keyboard->xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+
+    if (!xkb_state)
+    {
+        TRACE("no xkb state, returning\n");
+        return;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE("no active layout, returning\n");
+        return;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+
+    _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, 0, symbols_for_keycode);
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
index 58a14aac378..2eafb6d2cb5 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.h
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -30,258 +30,202 @@
 #ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
 #define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
 
-static const UINT xkb_keycode_to_vkey_us[] =
+#define MAIN_KEY_LEN 50
+/* We currently use two symbols (levels) per key to differentiate layouts. */
+#define MAIN_KEY_SYMBOLS_LEN 2
+
+/* Windows uses PS/2 scan code set 1 for the scan codes sent to applications. */
+static const WORD main_key_scan_ps2_set1[MAIN_KEY_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x7D,
+    /* Row D: AD01-AD12 */
+    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,
+    /* Row C: AC01-AC12 */
+    0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2B,
+    /* Row B: LSGT, AB01-AB11 */
+    0x56,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x73
+};
+
+static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+#define K(x) XKB_KEY_##x
+
+static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+#undef K
+
+/*** Layout table. Add your keyboard mappings to this list */
+static struct {
+    LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
+                 in the appropriate dlls/kernel/nls/.nls file */
+    const char *name;
+    const xkb_keysym_t (*symbols)[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN];
+    const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
+    const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
+} main_key_tab[]={
+    {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+};
+
+static const WORD xkb_keysym_0xff00_to_vkey[256] =
+{
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF00 */
+    /* special keys */
+    VK_BACK, VK_TAB, 0, VK_CLEAR, 0, VK_RETURN, 0, 0,           /* FF08 */
+    0, 0, 0, VK_PAUSE, VK_SCROLL, 0, 0, 0,                      /* FF10 */
+    0, 0, 0, VK_ESCAPE, 0, 0, 0, 0,                             /* FF18 */
+    /* Japanese special keys */
+    0, VK_KANJI, VK_NONCONVERT, VK_CONVERT,                     /* FF20 */
+    VK_DBE_ROMAN, 0, 0, VK_DBE_HIRAGANA,
+    0, 0, VK_DBE_SBCSCHAR, 0, 0, 0, 0, 0,                       /* FF28 */
+    /* Korean special keys (FF31-) */
+    VK_DBE_ALPHANUMERIC, VK_HANGUL, 0, 0, VK_HANJA, 0, 0, 0,    /* FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF38 */
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF48 */
+    /* cursor keys */
+    VK_HOME, VK_LEFT, VK_UP, VK_RIGHT,                          /* FF50 */
+    VK_DOWN, VK_PRIOR, VK_NEXT, VK_END,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF58 */
+    /* misc keys */
+    VK_SELECT, VK_SNAPSHOT, VK_EXECUTE, VK_INSERT, 0,0,0, VK_APPS, /* FF60 */
+    0, VK_CANCEL, VK_HELP, VK_CANCEL, 0, 0, 0, 0,               /* FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF70 */
+    /* keypad keys */
+    0, 0, 0, 0, 0, 0, 0, VK_NUMLOCK,                            /* FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF80 */
+    0, 0, 0, 0, 0, VK_RETURN, 0, 0,                             /* FF88 */
+    0, 0, 0, 0, 0, VK_HOME, VK_LEFT, VK_UP,                     /* FF90 */
+    VK_RIGHT, VK_DOWN, VK_PRIOR, VK_NEXT,                       /* FF98 */
+    VK_END, VK_CLEAR, VK_INSERT, VK_DELETE,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFA0 */
+    0, 0, VK_MULTIPLY, VK_ADD,                                  /* FFA8 */
+    /* Windows always generates VK_DECIMAL for Del/. on keypad while some
+     * X11 keyboard layouts generate XK_KP_Separator instead of XK_KP_Decimal
+     * in order to produce a locale dependent numeric separator.
+     */
+    VK_DECIMAL, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
+    VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3,             /* FFB0 */
+    VK_NUMPAD4, VK_NUMPAD5, VK_NUMPAD6, VK_NUMPAD7,
+    VK_NUMPAD8, VK_NUMPAD9, 0, 0, 0, VK_OEM_NEC_EQUAL,          /* FFB8 */
+    /* function keys */
+    VK_F1, VK_F2,
+    VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10,    /* FFC0 */
+    VK_F11, VK_F12, VK_F13, VK_F14, VK_F15, VK_F16, VK_F17, VK_F18, /* FFC8 */
+    VK_F19, VK_F20, VK_F21, VK_F22, VK_F23, VK_F24, 0, 0,       /* FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFD8 */
+    /* modifier keys */
+    0, VK_LSHIFT, VK_RSHIFT, VK_LCONTROL,                       /* FFE0 */
+    VK_RCONTROL, VK_CAPITAL, 0, VK_LMENU,
+    VK_RMENU, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN, 0, 0, 0,    /* FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFF0 */
+    0, 0, 0, 0, 0, 0, 0, VK_DELETE                              /* FFF8 */
+};
+
+static const WORD xkb_keysym_0xff00_to_scan[256] =
+{
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF00 */
+    /* special keys */
+    0x0E, 0x0F, 0x00, /*?*/ 0, 0x00, 0x1C, 0x00, 0x00,           /* FF08 */
+    0x00, 0x00, 0x00, 0x45, 0x46, 0x00, 0x00, 0x00,              /* FF10 */
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,              /* FF18 */
+    /* Japanese special keys */
+    0x00, 0x29, 0x7B, 0x79, 0x70, 0x00, 0x00, 0x70,              /* FF20 */
+    0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF28 */
+    /* Korean special keys (FF31-) */
+    0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF30 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF38 */
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF40 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF48 */
+    /* cursor keys */
+    0x147, 0x14B, 0x148, 0x14D, 0x150, 0x149, 0x151, 0x14F,      /* FF50 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF58 */
+    /* misc keys */
+    /*?*/ 0, 0x137, /*?*/ 0, 0x152, 0x00, 0x00, 0x00, 0x15D,     /* FF60 */
+    /*?*/ 0, /*?*/ 0, 0x38, 0x146, 0x00, 0x00, 0x00, 0x00,       /* FF68 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF70 */
+    /* keypad keys */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x145,             /* FF78 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF80 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x11C, 0x00, 0x00,             /* FF88 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4B, 0x48,              /* FF90 */
+    0x4D, 0x50, 0x49, 0x51, 0x4F, 0x4C, 0x52, 0x53,              /* FF98 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFA0 */
+    0x00, 0x00, 0x37, 0x4E, 0x53, 0x4A, 0x53, 0x135,             /* FFA8 */
+    0x52, 0x4F, 0x50, 0x51, 0x4B, 0x4C, 0x4D, 0x47,              /* FFB0 */
+    0x48, 0x49, 0x00, 0x00, 0x00, 0x00,                          /* FFB8 */
+    /* function keys */
+    0x3B, 0x3C,
+    0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44,              /* FFC0 */
+    0x57, 0x58, 0x5B, 0x5C, 0x5D, 0x00, 0x00, 0x00,              /* FFC8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD8 */
+    /* modifier keys */
+    0x00, 0x2A, 0x136, 0x1D, 0x11D, 0x3A, 0x00, 0x38,            /* FFE0 */
+    0x138, 0x38, 0x138, 0x15b, 0x15c, 0x00, 0x00, 0x00,          /* FFE8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFF0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x153              /* FFF8 */
+};
+
+static const WORD xkb_keysym_xfree86_to_vkey[256] =
 {
-    0, 0, 0, 0, 0, 0, 0, 0,
-    0,                   /* KEY_RESERVED  0 */
-    VK_ESCAPE,           /* KEY_ESC   1 */
-    '1',                 /* KEY_1   2 */
-    '2',                 /* KEY_2   3 */
-    '3',                 /* KEY_3   4 */
-    '4',                 /* KEY_4   5 */
-    '5',                 /* KEY_5   6 */
-    '6',                 /* KEY_6   7 */
-    '7',                 /* KEY_7   8 */
-    '8',                 /* KEY_8   9 */
-    '9',                 /* KEY_9   10 */
-    '0',                 /* KEY_0   11 */
-    VK_OEM_MINUS,        /* KEY_MINUS  12 */
-    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
-    VK_BACK,             /* KEY_BACKSPACE 14 */
-    VK_TAB,              /* KEY_TAB   15 */
-    'Q',                 /* KEY_Q   16 */
-    'W',                 /* KEY_W   17 */
-    'E',                 /* KEY_E   18 */
-    'R',                 /* KEY_R   19 */
-    'T',                 /* KEY_T   20 */
-    'Y',                 /* KEY_Y   21 */
-    'U',                 /* KEY_U   22 */
-    'I',                 /* KEY_I   23 */
-    'O',                 /* KEY_O   24 */
-    'P',                 /* KEY_P   25 */
-    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
-    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
-    VK_RETURN,           /* KEY_ENTER  28 */
-    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
-    'A',                 /* KEY_A   30 */
-    'S',                 /* KEY_S   31 */
-    'D',                 /* KEY_D   32 */
-    'F',                 /* KEY_F   33 */
-    'G',                 /* KEY_G   34 */
-    'H',                 /* KEY_H   35 */
-    'J',                 /* KEY_J   36 */
-    'K',                 /* KEY_K   37 */
-    'L',                 /* KEY_L   38 */
-    VK_OEM_1,            /* KEY_SEMICOLON  39 */
-    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
-    VK_OEM_3,            /* KEY_GRAVE  41 */
-    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
-    VK_OEM_5,            /* KEY_BACKSLASH  43 */
-    'Z',                 /* KEY_Z   44 */
-    'X',                 /* KEY_X   45 */
-    'C',                 /* KEY_C   46 */
-    'V',                 /* KEY_V   47 */
-    'B',                 /* KEY_B   48 */
-    'N',                 /* KEY_N   49 */
-    'M',                 /* KEY_M   50 */
-    VK_OEM_COMMA,        /* KEY_COMMA  51 */
-    VK_OEM_PERIOD,       /* KEY_DOT   52 */
-    VK_OEM_2,            /* KEY_SLASH  53 */
-    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
-    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
-    VK_LMENU,            /* KEY_LEFTALT  56 */
-    VK_SPACE,            /* KEY_SPACE  57 */
-    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
-    VK_F1,               /* KEY_F1   59 */
-    VK_F2,               /* KEY_F2   60 */
-    VK_F3,               /* KEY_F3   61 */
-    VK_F4,               /* KEY_F4   62 */
-    VK_F5,               /* KEY_F5   63 */
-    VK_F6,               /* KEY_F6   64 */
-    VK_F7,               /* KEY_F7   65 */
-    VK_F8,               /* KEY_F8   66 */
-    VK_F9,               /* KEY_F9   67 */
-    VK_F10,              /* KEY_F10   68 */
-    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
-    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
-    VK_NUMPAD7,          /* KEY_KP7   71 */
-    VK_NUMPAD8,          /* KEY_KP8   72 */
-    VK_NUMPAD9,          /* KEY_KP9   73 */
-    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
-    VK_NUMPAD4,          /* KEY_KP4   75 */
-    VK_NUMPAD5,          /* KEY_KP5   76 */
-    VK_NUMPAD6,          /* KEY_KP6   77 */
-    VK_ADD,              /* KEY_KPPLUS  78 */
-    VK_NUMPAD1,          /* KEY_KP1   79 */
-    VK_NUMPAD2,          /* KEY_KP2   80 */
-    VK_NUMPAD3,          /* KEY_KP3   81 */
-    VK_NUMPAD0,          /* KEY_KP0   82 */
-    VK_DECIMAL,          /* KEY_KPDOT  83 */
-    0,                   /* 84 */
-    0,                   /* KEY_ZENKAKUHANKAKU 85 */
-    VK_OEM_102,          /* KEY_102ND  86 */
-    VK_F11,              /* KEY_F11   87 */
-    VK_F12,              /* KEY_F12   88 */
-    0,                   /* KEY_RO   89 */
-    0,                   /* KEY_KATAKANA  90 */
-    0,                   /* KEY_HIRAGANA  91 */
-    0,                   /* KEY_HENKAN  92 */
-    0,                   /* KEY_KATAKANAHIRAGANA 93 */
-    0,                   /* KEY_MUHENKAN  94 */
-    0,                   /* KEY_KPJPCOMMA  95 */
-    VK_RETURN,           /* KEY_KPENTER  96 */
-    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
-    VK_DIVIDE,           /* KEY_KPSLASH  98 */
-    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
-    VK_RMENU,            /* KEY_RIGHTALT  100 */
-    0,                   /* KEY_LINEFEED  101 */
-    VK_HOME,             /* KEY_HOME  102 */
-    VK_UP,               /* KEY_UP   103 */
-    VK_PRIOR,            /* KEY_PAGEUP  104 */
-    VK_LEFT,             /* KEY_LEFT  105 */
-    VK_RIGHT,            /* KEY_RIGHT  106 */
-    VK_END,              /* KEY_END   107 */
-    VK_DOWN,             /* KEY_DOWN  108 */
-    VK_NEXT,             /* KEY_PAGEDOWN  109 */
-    VK_INSERT,           /* KEY_INSERT  110 */
-    VK_DELETE,           /* KEY_DELETE  111 */
-    0,                   /* KEY_MACRO  112 */
-    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
-    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
-    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
-    0,                   /* KEY_POWER  116  */
-    0,                   /* KEY_KPEQUAL  117 */
-    0,                   /* KEY_KPPLUSMINUS  118 */
-    VK_PAUSE,            /* KEY_PAUSE  119 */
-    0,                   /* KEY_SCALE  120  */
-    0,                   /* KEY_KPCOMMA  121 */
-    0,                   /* KEY_HANGEUL  122 */
-    0,                   /* KEY_HANJA  123 */
-    0,                   /* KEY_YEN   124 */
-    VK_LWIN,             /* KEY_LEFTMETA  125 */
-    VK_RWIN,             /* KEY_RIGHTMETA  126 */
-    0,                   /* KEY_COMPOSE  127 */
-    0,                   /* KEY_STOP  128  */
-    0,                   /* KEY_AGAIN  129 */
-    0,                   /* KEY_PROPS  130  */
-    0,                   /* KEY_UNDO  131  */
-    0,                   /* KEY_FRONT  132 */
-    0,                   /* KEY_COPY  133  */
-    0,                   /* KEY_OPEN  134  */
-    0,                   /* KEY_PASTE  135  */
-    0,                   /* KEY_FIND  136  */
-    0,                   /* KEY_CUT   137  */
-    0,                   /* KEY_HELP  138  */
-    0,                   /* KEY_MENU  139  */
-    0,                   /* KEY_CALC  140  */
-    0,                   /* KEY_SETUP  141 */
-    0,                   /* KEY_SLEEP  142  */
-    0,                   /* KEY_WAKEUP  143  */
-    0,                   /* KEY_FILE  144  */
-    0,                   /* KEY_SENDFILE  145 */
-    0,                   /* KEY_DELETEFILE  146 */
-    0,                   /* KEY_XFER  147 */
-    0,                   /* KEY_PROG1  148 */
-    0,                   /* KEY_PROG2  149 */
-    0,                   /* KEY_WWW   150  */
-    0,                   /* KEY_MSDOS  151 */
-    0,                   /* KEY_COFFEE  152 */
-    0,                   /* KEY_ROTATE_DISPLAY 153  */
-    0,                   /* KEY_CYCLEWINDOWS 154 */
-    0,                   /* KEY_MAIL  155 */
-    0,                   /* KEY_BOOKMARKS  156  */
-    0,                   /* KEY_COMPUTER  157 */
-    0,                   /* KEY_BACK  158  */
-    0,                   /* KEY_FORWARD  159  */
-    0,                   /* KEY_CLOSECD  160 */
-    0,                   /* KEY_EJECTCD  161 */
-    0,                   /* KEY_EJECTCLOSECD 162 */
-    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
-    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
-    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
-    0,                   /* KEY_STOPCD  166 */
-    0,                   /* KEY_RECORD  167 */
-    0,                   /* KEY_REWIND  168 */
-    0,                   /* KEY_PHONE  169  */
-    0,                   /* KEY_ISO   170 */
-    0,                   /* KEY_CONFIG  171  */
-    0,                   /* KEY_HOMEPAGE  172  */
-    0,                   /* KEY_REFRESH  173  */
-    0,                   /* KEY_EXIT  174  */
-    0,                   /* KEY_MOVE  175 */
-    0,                   /* KEY_EDIT  176 */
-    0,                   /* KEY_SCROLLUP  177 */
-    0,                   /* KEY_SCROLLDOWN  178 */
-    0,                   /* KEY_KPLEFTPAREN  179 */
-    0,                   /* KEY_KPRIGHTPAREN 180 */
-    0,                   /* KEY_NEW   181  */
-    0,                   /* KEY_REDO  182  */
-    VK_F13,              /* KEY_F13   183 */
-    VK_F14,              /* KEY_F14   184 */
-    VK_F15,              /* KEY_F15   185 */
-    VK_F16,              /* KEY_F16   186 */
-    VK_F17,              /* KEY_F17   187 */
-    VK_F18,              /* KEY_F18   188 */
-    VK_F19,              /* KEY_F19   189 */
-    VK_F20,              /* KEY_F20   190 */
-    VK_F21,              /* KEY_F21   191 */
-    VK_F22,              /* KEY_F22   192 */
-    VK_F23,              /* KEY_F23   193 */
-    VK_F24,              /* KEY_F24   194 */
-    0,                   /* 195 */
-    0,                   /* 196 */
-    0,                   /* 197 */
-    0,                   /* 198 */
-    0,                   /* 199 */
-    0,                   /* KEY_PLAYCD  200 */
-    0,                   /* KEY_PAUSECD  201 */
-    0,                   /* KEY_PROG3  202 */
-    0,                   /* KEY_PROG4  203 */
-    0,                   /* KEY_DASHBOARD  204  */
-    0,                   /* KEY_SUSPEND  205 */
-    0,                   /* KEY_CLOSE  206  */
-    VK_PLAY,             /* KEY_PLAY  207 */
-    0,                   /* KEY_FASTFORWARD  208 */
-    0,                   /* KEY_BASSBOOST  209 */
-    VK_PRINT,            /* KEY_PRINT  210  */
-    0,                   /* KEY_HP   211 */
-    0,                   /* KEY_CAMERA  212 */
-    0,                   /* KEY_SOUND  213 */
-    0,                   /* KEY_QUESTION  214  */
-    0,                   /* KEY_EMAIL  215 */
-    0,                   /* KEY_CHAT  216 */
-    0,                   /* KEY_SEARCH  217 */
-    0,                   /* KEY_CONNECT  218 */
-    0,                   /* KEY_FINANCE  219  */
-    0,                   /* KEY_SPORT  220 */
-    0,                   /* KEY_SHOP  221 */
-    0,                   /* KEY_ALTERASE  222 */
-    0,                   /* KEY_CANCEL  223  */
-    0,                   /* KEY_BRIGHTNESSDOWN 224 */
-    0,                   /* KEY_BRIGHTNESSUP 225 */
-    0,                   /* KEY_MEDIA  226 */
-    0,                   /* KEY_SWITCHVIDEOMODE 227  */
-    0,                   /* KEY_KBDILLUMTOGGLE 228 */
-    0,                   /* KEY_KBDILLUMDOWN 229 */
-    0,                   /* KEY_KBDILLUMUP  230 */
-    0,                   /* KEY_SEND  231  */
-    0,                   /* KEY_REPLY  232  */
-    0,                   /* KEY_FORWARDMAIL  233  */
-    0,                   /* KEY_SAVE  234  */
-    0,                   /* KEY_DOCUMENTS  235 */
-    0,                   /* KEY_BATTERY  236 */
-    0,                   /* KEY_BLUETOOTH  237 */
-    0,                   /* KEY_WLAN  238 */
-    0,                   /* KEY_UWB   239  */
-    0,                   /* KEY_UNKNOWN  240 */
-    0,                   /* KEY_VIDEO_NEXT  241  */
-    0,                   /* KEY_VIDEO_PREV  242  */
-    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
-    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
-    0,                   /* KEY_DISPLAY_OFF  245  */
-    0,                   /* KEY_WWAN  246  */
-    0,                   /* KEY_RFKILL  247  */
-    0,                   /* KEY_MICMUTE  248  */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, VK_VOLUME_DOWN, VK_VOLUME_MUTE, VK_VOLUME_UP,            /* 1008FF10 */
+    VK_MEDIA_PLAY_PAUSE, VK_MEDIA_STOP,
+    VK_MEDIA_PREV_TRACK, VK_MEDIA_NEXT_TRACK,
+    0, VK_LAUNCH_MAIL, 0, VK_BROWSER_SEARCH,                    /* 1008FF18 */
+    0, 0, 0, VK_BROWSER_HOME,
+    0, 0, 0, 0, 0, 0, VK_BROWSER_BACK, VK_BROWSER_FORWARD,      /* 1008FF20 */
+    VK_BROWSER_STOP, VK_BROWSER_REFRESH, 0, 0, 0, 0, 0, 0,      /* 1008FF28 */
+    VK_BROWSER_FAVORITES, 0, VK_LAUNCH_MEDIA_SELECT, 0,         /* 1008FF30 */
+    0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
 #endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index aad3cf3025b..1b272602fec 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -66,6 +66,8 @@ struct wayland_keyboard
     uint32_t enter_serial;
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
+    UINT xkb_keycode_to_vkey[256];
+    WORD xkb_keycode_to_scancode[256];
 };
 
 struct wayland_cursor
@@ -315,6 +317,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
                            struct wl_keyboard *wl_keyboard);
 void wayland_keyboard_deinit(struct wayland_keyboard *keyboard);
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard);
 
 /**********************************************************************
  *          Wayland Pointer/Cursor
diff --git a/dlls/winewayland.drv/xkb_util.c b/dlls/winewayland.drv/xkb_util.c
new file mode 100644
index 00000000000..2a33c7ba564
--- /dev/null
+++ b/dlls/winewayland.drv/xkb_util.c
@@ -0,0 +1,76 @@
+/*
+ * XKB related utility functions
+ *
+ * Copyright 2021 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <xkbcommon/xkbcommon.h>
+
+/**********************************************************************
+ *          _xkb_state_get_active_layout
+ *
+ * Gets the active layout of the xkb state.
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state)
+{
+    struct xkb_keymap *xkb_keymap = xkb_state_get_keymap(xkb_state);
+    xkb_layout_index_t num_layouts = xkb_keymap_num_layouts(xkb_keymap);
+    xkb_layout_index_t layout;
+
+    for (layout = 0; layout < num_layouts; layout++)
+    {
+        if (xkb_state_layout_index_is_active(xkb_state, layout,
+                                             XKB_STATE_LAYOUT_LOCKED))
+            return layout;
+    }
+
+    return XKB_LAYOUT_INVALID;
+}
+
+/**********************************************************************
+ *          _xkb_keysyms_to_utf8
+ *
+ * Get the null-terminated UTF-8 string representation of a sequence of
+ * keysyms. Returns the length of the UTF-8 string written, *not* including
+ * the null byte. If no bytes were produced or in case of error returns 0
+ * and produces a properly null-terminated empty string if possible.
+ */
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size)
+{
+    int i;
+    int utf8_len = 0;
+
+    if (utf8_size == 0) return 0;
+
+    for (i = 0; i < nsyms; i++)
+    {
+        int nwritten = xkb_keysym_to_utf8(syms[i], utf8 + utf8_len,
+                                          utf8_size - utf8_len);
+        if (nwritten <= 0)
+        {
+            utf8_len = 0;
+            break;
+        }
+
+        /* nwritten includes the terminating null byte */
+        utf8_len += nwritten - 1;
+    }
+
+    utf8[utf8_len] = '\0';
+
+    return utf8_len;
+}
-- 
2.33.0


From c9e92c5d38468a69dd6aebe1af46cf3afc813648 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:57:33 +0300
Subject: [PATCH 031/125] winewayland.drv: Add detection of best keyboard
 layout match.

Add a mechanism to detect the best matching keyboard layout for a given
Wayland keymap, by scoring the similarity of the symbols produced by
Wayland keycodes for that keymap, to the symbols for keys in the layout.

The scoring algorithm takes relative key order into account to provide
better detection of layouts that differ only in their key order.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../winewayland.drv/wayland_keyboard_layout.c | 92 ++++++++++++++++++-
 1 file changed, 91 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
index 60786cce7d2..1172c95f9d8 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.c
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -52,6 +52,62 @@ static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
     return score;
 }
 
+static int score_layout(int layout,
+                        const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    int score = 0;
+    int prev_key = 1000;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int key, key_score = 0;
+        const xkb_keysym_t *symbols = symbols_for_keycode[xkb_keycode];
+
+        if (*symbols == 0)
+            continue;
+
+        for (key = 0; key < MAIN_KEY_LEN; key++)
+        {
+            if (key_used[key]) continue;
+            key_score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                      (*main_key_tab[layout].symbols)[key]);
+            if (key_score)
+                break;
+        }
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols, MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' key=%d score=%d order=%d\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, key, key_score, key_score && (key > prev_key));
+        }
+
+        if (key_score)
+        {
+            /* Multiply score by 100 to allow the key order bonus to break ties,
+             * while not being a primary decision factor. */
+            score += key_score * 100;
+
+            /* xkb keycodes roughly follow a top left to bottom right direction
+             * on the keyboard as they increase, similarly to the keys in
+             * main_key_tab. Give a bonus to layouts that more closely match
+             * the expected ordering. We compare with the last key to get
+             * some reasonable (although local) measure of the order. */
+            score += (key > prev_key);
+            prev_key = key;
+            key_used[key] = 1;
+        }
+    }
+
+    return score;
+}
+
 static void _xkb_keymap_populate_symbols_for_keycode(
     struct xkb_keymap *xkb_keymap,
     xkb_layout_index_t layout,
@@ -82,6 +138,37 @@ static void _xkb_keymap_populate_symbols_for_keycode(
     }
 }
 
+static int detect_main_key_layout(struct wayland_keyboard *keyboard,
+                                  const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    int max_score = 0;
+    int max_i = 0;
+
+    for (int i = 0; i < ARRAY_SIZE(main_key_tab); i++)
+    {
+        int score = score_layout(i, symbols_for_keycode);
+        if (score > max_score)
+        {
+            max_i = i;
+            max_score = score;
+        }
+        TRACE("evaluated layout '%s' score %d\n", main_key_tab[i].name, score);
+    }
+
+    if (max_score == 0)
+    {
+        max_i = 0;
+        while (strcmp(main_key_tab[max_i].name, "us")) max_i++;
+        TRACE("failed to detect layout, falling back to layout 'us'\n");
+    }
+    else
+    {
+        TRACE("detected layout '%s' (score %d)\n", main_key_tab[max_i].name, max_score);
+    }
+
+    return max_i;
+}
+
 /* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
  * the specified main_key layout (see wayland_keyboard_layout.h) and the
  * xkb_keycode to xkb_keysym_t mappings which have been created from the
@@ -183,6 +270,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
     struct xkb_state *xkb_state = keyboard->xkb_state;
     struct xkb_keymap *xkb_keymap;
     xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+    int main_key_layout;
 
     if (!xkb_state)
     {
@@ -201,5 +289,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
 
     _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
 
-    populate_xkb_keycode_maps(keyboard, 0, symbols_for_keycode);
+    main_key_layout = detect_main_key_layout(keyboard, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, main_key_layout, symbols_for_keycode);
 }
-- 
2.33.0


From 13a5bd109b3a9351e0e32f190aec58b5917cd62d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:00:11 +0300
Subject: [PATCH 032/125] winewayland.drv: Add support for more keyboard
 layouts.

Add virtual key mappings, scan code mappings, and symbol mappings for
various keyboard layouts and languages.

These mappings were produced automatically by a helper program using
the xkbcommon library.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../winewayland.drv/wayland_keyboard_layout.h | 699 ++++++++++++++++++
 1 file changed, 699 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
index 2eafb6d2cb5..26f688cc636 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.h
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -56,8 +56,586 @@ static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
     VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
 };
 
+static const WORD main_key_vkey_qwerty_jp106[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    0,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_7,VK_OEM_5,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_3,VK_OEM_4,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_PLUS,VK_OEM_1,VK_OEM_6,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_v2[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_5,'1','2','3','4','5','6','7','8','9','0',VK_OEM_PLUS,VK_OEM_4,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_3,VK_OEM_7,VK_OEM_2,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_MINUS,
+};
+
+static const WORD main_key_vkey_qwertz[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Z','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Y','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_abnt_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_8,VK_OEM_5,
+    VK_OEM_7,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_102,
+};
+
+static const WORD main_key_vkey_colemak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','F','P','G','J','L','U','Y',VK_OEM_1,VK_OEM_4,VK_OEM_6,
+    'A','R','S','T','D','H','N','E','I','O',VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','K','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_azerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_7,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_PLUS,0,
+    'A','Z','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'Q','S','D','F','G','H','J','K','L','M',VK_OEM_3,VK_OEM_5,
+    VK_OEM_102,'W','X','C','V','B','N',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_8,
+};
+
+static const WORD main_key_vkey_dvorak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_6,0,
+    VK_OEM_7,VK_OEM_COMMA,VK_OEM_PERIOD,'P','Y','F','G','C','R','L',VK_OEM_2,VK_OEM_PLUS,
+    'A','O','E','U','I','D','H','T','N','S',VK_OEM_MINUS,VK_OEM_5,
+    VK_OEM_102,VK_OEM_1,'Q','J','K','X','B','M','W','V','Z',
+};
+
 #define K(x) XKB_KEY_##x
 
+static const xkb_keysym_t main_key_symbols_be[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+   {K(twosuperior), K(threesuperior)}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {K(section), '6'}, {K(egrave), '7'}, {'!', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+   {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', '*'},
+    /* Row C: AC01-AC12 */
+   {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {K(mu), K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+   {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'=', '+'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_bds[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'(', ')'}, {'1', '!'}, {'2', '?'}, {'3', '+'}, {'4', '"'}, {'5', '%'}, {'6', '='}, {'7', ':'}, {'8', '/'}, {'9', K(endash)}, {'0', K(numerosign)}, {'-', '$'}, {'.', K(EuroSign)}, {},
+    /* Row D: AD01-AD12 */
+    {',', K(Cyrillic_yeru)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {';', K(section)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(doublelowquotemark), K(leftdoublequotemark)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_e), K(Cyrillic_E)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_che), K(Cyrillic_CHE)}, {'1', '!'}, {'2', '@'}, {'3', K(numerosign)}, {'4', '$'}, {'5', '%'}, {'6', K(EuroSign)}, {'7', K(section)}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', K(endash)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_yu), K(Cyrillic_YU)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', K(doublelowquotemark)}, {'.', K(leftdoublequotemark)}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_br_abnt2[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', '"'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_diaeresis)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_acute), K(dead_grave)}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(dead_tilde), K(dead_circumflex)}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+   {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {';', ':'}, {'/', '?'},
+};
+
+static const xkb_keysym_t main_key_symbols_by[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Byelorussian_shortu), K(Byelorussian_SHORTU)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {'\'', '\''},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ca[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'#', '|'}, {'1', '!'}, {'2', '"'}, {'3', '/'}, {'4', '$'}, {'5', '%'}, {'6', '?'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_circumflex)}, {K(dead_cedilla), K(dead_diaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_grave), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '\''}, {'.', '.'}, {K(eacute), K(Eacute)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(egrave)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(eacute)}, {K(adiaeresis), K(agrave)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(udiaeresis)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(odiaeresis)}, {K(agrave), K(adiaeresis)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz_qwerty[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_circumflex), K(degree)}, {'1', '!'}, {'2', '"'}, {'3', K(section)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(ssharp), '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'#', '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_dk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(onehalf), K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(oslash), K(Oslash)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ee[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_caron), K(dead_tilde)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {K(otilde), K(Otilde)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_es[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(masculine), K(ordfeminine)}, {'1', '!'}, {'2', '"'}, {'3', K(periodcentered)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(exclamdown), K(questiondown)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_grave), K(dead_circumflex)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ntilde), K(Ntilde)}, {K(dead_acute), K(dead_diaeresis)}, {K(ccedilla), K(Ccedilla)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fi[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(twosuperior), '~'}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {'-', '6'}, {K(egrave), '7'}, {'_', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', K(sterling)},
+    /* Row C: AC01-AC12 */
+    {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {'*', K(mu)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'!', K(section)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gb[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', K(notsign)}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '@'}, {'#', '~'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {K(Greek_finalsmallsigma), K(Greek_SIGMA)}, {K(Greek_epsilon), K(Greek_EPSILON)}, {K(Greek_rho), K(Greek_RHO)}, {K(Greek_tau), K(Greek_TAU)}, {K(Greek_upsilon), K(Greek_UPSILON)}, {K(Greek_theta), K(Greek_THETA)}, {K(Greek_iota), K(Greek_IOTA)}, {K(Greek_omicron), K(Greek_OMICRON)}, {K(Greek_pi), K(Greek_PI)}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {K(Greek_alpha), K(Greek_ALPHA)}, {K(Greek_sigma), K(Greek_SIGMA)}, {K(Greek_delta), K(Greek_DELTA)}, {K(Greek_phi), K(Greek_PHI)}, {K(Greek_gamma), K(Greek_GAMMA)}, {K(Greek_eta), K(Greek_ETA)}, {K(Greek_xi), K(Greek_XI)}, {K(Greek_kappa), K(Greek_KAPPA)}, {K(Greek_lamda), K(Greek_LAMDA)}, {K(dead_acute), K(dead_diaeresis)}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {K(Greek_zeta), K(Greek_ZETA)}, {K(Greek_chi), K(Greek_CHI)}, {K(Greek_psi), K(Greek_PSI)}, {K(Greek_omega), K(Greek_OMEGA)}, {K(Greek_beta), K(Greek_BETA)}, {K(Greek_nu), K(Greek_NU)}, {K(Greek_mu), K(Greek_MU)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hu[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'0', K(section)}, {'1', '\''}, {'2', '"'}, {'3', '+'}, {'4', '!'}, {'5', '%'}, {'6', '/'}, {'7', '='}, {'8', '('}, {'9', ')'}, {K(odiaeresis), K(Odiaeresis)}, {K(udiaeresis), K(Udiaeresis)}, {K(oacute), K(Oacute)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(odoubleacute), K(Odoubleacute)}, {K(uacute), K(Uacute)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(Eacute)}, {K(aacute), K(Aacute)}, {K(udoubleacute), K(Udoubleacute)},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(iacute), K(Iacute)}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', ')'}, {'0', '('}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'/', 'Q'}, {'\'', 'W'}, {K(hebrew_qoph), 'E'}, {K(hebrew_resh), 'R'}, {K(hebrew_aleph), 'T'}, {K(hebrew_tet), 'Y'}, {K(hebrew_waw), 'U'}, {K(hebrew_finalnun), 'I'}, {K(hebrew_finalmem), 'O'}, {K(hebrew_pe), 'P'}, {']', '}'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_shin), 'A'}, {K(hebrew_dalet), 'S'}, {K(hebrew_gimel), 'D'}, {K(hebrew_kaph), 'F'}, {K(hebrew_ayin), 'G'}, {K(hebrew_yod), 'H'}, {K(hebrew_chet), 'J'}, {K(hebrew_lamed), 'K'}, {K(hebrew_finalkaph), 'L'}, {K(hebrew_finalpe), ':'}, {',', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), 'Z'}, {K(hebrew_samech), 'X'}, {K(hebrew_bet), 'C'}, {K(hebrew_he), 'V'}, {K(hebrew_nun), 'B'}, {K(hebrew_mem), 'N'}, {K(hebrew_zade), 'M'}, {K(hebrew_taw), '>'}, {K(hebrew_finalzade), '<'}, {'.', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(hebrew_qoph), K(hebrew_qoph)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_resh), K(hebrew_resh)}, {K(hebrew_taw), K(hebrew_tet)}, {K(hebrew_ayin), K(hebrew_ayin)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_samech), K(hebrew_samech)}, {K(hebrew_pe), K(hebrew_finalpe)}, {}, {},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_shin), K(hebrew_shin)}, {K(hebrew_dalet), K(hebrew_dalet)}, {K(hebrew_pe), K(hebrew_finalpe)}, {K(hebrew_gimel), K(hebrew_gimel)}, {K(hebrew_he), K(hebrew_he)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_kaph), K(hebrew_finalkaph)}, {K(hebrew_lamed), K(hebrew_lamed)}, {}, {}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), K(hebrew_zain)}, {K(hebrew_chet), K(hebrew_chet)}, {K(hebrew_zade), K(hebrew_finalzade)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_bet), K(hebrew_bet)}, {K(hebrew_nun), K(hebrew_finalnun)}, {K(hebrew_mem), K(hebrew_finalmem)}, {}, {}, {}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_is[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_abovering), K(dead_diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(odiaeresis), K(Odiaeresis)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(eth), K(ETH)}, {'\'', '?'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(dead_acute), K(dead_acute)}, {'+', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {K(thorn), K(THORN)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_it[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(igrave), '^'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(eacute)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ograve), K(ccedilla)}, {K(agrave), K(degree)}, {K(ugrave), K(section)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_106[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '~'}, {'-', '='}, {'^', '~'}, {'\\', '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_kana86[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', K(kana_WO)}, {'-', '='}, {'^', '~'}, {K(yen), '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_mac[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {K(kana_NU)}, {K(kana_FU)}, {K(kana_A), K(kana_a)}, {K(kana_U), K(kana_u)}, {K(kana_E), K(kana_e)}, {K(kana_O), K(kana_o)}, {K(kana_YA), K(kana_ya)}, {K(kana_YU), K(kana_yu)}, {K(kana_YO), K(kana_yo)}, {K(kana_WA), K(kana_WO)}, {K(kana_HO)}, {K(kana_HE)}, {K(prolongedsound)},
+    /* Row D: AD01-AD12 */
+    {K(kana_TA)}, {K(kana_TE)}, {K(kana_I), K(kana_i)}, {K(kana_SU)}, {K(kana_KA)}, {K(kana_N)}, {K(kana_NA)}, {K(kana_NI)}, {K(kana_RA)}, {K(kana_SE)}, {K(voicedsound)}, {K(semivoicedsound), K(kana_openingbracket)},
+    /* Row C: AC01-AC12 */
+    {K(kana_CHI)}, {K(kana_TO)}, {K(kana_SHI)}, {K(kana_HA)}, {K(kana_KI)}, {K(kana_KU)}, {K(kana_MA)}, {K(kana_NO)}, {K(kana_RI)}, {K(kana_RE)}, {K(kana_KE)}, {K(kana_MU), K(kana_closingbracket)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(kana_TSU), K(kana_tsu)}, {K(kana_SA)}, {K(kana_SO)}, {K(kana_HI)}, {K(kana_KO)}, {K(kana_MI)}, {K(kana_MO)}, {K(kana_NE), K(kana_comma)}, {K(kana_RU), K(kana_fullstop)}, {K(kana_ME), K(kana_conjunctive)}, {K(kana_RO)},
+};
+
+static const xkb_keysym_t main_key_symbols_lt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {K(aogonek), K(Aogonek)}, {K(ccaron), K(Ccaron)}, {K(eogonek), K(Eogonek)}, {K(eabovedot), K(Eabovedot)}, {K(iogonek), K(Iogonek)}, {K(scaron), K(Scaron)}, {K(uogonek), K(Uogonek)}, {K(umacron), K(Umacron)}, {K(doublelowquotemark), '('}, {K(leftdoublequotemark), ')'}, {'-', '_'}, {K(zcaron), K(Zcaron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(endash), K(EuroSign)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_nl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'@', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '_'}, {'8', '('}, {'9', ')'}, {'0', '\''}, {'/', '?'}, {K(degree), K(dead_tilde)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_diaeresis), K(dead_circumflex)}, {'*', '|'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'+', K(plusminus)}, {K(dead_acute), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {']', '['}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '='}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_no[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'|', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {'\\', K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(oslash), K(Oslash)}, {K(ae), K(AE)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl_dvp[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'$', '~'}, {'&', '%'}, {'[', '7'}, {'{', '5'}, {'}', '3'}, {'(', '1'}, {'=', '9'}, {'*', '0'}, {')', '2'}, {'+', '4'}, {']', '6'}, {'!', '8'}, {'#', '`'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'@', '^'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'\'', '"'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(guillemotleft), K(guillemotright)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'+', '*'}, {K(dead_acute), K(dead_grave)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(masculine), K(ordfeminine)}, {K(dead_tilde), K(dead_circumflex)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_yu), K(Cyrillic_YU)}, {'1', '!'}, {'2', '@'}, {'3', K(Cyrillic_io)}, {'4', K(Cyrillic_IO)}, {'5', K(Cyrillic_hardsign)}, {'6', K(Cyrillic_HARDSIGN)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_e), K(Cyrillic_E)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'|', K(brokenbar)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_rs[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] = {
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_lje), K(Cyrillic_LJE)}, {K(Cyrillic_nje), K(Cyrillic_NJE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Serbian_dje), K(Serbian_DJE)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_je), K(Cyrillic_JE)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Serbian_tshe), K(Serbian_TSHE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_dzhe), K(Cyrillic_DZHE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_se[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_si[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(cedilla), K(diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_sk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(lcaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(tcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {K(adiaeresis), '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ocircumflex), '"'}, {K(section), '!'}, {K(ncaron), ')'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_th[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'_', '%'}, {K(Thai_lakkhangyao), '+'}, {'/', K(Thai_leknung)}, {'-', K(Thai_leksong)}, {K(Thai_phosamphao), K(Thai_leksam)}, {K(Thai_thothung), K(Thai_leksi)}, {K(Thai_sarau), K(Thai_sarauu)}, {K(Thai_saraue), K(Thai_baht)}, {K(Thai_khokhwai), K(Thai_lekha)}, {K(Thai_totao), K(Thai_lekhok)}, {K(Thai_chochan), K(Thai_lekchet)}, {K(Thai_khokhai), K(Thai_lekpaet)}, {K(Thai_chochang), K(Thai_lekkao)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Thai_maiyamok), K(Thai_leksun)}, {K(Thai_saraaimaimalai), '"'}, {K(Thai_saraam), K(Thai_dochada)}, {K(Thai_phophan), K(Thai_thonangmontho)}, {K(Thai_saraa), K(Thai_thothong)}, {K(Thai_maihanakat), K(Thai_nikhahit)}, {K(Thai_saraii), K(Thai_maitri)}, {K(Thai_rorua), K(Thai_nonen)}, {K(Thai_nonu), K(Thai_paiyannoi)}, {K(Thai_yoyak), K(Thai_yoying)}, {K(Thai_bobaimai), K(Thai_thothan)}, {K(Thai_loling), ','},
+    /* Row C: AC01-AC12 */
+    {K(Thai_fofan), K(Thai_ru)}, {K(Thai_hohip), K(Thai_khorakhang)}, {K(Thai_kokai), K(Thai_topatak)}, {K(Thai_dodek), K(Thai_sarao)}, {K(Thai_sarae), K(Thai_chochoe)}, {K(Thai_maitho), K(Thai_maitaikhu)}, {K(Thai_maiek), K(Thai_maichattawa)}, {K(Thai_saraaa), K(Thai_sorusi)}, {K(Thai_sosua), K(Thai_sosala)}, {K(Thai_wowaen), K(Thai_soso)}, {K(Thai_ngongu), '.'}, {K(Thai_khokhuat), K(Thai_khokhon)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Thai_phophung), '('}, {K(Thai_popla), ')'}, {K(Thai_saraae), K(Thai_choching)}, {K(Thai_oang), K(Thai_honokhuk)}, {K(Thai_sarai), K(Thai_phinthu)}, {K(Thai_sarauee), K(Thai_thanthakhat)}, {K(Thai_thothahan), '?'}, {K(Thai_moma), K(Thai_thophuthao)}, {K(Thai_saraaimaimuan), K(Thai_lochula)}, {K(Thai_fofa), K(Thai_lu)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'"', K(eacute)}, {'1', '!'}, {'2', '\''}, {'3', '^'}, {'4', '+'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'*', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {K(idotless), 'I'}, {'o', 'O'}, {'p', 'P'}, {K(gbreve), K(Gbreve)}, {K(udiaeresis), K(Udiaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(scedilla), K(Scedilla)}, {'i', K(Iabovedot)}, {',', ';'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {K(odiaeresis), K(Odiaeresis)}, {K(ccedilla), K(Ccedilla)}, {'.', ':'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr_f[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'+', '*'}, {'1', '!'}, {'2', '"'}, {'3', '^'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '='}, {'/', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'f', 'F'}, {'g', 'G'}, {K(gbreve), K(Gbreve)}, {K(idotless), 'I'}, {'o', 'O'}, {'d', 'D'}, {'r', 'R'}, {'n', 'N'}, {'h', 'H'}, {'p', 'P'}, {'q', 'Q'}, {'w', 'W'},
+    /* Row C: AC01-AC12 */
+    {'u', 'U'}, {'i', K(Iabovedot)}, {'e', 'E'}, {'a', 'A'}, {K(udiaeresis), K(Udiaeresis)}, {'t', 'T'}, {'k', 'K'}, {'m', 'M'}, {'l', 'L'}, {'y', 'Y'}, {K(scedilla), K(Scedilla)}, {'x', 'X'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'j', 'J'}, {K(odiaeresis), K(Odiaeresis)}, {'v', 'V'}, {'c', 'C'}, {K(ccedilla), K(Ccedilla)}, {'z', 'Z'}, {'s', 'S'}, {'b', 'B'}, {'.', ':'}, {',', ';'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ua[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', 0x10002bc}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Ukrainian_yi), K(Ukrainian_YI)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Ukrainian_ie), K(Ukrainian_IE)}, {K(Ukrainian_ghe_with_upturn), K(Ukrainian_GHE_WITH_UPTURN)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
 static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
 {
     /* Row E: TLDE, AE01-AE13 */
@@ -70,8 +648,83 @@ static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN
     {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
 };
 
+
+static const xkb_keysym_t main_key_symbols_us_colemak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'f', 'F'}, {'p', 'P'}, {'g', 'G'}, {'j', 'J'}, {'l', 'L'}, {'u', 'U'}, {'y', 'Y'}, {';', ':'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'d', 'D'}, {'h', 'H'}, {'n', 'N'}, {'e', 'E'}, {'i', 'I'}, {'o', 'O'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'-', '_'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'k', 'K'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_dvorak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'[', '{'}, {']', '}'}, {},
+    /* Row D: AD01-AD12 */
+    {'\'', '"'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'=', '+'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {';', ':'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_intl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_grave), K(dead_tilde)}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_circumflex)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_acute), K(dead_diaeresis)}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
 #undef K
 
+/*** The VNC keyboard layout is a special case */
+
+static const WORD main_key_scan_vnc[MAIN_KEY_LEN] =
+{
+    0x02,0x03,0x04,0x05,0x06,0x07,
+    0x08,0x09,0x0A,0x0B,0x0C,0x0D,
+    0x1A,0x1B,0x27,0x28,0x29,0x33,
+    0x34,0x35,0x2B,0x1E,0x30,0x2E,
+    0x20,0x12,0x21,0x22,0x23,0x17,
+    0x24,0x25,0x26,0x32,0x31,0x18,
+    0x19,0x10,0x13,0x1F,0x14,0x16,
+    0x2F,0x11,0x2D,0x15,0x2C,0x56
+};
+
+static const WORD main_key_vkey_vnc[MAIN_KEY_LEN] =
+{
+    '1','2','3','4','5','6',
+    '7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,
+    VK_OEM_4,VK_OEM_6,VK_OEM_1,VK_OEM_7,VK_OEM_3,VK_OEM_COMMA,
+    VK_OEM_PERIOD,VK_OEM_2,VK_OEM_5, 'A','B','C',
+    'D','E','F','G','H','I',
+    'J','K','L','M','N','O',
+    'P','Q','R','S','T','U',
+    'V','W','X','Y','Z', VK_OEM_102
+};
+
+static const xkb_keysym_t main_key_symbols_vnc[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'},
+    {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'},
+    {'[', '{'}, {']', '}'}, {';', ':'}, {'\'', '"'}, {'`', '~'}, {',', '<'},
+    {'.', '>'}, {'/', '?'}, {'\\', '|'}, {'a', 'A'}, {'b', 'B'}, {'c', 'C'},
+    {'d', 'D'}, {'e', 'E'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'i', 'I'},
+    {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {'n', 'N'}, {'o', 'O'},
+    {'p', 'P'}, {'q', 'Q'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'u', 'U'},
+    {'v', 'V'}, {'w', 'W'}, {'x', 'X'}, {'y', 'Y'}, {'z', 'Z'}
+};
+
 /*** Layout table. Add your keyboard mappings to this list */
 static struct {
     LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
@@ -81,7 +734,53 @@ static struct {
     const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
     const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
 } main_key_tab[]={
+    {0x0402, "bg_bds", &main_key_symbols_bg_bds, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0402, "bg_phonetic", &main_key_symbols_bg_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz", &main_key_symbols_cz, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz_qwerty", &main_key_symbols_cz_qwerty, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0406, "dk", &main_key_symbols_dk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0407, "de", &main_key_symbols_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0408, "gr", &main_key_symbols_gr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
     {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us_colemak", &main_key_symbols_us_colemak, &main_key_scan_ps2_set1, &main_key_vkey_colemak},
+    {0x0409, "us_dvorak", &main_key_symbols_us_dvorak, &main_key_scan_ps2_set1, &main_key_vkey_dvorak},
+    {0x0409, "us_intl", &main_key_symbols_us_intl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "vnc", &main_key_symbols_vnc, &main_key_scan_vnc, &main_key_vkey_vnc},
+    {0x040a, "es", &main_key_symbols_es, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040b, "fi", &main_key_symbols_fi, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040c, "fr", &main_key_symbols_fr, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x040d, "il", &main_key_symbols_il, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040d, "il_phonetic", &main_key_symbols_il_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040e, "hu", &main_key_symbols_hu, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x040f, "is", &main_key_symbols_is, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0410, "it", &main_key_symbols_it, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_106", &main_key_symbols_jp_106, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0411, "jp_kana86", &main_key_symbols_jp_kana86, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_mac", &main_key_symbols_jp_mac, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0413, "nl", &main_key_symbols_nl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0414, "no", &main_key_symbols_no, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0415, "pl_dvp", &main_key_symbols_pl_dvp, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0416, "br_abnt2", &main_key_symbols_br_abnt2, &main_key_scan_ps2_set1, &main_key_vkey_abnt_qwerty},
+    {0x0419, "ru", &main_key_symbols_ru, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0419, "ru_phonetic", &main_key_symbols_ru_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041a, "hr", &main_key_symbols_hr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x041b, "sk", &main_key_symbols_sk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041d, "se", &main_key_symbols_se, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_v2},
+    {0x041e, "th", &main_key_symbols_th, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr_f", &main_key_symbols_tr_f, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr", &main_key_symbols_tr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0422, "ua", &main_key_symbols_ua, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0423, "by", &main_key_symbols_by, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0424, "si", &main_key_symbols_si, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0425, "ee", &main_key_symbols_ee, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0427, "lt", &main_key_symbols_lt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0807, "ch_de", &main_key_symbols_ch_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0809, "gb", &main_key_symbols_gb, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x080c, "be", &main_key_symbols_be, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x0816, "pt", &main_key_symbols_pt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c0c, "ca", &main_key_symbols_ca, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c1a, "rs", &main_key_symbols_rs, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x100c, "ch_fr", &main_key_symbols_ch_fr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
 };
 
 static const WORD xkb_keysym_0xff00_to_vkey[256] =
-- 
2.33.0


From 152cec924ceb21a139d2f32877c06b45f96d6a44 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:14:40 +0300
Subject: [PATCH 033/125] winewayland.drv: Implement ToUnicodeEx.

We use the the current XKB state and XKB compose state to perform the
translation.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c   | 156 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |   2 +
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 3 files changed, 159 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 48141b04e71..66bf06a4f63 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -35,9 +35,11 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 #include "winuser.h"
 
+#include <stdlib.h>
 #include <sys/mman.h>
 #include <unistd.h>
 
@@ -58,6 +60,19 @@ static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
            keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
 }
 
+static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    xkb_keycode_t i;
+
+    for (i = 0; i < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey); i++)
+    {
+        if (keyboard->xkb_keycode_to_vkey[i] == vkey)
+            return i;
+    }
+
+    return 0;
+}
+
 /* xkb keycodes are offset by 8 from linux input keycodes. */
 static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 {
@@ -78,6 +93,64 @@ static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
     __wine_send_input(hwnd, &input, NULL);
 }
 
+static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
+{
+    switch (xkb_keysym)
+    {
+    case XKB_KEY_dead_grave: return 0x0060;
+    case XKB_KEY_dead_acute: return 0x00B4;
+    case XKB_KEY_dead_circumflex: return 0x005E;
+    case XKB_KEY_dead_tilde: return 0x007E;
+    case XKB_KEY_dead_macron: return 0x00AF;
+    case XKB_KEY_dead_breve: return 0x02D8;
+    case XKB_KEY_dead_abovedot: return 0x02D9;
+    case XKB_KEY_dead_diaeresis: return 0x00A8;
+    case XKB_KEY_dead_abovering: return 0x02DA;
+    case XKB_KEY_dead_doubleacute: return 0x02DD;
+    case XKB_KEY_dead_caron: return 0x02C7;
+    case XKB_KEY_dead_cedilla: return 0x00B8;
+    case XKB_KEY_dead_ogonek: return 0x02DB;
+    case XKB_KEY_dead_iota: return 0x037A;
+    case XKB_KEY_dead_voiced_sound: return 0x309B;
+    case XKB_KEY_dead_semivoiced_sound: return 0x309C;
+    case XKB_KEY_dead_belowdot: return 0x002E;
+    case XKB_KEY_dead_stroke: return 0x002D;
+    case XKB_KEY_dead_abovecomma: return 0x1FBF;
+    case XKB_KEY_dead_abovereversedcomma: return 0x1FFE;
+    case XKB_KEY_dead_doublegrave: return 0x02F5;
+    case XKB_KEY_dead_belowring: return 0x02F3;
+    case XKB_KEY_dead_belowmacron: return 0x02CD;
+    case XKB_KEY_dead_belowtilde: return 0x02F7;
+    case XKB_KEY_dead_currency: return 0x00A4;
+    case XKB_KEY_dead_lowline: return 0x005F;
+    case XKB_KEY_dead_aboveverticalline: return 0x02C8;
+    case XKB_KEY_dead_belowverticalline: return 0x02CC;
+    case XKB_KEY_dead_longsolidusoverlay: return 0x002F;
+    case XKB_KEY_dead_a: return 0x0061;
+    case XKB_KEY_dead_A: return 0x0041;
+    case XKB_KEY_dead_e: return 0x0065;
+    case XKB_KEY_dead_E: return 0x0045;
+    case XKB_KEY_dead_i: return 0x0069;
+    case XKB_KEY_dead_I: return 0x0049;
+    case XKB_KEY_dead_o: return 0x006F;
+    case XKB_KEY_dead_O: return 0x004F;
+    case XKB_KEY_dead_u: return 0x0075;
+    case XKB_KEY_dead_U: return 0x0055;
+    case XKB_KEY_dead_small_schwa: return 0x0259;
+    case XKB_KEY_dead_capital_schwa: return 0x018F;
+    /* The following are non-spacing characters, couldn't find good
+     * spacing alternatives. */
+    case XKB_KEY_dead_hook: return 0x0309;
+    case XKB_KEY_dead_horn: return 0x031B;
+    case XKB_KEY_dead_belowcircumflex: return 0x032D;
+    case XKB_KEY_dead_belowbreve: return 0x032E;
+    case XKB_KEY_dead_belowdiaeresis: return 0x0324;
+    case XKB_KEY_dead_invertedbreve: return 0x0311;
+    case XKB_KEY_dead_belowcomma: return 0x0326;
+    default: return 0;
+    }
+}
+
 /* Get the vkey corresponding to an xkb keycode, potentially translating it to
  * take into account the current keyboard state. */
 static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
@@ -175,6 +248,8 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
 
     xkb_state_unref(wayland->keyboard.xkb_state);
     wayland->keyboard.xkb_state = xkb_state;
+    if (wayland->keyboard.xkb_compose_state)
+        xkb_compose_state_reset(wayland->keyboard.xkb_compose_state);
 
     wayland_keyboard_update_layout(&wayland->keyboard);
 
@@ -323,6 +398,17 @@ static const struct wl_keyboard_listener keyboard_listener = {
 void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
                            struct wl_keyboard *wl_keyboard)
 {
+    struct xkb_compose_table *compose_table;
+    const char *locale;
+
+    locale = getenv("LC_ALL");
+    if (!locale || !*locale)
+        locale = getenv("LC_CTYPE");
+    if (!locale || !*locale)
+        locale = getenv("LANG");
+    if (!locale || !*locale)
+        locale = "C";
+
     keyboard->wl_keyboard = wl_keyboard;
     /* Some sensible default values for the repeat rate and delay. */
     keyboard->repeat_interval_ms = 40;
@@ -333,6 +419,20 @@ void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wa
         ERR("Failed to create XKB context\n");
         return;
     }
+    compose_table =
+        xkb_compose_table_new_from_locale(keyboard->xkb_context, locale,
+                                          XKB_COMPOSE_COMPILE_NO_FLAGS);
+    if (!compose_table)
+    {
+        ERR("Failed to create XKB compose table\n");
+        return;
+    }
+
+    keyboard->xkb_compose_state =
+        xkb_compose_state_new(compose_table, XKB_COMPOSE_STATE_NO_FLAGS);
+    xkb_compose_table_unref(compose_table);
+    if (!keyboard->xkb_compose_state)
+        ERR("Failed to create XKB compose table\n");
 
     wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
 }
@@ -345,8 +445,64 @@ void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
     if (keyboard->wl_keyboard)
         wl_keyboard_destroy(keyboard->wl_keyboard);
 
+    xkb_compose_state_unref(keyboard->xkb_compose_state);
     xkb_state_unref(keyboard->xkb_state);
     xkb_context_unref(keyboard->xkb_context);
 
     memset(keyboard, 0, sizeof(*keyboard));
 }
+
+/***********************************************************************
+ *           WAYLAND_ToUnicodeEx
+ */
+INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                              LPWSTR buf, int nchars, UINT flags, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    char utf8[64];
+    int utf8_len = 0;
+    struct xkb_compose_state *compose_state = wayland->keyboard.xkb_compose_state;
+    enum xkb_compose_status compose_status = XKB_COMPOSE_NOTHING;
+    xkb_keycode_t xkb_keycode;
+    xkb_keysym_t xkb_keysym;
+
+    if (!wayland->keyboard.xkb_state) return 0;
+
+    if (scan & 0x8000) return 0;  /* key up */
+
+    xkb_keycode = vkey_to_xkb_keycode(&wayland->keyboard, virt);
+
+    /* Try to compose */
+    xkb_keysym = xkb_state_key_get_one_sym(wayland->keyboard.xkb_state, xkb_keycode);
+    if (xkb_keysym != XKB_KEY_NoSymbol && compose_state &&
+        xkb_compose_state_feed(compose_state, xkb_keysym) == XKB_COMPOSE_FEED_ACCEPTED)
+    {
+        compose_status = xkb_compose_state_get_status(compose_state);
+    }
+
+    TRACE_(key)("vkey=0x%x scan=0x%x xkb_keycode=%d xkb_keysym=0x%x compose_status=%d\n",
+                virt, scan, xkb_keycode, xkb_keysym, compose_status);
+
+    if (compose_status == XKB_COMPOSE_NOTHING)
+    {
+        utf8_len = xkb_state_key_get_utf8(wayland->keyboard.xkb_state,
+                                          xkb_keycode, utf8, sizeof(utf8));
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSED)
+    {
+        utf8_len = xkb_compose_state_get_utf8(compose_state, utf8, sizeof(utf8));
+        TRACE_(key)("composed\n");
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSING && nchars > 0)
+    {
+        if ((buf[0] = dead_xkb_keysym_to_wchar(xkb_keysym)))
+        {
+            TRACE_(key)("returning dead char 0x%04x\n", buf[0]);
+            return -1;
+        }
+    }
+
+    TRACE_(key)("utf8 len=%d '%s'\n", utf8_len, utf8_len ? utf8 : "");
+
+    return MultiByteToWideChar(CP_UTF8, 0, utf8, utf8_len, buf, nchars);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1b272602fec..4e6e8535b93 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
+#include <xkbcommon/xkbcommon-compose.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -66,6 +67,7 @@ struct wayland_keyboard
     uint32_t enter_serial;
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
+    struct xkb_compose_state *xkb_compose_state;
     UINT xkb_keycode_to_vkey[256];
     WORD xkb_keycode_to_scancode[256];
 };
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index ba6147fd363..f5d65a82b50 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -6,5 +6,6 @@
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
+@ cdecl ToUnicodeEx(long long ptr ptr long long long) WAYLAND_ToUnicodeEx
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
 @ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) WAYLAND_WindowPosChanged
-- 
2.33.0


From 614e5b3c68d79cefdb9c669d0c661160680ef211 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:20:54 +0300
Subject: [PATCH 034/125] winewayland.drv: Implement GetKeyNameText.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c   | 178 ++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 2 files changed, 179 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 66bf06a4f63..f951fcbf6bb 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -46,6 +46,99 @@
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
+static const struct
+{
+    DWORD       vkey;
+    const char *name;
+} vkey_names[] = {
+    { VK_ADD,                   "Num +" },
+    { VK_BACK,                  "Backspace" },
+    { VK_CAPITAL,               "Caps Lock" },
+    { VK_CONTROL,               "Ctrl" },
+    { VK_DECIMAL,               "Num Del" },
+    { VK_DELETE,                "Delete" },
+    { VK_DIVIDE,                "Num /" },
+    { VK_DOWN,                  "Down" },
+    { VK_END,                   "End" },
+    { VK_ESCAPE,                "Esc" },
+    { VK_F1,                    "F1" },
+    { VK_F2,                    "F2" },
+    { VK_F3,                    "F3" },
+    { VK_F4,                    "F4" },
+    { VK_F5,                    "F5" },
+    { VK_F6,                    "F6" },
+    { VK_F7,                    "F7" },
+    { VK_F8,                    "F8" },
+    { VK_F9,                    "F9" },
+    { VK_F10,                   "F10" },
+    { VK_F11,                   "F11" },
+    { VK_F12,                   "F12" },
+    { VK_F13,                   "F13" },
+    { VK_F14,                   "F14" },
+    { VK_F15,                   "F15" },
+    { VK_F16,                   "F16" },
+    { VK_F17,                   "F17" },
+    { VK_F18,                   "F18" },
+    { VK_F19,                   "F19" },
+    { VK_F20,                   "F20" },
+    { VK_F21,                   "F21" },
+    { VK_F22,                   "F22" },
+    { VK_F23,                   "F23" },
+    { VK_F24,                   "F24" },
+    { VK_HELP,                  "Help" },
+    { VK_HOME,                  "Home" },
+    { VK_INSERT,                "Insert" },
+    { VK_LCONTROL,              "Ctrl" },
+    { VK_LEFT,                  "Left" },
+    { VK_LMENU,                 "Alt" },
+    { VK_LSHIFT,                "Shift" },
+    { VK_LWIN,                  "Win" },
+    { VK_MENU,                  "Alt" },
+    { VK_MULTIPLY,              "Num *" },
+    { VK_NEXT,                  "Page Down" },
+    { VK_NUMLOCK,               "Num Lock" },
+    { VK_NUMPAD0,               "Num 0" },
+    { VK_NUMPAD1,               "Num 1" },
+    { VK_NUMPAD2,               "Num 2" },
+    { VK_NUMPAD3,               "Num 3" },
+    { VK_NUMPAD4,               "Num 4" },
+    { VK_NUMPAD5,               "Num 5" },
+    { VK_NUMPAD6,               "Num 6" },
+    { VK_NUMPAD7,               "Num 7" },
+    { VK_NUMPAD8,               "Num 8" },
+    { VK_NUMPAD9,               "Num 9" },
+    { VK_OEM_CLEAR,             "Num Clear" },
+    { VK_OEM_NEC_EQUAL,         "Num =" },
+    { VK_PRIOR,                 "Page Up" },
+    { VK_RCONTROL,              "Right Ctrl" },
+    { VK_RETURN,                "Return" },
+    { VK_RETURN,                "Num Enter" },
+    { VK_RIGHT,                 "Right" },
+    { VK_RMENU,                 "Right Alt" },
+    { VK_RSHIFT,                "Right Shift" },
+    { VK_RWIN,                  "Right Win" },
+    { VK_SEPARATOR,             "Num ," },
+    { VK_SHIFT,                 "Shift" },
+    { VK_SPACE,                 "Space" },
+    { VK_SUBTRACT,              "Num -" },
+    { VK_TAB,                   "Tab" },
+    { VK_UP,                    "Up" },
+    { VK_VOLUME_DOWN,           "Volume Down" },
+    { VK_VOLUME_MUTE,           "Mute" },
+    { VK_VOLUME_UP,             "Volume Up" },
+    { VK_OEM_MINUS,             "-" },
+    { VK_OEM_PLUS,              "=" },
+    { VK_OEM_1,                 ";" },
+    { VK_OEM_2,                 "/" },
+    { VK_OEM_3,                 "`" },
+    { VK_OEM_4,                 "[" },
+    { VK_OEM_5,                 "\\" },
+    { VK_OEM_6,                 "]" },
+    { VK_OEM_7,                 "'" },
+    { VK_OEM_COMMA,             "," },
+    { VK_OEM_PERIOD,            "." },
+};
+
 static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
                                       xkb_keycode_t xkb_keycode)
 {
@@ -53,6 +146,17 @@ static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
            keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
 }
 
+static xkb_keycode_t scancode_to_xkb_keycode(struct wayland_keyboard *keyboard, WORD scan)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode); j++)
+        if ((keyboard->xkb_keycode_to_scancode[j] & 0xff) == (scan & 0xff))
+            return j;
+
+    return 0;
+}
+
 static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
                                  xkb_keycode_t xkb_keycode)
 {
@@ -73,6 +177,22 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return 0;
 }
 
+static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
+{
+    return _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
+}
+
+static const char* vkey_to_name(UINT vkey)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(vkey_names); j++)
+        if (vkey_names[j].vkey == vkey)
+            return vkey_names[j].name;
+
+    return NULL;
+}
+
 /* xkb keycodes are offset by 8 from linux input keycodes. */
 static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 {
@@ -506,3 +626,61 @@ INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
 
     return MultiByteToWideChar(CP_UTF8, 0, utf8, utf8_len, buf, nchars);
 }
+
+/***********************************************************************
+ *           GetKeyNameText
+ */
+INT CDECL WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+{
+    struct wayland *wayland = thread_init_wayland();
+    int scan, vkey, len;
+    const char *name;
+    char key[2];
+
+    scan = (lparam >> 16) & 0x1FF;
+    vkey = scancode_to_vkey(&wayland->keyboard, scan);
+
+    if (lparam & (1 << 25))
+    {
+        /* Caller doesn't care about distinctions between left and
+           right keys. */
+        switch (vkey)
+        {
+        case VK_LSHIFT:
+        case VK_RSHIFT:
+            vkey = VK_SHIFT; break;
+        case VK_LCONTROL:
+        case VK_RCONTROL:
+            vkey = VK_CONTROL; break;
+        case VK_LMENU:
+        case VK_RMENU:
+            vkey = VK_MENU; break;
+        }
+    }
+
+    if ((vkey >= 0x30 && vkey <= 0x39) || (vkey >= 0x41 && vkey <= 0x5a))
+    {
+        key[0] = vkey;
+        if (vkey >= 0x41)
+            key[0] += 0x20;
+        key[1] = 0;
+        name = key;
+    }
+    else
+    {
+        name = vkey_to_name(vkey);
+    }
+
+    len = MultiByteToWideChar(CP_UTF8, 0, name, -1, buffer, size);
+    if (len) len--;
+
+    if (!len)
+    {
+        static const WCHAR format[] = {'K','e','y',' ','0','x','%','0','2','x',0};
+        snprintfW(buffer, size, format, vkey);
+        len = strlenW(buffer);
+    }
+
+    TRACE_(key)("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
+    return len;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index f5d65a82b50..d1586dd6094 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -3,6 +3,7 @@
 @ cdecl CreateWindow(long) WAYLAND_CreateWindow
 @ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
+@ cdecl GetKeyNameText(long ptr long) WAYLAND_GetKeyNameText
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From dcca7f2a229a28a6e1ae7bf2533811dea978dca7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:24:49 +0300
Subject: [PATCH 035/125] winewayland.drv: Implement MapVirtualKeyEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c   | 135 ++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 2 files changed, 136 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index f951fcbf6bb..fc4161a2083 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -177,6 +177,11 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return 0;
 }
 
+static WORD vkey_to_scancode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    return _xkb_keycode_to_scancode(keyboard, vkey_to_xkb_keycode(keyboard, vkey));
+}
+
 static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
 {
     return _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
@@ -271,6 +276,28 @@ static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
     }
 }
 
+static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
+{
+    char utf8[64];
+    int utf8_len;
+    WCHAR wchars[8];
+    WCHAR normalized[8];
+    int nchars;
+
+    utf8_len = _xkb_keysyms_to_utf8(syms, nsyms, utf8, sizeof(utf8));
+
+    nchars = MultiByteToWideChar(CP_UTF8, 0, utf8, utf8_len, wchars,
+                                 ARRAY_SIZE(wchars));
+    if (nchars == 0)
+        return 0;
+
+    if (NormalizeString(NormalizationC, wchars, nchars, normalized,
+                        ARRAY_SIZE(normalized)) != 1)
+        return 0;
+
+    return normalized[0];
+}
+
 /* Get the vkey corresponding to an xkb keycode, potentially translating it to
  * take into account the current keyboard state. */
 static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
@@ -311,6 +338,48 @@ static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
     return vkey;
 }
 
+static UINT map_vkey_to_wchar_with_deadchar_bit(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WCHAR wchar;
+    xkb_keycode_t xkb_keycode;
+    struct xkb_keymap *xkb_keymap;
+    xkb_layout_index_t layout;
+    const xkb_keysym_t *syms;
+    int nsyms;
+
+    if (!keyboard->xkb_state) return 0;
+
+    layout = _xkb_state_get_active_layout(keyboard->xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("no active layout, returning wchar 0\n");
+        return 0;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(keyboard->xkb_state);
+    xkb_keycode = vkey_to_xkb_keycode(keyboard, vkey);
+
+    nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                             layout, 0, &syms);
+    if (nsyms > 0)
+    {
+        /* Set the high bit to 1 if this is dead char. */
+        if ((wchar = dead_xkb_keysym_to_wchar(syms[0])))
+            wchar |= 0x80000000;
+        else
+            wchar = _xkb_keysyms_to_wchar(syms, nsyms);
+    }
+    else
+    {
+        wchar = 0;
+    }
+
+    TRACE_(key)("vkey=0x%x xkb_keycode=%d nsyms=%d xkb_keysym[0]=0x%x => wchar=0x%x\n",
+                vkey, xkb_keycode, nsyms, nsyms ? syms[0] : 0, wchar);
+
+    return wchar;
+}
+
 static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
                                   uint32_t state, HWND hwnd)
 {
@@ -684,3 +753,69 @@ INT CDECL WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
     TRACE_(key)("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
     return len;
 }
+
+/***********************************************************************
+ *           WAYLAND_MapVirtualKeyEx
+ */
+UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    UINT ret = 0;
+
+    TRACE_(key)("code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl);
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+
+        ret = vkey_to_scancode(&wayland->keyboard, code);
+
+        /* set scan code prefix */
+        if (maptype == MAPVK_VK_TO_VSC_EX &&
+            (code == VK_RCONTROL || code == VK_RMENU))
+            ret |= 0xe000;
+        break;
+    case MAPVK_VSC_TO_VK:
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey(&wayland->keyboard, code);
+        if (maptype == MAPVK_VSC_TO_VK)
+        {
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        ret = map_vkey_to_wchar_with_deadchar_bit(&wayland->keyboard, code);
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index d1586dd6094..80b9ee44e8a 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -4,6 +4,7 @@
 @ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
 @ cdecl GetKeyNameText(long ptr long) WAYLAND_GetKeyNameText
+@ cdecl MapVirtualKeyEx(long long long) WAYLAND_MapVirtualKeyEx
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From fa96439fa12c059f52a56d65de7492bb130d520b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:31:19 +0300
Subject: [PATCH 036/125] winewayland.drv: Implement VkKeyScanEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c   | 93 +++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 2 files changed, 94 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index fc4161a2083..6e8d483ec67 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -298,6 +298,31 @@ static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
     return normalized[0];
 }
 
+static SHORT _xkb_mod_mask_to_win32(struct xkb_keymap *xkb_keymap,
+                                    xkb_mod_mask_t mod_mask)
+{
+    xkb_mod_index_t num_mods, i;
+    SHORT ret = 0;
+
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (mod_mask & (1 << i))
+        {
+            const char *mod_name = xkb_keymap_mod_get_name(xkb_keymap, i);
+
+            if (!strcmp(mod_name, XKB_MOD_NAME_SHIFT))
+                ret |= 0x0100;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_CTRL))
+                ret |= 0x0200;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_ALT))
+                ret |= 0x0400;
+        }
+    }
+
+    return ret;
+}
+
 /* Get the vkey corresponding to an xkb keycode, potentially translating it to
  * take into account the current keyboard state. */
 static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
@@ -819,3 +844,71 @@ UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
     TRACE_(key)("returning 0x%04x\n", ret);
     return ret;
 }
+
+/***********************************************************************
+ *           WAYLAND_VkKeyScanEx
+ */
+SHORT CDECL WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = wayland->keyboard.xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    TRACE_(key)("ch %04x hkl %p ...\n", ch, hkl);
+
+    if (!xkb_state)
+    {
+        TRACE_(key)("... no xkb state , returning -1\n");
+        return -1;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("... no active layout, returning -1\n");
+        return -1;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+
+    /* Search through all keycodes and their shift levels for one that
+     * produces a keysym that matches the requested character. */
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+
+            if (_xkb_keysyms_to_wchar(syms, nsyms) == ch)
+            {
+                UINT vkey;
+                xkb_mod_mask_t mod_mask;
+                SHORT ret;
+
+                vkey = _xkb_keycode_to_vkey(&wayland->keyboard, xkb_keycode);
+                if (vkey == 0)
+                    continue;
+
+                xkb_keymap_key_get_mods_for_level(xkb_keymap, xkb_keycode,
+                                                  layout, level, &mod_mask, 1);
+                ret = _xkb_mod_mask_to_win32(xkb_keymap, mod_mask) | vkey;
+
+                TRACE_(key)("... returning %04x\n", ret);
+                return ret;
+            }
+        }
+    }
+
+    TRACE_(key)("... matching vkey not found, returning -1\n");
+    return -1;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 80b9ee44e8a..f8b4ef42465 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -9,5 +9,6 @@
 @ cdecl SetCursor(long) WAYLAND_SetCursor
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl ToUnicodeEx(long long ptr ptr long long long) WAYLAND_ToUnicodeEx
+@ cdecl VkKeyScanEx(long long) WAYLAND_VkKeyScanEx
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
 @ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) WAYLAND_WindowPosChanged
-- 
2.33.0


From 2a0c120106040c905ace8b69c9bc75b6ce0988cc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 11:34:08 +0300
Subject: [PATCH 037/125] winewayland.drv: Refine heuristics for relative
 positioning of windows.

The current, simple heurestic for using a Wayland subsurface and relative
positioning for displaying a window is: it doesn't have a caption
AND it has an owner.

Since many applications use unowned top-level windows for various kinds
of popups, this commit adds a heurestic to detect detect such windows
and use relative positioning for them too: if a window is an unowned
top-level AND it doesn't have a caption AND it's relatively small
compared to the monitor size THEN use a subsurface/relative positioning.

Since for such windows we don't have a owner window, and thus a Wayland
surface parent to attach them to, we use the most recent surface the
user interacted with as the effective parent.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c |   1 +
 dlls/winewayland.drv/wayland_pointer.c  |   3 +
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/window.c           | 109 +++++++++++++++++++++++-
 4 files changed, 111 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 6e8d483ec67..ad2b3b1a65a 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -533,6 +533,7 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
     TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
 
     wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+    wayland->last_event_type = INPUT_KEYBOARD;
 
     wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index a7a23905526..5ee3ddfc477 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -62,6 +62,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
     input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
 
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
@@ -138,6 +139,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
         input.mi.dwFlags <<= 1;
 
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
@@ -190,6 +192,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     }
 
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4e6e8535b93..b4132e664b0 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -110,6 +110,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
+    DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
 };
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 8ac41db3cf7..e336fb1c4e4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -41,6 +41,9 @@ struct wayland_win_data
     HWND           hwnd;
     /* parent hwnd for child windows */
     HWND           parent;
+    /* effective parent hwnd (what the driver considers to
+     * be the parent for relative positioning) */
+    HWND           effective_parent;
     /* USER window rectangle relative to parent */
     RECT           window_rect;
     /* client area relative to parent */
@@ -51,6 +54,9 @@ struct wayland_win_data
     struct window_surface *window_surface;
     /* whether this window is visible */
     BOOL visible;
+    /* Save previous state to be able to decide when to recreate wayland surface */
+    HWND           old_parent;
+    RECT           old_window_rect;
     /* Whether a first wayland surface update is needed */
     BOOL           wayland_surface_needs_first_update;
 };
@@ -167,11 +173,107 @@ static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
     if (surface) LeaveCriticalSection(&win_data_section);
 }
 
+static HWND guess_popup_parent(struct wayland *wayland)
+{
+    HWND cursor_hwnd;
+    HWND keyboard_hwnd;
+    POINT cursor;
+
+    GetCursorPos(&cursor);
+    cursor_hwnd = wayland->pointer.focused_surface ?
+                  wayland->pointer.focused_surface->hwnd :
+                  WindowFromPoint(cursor);
+    cursor_hwnd = GetAncestor(cursor_hwnd, GA_ROOT);
+    keyboard_hwnd = GetFocus();
+
+    TRACE("cursor_hwnd=%p keyboard_hwnd=%p\n", cursor_hwnd, keyboard_hwnd);
+
+    /* If we have a recent mouse event, the popup parent is likely the window
+     * under the cursor, so prefer it. Otherwise prefer the window with
+     * the keyboard focus. */
+    if (wayland->last_event_type == INPUT_MOUSE)
+        return cursor_hwnd ? cursor_hwnd : keyboard_hwnd;
+    else
+        return keyboard_hwnd ? keyboard_hwnd : cursor_hwnd;
+}
+
+static HWND wayland_win_data_get_effective_parent(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_init_wayland();
+    DWORD style = GetWindowLongW(data->hwnd, GWL_STYLE);
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    HWND parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    HWND effective_parent_hwnd;
+    MONITORINFOEXW mi;
+    double monitor_width;
+    double monitor_height;
+    double window_width;
+    double window_height;
+
+    if (parent_hwnd == GetDesktopWindow()) parent_hwnd = 0;
+
+    /* Child windows don't have an effective parent, unless they are children
+     * of the desktop (thus effectively top-level). */
+    if ((style & WS_CHILD) && parent_hwnd) return 0;
+
+    mi.cbSize = sizeof(mi);
+    GetMonitorInfoW(MonitorFromRect(&data->window_rect, MONITOR_DEFAULTTOPRIMARY),
+                    (MONITORINFO *)&mi);
+
+    monitor_width = mi.rcMonitor.right - mi.rcMonitor.left;
+    monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
+    window_width = data->window_rect.right - data->window_rect.left;
+    window_height = data->window_rect.bottom - data->window_rect.top;
+
+    /* Many applications use top level, unowned (or owned by the desktop)
+     * popup windows for menus and tooltips and depend on screen
+     * coordinates for correct positioning. Since wayland can't deal with
+     * screen coordinates, try to guess the effective parent window of such
+     * popups and manage them as wayland subsurfaces. Our heuristic is to
+     * treat all unowned, undecorated top-level windows with reasonable size
+     * as transient popups.  */
+    if (!parent_hwnd && (style & WS_CAPTION) != WS_CAPTION &&
+        window_width > 1.0 && window_height > 1.0 &&
+        window_width * window_height < 0.5 * monitor_width * monitor_height)
+    {
+        effective_parent_hwnd = guess_popup_parent(wayland);
+        if (effective_parent_hwnd == data->hwnd ||
+            effective_parent_hwnd == GetDesktopWindow())
+        {
+            effective_parent_hwnd = 0;
+        }
+    }
+    else
+    {
+        effective_parent_hwnd = parent_hwnd;
+    }
+
+    TRACE("hwnd=%p parent=%p effective_parent=%p style=0x%08x rect=%s monitor=%s\n",
+          data->hwnd, parent_hwnd, effective_parent_hwnd, style,
+          wine_dbgstr_rect(&data->window_rect),
+          wine_dbgstr_rect(&mi.rcMonitor));
+
+    return effective_parent_hwnd;
+}
+
 static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
 {
     if (data->wayland_surface_needs_first_update)
         return TRUE;
 
+    /* Change of parentage (either actual or effective) requires recreating the
+     * whole win_data to ensure we have a properly owned wayland surface. We
+     * check for change of effective parent only if the window changed in any
+     * way, to avoid spuriously reassigning parent windows when new windows
+     * are created. */
+    if ((!EqualRect(&data->window_rect, &data->old_window_rect) &&
+         data->effective_parent != wayland_win_data_get_effective_parent(data)) ||
+        data->parent != data->old_parent)
+    {
+        return TRUE;
+    }
+
     /* If this is currently or potentially a toplevel surface, and its
      * visibility state has changed, recreate win_data so that we only have
      * xdg_toplevels for visible windows. */
@@ -209,9 +311,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
      * surface. */
     if (data->parent) return;
 
-    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
-     * and the parent for child windows. */
-    effective_parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    effective_parent_hwnd = wayland_win_data_get_effective_parent(data);
     parent_surface = NULL;
 
     if (effective_parent_hwnd)
@@ -220,6 +320,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         wayland_surface_for_hwnd_unlock(parent_surface);
     }
 
+    data->effective_parent = effective_parent_hwnd;
     style = GetWindowLongW(data->hwnd, GWL_STYLE);
 
     /* Use wayland subsurfaces for owned win32 windows that are transient (i.e., don't have
@@ -300,6 +401,8 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
 
     if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
 
+    data->old_parent = data->parent;
+    data->old_window_rect = data->window_rect;
     data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
-- 
2.33.0


From 3254311477b01398e50c7e29edd3cc91524f09dc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:01:12 +0300
Subject: [PATCH 038/125] winewayland.drv: Update Wayland surface state.

When the properties of window change, update the state of the Wayland
surface backing that window. This potentially involves requesting a
state change from the compositor and setting proper values for the
surface geometry and subsurface position, when applicable.

In order to avoid protocol errors, apply the new state only if the
current or pending Wayland configure events are compatible with it. In
the latter case also acknowledge the pending event.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c |  50 ++++++++
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/window.c          | 154 +++++++++++++++++++++++++
 3 files changed, 207 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5a867520087..a99f52be846 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -251,6 +251,56 @@ err:
     return NULL;
 }
 
+/**********************************************************************
+ *          wayland_surface_reconfigure
+ *
+ * Configures the position and size of a wayland surface. Depending on the
+ * surface type, either repositioning or resizing may have no effect.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure(struct wayland_surface *surface,
+                                 int wine_x, int wine_y,
+                                 int wine_width, int wine_height)
+{
+    int x, y, width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    if (surface->wl_subsurface)
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+
+    if (surface->xdg_surface && width != 0 && height != 0)
+        xdg_surface_set_window_geometry(surface->xdg_surface, 0, 0, width, height);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
+
 static RGNDATA *get_region_data(HRGN region)
 {
     RGNDATA *data = NULL;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b4132e664b0..8806b287f15 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -273,6 +273,9 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
                                    struct wayland_shm_buffer *shm_buffer,
                                    HRGN surface_damage_region);
 void wayland_surface_destroy(struct wayland_surface *surface);
+void wayland_surface_reconfigure(struct wayland_surface *surface, int x, int y,
+                                 int width,int height);
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e336fb1c4e4..3f4fed000ab 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -52,6 +52,10 @@ struct wayland_win_data
     struct wayland_surface *wayland_surface;
     /* wine window_surface backing this window */
     struct window_surface *window_surface;
+    /* whether the window is currently fullscreen */
+    BOOL           fullscreen;
+    /* whether the window is currently maximized */
+    BOOL           maximized;
     /* whether this window is visible */
     BOOL visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -338,11 +342,161 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         data->wayland_surface->hwnd = data->hwnd;
 }
 
+static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
+{
+    RECT parent_rect = {0};
+    MONITORINFOEXW mi;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    int monitor_width;
+    int monitor_height;
+    struct wayland_win_data *parent_data;
+    enum wayland_configure_flags conf_flags = 0;
+    struct wayland_output *output;
+    DWORD style = GetWindowLongW(data->hwnd, GWL_STYLE);
+
+    mi.cbSize = sizeof(mi);
+    GetMonitorInfoW(MonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY), (MONITORINFO *)&mi);
+    monitor_width = mi.rcMonitor.right - mi.rcMonitor.left;
+    monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
+    output = wayland_output_get_by_wine_name(data->wayland_surface->wayland, mi.szDevice);
+
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d\n",
+          data->hwnd, width, height, monitor_width, monitor_height,
+          data->maximized, data->fullscreen);
+
+    if (!(style & WS_VISIBLE))
+    {
+        wayland_surface_unmap(data->wayland_surface);
+        return;
+    }
+
+    /* Set the wayland fullscreen state if the window rect covers the
+     * current monitor exactly. Note that we set/maintain the fullscreen
+     * wayland state, even if the window style is also maximized. */
+    if (EqualRect(&data->window_rect, &mi.rcMonitor) &&
+        !(style & (WS_MINIMIZE|WS_CAPTION)))
+    {
+        conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+    }
+    if (style & WS_MAXIMIZE)
+    {
+        conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+    }
+
+    /* First do all state unsettings, before setting new state. Some wayland
+     * compositors misbehave if the order is reversed. */
+    if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        xdg_toplevel_unset_maximized(data->wayland_surface->xdg_toplevel);
+        data->maximized = FALSE;
+    }
+
+    if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        xdg_toplevel_unset_fullscreen(data->wayland_surface->xdg_toplevel);
+        data->fullscreen = FALSE;
+    }
+
+    if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        xdg_toplevel_set_maximized(data->wayland_surface->xdg_toplevel);
+        data->maximized = TRUE;
+    }
+
+   /* Set the fullscreen state after the maximized state on the wayland surface
+    * to ensure compositors apply the final fullscreen state properly. */
+    if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        xdg_toplevel_set_fullscreen(data->wayland_surface->xdg_toplevel,
+                                    output ? output->wl_output : NULL);
+        data->fullscreen = TRUE;
+    }
+
+    TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
+          data->hwnd, data->maximized, data->fullscreen);
+
+    if (data->wayland_surface->xdg_toplevel)
+    {
+        int wayland_width, wayland_height;
+        BOOL compat_with_current = FALSE;
+        BOOL compat_with_pending = FALSE;
+
+        wayland_surface_coords_rounded_from_wine(data->wayland_surface, width, height,
+                                                 &wayland_width, &wayland_height);
+
+        if (data->wayland_surface->current.serial &&
+            wayland_surface_configure_is_compatible(&data->wayland_surface->current,
+                                                    wayland_width, wayland_height,
+                                                    conf_flags))
+        {
+            compat_with_current = TRUE;
+        }
+
+        if (data->wayland_surface->pending.serial &&
+            wayland_surface_configure_is_compatible(&data->wayland_surface->pending,
+                                                    wayland_width, wayland_height,
+                                                    conf_flags))
+        {
+            compat_with_pending = TRUE;
+        }
+
+        TRACE("current conf serial=%d size=%dx%d flags=%#x\n compat=%d\n",
+              data->wayland_surface->current.serial,
+              data->wayland_surface->current.width,
+              data->wayland_surface->current.height,
+              data->wayland_surface->current.configure_flags,
+              compat_with_current);
+        TRACE("pending conf serial=%d size=%dx%d flags=%#x compat=%d\n",
+              data->wayland_surface->pending.serial,
+              data->wayland_surface->pending.width,
+              data->wayland_surface->pending.height,
+              data->wayland_surface->pending.configure_flags,
+              compat_with_pending);
+
+        /* Only update the wayland surface state to match the window
+         * configuration if the surface can accept the new config, in order to
+         * avoid causing a protocol error. */
+        if (!compat_with_pending && !compat_with_current)
+        {
+            TRACE("hwnd=%p window state not compatible with current or "
+                  "pending wayland surface configuration\n", data->hwnd);
+            return;
+        }
+
+        if (compat_with_pending)
+            wayland_surface_ack_pending_configure(data->wayland_surface);
+    }
+
+    /* We manage some top level, popup window with subsurfaces (see
+     * wayland_win_data_get_effective_parent), which use coordinates relative
+     * to their parent surface. */
+    parent_data = wayland_win_data_get(data->effective_parent);
+    if (parent_data)
+    {
+        TRACE("positioning relative to parent hwnd=%p window %s\n",
+              parent_data->hwnd, wine_dbgstr_rect(&parent_data->window_rect));
+        parent_rect = parent_data->window_rect;
+    }
+
+    wayland_surface_reconfigure(data->wayland_surface,
+                                data->window_rect.left - parent_rect.left,
+                                data->window_rect.top - parent_rect.top,
+                                width, height);
+
+    wayland_surface_reconfigure_apply(data->wayland_surface);
+
+    wayland_win_data_release(parent_data);
+}
+
 static void update_wayland_state(struct wayland_win_data *data)
 {
     if (wayland_win_data_wayland_surface_needs_update(data))
         wayland_win_data_update_wayland_surface(data);
 
+    if (data->wayland_surface)
+        wayland_win_data_update_wayland_surface_state(data);
+
     if (data->window_surface)
     {
         wayland_window_surface_update_wayland_surface(data->window_surface,
-- 
2.33.0


From 3c4b2ebabd5ced91842d30fa27834ff04178c102 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:09:31 +0300
Subject: [PATCH 039/125] winewayland.drv: Disallow flushing windows with
 incorrectly sized buffers.

When we detect that a window is not compatible with the current Wayland
surface state, disallow window_surface flushes to avoid protocol errors.

This is typically a transient condition, and the flush will be performed
as soon as the window becomes compatible with its backing Wayland
surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 17 +++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 dlls/winewayland.drv/window.c          |  4 ++++
 dlls/winewayland.drv/window_surface.c  |  5 +++--
 4 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index a99f52be846..4c869384d74 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -135,6 +135,7 @@ static struct wayland_surface *wayland_surface_create_common(struct wayland *way
         goto err;
 
     wl_surface_set_user_data(surface->wl_surface, surface);
+    surface->drawing_allowed = TRUE;
 
     surface->ref = 1;
 
@@ -578,3 +579,19 @@ void wayland_surface_unref(struct wayland_surface *surface)
     if (ref == 0)
         wayland_surface_destroy(surface);
 }
+
+/**********************************************************************
+ *          wayland_surface_set_drawing_allowed
+ */
+void wayland_surface_set_drawing_allowed(struct wayland_surface *surface, BOOL allowed)
+{
+    __atomic_store_n(&surface->drawing_allowed, allowed, __ATOMIC_SEQ_CST);
+}
+
+/**********************************************************************
+ *          wayland_surface_is_drawing_allowed
+ */
+BOOL wayland_surface_is_drawing_allowed(struct wayland_surface *surface)
+{
+    return __atomic_load_n(&surface->drawing_allowed, __ATOMIC_SEQ_CST);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8806b287f15..1c226930318 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -164,6 +164,7 @@ struct wayland_surface
     struct wayland_surface_configure current;
     BOOL mapped;
     LONG ref;
+    BOOL drawing_allowed;
 };
 
 struct wayland_buffer_queue
@@ -292,6 +293,8 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     int *wine_x, int *wine_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
+void wayland_surface_set_drawing_allowed(struct wayland_surface *surface, BOOL allowed);
+BOOL wayland_surface_is_drawing_allowed(struct wayland_surface *surface);
 
 /**********************************************************************
  *          Wayland SHM buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 3f4fed000ab..3917e7d949b 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -367,6 +367,7 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     if (!(style & WS_VISIBLE))
     {
+        wayland_surface_set_drawing_allowed(data->wayland_surface, TRUE);
         wayland_surface_unmap(data->wayland_surface);
         return;
     }
@@ -461,6 +462,7 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         {
             TRACE("hwnd=%p window state not compatible with current or "
                   "pending wayland surface configuration\n", data->hwnd);
+            wayland_surface_set_drawing_allowed(data->wayland_surface, FALSE);
             return;
         }
 
@@ -486,6 +488,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(data->wayland_surface);
 
+    wayland_surface_set_drawing_allowed(data->wayland_surface, TRUE);
+
     wayland_win_data_release(parent_data);
 }
 
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index cf76866dd7c..f2b93646607 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -143,9 +143,10 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
     needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
     if (needs_flush &&
-        (!wws->wayland_surface || !wws->wayland_buffer_queue))
+        (!wws->wayland_surface || !wws->wayland_buffer_queue ||
+         !wayland_surface_is_drawing_allowed(wws->wayland_surface)))
     {
-        TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
+        TRACE("missing wayland surface=%p buffer_queue=%p or drawing disallowed, returning\n",
               wws->wayland_surface, wws->wayland_buffer_queue);
         wws->last_flush_missing_wayland = TRUE;
         goto done;
-- 
2.33.0


From a62522be10a4127e443f06c94b9156e8897bb63a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:30:53 +0300
Subject: [PATCH 040/125] winewayland.drv: Handle dynamic Wayland surface
 configure events.

When a Wayland configure event arrives, change the window size and
state to match what the compositor has requested.

While resizing, configure events can come continuously and due to the
amount of other message their handling produces (e.g., paints), have the
potential to keep the message loop busy for some time. This may lead
Wine core to think that the app never goes idle (see win.c:
flush_window_surfaces), and thus start flushing at unfortunate times
(e.g., in between partial window paints), causing visual artifacts.

To mitigate this we handle the configure message only if the message
queue is empty, ensuring that the loop has had time to become idle.  If
the queue is not currently empty, we schedule a timer message, which due
to having the lowest priority is guaranteed to be triggered only on
otherwise empty queues.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c    |  20 +-
 dlls/winewayland.drv/waylanddrv.h         |   5 +
 dlls/winewayland.drv/window.c             | 255 ++++++++++++++++++++--
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 4 files changed, 265 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 4c869384d74..9833373b25c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -32,12 +32,30 @@ static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_sur
                                          uint32_t serial)
 {
     struct wayland_surface *surface = data;
+    uint32_t last_serial = surface->pending.serial;
+    BOOL last_processed = surface->pending.processed;
 
     TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
 
     surface->pending.serial = serial;
+    surface->pending.processed = FALSE;
+
+    /* If we have an unprocessed WM_WAYLAND_CONFIGURE message, no need to
+     * repost. Note that checking only for a valid serial is not enough to
+     * guarantee that there is a pending WM_WAYLAND_CONFIGURE message: we may
+     * have processed the message but not acked the configure request due to
+     * surface size incompatibilities (see window.c:
+     * wayland_win_data_update_wayland_surface_state()). */
+    if (last_serial && !last_processed)
+    {
+        TRACE("not reposting, last_serial=%u\n", last_serial);
+        return;
+    }
 
-    wayland_surface_ack_pending_configure(surface);
+    if (surface->hwnd)
+        PostMessageW(surface->hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+    else
+        wayland_surface_ack_pending_configure(surface);
 }
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1c226930318..b5fd819ab79 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -41,6 +41,10 @@ extern struct wl_display *process_wl_display;
 /**********************************************************************
  *          Internal messages and data
  */
+enum wayland_window_message
+{
+    WM_WAYLAND_CONFIGURE = 0x80001000,
+};
 
 enum wayland_configure_flags
 {
@@ -148,6 +152,7 @@ struct wayland_surface_configure
     int height;
     enum wayland_configure_flags configure_flags;
     uint32_t serial;
+    BOOL processed;
 };
 
 struct wayland_surface
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 3917e7d949b..6eb1c415970 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -52,10 +52,18 @@ struct wayland_win_data
     struct wayland_surface *wayland_surface;
     /* wine window_surface backing this window */
     struct window_surface *window_surface;
+    /* whether this window is currently being resized */
+    BOOL           resizing;
+    /* the window_rect this window should be restored to after unmaximizing */
+    RECT           restore_rect;
     /* whether the window is currently fullscreen */
     BOOL           fullscreen;
     /* whether the window is currently maximized */
     BOOL           maximized;
+    /* whether we are currently handling a wayland configure event */
+    BOOL           handling_wayland_configure_event;
+    /* the configure flags for the configure event we are handling */
+    enum wayland_configure_flags wayland_configure_event_flags;
     /* whether this window is visible */
     BOOL visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -361,9 +369,9 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
     monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
     output = wayland_output_get_by_wine_name(data->wayland_surface->wayland, mi.szDevice);
 
-    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d\n",
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d handling_event=%d\n",
           data->hwnd, width, height, monitor_width, monitor_height,
-          data->maximized, data->fullscreen);
+          data->maximized, data->fullscreen, data->handling_wayland_configure_event);
 
     if (!(style & WS_VISIBLE))
     {
@@ -372,36 +380,50 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         return;
     }
 
-    /* Set the wayland fullscreen state if the window rect covers the
-     * current monitor exactly. Note that we set/maintain the fullscreen
-     * wayland state, even if the window style is also maximized. */
-    if (EqualRect(&data->window_rect, &mi.rcMonitor) &&
-        !(style & (WS_MINIMIZE|WS_CAPTION)))
+    /* If we are currently handling a wayland configure event (i.e., we are
+     * being called through handle_wm_wayland_configure() -> SetWindowPos()),
+     * use the event configure flags directly. Otherwise try to infer the flags
+     * from the window style and rectangle. */
+    if (data->handling_wayland_configure_event)
     {
-        conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        conf_flags = data->wayland_configure_event_flags;
     }
-    if (style & WS_MAXIMIZE)
+    else
     {
-        conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        /* Set the wayland fullscreen state if the window rect covers the
+         * current monitor exactly. Note that we set/maintain the fullscreen
+         * wayland state, even if the window style is also maximized. */
+        if (EqualRect(&data->window_rect, &mi.rcMonitor) &&
+            !(style & (WS_MINIMIZE|WS_CAPTION)))
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        }
+        if (style & WS_MAXIMIZE)
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        }
     }
 
     /* First do all state unsettings, before setting new state. Some wayland
      * compositors misbehave if the order is reversed. */
     if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
-        xdg_toplevel_unset_maximized(data->wayland_surface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_maximized(data->wayland_surface->xdg_toplevel);
         data->maximized = FALSE;
     }
 
     if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        xdg_toplevel_unset_fullscreen(data->wayland_surface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_fullscreen(data->wayland_surface->xdg_toplevel);
         data->fullscreen = FALSE;
     }
 
     if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
-        xdg_toplevel_set_maximized(data->wayland_surface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_set_maximized(data->wayland_surface->xdg_toplevel);
         data->maximized = TRUE;
     }
 
@@ -409,11 +431,23 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
     * to ensure compositors apply the final fullscreen state properly. */
     if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        xdg_toplevel_set_fullscreen(data->wayland_surface->xdg_toplevel,
-                                    output ? output->wl_output : NULL);
+        if (!data->handling_wayland_configure_event)
+        {
+            xdg_toplevel_set_fullscreen(data->wayland_surface->xdg_toplevel,
+                                        output ? output->wl_output : NULL);
+        }
         data->fullscreen = TRUE;
     }
 
+    if (!(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        !(style & WS_MINIMIZE))
+    {
+        data->restore_rect = data->window_rect;
+        TRACE("setting hwnd=%p restore_rect=%s\n",
+              data->hwnd, wine_dbgstr_rect(&data->restore_rect));
+    }
+
     TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
           data->hwnd, data->maximized, data->fullscreen);
 
@@ -619,3 +653,194 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
 
     wayland_win_data_release(data);
 }
+
+static LRESULT handle_wm_wayland_configure(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+    DWORD flags;
+    int width, height, wine_width, wine_height;
+    BOOL needs_move_to_origin;
+    int origin_x, origin_y;
+    UINT swp_flags;
+    BOOL needs_enter_size_move = FALSE;
+    BOOL needs_exit_size_move = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return 0;
+    if (!data->wayland_surface || !data->wayland_surface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface = data->wayland_surface;
+
+    TRACE("serial=%d size=%dx%d flags=%#x restore_rect=%s\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          wine_dbgstr_rect(&data->restore_rect));
+
+    if (wsurface->pending.serial == 0)
+    {
+        TRACE("pending configure event already handled, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface->pending.processed = TRUE;
+
+    data->wayland_configure_event_flags = wsurface->pending.configure_flags;
+
+    width = wsurface->pending.width;
+    height = wsurface->pending.height;
+    flags = wsurface->pending.configure_flags;
+
+    /* If we are free to set our size, first try the restore size, then
+     * the current size. */
+    if (width == 0)
+    {
+        int ignore;
+        width = data->restore_rect.right - data->restore_rect.left;
+        if (width == 0)
+            width = data->window_rect.right - data->window_rect.left;
+        wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
+                                                 &width, &ignore);
+        wsurface->pending.width = width;
+    }
+    if (height == 0)
+    {
+        int ignore;
+        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (height == 0)
+            height = data->window_rect.bottom - data->window_rect.top;
+        wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
+                                                 &ignore, &height);
+        wsurface->pending.height = height;
+    }
+
+    wayland_surface_coords_to_wine(wsurface, width, height,
+                                   &wine_width, &wine_height);
+
+    TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
+          data->hwnd, width, height, wine_width, wine_height);
+
+    if ((flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && !data->resizing)
+    {
+        data->resizing = TRUE;
+        needs_enter_size_move = TRUE;
+    }
+
+    if (!(flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && data->resizing)
+    {
+        data->resizing = FALSE;
+        needs_exit_size_move = TRUE;
+    }
+
+    /* Parts of the window that are outside the win32 display are not
+     * accessible to mouse events, although they may be visible and accessible
+     * to the user from a wayland compositor pespective. To mitigate this, we
+     * place all top-level windows at 0,0, to maximize the area that can reside
+     * within the win32 display. */
+    origin_x = 0;
+    origin_y = 0;
+    needs_move_to_origin = data->window_rect.top != origin_x ||
+                           data->window_rect.left != origin_y;
+    TRACE("current=%d,%d origin=%d,%d\n",
+          data->window_rect.left, data->window_rect.top,
+          origin_x, origin_y);
+
+    wayland_win_data_release(data);
+
+    if (needs_enter_size_move)
+        SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+
+    if (needs_exit_size_move)
+        SendMessageW(hwnd, WM_EXITSIZEMOVE, 0, 0);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = TRUE;
+        wayland_win_data_release(data);
+    }
+
+    if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+        SetWindowLongW(hwnd, GWL_STYLE, GetWindowLongW(hwnd, GWL_STYLE) | WS_MAXIMIZE);
+    else
+        SetWindowLongW(hwnd, GWL_STYLE, GetWindowLongW(hwnd, GWL_STYLE) & ~WS_MAXIMIZE);
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER;
+
+    if (!needs_move_to_origin) swp_flags |= SWP_NOMOVE;
+    if (wine_width > 0 && wine_height > 0)
+        swp_flags |= SWP_FRAMECHANGED;
+    else
+        swp_flags |= SWP_NOSIZE | SWP_NOREDRAW;
+    /* When we are maximized or fullscreen, wayland is particular about the
+     * surface size it accepts, so don't allow the app to change it. */
+    if (flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+        swp_flags |= SWP_NOSENDCHANGING;
+
+    SetWindowPos(hwnd, 0, origin_x, origin_y, wine_width, wine_height, swp_flags);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = FALSE;
+        wayland_win_data_release(data);
+    }
+
+    return 0;
+}
+
+static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    TRACE("hwnd=%p\n", hwnd);
+    KillTimer(hwnd, timer_id);
+    handle_wm_wayland_configure(hwnd);
+}
+
+/**********************************************************************
+ *           WAYLAND_WindowMessage
+ */
+LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    TRACE("msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
+
+    switch (msg)
+    {
+    case WM_WAYLAND_CONFIGURE:
+        /* While resizing, configure events can come continuously and due to the
+         * amount of other message their handling produces (e.g., paints), have
+         * the potential to keep the message loop busy for some time. This may
+         * lead Wine core to think that the app never goes idle (see
+         * win.c:flush_window_surfaces), and thus start flushing at unfortunate
+         * times (e.g., in between partial window paints), causing visual
+         * artifacts.
+         *
+         * To mitigate this we handle the configure message only if the message
+         * queue is empty, ensuring that the loop has had time to become idle.
+         * If the queue is not currently empty, we schedule a timer message,
+         * which due to having the lowest priority is guaranteed to be triggered
+         * only on otherwise empty queues.
+         */
+        if (!GetQueueStatus(QS_ALLINPUT))
+        {
+            return handle_wm_wayland_configure(hwnd);
+        }
+        else
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface && wayland_surface->xdg_toplevel)
+            {
+                SetTimer(hwnd, (UINT_PTR)wayland_surface->wl_surface, 10,
+                         post_configure);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
+    default:
+        FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
+    }
+
+    return 0;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index f8b4ef42465..f4fa91b65ac 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -10,5 +10,6 @@
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl ToUnicodeEx(long long ptr ptr long long long) WAYLAND_ToUnicodeEx
 @ cdecl VkKeyScanEx(long long) WAYLAND_VkKeyScanEx
+@ cdecl WindowMessage(long long long long) WAYLAND_WindowMessage
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
 @ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) WAYLAND_WindowPosChanged
-- 
2.33.0


From 29d98ec9f792b1c660d55e1e3807d408f8fa99ea Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:40:58 +0300
Subject: [PATCH 041/125] winewayland.drv: Handle window minimization and
 restoration.

Request a minimized state from the Wayland compositor when a window
is minimized.

Since Wayland doesn't provide any explicit information about the
minimization state of surfaces, we heurestically infer a restoration
from a minimized state by using the activation state of the surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c             | 71 ++++++++++++++++++++++-
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 2 files changed, 70 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 6eb1c415970..35dccc669ca 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -64,6 +64,8 @@ struct wayland_win_data
     BOOL           handling_wayland_configure_event;
     /* the configure flags for the configure event we are handling */
     enum wayland_configure_flags wayland_configure_event_flags;
+    /* whether this window has been deactivated by wayland after minimization */
+    BOOL deactivated_after_minimization;
     /* whether this window is visible */
     BOOL visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -654,6 +656,32 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
     wayland_win_data_release(data);
 }
 
+/***********************************************************************
+ *           WAYLAND_ShowWindow
+ */
+UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+{
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p cmd=%d\n", hwnd, cmd);
+
+    if (IsRectEmpty(rect)) return swp;
+    if (!IsIconic(hwnd)) return swp;
+    /* always hide icons off-screen */
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect(rect, -32000 - rect->left, -32000 - rect->top);
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+
+    if ((wsurface = wayland_surface_for_hwnd_lock(hwnd)) && wsurface->xdg_toplevel)
+        xdg_toplevel_set_minimized(wsurface->xdg_toplevel);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+
+    return swp;
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
@@ -663,6 +691,7 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     BOOL needs_move_to_origin;
     int origin_x, origin_y;
     UINT swp_flags;
+    BOOL needs_restore = FALSE;
     BOOL needs_enter_size_move = FALSE;
     BOOL needs_exit_size_move = FALSE;
 
@@ -688,6 +717,36 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
         return 0;
     }
 
+    if (IsIconic(hwnd) &&
+        !(wsurface->pending.configure_flags & WAYLAND_CONFIGURE_FLAG_ACTIVATED))
+    {
+        data->deactivated_after_minimization = TRUE;
+    }
+
+    /* Restore a minimized window if it is activated. We only do this after we
+     * have seen a deactivation event for the surface or if the flags indicate
+     * an explicit non-minimized state, to ensure we don't restore prematurely,
+     * e.g., while minimization is still in progress. */
+    if (IsIconic(hwnd) &&
+        (wsurface->pending.configure_flags & WAYLAND_CONFIGURE_FLAG_ACTIVATED) &&
+        (data->deactivated_after_minimization ||
+         (wsurface->pending.configure_flags &
+          (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN))))
+    {
+        needs_restore = TRUE;
+        data->deactivated_after_minimization = FALSE;
+        /* If allowed, ignore the restoration size provided by wayland, since
+         * it may cause wayland_win_data.restore_rect to be set and mess up our
+         * own tracking.
+         */
+        if (!(wsurface->pending.configure_flags &
+              (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN)))
+        {
+            wsurface->pending.width = 0;
+            wsurface->pending.height = 0;
+        }
+    }
+
     wsurface->pending.processed = TRUE;
 
     data->wayland_configure_event_flags = wsurface->pending.configure_flags;
@@ -701,7 +760,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (width == 0)
     {
         int ignore;
-        width = data->restore_rect.right - data->restore_rect.left;
+        if (!IsIconic(hwnd) || needs_restore)
+            width = data->restore_rect.right - data->restore_rect.left;
         if (width == 0)
             width = data->window_rect.right - data->window_rect.left;
         wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
@@ -711,7 +771,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (height == 0)
     {
         int ignore;
-        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (!IsIconic(hwnd) || needs_restore)
+            height = data->restore_rect.bottom - data->restore_rect.top;
         if (height == 0)
             height = data->window_rect.bottom - data->window_rect.top;
         wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
@@ -752,6 +813,12 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
 
     wayland_win_data_release(data);
 
+    if (needs_restore)
+    {
+        ShowOwnedPopups(hwnd, TRUE);
+        ShowWindow(hwnd, SW_RESTORE);
+    }
+
     if (needs_enter_size_move)
         SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
 
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index f4fa91b65ac..7ff506195cc 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -7,6 +7,7 @@
 @ cdecl MapVirtualKeyEx(long long long) WAYLAND_MapVirtualKeyEx
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
+@ cdecl ShowWindow(long long ptr long) WAYLAND_ShowWindow
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl ToUnicodeEx(long long ptr ptr long long long) WAYLAND_ToUnicodeEx
 @ cdecl VkKeyScanEx(long long) WAYLAND_VkKeyScanEx
-- 
2.33.0


From 483135fc78109d2869b071a4f12e384f1eab4071 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:49:26 +0300
Subject: [PATCH 042/125] winewayland.drv: Handle interactive window resizing.

Propagate resize notification to the Wayland compositor, so it can
update the surface size by sending new Wayland configure events.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_pointer.c    |  5 +++
 dlls/winewayland.drv/waylanddrv.h         |  1 +
 dlls/winewayland.drv/window.c             | 46 +++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 4 files changed, 53 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 5ee3ddfc477..3791bc54f59 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -141,6 +141,11 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
     wayland->last_event_type = INPUT_MOUSE;
 
+    if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+        wayland->last_button_serial = serial;
+    else
+        wayland->last_button_serial = 0;
+
     __wine_send_input(focused_hwnd, &input, NULL);
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b5fd819ab79..9e658286c00 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -114,6 +114,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
+    uint32_t last_button_serial;
     DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 35dccc669ca..e71eb86005f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -682,6 +682,52 @@ UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
+{
+    switch (hittest) {
+    case WMSZ_LEFT:        return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
+    case WMSZ_RIGHT:       return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
+    case WMSZ_TOP:         return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
+    case WMSZ_TOPLEFT:     return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
+    case WMSZ_TOPRIGHT:    return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
+    case WMSZ_BOTTOM:      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
+    case WMSZ_BOTTOMLEFT:  return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
+    case WMSZ_BOTTOMRIGHT: return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
+    default:               return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
+    }
+}
+
+/***********************************************************************
+ *          WAYLAND_SysCommand
+ */
+LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
+{
+    LRESULT ret = -1;
+    WPARAM command = wparam & 0xfff0;
+    WPARAM hittest = wparam & 0x0f;
+    struct wayland_surface *wsurface;
+
+    TRACE("cmd=%lx hwnd=%p, %x, %lx,\n", command, hwnd, (unsigned)wparam, lparam);
+
+    if (!(wsurface = wayland_surface_for_hwnd_lock(hwnd)) || !wsurface->xdg_toplevel)
+        goto done;
+
+    if (command == SC_SIZE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_resize(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                                wsurface->wayland->last_button_serial,
+                                hittest_to_resize_edge(hittest));
+        }
+        ret = 0;
+    }
+
+done:
+    wayland_surface_for_hwnd_unlock(wsurface);
+    return ret;
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 7ff506195cc..aa2649e6d3e 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -8,6 +8,7 @@
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
 @ cdecl ShowWindow(long long ptr long) WAYLAND_ShowWindow
+@ cdecl SysCommand(long long long) WAYLAND_SysCommand
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl ToUnicodeEx(long long ptr ptr long long long) WAYLAND_ToUnicodeEx
 @ cdecl VkKeyScanEx(long long) WAYLAND_VkKeyScanEx
-- 
2.33.0


From 3e57fda0f77c9b348c478daa7ecb32d8bb47ea38 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:51:31 +0300
Subject: [PATCH 043/125] winewayland.drv: Handle interactive window movement.

Propagate window movement requests to the compositor. Note that although
the Wayland surface may move on screen, the client (Wine in this case)
is never aware, since such absolute positioning information is not
provided by the Wayland protocol.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e71eb86005f..2ebb57f5d7a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -722,6 +722,15 @@ LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
         }
         ret = 0;
     }
+    else if (command == SC_MOVE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_move(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                              wsurface->wayland->last_button_serial);
+        }
+        ret = 0;
+    }
 
 done:
     wayland_surface_for_hwnd_unlock(wsurface);
-- 
2.33.0


From b45a41143c8187afdff1707acf8b92440cf99c1b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 15:53:46 +0300
Subject: [PATCH 044/125] winewayland.drv: Support window and window_surface
 regions.

Use buffers with an alpha channel (ARGB8888) to implement window
regions. Pixels outside the region are left as transparent in the
buffer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h         |   2 +
 dlls/winewayland.drv/window.c             |  17 +++
 dlls/winewayland.drv/window_surface.c     | 161 ++++++++++++++++++++--
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 4 files changed, 171 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9e658286c00..9a7eef7cc97 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -324,6 +324,8 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region);
 
 /**********************************************************************
  *          Wayland Keyboard
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2ebb57f5d7a..7136a6a7a33 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -682,6 +682,23 @@ UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index f2b93646607..9832d311a6b 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -44,6 +44,8 @@ struct wayland_window_surface
     struct wayland_surface *wayland_surface; /* Not owned by us */
     struct wayland_buffer_queue *wayland_buffer_queue;
     RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_missing_wayland;
@@ -73,6 +75,104 @@ static inline void reset_bounds(RECT *bounds)
     bounds->right = bounds->bottom = INT_MIN;
 }
 
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = CreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR))
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) DeleteObject(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = CreateRectRgn(0, 0, 0, 0);
+        if (region && GetWindowRgn(wws->hwnd, region) == ERROR)
+        {
+            DeleteObject(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = CreateRectRgn(0, 0, 0, 0);
+        if (region) CombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            CombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = CreateRectRgn(0, 0, 0, 0);
+            if (region) CombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) DeleteObject(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
 /***********************************************************************
  *           wayland_window_surface_lock
  */
@@ -119,7 +219,23 @@ static RECT CDECL *wayland_window_surface_get_bounds(struct window_surface *wind
 static void CDECL wayland_window_surface_set_region(struct window_surface *window_surface,
                                                     HRGN region)
 {
-    /* TODO */
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) DeleteObject(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = CreateRectRgn(0, 0, 0, 0);
+        CombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
 }
 
 /***********************************************************************
@@ -142,6 +258,16 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
           wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
 
     needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        surface_damage_region = CreateRectRgnIndirect(&damage_rect);
+        if (wws->total_region)
+        {
+            needs_flush = CombineRgn(surface_damage_region, surface_damage_region,
+                                     wws->total_region, RGN_AND);
+        }
+    }
+
     if (needs_flush &&
         (!wws->wayland_surface || !wws->wayland_buffer_queue ||
          !wayland_surface_is_drawing_allowed(wws->wayland_surface)))
@@ -156,17 +282,15 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     reset_bounds(&wws->bounds);
     if (!needs_flush) goto done;
 
-    surface_damage_region = CreateRectRgnIndirect(&damage_rect);
-
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits);
+          wws->bits, wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
     buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
-    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
@@ -175,7 +299,8 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     for (;rgn_rect < rgn_rect_end; rgn_rect++)
     {
         unsigned int *src, *dst;
-        int y, width, height;
+        int x, y, width, height;
+        BOOL apply_surface_alpha;
 
         TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
 
@@ -191,8 +316,13 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
+        /* If we have an ARGB buffer we need to explicitly apply the surface
+         * alpha (assumed to be 255 currently) to ensure the destination has
+         * sensible alpha values. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+
         /* Fast path for full width rectangles. */
-        if (width == buffer->width)
+        if (width == buffer->width && !apply_surface_alpha)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -200,7 +330,15 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
         for (y = 0; y < height; y++)
         {
-            memcpy(dst, src, width * 4);
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -228,6 +366,8 @@ static void CDECL wayland_window_surface_destroy(struct window_surface *window_s
 
     wws->crit.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&wws->crit);
+    if (wws->region) DeleteObject(wws->region);
+    if (wws->total_region) DeleteObject(wws->total_region);
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     heap_free(wws->bits);
@@ -272,6 +412,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
     if (!(wws->bits = heap_alloc(wws->info.bmiHeader.biSizeImage)))
@@ -314,7 +455,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
         wws->wayland_buffer_queue =
             wayland_buffer_queue_create(wws->wayland_surface->wayland,
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
-                    WL_SHM_FORMAT_XRGB8888);
+                    get_preferred_format(wws));
     }
 
     window_surface->funcs->unlock(window_surface);
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index aa2649e6d3e..792f45ecb3c 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -7,6 +7,7 @@
 @ cdecl MapVirtualKeyEx(long long long) WAYLAND_MapVirtualKeyEx
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
+@ cdecl SetWindowRgn(long long long) WAYLAND_SetWindowRgn
 @ cdecl ShowWindow(long long ptr long) WAYLAND_ShowWindow
 @ cdecl SysCommand(long long long) WAYLAND_SysCommand
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From 71bf154dda8057c82957c91b058db94273585232 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 10:47:53 +0300
Subject: [PATCH 045/125] winewayland.drv: Implement
 SetLayeredWindowAttributes.

Support color-keying and whole window opacity by manipulating the pixel
alpha values of ARGB8888 buffers.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h         |  5 +-
 dlls/winewayland.drv/window.c             | 57 +++++++++++++++++++-
 dlls/winewayland.drv/window_surface.c     | 63 ++++++++++++++++++++---
 dlls/winewayland.drv/winewayland.drv.spec |  2 +
 4 files changed, 117 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9a7eef7cc97..2e47ac6a749 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -319,13 +319,16 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
  *          Wayland window surface
  */
 
-struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect);
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha);
 void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region);
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha);
 
 /**********************************************************************
  *          Wayland Keyboard
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 7136a6a7a33..17fd4903782 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -588,6 +588,9 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
     HWND parent = GetAncestor(hwnd, GA_PARENT);
     RECT surface_rect;
+    DWORD flags;
+    COLORREF color_key;
+    BYTE alpha;
 
     TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
@@ -623,7 +626,16 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     }
 
     /* Create new window surface. */
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect);
+    color_key = alpha = flags = 0;
+    if (!(exstyle & WS_EX_LAYERED) ||
+        !GetLayeredWindowAttributes(hwnd, &color_key, &alpha, &flags))
+    {
+        flags = 0;
+    }
+    if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
 
 done:
     wayland_win_data_release(data);
@@ -699,6 +711,49 @@ void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
     }
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowStyle
+ */
+void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
+{
+    struct wayland_win_data *data;
+    DWORD changed = style->styleNew ^ style->styleOld;
+
+    TRACE("hwnd=%p offset=%d changed=%#x\n", hwnd, offset, changed);
+
+    if (hwnd == GetDesktopWindow()) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED))
+    {
+        TRACE("hwnd=%p changed layered\n", hwnd);
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+    }
+
+    wayland_win_data_release(data);
+}
+
+/***********************************************************************
+ *	     WAYLAND_SetLayeredWindowAttributes
+ */
+void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if (!(flags & LWA_COLORKEY)) key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+        wayland_win_data_release(data);
+    }
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 9832d311a6b..b8c3d760baf 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -46,6 +46,8 @@ struct wayland_window_surface
     RECT                  bounds;
     HRGN                  region; /* region set through window_surface funcs */
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
+    COLORREF              color_key;
+    BYTE                  alpha;
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_missing_wayland;
@@ -85,7 +87,8 @@ static int get_preferred_format(struct wayland_window_surface *wws)
 
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
-    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR))
+    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR) ||
+        wws->color_key != CLR_INVALID || wws->alpha != 255)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -282,9 +285,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     reset_bounds(&wws->bounds);
     if (!needs_flush) goto done;
 
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
+          "alpha %02x compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->total_region);
+          wws->bits, wws->color_key, wws->alpha,
+          wws->info.bmiHeader.biCompression,
+          wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -317,12 +323,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha (assumed to be 255 currently) to ensure the destination has
-         * sensible alpha values. */
+         * alpha to ensure the destination has sensible alpha values. */
         apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
 
         /* Fast path for full width rectangles. */
-        if (width == buffer->width && !apply_surface_alpha)
+        if (width == buffer->width && !apply_surface_alpha &&
+            wws->color_key == CLR_INVALID)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -334,11 +340,24 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else
+            else if (wws->alpha == 255)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((wws->alpha << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+
+            if (wws->color_key != CLR_INVALID)
+                for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -388,7 +407,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
 /***********************************************************************
  *           wayland_window_surface_create
  */
-struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect)
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -412,6 +432,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wws->color_key    = color_key;
+    wws->alpha        = alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -460,3 +482,28 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_layered
+ */
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (alpha != wws->alpha || color_key != wws->color_key)
+        *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+
+    wws->alpha = alpha;
+    wws->color_key = color_key;
+
+    if (wws->wayland_buffer_queue &&
+        wws->wayland_buffer_queue->format != get_preferred_format(wws))
+    {
+        recreate_wayland_buffer_queue(wws);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 792f45ecb3c..e495b182910 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -7,7 +7,9 @@
 @ cdecl MapVirtualKeyEx(long long long) WAYLAND_MapVirtualKeyEx
 @ cdecl MsgWaitForMultipleObjectsEx(long ptr long long long) WAYLAND_MsgWaitForMultipleObjectsEx
 @ cdecl SetCursor(long) WAYLAND_SetCursor
+@ cdecl SetLayeredWindowAttributes(long long long long) WAYLAND_SetLayeredWindowAttributes
 @ cdecl SetWindowRgn(long long long) WAYLAND_SetWindowRgn
+@ cdecl SetWindowStyle(ptr long ptr) WAYLAND_SetWindowStyle
 @ cdecl ShowWindow(long long ptr long) WAYLAND_ShowWindow
 @ cdecl SysCommand(long long long) WAYLAND_SysCommand
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From 77ae38b73dcee0114254bac90f91b5c075dda852 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 14:39:51 +0300
Subject: [PATCH 046/125] winewayland.drv: Implement UpdateLayeredWindow.

Support per-pixel alpha values and background blending.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h         |  6 +-
 dlls/winewayland.drv/window.c             | 98 ++++++++++++++++++++++-
 dlls/winewayland.drv/window_surface.c     | 39 ++++++---
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 4 files changed, 129 insertions(+), 15 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 2e47ac6a749..155fff35b7b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -320,7 +320,8 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
  */
 
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha);
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha);
 void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
@@ -328,7 +329,8 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region);
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha);
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha);
 
 /**********************************************************************
  *          Wayland Keyboard
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 17fd4903782..3c0eee27c16 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -635,7 +635,7 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
     if (!(flags & LWA_ALPHA)) alpha = 255;
 
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
 
 done:
     wayland_win_data_release(data);
@@ -728,7 +728,7 @@ void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     {
         TRACE("hwnd=%p changed layered\n", hwnd);
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
     }
 
     wayland_win_data_release(data);
@@ -749,11 +749,103 @@ void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alph
     if ((data = wayland_win_data_get(hwnd)))
     {
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
         wayland_win_data_release(data);
     }
 }
 
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL CDECL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                       const RECT *window_rect)
+{
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, info->crKey, wine_dbgstr_rect(info->prcDirty), info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = CreateDIBSection(info->hdcDst, bmi, DIB_RGB_COLORS, &src_bits, NULL, 0))) goto done;
+    if (!(hdc = CreateCompatibleDC(0))) goto done;
+
+    SelectObject(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        IntersectRect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    DPtoLP(info->hdcSrc, (POINT *)&src_rect, 2);
+
+    ret = GdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                        info->hdcSrc, src_rect.left, src_rect.top,
+                        src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                        (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        UnionRect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) DeleteDC(hdc);
+    if (dib) DeleteObject(dib);
+    return ret;
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index b8c3d760baf..34c83c057c5 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -48,6 +48,7 @@ struct wayland_window_surface
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
     COLORREF              color_key;
     BYTE                  alpha;
+    BOOL                  src_alpha;
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_missing_wayland;
@@ -88,7 +89,7 @@ static int get_preferred_format(struct wayland_window_surface *wws)
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
     if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR) ||
-        wws->color_key != CLR_INVALID || wws->alpha != 255)
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -286,9 +287,9 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     if (!needs_flush) goto done;
 
     TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
-          "alpha %02x compression %d region %p\n",
+          "alpha %02x src_alpha %d compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->color_key, wws->alpha,
+          wws->bits, wws->color_key, wws->alpha, wws->src_alpha,
           wws->info.bmiHeader.biCompression,
           wws->total_region);
 
@@ -323,8 +324,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha to ensure the destination has sensible alpha values. */
-        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+         * alpha to ensure the destination has sensible alpha values. The
+         * exception is when the surface uses source alpha values and the
+         * surface alpha is 255, in which case we can just copy pixel values
+         * as they are. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                              (wws->alpha != 255 || !wws->src_alpha);
 
         /* Fast path for full width rectangles. */
         if (width == buffer->width && !apply_surface_alpha &&
@@ -340,12 +345,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else if (wws->alpha == 255)
+            else if (wws->alpha == 255 && !wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
-            else
+            else if (!wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                 {
@@ -355,6 +360,16 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
                               (((BYTE)src[x] * wws->alpha / 255)));
                 }
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
 
             if (wws->color_key != CLR_INVALID)
                 for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
@@ -408,7 +423,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
  *           wayland_window_surface_create
  */
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha)
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -434,6 +450,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->hwnd         = hwnd;
     wws->color_key    = color_key;
     wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -487,17 +504,19 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
  *           wayland_window_surface_update_layered
  */
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha)
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
 
     window_surface->funcs->lock(window_surface);
 
-    if (alpha != wws->alpha || color_key != wws->color_key)
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
         *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
 
     wws->alpha = alpha;
     wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
 
     if (wws->wayland_buffer_queue &&
         wws->wayland_buffer_queue->format != get_preferred_format(wws))
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index e495b182910..e43bd66c67c 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -14,6 +14,7 @@
 @ cdecl SysCommand(long long long) WAYLAND_SysCommand
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
 @ cdecl ToUnicodeEx(long long ptr ptr long long long) WAYLAND_ToUnicodeEx
+@ cdecl UpdateLayeredWindow(long ptr ptr) WAYLAND_UpdateLayeredWindow
 @ cdecl VkKeyScanEx(long long) WAYLAND_VkKeyScanEx
 @ cdecl WindowMessage(long long long long) WAYLAND_WindowMessage
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) WAYLAND_WindowPosChanging
-- 
2.33.0


From d2b2dddb4ffe26823a0df6728d56ad5a037222eb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 14:25:25 +0300
Subject: [PATCH 047/125] winewayland.drv: Fix thread safety issue with
 UpdateLayeredWindow.

In some cases, notably when the app calls UpdateLayeredWindow, position
and size changes may be emitted from a thread other than the window
thread. Since in the current implementation updating the Wayland state
needs to happen in the context of the window thread to avoid racy
interactions, post a message to update the state in the right thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 28 +++++++++++++++++++++++++++-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 155fff35b7b..7b60838a955 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -44,6 +44,7 @@ extern struct wl_display *process_wl_display;
 enum wayland_window_message
 {
     WM_WAYLAND_CONFIGURE = 0x80001000,
+    WM_WAYLAND_STATE_UPDATE = 0x80001001,
 };
 
 enum wayland_configure_flags
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 3c0eee27c16..1903e9fb13a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -73,6 +73,8 @@ struct wayland_win_data
     RECT           old_window_rect;
     /* Whether a first wayland surface update is needed */
     BOOL           wayland_surface_needs_first_update;
+    /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
+    BOOL           pending_state_update_message;
 };
 
 static CRITICAL_SECTION win_data_section;
@@ -663,7 +665,20 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
     if (data->window_surface) window_surface_release(data->window_surface);
     data->window_surface = surface;
 
-    update_wayland_state(data);
+    /* In some cases, notably when the app calls UpdateLayeredWindow, position
+     * and size changes may be emitted from a thread other than the window
+     * thread. Since in the current implementation updating the wayland state
+     * needs to happen in the context of the window thread to avoid racy
+     * interactions, post a message to update the state in the right thread. */
+    if (GetCurrentThreadId() == GetWindowThreadProcessId(hwnd, NULL))
+    {
+        update_wayland_state(data);
+    }
+    else if (!data->pending_state_update_message)
+    {
+        PostMessageW(hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+        data->pending_state_update_message = TRUE;
+    }
 
     wayland_win_data_release(data);
 }
@@ -1124,6 +1139,17 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_STATE_UPDATE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data)
+            {
+                data->pending_state_update_message = FALSE;
+                update_wayland_state(data);
+                wayland_win_data_release(data);
+            }
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.33.0


From 37fd8c823bf101b79616bbb3ec440798e29bf2f0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 15:38:48 +0300
Subject: [PATCH 048/125] winewayland.drv: Store a list of children surfaces

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |  5 ++++
 dlls/winewayland.drv/wayland_surface.c | 35 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 3 files changed, 43 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index b44a494b161..63971485073 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -224,6 +224,7 @@ BOOL wayland_init(struct wayland *wayland)
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
     wl_list_init(&wayland->output_list);
+    wl_list_init(&wayland->toplevel_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -263,6 +264,7 @@ BOOL wayland_init(struct wayland *wayland)
 void wayland_deinit(struct wayland *wayland)
 {
     struct wayland_output *output, *output_tmp;
+    struct wayland_surface *toplevel, *toplevel_tmp;
 
     TRACE("%p\n", wayland);
 
@@ -270,6 +272,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     LeaveCriticalSection(&thread_wayland_section);
 
+    wl_list_for_each_safe(toplevel, toplevel_tmp, &wayland->toplevel_list, link)
+        wayland_surface_destroy(toplevel);
+
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
     if (wayland->event_notification_pipe[1] >= 0)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9833373b25c..faf7e13e519 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -152,6 +152,8 @@ static struct wayland_surface *wayland_surface_create_common(struct wayland *way
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->link);
+    wl_list_init(&surface->child_list);
     wl_surface_set_user_data(surface->wl_surface, surface);
     surface->drawing_allowed = TRUE;
 
@@ -180,6 +182,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface)
         goto err;
 
+    wl_list_insert(&wayland->toplevel_list, &surface->link);
+
     wl_surface_commit(surface->wl_surface);
 
     return surface;
@@ -221,6 +225,8 @@ struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
 
+    wl_list_insert(&wayland->toplevel_list, &surface->link);
+
     wl_surface_commit(surface->wl_surface);
 
     /* Wait for the first configure event. */
@@ -252,6 +258,11 @@ struct wayland_surface *wayland_surface_create_subsurface(struct wayland *waylan
         goto err;
 
     surface->parent = wayland_surface_ref(parent);
+
+    EnterCriticalSection(&parent->crit);
+    wl_list_insert(&parent->child_list, &surface->link);
+    LeaveCriticalSection(&parent->crit);
+
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
                                         surface->wl_surface,
@@ -439,8 +450,24 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
+    struct wayland_surface *child, *child_tmp;
+
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    EnterCriticalSection(&surface->crit);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, link)
+    {
+        /* Since the current surface (the parent) is being destroyed,
+         * disassociate from the child to avoid the child trying to
+         * destroy the parent. */
+        child->parent = NULL;
+        wayland_surface_destroy(child);
+    }
+    LeaveCriticalSection(&surface->crit);
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -467,9 +494,17 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     if (surface->parent)
     {
+        EnterCriticalSection(&surface->parent->crit);
+        wl_list_remove(&surface->link);
+        LeaveCriticalSection(&surface->parent->crit);
+
         wayland_surface_unref(surface->parent);
         surface->parent = NULL;
     }
+    else
+    {
+        wl_list_remove(&surface->link);
+    }
 
     surface->crit.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&surface->crit);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7b60838a955..d2f668d2949 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -112,6 +112,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wl_list toplevel_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
@@ -159,6 +160,7 @@ struct wayland_surface_configure
 
 struct wayland_surface
 {
+    struct wl_list link;
     struct wayland *wayland;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
@@ -172,6 +174,7 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     BOOL drawing_allowed;
+    struct wl_list child_list;
 };
 
 struct wayland_buffer_queue
-- 
2.33.0


From ceee40e0d8bdf0efd01e1dd366720dc953d6363f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 18:40:24 +0300
Subject: [PATCH 049/125] winewayland.drv: Handle surface output positioning

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |   8 ++
 dlls/winewayland.drv/wayland_surface.c | 150 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  13 +++
 dlls/winewayland.drv/window.c          |  87 ++++++++++++--
 4 files changed, 251 insertions(+), 7 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 63971485073..4718d9a16d5 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -166,7 +166,15 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         if (output->global_id == id)
         {
+            struct wayland_surface *surface;
+
             TRACE("removing output->name=%s\n", output->name);
+
+            /* Remove the output from toplevels, as some compositor don't send
+             * a leave event if the output is disconnected. */
+            wl_list_for_each(surface, &wayland->toplevel_list, link)
+                wayland_surface_leave_output(surface, output);
+
             wayland_output_destroy(output);
             wayland_init_display_devices(wayland);
             return;
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index faf7e13e519..51a00dad0c4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -135,6 +135,65 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener = {
     handle_xdg_toplevel_close,
 };
 
+static struct wayland_output *
+wayland_surface_get_exclusive_output(struct wayland_surface *surface)
+{
+    struct wayland_output *exclusive = NULL;
+    struct wayland_output_ref *ref;
+
+    wl_list_for_each(ref, &surface->output_ref_list, link)
+    {
+        if (exclusive) { exclusive = NULL; break; }
+        exclusive = ref->output;
+    }
+
+    return exclusive;
+}
+
+static void handle_wl_surface_enter(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+    struct wayland_output_ref *ref;
+    struct wayland_output *exclusive;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    ref = heap_alloc_zero(sizeof(*ref));
+    if (!ref) { ERR("memory allocation failed"); return; }
+    ref->output = output;
+    wl_list_insert(&surface->output_ref_list, &ref->link);
+
+    exclusive = wayland_surface_get_exclusive_output(surface);
+    if (exclusive)
+        wayland_surface_set_main_output(surface, exclusive, FALSE);
+}
+
+static void handle_wl_surface_leave(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    wayland_surface_leave_output(surface, output);
+}
+
+static const struct wl_surface_listener wl_surface_listener = {
+    handle_wl_surface_enter,
+    handle_wl_surface_leave,
+};
+
 static struct wayland_surface *wayland_surface_create_common(struct wayland *wayland)
 {
     struct wayland_surface *surface;
@@ -152,6 +211,7 @@ static struct wayland_surface *wayland_surface_create_common(struct wayland *way
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->child_list);
     wl_surface_set_user_data(surface->wl_surface, surface);
@@ -211,6 +271,9 @@ struct wayland_surface *wayland_surface_create_toplevel(struct wayland *wayland,
     if (!surface)
         goto err;
 
+    /* We want enter/leave events only for toplevels */
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, surface);
+
     surface->xdg_surface =
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
@@ -271,6 +334,8 @@ struct wayland_surface *wayland_surface_create_subsurface(struct wayland *waylan
         goto err;
     wl_subsurface_set_desync(surface->wl_subsurface);
 
+    surface->main_output = parent->main_output;
+
     wl_surface_commit(surface->wl_surface);
 
     return surface;
@@ -451,6 +516,7 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_surface *child, *child_tmp;
+    struct wayland_output_ref *ref, *ref_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -468,6 +534,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     }
     LeaveCriticalSection(&surface->crit);
 
+    wl_list_for_each_safe(ref, ref_tmp, &surface->output_ref_list, link)
+    {
+        wl_list_remove(&ref->link);
+        heap_free(ref);
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -633,6 +705,84 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
+static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->main_output = output;
+
+    EnterCriticalSection(&surface->crit);
+
+    wl_list_for_each(child, &surface->child_list, link)
+        wayland_surface_tree_set_main_output(child, output);
+
+    LeaveCriticalSection(&surface->crit);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_main_output
+ *
+ * Sets the main output for a surface, i.e., the output whose scale will be
+ * used for surface scaling.
+ */
+void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                     struct wayland_output *output,
+                                     BOOL post)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->main_output != output)
+    {
+        wayland_surface_tree_set_main_output(surface, output);
+        if (surface->hwnd)
+        {
+            if (post)
+                PostMessageW(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
+            else
+                SendMessageW(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
+        }
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_leave_output
+ *
+ * Removes an output from the set of outputs a surface is presented on.
+ *
+ * It is OK to call this function even if the surface is not presented
+ * on the specified output, in which case this function is a NOP.
+ */
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output)
+{
+    struct wayland_output_ref *ref, *tmp;
+
+    wl_list_for_each_safe(ref, tmp, &surface->output_ref_list, link)
+    {
+        if (ref->output == output)
+        {
+            wl_list_remove(&ref->link);
+            heap_free(ref);
+            break;
+        }
+    }
+
+    if (surface->main_output == output)
+    {
+        struct wayland_output *exclusive =
+            wayland_surface_get_exclusive_output(surface);
+
+        wayland_surface_set_main_output(surface, exclusive, FALSE);
+    }
+}
+
 /**********************************************************************
  *          wayland_surface_set_drawing_allowed
  */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index d2f668d2949..5c61672abbe 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -45,6 +45,7 @@ enum wayland_window_message
 {
     WM_WAYLAND_CONFIGURE = 0x80001000,
     WM_WAYLAND_STATE_UPDATE = 0x80001001,
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001002
 };
 
 enum wayland_configure_flags
@@ -158,6 +159,12 @@ struct wayland_surface_configure
     BOOL processed;
 };
 
+struct wayland_output_ref
+{
+    struct wl_list link;
+    struct wayland_output *output;
+};
+
 struct wayland_surface
 {
     struct wl_list link;
@@ -173,6 +180,8 @@ struct wayland_surface
     struct wayland_surface_configure current;
     BOOL mapped;
     LONG ref;
+    struct wl_list output_ref_list;
+    struct wayland_output *main_output;
     BOOL drawing_allowed;
     struct wl_list child_list;
 };
@@ -303,6 +312,10 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     int *wine_x, int *wine_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
+void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                     struct wayland_output *output, BOOL post);
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output);
 void wayland_surface_set_drawing_allowed(struct wayland_surface *surface, BOOL allowed);
 BOOL wayland_surface_is_drawing_allowed(struct wayland_surface *surface);
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 1903e9fb13a..cd99bfa42e1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1037,13 +1037,22 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
      * to the user from a wayland compositor pespective. To mitigate this, we
      * place all top-level windows at 0,0, to maximize the area that can reside
      * within the win32 display. */
-    origin_x = 0;
-    origin_y = 0;
-    needs_move_to_origin = data->window_rect.top != origin_x ||
-                           data->window_rect.left != origin_y;
-    TRACE("current=%d,%d origin=%d,%d\n",
-          data->window_rect.left, data->window_rect.top,
-          origin_x, origin_y);
+    if (data->wayland_surface->main_output)
+    {
+        origin_x = data->wayland_surface->main_output->x;
+        origin_y = data->wayland_surface->main_output->y;
+        needs_move_to_origin = data->window_rect.top != origin_x ||
+                               data->window_rect.left != origin_y;
+        TRACE("current=%d,%d origin=%d,%d\n",
+              data->window_rect.left, data->window_rect.top,
+              origin_x, origin_y);
+    }
+    else
+    {
+        origin_x = 0;
+        origin_y = 0;
+        needs_move_to_origin = FALSE;
+    }
 
     wayland_win_data_release(data);
 
@@ -1100,6 +1109,67 @@ static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWOR
     handle_wm_wayland_configure(hwnd);
 }
 
+static void handle_wm_wayland_surface_output_change(HWND hwnd)
+{
+    struct wayland_surface *wsurface;
+    int x, y, w, h;
+    UINT swp_flags;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wsurface = wayland_surface_for_hwnd_lock(hwnd);
+    if (!wsurface || !wsurface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        goto out;
+    }
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER |
+                SWP_FRAMECHANGED | SWP_NOSENDCHANGING;
+
+    if (wsurface->main_output)
+    {
+        x = wsurface->main_output->x;
+        y = wsurface->main_output->y;
+        TRACE("moving window to %d,%d\n", x, y);
+    }
+    else
+    {
+        x = y = 0;
+        swp_flags |= SWP_NOMOVE;
+    }
+
+    /* If we are fullscreen or maximized we need to provide a particular buffer
+     * size to the wayland compositor on the new output (hence swp_flags
+     * includes SWP_NOSENDCHANGING). */
+    if (wsurface->current.serial &&
+        (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
+                                       wsurface->current.height,
+                                       &w, &h);
+        TRACE("resizing window to maximized %dx%d\n", w, h);
+    }
+    else if (wsurface->current.serial &&
+             (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
+                                       wsurface->current.height,
+                                       &w, &h);
+        TRACE("resizing window to fullscreen %dx%d\n", w, h);
+    }
+    else
+    {
+        w = h = 0;
+        swp_flags |= SWP_NOSIZE;
+    }
+
+    SetWindowPos(hwnd, 0, x, y, w, h, swp_flags);
+
+out:
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
@@ -1150,6 +1220,9 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             }
         }
         break;
+    case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
+        handle_wm_wayland_surface_output_change(hwnd);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.33.0


From 8fa0c84cbd66678aa0fa3f53b1c90c1043aef1de Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Sat, 11 Sep 2021 01:51:44 +0300
Subject: [PATCH 050/125] winewayland.drv: Apply output buffer scale

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_cursor.c  |  5 +++
 dlls/winewayland.drv/wayland_surface.c | 43 +++++++++++++++++++++-----
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 3 files changed, 41 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index c0c301de27e..ff5bdb1b3bd 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -261,6 +261,11 @@ static void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *poi
                              0, 0,
                              wayland_cursor->shm_buffer->width,
                              wayland_cursor->shm_buffer->height);
+    if (pointer->focused_surface)
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface,
+                                    wayland_surface_get_buffer_scale(pointer->focused_surface));
+    else
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface, 1);
 
     wl_surface_commit(pointer->cursor_wl_surface);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 51a00dad0c4..701f1d157f6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -335,6 +335,7 @@ struct wayland_surface *wayland_surface_create_subsurface(struct wayland *waylan
     wl_subsurface_set_desync(surface->wl_subsurface);
 
     surface->main_output = parent->main_output;
+    wl_surface_set_buffer_scale(surface->wl_surface, wayland_surface_get_buffer_scale(parent));
 
     wl_surface_commit(surface->wl_surface);
 
@@ -645,8 +646,10 @@ void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y)
 {
-    *wayland_x = wine_x;
-    *wayland_y = wine_y;
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    *wayland_x = wine_x / scale;
+    *wayland_y = wine_y / scale;
 }
 
 /**********************************************************************
@@ -674,8 +677,10 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y)
 {
-    *wine_x = wayland_x;
-    *wine_y = wayland_y;
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    *wine_x = wayland_x * scale;
+    *wine_y = wayland_y * scale;
 }
 
 /**********************************************************************
@@ -705,17 +710,19 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
-static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
-                                                 struct wayland_output *output)
+static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
+                                                           struct wayland_output *output,
+                                                           int scale)
 {
     struct wayland_surface *child;
 
     surface->main_output = output;
+    wl_surface_set_buffer_scale(surface->wl_surface, scale);
 
     EnterCriticalSection(&surface->crit);
 
     wl_list_for_each(child, &surface->child_list, link)
-        wayland_surface_tree_set_main_output(child, output);
+        wayland_surface_tree_set_main_output_and_scale(child, output, scale);
 
     LeaveCriticalSection(&surface->crit);
 }
@@ -740,7 +747,8 @@ void wayland_surface_set_main_output(struct wayland_surface *surface,
 
     if (surface->main_output != output)
     {
-        wayland_surface_tree_set_main_output(surface, output);
+        wayland_surface_tree_set_main_output_and_scale(surface, output,
+                                                       output ? output->scale : 1);
         if (surface->hwnd)
         {
             if (post)
@@ -783,6 +791,25 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
     }
 }
 
+/**********************************************************************
+ *          wayland_surface_get_buffer_scale
+ *
+ */
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
+{
+    /* Use the toplevel surface to get the scale */
+    struct wayland_surface *toplevel = surface;
+    int scale = 1;
+
+    while (toplevel->parent) toplevel = toplevel->parent;
+
+    if (toplevel->main_output)
+        scale = toplevel->main_output->scale;
+
+    TRACE("hwnd=%p (toplevel=%p) => scale=%d\n", surface->hwnd, toplevel->hwnd, scale);
+    return scale;
+}
+
 /**********************************************************************
  *          wayland_surface_set_drawing_allowed
  */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5c61672abbe..e9088a2f177 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -316,6 +316,7 @@ void wayland_surface_set_main_output(struct wayland_surface *surface,
                                      struct wayland_output *output, BOOL post);
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output);
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface);
 void wayland_surface_set_drawing_allowed(struct wayland_surface *surface, BOOL allowed);
 BOOL wayland_surface_is_drawing_allowed(struct wayland_surface *surface);
 
-- 
2.33.0


From ec08f94c13b43c996071dd69de5c746476472210 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:14:48 +0300
Subject: [PATCH 051/125] winewayland.drv: Introduce support for setting a
 display mode different than the native

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c        | 32 ++++++++++++++++++++-------
 dlls/winewayland.drv/wayland_output.c |  6 +++++
 dlls/winewayland.drv/waylanddrv.h     |  1 +
 3 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 0232cfeceb1..8326ede7222 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -326,8 +326,8 @@ static BOOL wayland_init_monitor(HDEVINFO devinfo, struct wayland_output *output
     RECT rc_mode;
 
     SetRect(&rc_mode, output->x, output->y,
-            output->x + output->current_mode->width,
-            output->y + output->current_mode->height);
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
 
     if (!MultiByteToWideChar(CP_UTF8, 0, output->name, -1, output_name, ARRAY_SIZE(output_name)))
         output_name[0] = 0;
@@ -478,7 +478,7 @@ static void wayland_init_display_devices_internal(struct wayland *wayland, BOOL
 
     wl_list_for_each(output, &wayland->output_list, link)
     {
-        if (!output->current_mode) continue;
+        if (!output->current_wine_mode) continue;
 
         /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
         if (!wayland_init_adapter(video_hkey, output_index, gpu_index, output_index, 1,
@@ -522,11 +522,11 @@ done:
         /* The first valid output is the primary. */
         wl_list_for_each(output, &wayland->output_list, link)
         {
-            if (!output->current_mode) continue;
+            if (!output->current_wine_mode) continue;
 
             SendMessageTimeoutW(HWND_BROADCAST, WM_DISPLAYCHANGE, 32,
-                                MAKELPARAM(output->current_mode->width,
-                                           output->current_mode->height),
+                                MAKELPARAM(output->current_wine_mode->width,
+                                           output->current_wine_mode->height),
                                 SMTO_ABORTIFHUNG, 2000, NULL);
             break;
         }
@@ -643,7 +643,7 @@ static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *
     mode->dmDisplayFrequency = output_mode->refresh / 1000;
 }
 
-static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+static BOOL wayland_get_native_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
 {
     struct wayland_output *output;
 
@@ -659,6 +659,22 @@ static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, D
     return TRUE;
 }
 
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_wine_mode)
+        return FALSE;
+
+    populate_devmode(output->current_wine_mode, mode);
+
+    return TRUE;
+}
+
 static BOOL wayland_get_devmode(struct wayland *wayland, LPCWSTR name, DWORD n, DEVMODEW *mode)
 {
     struct wayland_output *output;
@@ -698,7 +714,7 @@ BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmo
     if (n == ENUM_REGISTRY_SETTINGS)
     {
         if (!read_registry_settings(name, devmode) &&
-            !wayland_get_current_devmode(wayland, name, devmode))
+            !wayland_get_native_devmode(wayland, name, devmode))
         {
             ERR("Failed to get %s registry display settings and native mode.\n",
                 wine_dbgstr_w(name));
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 087f7f9a5f6..aa739bac207 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -86,7 +86,10 @@ static void wayland_output_add_mode(struct wayland_output *output,
             /* Upgrade modes from virtual to native, never the reverse. */
             if (native) mode->native = TRUE;
             if (current)
+            {
                 output->current_mode = mode;
+                output->current_wine_mode = mode;
+            }
             return;
         }
     }
@@ -100,7 +103,10 @@ static void wayland_output_add_mode(struct wayland_output *output,
     mode->native = native;
 
     if (current)
+    {
         output->current_mode = mode;
+        output->current_wine_mode = mode;
+    }
 
     wl_list_insert(&output->mode_list, &mode->link);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e9088a2f177..f283fb245ef 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -141,6 +141,7 @@ struct wayland_output
     struct zxdg_output_v1 *zxdg_output_v1;
     struct wl_list mode_list;
     struct wayland_output_mode *current_mode;
+    struct wayland_output_mode *current_wine_mode;
     int logical_x, logical_y;  /* logical position */
     int logical_w, logical_h;  /* logical size */
     int x, y;  /* position in native pixel coordinate space */
-- 
2.33.0


From b35d9a1bc0960ad245d8501e49010587af93ffbb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:17:32 +0300
Subject: [PATCH 052/125] winewayland.drv: Coordinate transformations for
 non-native display modes

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_output.c  |  1 +
 dlls/winewayland.drv/wayland_surface.c | 82 ++++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |  7 +++
 dlls/winewayland.drv/window.c          | 19 ++++--
 4 files changed, 100 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index aa739bac207..f61e14390bb 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -398,6 +398,7 @@ BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t versio
     wl_list_init(&output->link);
 
     output->scale = 1;
+    output->wine_scale = 1.0;
 
     /* Have a fallback in case xdg_output is not supported or name is not sent. */
     output->name = malloc(20);
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 701f1d157f6..8e003d1d5bd 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -646,10 +646,23 @@ void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y)
 {
+    struct wayland_output *output = surface->main_output;
     int scale = wayland_surface_get_buffer_scale(surface);
 
-    *wayland_x = wine_x / scale;
-    *wayland_y = wine_y / scale;
+    if (output)
+    {
+        *wayland_x = wine_x * output->wine_scale / scale;
+        *wayland_y = wine_y * output->wine_scale / scale;
+    }
+    else
+    {
+        *wayland_x = wine_x / scale;
+        *wayland_y = wine_y / scale;
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wine=%d,%d => wayland=%.2f,%.2f\n",
+          surface->hwnd, output ? output->wine_scale : -1.0, wine_x, wine_y,
+          *wayland_x, *wayland_y);
 }
 
 /**********************************************************************
@@ -677,10 +690,71 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y)
 {
+    struct wayland_output *output = surface->main_output;
     int scale = wayland_surface_get_buffer_scale(surface);
 
-    *wine_x = wayland_x * scale;
-    *wine_y = wayland_y * scale;
+    if (output)
+    {
+        *wine_x = round(wayland_x * scale / output->wine_scale);
+        *wine_y = round(wayland_y * scale / output->wine_scale);
+    }
+    else
+    {
+        *wine_x = wayland_x * scale;
+        *wine_y = wayland_y * scale;
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wayland=%.2f,%.2f => wine=%d,%d\n",
+          surface->hwnd, output ? output->wine_scale : -1.0,
+          wayland_x, wayland_y, *wine_x, *wine_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_find_wine_fullscreen_fit
+ *
+ * Finds the size of a fullscreen Wine window that when scaled best fits into a
+ * wayland surface with the provided size, while maintaining the aspect
+ * ratio of the current Wine display mode.
+ */
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height)
+{
+    struct wayland_output *output = surface->main_output;
+    double subarea_width, subarea_height;
+
+    TRACE("hwnd=%p wayland_width=%d wayland_height=%d\n",
+          surface->hwnd, wayland_width, wayland_height);
+
+    /* If the wine mode doesn't match the wayland mode, Find the largest subarea
+     * within wayland_width x wayland_height that has an aspect ratio equal to
+     * the wine display mode aspect ratio. */
+    if (output)
+    {
+        double aspect = ((double)wayland_width) / wayland_height;
+        double wine_aspect = ((double)output->current_wine_mode->width) /
+                             output->current_wine_mode->height;
+        if (aspect > wine_aspect)
+        {
+            subarea_width = wayland_height * wine_aspect;
+            subarea_height = wayland_height;
+        }
+        else
+        {
+            subarea_width = wayland_width;
+            subarea_height = wayland_width / wine_aspect;
+        }
+    }
+    else
+    {
+        subarea_width = wayland_width;
+        subarea_height = wayland_height;
+    }
+
+    /* Transform the calculated subarea to wine coordinates. */
+    wayland_surface_coords_to_wine(surface,
+                                   subarea_width, subarea_height,
+                                   wine_width, wine_height);
 }
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f283fb245ef..083516ecbbc 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -146,6 +146,10 @@ struct wayland_output
     int logical_w, logical_h;  /* logical size */
     int x, y;  /* position in native pixel coordinate space */
     int scale; /* wayland output scale factor for hidpi */
+    /* Scale factor by which we need to multiply values in the wine coordinate
+     * space to get values in the wayland coordinate space for this output. Used
+     * when emulating a display mode change. */
+    double wine_scale;
     char *name;
     WCHAR wine_name[128];
     uint32_t global_id;
@@ -311,6 +315,9 @@ void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
 void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y);
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 void wayland_surface_set_main_output(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cd99bfa42e1..04327d2ad99 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1014,8 +1014,17 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
         wsurface->pending.height = height;
     }
 
-    wayland_surface_coords_to_wine(wsurface, width, height,
-                                   &wine_width, &wine_height);
+    if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_find_wine_fullscreen_fit(wsurface, width, height,
+                                                 &wine_width, &wine_height);
+    }
+    else
+    {
+        wayland_surface_coords_to_wine(wsurface, width, height,
+                                       &wine_width, &wine_height);
+    }
 
     TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
           data->hwnd, width, height, wine_width, wine_height);
@@ -1153,9 +1162,9 @@ static void handle_wm_wayland_surface_output_change(HWND hwnd)
     else if (wsurface->current.serial &&
              (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
-                                       wsurface->current.height,
-                                       &w, &h);
+        wayland_surface_find_wine_fullscreen_fit(wsurface, wsurface->current.width,
+                                                 wsurface->current.height,
+                                                 &w, &h);
         TRACE("resizing window to fullscreen %dx%d\n", w, h);
     }
     else
-- 
2.33.0


From b8af0717f54865eb97103f9f87566df9683abc3f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:18:46 +0300
Subject: [PATCH 053/125] winewayland.drv: Use the viewporter protocol to scale
 surfaces for non-native display modes

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/wayland.c         |  7 +++++++
 dlls/winewayland.drv/wayland_surface.c | 22 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 4 files changed, 33 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index df29e600695..6aa1d630d83 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -26,6 +26,7 @@ C_SRCS = \
 	xkb_util.c \
 
 WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 4718d9a16d5..0a64aa063da 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -135,6 +135,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
                                             version < 5 ? version : 5);
         wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
     }
+    else if (strcmp(interface, "wp_viewporter") == 0)
+    {
+        wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
+    }
     else if (strcmp(interface, "wl_output") == 0)
     {
         if (!wayland_output_create(wayland, id, version))
@@ -300,6 +304,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
+    if (wayland->wp_viewporter)
+        wp_viewporter_destroy(wayland->wp_viewporter);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 8e003d1d5bd..83899a5264d 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -211,6 +211,13 @@ static struct wayland_surface *wayland_surface_create_common(struct wayland *way
     if (!surface->wl_surface)
         goto err;
 
+    if (surface->wayland->wp_viewporter)
+    {
+        surface->wp_viewport =
+            wp_viewporter_get_viewport(surface->wayland->wp_viewporter,
+                                       surface->wl_surface);
+    }
+
     wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->child_list);
@@ -377,6 +384,15 @@ void wayland_surface_reconfigure(struct wayland_surface *surface,
     if (surface->wl_subsurface)
         wl_subsurface_set_position(surface->wl_subsurface, x, y);
 
+    /* Use a viewport, if supported, to handle display mode changes. */
+    if (surface->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(surface->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(surface->wp_viewport, -1, -1);
+    }
+
     if (surface->xdg_surface && width != 0 && height != 0)
         xdg_surface_set_window_geometry(surface->xdg_surface, 0, 0, width, height);
 }
@@ -541,6 +557,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         heap_free(ref);
     }
 
+    if (surface->wp_viewport)
+    {
+        wp_viewport_destroy(surface->wp_viewport);
+        surface->wp_viewport = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 083516ecbbc..219a0d3cf97 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -29,6 +29,7 @@
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -110,6 +111,7 @@ struct wayland
     struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
+    struct wp_viewporter *wp_viewporter;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -178,6 +180,7 @@ struct wayland_surface
     struct wl_subsurface *wl_subsurface;
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
+    struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
     HWND hwnd;
     CRITICAL_SECTION crit;
-- 
2.33.0


From c681a162977b22901df7a5b6be5ba4f55fd8c9a5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 13:27:04 +0300
Subject: [PATCH 054/125] winewayland.drv: Compute unique 32-bit output ids

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         |  3 +-
 dlls/winewayland.drv/wayland.c         |  3 ++
 dlls/winewayland.drv/wayland_output.c  | 64 ++++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c | 14 +++---
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 5 files changed, 79 insertions(+), 7 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 8326ede7222..fa9436728b8 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -498,7 +498,8 @@ static void wayland_init_display_devices_internal(struct wayland *wayland, BOOL
     {
         snprintfW(output->wine_name, ARRAY_SIZE(output->wine_name),
                   adapter_name_fmtW, output_index + 1);
-        TRACE("name=%s wine_name=%s\n", output->name, wine_dbgstr_w(output->wine_name));
+        TRACE("output->name=%s (id=0x%x) wine_name=%s\n",
+              output->name, output->id, wine_dbgstr_w(output->wine_name));
         output_index++;
     }
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 0a64aa063da..6b48c9e6985 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -235,6 +235,9 @@ BOOL wayland_init(struct wayland *wayland)
     }
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
+    /* Start with the default FNV-1a offset for 32-bits. */
+    wayland->output_id_fnv_offset = 0x811c9dc5;
+
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->toplevel_list);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index f61e14390bb..0cdf2ee1e37 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -121,6 +121,65 @@ static void wayland_output_add_mode_all_bpp(struct wayland_output *output,
     wayland_output_add_mode(output, width, height, refresh, 8, FALSE, FALSE);
 }
 
+/* The output id is computed using the FNV-1a hash of the name. We start
+ * with the default FNV offset basis, but we update it (and recompute
+ * all ids) if we find a collision. From the author's page at
+ * http://www.isthe.com/chongo/tech/comp/fnv/index.html:
+ *
+ *   "In the general case, almost any offset_basis will serve so long as
+ *    it is non-zero"
+ */
+static void wayland_output_recompute_id(struct wayland_output *output)
+{
+    static const uint32_t fnv_prime = 0x01000193;
+    uint32_t hash = output->wayland->output_id_fnv_offset;
+    const char *p;
+
+    if (output->name)
+    {
+        for(p = output->name; *p; p++)
+        {
+            hash ^= *p;
+            hash *= fnv_prime;
+        }
+    }
+
+    output->id = hash;
+}
+
+static BOOL wayland_output_ids_conflict(struct wayland *wayland)
+{
+    struct wayland_output *o;
+    struct wayland_output *n;
+
+    wl_list_for_each(o, &wayland->output_list, link)
+    {
+        for (n = wl_container_of(o->link.next, n, link);
+             &n->link != &wayland->output_list;
+             n = wl_container_of(n->link.next, n, link))
+        {
+            if (o->id == n->id) return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+static void wayland_recompute_output_ids_until_no_conflict(struct wayland *wayland)
+{
+    while (wayland_output_ids_conflict(wayland))
+    {
+        struct wayland_output *output;
+
+        wayland->output_id_fnv_offset += 2;
+        TRACE("recomputing output ids using fnv_offset=0x%x\n",
+              wayland->output_id_fnv_offset);
+
+        wl_list_for_each(output, &wayland->output_list, link)
+            wayland_output_recompute_id(output);
+    }
+}
+
 static void wayland_output_add_default_modes(struct wayland_output *output)
 {
     int i;
@@ -356,6 +415,9 @@ static void zxdg_output_v1_handle_name(void *data,
 
     free(output->name);
     output->name = strdup(name);
+    wayland_output_recompute_id(output);
+
+    wayland_recompute_output_ids_until_no_conflict(output->wayland);
 }
 
 static void zxdg_output_v1_handle_description(void *data,
@@ -406,6 +468,8 @@ BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t versio
     {
         snprintf(output->name, 20, "WaylandOutput%d",
                  wayland->next_fallback_output_id++);
+        wayland_output_recompute_id(output);
+        wayland_recompute_output_ids_until_no_conflict(output->wayland);
     }
     else
     {
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 83899a5264d..0f35a4e7ff6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -162,7 +162,8 @@ static void handle_wl_surface_enter(void *data,
 
     if (!output || output->wayland != surface->wayland) return;
 
-    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+    TRACE("hwnd=%p output->name=%s output->id=0x%x\n",
+          surface->hwnd, output->name, output->id);
 
     ref = heap_alloc_zero(sizeof(*ref));
     if (!ref) { ERR("memory allocation failed"); return; }
@@ -184,7 +185,8 @@ static void handle_wl_surface_leave(void *data,
 
     if (!output || output->wayland != surface->wayland) return;
 
-    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+    TRACE("hwnd=%p output->name=%s output->id=0x%x\n",
+          surface->hwnd, output->name, output->id);
 
     wayland_surface_leave_output(surface, output);
 }
@@ -836,10 +838,10 @@ void wayland_surface_set_main_output(struct wayland_surface *surface,
     /* Don't update non-toplevels. */
     if (surface->parent) return;
 
-    TRACE("surface=%p output->name=%s => output->name=%s\n",
-          surface,
-          surface->main_output ? surface->main_output->name : NULL,
-          output ? output->name : NULL);
+    TRACE("surface=%p output->name=%s (id=0x%x) => output->name=%s (id=0x%x)\n",
+          surface, surface->main_output ? surface->main_output->name : NULL,
+          surface->main_output ? surface->main_output->id : 0,
+          output ? output->name : NULL, output ? output->id : 0);
 
     if (surface->main_output != output)
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 219a0d3cf97..156043c0659 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -113,6 +113,7 @@ struct wayland
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
+    uint32_t output_id_fnv_offset;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list toplevel_list;
@@ -154,6 +155,7 @@ struct wayland_output
     double wine_scale;
     char *name;
     WCHAR wine_name[128];
+    uint32_t id;
     uint32_t global_id;
 };
 
-- 
2.33.0


From 8dc909611a268148579095d1f039f226f437a39e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 16:05:25 +0300
Subject: [PATCH 055/125] winewayland.drv: Implement ChangeDisplaySettingsEx

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c            | 171 ++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c            |  30 ++++
 dlls/winewayland.drv/wayland_output.c     |  59 ++++++++
 dlls/winewayland.drv/waylanddrv.h         |   8 +-
 dlls/winewayland.drv/window.c             |   8 +
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 6 files changed, 276 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index fa9436728b8..6780a16c8c6 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -630,6 +630,51 @@ done:
     return ret;
 }
 
+static BOOL write_registry_settings(const WCHAR *device_name, const DEVMODEW *dm)
+{
+    WCHAR display_device_reg_key[MAX_PATH];
+    HANDLE mutex;
+    HKEY hkey;
+    BOOL ret = TRUE;
+
+    mutex = acquire_display_devices_init_mutex();
+    if (!get_display_device_reg_key(device_name, display_device_reg_key,
+                                    ARRAY_SIZE(display_device_reg_key)))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+    if (RegCreateKeyExW(HKEY_CURRENT_CONFIG, display_device_reg_key, 0, NULL,
+                        REG_OPTION_VOLATILE, KEY_WRITE, NULL, &hkey, NULL))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+#define set_value(name, data) \
+    if (RegSetValueExA(hkey, name, 0, REG_DWORD, (const BYTE*)(data), sizeof(DWORD))) \
+        ret = FALSE
+
+    set_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    set_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    set_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    set_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    set_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    set_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    set_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    set_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    set_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef set_value
+
+    RegCloseKey(hkey);
+
+done:
+    release_display_devices_init_mutex(mutex);
+    return ret;
+}
+
 static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
 {
     mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
@@ -751,3 +796,129 @@ done:
     lstrcpyW(devmode->dmDeviceName, dev_name);
     return TRUE;
 }
+
+static struct wayland_output_mode *get_matching_output_mode_32bpp(struct wayland_output *output,
+                                                                  LPDEVMODEW devmode)
+{
+    struct wayland_output_mode *output_mode;
+    DEVMODEW full_mode;
+
+    if (output->current_wine_mode)
+        populate_devmode(output->current_wine_mode, &full_mode);
+    else
+        populate_devmode(output->current_mode, &full_mode);
+
+    if (devmode->dmFields & DM_PELSWIDTH)
+        full_mode.dmPelsWidth = devmode->dmPelsWidth;
+    if (devmode->dmFields & DM_PELSHEIGHT)
+        full_mode.dmPelsHeight = devmode->dmPelsHeight;
+    if (devmode->dmFields & DM_BITSPERPEL)
+        full_mode.dmBitsPerPel = devmode->dmBitsPerPel;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (full_mode.dmPelsWidth == output_mode->width &&
+            full_mode.dmPelsHeight == output_mode->height &&
+            output_mode->bpp == 32)
+        {
+            return output_mode;
+        }
+    }
+
+    return NULL;
+}
+
+static BOOL wayland_restore_all_outputs(struct wayland *wayland)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        struct wayland_output_mode *output_mode = NULL;
+        DEVMODEW devmode;
+
+        if (read_registry_settings(output->wine_name, &devmode))
+            output_mode = get_matching_output_mode_32bpp(output, &devmode);
+        else
+            output_mode = output->current_mode;
+
+        if (!output_mode)
+            return FALSE;
+
+        if (output_mode != output->current_wine_mode)
+            wayland_notify_wine_mode_change(output->id, output_mode->width, output_mode->height);
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *		ChangeDisplaySettingsEx  (WAYLAND.@)
+ *
+ */
+LONG CDECL WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                           HWND hwnd, DWORD flags, LPVOID lpvoid)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+
+    TRACE("(%s,%p,%p,0x%08x,%p) %dx%d@%d wayland=%p\n",
+          debugstr_w(devname), devmode, hwnd, flags, lpvoid,
+          devmode ? devmode->dmPelsWidth : -1,
+          devmode ? devmode->dmPelsHeight : -1,
+          devmode ? devmode->dmDisplayFrequency : -1, wayland);
+
+    if (devname && devmode)
+    {
+        DEVMODEW full_mode;
+
+        output = wayland_output_get_by_wine_name(wayland, devname);
+        if (!output)
+            return DISP_CHANGE_BADPARAM;
+
+        output_mode = get_matching_output_mode_32bpp(output, devmode);
+        if (!output_mode)
+            return DISP_CHANGE_BADMODE;
+
+        populate_devmode(output_mode, &full_mode);
+
+        if (flags & CDS_UPDATEREGISTRY)
+        {
+            if (!write_registry_settings(devname, &full_mode))
+            {
+                ERR("Failed to write %s display settings to registry.\n", wine_dbgstr_w(devname));
+                return DISP_CHANGE_NOTUPDATED;
+            }
+        }
+    }
+
+    if (flags & (CDS_TEST | CDS_NORESET))
+        return DISP_CHANGE_SUCCESSFUL;
+
+    /* The notification needs to happen before we reinit the display devices,
+     * in order for the reinit to read the new current mode. */
+    if (devname && devmode)
+    {
+        wayland_notify_wine_mode_change(output->id, output_mode->width, output_mode->height);
+    }
+    else
+    {
+        if (!wayland_restore_all_outputs(wayland))
+            return DISP_CHANGE_BADMODE;
+    }
+
+    wayland_init_display_devices_internal(wayland, TRUE);
+
+    if (devname && devmode)
+    {
+        TRACE("set current wine mode %dx%d wine_scale %f\n",
+              output_mode->width, output_mode->height, output->wine_scale);
+    }
+    else
+    {
+        TRACE("restored all outputs to registry (or native) settings\n");
+    }
+
+    return DISP_CHANGE_SUCCESSFUL;
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 6b48c9e6985..6fd90ecfb41 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -536,3 +536,33 @@ DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handl
 
     return ret;
 }
+
+/**********************************************************************
+ *          wayland_notify_wine_mode_change
+ *
+ * Notify all wayland instances about a change in the current wine mode.
+ * The notification is synchronous, this function returns after all
+ * wayland instances have handled the event.
+ */
+void wayland_notify_wine_mode_change(uint32_t output_id, int width, int height)
+{
+    struct wayland *w;
+
+    EnterCriticalSection(&thread_wayland_section);
+
+    /* Each thread maintains its own output mode information, so we need to
+     * notify all threads about the wine mode change. We can't guarantee that
+     * all threads will have windows to which we could potentially send the
+     * notification message to, so we use the internal send function to target
+     * the threads directly. We can't use PostThreadMessage since we require
+     * synchronous message handling. */
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        __wine_send_internal_message_timeout(w->process_id, w->thread_id,
+                                             WM_WAYLAND_MODE_CHANGE,
+                                             output_id, MAKELPARAM(width, height),
+                                             0, -1, NULL);
+    }
+
+    LeaveCriticalSection(&thread_wayland_section);
+}
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 0cdf2ee1e37..066fce572c4 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -539,3 +539,62 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
     return NULL;
 }
+
+/**********************************************************************
+ *          wayland_output_get_by_id
+ *
+ *  Returns the wayland_output with the specified id (or NULL
+ *  if not present).
+ */
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland,
+                                                uint32_t output_id)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (output->id == output_id)
+            return output;
+    }
+
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_output_set_wine_mode
+ *
+ * Set the current wine mode for the specified output.
+ */
+void wayland_output_set_wine_mode(struct wayland_output *output, int width, int height)
+{
+    struct wayland_output_mode *output_mode;
+
+    TRACE("output->name=%s (id=0x%x) width=%d height=%d\n",
+          output->name, output->id, width, height);
+
+    /* We always use 32bpp modes since that's the only one we really
+     * support. */
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (output_mode->width == width && output_mode->height == height &&
+            output_mode->bpp == 32)
+        {
+            output->current_wine_mode = output_mode;
+            break;
+        }
+    }
+
+    if (!output->current_wine_mode || !output->current_mode)
+    {
+        output->wine_scale = 1.0;
+    }
+    else
+    {
+        double scale_x = ((double)output->current_mode->width) /
+                         output->current_wine_mode->width;
+        double scale_y = ((double)output->current_mode->height) /
+                         output->current_wine_mode->height;
+        /* We want to keep the aspect ratio of the target mode. */
+        output->wine_scale = fmin(scale_x, scale_y);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 156043c0659..188a97213e0 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -46,7 +46,8 @@ enum wayland_window_message
 {
     WM_WAYLAND_CONFIGURE = 0x80001000,
     WM_WAYLAND_STATE_UPDATE = 0x80001001,
-    WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001002
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001002,
+    WM_WAYLAND_MODE_CHANGE = 0x80001003,
 };
 
 enum wayland_configure_flags
@@ -268,6 +269,11 @@ void wayland_output_destroy(struct wayland_output *output);
 void wayland_output_use_xdg_extension(struct wayland_output *output);
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name);
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland,
+                                                uint32_t id);
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  int width, int height);
+void wayland_notify_wine_mode_change(uint32_t output_id, int width, int height);
 
 /**********************************************************************
  *          Wayland event dispatch
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 04327d2ad99..c08e9eec6bb 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1232,6 +1232,14 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
         handle_wm_wayland_surface_output_change(hwnd);
         break;
+    case WM_WAYLAND_MODE_CHANGE:
+        {
+            struct wayland_output *output =
+                wayland_output_get_by_id(thread_wayland(), wp);
+            if (output)
+                wayland_output_set_wine_mode(output, LOWORD(lp), HIWORD(lp));
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index e43bd66c67c..c384c6fe254 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -1,5 +1,6 @@
 # USER driver
 
+@ cdecl ChangeDisplaySettingsEx(ptr ptr long long long) WAYLAND_ChangeDisplaySettingsEx
 @ cdecl CreateWindow(long) WAYLAND_CreateWindow
 @ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
 @ cdecl EnumDisplaySettingsEx(ptr long ptr long) WAYLAND_EnumDisplaySettingsEx
-- 
2.33.0


From 6a8bc1de8b3cc3358bc5a6f10ef61bc80c79edff Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 16:59:19 +0300
Subject: [PATCH 056/125] winewayland.drv: Add skeleton gdi driver

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in          |   1 +
 dlls/winewayland.drv/gdi.c                | 113 ++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |   4 +
 3 files changed, 118 insertions(+)
 create mode 100644 dlls/winewayland.drv/gdi.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 6aa1d630d83..82f8de27335 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,6 +11,7 @@ EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	display.c \
+	gdi.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
new file mode 100644
index 00000000000..a26f09ad866
--- /dev/null
+++ b/dlls/winewayland.drv/gdi.c
@@ -0,0 +1,113 @@
+/*
+ * Wayland gdi functions
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/gdi_driver.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static const struct gdi_dc_funcs wayland_gdi_dc_funcs;
+
+typedef struct
+{
+    struct gdi_physdev dev;
+} WAYLAND_PDEVICE;
+
+static inline WAYLAND_PDEVICE *get_wayland_dev(PHYSDEV dev)
+{
+    return (WAYLAND_PDEVICE *)dev;
+}
+
+static WAYLAND_PDEVICE *create_wayland_physdev(void)
+{
+    WAYLAND_PDEVICE *physDev;
+
+    physDev = heap_alloc_zero(sizeof(*physDev));
+
+    return physDev;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateDC
+ */
+static BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR driver, LPCWSTR device,
+                                       LPCWSTR output, const DEVMODEW* initData)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &wayland_gdi_dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateCompatibleDC
+ */
+static BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &wayland_gdi_dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_DeleteDC
+ */
+static BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
+{
+    WAYLAND_PDEVICE *physDev = get_wayland_dev(dev);
+
+    HeapFree(GetProcessHeap(), 0, physDev);
+    return TRUE;
+}
+
+
+static const struct gdi_dc_funcs wayland_gdi_dc_funcs =
+{
+    .pCreateDC = WAYLAND_CreateDC,
+    .pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
+    .pDeleteDC = WAYLAND_DeleteDC,
+    .priority = GDI_PRIORITY_GRAPHICS_DRV
+};
+
+/******************************************************************************
+ *      WAYLAND_get_gdi_driver
+ */
+const struct gdi_dc_funcs * CDECL WAYLAND_get_gdi_driver(unsigned int version)
+{
+    if (version != WINE_GDI_DRIVER_VERSION)
+    {
+        ERR("version mismatch, gdi32 wants %u but winewayland has %u\n",
+            version, WINE_GDI_DRIVER_VERSION);
+        return NULL;
+    }
+    return &wayland_gdi_dc_funcs;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index c384c6fe254..e668254352b 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -1,3 +1,7 @@
+# GDI driver
+
+@ cdecl wine_get_gdi_driver(long) WAYLAND_get_gdi_driver
+
 # USER driver
 
 @ cdecl ChangeDisplaySettingsEx(ptr ptr long long long) WAYLAND_ChangeDisplaySettingsEx
-- 
2.33.0


From 533b0486d7c391ee0e55743640914e6269cf45d2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:48:15 +0300
Subject: [PATCH 057/125] winewayland.drv: Prepare for handling OpenGL/VK areas
 as subsurfaces of main window

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                              |  83 +++++++++
 configure.ac                           |   4 +
 dlls/winewayland.drv/Makefile.in       |   4 +-
 dlls/winewayland.drv/wayland_surface.c | 228 +++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |   9 +
 dlls/winewayland.drv/window.c          |   8 +
 include/config.h.in                    |   3 +
 7 files changed, 321 insertions(+), 18 deletions(-)

diff --git a/configure.ac b/configure.ac
index f8717f10d5c..30da42d6bf3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1296,6 +1296,10 @@ then
     WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
         [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
          AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_EGL,[wayland-egl],,,,
+        [AC_CHECK_HEADERS([wayland-egl.h])
+         AC_CHECK_LIB(wayland-egl,wl_egl_window_create,[:],
+                      [WAYLAND_EGL_LIBS=""],[$WAYLAND_EGL_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 82f8de27335..553299637c4 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32
-EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(XKBCOMMON_CFLAGS)
-EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(XKBCOMMON_LIBS)
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
+EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 0f35a4e7ff6..ae3995d0225 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -364,6 +364,9 @@ err:
  *
  * The coordinates and sizes should be given in wine's coordinate space.
  *
+ * Note that this doesn't configure any associated GL/VK subsurface,
+ * wayland_surface_reconfigure_glvk() needs to be called separately.
+ *
  * This function sets up but doesn't actually apply any new configuration.
  * The wayland_surface_reconfigure_apply() needs to be called for changes
  * to take effect.
@@ -399,22 +402,6 @@ void wayland_surface_reconfigure(struct wayland_surface *surface,
         xdg_surface_set_window_geometry(surface->xdg_surface, 0, 0, width, height);
 }
 
-/**********************************************************************
- *          wayland_surface_reconfigure_apply
- *
- * Applies the configuration set by previous calls to the
- * wayland_surface_reconfigure{_glvk}() functions.
- */
-void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
-{
-    wl_surface_commit(surface->wl_surface);
-
-    /* Commit the parent so any subsurface repositioning takes effect. */
-    if (surface->parent)
-        wl_surface_commit(surface->parent->wl_surface);
-}
-
-
 static RGNDATA *get_region_data(HRGN region)
 {
     RGNDATA *data = NULL;
@@ -559,6 +546,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         heap_free(ref);
     }
 
+    if (surface->wl_egl_window)
+    {
+        wl_egl_window_destroy(surface->wl_egl_window);
+        surface->wl_egl_window = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
@@ -620,6 +613,205 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
+static struct wayland_surface *wayland_surface_create_glvk_common(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    glvk = wayland_surface_create_common(surface->wayland);
+    if (!glvk)
+        goto err;
+
+    glvk->parent = wayland_surface_ref(surface);
+
+    EnterCriticalSection(&glvk->parent->crit);
+    wl_list_insert(&glvk->parent->child_list, &glvk->link);
+    LeaveCriticalSection(&glvk->parent->crit);
+
+    glvk->wl_subsurface =
+        wl_subcompositor_get_subsurface(glvk->wayland->wl_subcompositor,
+                                        glvk->wl_surface,
+                                        surface->wl_surface);
+    if (!glvk->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(glvk->wl_subsurface);
+
+    glvk->hwnd = surface->hwnd;
+    glvk->main_output = surface->main_output;
+    wl_surface_set_buffer_scale(glvk->wl_surface, wayland_surface_get_buffer_scale(surface));
+
+    return glvk;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return NULL;
+
+}
+
+static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = NULL;
+    EnterCriticalSection(&surface->crit);
+    if (surface->glvk)
+        glvk = wayland_surface_ref(surface->glvk);
+    LeaveCriticalSection(&surface->crit);
+    return glvk;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_gl
+ *
+ * Creates a GL subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+    RECT client_rect;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (wayland_surface_ref_glvk(surface))
+        return TRUE;
+
+    glvk = wayland_surface_create_glvk_common(surface);
+    if (!glvk)
+        goto err;
+
+    glvk->wl_egl_window = wl_egl_window_create(glvk->wl_surface, 1, 1);
+    if (!glvk->wl_egl_window)
+        goto err;
+
+    EnterCriticalSection(&surface->crit);
+    surface->glvk = glvk;
+    LeaveCriticalSection(&surface->crit);
+
+    /* Set initial position in the client area. */
+    GetClientRect(surface->hwnd, &client_rect);
+    MapWindowPoints(surface->hwnd, NULL, (POINT*)&client_rect, 2);
+
+    wayland_surface_reconfigure_glvk(surface,
+                                     client_rect.left, client_rect.top,
+                                     client_rect.right - client_rect.left,
+                                     client_rect.bottom - client_rect.top);
+
+    wayland_surface_reconfigure_apply(surface);
+
+    return TRUE;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref_glvk
+ *
+ * Unreferences the associated GL/VK subsurface for this wayland surface.
+ */
+void wayland_surface_unref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk_to_destroy = NULL;
+    LONG ref = -12345;
+
+    EnterCriticalSection(&surface->crit);
+    if (surface->glvk && (ref = InterlockedDecrement(&surface->glvk->ref)) == 0)
+    {
+        glvk_to_destroy = surface->glvk;
+        surface->glvk = NULL;
+    }
+    TRACE("surface=%p glvk=%p ref=%d->%d\n",
+          surface, glvk_to_destroy ? glvk_to_destroy : surface->glvk, ref + 1, ref);
+    LeaveCriticalSection(&surface->crit);
+
+    if (glvk_to_destroy)
+        wayland_surface_destroy(glvk_to_destroy);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_glvk
+ *
+ * Configures the position and size of the GL/VK subsurface associated with
+ * a wayland surface.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      int wine_width, int wine_height)
+{
+    int x, y, width, height;
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (!glvk)
+        return;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    glvk->offset_x = wine_x;
+    glvk->offset_y = wine_y;
+
+    wl_subsurface_set_position(glvk->wl_subsurface, x, y);
+
+    /* The EGL window size needs to be in wine coords since this affects
+     * the effective EGL buffer size. */
+    if (glvk->wl_egl_window)
+        wl_egl_window_resize(glvk->wl_egl_window, wine_width, wine_height, 0, 0);
+
+    /* Use a viewport, if supported, to ensure GL surfaces remain inside their
+     * parent's boundaries when resizing and also to handle display mode
+     * changes. If the size is invalid use a 1x1 destination (instead of
+     * unsetting with -1x-1) since many apps don't respect a GL/VK 0x0 size
+     * which can happen, e.g., when an app is minimized. */
+    if (glvk->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(glvk->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(glvk->wp_viewport, 1, 1);
+    }
+
+    wayland_surface_unref_glvk(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (glvk)
+    {
+        wl_surface_commit(glvk->wl_surface);
+        wayland_surface_unref_glvk(surface);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
 /**********************************************************************
  *          wayland_surface_unmap
  *
@@ -653,6 +845,10 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
 
     GetWindowRect(surface->hwnd, &window_rect);
 
+    /* Some wayland surfaces are offset relative to their window rect,
+     * e.g., GL subsurfaces. */
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
     *screen_x = wine_x + window_rect.left;
     *screen_y = wine_y + window_rect.top;
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 188a97213e0..908530b150b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -27,6 +27,7 @@
 
 #include <stdarg.h>
 #include <wayland-client.h>
+#include <wayland-egl.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
 #include "viewporter-client-protocol.h"
@@ -184,7 +185,11 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wp_viewport *wp_viewport;
+    struct wl_egl_window *wl_egl_window;
     struct wayland_surface *parent;
+    struct wayland_surface *glvk;
+    /* The offset of this surface relative to its owning win32 window */
+    int offset_x, offset_y;
     HWND hwnd;
     CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
@@ -312,6 +317,10 @@ void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_reconfigure(struct wayland_surface *surface, int x, int y,
                                  int width,int height);
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
+BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface);
+void wayland_surface_unref_glvk(struct wayland_surface *surface);
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
+                                      int width, int height);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index c08e9eec6bb..31e15376c9b 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -523,6 +523,14 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
                                 data->window_rect.left - parent_rect.left,
                                 data->window_rect.top - parent_rect.top,
                                 width, height);
+    /* The GL/VK subsurface (if any), is positioned over the client area of the
+     * window. The position of the GL/VK subsurface is relative to the window
+     * top-left. */
+    wayland_surface_reconfigure_glvk(data->wayland_surface,
+                                     data->client_rect.left - data->window_rect.left,
+                                     data->client_rect.top - data->window_rect.top,
+                                     data->client_rect.right - data->client_rect.left,
+                                     data->client_rect.bottom - data->client_rect.top);
 
     wayland_surface_reconfigure_apply(data->wayland_surface);
 
diff --git a/include/config.h.in b/include/config.h.in
index d025830a82d..8f613872180 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -911,6 +911,9 @@
 /* Define to 1 if you have the <wayland-client.h> header file. */
 #undef HAVE_WAYLAND_CLIENT_H
 
+/* Define to 1 if you have the <wayland-egl.h> header file. */
+#undef HAVE_WAYLAND_EGL_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.33.0


From 7b3c6b5845fdcded3aae1c2a372193702722758e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 11:49:22 +0300
Subject: [PATCH 058/125] winewayland.drv: Skeleton OpenGL driver

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                        | 165 ++++++++++++
 configure.ac                     |   3 +
 dlls/winewayland.drv/Makefile.in |   1 +
 dlls/winewayland.drv/opengl.c    | 446 +++++++++++++++++++++++++++++++
 4 files changed, 615 insertions(+)
 create mode 100644 dlls/winewayland.drv/opengl.c

diff --git a/configure.ac b/configure.ac
index 30da42d6bf3..a74a4db0459 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1300,6 +1300,9 @@ then
         [AC_CHECK_HEADERS([wayland-egl.h])
          AC_CHECK_LIB(wayland-egl,wl_egl_window_create,[:],
                       [WAYLAND_EGL_LIBS=""],[$WAYLAND_EGL_LIBS])])
+    WINE_CHECK_SONAME(EGL,eglGetProcAddress)
+    WINE_CHECK_SONAME(GL,glFlush)
+    WINE_CHECK_SONAME(GLESv2,glFlush)
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 553299637c4..35400e11588 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -12,6 +12,7 @@ EXTRADLLFLAGS = -mcygwin
 C_SRCS = \
 	display.c \
 	gdi.c \
+	opengl.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
new file mode 100644
index 00000000000..c4e5ee8d1d6
--- /dev/null
+++ b/dlls/winewayland.drv/opengl.c
@@ -0,0 +1,446 @@
+/*
+ * Wayland OpenGL functions
+ *
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2005 Alex Woods
+ * Copyright 2005 Raphael Junqueira
+ * Copyright 2006-2009 Roderick Colenbrander
+ * Copyright 2006 Tomas Carnecky
+ * Copyright 2013 Matteo Bruni
+ * Copyright 2012, 2013, 2014, 2017 Alexandre Julliard
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include "waylanddrv.h"
+
+#define GLAPIENTRY /* nothing */
+#include "wine/wgl.h"
+#undef GLAPIENTRY
+#include "wine/wgl_driver.h"
+#include "wine/debug.h"
+
+#include <EGL/egl.h>
+#include <assert.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void *egl_handle;
+static void *opengl_handle;
+static EGLDisplay egl_display;
+static char wgl_extensions[4096];
+static struct opengl_funcs egl_funcs;
+
+#define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglInitialize);
+#undef DECL_FUNCPTR
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringARB
+ */
+static const char *wayland_wglGetExtensionsStringARB(HDC hdc)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringEXT
+ */
+static const char *wayland_wglGetExtensionsStringEXT(void)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+static void register_extension(const char *ext)
+{
+    if (wgl_extensions[0]) strcat(wgl_extensions, " ");
+    strcat(wgl_extensions, ext);
+    TRACE("%s\n", ext);
+}
+
+static void init_extensions(void)
+{
+    void *ptr;
+
+    register_extension("WGL_ARB_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
+
+    register_extension("WGL_EXT_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
+
+    register_extension("WGL_EXT_framebuffer_sRGB");
+
+    /* load standard functions and extensions exported from the OpenGL library */
+
+#define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
+    ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+#define LOAD_FUNCPTR(func) egl_funcs.ext.p_##func = dlsym(opengl_handle, #func)
+    LOAD_FUNCPTR(glActiveShaderProgram);
+    LOAD_FUNCPTR(glActiveTexture);
+    LOAD_FUNCPTR(glAttachShader);
+    LOAD_FUNCPTR(glBeginQuery);
+    LOAD_FUNCPTR(glBeginTransformFeedback);
+    LOAD_FUNCPTR(glBindAttribLocation);
+    LOAD_FUNCPTR(glBindBuffer);
+    LOAD_FUNCPTR(glBindBufferBase);
+    LOAD_FUNCPTR(glBindBufferRange);
+    LOAD_FUNCPTR(glBindFramebuffer);
+    LOAD_FUNCPTR(glBindImageTexture);
+    LOAD_FUNCPTR(glBindProgramPipeline);
+    LOAD_FUNCPTR(glBindRenderbuffer);
+    LOAD_FUNCPTR(glBindSampler);
+    LOAD_FUNCPTR(glBindTransformFeedback);
+    LOAD_FUNCPTR(glBindVertexArray);
+    LOAD_FUNCPTR(glBindVertexBuffer);
+    LOAD_FUNCPTR(glBlendBarrierKHR);
+    LOAD_FUNCPTR(glBlendColor);
+    LOAD_FUNCPTR(glBlendEquation);
+    LOAD_FUNCPTR(glBlendEquationSeparate);
+    LOAD_FUNCPTR(glBlendFuncSeparate);
+    LOAD_FUNCPTR(glBlitFramebuffer);
+    LOAD_FUNCPTR(glBufferData);
+    LOAD_FUNCPTR(glBufferSubData);
+    LOAD_FUNCPTR(glCheckFramebufferStatus);
+    LOAD_FUNCPTR(glClearBufferfi);
+    LOAD_FUNCPTR(glClearBufferfv);
+    LOAD_FUNCPTR(glClearBufferiv);
+    LOAD_FUNCPTR(glClearBufferuiv);
+    LOAD_FUNCPTR(glClearDepthf);
+    LOAD_FUNCPTR(glClientWaitSync);
+    LOAD_FUNCPTR(glCompileShader);
+    LOAD_FUNCPTR(glCompressedTexImage2D);
+    LOAD_FUNCPTR(glCompressedTexImage3D);
+    LOAD_FUNCPTR(glCompressedTexSubImage2D);
+    LOAD_FUNCPTR(glCompressedTexSubImage3D);
+    LOAD_FUNCPTR(glCopyBufferSubData);
+    LOAD_FUNCPTR(glCopyTexSubImage3D);
+    LOAD_FUNCPTR(glCreateProgram);
+    LOAD_FUNCPTR(glCreateShader);
+    LOAD_FUNCPTR(glCreateShaderProgramv);
+    LOAD_FUNCPTR(glDeleteBuffers);
+    LOAD_FUNCPTR(glDeleteFramebuffers);
+    LOAD_FUNCPTR(glDeleteProgram);
+    LOAD_FUNCPTR(glDeleteProgramPipelines);
+    LOAD_FUNCPTR(glDeleteQueries);
+    LOAD_FUNCPTR(glDeleteRenderbuffers);
+    LOAD_FUNCPTR(glDeleteSamplers);
+    LOAD_FUNCPTR(glDeleteShader);
+    LOAD_FUNCPTR(glDeleteSync);
+    LOAD_FUNCPTR(glDeleteTransformFeedbacks);
+    LOAD_FUNCPTR(glDeleteVertexArrays);
+    LOAD_FUNCPTR(glDepthRangef);
+    LOAD_FUNCPTR(glDetachShader);
+    LOAD_FUNCPTR(glDisableVertexAttribArray);
+    LOAD_FUNCPTR(glDispatchCompute);
+    LOAD_FUNCPTR(glDispatchComputeIndirect);
+    LOAD_FUNCPTR(glDrawArraysIndirect);
+    LOAD_FUNCPTR(glDrawArraysInstanced);
+    LOAD_FUNCPTR(glDrawBuffers);
+    LOAD_FUNCPTR(glDrawElementsIndirect);
+    LOAD_FUNCPTR(glDrawElementsInstanced);
+    LOAD_FUNCPTR(glDrawRangeElements);
+    LOAD_FUNCPTR(glEnableVertexAttribArray);
+    LOAD_FUNCPTR(glEndQuery);
+    LOAD_FUNCPTR(glEndTransformFeedback);
+    LOAD_FUNCPTR(glFenceSync);
+    LOAD_FUNCPTR(glFlushMappedBufferRange);
+    LOAD_FUNCPTR(glFramebufferParameteri);
+    LOAD_FUNCPTR(glFramebufferRenderbuffer);
+    LOAD_FUNCPTR(glFramebufferTexture2D);
+    LOAD_FUNCPTR(glFramebufferTextureEXT);
+    LOAD_FUNCPTR(glFramebufferTextureLayer);
+    LOAD_FUNCPTR(glGenBuffers);
+    LOAD_FUNCPTR(glGenFramebuffers);
+    LOAD_FUNCPTR(glGenProgramPipelines);
+    LOAD_FUNCPTR(glGenQueries);
+    LOAD_FUNCPTR(glGenRenderbuffers);
+    LOAD_FUNCPTR(glGenSamplers);
+    LOAD_FUNCPTR(glGenTransformFeedbacks);
+    LOAD_FUNCPTR(glGenVertexArrays);
+    LOAD_FUNCPTR(glGenerateMipmap);
+    LOAD_FUNCPTR(glGetActiveAttrib);
+    LOAD_FUNCPTR(glGetActiveUniform);
+    LOAD_FUNCPTR(glGetActiveUniformBlockName);
+    LOAD_FUNCPTR(glGetActiveUniformBlockiv);
+    LOAD_FUNCPTR(glGetActiveUniformsiv);
+    LOAD_FUNCPTR(glGetAttachedShaders);
+    LOAD_FUNCPTR(glGetAttribLocation);
+    LOAD_FUNCPTR(glGetBooleani_v);
+    LOAD_FUNCPTR(glGetBufferParameteri64v);
+    LOAD_FUNCPTR(glGetBufferParameteriv);
+    LOAD_FUNCPTR(glGetBufferPointerv);
+    LOAD_FUNCPTR(glGetFragDataLocation);
+    LOAD_FUNCPTR(glGetFramebufferAttachmentParameteriv);
+    LOAD_FUNCPTR(glGetFramebufferParameteriv);
+    LOAD_FUNCPTR(glGetInteger64i_v);
+    LOAD_FUNCPTR(glGetInteger64v);
+    LOAD_FUNCPTR(glGetIntegeri_v);
+    LOAD_FUNCPTR(glGetInternalformativ);
+    LOAD_FUNCPTR(glGetMultisamplefv);
+    LOAD_FUNCPTR(glGetProgramBinary);
+    LOAD_FUNCPTR(glGetProgramInfoLog);
+    LOAD_FUNCPTR(glGetProgramInterfaceiv);
+    LOAD_FUNCPTR(glGetProgramPipelineInfoLog);
+    LOAD_FUNCPTR(glGetProgramPipelineiv);
+    LOAD_FUNCPTR(glGetProgramResourceIndex);
+    LOAD_FUNCPTR(glGetProgramResourceLocation);
+    LOAD_FUNCPTR(glGetProgramResourceName);
+    LOAD_FUNCPTR(glGetProgramResourceiv);
+    LOAD_FUNCPTR(glGetProgramiv);
+    LOAD_FUNCPTR(glGetQueryObjectuiv);
+    LOAD_FUNCPTR(glGetQueryiv);
+    LOAD_FUNCPTR(glGetRenderbufferParameteriv);
+    LOAD_FUNCPTR(glGetSamplerParameterfv);
+    LOAD_FUNCPTR(glGetSamplerParameteriv);
+    LOAD_FUNCPTR(glGetShaderInfoLog);
+    LOAD_FUNCPTR(glGetShaderPrecisionFormat);
+    LOAD_FUNCPTR(glGetShaderSource);
+    LOAD_FUNCPTR(glGetShaderiv);
+    LOAD_FUNCPTR(glGetStringi);
+    LOAD_FUNCPTR(glGetSynciv);
+    LOAD_FUNCPTR(glGetTexParameterIivEXT);
+    LOAD_FUNCPTR(glGetTexParameterIuivEXT);
+    LOAD_FUNCPTR(glGetTransformFeedbackVarying);
+    LOAD_FUNCPTR(glGetUniformBlockIndex);
+    LOAD_FUNCPTR(glGetUniformIndices);
+    LOAD_FUNCPTR(glGetUniformLocation);
+    LOAD_FUNCPTR(glGetUniformfv);
+    LOAD_FUNCPTR(glGetUniformiv);
+    LOAD_FUNCPTR(glGetUniformuiv);
+    LOAD_FUNCPTR(glGetVertexAttribIiv);
+    LOAD_FUNCPTR(glGetVertexAttribIuiv);
+    LOAD_FUNCPTR(glGetVertexAttribPointerv);
+    LOAD_FUNCPTR(glGetVertexAttribfv);
+    LOAD_FUNCPTR(glGetVertexAttribiv);
+    LOAD_FUNCPTR(glInvalidateFramebuffer);
+    LOAD_FUNCPTR(glInvalidateSubFramebuffer);
+    LOAD_FUNCPTR(glIsBuffer);
+    LOAD_FUNCPTR(glIsFramebuffer);
+    LOAD_FUNCPTR(glIsProgram);
+    LOAD_FUNCPTR(glIsProgramPipeline);
+    LOAD_FUNCPTR(glIsQuery);
+    LOAD_FUNCPTR(glIsRenderbuffer);
+    LOAD_FUNCPTR(glIsSampler);
+    LOAD_FUNCPTR(glIsShader);
+    LOAD_FUNCPTR(glIsSync);
+    LOAD_FUNCPTR(glIsTransformFeedback);
+    LOAD_FUNCPTR(glIsVertexArray);
+    LOAD_FUNCPTR(glLinkProgram);
+    LOAD_FUNCPTR(glMapBufferRange);
+    LOAD_FUNCPTR(glMemoryBarrier);
+    LOAD_FUNCPTR(glMemoryBarrierByRegion);
+    LOAD_FUNCPTR(glPauseTransformFeedback);
+    LOAD_FUNCPTR(glProgramBinary);
+    LOAD_FUNCPTR(glProgramParameteri);
+    LOAD_FUNCPTR(glProgramUniform1f);
+    LOAD_FUNCPTR(glProgramUniform1fv);
+    LOAD_FUNCPTR(glProgramUniform1i);
+    LOAD_FUNCPTR(glProgramUniform1iv);
+    LOAD_FUNCPTR(glProgramUniform1ui);
+    LOAD_FUNCPTR(glProgramUniform1uiv);
+    LOAD_FUNCPTR(glProgramUniform2f);
+    LOAD_FUNCPTR(glProgramUniform2fv);
+    LOAD_FUNCPTR(glProgramUniform2i);
+    LOAD_FUNCPTR(glProgramUniform2iv);
+    LOAD_FUNCPTR(glProgramUniform2ui);
+    LOAD_FUNCPTR(glProgramUniform2uiv);
+    LOAD_FUNCPTR(glProgramUniform3f);
+    LOAD_FUNCPTR(glProgramUniform3fv);
+    LOAD_FUNCPTR(glProgramUniform3i);
+    LOAD_FUNCPTR(glProgramUniform3iv);
+    LOAD_FUNCPTR(glProgramUniform3ui);
+    LOAD_FUNCPTR(glProgramUniform3uiv);
+    LOAD_FUNCPTR(glProgramUniform4f);
+    LOAD_FUNCPTR(glProgramUniform4fv);
+    LOAD_FUNCPTR(glProgramUniform4i);
+    LOAD_FUNCPTR(glProgramUniform4iv);
+    LOAD_FUNCPTR(glProgramUniform4ui);
+    LOAD_FUNCPTR(glProgramUniform4uiv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glReleaseShaderCompiler);
+    LOAD_FUNCPTR(glRenderbufferStorage);
+    LOAD_FUNCPTR(glRenderbufferStorageMultisample);
+    LOAD_FUNCPTR(glResumeTransformFeedback);
+    LOAD_FUNCPTR(glSampleCoverage);
+    LOAD_FUNCPTR(glSampleMaski);
+    LOAD_FUNCPTR(glSamplerParameterf);
+    LOAD_FUNCPTR(glSamplerParameterfv);
+    LOAD_FUNCPTR(glSamplerParameteri);
+    LOAD_FUNCPTR(glSamplerParameteriv);
+    LOAD_FUNCPTR(glShaderBinary);
+    LOAD_FUNCPTR(glShaderSource);
+    LOAD_FUNCPTR(glStencilFuncSeparate);
+    LOAD_FUNCPTR(glStencilMaskSeparate);
+    LOAD_FUNCPTR(glStencilOpSeparate);
+    LOAD_FUNCPTR(glTexBufferEXT);
+    LOAD_FUNCPTR(glTexImage3D);
+    LOAD_FUNCPTR(glTexParameterIivEXT);
+    LOAD_FUNCPTR(glTexParameterIuivEXT);
+    LOAD_FUNCPTR(glTexStorage2D);
+    LOAD_FUNCPTR(glTexStorage2DMultisample);
+    LOAD_FUNCPTR(glTexStorage3D);
+    LOAD_FUNCPTR(glTexSubImage3D);
+    LOAD_FUNCPTR(glTransformFeedbackVaryings);
+    LOAD_FUNCPTR(glUniform1f);
+    LOAD_FUNCPTR(glUniform1fv);
+    LOAD_FUNCPTR(glUniform1i);
+    LOAD_FUNCPTR(glUniform1iv);
+    LOAD_FUNCPTR(glUniform1ui);
+    LOAD_FUNCPTR(glUniform1uiv);
+    LOAD_FUNCPTR(glUniform2f);
+    LOAD_FUNCPTR(glUniform2fv);
+    LOAD_FUNCPTR(glUniform2i);
+    LOAD_FUNCPTR(glUniform2iv);
+    LOAD_FUNCPTR(glUniform2ui);
+    LOAD_FUNCPTR(glUniform2uiv);
+    LOAD_FUNCPTR(glUniform3f);
+    LOAD_FUNCPTR(glUniform3fv);
+    LOAD_FUNCPTR(glUniform3i);
+    LOAD_FUNCPTR(glUniform3iv);
+    LOAD_FUNCPTR(glUniform3ui);
+    LOAD_FUNCPTR(glUniform3uiv);
+    LOAD_FUNCPTR(glUniform4f);
+    LOAD_FUNCPTR(glUniform4fv);
+    LOAD_FUNCPTR(glUniform4i);
+    LOAD_FUNCPTR(glUniform4iv);
+    LOAD_FUNCPTR(glUniform4ui);
+    LOAD_FUNCPTR(glUniform4uiv);
+    LOAD_FUNCPTR(glUniformBlockBinding);
+    LOAD_FUNCPTR(glUniformMatrix2fv);
+    LOAD_FUNCPTR(glUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glUniformMatrix3fv);
+    LOAD_FUNCPTR(glUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glUniformMatrix4fv);
+    LOAD_FUNCPTR(glUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glUnmapBuffer);
+    LOAD_FUNCPTR(glUseProgram);
+    LOAD_FUNCPTR(glUseProgramStages);
+    LOAD_FUNCPTR(glValidateProgram);
+    LOAD_FUNCPTR(glValidateProgramPipeline);
+    LOAD_FUNCPTR(glVertexAttrib1f);
+    LOAD_FUNCPTR(glVertexAttrib1fv);
+    LOAD_FUNCPTR(glVertexAttrib2f);
+    LOAD_FUNCPTR(glVertexAttrib2fv);
+    LOAD_FUNCPTR(glVertexAttrib3f);
+    LOAD_FUNCPTR(glVertexAttrib3fv);
+    LOAD_FUNCPTR(glVertexAttrib4f);
+    LOAD_FUNCPTR(glVertexAttrib4fv);
+    LOAD_FUNCPTR(glVertexAttribBinding);
+    LOAD_FUNCPTR(glVertexAttribDivisor);
+    LOAD_FUNCPTR(glVertexAttribFormat);
+    LOAD_FUNCPTR(glVertexAttribI4i);
+    LOAD_FUNCPTR(glVertexAttribI4iv);
+    LOAD_FUNCPTR(glVertexAttribI4ui);
+    LOAD_FUNCPTR(glVertexAttribI4uiv);
+    LOAD_FUNCPTR(glVertexAttribIFormat);
+    LOAD_FUNCPTR(glVertexAttribIPointer);
+    LOAD_FUNCPTR(glVertexAttribPointer);
+    LOAD_FUNCPTR(glVertexBindingDivisor);
+    LOAD_FUNCPTR(glWaitSync);
+#undef LOAD_FUNCPTR
+}
+
+static BOOL egl_init(void)
+{
+    static int retval = -1;
+    EGLint major, minor;
+
+    if (retval != -1) return retval;
+    retval = 0;
+
+    if (!(egl_handle = dlopen(SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        ERR("failed to load %s: %s\n", SONAME_LIBEGL, dlerror());
+        return FALSE;
+    }
+
+    if (!(opengl_handle = dlopen(SONAME_LIBGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        WARN("failed to load %s: %s, trying GLESv2\n", SONAME_LIBGL, dlerror());
+        if (!(opengl_handle = dlopen(SONAME_LIBGLESV2, RTLD_NOW|RTLD_GLOBAL)))
+        {
+            ERR("failed to load %s: %s\n", SONAME_LIBGLESV2, dlerror());
+            return FALSE;
+        }
+    }
+
+#define LOAD_FUNCPTR(func) do { \
+        if (!(p_##func = dlsym(egl_handle, #func))) \
+        { ERR("can't find symbol %s\n", #func); return FALSE; }    \
+    } while(0)
+    LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglInitialize);
+#undef LOAD_FUNCPTR
+
+    egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
+    if (!p_eglInitialize(egl_display, &major, &minor)) return FALSE;
+    TRACE("display %p version %u.%u\n", egl_display, major, minor);
+
+    init_extensions();
+    retval = 1;
+    return TRUE;
+}
+
+/* generate stubs for GL functions that are not exported */
+
+#define USE_GL_FUNC(name) \
+static void glstub_##name(void) \
+{ \
+    ERR(#name " called\n"); \
+    assert(0); \
+    ExitProcess(1); \
+}
+
+ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+static struct opengl_funcs egl_funcs =
+{
+#define USE_GL_FUNC(name) (void *)glstub_##name,
+    .gl = { ALL_WGL_FUNCS }
+#undef USE_GL_FUNC
+};
+
+struct opengl_funcs *wayland_get_wgl_driver(UINT version)
+{
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR("version mismatch, opengl32 wants %u but driver has %u\n",
+            version, WINE_WGL_DRIVER_VERSION);
+        return NULL;
+    }
+    if (!egl_init()) return NULL;
+    return &egl_funcs;
+}
-- 
2.33.0


From 69d19c991c5ee06d17fe95fe2f618808a623bc5e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:37:55 +0300
Subject: [PATCH 059/125] winewayland.drv: Implement wglGetProcAddress

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index c4e5ee8d1d6..324f9ad4403 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -49,9 +49,22 @@ static struct opengl_funcs egl_funcs;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
 DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+/***********************************************************************
+ *		wayland_wglGetProcAddress
+ */
+static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
+{
+    PROC ret;
+    if (!strncmp(name, "wgl", 3)) return NULL;
+    ret = (PROC)p_eglGetProcAddress(name);
+    TRACE("%s -> %p\n", name, ret);
+    return ret;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -401,6 +414,7 @@ static BOOL egl_init(void)
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
     LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
 #undef LOAD_FUNCPTR
 
@@ -428,6 +442,10 @@ ALL_WGL_FUNCS
 
 static struct opengl_funcs egl_funcs =
 {
+    .wgl =
+    {
+        .p_wglGetProcAddress = wayland_wglGetProcAddress,
+    },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
 #undef USE_GL_FUNC
-- 
2.33.0


From ae19facc5653a41d4d0ea31332b372871923bf60 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:26:45 +0300
Subject: [PATCH 060/125] winewayland.drv: Initialize OpenGL pixel formats

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 71 +++++++++++++++++++++++++++++++++++
 1 file changed, 71 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 324f9ad4403..dbf988b920d 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -35,19 +35,29 @@
 #undef GLAPIENTRY
 #include "wine/wgl_driver.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 #include <EGL/egl.h>
 #include <assert.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+struct wgl_pixel_format
+{
+    EGLConfig config;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
 static char wgl_extensions[4096];
 static struct opengl_funcs egl_funcs;
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetConfigAttrib);
+DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
@@ -385,6 +395,63 @@ static void init_extensions(void)
 #undef LOAD_FUNCPTR
 }
 
+static BOOL init_pixel_formats(void)
+{
+    EGLint count, i, pass;
+    EGLConfig *egl_configs;
+
+    p_eglGetConfigs(egl_display, NULL, 0, &count);
+    egl_configs = heap_alloc(count * sizeof(*egl_configs));
+    pixel_formats = heap_alloc(count * sizeof(*pixel_formats));
+    p_eglGetConfigs(egl_display, egl_configs, count, &count);
+    if (!count || !egl_configs || !pixel_formats)
+    {
+        heap_free(egl_configs);
+        heap_free(pixel_formats);
+        ERR("eglGetConfigs returned no configs\n");
+        return FALSE;
+    }
+
+    /* Use two passes: the first pass adds the onscreen formats to the format list,
+     * the second offscreen ones. */
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_SURFACE_TYPE, &type);
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_COLOR_BUFFER_TYPE, &color);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RED_SIZE, &r);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_GREEN_SIZE, &g);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_BLUE_SIZE, &b);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_DEPTH_SIZE, &d);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_STENCIL_SIZE, &s);
+
+            /* Some drivers expose 10 bit components which are not typically what
+             * applications want. */
+            if (r > 8 || g > 8 || b > 8) continue;
+
+            pixel_formats[nb_pixel_formats++].config = egl_configs[i];
+            TRACE("%u: config %u id %u type %x visual %u native %u render %x "
+                  "colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render,
+                   color, r, g, b, d, s);
+        }
+        if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
+    }
+
+    heap_free(egl_configs);
+
+    return TRUE;
+}
+
 static BOOL egl_init(void)
 {
     static int retval = -1;
@@ -413,6 +480,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglGetConfigAttrib);
+    LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
@@ -422,6 +491,8 @@ static BOOL egl_init(void)
     if (!p_eglInitialize(egl_display, &major, &minor)) return FALSE;
     TRACE("display %p version %u.%u\n", egl_display, major, minor);
 
+    if (!init_pixel_formats()) return FALSE;
+
     init_extensions();
     retval = 1;
     return TRUE;
-- 
2.33.0


From 1a6b2719365f143127471ea2ac3cc2d9d46d2118 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:32:28 +0300
Subject: [PATCH 061/125] winewayland.drv: Implement wglDescribePixelFormat

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 54 +++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index dbf988b920d..81ba3746f2b 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -63,6 +63,59 @@ DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+static inline BOOL is_onscreen_pixel_format(int format)
+{
+    return format > 0 && format <= nb_onscreen_formats;
+}
+
+/***********************************************************************
+ *		wayland_wglDescribePixelFormat
+ */
+static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
+                                                 PIXELFORMATDESCRIPTOR *pfd)
+{
+    EGLint val;
+    EGLConfig config;
+
+    if (!pfd) return nb_onscreen_formats;
+    if (!is_onscreen_pixel_format(fmt)) return 0;
+    if (size < sizeof(*pfd)) return 0;
+    config = pixel_formats[fmt - 1].config;
+
+    memset(pfd, 0, sizeof(*pfd));
+    pfd->nSize = sizeof(*pfd);
+    pfd->nVersion = 1;
+    pfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
+                   PFD_SUPPORT_COMPOSITION;
+    pfd->iPixelType = PFD_TYPE_RGBA;
+    pfd->iLayerType = PFD_MAIN_PLANE;
+
+    p_eglGetConfigAttrib(egl_display, config, EGL_BUFFER_SIZE, &val);
+    pfd->cColorBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_RED_SIZE, &val);
+    pfd->cRedBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_GREEN_SIZE, &val);
+    pfd->cGreenBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_BLUE_SIZE, &val);
+    pfd->cBlueBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_ALPHA_SIZE, &val);
+    pfd->cAlphaBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_DEPTH_SIZE, &val);
+    pfd->cDepthBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_STENCIL_SIZE, &val);
+    pfd->cStencilBits = val;
+
+    pfd->cAlphaShift = 0;
+    pfd->cBlueShift = pfd->cAlphaShift + pfd->cAlphaBits;
+    pfd->cGreenShift = pfd->cBlueShift + pfd->cBlueBits;
+    pfd->cRedShift = pfd->cGreenShift + pfd->cGreenBits;
+
+    TRACE("fmt %u color %u %u/%u/%u/%u depth %u stencil %u\n",
+           fmt, pfd->cColorBits, pfd->cRedBits, pfd->cGreenBits, pfd->cBlueBits,
+           pfd->cAlphaBits, pfd->cDepthBits, pfd->cStencilBits);
+    return nb_onscreen_formats;
+}
+
 /***********************************************************************
  *		wayland_wglGetProcAddress
  */
@@ -515,6 +568,7 @@ static struct opengl_funcs egl_funcs =
 {
     .wgl =
     {
+        .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.33.0


From 971d5f77996d41d4584db58038748369ecd73e03 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:19:52 +0300
Subject: [PATCH 062/125] winewayland.drv: Introduce facility to associated an
 EGL surface with a window

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 102 ++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |   2 +
 dlls/winewayland.drv/window.c     |   4 +-
 3 files changed, 106 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 81ba3746f2b..e3df887cd0f 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -37,6 +37,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 #include <EGL/egl.h>
 #include <assert.h>
 
@@ -47,6 +49,15 @@ struct wgl_pixel_format
     EGLConfig config;
 };
 
+struct wayland_gl_drawable
+{
+    struct wl_list  link;
+    HWND            hwnd;
+    int             format;
+    struct wayland_surface  *wayland_surface;
+    EGLSurface      surface;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
@@ -55,7 +66,21 @@ static struct opengl_funcs egl_funcs;
 static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
 
+static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+
+/* Protects drawables and contexts. */
+static CRITICAL_SECTION drawable_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &drawable_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": drawable_section") }
+};
+static CRITICAL_SECTION drawable_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroySurface);
 DECL_FUNCPTR(eglGetConfigAttrib);
 DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
@@ -68,6 +93,81 @@ static inline BOOL is_onscreen_pixel_format(int format)
     return format > 0 && format <= nb_onscreen_formats;
 }
 
+static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int format)
+{
+    struct wayland_gl_drawable *gl = heap_alloc(sizeof(*gl));
+    struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p wayland_surface=%p\n", hwnd, wayland_surface);
+
+    if (wayland_surface)
+    {
+        BOOL ref_gl = wayland_surface_create_or_ref_gl(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_gl) return NULL;
+    }
+
+    gl->hwnd   = hwnd;
+    gl->format = format;
+    gl->wayland_surface = wayland_surface;
+    gl->surface = 0;
+
+    EnterCriticalSection(&drawable_section);
+    wl_list_insert(&gl_drawables, &gl->link);
+    return gl;
+}
+
+static void wayland_destroy_gl_drawable(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    EnterCriticalSection(&drawable_section);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd != hwnd) continue;
+        wl_list_remove(&gl->link);
+        if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+        heap_free(gl);
+        break;
+    }
+    LeaveCriticalSection(&drawable_section);
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_get(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    if (!hwnd) return NULL;
+
+    EnterCriticalSection(&drawable_section);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd == hwnd) return gl;
+    }
+    LeaveCriticalSection(&drawable_section);
+    return NULL;
+}
+
+static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
+{
+    if (gl) LeaveCriticalSection(&drawable_section);
+}
+
+static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
+{
+    TRACE("hwnd=%p\n", gl->hwnd);
+
+    if (gl->surface || !gl->wayland_surface) goto out;
+
+    gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
+                                           gl->wayland_surface->glvk->wl_egl_window, NULL);
+
+out:
+    RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -533,6 +633,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroySurface);
     LOAD_FUNCPTR(eglGetConfigAttrib);
     LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 908530b150b..51dd13a07a9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -323,6 +323,8 @@ void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, in
                                       int width, int height);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd);
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
                                       double wayland_x, double wayland_y,
                                       int *screen_x, int *screen_y);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 31e15376c9b..58897fb0caa 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -169,7 +169,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
  *
  *  Gets the wayland surface for HWND while locking the private window data.
  */
-static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
 {
     struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
@@ -184,7 +184,7 @@ static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
 /***********************************************************************
  *           wayland_surface_for_hwnd_unlock
  */
-static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
 {
     if (surface) LeaveCriticalSection(&win_data_section);
 }
-- 
2.33.0


From 17104668550a6384992defe1de1ce6f34f3f6b2f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:20:22 +0300
Subject: [PATCH 063/125] winewayland.drv: Implement wglSetPixelFormat(WINE)

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 65 +++++++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index e3df887cd0f..c4e76c1a3e9 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -168,6 +168,46 @@ out:
     RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
 }
 
+static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
+{
+    struct wayland_gl_drawable *gl;
+    HWND hwnd = WindowFromDC(hdc);
+    int prev = 0;
+
+    if (!hwnd || hwnd == GetDesktopWindow())
+    {
+        WARN("not a proper window DC %p/%p\n", hdc, hwnd);
+        return FALSE;
+    }
+    if (!is_onscreen_pixel_format(format))
+    {
+        WARN("Invalid format %d\n", format);
+        return FALSE;
+    }
+    TRACE("%p/%p format %d\n", hdc, hwnd, format);
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        prev = gl->format;
+        if (allow_change)
+            gl->format = format;
+    }
+    else
+    {
+        gl = wayland_gl_drawable_create(hwnd, format);
+    }
+
+    if (gl) wayland_gl_drawable_update(gl);
+
+    wayland_gl_drawable_release(gl);
+
+    if (prev && prev != format && !allow_change) return FALSE;
+    if (__wine_set_pixel_format(hwnd, format)) return TRUE;
+
+    wayland_destroy_gl_drawable(hwnd);
+    return FALSE;
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -228,6 +268,23 @@ static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
     return ret;
 }
 
+/***********************************************************************
+ *		wayland_wglSetPixelFormat
+ */
+static BOOL WINAPI wayland_wglSetPixelFormat(HDC hdc, int format,
+                                             const PIXELFORMATDESCRIPTOR *pfd)
+{
+    return set_pixel_format(hdc, format, FALSE);
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormatWINE
+ */
+static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
+{
+    return set_pixel_format(hdc, format, TRUE);
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -265,6 +322,13 @@ static void init_extensions(void)
 
     register_extension("WGL_EXT_framebuffer_sRGB");
 
+    /* In WineD3D we need the ability to set the pixel format more than once
+     * (e.g. after a device reset).  The default wglSetPixelFormat doesn't
+     * allow this, so add our own which allows it.
+     */
+    register_extension("WGL_WINE_pixel_format_passthrough");
+    egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -672,6 +736,7 @@ static struct opengl_funcs egl_funcs =
     {
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.33.0


From 80e39de4f7931dddc4874e2f6d8d0901edd2ec43 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:44:37 +0300
Subject: [PATCH 064/125] winewayland.drv: Implement context creation

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 80 +++++++++++++++++++++++++++++++++++
 1 file changed, 80 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index c4e76c1a3e9..ef44bb5ee4b 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -58,6 +58,15 @@ struct wayland_gl_drawable
     EGLSurface      surface;
 };
 
+struct wgl_context
+{
+    struct wl_list link;
+    EGLConfig  config;
+    EGLContext context;
+    EGLSurface surface;
+    HWND       hwnd;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
@@ -67,6 +76,7 @@ static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
 
 static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+static struct wl_list gl_contexts = { &gl_contexts, &gl_contexts };
 
 /* Protects drawables and contexts. */
 static CRITICAL_SECTION drawable_section;
@@ -79,7 +89,10 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION drawable_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglBindAPI);
+DECL_FUNCPTR(eglCreateContext);
 DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroyContext);
 DECL_FUNCPTR(eglDestroySurface);
 DECL_FUNCPTR(eglGetConfigAttrib);
 DECL_FUNCPTR(eglGetConfigs);
@@ -208,6 +221,67 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     return FALSE;
 }
 
+static struct wgl_context *create_context(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    struct wgl_context *ctx;
+
+    if (!(gl = wayland_gl_drawable_get(WindowFromDC(hdc)))) return NULL;
+
+    ctx = heap_alloc(sizeof(*ctx));
+
+    ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->context = p_eglCreateContext(egl_display, ctx->config,
+                                      EGL_NO_CONTEXT,
+                                      NULL);
+    ctx->surface = 0;
+    ctx->hwnd = 0;
+
+    /* The drawable critical section also guards access to gl_contexts, so it's
+     * safe to add the entry here. */
+    wl_list_insert(&gl_contexts, &ctx->link);
+
+    wayland_gl_drawable_release(gl);
+
+    TRACE("ctx=%p hdc=%p fmt=%d egl_ctx=%p\n", ctx, hdc, gl->format, ctx->context);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglCopyContext
+ */
+static BOOL WINAPI wayland_wglCopyContext(struct wgl_context *src,
+                                          struct wgl_context *dst, UINT mask)
+{
+    FIXME("%p -> %p mask %#x unsupported\n", src, dst, mask);
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContext
+ */
+static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
+{
+    TRACE("hdc=%p\n", hdc);
+
+    p_eglBindAPI(EGL_OPENGL_API);
+
+    return create_context(hdc);
+}
+
+/***********************************************************************
+ *		wayland_wglDeleteContext
+ */
+static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
+{
+    EnterCriticalSection(&drawable_section);
+    wl_list_remove(&ctx->link);
+    LeaveCriticalSection(&drawable_section);
+    p_eglDestroyContext(egl_display, ctx->context);
+    return HeapFree(GetProcessHeap(), 0, ctx);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -697,7 +771,10 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglBindAPI);
+    LOAD_FUNCPTR(eglCreateContext);
     LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroyContext);
     LOAD_FUNCPTR(eglDestroySurface);
     LOAD_FUNCPTR(eglGetConfigAttrib);
     LOAD_FUNCPTR(eglGetConfigs);
@@ -734,6 +811,9 @@ static struct opengl_funcs egl_funcs =
 {
     .wgl =
     {
+        .p_wglCopyContext = wayland_wglCopyContext,
+        .p_wglCreateContext = wayland_wglCreateContext,
+        .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
-- 
2.33.0


From 9a7ef78a6674e68bc70beb5d1e3b31a4d7f7e7cf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:34:46 +0300
Subject: [PATCH 065/125] winewayland.drv: Implement wglMakeCurrent

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 85 +++++++++++++++++++++++++++++++++++
 1 file changed, 85 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index ef44bb5ee4b..8c3c987d837 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -38,6 +38,7 @@
 #include "wine/heap.h"
 
 #include "winuser.h"
+#include "winternl.h"
 
 #include <EGL/egl.h>
 #include <assert.h>
@@ -99,6 +100,7 @@ DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
+DECL_FUNCPTR(eglMakeCurrent);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -176,6 +178,20 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 
     gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
                                            gl->wayland_surface->glvk->wl_egl_window, NULL);
+    if (gl->surface)
+    {
+        struct wgl_context *ctx;
+
+        wl_list_for_each(ctx, &gl_contexts, link)
+        {
+            if (ctx->hwnd != gl->hwnd) continue;
+            TRACE("hwnd %p refreshing %p %scurrent\n",
+                  gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
+            ctx->surface = gl->surface;
+            if (NtCurrentTeb()->glContext == ctx)
+                p_eglMakeCurrent(egl_display, ctx->surface, ctx->surface, ctx->context);
+        }
+    }
 
 out:
     RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
@@ -282,6 +298,69 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     return HeapFree(GetProcessHeap(), 0, ctx);
 }
 
+/***********************************************************************
+ *		wayland_wglMakeContextCurrentARB
+ */
+static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
+                                             struct wgl_context *ctx)
+{
+    BOOL ret = FALSE;
+    struct wayland_gl_drawable *draw_gl = NULL, *read_gl = NULL;
+    EGLSurface draw_surface, read_surface;
+    HWND draw_hwnd;
+
+    TRACE("draw_hdc=%p read_hdc=%p ctx=%p\n", draw_hdc, read_hdc, ctx);
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    draw_hwnd = WindowFromDC(draw_hdc);
+    if ((draw_gl = wayland_gl_drawable_get(draw_hwnd)))
+    {
+        draw_surface = draw_gl->surface;
+
+        if (draw_hdc == read_hdc)
+        {
+            read_surface = draw_surface;
+        }
+        else
+        {
+            read_gl = wayland_gl_drawable_get(WindowFromDC(read_hdc));
+            read_surface = read_gl ? read_gl->surface : NULL;
+        }
+
+        TRACE("%p/%p context %p surface %p/%p\n",
+               draw_hdc, read_hdc, ctx->context, draw_surface, read_surface);
+
+        ret = p_eglMakeCurrent(egl_display, draw_surface, read_surface, ctx->context);
+        if (ret)
+        {
+            ctx->surface = draw_surface;
+            ctx->hwnd    = draw_hwnd;
+            NtCurrentTeb()->glContext = ctx;
+            goto done;
+        }
+    }
+    SetLastError(ERROR_INVALID_HANDLE);
+
+done:
+    wayland_gl_drawable_release(read_gl);
+    wayland_gl_drawable_release(draw_gl);
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeCurrent
+ */
+static BOOL WINAPI wayland_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+{
+    return wayland_wglMakeContextCurrentARB(hdc, hdc, ctx);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -403,6 +482,10 @@ static void init_extensions(void)
     register_extension("WGL_WINE_pixel_format_passthrough");
     egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
 
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -781,6 +864,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
+    LOAD_FUNCPTR(eglMakeCurrent);
 #undef LOAD_FUNCPTR
 
     egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
@@ -816,6 +900,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.33.0


From 6adbd3211b71b68af07245151a5cb80e85bb5e05 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:46:40 +0300
Subject: [PATCH 066/125] winewayland.drv: Implement wglGetPixelFormat

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 8c3c987d837..4231722cf1f 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -409,6 +409,24 @@ static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
     return nb_onscreen_formats;
 }
 
+/***********************************************************************
+ *		wayland_wglGetPixelFormat
+ */
+static int WINAPI wayland_wglGetPixelFormat(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    int ret = 0;
+
+    if ((gl = wayland_gl_drawable_get(WindowFromDC(hdc))))
+    {
+        ret = gl->format;
+        /* offscreen formats can't be used with traditional WGL calls */
+        if (!is_onscreen_pixel_format(ret)) ret = 1;
+        wayland_gl_drawable_release(gl);
+    }
+    return ret;
+}
+
 /***********************************************************************
  *		wayland_wglGetProcAddress
  */
@@ -899,6 +917,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglCreateContext = wayland_wglCreateContext,
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
+        .p_wglGetPixelFormat = wayland_wglGetPixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
-- 
2.33.0


From 76c0614d152d067e8ad9d5a0d4a507c429cc2e8d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:56:36 +0300
Subject: [PATCH 067/125] winewayland.drv: Implement wglCreateContextAttribsARB

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 142 +++++++++++++++++++++++++++++++++-
 1 file changed, 138 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 4231722cf1f..a195fe0e4bf 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -66,6 +66,7 @@ struct wgl_context
     EGLContext context;
     EGLSurface surface;
     HWND       hwnd;
+    int        *attribs;
 };
 
 static void *egl_handle;
@@ -237,7 +238,66 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     return FALSE;
 }
 
-static struct wgl_context *create_context(HDC hdc)
+struct egl_attribs
+{
+    EGLint *data;
+    int count;
+};
+
+static void egl_attribs_init(struct egl_attribs *attribs)
+{
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static void egl_attribs_add(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    EGLint *new_data = heap_realloc(attribs->data,
+                                    sizeof(*attribs->data) * (attribs->count + 2));
+    if (!new_data)
+    {
+        ERR("Could not allocate memory for EGL attributes!\n");
+        return;
+    }
+
+    attribs->data = new_data;
+    attribs->data[attribs->count] = name;
+    attribs->data[attribs->count + 1] = value;
+    attribs->count += 2;
+}
+
+static EGLint *egl_attribs_steal_finished_data(struct egl_attribs *attribs)
+{
+    EGLint *data = NULL;
+
+    if (attribs->data)
+    {
+        data = heap_realloc(attribs->data,
+                            sizeof(*attribs->data) * (attribs->count + 1));
+        if (!data)
+        {
+            ERR("Could not allocate memory for EGL attributes!\n");
+        }
+        else
+        {
+            data[attribs->count] = EGL_NONE;
+            attribs->data = NULL;
+            attribs->count = 0;
+        }
+    }
+
+    return data;
+}
+
+static void egl_attribs_deinit(struct egl_attribs *attribs)
+{
+    heap_free(attribs->data);
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
+                                          struct egl_attribs *attribs)
 {
     struct wayland_gl_drawable *gl;
     struct wgl_context *ctx;
@@ -247,9 +307,10 @@ static struct wgl_context *create_context(HDC hdc)
     ctx = heap_alloc(sizeof(*ctx));
 
     ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->attribs = attribs ? egl_attribs_steal_finished_data(attribs) : NULL;
     ctx->context = p_eglCreateContext(egl_display, ctx->config,
-                                      EGL_NO_CONTEXT,
-                                      NULL);
+                                      share ? share->context : EGL_NO_CONTEXT,
+                                      ctx->attribs);
     ctx->surface = 0;
     ctx->hwnd = 0;
 
@@ -283,7 +344,75 @@ static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
 
     p_eglBindAPI(EGL_OPENGL_API);
 
-    return create_context(hdc);
+    return create_context(hdc, NULL, NULL);
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContextAttribsARB
+ */
+static struct wgl_context *wayland_wglCreateContextAttribsARB(HDC hdc,
+                                                              struct wgl_context *share,
+                                                              const int *attribs)
+{
+    struct egl_attribs egl_attribs = {0};
+    EGLenum api_type = EGL_OPENGL_API;
+    EGLenum profile_mask;
+    struct wgl_context *ctx;
+
+    egl_attribs_init(&egl_attribs);
+
+    TRACE("hdc=%p share=%p attribs=%p\n", hdc, share, attribs);
+
+    while (attribs && *attribs)
+    {
+        TRACE("%#x %#x\n", attribs[0], attribs[1]);
+        switch (*attribs)
+        {
+        case WGL_CONTEXT_PROFILE_MASK_ARB:
+            profile_mask = 0;
+            if (attribs[1] & WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+                api_type = EGL_OPENGL_ES_API;
+            if (attribs[1] & WGL_CONTEXT_CORE_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT;
+            if (attribs[1] & WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT;
+            /* If the WGL profile mask doesn't have ES2 as the only set bit,
+             * pass the mask to EGL. Note that this will also pass empty
+             * WGL masks, in order to elicit the respective EGL error. */
+            if (attribs[1] != WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+            {
+                egl_attribs_add(&egl_attribs,
+                                EGL_CONTEXT_OPENGL_PROFILE_MASK, profile_mask);
+            }
+            break;
+        case WGL_CONTEXT_MAJOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MAJOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_MINOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MINOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_FLAGS_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_OPENGL_DEBUG,
+                            (attribs[1] & WGL_CONTEXT_DEBUG_BIT_ARB) ?
+                                EGL_TRUE : EGL_FALSE);
+            egl_attribs_add(&egl_attribs,
+                            EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE,
+                            (attribs[1] & WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB) ?
+                                EGL_TRUE : EGL_FALSE);
+            break;
+        default:
+            FIXME("Unhandled attributes: %#x %#x\n", attribs[0], attribs[1]);
+        }
+        attribs += 2;
+    }
+
+    p_eglBindAPI(api_type);
+
+    ctx = create_context(hdc, share, &egl_attribs);
+
+    egl_attribs_deinit(&egl_attribs);
+
+    return ctx;
 }
 
 /***********************************************************************
@@ -295,6 +424,7 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     wl_list_remove(&ctx->link);
     LeaveCriticalSection(&drawable_section);
     p_eglDestroyContext(egl_display, ctx->context);
+    heap_free(ctx->attribs);
     return HeapFree(GetProcessHeap(), 0, ctx);
 }
 
@@ -504,6 +634,10 @@ static void init_extensions(void)
     egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
     egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
 
+    register_extension("WGL_ARB_create_context");
+    register_extension("WGL_ARB_create_context_profile");
+    egl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
-- 
2.33.0


From 1fc2aa16ca45c21a03603995a92e6b9f269df00b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:57:55 +0300
Subject: [PATCH 068/125] winewayland.drv: Implement wglShareLists

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 51 +++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index a195fe0e4bf..50f457daf1e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -66,6 +66,8 @@ struct wgl_context
     EGLContext context;
     EGLSurface surface;
     HWND       hwnd;
+    BOOL       has_been_current;
+    BOOL       sharing;
     int        *attribs;
 };
 
@@ -313,6 +315,8 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
                                       ctx->attribs);
     ctx->surface = 0;
     ctx->hwnd = 0;
+    ctx->has_been_current = FALSE;
+    ctx->sharing = FALSE;
 
     /* The drawable critical section also guards access to gl_contexts, so it's
      * safe to add the entry here. */
@@ -471,6 +475,7 @@ static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
         {
             ctx->surface = draw_surface;
             ctx->hwnd    = draw_hwnd;
+            ctx->has_been_current = TRUE;
             NtCurrentTeb()->glContext = ctx;
             goto done;
         }
@@ -586,6 +591,51 @@ static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
     return set_pixel_format(hdc, format, TRUE);
 }
 
+/***********************************************************************
+ *		wayland_wglShareLists
+ */
+static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
+                                         struct wgl_context *dest)
+{
+    TRACE("(%p, %p)\n", org, dest);
+
+    /* Sharing of display lists works differently in EGL and WGL. In case of
+     * EGL it is done at context creation time but in case of EGL it can also
+     * be done using wglShareLists.
+     *
+     * We handle this by creating an EGL context in wglCreateContext /
+     * wglCreateContextAttribsARB and when a program requests sharing we
+     * recreate the destination context if it hasn't been made current and
+     * it hasn't shared display lists before.
+     */
+
+    if (dest->has_been_current)
+    {
+        ERR("Could not share display lists, the hglrc2 context has been current already!\n");
+        return FALSE;
+    }
+    else if (dest->sharing)
+    {
+        ERR("Could not share display lists because hglrc2 has already shared lists before!\n");
+        return FALSE;
+    }
+    else
+    {
+        /* Re-create the EGL context and share display lists */
+        p_eglDestroyContext(egl_display, dest->context);
+        dest->context = p_eglCreateContext(egl_display, dest->config,
+                                           org->context, dest->attribs);
+        TRACE("re-created EGL context (%p) for WGL context %p (config: %p) "
+              "sharing lists with EGL context %p for WGL context %p (config: %p)\n",
+              dest->context, dest, dest->config, org->context, org, org->config);
+        org->sharing = TRUE;
+        dest->sharing = TRUE;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1055,6 +1105,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
+        .p_wglShareLists = wayland_wglShareLists,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.33.0


From 70c4d5a4914171785ceeed7a388291d3a29e174b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:25:18 +0300
Subject: [PATCH 069/125] winewayland.drv: Add function to ensure wayland
 surface is mapped

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 74 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 75 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index ae3995d0225..726a447b1e9 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -977,6 +977,80 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                    wine_width, wine_height);
 }
 
+static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    wayland_shm_buffer_destroy(shm_buffer);
+}
+
+static const struct wl_buffer_listener dummy_buffer_listener = {
+    dummy_buffer_release
+};
+
+/**********************************************************************
+ *          wayland_surface_ensure_mapped
+ *
+ * Ensure that the wayland surface is mapped, by committing a dummy
+ * buffer if necessary.
+ *
+ * The contents of GL or Vulkan windows are rendered on subsurfaces
+ * with the parent surface used for the decorations. Such GL/VK
+ * subsurfaces may want to commit their contents before the parent
+ * surface has had a chance to commit. In such cases the GL/VK commit
+ * will not be displayed, but, more importantly, will not get a frame
+ * callback until the parent surface is also committed. Depending on
+ * the presentation mode, a second GL/VK buffer swap may indefinitely
+ * block waiting on the frame callback. By calling this function before a
+ * GL/VK buffer swap we can avoid this situation.
+ */
+void wayland_surface_ensure_mapped(struct wayland_surface *surface)
+{
+    EnterCriticalSection(&surface->crit);
+
+    TRACE("surface=%p hwnd=%p mapped=%d\n",
+          surface, surface->hwnd, surface->mapped);
+
+    if (!surface->mapped)
+    {
+        int width = surface->current.width;
+        int height = surface->current.height;
+        int flags = surface->current.configure_flags;
+        int wine_width, wine_height;
+        struct wayland_shm_buffer *dummy_shm_buffer;
+
+        /* Use a large enough width/height, so even when the target
+         * surface is scaled by the compositor, this will not end up
+         * being 0x0. */
+        if (width == 0) width = 32;
+        if (height == 0) height = 32;
+
+        if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+            !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        {
+            wayland_surface_find_wine_fullscreen_fit(surface, width, height,
+                                                     &wine_width, &wine_height);
+        }
+        else
+        {
+            wayland_surface_coords_to_wine(surface, width, height,
+                                           &wine_width, &wine_height);
+        }
+
+        dummy_shm_buffer = wayland_shm_buffer_create(surface->wayland,
+                                                     wine_width, wine_height,
+                                                     WL_SHM_FORMAT_ARGB8888);
+        wl_buffer_add_listener(dummy_shm_buffer->wl_buffer,
+                               &dummy_buffer_listener, dummy_shm_buffer);
+
+        wayland_surface_commit_buffer(surface, dummy_shm_buffer, NULL);
+    }
+
+    LeaveCriticalSection(&surface->crit);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 51dd13a07a9..b863d2b701e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -340,6 +340,7 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
 void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                               int wayland_width, int wayland_height,
                                               int *wine_width, int *wine_height);
+void wayland_surface_ensure_mapped(struct wayland_surface *surface);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 void wayland_surface_set_main_output(struct wayland_surface *surface,
-- 
2.33.0


From 573b860eb5266c5a68c72b27641dd7e7cab0291d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:26:32 +0300
Subject: [PATCH 070/125] winewayland.drv: Implement wglSwapBuffers

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 56 +++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 50f457daf1e..5cd69423e18 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -66,6 +66,7 @@ struct wgl_context
     EGLContext context;
     EGLSurface surface;
     HWND       hwnd;
+    BOOL       refresh;
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
@@ -104,6 +105,7 @@ DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 DECL_FUNCPTR(eglMakeCurrent);
+DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -193,6 +195,8 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
             ctx->surface = gl->surface;
             if (NtCurrentTeb()->glContext == ctx)
                 p_eglMakeCurrent(egl_display, ctx->surface, ctx->surface, ctx->context);
+            else
+                InterlockedExchange(&ctx->refresh, TRUE);
         }
     }
 
@@ -315,6 +319,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
                                       ctx->attribs);
     ctx->surface = 0;
     ctx->hwnd = 0;
+    ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
 
@@ -474,6 +479,7 @@ static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
         if (ret)
         {
             ctx->surface = draw_surface;
+            ctx->refresh = FALSE;
             ctx->hwnd    = draw_hwnd;
             ctx->has_been_current = TRUE;
             NtCurrentTeb()->glContext = ctx;
@@ -636,6 +642,54 @@ static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
     return FALSE;
 }
 
+static BOOL refresh_context(struct wgl_context *ctx)
+{
+    BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
+
+    if (ret)
+    {
+        TRACE("refreshing hwnd %p context %p surface %p\n",
+              ctx->hwnd, ctx->context, ctx->surface);
+        p_eglMakeCurrent(egl_display, ctx->surface, ctx->surface, ctx->context);
+        RedrawWindow(ctx->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+    }
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglSwapBuffers
+ */
+static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return FALSE;
+
+    TRACE("%p hwnd %p context %p surface %p\n", hdc, ctx->hwnd, ctx->context, ctx->surface);
+
+    if (refresh_context(ctx)) return TRUE;
+
+    if (ctx->surface)
+    {
+        struct wayland_gl_drawable *gl_drawable = wayland_gl_drawable_get(WindowFromDC(hdc));
+        BOOL drawing_allowed = TRUE;
+        if (gl_drawable)
+        {
+            if (gl_drawable->wayland_surface)
+            {
+                wayland_surface_ensure_mapped(gl_drawable->wayland_surface);
+                drawing_allowed =
+                    wayland_surface_is_drawing_allowed(gl_drawable->wayland_surface);
+            }
+            wayland_gl_drawable_release(gl_drawable);
+        }
+        if (drawing_allowed) p_eglSwapBuffers(egl_display, ctx->surface);
+    }
+
+    return TRUE;
+}
+
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1067,6 +1121,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
     LOAD_FUNCPTR(eglMakeCurrent);
+    LOAD_FUNCPTR(eglSwapBuffers);
 #undef LOAD_FUNCPTR
 
     egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
@@ -1106,6 +1161,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
         .p_wglShareLists = wayland_wglShareLists,
+        .p_wglSwapBuffers = wayland_wglSwapBuffers,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.33.0


From a0aa7b8e5d048ba2b8a0237b1ada3041f225071d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:31:10 +0300
Subject: [PATCH 071/125] winewayland.drv: Refresh the context on glFlush and
 glFinish

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 5cd69423e18..b399591cd00 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -108,6 +108,9 @@ DECL_FUNCPTR(eglMakeCurrent);
 DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
+static void (*p_glFinish)(void);
+static void (*p_glFlush)(void);
+
 static inline BOOL is_onscreen_pixel_format(int format)
 {
     return format > 0 && format <= nb_onscreen_formats;
@@ -689,6 +692,24 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
     return TRUE;
 }
 
+static void wayland_glFinish(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->hwnd, ctx->context);
+    refresh_context(ctx);
+    p_glFinish();
+}
+
+static void wayland_glFlush(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    refresh_context(ctx);
+    p_glFlush();
+}
 
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
@@ -1023,6 +1044,14 @@ static void init_extensions(void)
     LOAD_FUNCPTR(glVertexBindingDivisor);
     LOAD_FUNCPTR(glWaitSync);
 #undef LOAD_FUNCPTR
+
+    /* Redirect some standard OpenGL functions. */
+
+#define REDIRECT(func) \
+    do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glFinish);
+    REDIRECT(glFlush);
+#undef REDIRECT
 }
 
 static BOOL init_pixel_formats(void)
-- 
2.33.0


From bfaad27c0fb4ae1091605d5f846acdb4aec2146c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:41:51 +0300
Subject: [PATCH 072/125] winewayland.drv: Enable OpenGL support

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/gdi.c        | 16 ++++++++++++++++
 dlls/winewayland.drv/opengl.c     | 31 ++++++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h |  9 +++++++++
 dlls/winewayland.drv/window.c     |  6 +++++-
 4 files changed, 60 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
index a26f09ad866..4223cb98ed2 100644
--- a/dlls/winewayland.drv/gdi.c
+++ b/dlls/winewayland.drv/gdi.c
@@ -89,12 +89,28 @@ static BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
     return TRUE;
 }
 
+/**********************************************************************
+ *           WAYLAND_wine_get_wgl_driver
+ */
+static struct opengl_funcs * CDECL WAYLAND_wine_get_wgl_driver(PHYSDEV dev, UINT version)
+{
+    struct opengl_funcs *ret;
+
+    if (!(ret = wayland_get_wgl_driver(version)))
+    {
+        dev = GET_NEXT_PHYSDEV(dev, wine_get_wgl_driver);
+        ret = dev->funcs->wine_get_wgl_driver(dev, version);
+    }
+
+    return ret;
+}
 
 static const struct gdi_dc_funcs wayland_gdi_dc_funcs =
 {
     .pCreateDC = WAYLAND_CreateDC,
     .pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
     .pDeleteDC = WAYLAND_DeleteDC,
+    .wine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
     .priority = GDI_PRIORITY_GRAPHICS_DRV
 };
 
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b399591cd00..6942e48a704 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -140,7 +140,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     return gl;
 }
 
-static void wayland_destroy_gl_drawable(HWND hwnd)
+void wayland_destroy_gl_drawable(HWND hwnd)
 {
     struct wayland_gl_drawable *gl;
 
@@ -1208,3 +1208,32 @@ struct opengl_funcs *wayland_get_wgl_driver(UINT version)
     if (!egl_init()) return NULL;
     return &egl_funcs;
 }
+
+/***********************************************************************
+ *		wayland_update_gl_drawable_surface
+ */
+void wayland_update_gl_drawable_surface(HWND hwnd,
+                                        struct wayland_surface *wayland_surface)
+{
+    struct wayland_gl_drawable *gl;
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        if (gl->surface)
+        {
+            p_eglDestroySurface(egl_display, gl->surface);
+            gl->surface = EGL_NO_SURFACE;
+        }
+
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+
+        gl->wayland_surface = wayland_surface;
+        if (gl->wayland_surface)
+            wayland_surface_create_or_ref_gl(gl->wayland_surface);
+
+        wayland_gl_drawable_update(gl);
+
+        wayland_gl_drawable_release(gl);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b863d2b701e..66f500ce04a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -401,6 +401,15 @@ void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor);
 BOOL wayland_init_set_cursor(void);
 void wayland_invalidate_set_cursor(void);
 
+/**********************************************************************
+ *          OpenGL support
+ */
+
+struct opengl_funcs *wayland_get_wgl_driver(UINT version);
+void wayland_update_gl_drawable_surface(HWND hwnd,
+                                        struct wayland_surface *wayland_surface);
+void wayland_destroy_gl_drawable(HWND hwnd);
+
 /**********************************************************************
  *          XKB helpers
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 58897fb0caa..2a18d18cf5a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -325,7 +325,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     /* Only create wayland surfaces for toplevel windows. Let Wine core handle
      * the drawing of other windows in their corresponding top level window
      * surface. */
-    if (data->parent) return;
+    if (data->parent) goto out;
 
     effective_parent_hwnd = wayland_win_data_get_effective_parent(data);
     parent_surface = NULL;
@@ -352,6 +352,9 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     if (data->wayland_surface)
         data->wayland_surface->hwnd = data->hwnd;
+
+out:
+    wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
 }
 
 static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
@@ -583,6 +586,7 @@ void CDECL WAYLAND_DestroyWindow(HWND hwnd)
     TRACE("%p\n", hwnd);
 
     if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_destroy_gl_drawable(hwnd);
     wayland_win_data_destroy(data);
 }
 
-- 
2.33.0


From 731020f7e4a1a14e8be7f841016d6a4abb718978 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:06:08 +0300
Subject: [PATCH 073/125] winewayland.drv: Support front buffer rendering in
 window surfaces

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h     |  6 ++
 dlls/winewayland.drv/window.c         | 28 +++++++++
 dlls/winewayland.drv/window_surface.c | 90 +++++++++++++++++++++++++++
 3 files changed, 124 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 66f500ce04a..da1feae5bea 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -380,6 +380,9 @@ void wayland_window_surface_set_window_region(struct window_surface *window_surf
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
                                            COLORREF color_key, BYTE alpha,
                                            BOOL src_alpha);
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height));
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -409,6 +412,9 @@ struct opengl_funcs *wayland_get_wgl_driver(UINT version);
 void wayland_update_gl_drawable_surface(HWND hwnd,
                                         struct wayland_surface *wayland_surface);
 void wayland_destroy_gl_drawable(HWND hwnd);
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height));
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2a18d18cf5a..8d72d3cffa2 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1258,3 +1258,31 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     return 0;
 }
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 34c83c057c5..f7855f32f2e 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -52,6 +52,8 @@ struct wayland_window_surface
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_missing_wayland;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
     BITMAPINFO            info;
 };
 
@@ -272,6 +274,27 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         }
     }
 
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * TODO: Improve damage tracking and try to avoid unnecessary copying. */
+    if (wws->front_bits)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                SetRectRgn(surface_damage_region,
+                           wws->header.rect.left, wws->header.rect.top,
+                           wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = CreateRectRgnIndirect(&wws->header.rect);
+            }
+        }
+    }
+
     if (needs_flush &&
         (!wws->wayland_surface || !wws->wayland_buffer_queue ||
          !wayland_surface_is_drawing_allowed(wws->wayland_surface)))
@@ -299,6 +322,30 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
     buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
+    /* Copy the whole front buffer to wayland SHM buffer. */
+    if (wws->front_bits)
+    {
+        int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+        int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+        int stride = width * 4;
+        unsigned char *src = wws->front_bits;
+        unsigned char *dst = buffer->map_data;
+        int src_stride = wws->info.bmiHeader.biWidth * 4;
+        int dst_stride = buffer->width * 4;
+        int i;
+
+        TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+        /* Front buffer lines are stored bottom to top, so we need to flip
+         * when copying to our buffer. */
+        for (i = 0; i < height; i++)
+        {
+            memcpy(dst + (height - i - 1) * dst_stride,
+                   src + i * src_stride,
+                   stride);
+        }
+    }
+
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
 
@@ -383,6 +430,7 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     wayland_shm_buffer_clear_damage(buffer);
 
     heap_free(buffer_damage);
+    wws->front_bits_dirty = FALSE;
 
 done:
     if (surface_damage_region) DeleteObject(surface_damage_region);
@@ -405,6 +453,7 @@ static void CDECL wayland_window_surface_destroy(struct window_surface *window_s
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     heap_free(wws->bits);
+    heap_free(wws->front_bits);
     heap_free(wws);
 }
 
@@ -451,6 +500,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->color_key    = color_key;
     wws->alpha        = alpha;
     wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -526,3 +577,42 @@ void wayland_window_surface_update_layered(struct window_surface *window_surface
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd %p front_bits %p %dx%d\n", wws->hwnd, wws->front_bits,
+          wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        heap_free(wws->front_bits);
+        wws->front_bits_dirty = FALSE;
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = heap_alloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.33.0


From cd4504395f202b60ff395e605be938455003c489 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:34:39 +0300
Subject: [PATCH 074/125] winewayland.drv: Support front buffer rendering in
 OpenGL

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 65 +++++++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 6942e48a704..e4e4708c334 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -70,6 +70,7 @@ struct wgl_context
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
+    BOOL       is_draw_buffer_front;
 };
 
 static void *egl_handle;
@@ -110,6 +111,7 @@ DECL_FUNCPTR(eglSwapBuffers);
 
 static void (*p_glFinish)(void);
 static void (*p_glFlush)(void);
+static void (*p_glDrawBuffer)(GLenum);
 
 static inline BOOL is_onscreen_pixel_format(int format)
 {
@@ -325,6 +327,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
     ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
+    ctx->is_draw_buffer_front = FALSE;
 
     /* The drawable critical section also guards access to gl_contexts, so it's
      * safe to add the entry here. */
@@ -692,6 +695,16 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
     return TRUE;
 }
 
+static void wayland_glDrawBuffer(GLenum mode)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p mode 0x%x\n", ctx->hwnd, ctx->context, mode);
+    ctx->is_draw_buffer_front = (mode == GL_FRONT || mode == GL_FRONT_LEFT);
+    p_glDrawBuffer(mode);
+}
+
 static void wayland_glFinish(void)
 {
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
@@ -702,6 +715,51 @@ static void wayland_glFinish(void)
     p_glFinish();
 }
 
+static void read_front_buffer_pixels(void *pixels_out, int width, int height)
+{
+    GLenum prev_read_buffer;
+    GLint prev_read_framebuffer;
+    GLint prev_row_length;
+    GLint prev_image_height;
+    GLint prev_skip_rows;
+    GLint prev_skip_pixels;
+    GLint prev_skip_images;
+    GLint prev_alignment;
+
+    /* Store state we might change */
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_BUFFER, (GLint*)&prev_read_buffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &prev_read_framebuffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ROW_LENGTH, &prev_row_length);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_IMAGE_HEIGHT, &prev_image_height);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_ROWS, &prev_skip_rows);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_PIXELS, &prev_skip_pixels);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_IMAGES, &prev_skip_images);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ALIGNMENT, &prev_alignment);
+
+    /* Set state we need for reading the pixels */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+    egl_funcs.gl.p_glReadBuffer(GL_FRONT);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    egl_funcs.gl.p_glReadPixels(0, 0, width, height, GL_BGRA,  GL_UNSIGNED_BYTE,
+                                pixels_out);
+
+    /* Restore prev state */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, prev_read_framebuffer);
+    egl_funcs.gl.p_glReadBuffer(prev_read_buffer);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, prev_row_length);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, prev_image_height);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, prev_skip_rows);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, prev_skip_pixels);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, prev_skip_images);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, prev_alignment);
+}
+
 static void wayland_glFlush(void)
 {
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
@@ -709,6 +767,12 @@ static void wayland_glFlush(void)
     if (!ctx) return;
     refresh_context(ctx);
     p_glFlush();
+
+    /* Mesa Wayland EGL, and Wayland in general, doesn't support front buffer
+     * rendering. Emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->hwnd, read_front_buffer_pixels);
 }
 
 /***********************************************************************
@@ -1049,6 +1113,7 @@ static void init_extensions(void)
 
 #define REDIRECT(func) \
     do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glDrawBuffer);
     REDIRECT(glFinish);
     REDIRECT(glFlush);
 #undef REDIRECT
-- 
2.33.0


From 753cb846dbb7eca9bc1544225a01da18ba915406 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 15:40:50 +0300
Subject: [PATCH 075/125] winewayland.drv: Support setting pointer to relative
 event mode

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/wayland.c         |  8 +++
 dlls/winewayland.drv/wayland_pointer.c | 80 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  4 ++
 4 files changed, 93 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 35400e11588..3f8a72bf08f 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -30,6 +30,7 @@ C_SRCS = \
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 6fd90ecfb41..df30f7063cf 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -144,6 +144,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         if (!wayland_output_create(wayland, id, version))
             ERR("Failed to create wayland_output for global id=%u\n", id);
     }
+    else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
+    {
+        wayland->zwp_relative_pointer_manager_v1 =
+            wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
+    }
     else if (strcmp(interface, "zxdg_output_manager_v1") == 0)
     {
         struct wayland_output *output;
@@ -307,6 +312,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
+    if (wayland->zwp_relative_pointer_manager_v1)
+        zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
+
     if (wayland->wp_viewporter)
         wp_viewporter_destroy(wayland->wp_viewporter);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 3791bc54f59..eb2cffc6e69 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -70,6 +70,12 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
 static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
                                   uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
 {
+    struct wayland *wayland = data;
+
+    /* Don't handle absolute motion events if we are in relative mode. */
+    if (wayland->pointer.zwp_relative_pointer_v1)
+        return;
+
     pointer_handle_motion_internal(data, pointer, time, sx, sy);
 }
 
@@ -214,6 +220,47 @@ static const struct wl_pointer_listener pointer_listener = {
     pointer_handle_axis_discrete,
 };
 
+static void relative_pointer_handle_motion(void *data,
+                                           struct zwp_relative_pointer_v1 *rpointer,
+                                           uint32_t utime_hi,
+                                           uint32_t utime_lo,
+                                           wl_fixed_t dx,
+                                           wl_fixed_t dy,
+                                           wl_fixed_t dx_unaccel,
+                                           wl_fixed_t dy_unaccel)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    int wine_dx, wine_dy;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_wine(wayland->pointer.focused_surface,
+                                   wl_fixed_to_int(dx), wl_fixed_to_int(dy),
+                                   &wine_dx, &wine_dy);
+
+    TRACE("surface=%p hwnd=%p wayland_dxdy=%d,%d wine_dxdy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_int(dx), wl_fixed_to_int(dy), wine_dx, wine_dy);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = wine_dx;
+    input.mi.dy          = wine_dy;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
+    relative_pointer_handle_motion,
+};
+
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer)
 {
@@ -222,10 +269,14 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
     wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
     wayland->pointer.cursor_wl_surface =
         wl_compositor_create_surface(wayland->wl_compositor);
+    pointer->zwp_relative_pointer_v1 = NULL;
 }
 
 void wayland_pointer_deinit(struct wayland_pointer *pointer)
 {
+    if (pointer->zwp_relative_pointer_v1)
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+
     if (pointer->wl_pointer)
         wl_pointer_destroy(pointer->wl_pointer);
 
@@ -237,3 +288,32 @@ void wayland_pointer_deinit(struct wayland_pointer *pointer)
 
     memset(pointer, 0, sizeof(*pointer));
 }
+
+/**********************************************************************
+ *          wayland_pointer_set_relative
+ *
+ * Set whether the pointer emits relative (if able) or absolute motion events.
+ * The default is to emit absolute motion events.
+ */
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative)
+{
+    if (!pointer->wayland->zwp_relative_pointer_manager_v1)
+        return;
+
+    if (!pointer->zwp_relative_pointer_v1 && relative)
+    {
+        pointer->zwp_relative_pointer_v1 =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+                pointer->wayland->zwp_relative_pointer_manager_v1,
+                pointer->wl_pointer);
+
+        zwp_relative_pointer_v1_add_listener(pointer->zwp_relative_pointer_v1,
+                                             &zwp_relative_pointer_v1_listener,
+                                             pointer->wayland);
+    }
+    else if (pointer->zwp_relative_pointer_v1 && !relative)
+    {
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+        pointer->zwp_relative_pointer_v1 = NULL;
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index da1feae5bea..8d999e6f5e1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -30,6 +30,7 @@
 #include <wayland-egl.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -97,6 +98,7 @@ struct wayland_pointer
     uint32_t enter_serial;
     struct wayland_cursor *cursor;
     HCURSOR hcursor;
+    struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
 };
 
 struct wayland
@@ -114,6 +116,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t output_id_fnv_offset;
     uint32_t next_fallback_output_id;
@@ -400,6 +403,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard);
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer);
 void wayland_pointer_deinit(struct wayland_pointer *pointer);
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative);
 void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor);
 BOOL wayland_init_set_cursor(void);
 void wayland_invalidate_set_cursor(void);
-- 
2.33.0


From de73f23fce181ba30aba6ef8c1526b08f323a769 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:06:48 +0300
Subject: [PATCH 076/125] winewayland.drv: Add function to get wayland surface
 coords from wine screen coords

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 28 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 726a447b1e9..177110cfb00 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -857,6 +857,34 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
           *screen_x, *screen_y);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_from_screen
+ *
+ * Converts the Windows screen coordinates to surface-local coordinates.
+ */
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y)
+{
+    int wine_x, wine_y;
+    RECT window_rect = {0};
+
+    /* Screen to window */
+    GetWindowRect(surface->hwnd, &window_rect);
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    wine_x = screen_x - window_rect.left;
+    wine_y = screen_y - window_rect.top;
+
+    /* Window to wayland surface */
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y,
+                                     wayland_x, wayland_y);
+
+    TRACE("hwnd=%p screen=%d,%d rect=%s => wayland=%.2f,%.2f\n",
+          surface->hwnd, screen_x, screen_y, wine_dbgstr_rect(&window_rect),
+          *wayland_x, *wayland_y);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8d999e6f5e1..bb8642c64b0 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -331,6 +331,9 @@ void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
                                       double wayland_x, double wayland_y,
                                       int *screen_x, int *screen_y);
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y);
-- 
2.33.0


From f2e2c2e8e17419e61f7df06f4fc156d4d44ae4da Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:18:20 +0300
Subject: [PATCH 077/125] winewayland.drv: Implement ClipCursor

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in          |   1 +
 dlls/winewayland.drv/wayland.c            |   5 +
 dlls/winewayland.drv/wayland_cursor.c     |  17 +++
 dlls/winewayland.drv/wayland_surface.c    | 166 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  14 ++
 dlls/winewayland.drv/window.c             |  23 +++
 dlls/winewayland.drv/winewayland.drv.spec |   1 +
 7 files changed, 227 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 3f8a72bf08f..8549e5d89ac 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -30,6 +30,7 @@ C_SRCS = \
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index df30f7063cf..a49aac306f2 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -144,6 +144,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         if (!wayland_output_create(wayland, id, version))
             ERR("Failed to create wayland_output for global id=%u\n", id);
     }
+    else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
+    {
+        wayland->zwp_pointer_constraints_v1 =
+            wl_registry_bind(registry, id, &zwp_pointer_constraints_v1_interface, 1);
+    }
     else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
     {
         wayland->zwp_relative_pointer_manager_v1 =
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index ff5bdb1b3bd..8417a047716 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -319,6 +319,7 @@ void CDECL WAYLAND_SetCursor(HCURSOR handle)
 
     if (InterlockedExchangePointer((void **)&last_cursor, handle) != handle)
     {
+        HWND foreground = GetForegroundWindow();
         struct wayland *wayland = thread_wayland();
 
         /* If a non GUI thread calls SetCursor, just ignore it, since it doesn't
@@ -328,5 +329,21 @@ void CDECL WAYLAND_SetCursor(HCURSOR handle)
             wayland_pointer_update_cursor_from_win32(&wayland->pointer, handle);
         else
             wayland_invalidate_set_cursor();
+
+        /* Cursor visibility affects pointer confinement mode. */
+        SendMessageW(foreground, WM_WAYLAND_POINTER_CONFINEMENT_UPDATE,
+                     WAYLAND_POINTER_CONFINEMENT_RETAIN_CLIP, 0);
     }
 }
+
+/***********************************************************************
+ *           WAYLAND_ClipCursor
+ */
+void CDECL WAYLAND_ClipCursor(const RECT *clip)
+{
+    HWND foreground = GetForegroundWindow();
+    WPARAM confine = clip ? WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP :
+                            WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP;
+
+    SendMessageW(foreground, WM_WAYLAND_POINTER_CONFINEMENT_UPDATE, confine, 0);
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 177110cfb00..ecfe507e288 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -546,6 +546,18 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         heap_free(ref);
     }
 
+    if (surface->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
     if (surface->wl_egl_window)
     {
         wl_egl_window_destroy(surface->wl_egl_window);
@@ -1106,6 +1118,160 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_update_pointer_confinement
+ *
+ * Update pointer confinement on the surface. Confinement mode depends
+ * on the current Windows cursor clip and cursor visibility.
+ */
+void wayland_surface_update_pointer_confinement(struct wayland_surface *surface)
+{
+    struct wayland *wayland = surface->wayland;
+    struct wayland_surface *glvk;
+    struct wl_region *region;
+    RECT vscreen_rect;
+    RECT clip_rect = wayland->cursor_clip;
+    RECT client_rect = {0};
+    RECT client_clip_rect;
+    BOOL needs_lock = FALSE;
+    BOOL needs_confine = FALSE;
+
+    if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
+        return;
+
+    GetClientRect(surface->hwnd, &client_rect);
+    MapWindowPoints(surface->hwnd, NULL, (POINT*)&client_rect, 2);
+
+    vscreen_rect.top = GetSystemMetrics(SM_YVIRTUALSCREEN);
+    vscreen_rect.left = GetSystemMetrics(SM_XVIRTUALSCREEN);
+    vscreen_rect.bottom = vscreen_rect.top + GetSystemMetrics(SM_CYVIRTUALSCREEN);
+    vscreen_rect.right = vscreen_rect.left + GetSystemMetrics(SM_CXVIRTUALSCREEN);
+
+    /* Get the effective clip area, if any. */
+    IntersectRect(&clip_rect, &clip_rect, &vscreen_rect);
+    IntersectRect(&client_clip_rect, &clip_rect, &client_rect);
+
+    TRACE("wayland=%p surface=%p (glvk=%p) clip_rect=%s client_clip_rect=%s "
+          "client=%s vscreen=%s hcursor=%p\n",
+          wayland, surface, surface->glvk,
+          wine_dbgstr_rect(&clip_rect), wine_dbgstr_rect(&client_clip_rect),
+          wine_dbgstr_rect(&client_rect),
+          wine_dbgstr_rect(&vscreen_rect),
+          GetCursor());
+
+    glvk = wayland_surface_ref_glvk(surface);
+    surface = glvk ? glvk : surface;
+
+    /* Only confine or lock if the cursor is actually clipped within this window. */
+    if (!IsRectEmpty(&client_clip_rect))
+    {
+        HCURSOR hcursor = GetCursor();
+        if (!hcursor &&
+            (!EqualRect(&clip_rect, &vscreen_rect) ||
+             EqualRect(&client_rect, &vscreen_rect)))
+        {
+            needs_lock = TRUE;
+        }
+        else if (hcursor && !EqualRect(&clip_rect, &vscreen_rect))
+        {
+            needs_confine = TRUE;
+        }
+    }
+
+    /* Destroy unneeded interface objects. */
+    if (!needs_lock && surface->zwp_locked_pointer_v1)
+    {
+        POINT cursor_pos;
+
+        if (GetCursorPos(&cursor_pos) && PtInRect(&client_rect, cursor_pos))
+        {
+            double wayland_x, wayland_y;
+            wayland_surface_coords_from_screen(surface,
+                                               cursor_pos.x, cursor_pos.y,
+                                               &wayland_x, &wayland_y);
+
+            zwp_locked_pointer_v1_set_cursor_position_hint(
+                    surface->zwp_locked_pointer_v1,
+                    wl_fixed_from_double(wayland_x),
+                    wl_fixed_from_double(wayland_y));
+
+            wl_surface_commit(surface->wl_surface);
+        }
+
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (!needs_confine && surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    /* Set up (or update) pointer confinement or lock. */
+    if (needs_confine)
+    {
+        double top, left, bottom, right;
+
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.left,
+                                           client_clip_rect.top,
+                                           &left, &top);
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.right,
+                                           client_clip_rect.bottom,
+                                           &right, &bottom);
+
+        region = wl_compositor_create_region(wayland->wl_compositor);
+        wl_region_add(region, round(left), round(top),
+                      round(right - left), round(bottom - top));
+
+        if (!surface->zwp_confined_pointer_v1)
+        {
+            surface->zwp_confined_pointer_v1 =
+                zwp_pointer_constraints_v1_confine_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    region,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_confined_pointer_v1_set_region(surface->zwp_confined_pointer_v1,
+                                               region);
+        }
+
+        wl_region_destroy(region);
+    }
+    else if (needs_lock)
+    {
+        if (!surface->zwp_locked_pointer_v1)
+        {
+            surface->zwp_locked_pointer_v1 =
+                zwp_pointer_constraints_v1_lock_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    NULL,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_locked_pointer_v1_set_region(surface->zwp_locked_pointer_v1,
+                                             NULL);
+        }
+    }
+
+    wayland_pointer_set_relative(&wayland->pointer, needs_lock);
+
+    if (needs_confine || needs_lock)
+        wl_surface_commit(surface->wl_surface);
+
+    if (glvk)
+        wayland_surface_unref_glvk(glvk->parent);
+}
+
 static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
                                                            struct wayland_output *output,
                                                            int scale)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index bb8642c64b0..8c0d0852580 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -30,6 +30,7 @@
 #include <wayland-egl.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
@@ -50,6 +51,7 @@ enum wayland_window_message
     WM_WAYLAND_STATE_UPDATE = 0x80001001,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001002,
     WM_WAYLAND_MODE_CHANGE = 0x80001003,
+    WM_WAYLAND_POINTER_CONFINEMENT_UPDATE = 0x80001004,
 };
 
 enum wayland_configure_flags
@@ -60,6 +62,13 @@ enum wayland_configure_flags
     WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
 };
 
+enum wayland_pointer_confinement
+{
+    WAYLAND_POINTER_CONFINEMENT_RETAIN_CLIP,
+    WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP,
+    WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -116,6 +125,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t output_id_fnv_offset;
@@ -129,6 +139,7 @@ struct wayland
     DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
+    RECT cursor_clip;
 };
 
 struct wayland_output_mode
@@ -191,6 +202,8 @@ struct wayland_surface
     struct wl_egl_window *wl_egl_window;
     struct wayland_surface *parent;
     struct wayland_surface *glvk;
+    struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
+    struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     /* The offset of this surface relative to its owning win32 window */
     int offset_x, offset_y;
     HWND hwnd;
@@ -349,6 +362,7 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
 void wayland_surface_ensure_mapped(struct wayland_surface *surface);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
+void wayland_surface_update_pointer_confinement(struct wayland_surface *surface);
 void wayland_surface_set_main_output(struct wayland_surface *surface,
                                      struct wayland_output *output, BOOL post);
 void wayland_surface_leave_output(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 8d72d3cffa2..3ece29419ae 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -32,6 +32,8 @@
 #include "wine/gdi_driver.h"
 #include "wine/heap.h"
 
+#include <limits.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 /* private window data */
@@ -537,6 +539,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(data->wayland_surface);
 
+    wayland_surface_update_pointer_confinement(data->wayland_surface);
+
     wayland_surface_set_drawing_allowed(data->wayland_surface, TRUE);
 
     wayland_win_data_release(parent_data);
@@ -1252,6 +1256,25 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
                 wayland_output_set_wine_mode(output, LOWORD(lp), HIWORD(lp));
         }
         break;
+    case WM_WAYLAND_POINTER_CONFINEMENT_UPDATE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+            {
+                if (wp == WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP)
+                {
+                    GetClipCursor(&wayland_surface->wayland->cursor_clip);
+                }
+                else if (wp == WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP)
+                {
+                    SetRect(&wayland_surface->wayland->cursor_clip,
+                            INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+                }
+                wayland_surface_update_pointer_confinement(wayland_surface);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index e668254352b..4d8c427fbf4 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -4,6 +4,7 @@
 
 # USER driver
 
+@ cdecl ClipCursor(ptr) WAYLAND_ClipCursor
 @ cdecl ChangeDisplaySettingsEx(ptr ptr long long long) WAYLAND_ChangeDisplaySettingsEx
 @ cdecl CreateWindow(long) WAYLAND_CreateWindow
 @ cdecl DestroyWindow(long) WAYLAND_DestroyWindow
-- 
2.33.0


From ffe9c0c5941febcc468c49f20b88d3bb746724d6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 17:16:49 +0300
Subject: [PATCH 078/125] winewayland.drv: Implement SetWindowText

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c    | 25 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  1 +
 dlls/winewayland.drv/window.c             | 23 +++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  1 +
 4 files changed, 50 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index ecfe507e288..bd1122ee490 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -23,6 +23,7 @@
 #include "waylanddrv.h"
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/unicode.h"
 
 #include "winuser.h"
 
@@ -1372,6 +1373,30 @@ int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
     return scale;
 }
 
+/**********************************************************************
+ *          wayland_surface_set_title
+ */
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
+{
+    int utf8_count;
+    char *utf8 = NULL;
+
+    if (!surface->xdg_toplevel)
+        return;
+
+    TRACE("surface=%p hwnd=%p text='%s'\n",
+          surface, surface->hwnd, wine_dbgstr_w(text));
+
+    utf8_count = WideCharToMultiByte(CP_UTF8, 0, text, -1, NULL, 0, NULL, NULL);
+    if (utf8_count && (utf8 = heap_alloc(utf8_count)) &&
+        WideCharToMultiByte(CP_UTF8, 0, text, -1, utf8, utf8_count, NULL, NULL))
+    {
+        xdg_toplevel_set_title(surface->xdg_toplevel, utf8);
+    }
+
+    heap_free(utf8);
+}
+
 /**********************************************************************
  *          wayland_surface_set_drawing_allowed
  */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8c0d0852580..9e595212f41 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -368,6 +368,7 @@ void wayland_surface_set_main_output(struct wayland_surface *surface,
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output);
 int wayland_surface_get_buffer_scale(struct wayland_surface *surface);
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_drawing_allowed(struct wayland_surface *surface, BOOL allowed);
 BOOL wayland_surface_is_drawing_allowed(struct wayland_surface *surface);
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 3ece29419ae..1c39b591301 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -353,7 +353,15 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         data->wayland_surface = wayland_surface_create_plain(wayland);
 
     if (data->wayland_surface)
+    {
         data->wayland_surface->hwnd = data->hwnd;
+        if (data->wayland_surface->xdg_toplevel)
+        {
+            WCHAR text[1024];
+            if (!InternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text))) text[0] = 0;
+            wayland_surface_set_title(data->wayland_surface, text);
+        }
+    }
 
 out:
     wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
@@ -765,6 +773,21 @@ void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     wayland_win_data_release(data);
 }
 
+/*****************************************************************
+ *		WAYLAND_SetWindowText
+ */
+void CDECL WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
+{
+    struct wayland_surface *wsurface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p text=%s\n", hwnd, wine_dbgstr_w(text));
+
+    if (wsurface && wsurface->xdg_toplevel)
+        wayland_surface_set_title(wsurface, text);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
 /***********************************************************************
  *	     WAYLAND_SetLayeredWindowAttributes
  */
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index 4d8c427fbf4..6a316df29cc 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -16,6 +16,7 @@
 @ cdecl SetLayeredWindowAttributes(long long long long) WAYLAND_SetLayeredWindowAttributes
 @ cdecl SetWindowRgn(long long long) WAYLAND_SetWindowRgn
 @ cdecl SetWindowStyle(ptr long ptr) WAYLAND_SetWindowStyle
+@ cdecl SetWindowText(long wstr) WAYLAND_SetWindowText
 @ cdecl ShowWindow(long long ptr long) WAYLAND_ShowWindow
 @ cdecl SysCommand(long long long) WAYLAND_SysCommand
 @ cdecl ThreadDetach() WAYLAND_ThreadDetach
-- 
2.33.0


From f3e112b36963484479d251c9e5887acb492264fd Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:33:07 +0300
Subject: [PATCH 079/125] winewayland.drv: Skeleton Vulkan driver

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in  |  1 +
 dlls/winewayland.drv/vulkan.c     | 78 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  6 +++
 3 files changed, 85 insertions(+)
 create mode 100644 dlls/winewayland.drv/vulkan.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 8549e5d89ac..5a20d5fd547 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -13,6 +13,7 @@ C_SRCS = \
 	display.c \
 	gdi.c \
 	opengl.c \
+	vulkan.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
new file mode 100644
index 00000000000..4fcea818942
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan.c
@@ -0,0 +1,78 @@
+/* WAYLANDDRV Vulkan implementation
+ *
+ * Copyright 2017 Roderick Colenbrander
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+#ifdef SONAME_LIBVULKAN
+
+static void *vulkan_handle;
+
+static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
+{
+    if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    {
+        ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        return TRUE;
+    }
+
+    return TRUE;
+}
+
+static const struct vulkan_funcs vulkan_funcs;
+
+const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
+    if (version != WINE_VULKAN_DRIVER_VERSION)
+    {
+        ERR("version mismatch, vulkan wants %u but driver has %u\n", version, WINE_VULKAN_DRIVER_VERSION);
+        return NULL;
+    }
+
+    InitOnceExecuteOnce(&init_once, wine_vk_init, NULL, NULL);
+    if (vulkan_handle)
+        return &vulkan_funcs;
+
+    return NULL;
+}
+
+#else /* No vulkan */
+
+const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
+{
+    ERR("Wine was built without Vulkan support.\n");
+    return NULL;
+}
+
+#endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9e595212f41..98ed5495573 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -438,6 +438,12 @@ void wayland_update_front_buffer(HWND hwnd,
                                  void (*read_pixels)(void *pixels_out,
                                                      int width, int height));
 
+/**********************************************************************
+ *          Vulkan support
+ */
+
+const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version);
+
 /**********************************************************************
  *          XKB helpers
  */
-- 
2.33.0


From d44048b28bd771bd10d147ffa1ef7c2450b481fb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:41:32 +0300
Subject: [PATCH 080/125] winewayland.drv: Implement vkCreateInstance

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 93 ++++++++++++++++++++++++++++++++++-
 1 file changed, 92 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 4fcea818942..6a25cf54956 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -24,6 +24,7 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -35,8 +36,86 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+
 static void *vulkan_handle;
 
+/* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
+ * Caller is responsible for allocation and cleanup of 'dst'.
+ */
+static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
+                                                     VkInstanceCreateInfo *dst)
+{
+    unsigned int i;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pApplicationInfo = src->pApplicationInfo;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions = heap_calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+        {
+            /* Substitute extension with Wayland ones else copy. Long-term, when we
+             * support more extensions, we should store these in a list.
+             */
+            if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_surface"))
+            {
+                enabled_extensions[i] = "VK_KHR_wayland_surface";
+            }
+            else
+            {
+                enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+            }
+        }
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = src->enabledExtensionCount;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
+                                         const VkAllocationCallbacks *allocator,
+                                         VkInstance *instance)
+{
+    VkInstanceCreateInfo create_info_host;
+    VkResult res;
+    TRACE("create_info %p, allocator %p, instance %p\n", create_info, allocator, instance);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Perform a second pass on converting VkInstanceCreateInfo. Winevulkan
+     * performed a first pass in which it handles everything except for WSI
+     * functionality such as VK_KHR_win32_surface. Handle this now.
+     */
+    res = wine_vk_instance_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to convert instance create info, res=%d\n", res);
+        return res;
+    }
+
+    res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
+
+    heap_free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -45,10 +124,22 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
         return TRUE;
     }
 
+#define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+    LOAD_FUNCPTR(vkCreateInstance);
+#undef LOAD_FUNCPTR
+
+    return TRUE;
+
+fail:
+    dlclose(vulkan_handle);
+    vulkan_handle = NULL;
     return TRUE;
 }
 
-static const struct vulkan_funcs vulkan_funcs;
+static const struct vulkan_funcs vulkan_funcs =
+{
+    .p_vkCreateInstance = wayland_vkCreateInstance,
+};
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
 {
-- 
2.33.0


From 1b7082f1b7f3ed9446536d3e32a5363919ffc146 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:44:10 +0300
Subject: [PATCH 081/125] winewayland.drv: Implement vkDestroyInstance

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 6a25cf54956..c5cd969c155 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -37,6 +37,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 #ifdef SONAME_LIBVULKAN
 
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -116,6 +117,16 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
+{
+    TRACE("%p %p\n", instance, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    pvkDestroyInstance(instance, NULL /* allocator */);
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -126,6 +137,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkDestroyInstance);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -139,6 +151,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkDestroyInstance = wayland_vkDestroyInstance,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.33.0


From e599a2f88a5681500852969e7c3d5f725226a757 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 19:08:02 +0300
Subject: [PATCH 082/125] winewayland.drv: Support wayland surfaces with Vulkan
 content

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 39 ++++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 31 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index bd1122ee490..6547043ef8d 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -674,12 +674,10 @@ static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *
     return glvk;
 }
 
-/**********************************************************************
- *          wayland_surface_create_gl
- *
- * Creates a GL subsurface for this wayland surface.
- */
-BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
+enum WAYLAND_GLVK { WAYLAND_GLVK_GL, WAYLAND_GLVK_VK };
+
+static BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface,
+                                               enum WAYLAND_GLVK wayland_glvk)
 {
     struct wayland_surface *glvk;
     RECT client_rect;
@@ -693,9 +691,12 @@ BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
     if (!glvk)
         goto err;
 
-    glvk->wl_egl_window = wl_egl_window_create(glvk->wl_surface, 1, 1);
-    if (!glvk->wl_egl_window)
-        goto err;
+    if (wayland_glvk == WAYLAND_GLVK_GL)
+    {
+        glvk->wl_egl_window = wl_egl_window_create(glvk->wl_surface, 1, 1);
+        if (!glvk->wl_egl_window)
+            goto err;
+    }
 
     EnterCriticalSection(&surface->crit);
     surface->glvk = glvk;
@@ -721,6 +722,26 @@ err:
     return FALSE;
 }
 
+/**********************************************************************
+ *          wayland_surface_create_gl
+ *
+ * Creates a GL subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
+{
+    return wayland_surface_create_or_ref_glvk(surface, WAYLAND_GLVK_GL);
+}
+
+/**********************************************************************
+ *          wayland_surface_create_or_ref_vk
+ *
+ * Creates a VK subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_vk(struct wayland_surface *surface)
+{
+    return wayland_surface_create_or_ref_glvk(surface, WAYLAND_GLVK_VK);
+}
+
 /**********************************************************************
  *          wayland_surface_unref_glvk
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 98ed5495573..954c0d800e1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -334,6 +334,7 @@ void wayland_surface_reconfigure(struct wayland_surface *surface, int x, int y,
                                  int width,int height);
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
 BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface);
+BOOL wayland_surface_create_or_ref_vk(struct wayland_surface *surface);
 void wayland_surface_unref_glvk(struct wayland_surface *surface);
 void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
                                       int width, int height);
-- 
2.33.0


From 07194a67fff68e85d31ed95dda98721e24201dff Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 19:08:53 +0300
Subject: [PATCH 083/125] winewayland.drv: Implement vkCreateWaylandSurfaceKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 129 ++++++++++++++++++++++++++++++++++
 1 file changed, 129 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index c5cd969c155..1923367befa 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -26,6 +26,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
 
@@ -36,11 +38,66 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+#define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
+
+typedef struct VkWaylandSurfaceCreateInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkWaylandSurfaceCreateFlagsKHR flags;
+    struct wl_display *display;
+    struct wl_surface *surface;
+} VkWaylandSurfaceCreateInfoKHR;
+
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
+static CRITICAL_SECTION wine_vk_object_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &wine_vk_object_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": wine_vk_object_section") }
+};
+static CRITICAL_SECTION wine_vk_object_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+
+struct wine_vk_surface
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_surface *wayland_surface;
+    VkSurfaceKHR native_vk_surface;
+};
+
+static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
+{
+    EnterCriticalSection(&wine_vk_object_section);
+    wl_list_insert(list, link);
+    LeaveCriticalSection(&wine_vk_object_section);
+}
+
+static inline void wine_vk_list_remove(struct wl_list *link)
+{
+    EnterCriticalSection(&wine_vk_object_section);
+    wl_list_remove(link);
+    LeaveCriticalSection(&wine_vk_object_section);
+}
+
+static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
+{
+    wine_vk_list_remove(&wine_vk_surface->link);
+
+    if (wine_vk_surface->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_surface->wayland_surface);
+
+    heap_free(wine_vk_surface);
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -117,6 +174,76 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
+                                                const VkWin32SurfaceCreateInfoKHR *create_info,
+                                                const VkAllocationCallbacks *allocator,
+                                                VkSurfaceKHR *vk_surface)
+{
+    VkResult res;
+    VkWaylandSurfaceCreateInfoKHR create_info_host;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wayland_surface *wayland_surface;
+
+    TRACE("%p %p %p %p\n", instance, create_info, allocator, vk_surface);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* TODO: support child window rendering. */
+    if (GetAncestor(create_info->hwnd, GA_PARENT) != GetDesktopWindow())
+    {
+        FIXME("Application requires child window rendering, which is not implemented yet!\n");
+        return VK_ERROR_INCOMPATIBLE_DRIVER;
+    }
+
+    wine_vk_surface = heap_alloc_zero(sizeof(*wine_vk_surface));
+    if (!wine_vk_surface)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_surface->link);
+
+    wayland_surface = wayland_surface_for_hwnd_lock(create_info->hwnd);
+    if (wayland_surface)
+    {
+        BOOL ref_vk = wayland_surface_create_or_ref_vk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_vk)
+        {
+            ERR("Failed to allocate vulkan surface for hwnd=%p\n", create_info->hwnd);
+            /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+
+    wine_vk_surface->wayland_surface = wayland_surface;
+
+    create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
+    create_info_host.pNext = NULL;
+    create_info_host.flags = 0; /* reserved */
+    create_info_host.display = process_wl_display;
+    create_info_host.surface = wayland_surface->glvk->wl_surface;
+
+    res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host, NULL /* allocator */, vk_surface);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create vulkan wayland surface, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_surface->hwnd = create_info->hwnd;
+    wine_vk_surface->native_vk_surface = *vk_surface;
+
+    wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
+
+    TRACE("Created surface=0x%s\n", wine_dbgstr_longlong(*vk_surface));
+    return VK_SUCCESS;
+
+err:
+    wine_vk_surface_destroy(wine_vk_surface);
+    return res;
+}
+
 static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
 {
     TRACE("%p %p\n", instance, allocator);
@@ -137,6 +264,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
 #undef LOAD_FUNCPTR
 
@@ -151,6 +279,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
 };
 
-- 
2.33.0


From ce5533fe0fd8e8d30dfc8319a990dc3d8245980c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:02:59 +0300
Subject: [PATCH 084/125] winewayland.drv: Implement vkDestroySurfaceKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 37 +++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 1923367befa..99159958d6f 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -52,6 +52,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
+static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -98,6 +99,22 @@ static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
     heap_free(wine_vk_surface);
 }
 
+static struct wine_vk_surface *wine_vk_surface_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *surf;
+
+    EnterCriticalSection(&wine_vk_object_section);
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+        if (surf->native_vk_surface == handle) goto out;
+
+    surf = NULL;
+
+out:
+    LeaveCriticalSection(&wine_vk_object_section);
+    return surf;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -254,6 +271,24 @@ static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCal
     pvkDestroyInstance(instance, NULL /* allocator */);
 }
 
+static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
+                                        const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+
+    TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_surface)
+    {
+        pvkDestroySurfaceKHR(instance, wine_vk_surface->native_vk_surface,
+                             NULL /* allocator */);
+        wine_vk_surface_destroy(wine_vk_surface);
+    }
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -266,6 +301,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
+    LOAD_FUNCPTR(vkDestroySurfaceKHR);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -281,6 +317,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateInstance = wayland_vkCreateInstance,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.33.0


From 6079b30eaa9b2852d91346ea4fff8929ed66f787 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:21:29 +0300
Subject: [PATCH 085/125] winewayland.drv: Implement vkCreateSwapchainKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 72 +++++++++++++++++++++++++++++++++++
 1 file changed, 72 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 99159958d6f..73547a91498 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -50,6 +50,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 } VkWaylandSurfaceCreateInfoKHR;
 
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
@@ -66,6 +67,7 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION wine_vk_object_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
 
 struct wine_vk_surface
 {
@@ -75,6 +77,14 @@ struct wine_vk_surface
     VkSurfaceKHR native_vk_surface;
 };
 
+struct wine_vk_swapchain
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_surface *wayland_surface;
+    VkSwapchainKHR native_vk_swapchain;
+};
+
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
 {
     EnterCriticalSection(&wine_vk_object_section);
@@ -115,6 +125,16 @@ out:
     return surf;
 }
 
+static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    wine_vk_list_remove(&wine_vk_swapchain->link);
+
+    if (wine_vk_swapchain->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
+
+    heap_free(wine_vk_swapchain);
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -163,6 +183,11 @@ static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo
     return VK_SUCCESS;
 }
 
+#define RETURN_VK_ERROR_SURFACE_LOST_KHR { \
+    TRACE("VK_ERROR_SURFACE_LOST_KHR\n"); \
+    return VK_ERROR_SURFACE_LOST_KHR; \
+}
+
 static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
                                          const VkAllocationCallbacks *allocator,
                                          VkInstance *instance)
@@ -191,6 +216,51 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
+                                             const VkSwapchainCreateInfoKHR *create_info,
+                                             const VkAllocationCallbacks *allocator,
+                                             VkSwapchainKHR *swapchain)
+{
+    VkResult res;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_surface = wine_vk_surface_from_handle(create_info->surface);
+    if (!wine_vk_surface)
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    wine_vk_swapchain = heap_alloc_zero(sizeof(*wine_vk_swapchain));
+    if (!wine_vk_swapchain)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_swapchain->link);
+
+    res = pvkCreateSwapchainKHR(device, create_info, NULL /* allocator */, swapchain);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    wine_vk_swapchain->hwnd = wine_vk_surface->hwnd;
+    if (wine_vk_surface->wayland_surface)
+    {
+        wayland_surface_create_or_ref_vk(wine_vk_surface->wayland_surface);
+        wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
+    }
+    wine_vk_swapchain->native_vk_swapchain = *swapchain;
+
+    wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
+
+    return res;
+
+err:
+    wine_vk_swapchain_destroy(wine_vk_swapchain);
+    return res;
+}
+
 static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
                                                 const VkWin32SurfaceCreateInfoKHR *create_info,
                                                 const VkAllocationCallbacks *allocator,
@@ -299,6 +369,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
@@ -315,6 +386,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
-- 
2.33.0


From ef77eb85a2a4e7c15c8bc9f277943bdf13890ab9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:35:30 +0300
Subject: [PATCH 086/125] winewayland.drv: Implement vkDestroySwapchainKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 38 +++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 73547a91498..f040e8d7821 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -54,6 +54,7 @@ static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKH
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
+static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -135,6 +136,22 @@ static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchai
     heap_free(wine_vk_swapchain);
 }
 
+static struct wine_vk_swapchain *wine_vk_swapchain_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_swapchain *swap;
+
+    EnterCriticalSection(&wine_vk_object_section);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+        if (swap->native_vk_swapchain == handle) goto out;
+
+    swap = NULL;
+
+out:
+    LeaveCriticalSection(&wine_vk_object_section);
+    return swap;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -359,6 +376,25 @@ static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surfac
     }
 }
 
+static void wayland_vkDestroySwapchainKHR(VkDevice device,
+                                          VkSwapchainKHR swapchain,
+                                          const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_swapchain)
+    {
+        pvkDestroySwapchainKHR(device, wine_vk_swapchain->native_vk_swapchain,
+                               NULL /* allocator */);
+        wine_vk_swapchain_destroy(wine_vk_swapchain);
+    }
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -373,6 +409,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
+    LOAD_FUNCPTR(vkDestroySwapchainKHR);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -390,6 +427,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.33.0


From 74aef49038802b05fcabb2ee53c208bd77aeec22 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 13:22:11 +0300
Subject: [PATCH 087/125] winewayland.drv: Implement vkQueuePresentKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 47 +++++++++++++++++++++++++++++++++++
 1 file changed, 47 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index f040e8d7821..e085bb23e66 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -55,6 +55,7 @@ static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurface
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
 
@@ -395,6 +396,50 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
+{
+    uint32_t i;
+    VkResult res = VK_SUCCESS;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(vk_swapchain);
+
+        TRACE("swapchain[%d] vk=0x%s wine=%p wayland_surface=%p ",
+               i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL);
+
+        if (!wine_vk_swapchain) res = VK_ERROR_SURFACE_LOST_KHR;
+
+        /* Since Vulkan content is presented in a Wayland subsurface, we need
+         * to ensure the owning Wayland surface is mapped for the Vulkan
+         * content to be visible. */
+        if (wine_vk_swapchain->wayland_surface)
+            wayland_surface_ensure_mapped(wine_vk_swapchain->wayland_surface);
+    }
+
+    return res;
+}
+
+static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *present_info)
+{
+    VkResult res;
+    VkResult validation_res;
+
+    TRACE("%p, %p\n", queue, present_info);
+
+    validation_res = validate_present_info(present_info);
+    /* Even if validation fails, we need to call the native vkQueuePresent to ensure
+     * the presented image is handled/released properly. */
+    res = pvkQueuePresentKHR(queue, present_info);
+
+    if (validation_res != VK_SUCCESS)
+        return validation_res;
+
+    return res;
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -410,6 +455,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -428,6 +474,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.33.0


From c312d51425272bf89c37328d33164158a1819c66 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 13:30:46 +0300
Subject: [PATCH 088/125] winewayland.drv: Handle window resizes under Vulkan

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 24 +++++++++++++++++++++---
 1 file changed, 21 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index e085bb23e66..8b295ab6d5b 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -85,6 +85,7 @@ struct wine_vk_swapchain
     HWND hwnd;
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
+    VkExtent2D extent;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -269,6 +270,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
     }
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
+    wine_vk_swapchain->extent = create_info->imageExtent;
 
     wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
 
@@ -405,12 +407,28 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
     {
         const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
         struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(vk_swapchain);
+        RECT client;
 
-        TRACE("swapchain[%d] vk=0x%s wine=%p wayland_surface=%p ",
+        TRACE("swapchain[%d] vk=0x%s wine=%p extent=%ux%u wayland_surface=%p "
+              "drawing_allowed=%d\n",
                i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
-               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL);
+               wine_vk_swapchain->extent.width, wine_vk_swapchain->extent.height,
+               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
+               (wine_vk_swapchain && wine_vk_swapchain->wayland_surface) ?
+                   wayland_surface_is_drawing_allowed(wine_vk_swapchain->wayland_surface) : -1);
 
-        if (!wine_vk_swapchain) res = VK_ERROR_SURFACE_LOST_KHR;
+        if (!wine_vk_swapchain ||
+            !GetClientRect(wine_vk_swapchain->hwnd, &client))
+        {
+            res = VK_ERROR_SURFACE_LOST_KHR;
+        }
+        else if (client.right != wine_vk_swapchain->extent.width ||
+                 client.bottom != wine_vk_swapchain->extent.height ||
+                 (wine_vk_swapchain->wayland_surface &&
+                  !wayland_surface_is_drawing_allowed(wine_vk_swapchain->wayland_surface)))
+        {
+            res = VK_ERROR_OUT_OF_DATE_KHR;
+        }
 
         /* Since Vulkan content is presented in a Wayland subsurface, we need
          * to ensure the owning Wayland surface is mapped for the Vulkan
-- 
2.33.0


From 71316ae52df735fc6508d3a5863f2de676db598a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:43:33 +0300
Subject: [PATCH 089/125] winewayland.drv: Add mechanism to invalidate Vulkan
 objects

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c     | 35 ++++++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h |  1 +
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 8b295ab6d5b..fc7595c94d0 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -77,6 +77,7 @@ struct wine_vk_surface
     HWND hwnd;
     struct wayland_surface *wayland_surface;
     VkSurfaceKHR native_vk_surface;
+    BOOL valid;
 };
 
 struct wine_vk_swapchain
@@ -86,6 +87,7 @@ struct wine_vk_swapchain
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
     VkExtent2D extent;
+    BOOL valid;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -250,7 +252,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         FIXME("Support for allocation callbacks not implemented yet\n");
 
     wine_vk_surface = wine_vk_surface_from_handle(create_info->surface);
-    if (!wine_vk_surface)
+    if (!wine_vk_surface || !__atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST))
         RETURN_VK_ERROR_SURFACE_LOST_KHR;
 
     wine_vk_swapchain = heap_alloc_zero(sizeof(*wine_vk_swapchain));
@@ -271,6 +273,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
     }
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
     wine_vk_swapchain->extent = create_info->imageExtent;
+    wine_vk_swapchain->valid = TRUE;
 
     wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
 
@@ -340,6 +343,7 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
 
     wine_vk_surface->hwnd = create_info->hwnd;
     wine_vk_surface->native_vk_surface = *vk_surface;
+    wine_vk_surface->valid = TRUE;
 
     wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
 
@@ -418,6 +422,7 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
                    wayland_surface_is_drawing_allowed(wine_vk_swapchain->wayland_surface) : -1);
 
         if (!wine_vk_swapchain ||
+            !__atomic_load_n(&wine_vk_swapchain->valid, __ATOMIC_SEQ_CST) ||
             !GetClientRect(wine_vk_swapchain->hwnd, &client))
         {
             res = VK_ERROR_SURFACE_LOST_KHR;
@@ -512,6 +517,30 @@ const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
     return NULL;
 }
 
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+    struct wine_vk_swapchain *swap;
+    struct wine_vk_surface *surf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    EnterCriticalSection(&wine_vk_object_section);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+    {
+        if (swap->hwnd == hwnd)
+            __atomic_store_n(&swap->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+    {
+        if (surf->hwnd == hwnd)
+            __atomic_store_n(&surf->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    LeaveCriticalSection(&wine_vk_object_section);
+}
+
 #else /* No vulkan */
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
@@ -520,4 +549,8 @@ const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
     return NULL;
 }
 
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+}
+
 #endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 954c0d800e1..c99bfa74742 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -444,6 +444,7 @@ void wayland_update_front_buffer(HWND hwnd,
  */
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version);
+void wayland_invalidate_vulkan_objects(HWND hwnd);
 
 /**********************************************************************
  *          XKB helpers
-- 
2.33.0


From 8281dbb17cec2c5057ee995f59453cb3dcd54b20 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:34:43 +0300
Subject: [PATCH 090/125] winewayland.drv: Implement
 vkEnumerateInstanceExtensionProperties

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 45 +++++++++++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index fc7595c94d0..9e15ed24e57 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -55,6 +55,7 @@ static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurface
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -402,6 +403,48 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer_name,
+                                                               uint32_t *count,
+                                                               VkExtensionProperties* properties)
+{
+    unsigned int i;
+    VkResult res;
+
+    TRACE("layer_name %s, count %p, properties %p\n", debugstr_a(layer_name), count, properties);
+
+    /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
+    if (layer_name)
+    {
+        ERR("Layer enumeration not supported from ICD.\n");
+        return VK_ERROR_LAYER_NOT_PRESENT;
+    }
+
+    /* We will return the same number of instance extensions reported by the host back to
+     * winevulkan. Along the way we may replace xlib extensions with their win32 equivalents.
+     * Winevulkan will perform more detailed filtering as it knows whether it has thunks
+     * for a particular extension.
+     */
+    res = pvkEnumerateInstanceExtensionProperties(layer_name, count, properties);
+    if (!properties || res < 0)
+        return res;
+
+    for (i = 0; i < *count; i++)
+    {
+        /* For now the only wayland extension we need to fixup. Long-term we may need an array. */
+        if (!strcmp(properties[i].extensionName, "VK_KHR_wayland_surface"))
+        {
+            TRACE("Substituting VK_KHR_wayland_surface for VK_KHR_win32_surface\n");
+
+            snprintf(properties[i].extensionName, sizeof(properties[i].extensionName),
+                    VK_KHR_WIN32_SURFACE_EXTENSION_NAME);
+            properties[i].specVersion = VK_KHR_WIN32_SURFACE_SPEC_VERSION;
+        }
+    }
+
+    TRACE("Returning %u extensions.\n", *count);
+    return res;
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -478,6 +521,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 
@@ -497,6 +541,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From ba2fabb1871cf0a518f31b3eb9dffb33184a8206 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:58:45 +0300
Subject: [PATCH 091/125] winewayland.drv: Implement
 vkGetDeviceGroupSurfacePresentModesKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 9e15ed24e57..7f229e5e587 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -56,6 +56,7 @@ static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -131,6 +132,12 @@ out:
     return surf;
 }
 
+static BOOL wine_vk_surface_handle_is_valid(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(handle);
+    return wine_vk_surface && __atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST);
+}
+
 static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
 {
     wine_vk_list_remove(&wine_vk_swapchain->link);
@@ -445,6 +452,18 @@ static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer
     return res;
 }
 
+static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
+                                                               VkSurfaceKHR surface,
+                                                               VkDeviceGroupPresentModeFlagsKHR *flags)
+{
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(surface), flags);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -515,6 +534,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     }
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+#define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
@@ -522,8 +542,10 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
+    LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
+#undef LOAD_OPTIONAL_FUNCPTR
 
     return TRUE;
 
@@ -542,6 +564,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
     .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From e41544a5b32070b9c734581e4d793b534d621a83 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:56:18 +0300
Subject: [PATCH 092/125] winewayland.drv: Implement vkGetDeviceProcAddr and
 vkGetInstanceProcAddr

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 7f229e5e587..76c8a3e659d 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -57,6 +57,8 @@ static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocation
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
+static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
+static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -73,6 +75,8 @@ static CRITICAL_SECTION wine_vk_object_section = { &critsect_debug, -1, 0, 0, 0,
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
 static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
 
+static const struct vulkan_funcs vulkan_funcs;
+
 struct wine_vk_surface
 {
     struct wl_list link;
@@ -464,6 +468,30 @@ static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
     return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
 }
 
+static void *wayland_vkGetDeviceProcAddr(VkDevice device, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", device, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_device_proc_addr(&vulkan_funcs, name)))
+        return proc_addr;
+
+    return pvkGetDeviceProcAddr(device, name);
+}
+
+static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", instance, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_instance_proc_addr(&vulkan_funcs, instance, name)))
+        return proc_addr;
+
+    return pvkGetInstanceProcAddr(instance, name);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -543,6 +571,8 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetDeviceProcAddr);
+    LOAD_FUNCPTR(vkGetInstanceProcAddr);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -565,6 +595,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
     .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
     .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From 83836bd82f146d7f33cb457971832dcbcea3c21a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 11:04:58 +0300
Subject: [PATCH 093/125] winewayland.drv: Implement
 vkGetPhysicalDevicePresentRectanglesKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 76c8a3e659d..19aa9e26f06 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -59,6 +59,7 @@ static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
 static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
+static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -492,6 +493,15 @@ static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name
     return pvkGetInstanceProcAddr(instance, name);
 }
 
+static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice phys_dev,
+                                                                VkSurfaceKHR surface,
+                                                                uint32_t *count, VkRect2D *rects)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, rects);
+
+    return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -573,6 +583,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
     LOAD_FUNCPTR(vkGetInstanceProcAddr);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -597,6 +608,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
     .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
     .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From a9931229b34ed3c4d9f9ae0c56aba6f99349f0a3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 11:11:41 +0300
Subject: [PATCH 094/125] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceCapabilities(2)KHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 45 +++++++++++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 19aa9e26f06..744ac11cafd 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -60,6 +60,8 @@ static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKH
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
 static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -502,6 +504,45 @@ static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice
     return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice phys_dev,
+                                                                   const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                                   VkSurfaceCapabilities2KHR *capabilities)
+{
+    TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceCapabilities2KHR)
+    {
+        return pvkGetPhysicalDeviceSurfaceCapabilities2KHR(phys_dev, surface_info,
+                                                           capabilities);
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext || capabilities->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with "
+              "vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    }
+
+    return pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface_info->surface,
+                                                      &capabilities->surfaceCapabilities);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  VkSurfaceCapabilitiesKHR *capabilities)
+{
+    TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -584,6 +625,8 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
     LOAD_FUNCPTR(vkGetInstanceProcAddr);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -609,6 +652,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
     .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From 1dd85f65760766b736565404b964e0539553f680 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:27:03 +0300
Subject: [PATCH 095/125] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceFormats(2)KHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 66 +++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 744ac11cafd..49c5ddb3ceb 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -62,6 +62,8 @@ static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -543,6 +545,66 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevi
     return pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
+                                                              const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                              uint32_t *count,
+                                                              VkSurfaceFormat2KHR *formats)
+{
+    VkSurfaceFormatKHR *formats_host;
+    uint32_t i;
+    VkResult result;
+    TRACE("%p, %p, %p, %p\n", phys_dev, surface_info, count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceFormats2KHR with "
+              "vkGetPhysicalDeviceSurfaceFormatsKHR, pNext is ignored.\n");
+    }
+
+    if (!formats)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                     count, NULL);
+    }
+
+    formats_host = heap_calloc(*count, sizeof(*formats_host));
+    if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    result = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                   count, formats_host);
+    if (result == VK_SUCCESS || result == VK_INCOMPLETE)
+    {
+        for (i = 0; i < *count; i++)
+            formats[i].surfaceFormat = formats_host[i];
+    }
+
+    heap_free(formats_host);
+    return result;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice phys_dev,
+                                                             VkSurfaceKHR surface,
+                                                             uint32_t *count,
+                                                             VkSurfaceFormatKHR *formats)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -627,6 +689,8 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -654,6 +718,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From 2a8de2d522c876bbddc515ef7df6f968dd9e957c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:40:48 +0300
Subject: [PATCH 096/125] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfacePresentModesKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 49c5ddb3ceb..56eaf67e34a 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -64,6 +64,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice,
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -605,6 +606,19 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice ph
     return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  uint32_t *count,
+                                                                  VkPresentModeKHR *modes)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, modes);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -691,6 +705,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -720,6 +735,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From 7f79242ac0bb14293c0c07c5f2d51d66f12c078a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:42:03 +0300
Subject: [PATCH 097/125] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceSupportKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 56eaf67e34a..85d475ce609 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -65,6 +65,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice,
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -619,6 +620,19 @@ static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevi
     return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice phys_dev,
+                                                             uint32_t index,
+                                                             VkSurfaceKHR surface,
+                                                             VkBool32 *supported)
+{
+    TRACE("%p, %u, 0x%s, %p\n", phys_dev, index, wine_dbgstr_longlong(surface), supported);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -706,6 +720,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -736,6 +751,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From f343d5800dec8f2b9dac67e76922d0505b715891 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:45:12 +0300
Subject: [PATCH 098/125] winewayland.drv: Implement
 vkGetPhysicalDeviceWin32PresentationSupportKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 85d475ce609..f31fbf46334 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -66,6 +66,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, cons
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
+static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -633,6 +634,15 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice ph
     return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
 }
 
+static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice phys_dev,
+                                                                       uint32_t index)
+{
+    TRACE("%p %u\n", phys_dev, index);
+
+    return pvkGetPhysicalDeviceWaylandPresentationSupportKHR(phys_dev, index,
+                                                             process_wl_display);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -721,6 +731,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -752,6 +763,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From d8e755712ea4d0b745fd46646c0073552ebe5e1f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:59:01 +0300
Subject: [PATCH 099/125] winewayland.drv: Implement vkGetSwapchainImagesKHR

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index f31fbf46334..71d7091db91 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -67,6 +67,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSur
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
 static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
+static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -643,6 +644,14 @@ static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysica
                                                              process_wl_display);
 }
 
+static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    TRACE("%p, 0x%s %p %p\n", device, wine_dbgstr_longlong(swapchain), count, images);
+
+    return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -732,6 +741,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
+    LOAD_FUNCPTR(vkGetSwapchainImagesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -764,6 +774,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.33.0


From 89a1daef08a876c25af907987c6b39f488e82a71 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 16:35:45 +0300
Subject: [PATCH 100/125] winewayland.drv: Implement wine_get_native_surface

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 71d7091db91..81ed1a78cb1 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -713,6 +713,14 @@ static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR
     return res;
 }
 
+/* The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
+ * native surface. */
+static VkSurfaceKHR wayland_wine_get_native_surface(VkSurfaceKHR surface)
+{
+    TRACE("0x%s\n", wine_dbgstr_longlong(surface));
+    return surface;
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -776,6 +784,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
     .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
+    .p_wine_get_native_surface = wayland_wine_get_native_surface,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.33.0


From a2ac843ceb91ad163f3c7e127316ce23f4fa34e3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 16:25:16 +0300
Subject: [PATCH 101/125] winewayland.drv: Enable Vulkan support

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/gdi.c    | 17 +++++++++++++++++
 dlls/winewayland.drv/window.c |  5 +++++
 2 files changed, 22 insertions(+)

diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
index 4223cb98ed2..722f66a90f6 100644
--- a/dlls/winewayland.drv/gdi.c
+++ b/dlls/winewayland.drv/gdi.c
@@ -105,12 +105,29 @@ static struct opengl_funcs * CDECL WAYLAND_wine_get_wgl_driver(PHYSDEV dev, UINT
     return ret;
 }
 
+/**********************************************************************
+ *           WAYLAND_wine_get_vulkan_driver
+ */
+static const struct vulkan_funcs * CDECL WAYLAND_wine_get_vulkan_driver(PHYSDEV dev, UINT version)
+{
+    const struct vulkan_funcs *ret;
+
+    if (!(ret = wayland_get_vulkan_driver(version)))
+    {
+        dev = GET_NEXT_PHYSDEV(dev, wine_get_wgl_driver);
+        ret = dev->funcs->wine_get_vulkan_driver(dev, version);
+    }
+
+    return ret;
+}
+
 static const struct gdi_dc_funcs wayland_gdi_dc_funcs =
 {
     .pCreateDC = WAYLAND_CreateDC,
     .pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
     .pDeleteDC = WAYLAND_DeleteDC,
     .wine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
+    .wine_get_vulkan_driver = WAYLAND_wine_get_vulkan_driver,
     .priority = GDI_PRIORITY_GRAPHICS_DRV
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 1c39b591301..f7cf37fe382 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -318,6 +318,10 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     wayland = thread_init_wayland();
 
+    /* Force client to recreate Vulkan objects so that we use the
+     * updated backing surface in our internal Vulkan representations. */
+    wayland_invalidate_vulkan_objects(data->hwnd);
+
     if (data->wayland_surface)
     {
         wayland_surface_unref(data->wayland_surface);
@@ -599,6 +603,7 @@ void CDECL WAYLAND_DestroyWindow(HWND hwnd)
 
     if (!(data = wayland_win_data_get(hwnd))) return;
     wayland_destroy_gl_drawable(hwnd);
+    wayland_invalidate_vulkan_objects(hwnd);
     wayland_win_data_destroy(data);
 }
 
-- 
2.33.0


From f4ef5c59ecc9f78ee36c5e6c0211750b9cb0aaf7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 10:59:51 +0300
Subject: [PATCH 102/125] winewayland.drv: Skeleton data device support

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |   1 +
 dlls/winewayland.drv/wayland.c             |  15 ++++
 dlls/winewayland.drv/wayland_data_device.c | 100 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |  16 ++++
 4 files changed, 132 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 5a20d5fd547..1ecb6b05824 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -19,6 +19,7 @@ C_SRCS = \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_data_device.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
 	wayland_pointer.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index a49aac306f2..f6ee764dff6 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -139,6 +139,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        wayland->wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface,
+                             version < 3 ? version : 3);
+    }
     else if (strcmp(interface, "wl_output") == 0)
     {
         if (!wayland_output_create(wayland, id, version))
@@ -261,6 +267,9 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
 
+    if (wayland->wl_data_device_manager && wayland->wl_seat)
+        wayland_data_device_init(&wayland->data_device, wayland);
+
     /* Thread wayland instances have notification pipes to inform them when
      * there might be new events in their queues. The read part of the pipe
      * is also used as the wine server queue fd. */
@@ -314,6 +323,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->keyboard.wl_keyboard)
         wayland_keyboard_deinit(&wayland->keyboard);
 
+    if (wayland->data_device.wl_data_device)
+        wayland_data_device_deinit(&wayland->data_device);
+
+    if (wayland->wl_data_device_manager)
+        wl_data_device_manager_destroy(wayland->wl_data_device_manager);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..f73c541ea54
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,100 @@
+/*
+ * Wayland data device (clipboard and DnD) handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include "waylanddrv.h"
+
+#include "wine/heap.h"
+
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void data_device_data_offer(void *data,
+                                   struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_selection(void *data,
+                                  struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+}
+
+static const struct wl_data_device_listener data_device_listener = {
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection
+};
+
+/**********************************************************************
+ *          wayland_data_device_init
+ *
+ * Initializes the data_device extension in order to support clipboard
+ * operations.
+ */
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland)
+{
+    data_device->wayland = wayland;
+    data_device->wl_data_device =
+        wl_data_device_manager_get_data_device(wayland->wl_data_device_manager,
+                                               wayland->wl_seat);
+
+    wl_data_device_add_listener(data_device->wl_data_device, &data_device_listener,
+                                data_device);
+}
+
+/**********************************************************************
+ *          wayland_data_device_deinit
+ */
+void wayland_data_device_deinit(struct wayland_data_device *data_device)
+{
+    if (data_device->wl_data_device)
+        wl_data_device_destroy(data_device->wl_data_device);
+
+    memset(data_device, 0, sizeof(*data_device));
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c99bfa74742..fe14cccd759 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -110,6 +110,12 @@ struct wayland_pointer
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
 };
 
+struct wayland_data_device
+{
+    struct wayland *wayland;
+    struct wl_data_device *wl_data_device;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -125,6 +131,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct wl_data_device_manager *wl_data_device_manager;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
@@ -134,6 +141,7 @@ struct wayland
     struct wl_list toplevel_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
+    struct wayland_data_device data_device;
     DWORD last_dispatch_mask;
     uint32_t last_button_serial;
     DWORD last_event_type;
@@ -446,6 +454,14 @@ void wayland_update_front_buffer(HWND hwnd,
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version);
 void wayland_invalidate_vulkan_objects(HWND hwnd);
 
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland);
+void wayland_data_device_deinit(struct wayland_data_device *data_device);
+
 /**********************************************************************
  *          XKB helpers
  */
-- 
2.33.0


From 7a1eed0bd7bcf3138e0290f3c39298ba3b24df72 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 12:04:01 +0300
Subject: [PATCH 103/125] winewayland.drv: Handle data offers

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 156 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 2 files changed, 158 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index f73c541ea54..a3c55592c5d 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -24,15 +24,153 @@
 #include "waylanddrv.h"
 
 #include "wine/heap.h"
+#include "wine/debug.h"
+
+#include <assert.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+struct wayland_data_offer
+{
+    struct wayland *wayland;
+    struct wl_data_offer *wl_data_offer;
+    struct wl_array types;
+    uint32_t source_actions;
+    uint32_t action;
+};
+
+/* Normalize the mime type by skipping inconsequential characters, such as
+ * spaces and double quotes, and converting to lower case. */
+static char *normalize_mime_type(const char *mime)
+{
+    char *new_mime;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    cur_read = mime;
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime = heap_alloc(new_mime_len + 1);
+    cur_read = mime;
+    cur_write = new_mime;
+
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime;
+}
+
+/**********************************************************************
+ *          wl_data_offer handling
+ */
+
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer,
+                             const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    char **p;
+
+    p = wl_array_add(&data_offer->types, sizeof *p);
+    *p = normalize_mime_type(type);
+}
+
+static void data_offer_source_actions(void *data,
+                                      struct wl_data_offer *wl_data_offer,
+                                      uint32_t source_actions)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->source_actions = source_actions;
+}
+
+static void data_offer_action(void *data, struct wl_data_offer *wl_data_offer,
+                              uint32_t dnd_action)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->action = dnd_action;
+}
+
+static const struct wl_data_offer_listener data_offer_listener = {
+    data_offer_offer,
+    data_offer_source_actions,
+    data_offer_action
+};
+
+static void wayland_data_offer_create(struct wayland *wayland,
+                                      struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_offer *data_offer;
+
+    data_offer = heap_alloc_zero(sizeof(*data_offer));
+    if (!data_offer)
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->wayland = wayland;
+    data_offer->wl_data_offer = wl_data_offer;
+    wl_array_init(&data_offer->types);
+    wl_data_offer_add_listener(data_offer->wl_data_offer,
+                               &data_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+
+    wl_data_offer_destroy(data_offer->wl_data_offer);
+    wl_array_for_each(p, &data_offer->types)
+        heap_free(*p);
+    wl_array_release(&data_offer->types);
+
+    heap_free(data_offer);
+}
 
 /**********************************************************************
  *          wl_data_device handling
  */
 
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+}
+
+static void wayland_data_device_destroy_dnd_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->dnd_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->dnd_wl_data_offer = NULL;
+    }
+}
+
 static void data_device_data_offer(void *data,
                                    struct wl_data_device *wl_data_device,
                                    struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_offer_create(data_device->wayland, wl_data_offer);
 }
 
 static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
@@ -40,10 +178,19 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
                               wl_fixed_t x_w, wl_fixed_t y_w,
                               struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    /* Any previous dnd offer should have been freed by a drop or leave event. */
+    assert(data_device->dnd_wl_data_offer == NULL);
+
+    data_device->dnd_wl_data_offer = wl_data_offer;
 }
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
 static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
@@ -53,12 +200,21 @@ static void data_device_motion(void *data, struct wl_data_device *wl_data_device
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
 static void data_device_selection(void *data,
                                   struct wl_data_device *wl_data_device,
                                   struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    /* Destroy any previous data offer. */
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+
+    data_device->clipboard_wl_data_offer = wl_data_offer;
 }
 
 static const struct wl_data_device_listener data_device_listener = {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fe14cccd759..6b276adf26e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -114,6 +114,8 @@ struct wayland_data_device
 {
     struct wayland *wayland;
     struct wl_data_device *wl_data_device;
+    struct wl_data_offer *clipboard_wl_data_offer;
+    struct wl_data_offer *dnd_wl_data_offer;
 };
 
 struct wayland
-- 
2.33.0


From f21b8333c4e5545ebc32fceeff8799d6c2d4fe55 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 12:35:18 +0300
Subject: [PATCH 104/125] winewayland.drv: Create window to handle clipboard
 messages

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 58 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |  3 ++
 dlls/winewayland.drv/waylanddrv_main.c     | 10 ++++
 dlls/winewayland.drv/window.c              |  3 ++
 4 files changed, 74 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index a3c55592c5d..2dc15fae502 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -26,6 +26,8 @@
 #include "wine/heap.h"
 #include "wine/debug.h"
 
+#include "winuser.h"
+
 #include <assert.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
@@ -254,3 +256,59 @@ void wayland_data_device_deinit(struct wayland_data_device *data_device)
 
     memset(data_device, 0, sizeof(*data_device));
 }
+
+/**********************************************************************
+ *          clipboard window handling
+ */
+
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+        return TRUE;
+    }
+    return DefWindowProcW( hwnd, msg, wp, lp );
+}
+
+static HWND wayland_data_device_create_clipboard_window(void)
+{
+    static const WCHAR clipboard_classname[] = {
+        '_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d',
+        '_','m','a','n','a','g','e','r',0
+    };
+    WNDCLASSW class;
+    HWND clipboard_hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW(&class) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %u\n", GetLastError());
+        return 0;
+    }
+
+    if (!(clipboard_hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                         HWND_MESSAGE, 0, 0, NULL)))
+    {
+        ERR("failed to create clipboard window err %u\n", GetLastError());
+        return 0;
+    }
+
+    TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
+    return clipboard_hwnd;
+}
+
+/**********************************************************************
+ *          wayland_data_device_ensure_clipboard_window
+ *
+ * Creates (if not already created) the window which handles clipboard
+ * messages for the specified wayland instance.
+ */
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
+{
+    if (!wayland->clipboard_hwnd)
+        wayland->clipboard_hwnd = wayland_data_device_create_clipboard_window();
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6b276adf26e..e670f0c2b57 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -52,6 +52,7 @@ enum wayland_window_message
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001002,
     WM_WAYLAND_MODE_CHANGE = 0x80001003,
     WM_WAYLAND_POINTER_CONFINEMENT_UPDATE = 0x80001004,
+    WM_WAYLAND_CLIPBOARD_WINDOW_CREATE = 0x80001005,
 };
 
 enum wayland_configure_flags
@@ -149,6 +150,7 @@ struct wayland
     DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
+    HWND clipboard_hwnd;
     RECT cursor_clip;
 };
 
@@ -463,6 +465,7 @@ void wayland_invalidate_vulkan_objects(HWND hwnd);
 void wayland_data_device_init(struct wayland_data_device *data_device,
                               struct wayland *wayland);
 void wayland_data_device_deinit(struct wayland_data_device *data_device);
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland);
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 3dbe2840ce3..195b01ed04b 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -28,6 +28,8 @@
 #include "wine/heap.h"
 #include "wine/server.h"
 
+#include "winuser.h"
+
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -100,6 +102,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
     set_queue_fd(&data->wayland);
     TlsSetValue(thread_data_tls_index, data);
 
+    /* Create the clipboard window outside of thread init. We delay window
+     * creation since the thread init function may be invoked from within the
+     * context of a user32 function which holds the internal Wine user32 lock.
+     * In such a case creating the clipboard window would cause an internal
+     * user32 lock error. */
+    PostThreadMessageA(data->wayland.thread_id,
+                       WM_WAYLAND_CLIPBOARD_WINDOW_CREATE, 0, 0);
+
     return data;
 }
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f7cf37fe382..c9269f2f407 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1303,6 +1303,9 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_CLIPBOARD_WINDOW_CREATE:
+        wayland_data_device_ensure_clipboard_window(thread_wayland());
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.33.0


From b413af4265654d9b17707b2c2b2959c35d5b1ee8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:00:10 +0300
Subject: [PATCH 105/125] winewayland.drv: Skeleton data device format
 infrastructure

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |  1 +
 dlls/winewayland.drv/wayland_data_device.c    |  2 +
 .../wayland_data_device_format.c              | 72 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             | 14 ++++
 4 files changed, 89 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device_format.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 1ecb6b05824..7995b17b657 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -20,6 +20,7 @@ C_SRCS = \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
 	wayland_data_device.c \
+	wayland_data_device_format.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
 	wayland_pointer.c \
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 2dc15fae502..b3776534ba5 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -297,6 +297,8 @@ static HWND wayland_data_device_create_clipboard_window(void)
         return 0;
     }
 
+    wayland_data_device_init_formats();
+
     TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
     return clipboard_hwnd;
 }
diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
new file mode 100644
index 00000000000..8491a48d64b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -0,0 +1,72 @@
+/*
+ * Wayland data device format handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct wayland_data_device_format supported_formats[] =
+{
+    {NULL, 0, NULL, 0},
+};
+
+void wayland_data_device_init_formats(void)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = RegisterClipboardFormatA(format->register_name);
+        format++;
+    }
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (!strcmp(mime, format->mime_type))
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == clipboard_format)
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e670f0c2b57..499ae2cbce2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -119,6 +119,17 @@ struct wayland_data_device
     struct wl_data_offer *dnd_wl_data_offer;
 };
 
+struct wayland_data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    const char *register_name;
+    HGLOBAL (*import)(struct wayland_data_device_format *format,
+                      const void *data, size_t data_size);
+    void (*export)(struct wayland_data_device_format *format, int fd);
+    UINT_PTR extra;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -466,6 +477,9 @@ void wayland_data_device_init(struct wayland_data_device *data_device,
                               struct wayland *wayland);
 void wayland_data_device_deinit(struct wayland_data_device *data_device);
 void wayland_data_device_ensure_clipboard_window(struct wayland *wayland);
+void wayland_data_device_init_formats(void);
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime);
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format);
 
 /**********************************************************************
  *          XKB helpers
-- 
2.33.0


From 3dfacbf6341dba255abc474768ff2fbc53e3339d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:04:39 +0300
Subject: [PATCH 106/125] winewayland.drv: Support text/plain data device
 formats

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 62 +++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 8491a48d64b..6f658824901 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -22,12 +22,74 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/unicode.h"
+
 #include "winuser.h"
 
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static HGLOBAL import_text_as_unicode(struct wayland_data_device_format *format,
+                                      const void *data, size_t data_size)
+{
+    int wide_count;
+    HGLOBAL mem_handle;
+    void *mem;
+
+    wide_count = MultiByteToWideChar(format->extra, 0, data, data_size, NULL, 0);
+    mem_handle = GlobalAlloc(GMEM_MOVEABLE, wide_count * sizeof(WCHAR) + 1);
+    if (!mem_handle || !(mem = GlobalLock(mem_handle)))
+    {
+        if (mem_handle) GlobalFree(mem_handle);
+        return NULL;
+    }
+
+    MultiByteToWideChar(CP_UTF8, 0, data, data_size, mem, wide_count);
+    ((unsigned char*)mem)[wide_count * sizeof(WCHAR)] = 0;
+    GlobalUnlock(mem_handle);
+
+    return mem_handle;
+}
+
+static void export_text(struct wayland_data_device_format *format, int fd)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+    int byte_count;
+    char *bytes;
+
+    if (!OpenClipboard(thread_wayland()->clipboard_hwnd))
+    {
+        WARN("failed to open clipboard for export\n");
+        return;
+    }
+
+    mem_handle = GetClipboardData(format->clipboard_format);
+    mem = GlobalLock(mem_handle);
+
+    byte_count = WideCharToMultiByte(format->extra, 0, mem, -1, NULL, 0, NULL, NULL);
+    bytes = heap_alloc(byte_count);
+    WideCharToMultiByte(format->extra, 0, mem, -1, bytes, byte_count, NULL, NULL);
+    write(fd, bytes, byte_count);
+    heap_free(bytes);
+
+    GlobalUnlock(mem_handle);
+
+    CloseClipboard();
+}
+
+#define CP_ASCII 20127
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct wayland_data_device_format supported_formats[] =
 {
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
+    {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.33.0


From 766847782c4d2728e95b2936e08856f9e8fd3356 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:06:57 +0300
Subject: [PATCH 107/125] winewayland.drv: Support RTF data device format

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 42 +++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 6f658824901..fc31d428636 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -81,6 +81,46 @@ static void export_text(struct wayland_data_device_format *format, int fd)
     CloseClipboard();
 }
 
+static HGLOBAL import_data(struct wayland_data_device_format *format,
+                           const void *data, size_t data_size)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+
+    mem_handle = GlobalAlloc(GMEM_MOVEABLE, data_size);
+    if (!mem_handle || !(mem = GlobalLock(mem_handle)))
+    {
+        if (mem_handle) GlobalFree(mem_handle);
+        return NULL;
+    }
+
+    memcpy(mem, data, data_size);
+    GlobalUnlock(mem_handle);
+
+    return mem_handle;
+}
+
+static void export_data(struct wayland_data_device_format *format, int fd)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+
+    if (!OpenClipboard(thread_wayland()->clipboard_hwnd))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    mem_handle = GetClipboardData(format->clipboard_format);
+    mem = GlobalLock(mem_handle);
+
+    write(fd, mem, GlobalSize(mem_handle));
+
+    GlobalUnlock(mem_handle);
+
+    CloseClipboard();
+}
+
 #define CP_ASCII 20127
 
 /* Order is important. When selecting a mime-type for a clipboard format we
@@ -90,6 +130,8 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
     {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/rtf", 0, "Rich Text Format", import_data, export_data, 0},
+    {"text/richtext", 0, "Rich Text Format", import_data, export_data, 0},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.33.0


From a1b89b7a25d176f620b03f0df809c3c1fb1a53bb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:12:09 +0300
Subject: [PATCH 108/125] winewayland.drv: Support text/uri-list data device
 format

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 199 ++++++++++++++++++
 1 file changed, 199 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index fc31d428636..d97737ac8c4 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -26,8 +26,10 @@
 #include "wine/heap.h"
 #include "wine/unicode.h"
 
+#include "shlobj.h"
 #include "winuser.h"
 
+#include <errno.h>
 #include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
@@ -121,6 +123,202 @@ static void export_data(struct wayland_data_device_format *format, int fd)
     CloseClipboard();
 }
 
+/* Adapted from winex11.drv/clipboard.c */
+static char *decode_uri(const char *uri, size_t uri_length)
+{
+    char *decoded = heap_alloc_zero(uri_length + 1);
+    size_t uri_i = 0;
+    size_t decoded_i = 0;
+
+    if (decoded == NULL)
+        goto err;
+
+    while (uri_i < uri_length)
+    {
+        if (uri[uri_i] == '%')
+        {
+            unsigned long number;
+            char buffer[3];
+
+            if (uri_i + 1 == uri_length || uri_i + 2 == uri_length)
+                goto err;
+
+            buffer[0] = uri[uri_i + 1];
+            buffer[1] = uri[uri_i + 2];
+            buffer[2] = '\0';
+            errno = 0;
+            number = strtoul(buffer, NULL, 16);
+            if (errno != 0)
+                goto err;
+            decoded[decoded_i] = number;
+
+            uri_i += 3;
+            decoded_i++;
+        }
+        else
+        {
+            decoded[decoded_i++] = uri[uri_i++];
+        }
+    }
+
+    decoded[decoded_i] = '\0';
+
+    return decoded;
+
+err:
+    heap_free(decoded);
+    return NULL;
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static WCHAR* decoded_uri_to_dos(const char *uri)
+{
+    WCHAR *ret = NULL;
+
+    if (strncmp(uri, "file:/", 6))
+        return NULL;
+
+    if (uri[6] == '/')
+    {
+        if (uri[7] == '/')
+        {
+            /* file:///path/to/file (nautilus, thunar) */
+            ret = wine_get_dos_file_name(&uri[7]);
+        }
+        else if (uri[7])
+        {
+            /* file://hostname/path/to/file (X file drag spec) */
+            char hostname[256];
+            char *path = strchr(&uri[7], '/');
+            if (path)
+            {
+                *path = '\0';
+                if (strcmp(&uri[7], "localhost") == 0)
+                {
+                    *path = '/';
+                    ret = wine_get_dos_file_name(path);
+                }
+                else if (gethostname(hostname, sizeof(hostname)) == 0)
+                {
+                    if (strcmp(hostname, &uri[7]) == 0)
+                    {
+                        *path = '/';
+                        ret = wine_get_dos_file_name(path);
+                    }
+                }
+            }
+        }
+    }
+    else if (uri[6])
+    {
+        /* file:/path/to/file (konqueror) */
+        ret = wine_get_dos_file_name(&uri[5]);
+    }
+
+    return ret;
+}
+
+static HGLOBAL import_uri_list(struct wayland_data_device_format *format,
+                               const void *data, size_t data_size)
+{
+    HGLOBAL mem_handle = 0;
+    DROPFILES *drop_files;
+    const char *data_end = (const char *) data + data_size;
+    const char *line_start = data;
+    const char *line_end;
+    WCHAR **path;
+    struct wl_array paths;
+    size_t total_chars = 0;
+    WCHAR *dst;
+
+    TRACE("data=%p size=%lu\n", data, (unsigned long)data_size);
+
+    wl_array_init(&paths);
+
+    while (line_start < data_end)
+    {
+        line_end = strchr(line_start, '\r');
+        if (line_end == NULL || line_end == data_end - 1 || line_end[1] != '\n')
+        {
+            WARN("URI list line doesn't end in \\r\\n\n");
+            break;
+        }
+
+        if (line_start[0] != '#')
+        {
+            char *decoded_uri = decode_uri(line_start, line_end - line_start);
+            TRACE("decoded_uri=%s\n", decoded_uri);
+            path = wl_array_add(&paths, sizeof *path);
+            if (!path)
+                goto out;
+            *path = decoded_uri_to_dos(decoded_uri);
+            total_chars += strlenW(*path) + 1;
+            heap_free(decoded_uri);
+        }
+
+        line_start = line_end + 2;
+    }
+
+    /* DROPFILES points to an array of consecutive null terminated WCHAR strings,
+     * followed by a final 0 WCHAR to denote the end of the array. We place that
+     * array just after the DROPFILE struct itself. */
+    mem_handle = GlobalAlloc(GMEM_MOVEABLE, sizeof(DROPFILES) + (total_chars + 1) * sizeof(WCHAR));
+    if (!mem_handle || !(drop_files = GlobalLock(mem_handle)))
+    {
+        if (mem_handle)
+        {
+            GlobalFree(mem_handle);
+            mem_handle = NULL;
+        }
+        goto out;
+    }
+
+    drop_files->pFiles = sizeof(*drop_files);
+    drop_files->pt.x = 0;
+    drop_files->pt.y = 0;
+    drop_files->fNC = FALSE;
+    drop_files->fWide = TRUE;
+
+    dst = (WCHAR*)(drop_files + 1);
+    wl_array_for_each(path, &paths)
+    {
+        strcpyW(dst, *path);
+        dst += strlenW(*path) + 1;
+    }
+    *dst = 0;
+
+    GlobalUnlock(mem_handle);
+
+out:
+    wl_array_for_each(path, &paths)
+        heap_free(*path);
+
+    wl_array_release(&paths);
+
+    return mem_handle;
+}
+
+static void export_uri_list(struct wayland_data_device_format *format, int fd)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+
+    if (!OpenClipboard(thread_wayland()->clipboard_hwnd))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    mem_handle = GetClipboardData(format->clipboard_format);
+    mem = GlobalLock(mem_handle);
+
+    write(fd, mem, GlobalSize(mem_handle));
+
+    GlobalUnlock(mem_handle);
+
+    CloseClipboard();
+}
+
 #define CP_ASCII 20127
 
 /* Order is important. When selecting a mime-type for a clipboard format we
@@ -132,6 +330,7 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/rtf", 0, "Rich Text Format", import_data, export_data, 0},
     {"text/richtext", 0, "Rich Text Format", import_data, export_data, 0},
+    {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_uri_list, 0},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.33.0


From 86a560e21ac237b3e87433f3ce7d942a621b311f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:14:04 +0300
Subject: [PATCH 109/125] winewayland.drv: Support common image data device
 format

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device_format.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index d97737ac8c4..9ce75b686c2 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -331,6 +331,10 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/rtf", 0, "Rich Text Format", import_data, export_data, 0},
     {"text/richtext", 0, "Rich Text Format", import_data, export_data, 0},
     {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_uri_list, 0},
+    {"image/tiff", CF_TIFF, 0, import_data, export_data, 0},
+    {"image/png", 0, "PNG", import_data, export_data, 0},
+    {"image/jpeg", 0, "JFIF", import_data, export_data, 0},
+    {"image/gif", 0, "GIF", import_data, export_data, 0},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.33.0


From 521d930630fa8fdc5ada7bd84d797d3592f4564a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:22:00 +0300
Subject: [PATCH 110/125] winewayland.drv: Handle WM_CLIPBOARDUPDATE

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 102 +++++++++++++++++++++
 1 file changed, 102 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index b3776534ba5..2248b3bbb57 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -32,6 +32,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
 struct wayland_data_offer
 {
     struct wayland *wayland;
@@ -257,16 +259,113 @@ void wayland_data_device_deinit(struct wayland_data_device *data_device)
     memset(data_device, 0, sizeof(*data_device));
 }
 
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct wayland_data_device_format *format =
+        wayland_data_device_format_for_mime_type(mime_type);
+
+    TRACE("source=%p mime_type=%s\n", source, mime_type);
+
+    if (format) format->export(format, fd);
+
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    TRACE("source=%p\n", source);
+    wl_data_source_destroy(source);
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener = {
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
 /**********************************************************************
  *          clipboard window handling
  */
 
+static void clipboard_update(void)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wl_data_source *source;
+    UINT clipboard_format = 0;
+
+    TRACE("WM_CLIPBOARDUPDATE wayland %p enter_serial=%d\n",
+          wayland, wayland ? wayland->keyboard.enter_serial : -1);
+
+    if (!wayland || !wayland->keyboard.enter_serial)
+        return;
+
+    if (!OpenClipboard(wayland->clipboard_hwnd))
+    {
+        TRACE("failed to open clipboard\n");
+        return;
+    }
+
+    source = wl_data_device_manager_create_data_source(wayland->wl_data_device_manager);
+
+    while ((clipboard_format = EnumClipboardFormats(clipboard_format)))
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_clipboard_format(clipboard_format);
+        if (format)
+        {
+            TRACE("Offering source=%p mime=%s\n", source, format->mime_type);
+            wl_data_source_offer(source, format->mime_type);
+        }
+    }
+
+    /* Add a special entry so that we can detect when an offer is coming from us. */
+    wl_data_source_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
+
+    wl_data_source_add_listener(source, &data_source_listener, NULL);
+    wl_data_device_set_selection(wayland->data_device.wl_data_device, source,
+                                 wayland->keyboard.enter_serial);
+
+    CloseClipboard();
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
     {
     case WM_NCCREATE:
         return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        TRACE("WM_CLIPBOARDUPDATE\n");
+        /* Ignore our own updates */
+        if (GetClipboardOwner() != hwnd) clipboard_update();
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
@@ -299,6 +398,9 @@ static HWND wayland_data_device_create_clipboard_window(void)
 
     wayland_data_device_init_formats();
 
+    if (!AddClipboardFormatListener(clipboard_hwnd))
+        ERR("failed to set clipboard listener %u\n", GetLastError());
+
     TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
     return clipboard_hwnd;
 }
-- 
2.33.0


From a7954488e34d7d7ee8e40a36fe226a4b1d3b8787 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:33:25 +0300
Subject: [PATCH 111/125] winewayland.drv: Handle WM_RENDERFORMAT

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 125 +++++++++++++++++++++
 1 file changed, 125 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 2248b3bbb57..36903b5346e 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -29,6 +29,8 @@
 #include "winuser.h"
 
 #include <assert.h>
+#include <errno.h>
+#include <poll.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
@@ -142,6 +144,98 @@ static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
     heap_free(data_offer);
 }
 
+static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
+                                             const char *mime_type,
+                                             size_t *size_out)
+{
+    int data_pipe[2] = {-1, -1};
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    buffer = heap_alloc(buffer_size);
+    if (buffer == NULL)
+        goto out;
+
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+        goto out;
+
+    wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(data_offer->wayland->wl_display);
+
+    do
+    {
+        struct pollfd pfd = { .fd = data_pipe[0], .events = POLLIN };
+        int ret;
+
+        /* Wait a limited amount of time for the data to arrive, since otherwise
+         * a misbehaving data source could block us indefinitely. */
+        while ((ret = poll(&pfd, 1, 3000)) == -1 && errno == EINTR) continue;
+        if (ret <= 0 || !(pfd.revents & (POLLIN | POLLHUP)))
+        {
+            TRACE("failed polling data offer pipe ret=%d errno=%d revents=0x%x\n",
+                  ret, ret == -1 ? errno : 0, pfd.revents);
+            total = 0;
+            goto out;
+        }
+
+        nread = read(data_pipe[0], buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            ERR("failed to read data offer pipe\n");
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                buffer_size += 4096;
+                buffer = heap_realloc(buffer, buffer_size);
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("received %d bytes\n", total);
+
+out:
+    if (data_pipe[0] >= 0)
+        close(data_pipe[0]);
+
+    if (total == 0 && buffer != NULL)
+    {
+        heap_free(buffer);
+        buffer = NULL;
+    }
+
+    *size_out = total;
+
+    return buffer;
+}
+
+static HGLOBAL wayland_data_offer_import_format(struct wayland_data_offer *data_offer,
+                                                struct wayland_data_device_format *format)
+{
+    size_t data_size;
+    void *data;
+    HGLOBAL mem_handle;
+
+    data = wayland_data_offer_receive_data(data_offer, format->mime_type, &data_size);
+    if (!data)
+        return NULL;
+
+    mem_handle = format->import(format, data, data_size);
+
+    heap_free(data);
+
+    return mem_handle;
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
@@ -355,6 +449,33 @@ static void clipboard_update(void)
     CloseClipboard();
 }
 
+static void clipboard_render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device;
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    data_device = wl_data_device_get_user_data(thread_wayland()->data_device.wl_data_device);
+    if (!data_device->clipboard_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    if (!data_offer)
+        return;
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format && format->clipboard_format == clipboard_format)
+        {
+            HGLOBAL mem_handle = wayland_data_offer_import_format(data_offer, format);
+            SetClipboardData(format->clipboard_format, mem_handle);
+            break;
+        }
+    }
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
@@ -366,6 +487,10 @@ static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM
         /* Ignore our own updates */
         if (GetClipboardOwner() != hwnd) clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        TRACE("WM_RENDERFORMAT: %ld\n", wp);
+        clipboard_render_format(wp);
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
-- 
2.33.0


From cb8169a52c26fd58bdf6b1277d4d39009949ce98 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:35:36 +0300
Subject: [PATCH 112/125] winewayland.drv: Handle WM_DESTROYCLIPBOARD

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 36903b5346e..7219219d997 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -476,6 +476,14 @@ static void clipboard_render_format(UINT clipboard_format)
     }
 }
 
+static void clipboard_destroy(void)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_device *data_device =
+        wl_data_device_get_user_data(wayland->data_device.wl_data_device);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
@@ -491,6 +499,10 @@ static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM
         TRACE("WM_RENDERFORMAT: %ld\n", wp);
         clipboard_render_format(wp);
         break;
+    case WM_DESTROYCLIPBOARD:
+        TRACE("WM_DESTROYCLIPBOARD: lost ownership clipboard_hwnd=%p\n", hwnd);
+        clipboard_destroy();
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
-- 
2.33.0


From ba97a09ac835acfbabe1fd3d20742fd7554bf7a6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:27:47 +0300
Subject: [PATCH 113/125] winewayland.drv: Handle data device selection event

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 66 ++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 7219219d997..94aff3af915 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -308,11 +308,77 @@ static void data_device_selection(void *data,
                                   struct wl_data_offer *wl_data_offer)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    TRACE("wl_data_offer=%u\n",
+          wl_data_offer ? wl_proxy_get_id((struct wl_proxy*)wl_data_offer) : 0);
+
+    /* We may get a selection event before we have had a chance to create the
+     * clipboard window after thread init (see wayland_init_thread_data), so
+     * we need to ensure we have a valid window here. */
+    wayland_data_device_ensure_clipboard_window(wayland);
 
     /* Destroy any previous data offer. */
     wayland_data_device_destroy_clipboard_data_offer(data_device);
 
+    /* If we didn't get an offer and we are the clipboard owner, empty the
+     * clipboard. Otherwise ignore the empty offer completely. */
+    if (!wl_data_offer)
+    {
+        if (GetClipboardOwner() == wayland->clipboard_hwnd)
+        {
+            OpenClipboard(NULL);
+            EmptyClipboard();
+            CloseClipboard();
+        }
+        return;
+    }
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * from us to notify external wayland clients about a wine clipboard update.
+     * The clipboard already contains all the required data, plus we need to ignore
+     * this in order to avoid an endless notification loop. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("ignoring offer produced by winewayland\n");
+            goto ignore_selection;
+        }
+    }
+
+    if (!OpenClipboard(data_offer->wayland->clipboard_hwnd))
+    {
+        WARN("failed to open clipboard for selection\n");
+        goto ignore_selection;
+    }
+
+    EmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            TRACE("Avalaible clipboard format for %s => %u\n", *p, format->clipboard_format);
+            SetClipboardData(format->clipboard_format, 0);
+        }
+    }
+
+    CloseClipboard();
+
     data_device->clipboard_wl_data_offer = wl_data_offer;
+
+    return;
+
+ignore_selection:
+    wayland_data_offer_destroy(data_offer);
 }
 
 static const struct wl_data_device_listener data_device_listener = {
-- 
2.33.0


From 73aa4de01cb0958e695784adde5f6ad126502e3c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:27:13 +0300
Subject: [PATCH 114/125] winewayland.drv: Skeleton IDataObject for data offers

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |   2 +-
 dlls/winewayland.drv/wayland_data_device.c | 134 +++++++++++++++++++++
 2 files changed, 135 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 7995b17b657..86c276f67c9 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32
+IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32 uuid
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 94aff3af915..d1def56b2b9 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -26,6 +26,8 @@
 #include "wine/heap.h"
 #include "wine/debug.h"
 
+#define COBJMACROS
+#include "objidl.h"
 #include "winuser.h"
 
 #include <assert.h>
@@ -36,6 +38,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
 #define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
 
+static IDataObjectVtbl dataOfferDataObjectVtbl;
+
 struct wayland_data_offer
 {
     struct wayland *wayland;
@@ -43,6 +47,7 @@ struct wayland_data_offer
     struct wl_array types;
     uint32_t source_actions;
     uint32_t action;
+    IDataObject data_object;
 };
 
 /* Normalize the mime type by skipping inconsequential characters, such as
@@ -128,6 +133,7 @@ static void wayland_data_offer_create(struct wayland *wayland,
     data_offer->wayland = wayland;
     data_offer->wl_data_offer = wl_data_offer;
     wl_array_init(&data_offer->types);
+    data_offer->data_object.lpVtbl = &dataOfferDataObjectVtbl;
     wl_data_offer_add_listener(data_offer->wl_data_offer,
                                &data_offer_listener, data_offer);
 }
@@ -619,3 +625,131 @@ void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
     if (!wayland->clipboard_hwnd)
         wayland->clipboard_hwnd = wayland_data_device_create_clipboard_window();
 }
+
+/*********************************************************
+ * Implementation of IDataObject for wayland data offers *
+ *********************************************************/
+
+static HRESULT WINAPI dataOfferDataObject_QueryInterface(IDataObject *data_object,
+                                                         REFIID riid, void **object)
+{
+    TRACE("(%p, %s, %p)\n", data_object, debugstr_guid(riid), object);
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDataObject))
+    {
+        *object = data_object;
+        IDataObject_AddRef(data_object);
+        return S_OK;
+    }
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI dataOfferDataObject_AddRef(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when the data_offer is destroyed, so we don't care about proper
+     * reference tracking. */
+    return 2;
+}
+
+static ULONG WINAPI dataOfferDataObject_Release(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when, so we don't care about proper reference tracking. */
+    return 1;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium)
+{
+    TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
+
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
+                                                      FORMATETC *format_etc,
+                                                      STGMEDIUM *medium)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, medium);
+    return DATA_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
+                                                       FORMATETC *format_etc)
+{
+    TRACE("(%p, %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%d}\n",
+          data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
+          format_etc->cfFormat);
+
+    return DV_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetCanonicalFormatEtc(IDataObject *data_object,
+                                                                FORMATETC *format_etc,
+                                                                FORMATETC *format_etc_out)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, format_etc_out);
+    format_etc_out->ptd = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium, BOOL release)
+{
+    FIXME("(%p, %p, %p, %s): stub\n", data_object, format_etc,
+          medium, release ? "TRUE" : "FALSE");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
+                                                        DWORD direction,
+                                                        IEnumFORMATETC **enum_format_etc)
+{
+    TRACE("(%p, %u, %p)\n", data_object, direction, enum_format_etc);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
+                                                  FORMATETC *format_etc, DWORD advf,
+                                                  IAdviseSink *advise_sink,
+                                                  DWORD *connection)
+{
+    FIXME("(%p, %p, %u, %p, %p): stub\n", data_object, format_etc, advf,
+          advise_sink, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DUnadvise(IDataObject *data_object,
+                                                    DWORD connection)
+{
+    FIXME("(%p, %u): stub\n", data_object, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumDAdvise(IDataObject *data_object,
+                                                      IEnumSTATDATA **enum_advise)
+{
+    FIXME("(%p, %p): stub\n", data_object, enum_advise);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static IDataObjectVtbl dataOfferDataObjectVtbl =
+{
+    dataOfferDataObject_QueryInterface,
+    dataOfferDataObject_AddRef,
+    dataOfferDataObject_Release,
+    dataOfferDataObject_GetData,
+    dataOfferDataObject_GetDataHere,
+    dataOfferDataObject_QueryGetData,
+    dataOfferDataObject_GetCanonicalFormatEtc,
+    dataOfferDataObject_SetData,
+    dataOfferDataObject_EnumFormatEtc,
+    dataOfferDataObject_DAdvise,
+    dataOfferDataObject_DUnadvise,
+    dataOfferDataObject_EnumDAdvise
+};
-- 
2.33.0


From 5fb294db3aa08e6f78293531dae51ad5a84ace14 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:30:21 +0300
Subject: [PATCH 115/125] winewayland.drv: Implement IDataObject::QueryGetData
 for data offers

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 28 ++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index d1def56b2b9..ecad41b9002 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -242,6 +242,11 @@ static HGLOBAL wayland_data_offer_import_format(struct wayland_data_offer *data_
     return mem_handle;
 }
 
+static struct wayland_data_offer *wayland_data_offer_from_data_object(struct IDataObject *data_object)
+{
+    return CONTAINING_RECORD(data_object, struct wayland_data_offer, data_object);
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
@@ -681,10 +686,33 @@ static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
 static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
                                                        FORMATETC *format_etc)
 {
+    struct wayland_data_offer *data_offer;
+    char **p;
+
     TRACE("(%p, %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%d}\n",
           data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
           format_etc->cfFormat);
 
+    if (format_etc->tymed && !(format_etc->tymed & TYMED_HGLOBAL))
+    {
+        FIXME("only HGLOBAL medium types supported right now\n");
+        return DV_E_TYMED;
+    }
+
+    data_offer = wayland_data_offer_from_data_object(data_object);
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format && format->clipboard_format == format_etc->cfFormat)
+        {
+            TRACE("found offer %s for clipboard format %u\n", *p, format->clipboard_format);
+            return S_OK;
+        }
+    }
+
+    TRACE("didn't find offer for clipboard form %u\n", format_etc->cfFormat);
     return DV_E_FORMATETC;
 }
 
-- 
2.33.0


From 6197c566c755a2788330027c31098955b48488af Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:59:58 +0300
Subject: [PATCH 116/125] winewayland.drv: Implement IDataObject::GetData for
 data offers

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 28 ++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index ecad41b9002..c7cb760cf8b 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -21,6 +21,8 @@
 #include "config.h"
 #include "wine/port.h"
 
+#define NONAMELESSUNION
+
 #include "waylanddrv.h"
 
 #include "wine/heap.h"
@@ -47,6 +49,7 @@ struct wayland_data_offer
     struct wl_array types;
     uint32_t source_actions;
     uint32_t action;
+    const char *accepted_mime_type;
     IDataObject data_object;
 };
 
@@ -670,8 +673,32 @@ static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
                                                   FORMATETC *format_etc,
                                                   STGMEDIUM *medium)
 {
+    HRESULT hr;
+    struct wayland_data_offer *data_offer;
+    struct wayland_data_device_format *format;
+
     TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
 
+    hr = IDataObject_QueryGetData(data_object, format_etc);
+    if (!SUCCEEDED(hr))
+        return hr;
+
+    data_offer = wayland_data_offer_from_data_object(data_object);
+
+    /* A successful QueryGetData invocation sets a valid accepted_mime_type */
+    assert(data_offer->accepted_mime_type);
+
+    format = wayland_data_device_format_for_mime_type(data_offer->accepted_mime_type);
+    if (format)
+    {
+        medium->tymed = TYMED_HGLOBAL;
+        medium->u.hGlobal = wayland_data_offer_import_format(data_offer, format);
+        if (medium->u.hGlobal == NULL)
+            return E_OUTOFMEMORY;
+        medium->pUnkForRelease = 0;
+        return S_OK;
+    }
+
     return E_UNEXPECTED;
 }
 
@@ -708,6 +735,7 @@ static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
         if (format && format->clipboard_format == format_etc->cfFormat)
         {
             TRACE("found offer %s for clipboard format %u\n", *p, format->clipboard_format);
+            data_offer->accepted_mime_type = format->mime_type;
             return S_OK;
         }
     }
-- 
2.33.0


From 72c0bf279d1d31f83c3500d990470c77d6e6ca2e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 18:36:38 +0300
Subject: [PATCH 117/125] winewayland.drv: Implement IDataObject::EnumFormatEtc
 for data offers

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |  1 +
 dlls/winewayland.drv/wayland_data_device.c | 61 +++++++++++++++++++++-
 2 files changed, 61 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 86c276f67c9..03feefe72b3 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,6 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32 uuid
+DELAYIMPORTS = shell32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index c7cb760cf8b..41970761c69 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -30,6 +30,7 @@
 
 #define COBJMACROS
 #include "objidl.h"
+#include "shlobj.h"
 #include "winuser.h"
 
 #include <assert.h>
@@ -762,12 +763,70 @@ static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
     return E_NOTIMPL;
 }
 
+static BOOL formats_etc_contains_clipboard_format(FORMATETC *formats_etc,
+                                                  size_t formats_etc_count,
+                                                  UINT clipboard_format)
+{
+    size_t i;
+
+    for (i = 0; i < formats_etc_count; i++)
+    {
+        if (formats_etc[i].cfFormat == clipboard_format)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
 static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
                                                         DWORD direction,
                                                         IEnumFORMATETC **enum_format_etc)
 {
+    HRESULT hr;
+    FORMATETC *formats_etc;
+    size_t formats_etc_count = 0;
+    struct wayland_data_offer *data_offer;
+    char **p;
+
     TRACE("(%p, %u, %p)\n", data_object, direction, enum_format_etc);
-    return E_NOTIMPL;
+
+    if (direction != DATADIR_GET)
+    {
+        FIXME("only the get direction is implemented\n");
+        return E_NOTIMPL;
+    }
+
+    data_offer = wayland_data_offer_from_data_object(data_object);
+
+    /* Allocate space for all offered mime types, although we may not use them all */
+    formats_etc = heap_alloc((data_offer->types.size / sizeof(char *)) * sizeof(FORMATETC));
+    if (!formats_etc)
+        return E_OUTOFMEMORY;
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format &&
+            !formats_etc_contains_clipboard_format(formats_etc, formats_etc_count,
+                                                   format->clipboard_format))
+        {
+            FORMATETC *current= &formats_etc[formats_etc_count];
+
+            current->cfFormat = format->clipboard_format;
+            current->ptd = NULL;
+            current->dwAspect = DVASPECT_CONTENT;
+            current->lindex = -1;
+            current->tymed = TYMED_HGLOBAL;
+
+            formats_etc_count += 1;
+        }
+    }
+
+    hr = SHCreateStdEnumFmtEtc(formats_etc_count, formats_etc, enum_format_etc);
+    heap_free(formats_etc);
+
+    return hr;
 }
 
 static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
-- 
2.33.0


From acac24d62dd76da1c31142927b410fc45f0d6624 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 12:43:19 +0300
Subject: [PATCH 118/125] winewayland.drv: Implement functions for IDropTarget
 discovery

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |   2 +-
 dlls/winewayland.drv/wayland_data_device.c | 100 +++++++++++++++++++++
 2 files changed, 101 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 03feefe72b3..f982e7df488 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 rpcrt4 setupapi user32 uuid
-DELAYIMPORTS = shell32
+DELAYIMPORTS = ole32 shell32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 41970761c69..6bd34e409aa 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -85,6 +85,106 @@ static char *normalize_mime_type(const char *mime)
     return new_mime;
 }
 
+/**********************************************************************
+ *          IDropTarget discovery
+ *
+ * Based on functions in dlls/ole32/ole2.c
+ */
+
+static HANDLE get_drop_target_local_handle(HWND hwnd)
+{
+    static const WCHAR prop_marshalleddrop_target[] =
+        {'W','i','n','e','M','a','r','s','h','a','l','l','e','d',
+         'D','r','o','p','T','a','r','g','e','t',0};
+    HANDLE handle;
+    HANDLE local_handle = 0;
+
+    handle = GetPropW(hwnd, prop_marshalleddrop_target);
+    if (handle)
+    {
+        DWORD pid;
+        HANDLE process;
+
+        GetWindowThreadProcessId(hwnd, &pid);
+        process = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid);
+        if (process)
+        {
+            DuplicateHandle(process, handle, GetCurrentProcess(), &local_handle,
+                            0, FALSE, DUPLICATE_SAME_ACCESS);
+            CloseHandle(process);
+        }
+    }
+    return local_handle;
+}
+
+static HRESULT create_stream_from_map(HANDLE map, IStream **stream)
+{
+    HRESULT hr = E_OUTOFMEMORY;
+    HGLOBAL hmem;
+    void *data;
+    MEMORY_BASIC_INFORMATION info;
+
+    data = MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
+    if(!data) return hr;
+
+    VirtualQuery(data, &info, sizeof(info));
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, info.RegionSize);
+    if(hmem)
+    {
+        memcpy(GlobalLock(hmem), data, info.RegionSize);
+        GlobalUnlock(hmem);
+        hr = CreateStreamOnHGlobal(hmem, TRUE, stream);
+    }
+    UnmapViewOfFile(data);
+    return hr;
+}
+
+static IDropTarget* get_drop_target_pointer(HWND hwnd)
+{
+    IDropTarget *drop_target = NULL;
+    HANDLE map;
+    IStream *stream;
+
+    map = get_drop_target_local_handle(hwnd);
+    if(!map) return NULL;
+
+    if(SUCCEEDED(create_stream_from_map(map, &stream)))
+    {
+        CoUnmarshalInterface(stream, &IID_IDropTarget, (void**)&drop_target);
+        IStream_Release(stream);
+    }
+    CloseHandle(map);
+    return drop_target;
+}
+
+static IDropTarget *drop_target_from_window_point(HWND hwnd, POINT point)
+{
+    HWND child;
+    IDropTarget *drop_target;
+    HWND orig_hwnd = hwnd;
+    POINT orig_point = point;
+
+    /* Find the deepest child window. */
+    ScreenToClient(hwnd, &point);
+    while ((child = ChildWindowFromPointEx(hwnd, point, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE)) &&
+            child != hwnd)
+    {
+        MapWindowPoints(hwnd, child, &point, 1);
+        hwnd = child;
+    }
+
+    /* Ascend the children hierarchy until we find one that accepts drops. */
+    do
+    {
+        drop_target = get_drop_target_pointer(hwnd);
+    } while (drop_target == NULL && (hwnd = GetParent(hwnd)) != NULL);
+
+    TRACE("hwnd=%p point=(%d,%d) => dnd_hwnd=%p drop_target=%p\n",
+          orig_hwnd, orig_point.x, orig_point.y, hwnd, drop_target);
+    return drop_target;
+}
+
 /**********************************************************************
  *          wl_data_offer handling
  */
-- 
2.33.0


From 21a690cffd8d2930acdea3a393f3fb9eb50e2e33 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 12:52:27 +0300
Subject: [PATCH 119/125] winewayland.drv: Handle the wl_data_device::enter
 event

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 65 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |  4 ++
 2 files changed, 69 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 6bd34e409aa..ad112ed2cd8 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -85,6 +85,20 @@ static char *normalize_mime_type(const char *mime)
     return new_mime;
 }
 
+static DWORD dnd_actions_to_drop_effect(uint32_t actions)
+{
+    DWORD drop_effect = 0;
+
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+        drop_effect |= DROPEFFECT_COPY;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+        drop_effect |= DROPEFFECT_MOVE;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+        drop_effect |= DROPEFFECT_COPY | DROPEFFECT_MOVE;
+
+    return drop_effect;
+}
+
 /**********************************************************************
  *          IDropTarget discovery
  *
@@ -392,11 +406,62 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
                               struct wl_data_offer *wl_data_offer)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    struct wayland_surface *wayland_surface;
+    IDropTarget *drop_target;
+    POINT point;
+    DWORD drop_effect;
+    HRESULT hr;
 
     /* Any previous dnd offer should have been freed by a drop or leave event. */
     assert(data_device->dnd_wl_data_offer == NULL);
 
     data_device->dnd_wl_data_offer = wl_data_offer;
+
+    if (!wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    wayland_surface = wl_surface_get_user_data(wl_surface);
+
+    if (!wayland_surface || !wayland_surface->hwnd)
+        return;
+
+    data_device->dnd_enter_serial = serial;
+    data_device->dnd_surface = wayland_surface;
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (!drop_target)
+        return;
+
+    /* Clear accepted_mime_type here. It should be eventually set by
+     * IDropTarget_DragEnter, when it internally calls
+     * IDataObject::QueryGetData on our data offer's IDataObject. */
+    data_offer->accepted_mime_type = NULL;
+    drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    hr = IDropTarget_DragEnter(drop_target, &data_offer->data_object, MK_LBUTTON,
+                               *(POINTL*)&point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return;
+
+    wl_data_offer_set_actions(wl_data_offer, data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
 }
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 499ae2cbce2..a56a19bbb7e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -117,6 +117,10 @@ struct wayland_data_device
     struct wl_data_device *wl_data_device;
     struct wl_data_offer *clipboard_wl_data_offer;
     struct wl_data_offer *dnd_wl_data_offer;
+    uint32_t dnd_enter_serial;
+    struct wayland_surface *dnd_surface;
+    int dnd_x;
+    int dnd_y;
 };
 
 struct wayland_data_device_format
-- 
2.33.0


From 143e821f1c25d34e9bf547e65099f7f574a5478f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:02:14 +0300
Subject: [PATCH 120/125] winewayland.drv: Handle the wl_data_device::leave
 event

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index ad112ed2cd8..cec511f1d46 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -467,6 +467,27 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 {
     struct wayland_data_device *data_device = data;
+    IDropTarget *drop_target;
+    POINT point;
+
+    TRACE("surface=%p hwnd=%p\n",
+          data_device->dnd_surface,
+          data_device->dnd_surface->hwnd);
+
+    if (!data_device->dnd_wl_data_offer)
+        return;
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (drop_target)
+    {
+        IDropTarget_DragLeave(drop_target);
+        IDropTarget_Release(drop_target);
+    }
 
     wayland_data_device_destroy_dnd_data_offer(data_device);
 }
-- 
2.33.0


From bb9e6345f75f8a1ab436b777f58d4d68fdb5abc3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:03:47 +0300
Subject: [PATCH 121/125] winewayland.drv: Handle the wl_data_device::motion
 event

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 40 ++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index cec511f1d46..ea2c84db01b 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -495,6 +495,46 @@ static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
                                uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
 {
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    IDropTarget *drop_target;
+    POINT point;
+    DWORD drop_effect;
+    HRESULT hr;
+
+    if (!data_device->dnd_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (!drop_target)
+        return;
+
+    drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    hr = IDropTarget_DragOver(drop_target, MK_LBUTTON, *(POINTL*)&point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return;
+
+    wl_data_offer_set_actions(data_device->dnd_wl_data_offer,
+                              data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(data_device->dnd_wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
 }
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
-- 
2.33.0


From 1eaa1e0c2f84df699625e87cd0156b490a6b23fc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:05:09 +0300
Subject: [PATCH 122/125] winewayland.drv: Handle the wl_data_device::drop
 event

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 30 ++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index ea2c84db01b..ebf6d84b46c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -540,6 +540,36 @@ static void data_device_motion(void *data, struct wl_data_device *wl_data_device
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    IDropTarget *drop_target;
+    POINT point;
+    DWORD drop_effect;
+    HRESULT hr;
+
+    if (!data_device->dnd_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (drop_target)
+    {
+        drop_effect = dnd_actions_to_drop_effect(data_offer->action);
+        hr = IDropTarget_Drop(drop_target, &data_offer->data_object, MK_LBUTTON,
+                              *(POINTL*)&point, &drop_effect);
+        IDropTarget_Release(drop_target);
+        if (SUCCEEDED(hr) && drop_effect != DROPEFFECT_NONE)
+            wl_data_offer_finish(data_device->dnd_wl_data_offer);
+    }
 
     wayland_data_device_destroy_dnd_data_offer(data_device);
 }
-- 
2.33.0


From bb9c424219045c9e1a8e488a8d2215dbfe536310 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:13:42 +0300
Subject: [PATCH 123/125] winewayland.drv: Support compositor-side scaling

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c        |  2 ++
 dlls/winewayland.drv/wayland_output.c | 25 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h     |  7 +++++++
 3 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f6ee764dff6..5ae1aafd6e3 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -254,6 +254,8 @@ BOOL wayland_init(struct wayland *wayland)
     /* Start with the default FNV-1a offset for 32-bits. */
     wayland->output_id_fnv_offset = 0x811c9dc5;
 
+    wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->toplevel_list);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 066fce572c4..11aee82629f 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -249,6 +249,11 @@ static void wayland_output_update_physical_coords(struct wayland_output *output)
     output->x = output->logical_x;
     output->y = output->logical_y;
 
+    /* When compositor scaling is used, we treat logical coordinates as
+     * physical. */
+    if (output->wayland->hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
     /* Update output->x,y based on other outputs that are to
      * to the left or above. */
     wl_list_for_each(o, &output->wayland->output_list, link)
@@ -308,6 +313,15 @@ static void wayland_output_done(struct wayland_output *output)
 
     TRACE("output->name=%s\n", output->name);
 
+    /* When compositor scaling is used, the current and only native mode
+     * corresponds to the logical width and height. */
+    if (output->wayland->hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+    {
+        wayland_output_clear_modes(output);
+        wayland_output_add_mode_all_bpp(output, output->logical_w, output->logical_h,
+                                        60000, TRUE, TRUE);
+    }
+
     wayland_output_add_default_modes(output);
     wayland_output_update_physical_coords(output);
 
@@ -345,6 +359,12 @@ static void output_handle_mode(void *data, struct wl_output *wl_output,
 {
     struct wayland_output *output = data;
 
+    /* When compositor scaling is used, we don't use physical width/height
+     * for modes and the current mode will be set based on logical width
+     * and height (see wayland_output_handle()). */
+    if (output->wayland->hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
     wayland_output_add_mode_all_bpp(output, width, height, refresh,
                                     (flags & WL_OUTPUT_MODE_CURRENT),
                                     TRUE);
@@ -365,7 +385,10 @@ static void output_handle_scale(void *data, struct wl_output *wl_output,
 {
     struct wayland_output *output = data;
     TRACE("output=%p scale=%d\n", output, scale);
-    output->scale = scale;
+    /* When compositor scaling is used, we ignore the output scale, to
+     * allow the the compositor to scale us. */
+    if (output->wayland->hidpi_scaling != WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        output->scale = scale;
 }
 
 static const struct wl_output_listener output_listener = {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a56a19bbb7e..975f2b5d5df 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -70,6 +70,12 @@ enum wayland_pointer_confinement
     WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP,
 };
 
+enum wayland_hidpi_scaling
+{
+    WAYLAND_HIDPI_SCALING_APPLICATION,
+    WAYLAND_HIDPI_SCALING_COMPOSITOR,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -167,6 +173,7 @@ struct wayland
     struct wl_list thread_link;
     HWND clipboard_hwnd;
     RECT cursor_clip;
+    enum wayland_hidpi_scaling hidpi_scaling;
 };
 
 struct wayland_output_mode
-- 
2.33.0


From d1b1d4ff838e176fcc24f32d18039296da714a11 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:22:32 +0300
Subject: [PATCH 124/125] winewayland.drv: Read HiDPI scaling mode from driver
 options in the registry

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in  |  1 +
 dlls/winewayland.drv/options.c    | 93 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c    |  1 +
 dlls/winewayland.drv/waylanddrv.h |  1 +
 4 files changed, 96 insertions(+)
 create mode 100644 dlls/winewayland.drv/options.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f982e7df488..799f9cc2ee2 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	display.c \
 	gdi.c \
 	opengl.c \
+	options.c \
 	vulkan.c \
 	wayland.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
new file mode 100644
index 00000000000..bc426c15d16
--- /dev/null
+++ b/dlls/winewayland.drv/options.c
@@ -0,0 +1,93 @@
+/*
+ * winewayland.drv options
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Code to read options from the registry, adapted from the X11 driver */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include "waylanddrv.h"
+
+#include "wine/unicode.h"
+
+#include "winreg.h"
+#include "winuser.h"
+
+/***********************************************************************
+ *		get_config_key
+ *
+ * Get a config key from either the app-specific or the default config
+ */
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   DWORD flags, char *buffer, DWORD size)
+{
+    if (appkey && !RegGetValueA(appkey, NULL, name, flags, NULL, (LPBYTE)buffer, &size)) return 0;
+    if (defkey && !RegGetValueA(defkey, NULL, name, flags, NULL, (LPBYTE)buffer, &size)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/***********************************************************************
+ *		wayland_read_options_from_registry
+ *
+ * Read the Wayland driver options from the registry.
+ */
+void wayland_read_options_from_registry(struct wayland *wayland)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    char buffer[64];
+    WCHAR bufferW[MAX_PATH + 16];
+    HKEY hkey, appkey = 0;
+    DWORD len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    if (RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Wayland Driver", &hkey)) hkey = 0;
+
+    /* open the app-specific key */
+
+    len = GetModuleFileNameW(0, bufferW, MAX_PATH);
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+        WCHAR *p, *appname = bufferW;
+        if ((p = strrchrW(appname, '/'))) appname = p + 1;
+        if ((p = strrchrW(appname, '\\'))) appname = p + 1;
+        CharLowerW(appname);
+        strcatW(appname, waylanddriverW);
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+        if (!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey))
+        {
+            if (RegOpenKeyW(tmpkey, appname, &appkey)) appkey = 0;
+            RegCloseKey(tmpkey);
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "HiDPIScaling", RRF_RT_REG_SZ, buffer, sizeof(buffer)))
+    {
+        if (!strcasecmp(buffer, "Application"))
+            wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+        else if (!strcasecmp(buffer, "Compositor"))
+            wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
+    }
+
+    if (appkey) RegCloseKey(appkey);
+    if (hkey) RegCloseKey(hkey);
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 5ae1aafd6e3..cd1777850b3 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -255,6 +255,7 @@ BOOL wayland_init(struct wayland *wayland)
     wayland->output_id_fnv_offset = 0x811c9dc5;
 
     wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+    wayland_read_options_from_registry(wayland);
 
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->toplevel_list);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 975f2b5d5df..0e7f4d01b0f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -314,6 +314,7 @@ BOOL wayland_process_init(void);
 BOOL wayland_init(struct wayland *wayland);
 void wayland_deinit(struct wayland *wayland);
 void wayland_init_display_devices(struct wayland *wayland);
+void wayland_read_options_from_registry(struct wayland *wayland);
 
 /**********************************************************************
  *          Wayland output
-- 
2.33.0


From 7732780e428181476014b4622139ae5427ccbf71 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 13:36:40 +0300
Subject: [PATCH 125/125] winewayland.drv: Add helper functions for debugging
 pixel buffer contents

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/dump_pixels.c     | 171 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |  12 ++
 dlls/winewayland.drv/waylanddrv.h      |   6 +
 dlls/winewayland.drv/window_surface.c  |  25 ++++
 5 files changed, 215 insertions(+)
 create mode 100644 dlls/winewayland.drv/dump_pixels.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 799f9cc2ee2..24930d419f2 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -12,6 +12,7 @@ EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	display.c \
+	dump_pixels.c \
 	gdi.c \
 	opengl.c \
 	options.c \
diff --git a/dlls/winewayland.drv/dump_pixels.c b/dlls/winewayland.drv/dump_pixels.c
new file mode 100644
index 00000000000..f72f54e4938
--- /dev/null
+++ b/dlls/winewayland.drv/dump_pixels.c
@@ -0,0 +1,171 @@
+/*
+ * Debugging functions for pixel buffer contents
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "winuser.h"
+
+#include <assert.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!region)
+        return NULL;
+
+    if (!(size = GetRegionData(region, 0, NULL))) goto err;
+    if (!(data = heap_alloc(size))) goto err;
+
+    if (!GetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    heap_free(data);
+    return NULL;
+}
+
+/* Dump the contents of a pixel buffer, along with the outlines of damage
+ * and window regions, to a netpbm .pam file. */
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels,
+                 int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region)
+{
+    char fname[128] = {0};
+    RGNDATA *damage_data;
+    RGNDATA *win_region_data;
+    FILE *fp;
+    int x, y;
+
+    damage_data = get_region_data(damage);
+    win_region_data = get_region_data(win_region);
+
+    snprintf(fname, sizeof(fname), fpattern, dbgid);
+    TRACE("dumping pixels to %s\n", fname);
+
+    fp = fopen(fname, "w");
+    assert(fp && "Failed to open target file for dump pixels. Does the target directory exist?");
+
+    fprintf(fp, "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
+            width, height);
+
+    for (y = 0; y < height; ++y)
+    {
+        for (x = 0; x < width; ++x)
+        {
+            BOOL draw_damage = FALSE;
+            BOOL draw_win_region = FALSE;
+            RECT *rgn_rect;
+            RECT *end;
+
+            if (damage_data)
+            {
+                rgn_rect = (RECT *)damage_data->Buffer;
+                end = rgn_rect + damage_data->rdh.nCount;
+
+                /* Draw the outlines of damaged areas. */
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (win_region_data)
+            {
+                /* Draw the outlines of window region areas. */
+                rgn_rect = (RECT *)win_region_data->Buffer;
+                end = rgn_rect + win_region_data->rdh.nCount;
+
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (draw_damage || draw_win_region)
+            {
+                unsigned char rgba[4] = {
+                    draw_damage ? 0xff : 0x00,
+                    draw_win_region ? 0xff : 0x00,
+                    0x00, 0xff
+                };
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+            else
+            {
+                unsigned int *pixel = (unsigned int *)((char *)pixels +
+                                                       width * 4 * y + 4 * x);
+                unsigned char rgba[4] = {
+                    (*pixel & 0x00ff0000) >> 16,
+                    (*pixel & 0x0000ff00) >> 8,
+                    (*pixel & 0xff),
+                    alpha ? (*pixel & 0xff000000) >> 24 : 0xff,
+                };
+
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+        }
+    }
+
+    fflush(fp);
+    fclose(fp);
+
+    heap_free(damage_data);
+    heap_free(win_region_data);
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 6547043ef8d..daa62c5f523 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -29,6 +29,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump committed buffer contents to disk */
+#define DEBUG_DUMP_COMMIT_BUFFER 0
+
 static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
                                          uint32_t serial)
 {
@@ -486,6 +489,15 @@ void wayland_surface_commit_buffer(struct wayland_surface *surface,
         return;
     }
 
+    if (DEBUG_DUMP_COMMIT_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/commit-%.4d.pam", dbgid++, shm_buffer->map_data,
+                    shm_buffer->width, shm_buffer->height,
+                    shm_buffer->format == WL_SHM_FORMAT_ARGB8888,
+                    shm_buffer->damage_region, NULL);
+    }
+
     wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
 
     /* Add surface damage, i.e., which parts of the surface have changed since
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0e7f4d01b0f..bb7b22d3a9b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -499,4 +499,10 @@ struct wayland_data_device_format *wayland_data_device_format_for_clipboard_form
 xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state);
 int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size);
 
+/**********************************************************************
+ *          Debugging helpers
+ */
+
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels, int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region);
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index f7855f32f2e..bdc105c34ec 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -37,6 +37,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump flushed surface buffer contents to disk */
+#define DEBUG_DUMP_FLUSH_SURFACE_BUFFER 0
+
+/* Change to 1 to dump front buffer contents to disk when performing front
+ * buffer rendering. */
+#define DEBUG_DUMP_FRONT_BUFFER 0
+
 struct wayland_window_surface
 {
     struct window_surface header;
@@ -318,6 +325,15 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
     assert(wws->wayland_buffer_queue);
 
+    if (DEBUG_DUMP_FLUSH_SURFACE_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/flush-%.4d.pam", dbgid++, wws->bits,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    wws->wayland_buffer_queue->format == WL_SHM_FORMAT_ARGB8888,
+                    surface_damage_region, wws->total_region);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
     buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
     buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
@@ -613,6 +629,15 @@ void wayland_window_surface_update_front_buffer(struct window_surface *window_su
         WARN("Failed to allocate memory for front buffer pixels\n");
     }
 
+    if (DEBUG_DUMP_FRONT_BUFFER && wws->front_bits)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/front-%.4d.pam", dbgid++,
+                    wws->front_bits, wws->info.bmiHeader.biWidth,
+                    abs(wws->info.bmiHeader.biHeight),
+                    FALSE, NULL, NULL);
+    }
+
 out:
     window_surface->funcs->unlock(window_surface);
 }
-- 
2.33.0

