From 04bf4eda9c1f291a3bb6ff43b7085e8afbb74cd0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 14:09:36 +0200
Subject: [PATCH 001/202] gdi32: Track ticks since draw start per
 window_surface.

Track ticks since draw start per window_surface, instead of per window
as is currently the case. This helps reduce visual glitches caused by
badly timed flushes in backends which use the same (parent)
window_surface for children windows.

For example, with a shared window_surface, and with the current scheme
of per window start_tick tracking, we may flush while drawing a child
when performing a redraw originating from the parent:

flush
Draw parent (bounds is empty so parent start_ticks is reset)
Draw child 1 (bounds possibly not empty, child1 start_ticks not reset,
              and, depending on when child 1 was drawn independently,
              this could lead to a flush during the draw)

With per surface draw ticks:

flush
Draw parent (bounds is empty so surface start_ticks is reset)
Draw child 1 (bounds possibly not empty, but since surface start_ticks
              was reset by the parent it's unlikely that we flush during
              this draw)

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/win32u/dibdrv/dc.c   | 7 ++++---
 include/wine/gdi_driver.h | 1 +
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index 7c60466d9ee..434b0cbf778 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -731,7 +731,6 @@ struct windrv_physdev
     struct gdi_physdev     dev;
     struct dibdrv_physdev *dibdrv;
     struct window_surface *surface;
-    DWORD                  start_ticks;
 };
 
 static const struct gdi_dc_funcs window_driver;
@@ -745,13 +744,15 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     /* gdi_lock should not be locked */
     dev->surface->funcs->lock( dev->surface );
-    if (IsRectEmpty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (IsRectEmpty( dev->dibdrv->bounds ) || dev->surface->draw_start_ticks == 0)
+        dev->surface->draw_start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
 {
+    BOOL should_flush = NtGetTickCount() - dev->surface->draw_start_ticks > FLUSH_PERIOD;
     dev->surface->funcs->unlock( dev->surface );
-    if (NtGetTickCount() - dev->start_ticks > FLUSH_PERIOD) dev->surface->funcs->flush( dev->surface );
+    if (should_flush) dev->surface->funcs->flush( dev->surface );
 }
 
 static void CDECL unlock_bits_surface( struct gdi_image_bits *bits )
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index d074c09cceb..464e351ada8 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -217,6 +217,7 @@ struct window_surface
     struct list                        entry; /* entry in global list managed by user32 */
     LONG                               ref;   /* reference count */
     RECT                               rect;  /* constant, no locking needed */
+    DWORD                              draw_start_ticks; /* start ticks of fresh draw */
     /* driver-specific fields here */
 };
 
-- 
2.39.0.rc2

From 725e0bbeab8a3817e60b24e0f2aba28c1f3301ec Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 23 Jun 2021 17:22:20 +0300
Subject: [PATCH 002/202] win32u: Expose function to send internal thread
 messages.

Expose a function to drivers so that they can send internal messages to
specific threads, without the need to target a specific HWND.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/win32u/gdiobj.c         |  1 +
 dlls/win32u/message.c        | 14 ++++++++++++++
 dlls/win32u/win32u.spec      |  3 +++
 dlls/win32u/win32u_private.h |  3 +++
 dlls/win32u/wrappers.c       |  9 +++++++++
 include/winuser.h            |  3 +++
 6 files changed, 33 insertions(+)

diff --git a/dlls/win32u/gdiobj.c b/dlls/win32u/gdiobj.c
index f88efbaa679..df273beadde 100644
--- a/dlls/win32u/gdiobj.c
+++ b/dlls/win32u/gdiobj.c
@@ -1150,6 +1150,7 @@ static struct unix_funcs unix_funcs =
     __wine_get_file_outline_text_metric,
     __wine_get_icm_profile,
     __wine_send_input,
+    __wine_send_internal_message_timeout,
 };
 
 void gdi_init(void)
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 6f78c99921a..d8811939fe3 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -3102,6 +3102,20 @@ static BOOL send_message_callback( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lp
     return process_message( &info, NULL, ansi );
 }
 
+/***********************************************************************
+ *		     __wine_send_internal_message_timeout  (win32u.@)
+ *
+ * Same as SendMessageTimeoutW but sends the message to a specific thread
+ * without requiring a window handle. Only works for internal Wine messages.
+ */
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    return send_internal_message_timeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                          flags, timeout, res_ptr );
+}
+
 /***********************************************************************
  *           NtUserPostMessage  (win32u.@)
  */
diff --git a/dlls/win32u/win32u.spec b/dlls/win32u/win32u.spec
index c9c126ec2f3..b34618dc28a 100644
--- a/dlls/win32u/win32u.spec
+++ b/dlls/win32u/win32u.spec
@@ -1328,3 +1328,6 @@
 @ cdecl __wine_get_brush_bitmap_info(long ptr ptr ptr)
 @ cdecl __wine_get_icm_profile(long long ptr ptr)
 @ cdecl __wine_get_file_outline_text_metric(wstr ptr)
+
+# message
+@ cdecl __wine_send_internal_message_timeout(long long long long long long long ptr)
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 8fc00cf3296..10cd9e52be7 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -208,6 +208,9 @@ struct unix_funcs
     BOOL (CDECL *get_file_outline_text_metric)( const WCHAR *path, OUTLINETEXTMETRICW *otm );
     BOOL (CDECL *get_icm_profile)( HDC hdc, BOOL allow_default, DWORD *size, WCHAR *filename );
     BOOL (CDECL *wine_send_input)( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+    LRESULT (CDECL *wine_send_internal_message_timeout)( DWORD dest_pid, DWORD dest_tid,
+                                                         UINT msg, WPARAM wparam, LPARAM lparam,
+                                                         UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 };
 
 /* clipboard.c */
diff --git a/dlls/win32u/wrappers.c b/dlls/win32u/wrappers.c
index e128705ef37..d0d068c3e78 100644
--- a/dlls/win32u/wrappers.c
+++ b/dlls/win32u/wrappers.c
@@ -804,6 +804,15 @@ BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *raw
     return unix_funcs->wine_send_input( hwnd, input, rawinput );
 }
 
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    if (!unix_funcs) return 0;
+    return unix_funcs->wine_send_internal_message_timeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                                           flags, timeout, res_ptr );
+}
+
 extern void wrappers_init( unixlib_handle_t handle )
 {
     const void *args;
diff --git a/include/winuser.h b/include/winuser.h
index a82a6ec26c5..0ce6956bb76 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4764,6 +4764,9 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+WINUSERAPI LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                               UINT msg, WPARAM wparam, LPARAM lparam,
+                                                               UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 
 /* Uxtheme hook functions and struct */
 
-- 
2.39.0.rc2

From 0592ad9cb95366814723e51f759d0f014ac522ea Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 15:48:36 +0300
Subject: [PATCH 003/202] winewayland.drv: Add initial driver stub.

Add the initial driver stub for the Wayland driver and enable building
it with the '--with-wayland' configure flag.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                 | 22 +++++++++++++++++
 configure.ac                              |  6 +++++
 dlls/winewayland.drv/Makefile.in          |  6 +++++
 dlls/winewayland.drv/dllmain.c            | 30 +++++++++++++++++++++++
 dlls/winewayland.drv/version.rc           | 22 +++++++++++++++++
 dlls/winewayland.drv/waylanddrv_dll.h     | 28 +++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  0
 7 files changed, 114 insertions(+)
 create mode 100644 dlls/winewayland.drv/Makefile.in
 create mode 100644 dlls/winewayland.drv/dllmain.c
 create mode 100644 dlls/winewayland.drv/version.rc
 create mode 100644 dlls/winewayland.drv/waylanddrv_dll.h
 create mode 100644 dlls/winewayland.drv/winewayland.drv.spec

diff --git a/configure b/configure
index b29f480b726..0f50a0fdb10 100755
--- a/configure
+++ b/configure
@@ -948,6 +948,7 @@ with_xrender
 with_xshape
 with_xshm
 with_xxf86vm
+with_wayland
 with_system_dllpath
 with_wine_tools
 with_wine64
@@ -1465,6 +1466,7 @@ enable_wineps_drv
 enable_winepulse_drv
 enable_wineusb_sys
 enable_winevulkan
+enable_winewayland_drv
 enable_winex11_drv
 enable_winexinput_sys
 enable_wing32
@@ -2458,6 +2460,7 @@ Optional Packages:
   --without-xshape        do not use the Xshape extension
   --without-xshm          do not use XShm (shared memory extension)
   --without-xxf86vm       do not use XFree video mode extension
+  --with-wayland          build with wayland support
   --with-system-dllpath=PATH
                           load external PE dependencies from colon-separated
                           path PATH
@@ -4473,6 +4476,13 @@ then :
 fi
 
 
+# Check whether --with-wayland was given.
+if test ${with_wayland+y}
+then :
+  withval=$with_wayland;
+fi
+
+
 
 # Check whether --with-system-dllpath was given.
 if test ${with_system_dllpath+y}
@@ -15862,6 +15872,17 @@ enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 fi
 
+if false
+then :
+  case "x$with_wayland" in
+  x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found, the Wayland driver won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.
+This is an error since --with-wayland was requested." "$LINENO" 5 ;;
+esac
+enable_winewayland_drv=${enable_winewayland_drv:-no}
+fi
+
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
@@ -21917,6 +21938,7 @@ wine_fn_config_makefile dlls/wineps16.drv16 enable_win16
 wine_fn_config_makefile dlls/winepulse.drv enable_winepulse_drv
 wine_fn_config_makefile dlls/wineusb.sys enable_wineusb_sys
 wine_fn_config_makefile dlls/winevulkan enable_winevulkan
+wine_fn_config_makefile dlls/winewayland.drv enable_winewayland_drv
 wine_fn_config_makefile dlls/winex11.drv enable_winex11_drv
 wine_fn_config_makefile dlls/winexinput.sys enable_winexinput_sys
 wine_fn_config_makefile dlls/wing.dll16 enable_win16
diff --git a/configure.ac b/configure.ac
index 7313fde9a4e..ae7127c1747 100644
--- a/configure.ac
+++ b/configure.ac
@@ -83,6 +83,7 @@ AC_ARG_WITH(xshm,      AS_HELP_STRING([--without-xshm],[do not use XShm (shared
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XShm_h=no; fi])
 AC_ARG_WITH(xxf86vm,   AS_HELP_STRING([--without-xxf86vm],[do not use XFree video mode extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi])
+AC_ARG_WITH(wayland,   AS_HELP_STRING([--with-wayland],[build with wayland support]))
 
 AC_ARG_WITH(system-dllpath,AS_HELP_STRING([--with-system-dllpath=PATH],[load external PE dependencies from colon-separated path PATH]),
             AC_SUBST(system_dllpath,[$withval]))
@@ -1407,6 +1408,10 @@ else
                      [enable_winex11_drv])
 fi
 
+WINE_NOTICE_WITH(wayland, [false],
+                 [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
+                 [enable_winewayland_drv])
+
 dnl **** Check for OpenCL ****
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
@@ -3200,6 +3205,7 @@ WINE_CONFIG_MAKEFILE(dlls/wineps16.drv16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/winepulse.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineusb.sys)
 WINE_CONFIG_MAKEFILE(dlls/winevulkan)
+WINE_CONFIG_MAKEFILE(dlls/winewayland.drv)
 WINE_CONFIG_MAKEFILE(dlls/winex11.drv)
 WINE_CONFIG_MAKEFILE(dlls/winexinput.sys)
 WINE_CONFIG_MAKEFILE(dlls/wing.dll16,enable_win16)
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
new file mode 100644
index 00000000000..713b281b1bd
--- /dev/null
+++ b/dlls/winewayland.drv/Makefile.in
@@ -0,0 +1,6 @@
+MODULE = winewayland.drv
+
+C_SRCS = \
+	dllmain.c \
+
+RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
new file mode 100644
index 00000000000..7ab3341e61d
--- /dev/null
+++ b/dlls/winewayland.drv/dllmain.c
@@ -0,0 +1,30 @@
+/*
+ * winewayland.drv entry points
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "waylanddrv_dll.h"
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    if (reason != DLL_PROCESS_ATTACH) return TRUE;
+
+    DisableThreadLibraryCalls(instance);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/version.rc b/dlls/winewayland.drv/version.rc
new file mode 100644
index 00000000000..2d99c24f99c
--- /dev/null
+++ b/dlls/winewayland.drv/version.rc
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine Wayland driver"
+#define WINE_FILENAME_STR "winewayland.drv"
+
+#include "wine/wine_common_ver.rc"
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
new file mode 100644
index 00000000000..556898d44b2
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -0,0 +1,28 @@
+/*
+ * Wayland driver DLL definitions
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_DLL_H
+#define __WINE_WAYLANDDRV_DLL_H
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+
+#endif /* __WINE_WAYLANDDRV_DLL_H */
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
new file mode 100644
index 00000000000..e69de29bb2d
-- 
2.39.0.rc2

From 1d4e2d60b898ac12aa0eb4c78f4fe2662a8c085b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 7 Jun 2022 12:17:12 +0300
Subject: [PATCH 004/202] winewayland.drv: Add initial unixlib stub.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  2 ++
 dlls/winewayland.drv/dllmain.c         |  4 +++
 dlls/winewayland.drv/unixlib.h         | 32 ++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 35 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv_dll.h  |  4 +++
 dlls/winewayland.drv/waylanddrv_main.c | 42 ++++++++++++++++++++++++++
 6 files changed, 119 insertions(+)
 create mode 100644 dlls/winewayland.drv/unixlib.h
 create mode 100644 dlls/winewayland.drv/waylanddrv.h
 create mode 100644 dlls/winewayland.drv/waylanddrv_main.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 713b281b1bd..1d52f466c41 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,8 @@
 MODULE = winewayland.drv
+UNIXLIB = winewayland.so
 
 C_SRCS = \
 	dllmain.c \
+	waylanddrv_main.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index 7ab3341e61d..89d981a4314 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -25,6 +25,10 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
     if (reason != DLL_PROCESS_ATTACH) return TRUE;
 
     DisableThreadLibraryCalls(instance);
+    if (__wine_init_unix_call()) return FALSE;
+
+    if (WAYLANDDRV_UNIX_CALL(init, NULL))
+        return FALSE;
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
new file mode 100644
index 00000000000..427837523e3
--- /dev/null
+++ b/dlls/winewayland.drv/unixlib.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_UNIXLIB_H
+#define __WINE_WAYLANDDRV_UNIXLIB_H
+
+#include <stdarg.h>
+#include "winternl.h"
+#include "wine/unixlib.h"
+
+enum waylanddrv_unix_func
+{
+    waylanddrv_unix_func_init,
+    waylanddrv_unix_func_count,
+};
+
+#endif /* __WINE_WAYLANDDRV_UNIXLIB_H */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
new file mode 100644
index 00000000000..4479f2b8b57
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -0,0 +1,35 @@
+/*
+ * Wayland driver
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_H
+#define __WINE_WAYLANDDRV_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+
+#include "unixlib.h"
+
+#endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
index 556898d44b2..123b6cd5a61 100644
--- a/dlls/winewayland.drv/waylanddrv_dll.h
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -25,4 +25,8 @@
 #include "windef.h"
 #include "winbase.h"
 
+#include "unixlib.h"
+
+#define WAYLANDDRV_UNIX_CALL(func, params) WINE_UNIX_CALL(waylanddrv_unix_func_ ## func, params)
+
 #endif /* __WINE_WAYLANDDRV_DLL_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
new file mode 100644
index 00000000000..003b333f728
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -0,0 +1,42 @@
+/*
+ * WAYLANDDRV initialization code
+ *
+ * Copyright 2020 Alexandre Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+static NTSTATUS waylanddrv_unix_init(void *arg)
+{
+    return 0;
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    waylanddrv_unix_init,
+};
+
+C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
-- 
2.39.0.rc2

From f9c281e42ed063d1bd522b025a64947329a61b9a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 18:41:03 +0200
Subject: [PATCH 005/202] explorer: Add the Wayland driver to the default
 driver list.

Add the Wayland driver at the end of the default driver list. This
ensures that, by default, under Wayland compositors that support
Xwayland, the more mature X11 driver will be used. One can force using
the wayland driver by ensuring X11 is not accessible, e.g., by unsetting
the DISPLAY environment variable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 programs/explorer/desktop.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 96673adc254..afa711a8dbf 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -40,7 +40,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(explorer);
 #define DESKTOP_CLASS_ATOM ((LPCWSTR)MAKEINTATOM(32769))
 #define DESKTOP_ALL_ACCESS 0x01ff
 
-static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',0};
+static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',',','w','a','y','l','a','n','d',0};
 
 static BOOL using_root;
 
-- 
2.39.0.rc2

From e88a8c51a850172b02cfce2ffb4ea2baed152bce Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:21:21 +0300
Subject: [PATCH 006/202] winewayland.drv: Perform basic per-process Wayland
 initialization.

Try to connect to the Wayland compositor, and fail driver initialization
if we are unable to do so.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                              | 87 +++++++++++++++++++++++++-
 configure.ac                           |  9 ++-
 dlls/winewayland.drv/Makefile.in       |  3 +
 dlls/winewayland.drv/wayland.c         | 41 ++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 13 ++++
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 include/config.h.in                    |  3 +
 7 files changed, 156 insertions(+), 2 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland.c

diff --git a/configure b/configure
index 0f50a0fdb10..650bac9362e 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+WAYLAND_CLIENT_LIBS
+WAYLAND_CLIENT_CFLAGS
 X_EXTRA_LIBS
 X_LIBS
 X_PRE_LIBS
@@ -1736,6 +1738,8 @@ ZLIB_PE_CFLAGS
 ZLIB_PE_LIBS
 XMKMF
 CPP
+WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2535,6 +2539,10 @@ Some influential environment variables:
               Linker flags for the PE zlib, overriding the bundled version
   XMKMF       Path to xmkmf, Makefile generator for X Window System
   CPP         C preprocessor
+  WAYLAND_CLIENT_CFLAGS
+              C compiler flags for wayland-client, overriding pkg-config
+  WAYLAND_CLIENT_LIBS
+              Linker flags for wayland-client, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -15872,7 +15880,82 @@ enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 fi
 
-if false
+if test "x$with_wayland" = "xyes"
+then
+    if ${WAYLAND_CLIENT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_CFLAGS=`$PKG_CONFIG --cflags wayland-client 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_CLIENT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_LIBS=`$PKG_CONFIG --libs wayland-client 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client cflags: $WAYLAND_CLIENT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client libs: $WAYLAND_CLIENT_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CLIENT_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-client.h" "ac_cv_header_wayland_client_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_client_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CLIENT_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_display_connect in -lwayland-client" >&5
+printf %s "checking for wl_display_connect in -lwayland-client... " >&6; }
+if test ${ac_cv_lib_wayland_client_wl_display_connect+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-client $WAYLAND_CLIENT_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char wl_display_connect ();
+int
+main (void)
+{
+return wl_display_connect ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_client_wl_display_connect=yes
+else $as_nop
+  ac_cv_lib_wayland_client_wl_display_connect=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_client_wl_display_connect" >&5
+printf "%s\n" "$ac_cv_lib_wayland_client_wl_display_connect" >&6; }
+if test "x$ac_cv_lib_wayland_client_wl_display_connect" = xyes
+then :
+  :
+else $as_nop
+  WAYLAND_CLIENT_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test -z "$WAYLAND_CLIENT_LIBS"
 then :
   case "x$with_wayland" in
   x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found, the Wayland driver won't be supported." ;;
@@ -23239,6 +23322,8 @@ X_CFLAGS = $X_CFLAGS
 X_PRE_LIBS = $X_PRE_LIBS
 X_LIBS = $X_LIBS
 X_EXTRA_LIBS = $X_EXTRA_LIBS
+WAYLAND_CLIENT_CFLAGS = $WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS = $WAYLAND_CLIENT_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index ae7127c1747..6eb8f93640a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1408,7 +1408,14 @@ else
                      [enable_winex11_drv])
 fi
 
-WINE_NOTICE_WITH(wayland, [false],
+if test "x$with_wayland" = "xyes"
+then
+    WINE_PACKAGE_FLAGS(WAYLAND_CLIENT,[wayland-client],,,,
+        [AC_CHECK_HEADERS([wayland-client.h])
+         AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
+                      [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+fi
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS"],
                  [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 1d52f466c41..fc1fe8119ec 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,8 +1,11 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
+UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
+UNIX_LIBS = $(WAYLAND_CLIENT_LIBS)
 
 C_SRCS = \
 	dllmain.c \
+	wayland.c \
 	waylanddrv_main.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
new file mode 100644
index 00000000000..9b61427c8aa
--- /dev/null
+++ b/dlls/winewayland.drv/wayland.c
@@ -0,0 +1,41 @@
+/*
+ * Wayland core handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+struct wl_display *process_wl_display = NULL;
+
+/**********************************************************************
+ *          wayland_process_init
+ *
+ *  Initialise the per process wayland objects.
+ *
+ */
+BOOL wayland_process_init(void)
+{
+    process_wl_display = wl_display_connect(NULL);
+    return process_wl_display != NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4479f2b8b57..a37fd26531f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -26,10 +26,23 @@
 #endif
 
 #include <stdarg.h>
+#include <wayland-client.h>
 
 #include "windef.h"
 #include "winbase.h"
 
 #include "unixlib.h"
 
+/**********************************************************************
+ *          Globals
+ */
+
+extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland initialization
+ */
+
+BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 003b333f728..6fe01eb674d 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -31,6 +31,8 @@
 
 static NTSTATUS waylanddrv_unix_init(void *arg)
 {
+    if (!wayland_process_init()) return STATUS_UNSUCCESSFUL;
+
     return 0;
 }
 
diff --git a/include/config.h.in b/include/config.h.in
index 509dd2869bf..670ea0210e7 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -688,6 +688,9 @@
 /* Define to 1 if you have the <valgrind/valgrind.h> header file. */
 #undef HAVE_VALGRIND_VALGRIND_H
 
+/* Define to 1 if you have the <wayland-client.h> header file. */
+#undef HAVE_WAYLAND_CLIENT_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.39.0.rc2

From 5e84cc24fa4525d4707d2e8a3943227f4ac4556b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 17:16:12 +0300
Subject: [PATCH 007/202] winewayland.drv: Add stub for per-thread data.

Handle allocation and deallocation of per-thread data (currently without
any actual contents).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  2 +-
 dlls/winewayland.drv/waylanddrv.h      | 16 +++++++
 dlls/winewayland.drv/waylanddrv_main.c | 59 +++++++++++++++++++++++++-
 3 files changed, 75 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index fc1fe8119ec..ba460fcc792 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
-UNIX_LIBS = $(WAYLAND_CLIENT_LIBS)
+UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS)
 
 C_SRCS = \
 	dllmain.c \
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a37fd26531f..057eb3f8350 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -30,6 +30,7 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "ntuser.h"
 
 #include "unixlib.h"
 
@@ -39,6 +40,21 @@
 
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland thread data
+ */
+
+struct wayland_thread_data
+{
+};
+
+extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
+
+static inline struct wayland_thread_data *wayland_thread_data(void)
+{
+    return (struct wayland_thread_data *)(UINT_PTR)NtUserGetThreadInfo()->driver_data;
+}
+
 /**********************************************************************
  *          Wayland initialization
  */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 6fe01eb674d..e25ebfb0b14 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -29,11 +29,68 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+#include "wine/gdi_driver.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/***********************************************************************
+ *           Initialize per thread data
+ */
+struct wayland_thread_data *wayland_init_thread_data(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data) return data;
+
+    if (!(data = calloc(1, sizeof(*data))))
+    {
+        ERR("could not create data\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    NtUserGetThreadInfo()->driver_data = (UINT_PTR)data;
+
+    return data;
+}
+
+/***********************************************************************
+ *           ThreadDetach (WAYLAND.@)
+ */
+static void WAYLAND_ThreadDetach(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data)
+    {
+        free(data);
+        /* clear data in case we get re-entered from user32 before the thread is truly dead */
+        NtUserGetThreadInfo()->driver_data = 0;
+    }
+}
+
+static const struct user_driver_funcs waylanddrv_funcs =
+{
+    .pThreadDetach = WAYLAND_ThreadDetach,
+};
+
+static const struct user_driver_funcs null_funcs = { 0 };
+
 static NTSTATUS waylanddrv_unix_init(void *arg)
 {
-    if (!wayland_process_init()) return STATUS_UNSUCCESSFUL;
+    /* Set the user driver functions now so that they are available during
+     * our initialization. We clear them on error. */
+    __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
+
+    if (!wayland_process_init()) goto err;
 
     return 0;
+
+err:
+    __wine_set_user_driver(&null_funcs, WINE_GDI_DRIVER_VERSION);
+    return STATUS_UNSUCCESSFUL;
 }
 
 const unixlib_entry_t __wine_unix_call_funcs[] =
-- 
2.39.0.rc2

From ae35b5d8882242c49d62b234058867afc3200489 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 18 Jan 2022 12:52:10 +0200
Subject: [PATCH 008/202] winewayland.drv: Introduce wayland_mutex.

Introduce a thin wrapper around pthread mutex to provide more robust
mutex handling and informative error messages in case of suspected
deadlock, similarly to ntdll.RtlEnterCriticalSection.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in     |   3 +-
 dlls/winewayland.drv/wayland_mutex.c | 137 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h    |  23 +++++
 3 files changed, 162 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_mutex.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index ba460fcc792..6365ce4845c 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,11 +1,12 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
-UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS)
+UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
 	dllmain.c \
 	wayland.c \
+	wayland_mutex.c \
 	waylanddrv_main.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland_mutex.c b/dlls/winewayland.drv/wayland_mutex.c
new file mode 100644
index 00000000000..a32cbbbd519
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_mutex.c
@@ -0,0 +1,137 @@
+/*
+ * Wayland mutex
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <errno.h>
+#include <time.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_mutex_init
+ *
+ * Initialize a wayland_mutex.
+ */
+void wayland_mutex_init(struct wayland_mutex *wayland_mutex, int kind,
+                        const char *name)
+{
+    pthread_mutexattr_t mutexattr;
+
+    pthread_mutexattr_init(&mutexattr);
+    pthread_mutexattr_settype(&mutexattr, kind);
+    pthread_mutex_init(&wayland_mutex->mutex, &mutexattr);
+    pthread_mutexattr_destroy(&mutexattr);
+
+    wayland_mutex->owner_tid = 0;
+    wayland_mutex->lock_count = 0;
+    wayland_mutex->name = name;
+}
+
+/**********************************************************************
+ *          wayland_mutex_destroy
+ *
+ * Destroys a wayland_mutex.
+ */
+void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex)
+{
+    pthread_mutex_destroy(&wayland_mutex->mutex);
+    wayland_mutex->owner_tid = 0;
+    wayland_mutex->lock_count = 0;
+    wayland_mutex->name = NULL;
+}
+
+/**********************************************************************
+ *          wayland_mutex_lock
+ *
+ *  Lock a mutex, emitting error messages in cases of suspected deadlock.
+ *  In case of an unrecoverable error abort to ensure the program doesn't
+ *  continue with an inconsistent state.
+ */
+void wayland_mutex_lock(struct wayland_mutex *wayland_mutex)
+{
+    UINT tid = GetCurrentThreadId();
+    struct timespec timeout;
+    int err;
+
+    clock_gettime(CLOCK_REALTIME, &timeout);
+    timeout.tv_sec += 5;
+
+    while (TRUE)
+    {
+        err = pthread_mutex_timedlock(&wayland_mutex->mutex, &timeout);
+        if (!err) break;
+
+        if (err == ETIMEDOUT)
+        {
+            ERR("mutex %p %s lock timed out in thread %04x, blocked by %04x, retrying (60 sec)\n",
+                wayland_mutex, wayland_mutex->name, tid, wayland_mutex->owner_tid);
+            clock_gettime(CLOCK_REALTIME, &timeout);
+            timeout.tv_sec += 60;
+        }
+        else
+        {
+            ERR("error locking mutex %p %s errno=%d, aborting\n",
+                wayland_mutex, wayland_mutex->name, errno);
+            abort();
+        }
+    }
+
+    wayland_mutex->owner_tid = tid;
+    wayland_mutex->lock_count++;
+}
+
+/**********************************************************************
+ *          wayland_mutex_unlock
+ *
+ *  Unlock a mutex.
+ */
+void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex)
+{
+    int err;
+
+    wayland_mutex->lock_count--;
+
+    if (wayland_mutex->lock_count == 0)
+    {
+        wayland_mutex->owner_tid = 0;
+    }
+    else if (wayland_mutex->lock_count < 0)
+    {
+        ERR("mutex %p %s lock_count is %d < 0\n",
+             wayland_mutex, wayland_mutex->name, wayland_mutex->lock_count);
+    }
+
+    if ((err = pthread_mutex_unlock(&wayland_mutex->mutex)))
+    {
+        ERR("failed to unlock mutex %p %s errno=%d\n",
+            wayland_mutex, wayland_mutex->name, err);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 057eb3f8350..6c1cd770a6d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -25,6 +25,7 @@
 # error You must include config.h to use this header
 #endif
 
+#include <pthread.h>
 #include <stdarg.h>
 #include <wayland-client.h>
 
@@ -40,6 +41,18 @@
 
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Definitions for wayland types
+ */
+
+struct wayland_mutex
+{
+    pthread_mutex_t mutex;
+    UINT owner_tid;
+    int lock_count;
+    const char *name;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -61,4 +74,14 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
 
 BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland mutex
+ */
+
+void wayland_mutex_init(struct wayland_mutex *wayland_mutex, int kind,
+                        const char *name) DECLSPEC_HIDDEN;
+void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+void wayland_mutex_lock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_WAYLANDDRV_H */
-- 
2.39.0.rc2

From 79d4ce4e3c98d96d0b3f6a6354342b3a842eeb47 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:53:51 +0300
Subject: [PATCH 009/202] winewayland.drv: Initialize basic per-thread Wayland
 instance.

Every thread that requires interaction with Wayland maintains its own
independent set of Wayland protocols objects. Events from Wayland
protocol objects are dispatched into a thread-specific Wayland event
queue.

This design simplifies synchronization, since there is no shared Wayland
state between threads, and will later make it easier to dispatch events
to the proper thread message queue. The downside is that there is some
duplication of event handling if multiple GUI threads are present.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 132 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  27 +++++
 dlls/winewayland.drv/waylanddrv_main.c |  10 ++
 3 files changed, 169 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9b61427c8aa..852226cbb59 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -26,8 +26,140 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
 struct wl_display *process_wl_display = NULL;
 
+static struct wayland_mutex thread_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": thread_wayland_mutex"
+};
+
+static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
+
+/**********************************************************************
+ *          Registry handling
+ */
+
+static void registry_handle_global(void *data, struct wl_registry *registry,
+                                   uint32_t id, const char *interface,
+                                   uint32_t version)
+{
+    struct wayland *wayland = data;
+
+    TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
+
+    if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
+}
+
+static void registry_handle_global_remove(void *data, struct wl_registry *registry,
+                                          uint32_t id)
+{
+    TRACE("id=%d\n", id);
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+
+/**********************************************************************
+ *          wayland_init
+ *
+ *  Initialise a wayland instance.
+ */
+BOOL wayland_init(struct wayland *wayland)
+{
+    struct wl_display *wl_display_wrapper;
+
+    TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
+
+    wl_list_init(&wayland->thread_link);
+
+    wayland->process_id = GetCurrentProcessId();
+    wayland->thread_id = GetCurrentThreadId();
+    wayland->wl_display = process_wl_display;
+
+    if (!wayland->wl_display)
+    {
+        ERR("Failed to connect to wayland compositor\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create event queue\n");
+        return FALSE;
+    }
+
+    if (!(wl_display_wrapper = wl_proxy_create_wrapper(wayland->wl_display)))
+    {
+        ERR("Failed to create proxy wrapper for wl_display\n");
+        return FALSE;
+    }
+    wl_proxy_set_queue((struct wl_proxy *) wl_display_wrapper, wayland->wl_event_queue);
+
+    wayland->wl_registry = wl_display_get_registry(wl_display_wrapper);
+    wl_proxy_wrapper_destroy(wl_display_wrapper);
+    if (!wayland->wl_registry)
+    {
+        ERR("Failed to get to wayland registry\n");
+        return FALSE;
+    }
+
+    /* Populate registry */
+    wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
+
+    /* We need three roundtrips. One to get and bind globals, one to handle all
+     * initial events produced from registering the globals and one more to
+     * handle potential third-order registrations. */
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
+    /* Keep a list of all thread wayland instances. */
+    wayland_mutex_lock(&thread_wayland_mutex);
+    wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+    wayland_mutex_unlock(&thread_wayland_mutex);
+
+    wayland->initialized = TRUE;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_deinit
+ *
+ *  Deinitialise a wayland instance, releasing all associated resources.
+ */
+void wayland_deinit(struct wayland *wayland)
+{
+    TRACE("%p\n", wayland);
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+    wl_list_remove(&wayland->thread_link);
+    wayland_mutex_unlock(&thread_wayland_mutex);
+
+    if (wayland->wl_compositor)
+        wl_compositor_destroy(wayland->wl_compositor);
+
+    if (wayland->wl_registry)
+        wl_registry_destroy(wayland->wl_registry);
+
+    if (wayland->wl_event_queue)
+        wl_event_queue_destroy(wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    memset(wayland, 0, sizeof(*wayland));
+}
+
 /**********************************************************************
  *          wayland_process_init
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6c1cd770a6d..ee6ee2589a8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -53,12 +53,25 @@ struct wayland_mutex
     const char *name;
 };
 
+struct wayland
+{
+    struct wl_list thread_link;
+    BOOL initialized;
+    DWORD process_id;
+    DWORD thread_id;
+    struct wl_display *wl_display;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_registry *wl_registry;
+    struct wl_compositor *wl_compositor;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
 
 struct wayland_thread_data
 {
+    struct wayland wayland;
 };
 
 extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
@@ -68,11 +81,25 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
     return (struct wayland_thread_data *)(UINT_PTR)NtUserGetThreadInfo()->driver_data;
 }
 
+static inline struct wayland *thread_init_wayland(void)
+{
+    return &wayland_init_thread_data()->wayland;
+}
+
+static inline struct wayland *thread_wayland(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+    if (!data) return NULL;
+    return &data->wayland;
+}
+
 /**********************************************************************
  *          Wayland initialization
  */
 
 BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
+BOOL wayland_init(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index e25ebfb0b14..7f0fb61fa28 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -35,6 +35,7 @@
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 /***********************************************************************
  *           Initialize per thread data
@@ -51,6 +52,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         NtTerminateProcess(0, 1);
     }
 
+    if (!wayland_init(&data->wayland))
+    {
+        ERR_(winediag)("waylanddrv: Can't open wayland display. Please ensure "
+                       "that your wayland server is running and that "
+                       "$WAYLAND_DISPLAY is set correctly.\n");
+        NtTerminateProcess(0, 1);
+    }
+
     NtUserGetThreadInfo()->driver_data = (UINT_PTR)data;
 
     return data;
@@ -65,6 +74,7 @@ static void WAYLAND_ThreadDetach(void)
 
     if (data)
     {
+        wayland_deinit(&data->wayland);
         free(data);
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
         NtUserGetThreadInfo()->driver_data = 0;
-- 
2.39.0.rc2

From 0ce331ebabe8f0128dbe91f935faaecc45aac338 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 17:39:54 +0300
Subject: [PATCH 010/202] winewayland.drv: Initialize Wayland thread data for
 desktop window thread.

Having access to the Wayland thread data will allow the desktop process
to eventually access information that requires interaction with the
Wayland compositor. A prime example is accessing display information.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/waylanddrv.h      |  6 +++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 53 ++++++++++++++++++++++++++
 4 files changed, 61 insertions(+)
 create mode 100644 dlls/winewayland.drv/window.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 6365ce4845c..627cda9b7d3 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -8,5 +8,6 @@ C_SRCS = \
 	wayland.c \
 	wayland_mutex.c \
 	waylanddrv_main.c \
+	window.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ee6ee2589a8..b9ea28be33c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -111,4 +111,10 @@ void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 void wayland_mutex_lock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          USER driver functions
+ */
+
+BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 7f0fb61fa28..677637015e0 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -83,6 +83,7 @@ static void WAYLAND_ThreadDetach(void)
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
new file mode 100644
index 00000000000..86c621a369e
--- /dev/null
+++ b/dlls/winewayland.drv/window.c
@@ -0,0 +1,53 @@
+/*
+ * Window related functions
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *           WAYLAND_CreateWindow
+ */
+BOOL WAYLAND_CreateWindow(HWND hwnd)
+{
+    TRACE("%p\n", hwnd);
+
+    if (hwnd == NtUserGetDesktopWindow())
+    {
+        /* Initialize wayland so that the desktop process has access
+         * to all the wayland related information (e.g., displays). */
+        wayland_init_thread_data();
+    }
+
+    return TRUE;
+}
-- 
2.39.0.rc2

From 27d01204679cd3322afedfe3af9c48d3c02614b4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 8 Nov 2021 12:34:39 +0200
Subject: [PATCH 011/202] winewayland.drv: Maintain a per-process wayland
 instance.

All dispatches of Wayland events for per-process Wayland objects
are done with the per-process instance lock held.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 60 ++++++++++++++++++++++++++++---
 dlls/winewayland.drv/waylanddrv.h |  3 ++
 2 files changed, 58 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 852226cbb59..5f1de62c3b3 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -28,9 +28,16 @@
 
 #include "wine/debug.h"
 
+#include <stdlib.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
+static struct wayland *process_wayland = NULL;
+static struct wayland_mutex process_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": process_wayland_mutex"
+};
 
 static struct wayland_mutex thread_wayland_mutex =
 {
@@ -119,14 +126,19 @@ BOOL wayland_init(struct wayland *wayland)
     /* We need three roundtrips. One to get and bind globals, one to handle all
      * initial events produced from registering the globals and one more to
      * handle potential third-order registrations. */
+    if (wayland_is_process(wayland)) wayland_process_acquire();
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    if (wayland_is_process(wayland)) wayland_process_release();
 
-    /* Keep a list of all thread wayland instances. */
-    wayland_mutex_lock(&thread_wayland_mutex);
-    wl_list_insert(&thread_wayland_list, &wayland->thread_link);
-    wayland_mutex_unlock(&thread_wayland_mutex);
+    if (!wayland_is_process(wayland))
+    {
+        /* Keep a list of all thread wayland instances. */
+        wayland_mutex_lock(&thread_wayland_mutex);
+        wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+        wayland_mutex_unlock(&thread_wayland_mutex);
+    }
 
     wayland->initialized = TRUE;
 
@@ -169,5 +181,43 @@ void wayland_deinit(struct wayland *wayland)
 BOOL wayland_process_init(void)
 {
     process_wl_display = wl_display_connect(NULL);
-    return process_wl_display != NULL;
+    if (!process_wl_display)
+        return FALSE;
+
+    process_wayland = calloc(1, sizeof(*process_wayland));
+    if (!process_wayland)
+        return FALSE;
+
+    return wayland_init(process_wayland);
+}
+
+/**********************************************************************
+ *          wayland_is_process
+ *
+ *  Checks whether a wayland instance is the per-process one.
+ */
+BOOL wayland_is_process(struct wayland *wayland)
+{
+    return wayland == process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_acquire
+ *
+ *  Acquires the per-process wayland instance.
+ */
+struct wayland *wayland_process_acquire(void)
+{
+    wayland_mutex_lock(&process_wayland_mutex);
+    return process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_release
+ *
+ *  Releases the per-process wayland instance.
+ */
+void wayland_process_release(void)
+{
+    wayland_mutex_unlock(&process_wayland_mutex);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b9ea28be33c..847eecff875 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -100,6 +100,9 @@ static inline struct wayland *thread_wayland(void)
 BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
 BOOL wayland_init(struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
+BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
+void wayland_process_release(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
-- 
2.39.0.rc2

From 0fa4db8438eab8e3cb3766b4666224304b5b6e14 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 28 Nov 2022 18:30:33 +0200
Subject: [PATCH 012/202] configure: Add arch independent path to 32-bit
 PKG_CONFIG_LIBDIR

Add the architecture independent pkgconfig path /usr/share/pkgconfig
to the PKG_CONFIG_LIBDIR used for 32-bit builds.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure    | 2 +-
 configure.ac | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/configure b/configure
index 650bac9362e..6b3b1aa4650 100755
--- a/configure
+++ b/configure
@@ -6260,7 +6260,7 @@ printf "%s\n" "$wine_cv_cc_m32" >&6; }
       host_cpu="i386"
       notice_platform="32-bit "
       TARGETFLAGS="$TARGETFLAGS -m32"
-      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig}
+      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig}
       export PKG_CONFIG_LIBDIR
       with_unwind=${with_unwind:-no}
     else
diff --git a/configure.ac b/configure.ac
index 6eb8f93640a..aea78fc8475 100644
--- a/configure.ac
+++ b/configure.ac
@@ -130,7 +130,7 @@ case $host in
       host_cpu="i386"
       notice_platform="32-bit "
       TARGETFLAGS="$TARGETFLAGS -m32"
-      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig}
+      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig}
       export PKG_CONFIG_LIBDIR
       with_unwind=${with_unwind:-no}
     else
-- 
2.39.0.rc2

From 5b339edefc825a79afb2b1df37b7dc908f1ffb5f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 14:04:43 +0300
Subject: [PATCH 013/202] tools: Support building Wayland protocol source
 files.

Wayland protocol descriptions are distributed as source XML files that
need to be transformed to C source and header files with a version of
the wayland-scanner tool compatible with the used libwayland library.

This commit enhances the makedep build tool to support building such
Wayland protocol XML files. Components can use the WAYLAND_PROTOCOL_SRCS
build variable to add protocol XML files to their build.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure       | 93 +++++++++++++++++++++++++++++++++++++++++++++++--
 configure.ac    | 11 ++++--
 tools/makedep.c | 43 +++++++++++++++++++++++
 3 files changed, 142 insertions(+), 5 deletions(-)

diff --git a/configure b/configure
index 6b3b1aa4650..96e722f3c47 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,10 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+WAYLAND_SCANNER
+WAYLAND_PROTOCOLS_DATADIR
+WAYLAND_PROTOCOLS_LIBS
+WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_CLIENT_LIBS
 WAYLAND_CLIENT_CFLAGS
 X_EXTRA_LIBS
@@ -1740,6 +1744,8 @@ XMKMF
 CPP
 WAYLAND_CLIENT_CFLAGS
 WAYLAND_CLIENT_LIBS
+WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_PROTOCOLS_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2543,6 +2549,10 @@ Some influential environment variables:
               C compiler flags for wayland-client, overriding pkg-config
   WAYLAND_CLIENT_LIBS
               Linker flags for wayland-client, overriding pkg-config
+  WAYLAND_PROTOCOLS_CFLAGS
+              C compiler flags for wayland-protocols, overriding pkg-config
+  WAYLAND_PROTOCOLS_LIBS
+              Linker flags for wayland-protocols, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -15954,13 +15964,86 @@ fi
 
 CPPFLAGS=$ac_save_CPPFLAGS
 
+    if ${WAYLAND_PROTOCOLS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_PROTOCOLS_CFLAGS=`$PKG_CONFIG --cflags wayland-protocols 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_PROTOCOLS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_PROTOCOLS_LIBS=`$PKG_CONFIG --libs wayland-protocols 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-protocols cflags: $WAYLAND_PROTOCOLS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-protocols libs: $WAYLAND_PROTOCOLS_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_PROTOCOLS_CFLAGS"
+WAYLAND_PROTOCOLS_DATADIR=`$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    # Extract the first word of "wayland-scanner", so it can be a program name with args.
+set dummy wayland-scanner; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_WAYLAND_SCANNER+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  case $WAYLAND_SCANNER in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_WAYLAND_SCANNER="$WAYLAND_SCANNER" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_WAYLAND_SCANNER="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_WAYLAND_SCANNER" && ac_cv_path_WAYLAND_SCANNER="`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`"
+  ;;
+esac
+fi
+WAYLAND_SCANNER=$ac_cv_path_WAYLAND_SCANNER
+if test -n "$WAYLAND_SCANNER"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $WAYLAND_SCANNER" >&5
+printf "%s\n" "$WAYLAND_SCANNER" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
 fi
-if test -z "$WAYLAND_CLIENT_LIBS"
+if test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER"
 then :
   case "x$with_wayland" in
-  x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found, the Wayland driver won't be supported." ;;
+  x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
   xno) ;;
-  *)   as_fn_error $? "Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.
+  *)   as_fn_error $? "Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.
 This is an error since --with-wayland was requested." "$LINENO" 5 ;;
 esac
 enable_winewayland_drv=${enable_winewayland_drv:-no}
@@ -23324,6 +23407,10 @@ X_LIBS = $X_LIBS
 X_EXTRA_LIBS = $X_EXTRA_LIBS
 WAYLAND_CLIENT_CFLAGS = $WAYLAND_CLIENT_CFLAGS
 WAYLAND_CLIENT_LIBS = $WAYLAND_CLIENT_LIBS
+WAYLAND_PROTOCOLS_CFLAGS = $WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_PROTOCOLS_LIBS = $WAYLAND_PROTOCOLS_LIBS
+WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
+WAYLAND_SCANNER = $WAYLAND_SCANNER
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index aea78fc8475..e0a28333cb3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1414,9 +1414,16 @@ then
         [AC_CHECK_HEADERS([wayland-client.h])
          AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
                       [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_PROTOCOLS, [wayland-protocols],,,,
+         [AC_SUBST(WAYLAND_PROTOCOLS_DATADIR,
+                   `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
+    AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
+                 [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
 fi
-WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS"],
-                 [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER"],
+                 [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
 dnl **** Check for OpenCL ****
diff --git a/tools/makedep.c b/tools/makedep.c
index 893808930fb..f58c0c299e0 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -158,6 +158,7 @@ static const char *icotool;
 static const char *msgfmt;
 static const char *ln_s;
 static const char *sed_cmd;
+static const char *wayland_scanner;
 /* per-architecture global variables */
 static const char *arch_dirs[MAX_ARCHS];
 static const char *arch_pe_dirs[MAX_ARCHS];
@@ -472,6 +473,15 @@ static char *replace_filename( const char *path, const char *name )
     return ret;
 }
 
+/*******************************************************************
+ *         get_filename
+ */
+static char *get_filename( const char *name )
+{
+    char *filename = strrchr( name, '/' );
+    if (!filename) return strdup( name );
+    return strdup( filename + 1 );
+}
 
 /*******************************************************************
  *         replace_substr
@@ -1431,6 +1441,9 @@ static struct file *open_include_file( const struct makefile *make, struct incl_
         if ((file = open_local_generated_file( make, pFile, ".ico", ".svg" ))) return file;
     }
 
+    /* TODO: check for corresponding wayland protocol .xml file */
+    if (strendswith( pFile->name, "-client-protocol.h" )) return NULL;
+
     /* check for extra targets */
     if (strarray_exists( &make->extra_targets, pFile->name ))
     {
@@ -1918,6 +1931,23 @@ static void add_generated_sources( struct makefile *make )
             strarray_addall_uniq( &make->extra_imports,
                                   get_expanded_file_local_var( make, obj, "IMPORTS" ));
         }
+        if (strendswith( source->name, ".xml" ))
+        {
+            char *filename = get_filename( source->name );
+            char *code_filename = replace_extension ( filename , ".xml", "-protocol.c" );
+            char *header_filename = replace_extension ( filename , ".xml", "-client-protocol.h" );
+
+            file = add_generated_source( make, code_filename, NULL, 0 );
+            file->file->flags |= FLAG_C_UNIX;
+            file->use_msvcrt = 0;
+            file = add_generated_source( make, header_filename, NULL, 0 );
+            file->file->flags |= FLAG_C_UNIX;
+            file->use_msvcrt = 0;
+
+            free( filename );
+            free( code_filename );
+            free( header_filename );
+        }
     }
     if (make->testdll)
     {
@@ -3115,6 +3145,15 @@ static void output_source_spec( struct makefile *make, struct incl_file *source,
     }
 }
 
+static void output_source_xml( struct makefile *make, struct incl_file *source, const char *obj )
+{
+    char *base = get_filename( obj );
+    output( "%s-protocol.c: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s private-code $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner );
+    output( "%s-client-protocol.h: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s client-header $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner);
+    free( base );
+}
 
 /*******************************************************************
  *         output_source_one_arch
@@ -3258,6 +3297,7 @@ static const struct
     { "in", output_source_in },
     { "x", output_source_x },
     { "spec", output_source_spec },
+    { "xml", output_source_xml },
     { NULL, output_source_default }
 };
 
@@ -4104,6 +4144,7 @@ static void output_silent_rules(void)
         "MSG",
         "SED",
         "TEST",
+        "WAYLAND_SCANNER",
         "WIDL",
         "WMC",
         "WRC"
@@ -4203,6 +4244,7 @@ static void load_sources( struct makefile *make )
         "IN_SRCS",
         "PO_SRCS",
         "MANPAGES",
+        "WAYLAND_PROTOCOL_SRCS",
         NULL
     };
     const char **var;
@@ -4438,6 +4480,7 @@ int main( int argc, char *argv[] )
     msgfmt             = get_expanded_make_variable( top_makefile, "MSGFMT" );
     sed_cmd            = get_expanded_make_variable( top_makefile, "SED_CMD" );
     ln_s               = get_expanded_make_variable( top_makefile, "LN_S" );
+    wayland_scanner    = get_expanded_make_variable( top_makefile, "WAYLAND_SCANNER" );
 
     if (root_src_dir && !strcmp( root_src_dir, "." )) root_src_dir = NULL;
     if (tools_dir && !strcmp( tools_dir, "." )) tools_dir = NULL;
-- 
2.39.0.rc2

From af0004dcee977ec817ef012a818d94a45bc5d740 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 18:21:04 +0300
Subject: [PATCH 014/202] winewayland.drv: Handle Wayland output global events.

The wl_output global objects are dynamically created and destroyed by
the Wayland compositor to convey information about the display outputs.
This commit handles the creation and removal of wl_output objects as
well as related informational events to maintain a complete per-thread
display output state.

In addition to the core wl_output protocol object, the
xdg-output-unstable-v1 extension is used, if present, to get additional
information about the outputs, including their unique name and logical
coordinates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   4 +
 dlls/winewayland.drv/wayland.c        |  45 ++-
 dlls/winewayland.drv/wayland_output.c | 542 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  38 ++
 4 files changed, 628 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_output.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 627cda9b7d3..eb01feead76 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -7,7 +7,11 @@ C_SRCS = \
 	dllmain.c \
 	wayland.c \
 	wayland_mutex.c \
+	wayland_output.c \
 	waylanddrv_main.c \
 	window.c \
 
+WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
+
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 5f1de62c3b3..c114d80e302 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -38,7 +38,6 @@ static struct wayland_mutex process_wayland_mutex =
 {
     PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": process_wayland_mutex"
 };
-
 static struct wayland_mutex thread_wayland_mutex =
 {
     PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": thread_wayland_mutex"
@@ -58,6 +57,27 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
 
     TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
 
+    if (strcmp(interface, "wl_output") == 0)
+    {
+        if (!wayland_output_create(wayland, id, version))
+            ERR("Failed to create wayland_output for global id=%u\n", id);
+    }
+    else if (strcmp(interface, "zxdg_output_manager_v1") == 0)
+    {
+        struct wayland_output *output;
+
+        wayland->zxdg_output_manager_v1 =
+            wl_registry_bind(registry, id, &zxdg_output_manager_v1_interface,
+                             version < 3 ? version : 3);
+
+        /* Add zxdg_output_v1 to existing outputs. */
+        wl_list_for_each(output, &wayland->output_list, link)
+            wayland_output_use_xdg_extension(output);
+    }
+
+    /* The per-process wayland instance only handles output related globals. */
+    if (wayland_is_process(wayland)) return;
+
     if (strcmp(interface, "wl_compositor") == 0)
     {
         wayland->wl_compositor =
@@ -68,7 +88,20 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
                                           uint32_t id)
 {
+    struct wayland *wayland = data;
+    struct wayland_output *output, *tmp;
+
     TRACE("id=%d\n", id);
+
+    wl_list_for_each_safe(output, tmp, &wayland->output_list, link)
+    {
+        if (output->global_id == id)
+        {
+            TRACE("removing output->name=%s\n", output->name);
+            wayland_output_destroy(output);
+            return;
+        }
+    }
 }
 
 static const struct wl_registry_listener registry_listener = {
@@ -120,6 +153,8 @@ BOOL wayland_init(struct wayland *wayland)
         return FALSE;
     }
 
+    wl_list_init(&wayland->output_list);
+
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
 
@@ -152,12 +187,20 @@ BOOL wayland_init(struct wayland *wayland)
  */
 void wayland_deinit(struct wayland *wayland)
 {
+    struct wayland_output *output, *output_tmp;
+
     TRACE("%p\n", wayland);
 
     wayland_mutex_lock(&thread_wayland_mutex);
     wl_list_remove(&wayland->thread_link);
     wayland_mutex_unlock(&thread_wayland_mutex);
 
+    wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
+        wayland_output_destroy(output);
+
+    if (wayland->zxdg_output_manager_v1)
+        zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
+
     if (wayland->wl_compositor)
         wl_compositor_destroy(wayland->wl_compositor);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
new file mode 100644
index 00000000000..e1074edbe72
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -0,0 +1,542 @@
+/*
+ * Wayland output handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct default_mode { int32_t width; int32_t height; };
+static const struct default_mode default_modes[] = {
+    { 320,  200}, /* CGA 16:10 */
+    { 320,  240}, /* QVGA 4:3 */
+    { 400,  300}, /* qSVGA 4:3 */
+    { 480,  320}, /* HVGA 3:2 */
+    { 512,  384}, /* MAC 4:3 */
+    { 640,  360}, /* nHD 16:9 */
+    { 640,  400}, /* VESA-0100h 16:10 */
+    { 640,  480}, /* VGA 4:3 */
+    { 720,  480}, /* WVGA 3:2 */
+    { 720,  576}, /* PAL 5:4 */
+    { 768,  480}, /* WVGA 16:10 */
+    { 768,  576}, /* PAL* 4:3 */
+    { 800,  600}, /* SVGA 4:3 */
+    { 854,  480}, /* FWVGA 16:9 */
+    { 960,  540}, /* qHD 16:9 */
+    { 960,  640}, /* DVGA 3:2 */
+    {1024,  576}, /* WSVGA 16:9 */
+    {1024,  640}, /* WSVGA 16:10 */
+    {1024,  768}, /* XGA 4:3 */
+    {1152,  864}, /* XGA+ 4:3 */
+    {1280,  720}, /* HD 16:9 */
+    {1280,  768}, /* WXGA 5:3 */
+    {1280,  800}, /* WXGA 16:10 */
+    {1280,  960}, /* SXGA- 4:3 */
+    {1280, 1024}, /* SXGA 5:4 */
+    {1366,  768}, /* FWXGA 16:9 */
+    {1400, 1050}, /* SXGA+ 4:3 */
+    {1440,  900}, /* WSXGA 16:10 */
+    {1600,  900}, /* HD+ 16:9 */
+    {1600, 1200}, /* UXGA 4:3 */
+    {1680, 1050}, /* WSXGA+ 16:10 */
+    {1920, 1080}, /* FHD 16:9 */
+    {1920, 1200}, /* WUXGA 16:10 */
+    {2048, 1152}, /* QWXGA 16:9 */
+    {2048, 1536}, /* QXGA 4:3 */
+    {2560, 1440}, /* QHD 16:9 */
+    {2560, 1600}, /* WQXGA 16:10 */
+    {2560, 2048}, /* QSXGA 5:4 */
+    {2880, 1620}, /* 3K 16:9 */
+    {3200, 1800}, /* QHD+ 16:9 */
+    {3200, 2400}, /* QUXGA 4:3 */
+    {3840, 2160}, /* 4K 16:9 */
+    {3840, 2400}, /* WQUXGA 16:10 */
+    {5120, 2880}, /* 5K 16:9 */
+    {7680, 4320}, /* 8K 16:9 */
+};
+
+static const int32_t default_refresh = 60000;
+
+/**********************************************************************
+ *          Output handling
+ */
+
+/* Compare mode with the set of provided mode parameters and return -1 if the
+ * mode compares less than the parameters, 0 if the mode compares equal to the
+ * parameters, and 1 if the mode compares greater than the parameters.
+ *
+ * The comparison is based on comparing the width, height, bpp and refresh
+ * in that order.
+ */
+static int wayland_output_mode_cmp(struct wayland_output_mode *mode,
+                                   int32_t width, int32_t height,
+                                   int32_t refresh, int bpp)
+{
+    if (mode->width < width) return -1;
+    if (mode->width > width) return 1;
+    if (mode->height < height) return -1;
+    if (mode->height > height) return 1;
+    if (mode->bpp < bpp) return -1;
+    if (mode->bpp > bpp) return 1;
+    if (mode->refresh < refresh) return -1;
+    if (mode->refresh > refresh) return 1;
+    return 0;
+}
+
+static void wayland_output_add_mode(struct wayland_output *output,
+                                    int32_t width, int32_t height,
+                                    int32_t refresh, int bpp,
+                                    BOOL current, BOOL native)
+{
+    struct wayland_output_mode *mode;
+    struct wl_list *insert_after_link = output->mode_list.prev;
+
+    /* Update mode if it's already in list, otherwise find the insertion point
+     * to maintain the sorted order. */
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        int cmp = wayland_output_mode_cmp(mode, width, height, refresh, bpp);
+        if (cmp == 0) /* mode == new */
+        {
+            /* Upgrade modes from virtual to native, never the reverse. */
+            if (native) mode->native = TRUE;
+            if (current)
+                output->current_mode = mode;
+            return;
+        }
+        else if (cmp == 1) /* mode > new */
+        {
+            insert_after_link = mode->link.prev;
+            break;
+        }
+    }
+
+    mode = calloc(1, sizeof(*mode));
+
+    mode->width = width;
+    mode->height = height;
+    mode->refresh = refresh;
+    mode->bpp = bpp;
+    mode->native = native;
+
+    if (current)
+        output->current_mode = mode;
+
+    wl_list_insert(insert_after_link, &mode->link);
+}
+
+static void wayland_output_add_mode_all_bpp(struct wayland_output *output,
+                                            int32_t width, int32_t height,
+                                            int32_t refresh, BOOL current,
+                                            BOOL native)
+{
+    wayland_output_add_mode(output, width, height, refresh, 32, current, native);
+    wayland_output_add_mode(output, width, height, refresh, 16, FALSE, native);
+    wayland_output_add_mode(output, width, height, refresh, 8, FALSE, native);
+}
+
+static void wayland_output_add_default_modes(struct wayland_output *output)
+{
+    int i;
+    struct wayland_output_mode *mode, *tmp;
+    int32_t max_width = 0;
+    int32_t max_height = 0;
+    int32_t current_refresh =
+        output->current_mode ? output->current_mode->refresh : default_refresh;
+
+    /* Remove all existing virtual modes and get the maximum native
+     * mode size. */
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        if (!mode->native)
+        {
+            wl_list_remove(&mode->link);
+            free(mode);
+        }
+        else
+        {
+            max_width = mode->width > max_width ? mode->width : max_width;
+            max_height = mode->height > max_height ? mode->height : max_height;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(default_modes); i++)
+    {
+        int32_t width = default_modes[i].width;
+        int32_t height = default_modes[i].height;
+
+        /* Skip if this mode is larger than the largest native mode. */
+        if (width > max_width || height > max_height)
+        {
+            TRACE("Skipping mode %dx%d (max: %dx%d)\n",
+                    width, height, max_width, max_height);
+            continue;
+        }
+
+        wayland_output_add_mode_all_bpp(output, width, height, current_refresh,
+                                        FALSE, FALSE);
+    }
+}
+
+static int wayland_output_cmp_x(struct wayland_output *a, struct wayland_output *b)
+{
+    if (a->logical_x < b->logical_x) return -1;
+    if (a->logical_x > b->logical_x) return 1;
+    if (a->logical_y < b->logical_y) return -1;
+    if (a->logical_y > b->logical_y) return 1;
+    return 0;
+}
+
+static int wayland_output_cmp_y(struct wayland_output *a, struct wayland_output *b)
+{
+    if (a->logical_y < b->logical_y) return -1;
+    if (a->logical_y > b->logical_y) return 1;
+    if (a->logical_x < b->logical_x) return -1;
+    if (a->logical_x > b->logical_x) return 1;
+    return 0;
+}
+
+static struct wayland_output** wayland_output_list_sorted(struct wl_list *output_list,
+                                                          int (*cmp)(struct wayland_output *,
+                                                                     struct wayland_output *))
+{
+    int num_outputs = wl_list_length(output_list);
+    int num_sorted = 0;
+    struct wayland_output **sorted;
+    struct wayland_output *o;
+
+    sorted = malloc(sizeof(*sorted) * (num_outputs + 1));
+    if (!sorted)
+    {
+        ERR("Couldn't allocate space for sorted outputs\n");
+        return NULL;
+    }
+
+    wl_list_for_each(o, output_list, link)
+    {
+        int j = num_sorted;
+        while (j > 0 && cmp(o, sorted[j - 1]) < 0)
+        {
+            sorted[j] = sorted[j - 1];
+            j--;
+        }
+        sorted[j] = o;
+        num_sorted++;
+    }
+
+    sorted[num_outputs] = NULL;
+    return sorted;
+}
+
+static void wayland_output_list_update_physical_coords(struct wl_list *output_list)
+{
+    struct wayland_output **sorted_x, **sorted_y;
+    struct wayland_output **cur_p, **prev_p;
+    struct wayland_output *cur, *prev;
+
+    /* Set default physical coordinates. */
+    wl_list_for_each(cur, output_list, link)
+    {
+        cur->x = cur->logical_x;
+        cur->y = cur->logical_y;
+    }
+
+    /* Sort and process the outputs from left to right. */
+    cur_p = sorted_x = wayland_output_list_sorted(output_list, wayland_output_cmp_x);
+    if (!sorted_x) return;
+
+    while ((cur = *cur_p))
+    {
+        /* Update output->x based on other outputs that are to to the left. */
+        prev_p = sorted_x;
+        while ((prev = *prev_p) != cur)
+        {
+            if (cur->logical_x == prev->logical_x + prev->logical_w &&
+                prev->current_mode)
+            {
+                int new_x = prev->x + prev->current_mode->width;
+                if (new_x > cur->x) cur->x = new_x;
+            }
+            prev_p++;
+        }
+
+        cur_p++;
+    }
+
+    free(sorted_x);
+
+    /* Now sort and process the outputs from top to bottom. */
+    cur_p = sorted_y = wayland_output_list_sorted(output_list, wayland_output_cmp_y);
+    if (!sorted_y) return;
+
+    while ((cur = *cur_p))
+    {
+        /* Update output->y based on other outputs that are above. */
+        prev_p = sorted_y;
+        while ((prev = *prev_p) != cur)
+        {
+            if (cur->logical_y == prev->logical_y + prev->logical_h &&
+                prev->current_mode)
+            {
+                int new_y = prev->y + prev->current_mode->height;
+                if (new_y > cur->y) cur->y = new_y;
+            }
+            prev_p++;
+        }
+
+        cur_p++;
+    }
+
+    free(sorted_y);
+}
+
+static void wayland_output_clear_modes(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode, *tmp;
+
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        wl_list_remove(&mode->link);
+        free(mode);
+    }
+}
+
+static void wayland_output_done(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode;
+    struct wayland_output *o;
+
+    TRACE("output->name=%s\n", output->name);
+
+    wayland_output_add_default_modes(output);
+    wayland_output_list_update_physical_coords(&output->wayland->output_list);
+
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        TRACE("mode %dx%d @ %d %s\n",
+              mode->width, mode->height, mode->refresh,
+              output->current_mode == mode ? "*" : "");
+    }
+
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (!o->current_mode) continue;
+        TRACE("output->name=%s logical=%d,%d+%dx%d physical=%d,%d+%dx%d\n",
+              o->name,
+              o->logical_x, output->logical_y, o->logical_w, o->logical_h,
+              o->x, o->y, o->current_mode->width, o->current_mode->height);
+    }
+}
+
+static void output_handle_geometry(void *data, struct wl_output *wl_output,
+                                   int32_t x, int32_t y,
+                                   int32_t physical_width, int32_t physical_height,
+                                   int32_t subpixel,
+                                   const char *make, const char *model,
+                                   int32_t output_transform)
+{
+}
+
+static void output_handle_mode(void *data, struct wl_output *wl_output,
+                               uint32_t flags, int32_t width, int32_t height,
+                               int32_t refresh)
+{
+    struct wayland_output *output = data;
+
+    /* Windows apps don't expect a zero refresh rate, so use a default value. */
+    if (refresh == 0) refresh = default_refresh;
+
+    wayland_output_add_mode_all_bpp(output, width, height, refresh,
+                                    (flags & WL_OUTPUT_MODE_CURRENT),
+                                    TRUE);
+}
+
+static void output_handle_done(void *data, struct wl_output *wl_output)
+{
+    struct wayland_output *output = data;
+    if (!output->zxdg_output_v1 ||
+        zxdg_output_v1_get_version(output->zxdg_output_v1) >= 3)
+    {
+        wayland_output_done(output);
+    }
+}
+
+static void output_handle_scale(void *data, struct wl_output *wl_output,
+                                int32_t scale)
+{
+    struct wayland_output *output = data;
+    TRACE("output=%p scale=%d\n", output, scale);
+    output->scale = scale;
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale
+};
+
+static void zxdg_output_v1_handle_logical_position(void *data,
+                                                   struct zxdg_output_v1 *zxdg_output_v1,
+                                                   int32_t x,
+                                                   int32_t y)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_x=%d logical_y=%d\n", x, y);
+    output->logical_x = x;
+    output->logical_y = y;
+}
+
+static void zxdg_output_v1_handle_logical_size(void *data,
+                                               struct zxdg_output_v1 *zxdg_output_v1,
+                                               int32_t width,
+                                               int32_t height)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_w=%d logical_h=%d\n", width, height);
+    output->logical_w = width;
+    output->logical_h = height;
+}
+
+static void zxdg_output_v1_handle_done(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1)
+{
+    if (zxdg_output_v1_get_version(zxdg_output_v1) < 3)
+    {
+        struct wayland_output *output = data;
+        wayland_output_done(output);
+    }
+}
+
+static void zxdg_output_v1_handle_name(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1,
+                                       const char *name)
+{
+    struct wayland_output *output = data;
+
+    free(output->name);
+    output->name = strdup(name);
+}
+
+static void zxdg_output_v1_handle_description(void *data,
+                                              struct zxdg_output_v1 *zxdg_output_v1,
+                                              const char *description)
+{
+}
+
+static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
+    zxdg_output_v1_handle_logical_position,
+    zxdg_output_v1_handle_logical_size,
+    zxdg_output_v1_handle_done,
+    zxdg_output_v1_handle_name,
+    zxdg_output_v1_handle_description,
+};
+
+/**********************************************************************
+ *          wayland_output_create
+ *
+ *  Creates a wayland_output and adds it to the output list.
+ */
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version)
+{
+    struct wayland_output *output = calloc(1, sizeof(*output));
+
+    if (!output)
+    {
+        ERR("Couldn't allocate space for wayland_output\n");
+        goto err;
+    }
+
+    output->wayland = wayland;
+    output->wl_output = wl_registry_bind(wayland->wl_registry, id,
+                                         &wl_output_interface,
+                                         version < 2 ? version : 2);
+    output->global_id = id;
+    wl_output_add_listener(output->wl_output, &output_listener, output);
+
+    wl_list_init(&output->mode_list);
+    wl_list_init(&output->link);
+
+    output->scale = 1;
+
+    /* Have a fallback in case xdg_output is not supported or name is not sent. */
+    output->name = malloc(20);
+    if (output->name)
+    {
+        snprintf(output->name, 20, "WaylandOutput%d",
+                 wayland->next_fallback_output_id++);
+    }
+    else
+    {
+        ERR("Couldn't allocate space for output name\n");
+        goto err;
+    }
+
+    if (wayland->zxdg_output_manager_v1)
+        wayland_output_use_xdg_extension(output);
+
+    wl_list_insert(output->wayland->output_list.prev, &output->link);
+
+    return TRUE;
+
+err:
+    if (output) wayland_output_destroy(output);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_output_destroy
+ *
+ *  Destroys a wayland_output.
+ */
+void wayland_output_destroy(struct wayland_output *output)
+{
+    wayland_output_clear_modes(output);
+    wl_list_remove(&output->link);
+    free(output->name);
+    if (output->zxdg_output_v1)
+        zxdg_output_v1_destroy(output->zxdg_output_v1);
+    wl_output_destroy(output->wl_output);
+
+    free(output);
+}
+
+/**********************************************************************
+ *          wayland_output_use_xdg_extension
+ *
+ *  Use the zxdg_output_v1 extension to get output information.
+ */
+void wayland_output_use_xdg_extension(struct wayland_output *output)
+{
+    output->zxdg_output_v1 =
+        zxdg_output_manager_v1_get_xdg_output(output->wayland->zxdg_output_manager_v1,
+                                              output->wl_output);
+    zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
+                                output);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 847eecff875..2709e49e52d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <pthread.h>
 #include <stdarg.h>
 #include <wayland-client.h>
+#include "xdg-output-unstable-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -63,6 +64,35 @@ struct wayland
     struct wl_event_queue *wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
+    uint32_t next_fallback_output_id;
+    struct wl_list output_list;
+};
+
+struct wayland_output_mode
+{
+    struct wl_list link;
+    int32_t width;
+    int32_t height;
+    int32_t refresh;
+    int bpp;
+    BOOL native;
+};
+
+struct wayland_output
+{
+    struct wl_list link;
+    struct wayland *wayland;
+    struct wl_output *wl_output;
+    struct zxdg_output_v1 *zxdg_output_v1;
+    struct wl_list mode_list;
+    struct wayland_output_mode *current_mode;
+    int logical_x, logical_y;  /* logical position */
+    int logical_w, logical_h;  /* logical size */
+    int x, y;  /* position in native pixel coordinate space */
+    int scale; /* wayland output scale factor for hidpi */
+    char *name;
+    uint32_t global_id;
 };
 
 /**********************************************************************
@@ -114,6 +144,14 @@ void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 void wayland_mutex_lock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland output
+ */
+
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version) DECLSPEC_HIDDEN;
+void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.39.0.rc2

From 73cac102940e4b9d2c4bbe86630cc39c45e7f8cf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:28:21 +0300
Subject: [PATCH 015/202] winewayland.drv: Update Windows monitor information
 on Wayland changes.

Whenever the Wayland output display state changes (including during
initialization), update the monitor information on the Windows side to
reflect these changes. The update happens when handling output events
targeting the per-process Wayland instance.

We currently support a single GPU, and a single monitor for each
adapter.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/display.c         | 197 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c         |   9 ++
 dlls/winewayland.drv/wayland_output.c  |  10 ++
 dlls/winewayland.drv/waylanddrv.h      |   5 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 6 files changed, 223 insertions(+)
 create mode 100644 dlls/winewayland.drv/display.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index eb01feead76..569679f07c5 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -4,6 +4,7 @@ UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
 UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
+	display.c \
 	dllmain.c \
 	wayland.c \
 	wayland_mutex.c \
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..d6425dc2b4d
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,197 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static BOOL force_display_devices_refresh;
+
+static void wayland_refresh_display_devices(void)
+{
+    UINT32 num_path, num_mode;
+    force_display_devices_refresh = TRUE;
+    /* Trigger refresh in win32u */
+    NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
+}
+
+void wayland_init_display_devices()
+{
+    wayland_refresh_display_devices();
+}
+
+static void wayland_add_device_gpu(const struct gdi_device_manager *device_manager,
+                                   void *param)
+{
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    struct gdi_gpu gpu = {0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    /* TODO: Fill in gpu information from vulkan. */
+
+    TRACE("id=0x%s name=%s\n",
+          wine_dbgstr_longlong(gpu.id), wine_dbgstr_w(gpu.name));
+
+    device_manager->add_gpu(&gpu, param);
+}
+
+static void wayland_add_device_adapter(const struct gdi_device_manager *device_manager,
+                                       void *param, INT output_id)
+{
+    struct gdi_adapter adapter;
+    adapter.id = output_id;
+    adapter.state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
+    if (output_id == 0)
+        adapter.state_flags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    TRACE("id=0x%s state_flags=0x%x\n",
+          wine_dbgstr_longlong(adapter.id), (UINT)adapter.state_flags);
+
+    device_manager->add_adapter(&adapter, param);
+}
+
+static void wayland_add_device_monitor(const struct gdi_device_manager *device_manager,
+                                       void *param, struct wayland_output *output)
+{
+
+    struct gdi_monitor monitor = {0};
+    DWORD len = 0;
+
+    if (RtlUTF8ToUnicodeN(monitor.name, sizeof(monitor.name), &len,
+                          output->name, strlen(output->name) + 1))
+    {
+        monitor.name[0] = 0;
+    }
+
+    SetRect(&monitor.rc_monitor, output->x, output->y,
+            output->x + output->current_mode->width,
+            output->y + output->current_mode->height);
+
+    /* We don't have a direct way to get the work area in Wayland. */
+    monitor.rc_work = monitor.rc_monitor;
+
+    monitor.state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+
+    TRACE("name=%s rc_monitor=rc_work=%s state_flags=0x%x\n",
+          wine_dbgstr_w(monitor.name), wine_dbgstr_rect(&monitor.rc_monitor),
+          (UINT)monitor.state_flags);
+
+    device_manager->add_monitor(&monitor, param);
+}
+
+static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
+{
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY;
+    mode->dmDisplayOrientation = DMDO_DEFAULT;
+    mode->dmDisplayFlags = 0;
+    mode->dmBitsPerPel = output_mode->bpp;
+    mode->dmPelsWidth = output_mode->width;
+    mode->dmPelsHeight = output_mode->height;
+    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+}
+
+static void wayland_add_device_modes(const struct gdi_device_manager *device_manager,
+                                     void *param, struct wayland_output *output)
+{
+
+    struct wayland_output_mode *output_mode;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        DEVMODEW mode;
+        populate_devmode(output_mode, &mode);
+        device_manager->add_mode(&mode, param);
+    }
+}
+
+static void wayland_add_device_output(const struct gdi_device_manager *device_manager,
+                                      void *param, struct wayland_output *output,
+                                      INT output_id)
+{
+    /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+    wayland_add_device_adapter(device_manager, param, output_id);
+    wayland_add_device_monitor(device_manager, param, output);
+    wayland_add_device_modes(device_manager, param, output);
+}
+
+static struct wayland_output *wayland_get_primary_output(struct wayland *wayland)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (output->current_mode && output->x == 0 && output->y == 0)
+            return output;
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *      UpdateDisplayDevices (WAYLAND.@)
+ */
+BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param)
+{
+    struct wayland *wayland;
+    struct wayland_output *output, *primary;
+    INT output_id = 0;
+
+    if (!force && !force_display_devices_refresh) return TRUE;
+
+    TRACE("force=%d force_refresh=%d\n", force, force_display_devices_refresh);
+
+    force_display_devices_refresh = FALSE;
+
+    wayland = wayland_process_acquire();
+
+    wayland_add_device_gpu(device_manager, param);
+
+    /* Get the primary output (i.e., positioned at 0,0) and add it with id 0. */
+    primary = wayland_get_primary_output(wayland);
+    if (primary)
+    {
+        wayland_add_device_output(device_manager, param, primary, output_id);
+        output_id++;
+    }
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_mode || output == primary) continue;
+        wayland_add_device_output(device_manager, param, output, output_id);
+        output_id++;
+    }
+
+    wayland_process_release();
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c114d80e302..f8df12107b4 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -99,6 +99,15 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
         {
             TRACE("removing output->name=%s\n", output->name);
             wayland_output_destroy(output);
+            if (wayland_is_process(wayland))
+            {
+                /* Temporarily release the per-process instance lock, so that
+                 * wayland_init_display_devices can perform more fine grained
+                 * locking to avoid deadlocks. */
+                wayland_process_release();
+                wayland_init_display_devices();
+                wayland_process_acquire();
+            }
             return;
         }
     }
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index e1074edbe72..9d82cd288cb 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -352,6 +352,16 @@ static void wayland_output_done(struct wayland_output *output)
               o->logical_x, output->logical_y, o->logical_w, o->logical_h,
               o->x, o->y, o->current_mode->width, o->current_mode->height);
     }
+
+    if (wayland_is_process(output->wayland))
+    {
+        /* Temporarily release the per-process instance lock, so that
+         * wayland_init_display_devices can perform more fine grained locking
+         * to avoid deadlocks. */
+        wayland_process_release();
+        wayland_init_display_devices();
+        wayland_process_acquire();
+    }
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 2709e49e52d..ee75f233741 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -32,9 +32,11 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h"
 #include "ntuser.h"
 
 #include "unixlib.h"
+#include "wine/gdi_driver.h"
 
 /**********************************************************************
  *          Globals
@@ -133,6 +135,7 @@ void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
 BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
 struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
 void wayland_process_release(void) DECLSPEC_HIDDEN;
+void wayland_init_display_devices(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
@@ -157,5 +160,7 @@ void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HI
  */
 
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 677637015e0..fa404a5bc75 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -85,6 +85,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
+    .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
 };
 
 static const struct user_driver_funcs null_funcs = { 0 };
-- 
2.39.0.rc2

From 1c8a72c3af23f4829ad24c31f10504c0e84026ec Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 27 May 2022 14:35:48 +0300
Subject: [PATCH 016/202] winewayland.drv: Add helpers for sending window
 messages.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ee75f233741..96d4abf8576 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -155,6 +155,25 @@ BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t versio
 void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          USER32 helpers
+ */
+
+static inline LRESULT send_message(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserSendDriverMessage, FALSE);
+}
+
+static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+                                           UINT flags, UINT timeout, PDWORD_PTR res_ptr)
+{
+    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
+    LRESULT res = NtUserMessageCall(hwnd, msg, wparam, lparam, &params,
+                                    NtUserSendMessageTimeout, FALSE);
+    if (res_ptr) *res_ptr = res;
+    return params.result;
+}
+
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.39.0.rc2

From f6e51f4ec6e45acc8453f4ff8c218a2ff1a17a23 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 26 Sep 2022 10:27:47 +0300
Subject: [PATCH 017/202] winewayland.drv: Update desktop window size on
 Wayland output changes.

Update the desktop window size to match the current the output
configuration.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 16 ++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 21 +++++++++++++++++++++
 4 files changed, 39 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index d6425dc2b4d..3b4935ccfb3 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -43,9 +43,25 @@ static void wayland_refresh_display_devices(void)
     NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
 }
 
+static void wayland_resize_desktop_window(void)
+{
+    BOOL wayland_initialized = wayland_process_acquire()->initialized;
+    wayland_process_release();
+
+    /* During process wayland initialization we will get our initial output
+     * information and init the display devices. There is no need to resize the
+     * desktop in this case, since this is the initial display state.
+     * Additionally, initialization may occur in a context that has acquired
+     * the internal Wine user32 lock, and sending messages would lead to an
+     * internal user32 lock error. */
+    if (wayland_initialized)
+        send_message(NtUserGetDesktopWindow(), WM_DISPLAYCHANGE, 0, 0);
+}
+
 void wayland_init_display_devices()
 {
     wayland_refresh_display_devices();
+    wayland_resize_desktop_window();
 }
 
 static void wayland_add_device_gpu(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 96d4abf8576..dc8dc37728a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -179,6 +179,7 @@ static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, L
  */
 
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index fa404a5bc75..3e40c09eab7 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -84,6 +84,7 @@ static void WAYLAND_ThreadDetach(void)
 static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
+    .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
 };
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 86c621a369e..5ffe75257af 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -51,3 +51,24 @@ BOOL WAYLAND_CreateWindow(HWND hwnd)
 
     return TRUE;
 }
+
+/**********************************************************************
+ *           WAYLAND_DesktopWindowProc
+ */
+LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_DISPLAYCHANGE:
+        {
+            RECT virtual_rect = NtUserGetVirtualScreenRect();
+            NtUserSetWindowPos(hwnd, 0, virtual_rect.left, virtual_rect.top,
+                               virtual_rect.right - virtual_rect.left,
+                               virtual_rect.bottom - virtual_rect.top,
+                               SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE);
+        }
+        break;
+    }
+
+    return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserDefWindowProc, FALSE);
+}
-- 
2.39.0.rc2

From 6817ab43d43244abee329472dc7b5fa4efcb742b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 9 Nov 2021 19:22:04 +0200
Subject: [PATCH 018/202] winewayland.drv: Update registry settings after
 monitor changes.

Also update the desktop window size to match the virtual screen size.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c | 39 ++++++++++++++++++++++++++++++++++
 1 file changed, 39 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 3b4935ccfb3..660fd8bc02e 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -58,9 +58,48 @@ static void wayland_resize_desktop_window(void)
         send_message(NtUserGetDesktopWindow(), WM_DISPLAYCHANGE, 0, 0);
 }
 
+/* Initialize registry display settings when new display devices are added */
+static void wayland_init_registry_display_settings(void)
+{
+    DEVMODEW dm = {.dmSize = sizeof(dm)};
+    DISPLAY_DEVICEW dd = {sizeof(dd)};
+    UNICODE_STRING device_name;
+    DWORD i = 0;
+    int ret;
+
+    while (!NtUserEnumDisplayDevices(NULL, i++, &dd, 0))
+    {
+        RtlInitUnicodeString(&device_name, dd.DeviceName);
+
+        /* Skip if the device already has registry display settings */
+        if (NtUserEnumDisplaySettings(&device_name, ENUM_REGISTRY_SETTINGS, &dm, 0))
+            continue;
+
+        if (!NtUserEnumDisplaySettings(&device_name, ENUM_CURRENT_SETTINGS, &dm, 0))
+        {
+            ERR("Failed to query current display settings for %s.\n", wine_dbgstr_w(dd.DeviceName));
+            continue;
+        }
+
+        TRACE("Device %s current display mode %ux%u %ubits %uHz at %d,%d.\n",
+              wine_dbgstr_w(dd.DeviceName), (UINT)dm.dmPelsWidth, (UINT)dm.dmPelsHeight,
+              (UINT)dm.dmBitsPerPel, (UINT)dm.dmDisplayFrequency, (int)dm.dmPosition.x,
+              (int)dm.dmPosition.y);
+
+        ret = NtUserChangeDisplaySettings(&device_name, &dm, NULL,
+                                          CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL);
+        if (ret != DISP_CHANGE_SUCCESSFUL)
+        {
+            ERR("Failed to save registry display settings for %s, returned %d.\n",
+                wine_dbgstr_w(dd.DeviceName), ret);
+        }
+    }
+}
+
 void wayland_init_display_devices()
 {
     wayland_refresh_display_devices();
+    wayland_init_registry_display_settings();
     wayland_resize_desktop_window();
 }
 
-- 
2.39.0.rc2

From a9b047a90404bd33c27c51e2aac84d663c10e62f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 9 Nov 2021 18:58:22 +0200
Subject: [PATCH 019/202] winewayland.drv: Add stub for driver window messages.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 16 ++++++++++++++++
 3 files changed, 18 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dc8dc37728a..8b2c48a0d28 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -182,5 +182,6 @@ BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 3e40c09eab7..e2dcc06f27b 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -87,6 +87,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
+    .pWindowMessage = WAYLAND_WindowMessage,
 };
 
 static const struct user_driver_funcs null_funcs = { 0 };
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 5ffe75257af..1ef22787709 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -72,3 +72,19 @@ LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserDefWindowProc, FALSE);
 }
+
+/**********************************************************************
+ *           WAYLAND_WindowMessage
+ */
+LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    TRACE("msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
+
+    switch (msg)
+    {
+    default:
+        FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
+    }
+
+    return 0;
+}
-- 
2.39.0.rc2

From d0c5e0d4f5f6eb9138f7c9340e0d757c3e43b2fd Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 23 Feb 2022 12:28:33 +0200
Subject: [PATCH 020/202] winewayland.drv: Implement Wine monitor change
 notification.

Introduce a mechanism to synchronously (in the ideal case) notify all
Wayland capable threads about changes in the current Wine monitor setup.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c    |  1 +
 dlls/winewayland.drv/wayland.c    | 37 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h | 10 +++++++++
 dlls/winewayland.drv/window.c     |  7 ++++++
 4 files changed, 55 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 660fd8bc02e..03a48035946 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -99,6 +99,7 @@ static void wayland_init_registry_display_settings(void)
 void wayland_init_display_devices()
 {
     wayland_refresh_display_devices();
+    wayland_notify_wine_monitor_change();
     wayland_init_registry_display_settings();
     wayland_resize_desktop_window();
 }
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f8df12107b4..6dce3dfeddf 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -273,3 +273,40 @@ void wayland_process_release(void)
 {
     wayland_mutex_unlock(&process_wayland_mutex);
 }
+
+/**********************************************************************
+ *          wayland_notify_wine_monitor_change
+ *
+ * Notify all wayland instances about a change in the state of wine monitors.
+ * The notification is synchronous, this function returns after all wayland
+ * instances have handled the event, except if it a thread is slow to process
+ * the message, and thus likely to be blocked by this synchronous operation.
+ */
+void wayland_notify_wine_monitor_change(void)
+{
+    struct wayland *w;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    /* Each thread maintains its own output information, so we need to notify
+     * all threads about the change. We can't guarantee that all threads will
+     * have windows to which we could potentially send the notification message
+     * to, so we use the internal send function to target the threads directly.
+     * We can't use PostThreadMessage since we require synchronous message
+     * handling. */
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        LRESULT res;
+        TRACE("notifying thread %04x\n", (UINT)w->thread_id);
+        /* Use a timeout of 50ms to avoid blocking indefinitely if the
+         * target thread is not processing (and to avoid deadlocks). */
+        res = __wine_send_internal_message_timeout(w->process_id, w->thread_id,
+                                                   WM_WAYLAND_MONITOR_CHANGE,
+                                                   0, 0, 0, 50, NULL);
+        /* If we weren't able to synchronously send the message, post it. */
+        if (!res)
+            NtUserPostThreadMessage(w->thread_id, WM_WAYLAND_MONITOR_CHANGE, 0, 0);
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8b2c48a0d28..cdb7b0965e5 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -44,6 +44,15 @@
 
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 
+/**********************************************************************
+  *          Internal messages and data
+  */
+
+enum wayland_window_message
+{
+    WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -154,6 +163,7 @@ void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
 BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version) DECLSPEC_HIDDEN;
 void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_notify_wine_monitor_change(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER32 helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 1ef22787709..054a9c9c393 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -52,6 +52,10 @@ BOOL WAYLAND_CreateWindow(HWND hwnd)
     return TRUE;
 }
 
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+}
+
 /**********************************************************************
  *           WAYLAND_DesktopWindowProc
  */
@@ -82,6 +86,9 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     switch (msg)
     {
+    case WM_WAYLAND_MONITOR_CHANGE:
+        handle_wm_wayland_monitor_change(thread_wayland());
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From fda2f78b0caf6d8c9aadea3ef7e7cf8c69a0a9a9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 19 May 2022 13:45:44 +0300
Subject: [PATCH 021/202] winewayland.drv: Add helpers for converting between
 ASCII and WCHAR strings.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in  |   1 +
 dlls/winewayland.drv/unicode.c    | 105 ++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  11 ++++
 3 files changed, 117 insertions(+)
 create mode 100644 dlls/winewayland.drv/unicode.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 569679f07c5..8ec6bff197f 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -6,6 +6,7 @@ UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	unicode.c \
 	wayland.c \
 	wayland_mutex.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/unicode.c b/dlls/winewayland.drv/unicode.c
new file mode 100644
index 00000000000..7cce78573a7
--- /dev/null
+++ b/dlls/winewayland.drv/unicode.c
@@ -0,0 +1,105 @@
+/*
+ * Wayland driver unicode helpers
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+/**********************************************************************
+ *          ascii_to_unicode_maybe_z
+ *
+ * Converts an ascii, possibly zero-terminated, string containing up to
+ * src_max_chars to a unicode string. Returns the number of characters
+ * (including any trailing zero) in the source ascii string. If the returned
+ * number of characters is greater than dst_max_chars the output will have been
+ * truncated.
+ */
+size_t ascii_to_unicode_maybe_z(WCHAR *dst, size_t dst_max_chars,
+                                const char *src, size_t src_max_chars)
+{
+    size_t src_len = 0;
+
+    while (src_max_chars--)
+    {
+        src_len++;
+        if (dst_max_chars)
+        {
+            *dst++ = *src;
+            dst_max_chars--;
+        }
+        if (!*src++) break;
+    }
+
+    return src_len;
+}
+
+/**********************************************************************
+ *          unicode_to_ascii_maybe_z
+ *
+ * Converts a unicode, possibly zero-terminated, string containing up to
+ * src_max_chars to an ascii string. Returns the number of characters
+ * (including any trailing zero) in the source unicode string. If the returned
+ * number of characters is greater than dst_max_chars the output will have been
+ * truncated.
+ */
+size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
+                                const WCHAR *src, size_t src_max_chars)
+{
+    size_t src_len = 0;
+
+    while (src_max_chars--)
+    {
+        src_len++;
+        if (dst_max_chars)
+        {
+            *dst++ = *src;
+            dst_max_chars--;
+        }
+        if (!*src++) break;
+    }
+
+    return src_len;
+}
+
+/**********************************************************************
+ *          ascii_to_unicode_z
+ *
+ * Converts an ascii, possibly zero-terminated, string containing up to
+ * src_max_chars to a zero-terminated unicode string. Returns the number of
+ * characters (including the trailing zero) written to the destination string.
+ * If there isn't enough space in the destination to hold all the characters
+ * and the trailing zero, the string is truncated enough so that a trailing
+ * zero can be placed.
+ */
+size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
+                          const char *src, size_t src_max_chars)
+{
+    size_t len;
+    if (src_max_chars == 0) return 0;
+    len = ascii_to_unicode_maybe_z(dst, dst_max_chars, src, src_max_chars);
+    if (len >= dst_max_chars) len = dst_max_chars - 1;
+    if (len > 0 && dst[len - 1] == 0) len--;
+    dst[len] = 0;
+    return len + 1;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index cdb7b0965e5..35525e33502 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -165,6 +165,17 @@ void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_notify_wine_monitor_change(void) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Misc. helpers
+ */
+
+size_t ascii_to_unicode_maybe_z(WCHAR *dst, size_t dst_max_chars,
+                                const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
+                                const WCHAR *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
+                          const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          USER32 helpers
  */
-- 
2.39.0.rc2

From 6eb0b2446375c05d2660105a726f814f346c9c71 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 8 Nov 2021 13:23:34 +0200
Subject: [PATCH 022/202] winewayland.drv: Track the Wine monitor associated
 with a Wayland output.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c        | 10 +++++
 dlls/winewayland.drv/wayland_output.c | 53 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  4 ++
 dlls/winewayland.drv/window.c         |  1 +
 4 files changed, 68 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 03a48035946..43d3aef3635 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -193,10 +193,20 @@ static void wayland_add_device_output(const struct gdi_device_manager *device_ma
                                       void *param, struct wayland_output *output,
                                       INT output_id)
 {
+    char buf[16];
+    int len;
+
     /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
     wayland_add_device_adapter(device_manager, param, output_id);
     wayland_add_device_monitor(device_manager, param, output);
     wayland_add_device_modes(device_manager, param, output);
+
+    /* Set the wine name in wayland_output so that we can look it up. */
+    len = snprintf(buf, sizeof(buf), "\\\\.\\DISPLAY%u", output_id + 1);
+    if (len > sizeof(buf)) len = sizeof(buf);
+    ascii_to_unicode_z(output->wine_name, ARRAY_SIZE(output->wine_name), buf, len);
+    TRACE("name=%s wine_name=%s\n",
+          output->name, wine_dbgstr_w(output->wine_name));
 }
 
 static struct wayland_output *wayland_get_primary_output(struct wayland *wayland)
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 9d82cd288cb..af095afa446 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -362,6 +362,10 @@ static void wayland_output_done(struct wayland_output *output)
         wayland_init_display_devices();
         wayland_process_acquire();
     }
+    else
+    {
+        wayland_update_outputs_from_process(output->wayland);
+    }
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
@@ -550,3 +554,52 @@ void wayland_output_use_xdg_extension(struct wayland_output *output)
     zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
                                 output);
 }
+
+/**********************************************************************
+ *          wayland_update_outputs_from_process
+ *
+ * Update the information in the outputs of this instance, using the
+ * information in the process wayland instance.
+ */
+void wayland_update_outputs_from_process(struct wayland *wayland)
+{
+    struct wayland_output *output;
+    struct wayland_output *process_output;
+    struct wayland *process_wayland = wayland_process_acquire();
+
+    TRACE("wayland=%p process_wayland=%p\n", wayland, process_wayland);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        wl_list_for_each(process_output, &process_wayland->output_list, link)
+        {
+            if (!strcmp(output->name, process_output->name))
+            {
+                lstrcpyW(output->wine_name, process_output->wine_name);
+                break;
+            }
+        }
+    }
+
+    wayland_process_release();
+}
+
+/**********************************************************************
+ *          wayland_output_get_by_wine_name
+ *
+ *  Returns the wayland_output with the specified Wine name (or NULL
+ *  if not present).
+ */
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!wcsicmp(wine_name, output->wine_name))
+            return output;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 35525e33502..3e362b50db1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -103,6 +103,7 @@ struct wayland_output
     int x, y;  /* position in native pixel coordinate space */
     int scale; /* wayland output scale factor for hidpi */
     char *name;
+    WCHAR wine_name[128];
     uint32_t global_id;
 };
 
@@ -164,6 +165,9 @@ BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t versio
 void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_notify_wine_monitor_change(void) DECLSPEC_HIDDEN;
+void wayland_update_outputs_from_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Misc. helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 054a9c9c393..4e1d68c5bae 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -54,6 +54,7 @@ BOOL WAYLAND_CreateWindow(HWND hwnd)
 
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
+    wayland_update_outputs_from_process(wayland);
 }
 
 /**********************************************************************
-- 
2.39.0.rc2

From 15446df7e0fe8d605cc11014117e63bc1a064357 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 16 Aug 2022 15:04:41 +0300
Subject: [PATCH 023/202] winewayland.drv: Implement GetCurrentDisplaySettings.

Implement the GetCurrentDisplaySettings callback by using the Wayland
display output information stored in the per-process instance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 50 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 53 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 43d3aef3635..aceb1dd6930 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -261,3 +261,53 @@ BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manage
 
     return TRUE;
 }
+
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_mode)
+        return FALSE;
+
+    populate_devmode(output->current_mode, mode);
+
+    mode->dmFields |= DM_POSITION;
+    mode->dmPosition.x = output->x;
+    mode->dmPosition.y = output->y;
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *             GetCurrentDisplaySettings  (WAYLAND.@)
+ *
+ */
+BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary, LPDEVMODEW devmode)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    BOOL ret;
+
+    TRACE("(%s,%p) wayland=%p\n", debugstr_w(name), devmode, wayland);
+
+    ret = wayland_get_current_devmode(wayland, name, devmode);
+
+    wayland_process_release();
+
+    if (ret)
+    {
+        TRACE("=> %d,%d+%ux%u@%u %ubpp\n",
+              (int)devmode->dmPosition.x, (int)devmode->dmPosition.y,
+              (UINT)devmode->dmPelsWidth, (UINT)devmode->dmPelsHeight,
+              (UINT)devmode->dmDisplayFrequency, (UINT)devmode->dmBitsPerPel);
+    }
+    else
+    {
+        ERR("Failed to get %s current display settings.\n", wine_dbgstr_w(name));
+    }
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3e362b50db1..9233e326582 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -205,6 +205,8 @@ static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, L
 
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
+                                       LPDEVMODEW devmode) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index e2dcc06f27b..d2f0655734a 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -85,6 +85,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
+    .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.39.0.rc2

From 991c9f424db1bb54e097970e3c767c6cc28d8095 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:22:13 +0300
Subject: [PATCH 024/202] winewayland.drv: Introduce private driver window data
 structure.

Introduce a private driver window data structure and use it to keep
track of some basic window data. Access to the information is protected
for multithreaded access.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   4 +
 dlls/winewayland.drv/waylanddrv_main.c |   3 +-
 dlls/winewayland.drv/window.c          | 136 +++++++++++++++++++++++++
 3 files changed, 142 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9233e326582..5794faa6529 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -205,10 +205,14 @@ static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, L
 
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
                                        LPDEVMODEW devmode) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                               const RECT *window_rect, const RECT *client_rect,
+                               RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d2f0655734a..baa1283c161 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -30,7 +30,6 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
-#include "wine/gdi_driver.h"
 
 #include <stdlib.h>
 
@@ -85,10 +84,12 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
+    .pDestroyWindow = WAYLAND_DestroyWindow,
     .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanging = WAYLAND_WindowPosChanging,
 };
 
 static const struct user_driver_funcs null_funcs = { 0 };
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 4e1d68c5bae..e85df9f5287 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -33,8 +33,105 @@
 
 #include "ntuser.h"
 
+#include <stdlib.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* private window data */
+struct wayland_win_data
+{
+    /* hwnd that this private data belongs to */
+    HWND           hwnd;
+    /* parent hwnd for child windows */
+    HWND           parent;
+    /* USER window rectangle relative to parent */
+    RECT           window_rect;
+    /* client area relative to parent */
+    RECT           client_rect;
+};
+
+static struct wayland_mutex win_data_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": win_data_mutex"
+};
+
+static struct wayland_win_data *win_data_context[32768];
+
+static inline int context_idx(HWND hwnd)
+{
+    return LOWORD(hwnd) >> 1;
+}
+
+/***********************************************************************
+ *           wayland_win_data_destroy
+ */
+static void wayland_win_data_destroy(struct wayland_win_data *data)
+{
+    TRACE("hwnd=%p\n", data->hwnd);
+    win_data_context[context_idx(data->hwnd)] = NULL;
+
+    free(data);
+
+    wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+static struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    if (!hwnd) return NULL;
+
+    wayland_mutex_lock(&win_data_mutex);
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data;
+    wayland_mutex_unlock(&win_data_mutex);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_release
+ *
+ * Release the data returned by wayland_win_data_get.
+ */
+static void wayland_win_data_release(struct wayland_win_data *data)
+{
+    if (data) wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_win_data_create
+ *
+ * Create a data window structure for an existing window.
+ */
+static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    HWND parent;
+
+    /* Don't create win data for desktop or HWND_MESSAGE windows. */
+    if (!(parent = NtUserGetAncestor(hwnd, GA_PARENT))) return NULL;
+    if (parent != NtUserGetDesktopWindow() && !NtUserGetAncestor(parent, GA_PARENT))
+        return NULL;
+
+    if (!(data = calloc(1, sizeof(*data))))
+        return NULL;
+
+    data->hwnd = hwnd;
+
+    wayland_mutex_lock(&win_data_mutex);
+    win_data_context[context_idx(hwnd)] = data;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    return data;
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -52,6 +149,45 @@ BOOL WAYLAND_CreateWindow(HWND hwnd)
     return TRUE;
 }
 
+/***********************************************************************
+ *           WAYLAND_DestroyWindow
+ */
+void WAYLAND_DestroyWindow(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    TRACE("%p\n", hwnd);
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_win_data_destroy(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanging
+ */
+BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                               const RECT *window_rect, const RECT *client_rect,
+                               RECT *visible_rect, struct window_surface **surface)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    BOOL exstyle = NtUserGetWindowLongW(hwnd, GWL_EXSTYLE);
+    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
+
+    TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), (UINT)style, exstyle, swp_flags, insert_after);
+
+    if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
+
+    data->parent = (parent == NtUserGetDesktopWindow()) ? 0 : parent;
+    data->window_rect = *window_rect;
+    data->client_rect = *client_rect;
+
+    wayland_win_data_release(data);
+    return TRUE;
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
-- 
2.39.0.rc2

From d9023bc881d1be662029487976fece2b20672c6f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 17:11:53 +0300
Subject: [PATCH 025/202] winewayland.drv: Add function to dispatch Wayland
 events.

Introduce a mechanism to dispatch Wayland events from a queue,
potentially also reading and queueing new events. This is similar to the
wayland-client wl_display_dispatch_queue() function, with the addition of
a timeout to wait for while waiting for new events to arrive.

This function also ensures to dispatch any per-process queue events with
the per-process instance lock held.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 92 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  6 ++
 2 files changed, 98 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 6dce3dfeddf..2566f673dea 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -28,6 +28,8 @@
 
 #include "wine/debug.h"
 
+#include <errno.h>
+#include <poll.h>
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -310,3 +312,93 @@ void wayland_notify_wine_monitor_change(void)
 
     wayland_mutex_unlock(&thread_wayland_mutex);
 }
+
+/**********************************************************************
+ *          wayland_dispatch_queue
+ *
+ * Dispatch events from the specified queue. If the queue is empty,
+ * wait for timeout_ms for events to arrive and then dispatch any events in
+ * the queue.
+ *
+ * Returns the number of events dispatched, -1 on error
+ */
+int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
+{
+    struct pollfd pfd = {0};
+    BOOL is_process_queue = queue == process_wayland->wl_event_queue;
+    int ret;
+
+    TRACE("waiting for events with timeout=%d ...\n", timeout_ms);
+
+    pfd.fd = wl_display_get_fd(process_wl_display);
+
+    if (wl_display_prepare_read_queue(process_wl_display, queue) == -1)
+    {
+        if (is_process_queue) wayland_process_acquire();
+        if ((ret = wl_display_dispatch_queue_pending(process_wl_display, queue)) == -1)
+            TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+        if (is_process_queue) wayland_process_release();
+        TRACE("... done early\n");
+        return ret;
+    }
+
+    while (TRUE)
+    {
+        ret = wl_display_flush(process_wl_display);
+
+        if (ret != -1 || errno != EAGAIN)
+            break;
+
+        pfd.events = POLLOUT;
+        while ((ret = poll(&pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+
+        if (ret == -1)
+        {
+            TRACE("... failed poll out errno=%d\n", errno);
+            wl_display_cancel_read(process_wl_display);
+            return -1;
+        }
+    }
+
+    if (ret < 0 && errno != EPIPE)
+    {
+        wl_display_cancel_read(process_wl_display);
+        return -1;
+    }
+
+    pfd.events = POLLIN;
+    while ((ret = poll(&pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+
+    if (ret == 0)
+    {
+        TRACE("... done => 0 events (timeout)\n");
+        wl_display_cancel_read(process_wl_display);
+        return 0;
+    }
+
+    if (ret == -1)
+    {
+        TRACE("... failed poll errno=%d\n", errno);
+        wl_display_cancel_read(process_wl_display);
+        return -1;
+    }
+
+    if (wl_display_read_events(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_read_events errno=%d\n", errno);
+        return -1;
+    }
+
+    if (is_process_queue) wayland_process_acquire();
+    ret = wl_display_dispatch_queue_pending(process_wl_display, queue);
+    if (is_process_queue) wayland_process_release();
+    if (ret == -1)
+    {
+        TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+        return -1;
+    }
+
+    TRACE("... done => %d events\n", ret);
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5794faa6529..03de7c91479 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -169,6 +169,12 @@ void wayland_update_outputs_from_process(struct wayland *wayland) DECLSPEC_HIDDE
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland event dispatch
+ */
+
+int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
-- 
2.39.0.rc2

From 7328ff6e6d62202f723262fa3dee645841286f36 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 14 Mar 2022 14:56:03 +0200
Subject: [PATCH 026/202] winewayland.drv: Introduce abstraction for native
 buffers.

Introduce a structure to hold native buffers, which may consist
of a number of planes. The memory of each plane is represented
as a file descriptor, the exact type of which will depend on
the underlying buffer type. Future commits will add functions
to create native buffers for various buffer types.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in             |  1 +
 dlls/winewayland.drv/wayland_native_buffer.c | 42 ++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h            | 17 ++++++++
 3 files changed, 60 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_native_buffer.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 8ec6bff197f..b22300766ac 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	unicode.c \
 	wayland.c \
 	wayland_mutex.c \
+	wayland_native_buffer.c \
 	wayland_output.c \
 	waylanddrv_main.c \
 	window.c \
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
new file mode 100644
index 00000000000..4473c3a553f
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <unistd.h>
+
+/**********************************************************************
+ *          wayland_native_buffer_deinit
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+void wayland_native_buffer_deinit(struct wayland_native_buffer *native)
+{
+    int i;
+
+    for (i = 0; i < native->plane_count; i++)
+        if (native->fds[i] >= 0) close(native->fds[i]);
+
+    native->plane_count = 0;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 03de7c91479..9af3f5966bd 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -107,6 +107,17 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_native_buffer
+{
+    int plane_count;
+    int fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    uint32_t width, height;
+    uint32_t format;
+    uint64_t modifier;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -175,6 +186,12 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland native buffer
+ */
+
+void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
-- 
2.39.0.rc2

From b5d2228bda4260da25054f6c41520b01de2b858a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 29 Mar 2022 13:11:52 +0300
Subject: [PATCH 027/202] winewayland.drv: Add helper to create SHM backed file
 descriptors.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in     |  1 +
 dlls/winewayland.drv/wayland_shmfd.c | 86 ++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h    |  1 +
 3 files changed, 88 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_shmfd.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index b22300766ac..8e5b9962a95 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
+	wayland_shmfd.c \
 	waylanddrv_main.c \
 	window.c \
 
diff --git a/dlls/winewayland.drv/wayland_shmfd.c b/dlls/winewayland.drv/wayland_shmfd.c
new file mode 100644
index 00000000000..b2e69be33e4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shmfd.c
@@ -0,0 +1,86 @@
+/*
+ * Wayland SHM fd
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+/* For memfd_create */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+
+static int fd_resize(int fd, off_t size)
+{
+    /*
+     * Filesystems that do support fallocate will return EINVAL or
+     * EOPNOTSUPP. In this case we need to fall back to ftruncate
+     */
+    errno = posix_fallocate(fd, 0, size);
+    if (errno == 0)
+        return 0;
+    else if (errno != EINVAL && errno != EOPNOTSUPP)
+        return -1;
+    if (ftruncate(fd, size) < 0)
+        return -1;
+
+    return 0;
+}
+
+/**********************************************************************
+ *          wayland_shmfd_create
+ *
+ * Creates a file descriptor representing an anonymous SHM region.
+ */
+int wayland_shmfd_create(const char *name, int size)
+{
+    int fd = memfd_create(name, MFD_CLOEXEC | MFD_ALLOW_SEALING);
+
+    if (fd >= 0)
+    {
+        /* We can add this seal before calling posix_fallocate(), as
+         * the file is currently zero-sized anyway.
+         *
+         * There is also no need to check for the return value, we
+         * couldn't do anything with it anyway.
+         */
+        fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_SEAL);
+    }
+
+    while (TRUE)
+    {
+        int ret = fd_resize(fd, size);
+        if (ret == 0) break;
+        if (ret < 0 && errno == EINTR) continue;
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9af3f5966bd..c641579e8d3 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -202,6 +202,7 @@ size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
                                 const WCHAR *src, size_t src_max_chars) DECLSPEC_HIDDEN;
 size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
                           const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+int wayland_shmfd_create(const char *name, int size) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER32 helpers
-- 
2.39.0.rc2

From 55da1ac267ea71ee798d6f5e5e63991e273910e8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:56:28 +0300
Subject: [PATCH 028/202] winewayland.drv: Add infrastructure for Wayland SHM
 buffers.

Add the infrastructure and functions needed to manage Wayland SHM (i.e.,
software) buffers and their damage tracking.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in             |   1 +
 dlls/winewayland.drv/wayland.c               |   7 +
 dlls/winewayland.drv/wayland_native_buffer.c |  33 +++
 dlls/winewayland.drv/wayland_shm.c           | 219 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h            |  30 +++
 5 files changed, 290 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_shm.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 8e5b9962a95..1defab9690c 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
+	wayland_shm.c \
 	wayland_shmfd.c \
 	waylanddrv_main.c \
 	window.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2566f673dea..6676b44ad2c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -85,6 +85,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -209,6 +213,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    if (wayland->wl_shm)
+        wl_shm_destroy(wayland->wl_shm);
+
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
index 4473c3a553f..471c636c04a 100644
--- a/dlls/winewayland.drv/wayland_native_buffer.c
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -24,8 +24,41 @@
 
 #include "waylanddrv.h"
 
+#include <assert.h>
 #include <unistd.h>
 
+/**********************************************************************
+ *          wayland_native_buffer_init_shm
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format)
+{
+    int stride;
+    off_t size;
+    int fd;
+
+    assert(format == WL_SHM_FORMAT_ARGB8888 || format == WL_SHM_FORMAT_XRGB8888);
+
+    stride = width * 4;
+    size = stride * height;
+
+    fd = wayland_shmfd_create("wayland-shm", size);
+    if (fd < 0) return FALSE;
+
+    native->plane_count = 1;
+    native->fds[0] = fd;
+    native->strides[0] = stride;
+    native->offsets[0] = 0;
+    native->width = width;
+    native->height = height;
+    native->format = format;
+
+    return TRUE;
+}
+
 /**********************************************************************
  *          wayland_native_buffer_deinit
  *
diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
new file mode 100644
index 00000000000..254f574f33b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -0,0 +1,219 @@
+/*
+ * Wayland SHM buffers
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                        struct wayland_native_buffer *native)
+{
+    struct wayland_shm_buffer *shm_buffer;
+    struct wl_shm_pool *pool;
+    int size;
+    void *data;
+
+    shm_buffer = calloc(1, sizeof(*shm_buffer));
+    if (!shm_buffer)
+        goto err;
+
+    wl_list_init(&shm_buffer->link);
+
+    size = native->strides[0] * native->height;
+
+    TRACE("%p %dx%d format=%d size=%d\n",
+          shm_buffer, native->width, native->height, native->format, size);
+
+    if (size == 0)
+        goto err;
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, native->fds[0], 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("mmap failed: %s size=%d\n", strerror(errno), size);
+        goto err;
+    }
+
+    pool = wl_shm_create_pool(wayland->wl_shm, native->fds[0], size);
+    shm_buffer->wl_buffer = wl_shm_pool_create_buffer(pool, 0, native->width, native->height,
+                                                      native->strides[0], native->format);
+    wl_shm_pool_destroy(pool);
+
+    shm_buffer->width = native->width;
+    shm_buffer->height = native->height;
+    shm_buffer->stride = native->strides[0];
+    shm_buffer->format = native->format;
+    shm_buffer->map_data = data;
+    shm_buffer->map_size = size;
+    shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+    if (!shm_buffer->damage_region)
+    {
+        ERR("failed to create buffer damage region\n");
+        goto err;
+    }
+
+    TRACE("%p %dx%d size=%d => map=%p\n",
+          shm_buffer, native->width, native->height, size, data);
+
+    return shm_buffer;
+
+err:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_create
+ *
+ * Creates a SHM buffer with the specified width, height and format.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format)
+{
+    struct wayland_native_buffer native;
+    struct wayland_shm_buffer *shm_buffer;
+
+    if (wayland_native_buffer_init_shm(&native, width, height, format))
+    {
+        shm_buffer = wayland_shm_buffer_create_from_native(wayland, &native);
+        wayland_native_buffer_deinit(&native);
+    }
+    else
+    {
+        shm_buffer = NULL;
+    }
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_destroy
+ *
+ * Destroys a SHM buffer.
+ */
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    TRACE("%p map=%p\n", shm_buffer, shm_buffer->map_data);
+
+    wl_list_remove(&shm_buffer->link);
+
+    if (shm_buffer->wl_buffer)
+        wl_buffer_destroy(shm_buffer->wl_buffer);
+    if (shm_buffer->map_data)
+        munmap(shm_buffer->map_data, shm_buffer->map_size);
+    if (shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(shm_buffer->damage_region);
+
+    free(shm_buffer);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a SHM buffer and destroy the SHM buffer.
+ */
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = shm_buffer->wl_buffer;
+    shm_buffer->wl_buffer = NULL;
+
+    wayland_shm_buffer_destroy(shm_buffer);
+
+    return wl_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_clear_damage
+ *
+ *  Clears all damage accumulated by a SHM buffer.
+ */
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer)
+{
+    NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_add_damage
+ *
+ *  Adds damage (i.e., a region which needs update) to a SHM buffer.
+ */
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage)
+{
+    NtGdiCombineRgn(shm_buffer->damage_region, shm_buffer->damage_region, damage, RGN_OR);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_get_damage_clipped
+ *
+ * Returns the damage region data for this buffer clipped within the
+ * provided clip region (if any).
+ *
+ * The returned RGNDATA* should be freed by the caller using free().
+ */
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+    HRGN damage_region;
+
+    if (clip)
+    {
+        damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (!damage_region) goto err;
+        NtGdiCombineRgn(damage_region, shm_buffer->damage_region, clip, RGN_AND);
+    }
+    else
+    {
+        damage_region = shm_buffer->damage_region;
+    }
+
+    if (!(size = NtGdiGetRegionData(damage_region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+    if (!NtGdiGetRegionData(damage_region, size, data)) goto err;
+
+    if (damage_region != shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(damage_region);
+
+    return data;
+
+err:
+    if (damage_region && damage_region != shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(damage_region);
+    free(data);
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c641579e8d3..73465525a34 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -75,6 +75,7 @@ struct wayland
     struct wl_event_queue *wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -118,6 +119,18 @@ struct wayland_native_buffer
     uint64_t modifier;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height, stride;
+    enum wl_shm_format format;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    HRGN damage_region;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -190,8 +203,25 @@ int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPE
  *          Wayland native buffer
  */
 
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format) DECLSPEC_HIDDEN;
 void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland SHM buffer
+ */
+
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage) DECLSPEC_HIDDEN;
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
-- 
2.39.0.rc2

From 3c3bb4c1ebea4d49b142663968216d8fa6693a05 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 17:19:09 +0300
Subject: [PATCH 029/202] winewayland.drv: Add a Wayland SHM buffer queue.

Introduce a buffer queue object to handle a collection of Wayland SHM
buffers, including their acquisition by the driver and their release
by the Wayland compositor.

Each queue is initially empty, transparently and dynamically creating
up to 3 SHM buffers as needed.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in            |   1 +
 dlls/winewayland.drv/wayland.c              |   6 +
 dlls/winewayland.drv/wayland_buffer_queue.c | 216 ++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h           |  24 +++
 4 files changed, 247 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_buffer_queue.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 1defab9690c..450259e29ed 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -8,6 +8,7 @@ C_SRCS = \
 	dllmain.c \
 	unicode.c \
 	wayland.c \
+	wayland_buffer_queue.c \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 6676b44ad2c..db153ce4402 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -169,6 +169,7 @@ BOOL wayland_init(struct wayland *wayland)
     }
 
     wl_list_init(&wayland->output_list);
+    wl_list_init(&wayland->detached_shm_buffer_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -203,6 +204,7 @@ BOOL wayland_init(struct wayland *wayland)
 void wayland_deinit(struct wayland *wayland)
 {
     struct wayland_output *output, *output_tmp;
+    struct wayland_shm_buffer *shm_buffer, *shm_buffer_tmp;
 
     TRACE("%p\n", wayland);
 
@@ -213,6 +215,10 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    wl_list_for_each_safe(shm_buffer, shm_buffer_tmp,
+                          &wayland->detached_shm_buffer_list, link)
+        wayland_shm_buffer_destroy(shm_buffer);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_buffer_queue.c b/dlls/winewayland.drv/wayland_buffer_queue.c
new file mode 100644
index 00000000000..c2a424e947a
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_buffer_queue.c
@@ -0,0 +1,216 @@
+/*
+ * Wayland buffer queue
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "winuser.h"
+#include "ntgdi.h"
+
+#include <errno.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p detached=%d\n", shm_buffer, shm_buffer->detached);
+
+    if (shm_buffer->detached)
+        wayland_shm_buffer_destroy(shm_buffer);
+    else
+        shm_buffer->busy = FALSE;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+    buffer_release
+};
+
+/**********************************************************************
+ *          wayland_buffer_queue_create
+ *
+ * Creates a buffer queue containing buffers with the specified width, height
+ * and format.
+ */
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int height,
+                                                         enum wl_shm_format format)
+{
+    struct wayland_buffer_queue *queue;
+
+    queue = calloc(1, sizeof(*queue));
+    if (!queue) goto err;
+
+    queue->wayland = wayland;
+    queue->wl_event_queue = wl_display_create_queue(wayland->wl_display);
+    if (!queue->wl_event_queue) goto err;
+    queue->width = width;
+    queue->height = height;
+    queue->format = format;
+
+    wl_list_init(&queue->buffer_list);
+
+    return queue;
+
+err:
+    if (queue) wayland_buffer_queue_destroy(queue);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_destroy
+ *
+ * Destroys a buffer queue and any contained buffers.
+ */
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer, *next;
+
+    wl_list_for_each_safe(shm_buffer, next, &queue->buffer_list, link)
+    {
+        /* If the buffer is busy (committed but not yet released by the
+         * compositor), destroying it now may cause surface contents to become
+         * undefined and lead to visual artifacts. In such a case, we hand off
+         * handling of this buffer to the thread event queue and track it in
+         * the detatched_shm_buffer_list while we wait for the release event in
+         * order to destroy it (see buffer_release handler). */
+        if (shm_buffer->busy)
+        {
+            wl_list_remove(&shm_buffer->link);
+            wl_list_insert(&queue->wayland->detached_shm_buffer_list,
+                           &shm_buffer->link);
+            shm_buffer->detached = TRUE;
+            wl_proxy_set_queue((struct wl_proxy *)shm_buffer->wl_buffer,
+                                queue->wayland->wl_event_queue);
+        }
+        else
+        {
+            wayland_shm_buffer_destroy(shm_buffer);
+        }
+    }
+
+    if (queue->wl_event_queue)
+    {
+        wl_display_dispatch_queue_pending(queue->wayland->wl_display,
+                                          queue->wl_event_queue);
+        wl_event_queue_destroy(queue->wl_event_queue);
+    }
+
+    free(queue);
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_acquire_buffer
+ *
+ * Acquires a free buffer from the buffer queue. If no free buffers
+ * are available this function blocks until it can provide one.
+ *
+ * The returned buffer is marked as unavailable until committed to
+ * a surface and subsequently released by the compositor.
+ */
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    TRACE("queue=%p\n", queue);
+
+    while (TRUE)
+    {
+        int nbuffers = 0;
+
+        /* Search through our buffers to find an available one. */
+        wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        {
+            if (!shm_buffer->busy)
+            {
+                shm_buffer->busy = TRUE;
+                goto out;
+            }
+            nbuffers++;
+        }
+
+        /* Dynamically create up to 3 buffers. */
+        if (nbuffers < 3)
+        {
+            HRGN full_dmg = NtGdiCreateRectRgn(0, 0, queue->width, queue->height);
+            shm_buffer = wayland_shm_buffer_create(queue->wayland, queue->width,
+                                                   queue->height, queue->format);
+            if (shm_buffer)
+            {
+                /* Buffer events go to their own queue so that we can dispatch
+                 * them independently. */
+                wl_proxy_set_queue((struct wl_proxy *) shm_buffer->wl_buffer,
+                                   queue->wl_event_queue);
+                wl_buffer_add_listener(shm_buffer->wl_buffer, &buffer_listener,
+                                       shm_buffer);
+                wl_list_insert(&queue->buffer_list, &shm_buffer->link);
+                wayland_shm_buffer_add_damage(shm_buffer, full_dmg);
+                shm_buffer->busy = TRUE;
+            }
+            NtGdiDeleteObjectApp(full_dmg);
+            /* If we failed to allocate a new buffer, but we have at least two
+             * buffers busy, there is a good chance the compositor will
+             * eventually release one of them, so dispatch events and wait
+             * below. Otherwise, give up and return a NULL buffer. */
+            if (shm_buffer)
+            {
+                goto out;
+            }
+            else if (nbuffers < 2)
+            {
+                ERR(" => failed to acquire buffer\n");
+                return NULL;
+            }
+        }
+
+        if (wayland_dispatch_queue(queue->wl_event_queue, -1) == -1)
+            return NULL;
+    }
+
+out:
+    TRACE(" => %p %dx%d stride=%d map=[%p, %p)\n",
+          shm_buffer, shm_buffer->width, shm_buffer->height,
+          shm_buffer->stride, shm_buffer->map_data,
+          (unsigned char*)shm_buffer->map_data + shm_buffer->map_size);
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_add_damage
+ *
+ * Adds damage to all buffers in this queue.
+ */
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        wayland_shm_buffer_add_damage(shm_buffer, damage);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 73465525a34..fda05f24bb5 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -79,6 +79,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wl_list detached_shm_buffer_list;
 };
 
 struct wayland_output_mode
@@ -129,6 +130,18 @@ struct wayland_shm_buffer
     size_t map_size;
     BOOL busy;
     HRGN damage_region;
+    BOOL detached;
+};
+
+struct wayland_buffer_queue
+{
+    struct wayland *wayland;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_list buffer_list;
+    int width;
+    int height;
+    enum wl_shm_format format;
+    HRGN damage_region;
 };
 
 /**********************************************************************
@@ -222,6 +235,17 @@ void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN d
 RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
                                                HRGN clip) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland buffer queue
+ */
+
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int heigh,
+                                                         enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage) DECLSPEC_HIDDEN;
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
-- 
2.39.0.rc2

From 96f745c7ca02cba2db094d497d53a3e3bb820670 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 11:05:17 +0300
Subject: [PATCH 030/202] winewayland.drv: Introduce support for Wayland
 surfaces.

Introduce infrastructure to create, destroy and manage references to
Wayland surfaces.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   2 +
 dlls/winewayland.drv/wayland.c         |  33 ++++
 dlls/winewayland.drv/wayland_surface.c | 211 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  35 ++++
 4 files changed, 281 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_surface.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 450259e29ed..197e4e8a323 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,10 +14,12 @@ C_SRCS = \
 	wayland_output.c \
 	wayland_shm.c \
 	wayland_shmfd.c \
+	wayland_surface.c \
 	waylanddrv_main.c \
 	window.c \
 
 WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index db153ce4402..4c7964a2871 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -47,6 +47,19 @@ static struct wayland_mutex thread_wayland_mutex =
 
 static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
 
+/**********************************************************************
+ *          xdg_wm_base handling
+ */
+
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *shell, uint32_t serial)
+{
+    xdg_wm_base_pong(shell, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
+};
+
 /**********************************************************************
  *          Registry handling
  */
@@ -85,6 +98,20 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_subcompositor") == 0)
+    {
+        wayland->wl_subcompositor =
+            wl_registry_bind(registry, id, &wl_subcompositor_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_wm_base") == 0)
+    {
+        /* Bind version 2 so that compositors (e.g., sway) can properly send tiled
+         * states, instead of falling back to (ab)using the maximized state. */
+        wayland->xdg_wm_base =
+            wl_registry_bind(registry, id, &xdg_wm_base_interface,
+                             version < 2 ? version : 2);
+        xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
+    }
     else if (strcmp(interface, "wl_shm") == 0)
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
@@ -225,6 +252,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
+    if (wayland->xdg_wm_base)
+        xdg_wm_base_destroy(wayland->xdg_wm_base);
+
+    if (wayland->wl_subcompositor)
+        wl_subcompositor_destroy(wayland->wl_subcompositor);
+
     if (wayland->wl_compositor)
         wl_compositor_destroy(wayland->wl_compositor);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
new file mode 100644
index 00000000000..6eb87ea234e
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -0,0 +1,211 @@
+/*
+ * Wayland surfaces
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_surface_create_plain
+ *
+ * Creates a plain, role-less wayland surface.
+ */
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    surface = calloc(1, sizeof(*surface));
+    if (!surface)
+        goto err;
+
+    TRACE("surface=%p\n", surface);
+
+    surface->wayland = wayland;
+
+    surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
+    if (!surface->wl_surface)
+        goto err;
+
+    wl_surface_set_user_data(surface->wl_surface, surface);
+
+    surface->ref = 1;
+    surface->role = WAYLAND_SURFACE_ROLE_NONE;
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_make_toplevel
+ *
+ * Gives the toplevel role to a plain wayland surface, optionally associated
+ * with a parent surface.
+ */
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->xdg_surface =
+        xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
+    if (!surface->xdg_surface)
+        goto err;
+
+    surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
+    if (!surface->xdg_toplevel)
+        goto err;
+
+    if (parent && parent->xdg_toplevel)
+        xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
+
+    return;
+
+err:
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+    ERR("Failed to assign toplevel role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_create_subsurface
+ *
+ * Assigns the subsurface role to a plain wayland surface, with the specified
+ * parent.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->parent = wayland_surface_ref(parent);
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return;
+
+err:
+    wayland_surface_unref(surface->parent);
+    surface->parent = NULL;
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_destroy
+ *
+ * Destroys a wayland surface.
+ */
+void wayland_surface_destroy(struct wayland_surface *surface)
+{
+    TRACE("surface=%p\n", surface);
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    if (surface->wl_surface)
+    {
+        wl_surface_destroy(surface->wl_surface);
+        surface->wl_surface = NULL;
+    }
+
+    if (surface->parent)
+    {
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    free(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ref
+ *
+ * Add a reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface)
+{
+    int ref = InterlockedIncrement(&surface->ref);
+    TRACE("surface=%p ref=%d->%d\n", surface, ref - 1, ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref
+ *
+ * Remove a reference to wayland_surface, potentially destroying it.
+ */
+void wayland_surface_unref(struct wayland_surface *surface)
+{
+    int ref = InterlockedDecrement(&surface->ref);
+
+    TRACE("surface=%p ref=%d->%d\n", surface, ref + 1, ref);
+
+    if (ref == 0)
+        wayland_surface_destroy(surface);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fda05f24bb5..33da85dfd08 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -29,6 +29,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -53,6 +54,13 @@ enum wayland_window_message
     WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
 };
 
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -75,6 +83,8 @@ struct wayland
     struct wl_event_queue *wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_subcompositor *wl_subcompositor;
+    struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
@@ -109,6 +119,18 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface
+{
+    struct wayland *wayland;
+    struct wl_surface *wl_surface;
+    struct wl_subsurface *wl_subsurface;
+    struct xdg_surface *xdg_surface;
+    struct xdg_toplevel *xdg_toplevel;
+    struct wayland_surface *parent;
+    LONG ref;
+    enum wayland_surface_role role;
+};
+
 struct wayland_native_buffer
 {
     int plane_count;
@@ -212,6 +234,19 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland surface
+ */
+
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Wayland native buffer
  */
-- 
2.39.0.rc2

From 943094b651bfaa327b089983180bf1667a088453 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 12:55:01 +0300
Subject: [PATCH 031/202] winewayland.drv: Basic handling of Wayland surface
 configure events.

Handle the initial configure event for top-level Wayland surfaces.  More
dynamic configure event handling will be implemented in future commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 89 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 19 ++++++
 2 files changed, 108 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 6eb87ea234e..167846ca495 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -31,6 +31,89 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
+                                         uint32_t serial)
+{
+    struct wayland_surface *surface = data;
+
+    TRACE("serial=%u\n", serial);
+
+    surface->pending.serial = serial;
+
+    wayland_surface_ack_pending_configure(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ack_pending_configure
+ *
+ * Acks the pending configure event, making it current.
+ */
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
+{
+    if (!surface->xdg_surface || !surface->pending.serial)
+        return;
+
+    TRACE("Setting current serial=%u size=%dx%d flags=%#x\n",
+          surface->pending.serial, surface->pending.width,
+          surface->pending.height, surface->pending.configure_flags);
+
+    surface->current = surface->pending;
+    xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_xdg_surface_configure,
+};
+
+static void handle_xdg_toplevel_configure(void *data,
+                                          struct xdg_toplevel *xdg_toplevel,
+                                          int32_t width, int32_t height,
+                                          struct wl_array *states)
+{
+    struct wayland_surface *surface = data;
+    uint32_t *state;
+    int flags = 0;
+
+    wl_array_for_each(state, states)
+    {
+        switch(*state)
+        {
+        case XDG_TOPLEVEL_STATE_MAXIMIZED:
+            flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+            break;
+        case XDG_TOPLEVEL_STATE_ACTIVATED:
+            flags |= WAYLAND_CONFIGURE_FLAG_ACTIVATED;
+            break;
+        case XDG_TOPLEVEL_STATE_RESIZING:
+            flags |= WAYLAND_CONFIGURE_FLAG_RESIZING;
+            break;
+        case XDG_TOPLEVEL_STATE_FULLSCREEN:
+            flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+            break;
+        default:
+            break;
+        }
+    }
+
+    surface->pending.width = width;
+    surface->pending.height = height;
+    surface->pending.configure_flags = flags;
+
+    TRACE("%dx%d flags=%#x\n", width, height, flags);
+}
+
+static void handle_xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    TRACE("\n");
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    handle_xdg_toplevel_configure,
+    handle_xdg_toplevel_close,
+};
+
 /**********************************************************************
  *          wayland_surface_create_plain
  *
@@ -82,10 +165,12 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
         goto err;
+    xdg_surface_add_listener(surface->xdg_surface, &xdg_surface_listener, surface);
 
     surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
     if (!surface->xdg_toplevel)
         goto err;
+    xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface);
 
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
@@ -94,6 +179,10 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
 
+    /* Wait for the first configure event. */
+    while (!surface->current.serial)
+        wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
     return;
 
 err:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 33da85dfd08..9a146011ec2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -61,6 +61,14 @@ enum wayland_surface_role
     WAYLAND_SURFACE_ROLE_TOPLEVEL,
 };
 
+enum wayland_configure_flags
+{
+    WAYLAND_CONFIGURE_FLAG_RESIZING   = (1 << 0),
+    WAYLAND_CONFIGURE_FLAG_ACTIVATED  = (1 << 1),
+    WAYLAND_CONFIGURE_FLAG_MAXIMIZED  = (1 << 2),
+    WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -119,6 +127,14 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface_configure
+{
+    int width;
+    int height;
+    enum wayland_configure_flags configure_flags;
+    uint32_t serial;
+};
+
 struct wayland_surface
 {
     struct wayland *wayland;
@@ -127,6 +143,8 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    struct wayland_surface_configure pending;
+    struct wayland_surface_configure current;
     LONG ref;
     enum wayland_surface_role role;
 };
@@ -244,6 +262,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 
-- 
2.39.0.rc2

From 2a033cbd14082ff1a3ff885bbec85e73ac027149 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:03:11 +0300
Subject: [PATCH 032/202] winewayland.drv: Add functions to transform Wine
 coordinates to Wayland.

The functions are currently trivial, in the sense that they apply the
identity transformation. They will be enhanced as needed in future
commits to handle differences in the coordinate spaces, introduced, e.g,
by the use of scaling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 29 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++++
 2 files changed, 35 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 167846ca495..81d5d03efac 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -272,6 +272,35 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     free(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates.
+ */
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y)
+{
+    *wayland_x = wine_x;
+    *wayland_y = wine_y;
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_rounded_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates
+ * rounding to the closest integer value.
+ */
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y)
+{
+    double w_x, w_y;
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y, &w_x, &w_y);
+    *wayland_x = round(w_x);
+    *wayland_y = round(w_y);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9a146011ec2..9ace80ac377 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -263,6 +263,12 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 
-- 
2.39.0.rc2

From 928fc585eacf5069beb3eaeec492f651e4223dd5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 18 Nov 2021 10:15:43 +0200
Subject: [PATCH 033/202] winewayland.drv: Add function to check surface state
 compatibility.

Certain Wayland surface states place strict requirements on the surface
size. Introduce a function to check whether those requirements are met.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 35 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 38 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 81d5d03efac..f2e734b69aa 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -228,6 +228,41 @@ err:
     ERR("Failed to assign subsurface role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_configure_is_compatible
+ *
+ * Checks whether a wayland_surface_configure object is compatible with the
+ * the provided arguments.
+ */
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags)
+{
+    static int mask = WAYLAND_CONFIGURE_FLAG_MAXIMIZED |
+                      WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+
+    /* We require the same state. */
+    if ((flags & mask) != (conf->configure_flags & mask))
+        return FALSE;
+
+    /* The maximized state requires the configured size. */
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        (width != conf->width || height != conf->height))
+    {
+        return FALSE;
+    }
+
+    /* The fullscreen state requires sizes smaller or equal to the configured
+     * size. */
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        (width > conf->width || height > conf->height))
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9ace80ac377..3c3853634bd 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -261,6 +261,9 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
                                    struct wayland_surface *parent) DECLSPEC_HIDDEN;
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent) DECLSPEC_HIDDEN;
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
-- 
2.39.0.rc2

From d927c3a9616ffead549002b785a5d3d1044ad7ae Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:11:01 +0300
Subject: [PATCH 034/202] winewayland.drv: Add function to commit a buffer to a
 Wayland surface.

The buffer is committed along with damage information to allow the
Wayland compositor to potentially optimize presentation.

Some Wayland surface states, such as maximized and fullscreen, place
constraints on the effective surface size they accept. We honor
such constraints, not committing incompatible buffers, to avoid protocol
errors.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 95 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  4 ++
 2 files changed, 99 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index f2e734b69aa..7ecc1d23c6f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -26,6 +26,7 @@
 
 #include "waylanddrv.h"
 #include "wine/debug.h"
+#include "ntgdi.h"
 
 #include <stdlib.h>
 
@@ -129,6 +130,9 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
 
     TRACE("surface=%p\n", surface);
 
+    wayland_mutex_init(&surface->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_surface");
+
     surface->wayland = wayland;
 
     surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
@@ -263,6 +267,95 @@ BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *c
     return TRUE;
 }
 
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!(size = NtGdiGetRegionData(region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+
+    if (!NtGdiGetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    free(data);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_commit_buffer
+ *
+ * Commits a SHM buffer on a wayland surface. Returns whether the
+ * buffer was actually committed.
+ */
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region)
+{
+    RGNDATA *surface_damage;
+    int wayland_width, wayland_height;
+
+    /* Since multiple threads can commit a buffer to a wayland surface
+     * (e.g., child windows in different threads), we guard this function
+     * to ensure we get complete and atomic buffer commits. */
+    wayland_mutex_lock(&surface->mutex);
+
+    TRACE("surface=%p (%dx%d) flags=%#x buffer=%p (%dx%d)\n",
+          surface, surface->current.width, surface->current.height,
+          surface->current.configure_flags, shm_buffer,
+          shm_buffer->width, shm_buffer->height);
+
+    wayland_surface_coords_rounded_from_wine(surface,
+                                             shm_buffer->width, shm_buffer->height,
+                                             &wayland_width, &wayland_height);
+
+    /* Certain surface states are very strict about the dimensions of buffers
+     * they accept. To avoid wayland protocol errors, drop buffers not matching
+     * the expected dimensions of such surfaces. This typically happens
+     * transiently during resizing operations. */
+    if (!wayland_surface_configure_is_compatible(&surface->current,
+                                                 wayland_width,
+                                                 wayland_height,
+                                                 surface->current.configure_flags))
+    {
+        wayland_mutex_unlock(&surface->mutex);
+        TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
+        shm_buffer->busy = FALSE;
+        return FALSE;
+    }
+
+    wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
+
+    /* Add surface damage, i.e., which parts of the surface have changed since
+     * the last surface commit. Note that this is different from the buffer
+     * damage returned by wayland_shm_buffer_get_damage(). */
+    surface_damage = get_region_data(surface_damage_region);
+    if (surface_damage)
+    {
+        RECT *rgn_rect = (RECT *)surface_damage->Buffer;
+        RECT *rgn_rect_end = rgn_rect + surface_damage->rdh.nCount;
+
+        for (;rgn_rect < rgn_rect_end; rgn_rect++)
+        {
+            wl_surface_damage_buffer(surface->wl_surface,
+                                     rgn_rect->left, rgn_rect->top,
+                                     rgn_rect->right - rgn_rect->left,
+                                     rgn_rect->bottom - rgn_rect->top);
+        }
+        free(surface_damage);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    return TRUE;
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
@@ -302,6 +395,8 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->parent = NULL;
     }
 
+    wayland_mutex_destroy(&surface->mutex);
+
     wl_display_flush(surface->wayland->wl_display);
 
     free(surface);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3c3853634bd..eb775fae323 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -143,6 +143,7 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    struct wayland_mutex mutex;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
     LONG ref;
@@ -264,6 +265,9 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
 BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
                                              int width, int height,
                                              enum wayland_configure_flags flags) DECLSPEC_HIDDEN;
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
-- 
2.39.0.rc2

From 64a5ce6821a2eccdda1ba3aabecf848563f87f6c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:24:03 +0300
Subject: [PATCH 035/202] winewayland.drv: Add function to unmap a Wayland
 surface.

Keep track of whether a Wayland surface is mapped or not, and allow
unmapping (i.e., hiding) it.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 17 +++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 7ecc1d23c6f..2f663527893 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -348,6 +348,7 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
     }
 
     wl_surface_commit(surface->wl_surface);
+    surface->mapped = TRUE;
 
     wayland_mutex_unlock(&surface->mutex);
 
@@ -402,6 +403,22 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     free(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_unmap
+ *
+ * Unmaps (i.e., hides) this surface.
+ */
+void wayland_surface_unmap(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_surface_attach(surface->wl_surface, NULL, 0, 0);
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = FALSE;
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index eb775fae323..9534749be88 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -146,6 +146,7 @@ struct wayland_surface
     struct wayland_mutex mutex;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
+    BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
 };
@@ -269,6 +270,7 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
                                    struct wayland_shm_buffer *shm_buffer,
                                    HRGN surface_damage_region) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
-- 
2.39.0.rc2

From 7718946e2bed2734dab3ac2c696d863a6d7c9f81 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:26:30 +0300
Subject: [PATCH 036/202] winewayland.drv: Allow associating a Wayland surface
 with a HWND.

There is no initial HWND association. It's the responsibility of the
surface creator to set it.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 4 ++--
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2f663527893..5ee31cbe4f3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -37,7 +37,7 @@ static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_sur
 {
     struct wayland_surface *surface = data;
 
-    TRACE("serial=%u\n", serial);
+    TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
 
     surface->pending.serial = serial;
 
@@ -364,7 +364,7 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
-    TRACE("surface=%p\n", surface);
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
     if (surface->xdg_toplevel)
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9534749be88..7455a86dc90 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -143,6 +143,7 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    HWND hwnd;
     struct wayland_mutex mutex;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
-- 
2.39.0.rc2

From a13cfbae137365f07ddbc44bf574019ac4364220 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 26 Nov 2021 15:51:22 +0200
Subject: [PATCH 037/202] winewayland.drv: Introduce function to clear a
 surface's role.

Support clearing the role of Wayland surface. The same role (but
not a different one!) can be later assigned to the surface again.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 36 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5ee31cbe4f3..0a68c90824c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -232,6 +232,42 @@ err:
     ERR("Failed to assign subsurface role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_clear_role
+ *
+ * Clears the role related Wayland objects of a Wayland surface, making it a
+ * plain surface again. We can later assign the same role (but not a
+ * different one!) to the surface.
+ */
+void wayland_surface_clear_role(struct wayland_surface *surface)
+{
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+    memset(&surface->current, 0, sizeof(surface->current));
+
+    /* We need to unmap, otherwise future role assignments may fail. */
+    wayland_surface_unmap(surface);
+}
+
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7455a86dc90..639ed40f61e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -264,6 +264,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
                                    struct wayland_surface *parent) DECLSPEC_HIDDEN;
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_clear_role(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
                                              int width, int height,
                                              enum wayland_configure_flags flags) DECLSPEC_HIDDEN;
-- 
2.39.0.rc2

From c46f859fdfd6ea9e2560399017eed00ee4908966 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 20 May 2022 16:10:40 +0300
Subject: [PATCH 038/202] winewayland.drv: Add intersect_rect helper

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 639ed40f61e..aa517c22279 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -348,6 +348,15 @@ static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, L
     return params.result;
 }
 
+static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
+{
+    dst->left = max(src1->left, src2->left);
+    dst->top = max(src1->top, src2->top);
+    dst->right = min(src1->right, src2->right);
+    dst->bottom = min(src1->bottom, src2->bottom);
+    return !IsRectEmpty(dst);
+}
+
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.39.0.rc2

From 4547ea362d90afe4cd7734e2aed653378499368d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 10:38:51 +0300
Subject: [PATCH 039/202] winewayland.drv: Create backing Wayland surfaces for
 windows.

Associate Wayland surfaces with windows that need to be displayed by
the native window system. This includes all kinds of top-level windows,
but not child windows, since children are rendered by Wine in the
window surface of their parent top-level.

As a special case, we use Wayland subsurfaces to display windows
that we believe are transient (e.g., popups) and need relative
positioning. We currently use a very simple heuristic to detect such
cases: windows that have an owner but no caption. Future commits
will refine this heuristic.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   4 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          | 180 +++++++++++++++++++++++++
 3 files changed, 185 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index aa517c22279..9e17f5a123a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -369,6 +369,10 @@ BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface) DECLSPEC_HIDDEN;
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                const RECT *window_rect, const RECT *client_rect,
                                RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index baa1283c161..69d5ae4d373 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -89,6 +89,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e85df9f5287..19d1d686ac0 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -33,6 +33,7 @@
 
 #include "ntuser.h"
 
+#include <assert.h>
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -48,6 +49,12 @@ struct wayland_win_data
     RECT           window_rect;
     /* client area relative to parent */
     RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* whether this window is visible */
+    BOOL           visible;
+    /* whether a wayland surface update is needed */
+    BOOL           wayland_surface_needs_update;
 };
 
 static struct wayland_mutex win_data_mutex =
@@ -70,6 +77,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     free(data);
 
     wayland_mutex_unlock(&win_data_mutex);
@@ -123,6 +131,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
         return NULL;
 
     data->hwnd = hwnd;
+    data->wayland_surface_needs_update = TRUE;
 
     wayland_mutex_lock(&win_data_mutex);
     win_data_context[context_idx(hwnd)] = data;
@@ -132,6 +141,154 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
     return data;
 }
 
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlocked
+ *
+ * Helper function to get the wayland_surface for a HWND without any locking.
+ * The caller should ensure that win_data_mutex has been locked before this
+ * operation, and for as long as the association between the HWND and the
+ * returned wayland_surface needs to remain valid.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_unlocked(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    assert(win_data_mutex.owner_tid == GetCurrentThreadId());
+
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data->wayland_surface;
+
+    return NULL;
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_update)
+        return TRUE;
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct wayland_surface *update_surface_for_role(struct wayland_win_data *data,
+                                                       enum wayland_surface_role role,
+                                                       struct wayland *wayland,
+                                                       struct wayland_surface *parent_surface)
+{
+    struct wayland_surface *surface = data->wayland_surface;
+
+    if (!surface ||
+        (role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != role))
+    {
+        surface = wayland_surface_create_plain(wayland);
+        if (surface) wayland_mutex_lock(&surface->mutex);
+    }
+    else
+    {
+        /* Lock the wayland surface to avoid other threads interacting with it
+         * while we are updating. */
+        wayland_mutex_lock(&surface->mutex);
+        wayland_surface_clear_role(surface);
+        /* Clear the associated HWND, to allow a potential invocation of
+         * wayland_surface_make_toplevel below, to properly handle the
+         * initial configure event. */
+        surface->hwnd = 0;
+    }
+
+    if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
+        wayland_surface_make_toplevel(surface, parent_surface);
+    else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        wayland_surface_make_subsurface(surface, parent_surface);
+
+    surface->hwnd = data->hwnd;
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    return surface;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND effective_parent_hwnd;
+    struct wayland_surface *surface;
+    struct wayland_surface *parent_surface;
+    DWORD style;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_update = FALSE;
+
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    effective_parent_hwnd = (HWND)NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+        parent_surface = wayland_surface_for_hwnd_unlocked(effective_parent_hwnd);
+
+    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Use wayland subsurfaces for children windows and windows that are
+     * transient (i.e., don't have a titlebar). Otherwise, if the window is
+     * visible make it wayland toplevel. Finally, if the window is not visible
+     * create a plain (without a role) surface to avoid polluting the
+     * compositor with empty xdg_toplevels. */
+    if ((style & WS_CAPTION) != WS_CAPTION)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
+                                          wayland, parent_surface);
+    }
+    else if (data->visible)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_TOPLEVEL,
+                                          wayland, parent_surface);
+    }
+    else
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_NONE,
+                                          wayland, parent_surface);
+    }
+
+    if (data->wayland_surface != surface)
+    {
+        if (data->wayland_surface)
+            wayland_surface_unref(data->wayland_surface);
+        data->wayland_surface = surface;
+    }
+}
+
+static struct wayland_win_data *update_wayland_state(struct wayland_win_data *data)
+{
+    HWND hwnd = data->hwnd;
+
+    /* Ensure we have a thread wayland instance. Perform the initialization
+     * outside the win_data lock to avoid potential deadlocks. */
+    if (!thread_wayland())
+    {
+        wayland_win_data_release(data);
+        thread_init_wayland();
+        data = wayland_win_data_get(hwnd);
+        if (!data) return NULL;
+    }
+
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+
+    return data;
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -183,11 +340,34 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     data->parent = (parent == NtUserGetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
     wayland_win_data_release(data);
     return TRUE;
 }
 
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), (UINT)NtUserGetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    data = update_wayland_state(data);
+
+    wayland_win_data_release(data);
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
-- 
2.39.0.rc2

From 55bbe09fd0d8bc048e422fcd7dfaa29bd455cb3b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 13:49:48 +0300
Subject: [PATCH 040/202] winewayland.drv: Implement window_surface for
 Wayland.

Implement struct window_surface for windows backed by wayland surfaces.
Each window_surface uses a Wayland SHM buffer queue to manage a set of
XRGB8888 (for now) buffers used to display the window contents.

During flushing the contents of the window_surface bitmap are copied to
a available SHM buffer and committed to the associated Wayland surface.
Surface damage, and the cumulative buffer damage, is taken into account
to minimize the amount of pixel data that needs to be copied.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   1 +
 dlls/winewayland.drv/waylanddrv.h     |  10 +
 dlls/winewayland.drv/window.c         |  68 +++++
 dlls/winewayland.drv/window_surface.c | 342 ++++++++++++++++++++++++++
 4 files changed, 421 insertions(+)
 create mode 100644 dlls/winewayland.drv/window_surface.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 197e4e8a323..0afcbe723ae 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -17,6 +17,7 @@ C_SRCS = \
 	wayland_surface.c \
 	waylanddrv_main.c \
 	window.c \
+	window_surface.c \
 
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9e17f5a123a..d35690485de 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -317,6 +317,16 @@ void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue) DECLSPEC_H
 void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage) DECLSPEC_HIDDEN;
 struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland window surface
+ */
+
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect) DECLSPEC_HIDDEN;
+void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPEC_HIDDEN;
+BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
+                                                   struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 19d1d686ac0..7f836829884 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -51,6 +51,12 @@ struct wayland_win_data
     RECT           client_rect;
     /* wayland surface (if any) representing this window on the wayland side */
     struct wayland_surface *wayland_surface;
+    /* wine window_surface backing this window */
+    struct window_surface *window_surface;
+    /* pending wine window_surface for this window */
+    struct window_surface *pending_window_surface;
+    /* whether the pending_window_surface value is valid */
+    BOOL           has_pending_window_surface;
     /* whether this window is visible */
     BOOL           visible;
     /* whether a wayland surface update is needed */
@@ -77,6 +83,16 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->has_pending_window_surface && data->pending_window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->pending_window_surface, NULL);
+        window_surface_release(data->pending_window_surface);
+    }
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+        window_surface_release(data->window_surface);
+    }
     if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     free(data);
 
@@ -283,9 +299,30 @@ static struct wayland_win_data *update_wayland_state(struct wayland_win_data *da
         if (!data) return NULL;
     }
 
+    if (data->has_pending_window_surface)
+    {
+        if (data->window_surface)
+        {
+            if (data->window_surface != data->pending_window_surface)
+                wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+            window_surface_release(data->window_surface);
+        }
+        data->window_surface = data->pending_window_surface;
+        data->has_pending_window_surface = FALSE;
+        data->pending_window_surface = NULL;
+    }
+
     if (wayland_win_data_wayland_surface_needs_update(data))
         wayland_win_data_update_wayland_surface(data);
 
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+        if (wayland_window_surface_needs_flush(data->window_surface))
+            wayland_window_surface_flush(data->window_surface);
+    }
+
     return data;
 }
 
@@ -330,6 +367,7 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     BOOL exstyle = NtUserGetWindowLongW(hwnd, GWL_EXSTYLE);
     DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
     HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
+    RECT surface_rect;
 
     TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
@@ -342,6 +380,30 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     data->client_rect = *client_rect;
     data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
+    /* Release the dummy surface wine provides for toplevels. */
+    if (*surface) window_surface_release(*surface);
+    *surface = NULL;
+
+    /* Check if we don't want a dedicated window surface. */
+    if (data->parent || (swp_flags & SWP_HIDEWINDOW) || !data->visible) goto done;
+
+    surface_rect = *window_rect;
+    OffsetRect(&surface_rect, -surface_rect.left, -surface_rect.top);
+
+    /* Check if we can reuse our current window surface. */
+    if (data->window_surface &&
+        EqualRect(&data->window_surface->rect, &surface_rect))
+    {
+        window_surface_add_ref(data->window_surface);
+        *surface = data->window_surface;
+        TRACE("reusing surface %p\n", *surface);
+        goto done;
+    }
+
+    /* Create new window surface. */
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect);
+
+done:
     wayland_win_data_release(data);
     return TRUE;
 }
@@ -363,6 +425,12 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
           wine_dbgstr_rect(visible_rect), (UINT)NtUserGetWindowLongW(hwnd, GWL_STYLE),
           insert_after, swp_flags);
 
+    if (surface) window_surface_add_ref(surface);
+    if (data->has_pending_window_surface && data->pending_window_surface)
+        window_surface_release(data->pending_window_surface);
+    data->pending_window_surface = surface;
+    data->has_pending_window_surface = TRUE;
+
     data = update_wayland_state(data);
 
     wayland_win_data_release(data);
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
new file mode 100644
index 00000000000..e97426e9340
--- /dev/null
+++ b/dlls/winewayland.drv/window_surface.c
@@ -0,0 +1,342 @@
+/*
+ * Wayland window surface implementation
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include "ntgdi.h"
+#include "winuser.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct wayland_window_surface
+{
+    struct window_surface header;
+    HWND                  hwnd;
+    struct wayland_surface *wayland_surface; /* Not owned by us */
+    struct wayland_buffer_queue *wayland_buffer_queue;
+    RECT                  bounds;
+    void                 *bits;
+    struct wayland_mutex  mutex;
+    BOOL                  last_flush_failed;
+    BITMAPINFO            info;
+};
+
+static struct wayland_window_surface *wayland_window_surface_cast(
+    struct window_surface *window_surface)
+{
+    return (struct wayland_window_surface *)window_surface;
+}
+
+static inline int get_dib_stride(int width, int bpp)
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size(const BITMAPINFO *info)
+{
+    return get_dib_stride(info->bmiHeader.biWidth, info->bmiHeader.biBitCount) *
+           abs(info->bmiHeader.biHeight);
+}
+
+static inline void reset_bounds(RECT *bounds)
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_lock
+ */
+static void wayland_window_surface_lock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    wayland_mutex_lock(&wws->mutex);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_unlock
+ */
+static void wayland_window_surface_unlock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    wayland_mutex_unlock(&wws->mutex);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bitmap_info
+ */
+static void *wayland_window_surface_get_bitmap_info(struct window_surface *window_surface,
+                                                    BITMAPINFO *info)
+{
+    struct wayland_window_surface *surface = wayland_window_surface_cast(window_surface);
+    /* We don't store any additional information at the end of our BITMAPINFO, so
+     * just copy the structure itself. */
+    memcpy(info, &surface->info, sizeof(*info));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bounds
+ */
+static RECT *wayland_window_surface_get_bounds(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return &wws->bounds;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_region
+ */
+static void wayland_window_surface_set_region(struct window_surface *window_surface,
+                                              HRGN region)
+{
+    /* TODO */
+}
+
+/***********************************************************************
+ *           wayland_window_surface_flush
+ */
+void wayland_window_surface_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    struct wayland_shm_buffer *buffer;
+    RECT damage_rect;
+    BOOL needs_flush;
+    RGNDATA *buffer_damage;
+    HRGN surface_damage_region = NULL;
+    RECT *rgn_rect;
+    RECT *rgn_rect_end;
+
+    window_surface->funcs->lock(window_surface);
+
+    TRACE("hwnd=%p surface_rect=%s bounds=%s\n", wws->hwnd,
+          wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
+
+    needs_flush = intersect_rect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
+    {
+        TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
+              wws->wayland_surface, wws->wayland_buffer_queue);
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+    wws->last_flush_failed = FALSE;
+
+    if (!needs_flush) goto done;
+
+    surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
+                                               damage_rect.right, damage_rect.bottom);
+
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+          wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
+          wws->bits);
+
+    assert(wws->wayland_buffer_queue);
+
+    wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
+    buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
+    if (!buffer)
+    {
+        WARN("failed to acquire wayland buffer, returning\n");
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+
+    rgn_rect = (RECT *)buffer_damage->Buffer;
+    rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
+
+    /* Flush damaged buffer region from window_surface bitmap to wayland SHM buffer. */
+    for (;rgn_rect < rgn_rect_end; rgn_rect++)
+    {
+        unsigned int *src, *dst;
+        int y, width, height;
+
+        TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
+
+        if (IsRectEmpty(rgn_rect))
+            continue;
+
+        src = (unsigned int *)wws->bits +
+              rgn_rect->top * wws->info.bmiHeader.biWidth +
+              rgn_rect->left;
+        dst = (unsigned int *)((unsigned char *)buffer->map_data +
+              rgn_rect->top * buffer->stride +
+              rgn_rect->left * 4);
+        width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
+        height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
+
+        /* Fast path for full width rectangles. */
+        if (width == buffer->width)
+        {
+            memcpy(dst, src, height * buffer->stride);
+            continue;
+        }
+
+        for (y = 0; y < height; y++)
+        {
+            memcpy(dst, src, width * 4);
+
+            src += wws->info.bmiHeader.biWidth;
+            dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
+        }
+    }
+
+    if (!wayland_surface_commit_buffer(wws->wayland_surface, buffer,
+                                       surface_damage_region))
+    {
+        wws->last_flush_failed = TRUE;
+    }
+
+    wayland_shm_buffer_clear_damage(buffer);
+
+    free(buffer_damage);
+
+done:
+    if (!wws->last_flush_failed) reset_bounds(&wws->bounds);
+    if (surface_damage_region) NtGdiDeleteObjectApp(surface_damage_region);
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_destroy
+ */
+static void wayland_window_surface_destroy(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("surface=%p\n", wws);
+
+    wayland_mutex_destroy(&wws->mutex);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    if (wws->wayland_buffer_queue)
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+    free(wws->bits);
+    free(wws);
+}
+
+static const struct window_surface_funcs wayland_window_surface_funcs =
+{
+    wayland_window_surface_lock,
+    wayland_window_surface_unlock,
+    wayland_window_surface_get_bitmap_info,
+    wayland_window_surface_get_bounds,
+    wayland_window_surface_set_region,
+    wayland_window_surface_flush,
+    wayland_window_surface_destroy
+};
+
+/***********************************************************************
+ *           wayland_window_surface_create
+ */
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect)
+{
+    struct wayland_window_surface *wws;
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+
+    TRACE("win %p rect %s\n", hwnd, wine_dbgstr_rect(rect));
+    wws = calloc(1, sizeof(*wws));
+    if (!wws) return NULL;
+    wws->info.bmiHeader.biSize = sizeof(wws->info.bmiHeader);
+    wws->info.bmiHeader.biClrUsed = 0;
+    wws->info.bmiHeader.biBitCount = 32;
+    wws->info.bmiHeader.biCompression = BI_RGB;
+    wws->info.bmiHeader.biWidth       = width;
+    wws->info.bmiHeader.biHeight      = -height; /* top-down */
+    wws->info.bmiHeader.biPlanes      = 1;
+    wws->info.bmiHeader.biSizeImage   = get_dib_image_size(&wws->info);
+
+    wayland_mutex_init(&wws->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_window_surface");
+
+    wws->header.funcs = &wayland_window_surface_funcs;
+    wws->header.rect  = *rect;
+    wws->header.ref   = 1;
+    wws->hwnd         = hwnd;
+    reset_bounds(&wws->bounds);
+
+    if (!(wws->bits = malloc(wws->info.bmiHeader.biSizeImage)))
+        goto failed;
+
+    TRACE("created %p hwnd %p %s bits %p-%p compression %u\n", wws, hwnd, wine_dbgstr_rect(rect),
+           wws->bits, (char *)wws->bits + wws->info.bmiHeader.biSizeImage,
+           (UINT)wws->info.bmiHeader.biCompression);
+
+    return &wws->header;
+
+failed:
+    wayland_window_surface_destroy(&wws->header);
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_needs_flush
+ */
+BOOL wayland_window_surface_needs_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return wws->last_flush_failed;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_wayland_surface
+ */
+void wayland_window_surface_update_wayland_surface(struct window_surface *window_surface,
+                                                   struct wayland_surface *wayland_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wayland_surface) wayland_surface_ref(wayland_surface);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    wws->wayland_surface = wayland_surface;
+
+    /* We only need a buffer queue if we have a surface to commit to. */
+    if (wws->wayland_surface && !wws->wayland_buffer_queue)
+    {
+        wws->wayland_buffer_queue =
+            wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    WL_SHM_FORMAT_XRGB8888);
+    }
+    else if (!wws->wayland_surface && wws->wayland_buffer_queue)
+    {
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+        wws->wayland_buffer_queue = NULL;
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.39.0.rc2

From 8d33244161029418ffcaa16cc3f9cfeef74052cc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 14:37:22 +0300
Subject: [PATCH 041/202] winewayland.drv: Read and queue Wayland events.

Create a separate reader thread to read Wayland events from the
compositor, queue them to their appropriate queues and also dispatch
events for the per-process Wayland instance. The reader thread notifies
all Wayland-enabled threads of possible new events by using an unnamed
pipe for each thread. The read end of the pipe is used as the Wine
driver queue fd for the respective thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/dllmain.c         | 14 ++++++
 dlls/winewayland.drv/unixlib.h         |  1 +
 dlls/winewayland.drv/wayland.c         | 61 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 dlls/winewayland.drv/waylanddrv_main.c | 41 +++++++++++++++++
 5 files changed, 119 insertions(+)

diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index 89d981a4314..4aee1d6b948 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -20,8 +20,19 @@
 
 #include "waylanddrv_dll.h"
 
+static DWORD WINAPI wayland_read_events_thread(void *arg)
+{
+    WAYLANDDRV_UNIX_CALL(read_events, NULL);
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    TerminateProcess(GetCurrentProcess(), 1);
+    return 0;
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
+    DWORD tid;
+
     if (reason != DLL_PROCESS_ATTACH) return TRUE;
 
     DisableThreadLibraryCalls(instance);
@@ -30,5 +41,8 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
     if (WAYLANDDRV_UNIX_CALL(init, NULL))
         return FALSE;
 
+    /* Read wayland events from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid);
+
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 427837523e3..dc3bfdf8893 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -26,6 +26,7 @@
 enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
+    waylanddrv_unix_func_read_events,
     waylanddrv_unix_func_count,
 };
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 4c7964a2871..97f74cc1234 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -29,8 +29,10 @@
 #include "wine/debug.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <poll.h>
 #include <stdlib.h>
+#include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
@@ -159,10 +161,13 @@ static const struct wl_registry_listener registry_listener = {
 BOOL wayland_init(struct wayland *wayland)
 {
     struct wl_display *wl_display_wrapper;
+    int flags;
 
     TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
 
     wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
 
     wayland->process_id = GetCurrentProcessId();
     wayland->thread_id = GetCurrentThreadId();
@@ -212,6 +217,16 @@ BOOL wayland_init(struct wayland *wayland)
 
     if (!wayland_is_process(wayland))
     {
+        /* Thread wayland instances have notification pipes to inform them when
+         * there might be new events in their queues. The read part of the pipe
+         * is also used as the wine server queue fd. */
+        if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+            return FALSE;
+        /* Make just the read end non-blocking */
+        if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+            return FALSE;
+        if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+            return FALSE;
         /* Keep a list of all thread wayland instances. */
         wayland_mutex_lock(&thread_wayland_mutex);
         wl_list_insert(&thread_wayland_list, &wayland->thread_link);
@@ -239,6 +254,11 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     wayland_mutex_unlock(&thread_wayland_mutex);
 
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
@@ -322,6 +342,28 @@ void wayland_process_release(void)
     wayland_mutex_unlock(&process_wayland_mutex);
 }
 
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
+
 /**********************************************************************
  *          wayland_notify_wine_monitor_change
  *
@@ -444,7 +486,26 @@ int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
         return -1;
     }
 
+    /* We may have read and queued events in queues other than the specified
+     * one, so we need to notify threads (see wayland_read_events). */
+    wayland_notify_threads();
+
     TRACE("... done => %d events\n", ret);
 
     return ret;
 }
+
+/**********************************************************************
+ *          wayland_read_events_and_dispatch_process
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues, dispatch any events for the per-process wayland instance,
+ * and notify threads about the possibility of new per-thread wayland instance
+ * events (without dispatching them).
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events_and_dispatch_process(void)
+{
+    return (wayland_dispatch_queue(process_wayland->wl_event_queue, -1) != -1);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index d35690485de..f69438bf770 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -98,6 +98,7 @@ struct wayland
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
+    int event_notification_pipe[2];
 };
 
 struct wayland_output_mode
@@ -254,6 +255,7 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
+BOOL wayland_read_events_and_dispatch_process(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland surface
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 69d5ae4d373..08a6421f436 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -30,12 +30,43 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/server.h"
 
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        NtTerminateProcess(0, 1);
+    }
+
+    NtClose(handle);
+}
+
 /***********************************************************************
  *           Initialize per thread data
  */
@@ -59,6 +90,7 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         NtTerminateProcess(0, 1);
     }
 
+    set_queue_fd(&data->wayland);
     NtUserGetThreadInfo()->driver_data = (UINT_PTR)data;
 
     return data;
@@ -110,9 +142,18 @@ err:
     return STATUS_UNSUCCESSFUL;
 }
 
+static NTSTATUS waylanddrv_unix_read_events(void *arg)
+{
+    while (wayland_read_events_and_dispatch_process()) continue;
+    /* This function only returns on a fatal error, e.g., if our connection
+     * to the Wayland server is lost. */
+    return STATUS_UNSUCCESSFUL;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     waylanddrv_unix_init,
+    waylanddrv_unix_read_events,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
-- 
2.39.0.rc2

From 1a6fe443f84c88f78d774534cc60d472457966f5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:37:15 +0300
Subject: [PATCH 042/202] winewayland.drv: Add functions to transform Wayland
 to Wine coordinates.

The functions are currently trivial, in the sense that they apply the
identity transformation. They will be enhanced as needed in upcoming
commits to handle differences in the coordinate spaces, introduced, e.g,
by the use of scaling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  2 +-
 dlls/winewayland.drv/wayland_surface.c | 39 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++
 3 files changed, 46 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 0afcbe723ae..25230a6b8d5 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
-UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
 	display.c \
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 0a68c90824c..99c71846488 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -27,6 +27,7 @@
 #include "waylanddrv.h"
 #include "wine/debug.h"
 #include "ntgdi.h"
+#include "ntuser.h"
 
 #include <stdlib.h>
 
@@ -455,6 +456,31 @@ void wayland_surface_unmap(struct wayland_surface *surface)
     wayland_mutex_unlock(&surface->mutex);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_to_screen
+ *
+ * Converts the surface-local coordinates to Windows screen coordinates.
+ */
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y)
+{
+    RECT window_rect = {0};
+    int wine_x, wine_y;
+
+    wayland_surface_coords_to_wine(surface, wayland_x, wayland_y,
+                                   &wine_x, &wine_y);
+
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+
+    *screen_x = wine_x + window_rect.left;
+    *screen_y = wine_y + window_rect.top;
+
+    TRACE("hwnd=%p wayland=%.2f,%.2f rect=%s => screen=%d,%d\n",
+          surface->hwnd, wayland_x, wayland_y, wine_dbgstr_rect(&window_rect),
+          *screen_x, *screen_y);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
@@ -484,6 +510,19 @@ void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
     *wayland_y = round(w_y);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_to_wine
+ *
+ * Converts the surface-local coordinates to wine windows-local coordinates.
+ */
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y)
+{
+    *wine_x = round(wayland_x);
+    *wine_y = round(wayland_y);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f69438bf770..b75370f7a67 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -276,12 +276,18 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y) DECLSPEC_HIDDEN;
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
 void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
                                               int wine_x, int wine_y,
                                               int *wayland_x, int *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 
-- 
2.39.0.rc2

From 230f6deb9dd85b499eef9401a656f917f6f3fb97 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:49:33 +0300
Subject: [PATCH 043/202] winewayland.drv: Implement
 MsgWaitForMultipleObjectsEx.

Prepare for handling input events by dispatching thread Wayland events
in MsgWaitForMultipleObjectsEx and tracking the types of events actually
dispatched.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 85 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  4 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 90 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 97f74cc1234..aac8b59aa27 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -28,6 +28,8 @@
 
 #include "wine/debug.h"
 
+#include "winuser.h"
+
 #include <errno.h>
 #include <fcntl.h>
 #include <poll.h>
@@ -509,3 +511,86 @@ BOOL wayland_read_events_and_dispatch_process(void)
 {
     return (wayland_dispatch_queue(process_wayland->wl_event_queue, -1) != -1);
 }
+
+static int wayland_dispatch_thread_pending(struct wayland *wayland)
+{
+    char buf[64];
+
+    TRACE("wayland=%p queue=%p\n", wayland, wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    /* Consume notifications */
+    while (TRUE)
+    {
+        int ret = read(wayland->event_notification_pipe[0], buf, sizeof(buf));
+        if (ret > 0) continue;
+        if (ret == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EAGAIN) break; /* no data to read */
+            ERR("failed to read from notification pipe: %s\n", strerror(errno));
+            break;
+        }
+        if (ret == 0)
+        {
+            ERR("failed to read from notification pipe: pipe is closed\n");
+            break;
+        }
+    }
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->wl_event_queue);
+}
+
+static BOOL wayland_process_thread_events(struct wayland *wayland, DWORD mask)
+{
+    int dispatched;
+
+    wayland->last_dispatch_mask = 0;
+
+    dispatched = wayland_dispatch_thread_pending(wayland);
+    if (dispatched)
+        wayland->last_dispatch_mask |= QS_SENDMESSAGE;
+
+    TRACE("dispatched=%d mask=%s%s%s%s%s%s%s\n",
+          dispatched,
+          (wayland->last_dispatch_mask & QS_KEY) ? "QS_KEY|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEMOVE) ? "QS_MOUSEMOVE|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEBUTTON) ? "QS_MOUSEBUTTON|" : "",
+          (wayland->last_dispatch_mask & QS_INPUT) ? "QS_INPUT|" : "",
+          (wayland->last_dispatch_mask & QS_PAINT) ? "QS_PAINT|" : "",
+          (wayland->last_dispatch_mask & QS_POSTMESSAGE) ? "QS_POSTMESSAGE|" : "",
+          (wayland->last_dispatch_mask & QS_SENDMESSAGE) ? "QS_SENDMESSAGE|" : "");
+
+    return wayland->last_dispatch_mask & mask;
+}
+
+/***********************************************************************
+ *           WAYLAND_MsgWaitForMultipleObjectsEx
+ */
+NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                             const LARGE_INTEGER *timeout,
+                                             DWORD mask, DWORD flags)
+{
+    struct wayland *wayland = thread_wayland();
+    NTSTATUS ret;
+
+    if (wayland && wayland_process_thread_events(wayland, mask))
+    {
+        ret = count - 1;
+    }
+    else if (count || !timeout || timeout->QuadPart)
+    {
+        ret = NtWaitForMultipleObjects(count, handles, !(flags & MWMO_WAITALL),
+                                       !!(flags & MWMO_ALERTABLE), timeout);
+        if (wayland && ret == count - 1)
+            wayland_process_thread_events(wayland, mask);
+    }
+    else
+    {
+        ret = WAIT_TIMEOUT;
+    }
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b75370f7a67..620375aa43c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -98,6 +98,7 @@ struct wayland
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
+    DWORD last_dispatch_mask;
     int event_notification_pipe[2];
 };
 
@@ -384,6 +385,9 @@ LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DEC
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
                                        LPDEVMODEW devmode) DECLSPEC_HIDDEN;
+NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                             const LARGE_INTEGER *timeout,
+                                             DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 08a6421f436..4f544fde79d 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -118,6 +118,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
+    .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.39.0.rc2

From 0c6d517d0d92b4480f784af35621b5c488bab1fe Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 12:56:08 +0300
Subject: [PATCH 044/202] winewayland.drv: Handle Wayland pointer events.

Handle pointer events from the Wayland compositor, transform them
appropriately and send them to Wine core.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland.c         |  40 +++++
 dlls/winewayland.drv/wayland_pointer.c | 240 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |   5 +
 dlls/winewayland.drv/waylanddrv.h      |  18 ++
 5 files changed, 304 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_pointer.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 25230a6b8d5..d5d96b2788d 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -12,6 +12,7 @@ C_SRCS = \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
+	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_shmfd.c \
 	wayland_surface.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index aac8b59aa27..7278f6b4f57 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -64,6 +64,34 @@ static const struct xdg_wm_base_listener xdg_wm_base_listener = {
     xdg_wm_base_ping,
 };
 
+/**********************************************************************
+ *          Seat handling
+ */
+
+static void seat_handle_capabilities(void *data, struct wl_seat *seat,
+                                     enum wl_seat_capability caps)
+{
+    struct wayland *wayland = data;
+
+    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_init(&wayland->pointer, wayland, wl_seat_get_pointer(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_deinit(&wayland->pointer);
+    }
+}
+
+static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
+{
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+    seat_handle_name,
+};
+
 /**********************************************************************
  *          Registry handling
  */
@@ -120,6 +148,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
     }
+    else if (strcmp(interface, "wl_seat") == 0)
+    {
+        wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
+                                            version < 5 ? version : 5);
+        wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -268,6 +302,12 @@ void wayland_deinit(struct wayland *wayland)
                           &wayland->detached_shm_buffer_list, link)
         wayland_shm_buffer_destroy(shm_buffer);
 
+    if (wayland->pointer.wl_pointer)
+        wayland_pointer_deinit(&wayland->pointer);
+
+    if (wayland->wl_seat)
+        wl_seat_destroy(wayland->wl_seat);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
new file mode 100644
index 00000000000..26116eeb2f8
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -0,0 +1,240 @@
+/*
+ * Wayland input handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <linux/input.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          Pointer handling
+ */
+
+static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointer,
+                                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    int screen_x, screen_y;
+    RECT screen_rect;
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_screen(wayland->pointer.focused_surface,
+                                     wl_fixed_to_double(sx),
+                                     wl_fixed_to_double(sy),
+                                     &screen_x, &screen_y);
+
+    /* Sometimes, due to rounding, we may end up with pointer coordinates
+     * slightly outside the target window, so bring them within bounds. */
+    if (NtUserGetWindowRect(focused_hwnd, &screen_rect))
+    {
+        if (screen_x >= screen_rect.right) screen_x = screen_rect.right - 1;
+        else if (screen_x < screen_rect.left) screen_x = screen_rect.left;
+        if (screen_y >= screen_rect.bottom) screen_y = screen_rect.bottom - 1;
+        else if (screen_y < screen_rect.top) screen_y = screen_rect.top;
+    }
+
+    TRACE("surface=%p hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_double(sx), wl_fixed_to_double(sy),
+          screen_x, screen_y);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = screen_x;
+    input.mi.dy          = screen_y;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
+                                  uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    pointer_handle_motion_internal(data, pointer, time, sx, sy);
+}
+
+static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface,
+                                 wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since pointer events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
+        wayland->pointer.focused_surface = wayland_surface;
+        wayland->pointer.enter_serial = serial;
+        /* Handle the enter as a motion, to account for cases where the
+         * window first appears beneath the pointer and won't get a separate
+         * motion event. */
+        pointer_handle_motion_internal(data, pointer, 0, sx, sy);
+    }
+}
+
+static void pointer_handle_leave(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+
+    if (wayland->pointer.focused_surface &&
+        wayland->pointer.focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n",
+              wayland->pointer.focused_surface,
+              wayland->pointer.focused_surface->hwnd);
+        wayland->pointer.focused_surface = NULL;
+        wayland->pointer.enter_serial = 0;
+    }
+}
+
+static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+                                  uint32_t serial, uint32_t time, uint32_t button,
+                                  uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("button=%#x state=%#x hwnd=%p\n", button, state, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (button)
+    {
+    case BTN_LEFT: input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN; break;
+    case BTN_RIGHT: input.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN; break;
+    case BTN_MIDDLE: input.mi.dwFlags = MOUSEEVENTF_MIDDLEDOWN; break;
+    default: break;
+    }
+
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+        input.mi.dwFlags <<= 1;
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+                                uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
+{
+}
+
+static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
+                                       uint32_t axis_source)
+{
+}
+
+static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
+                                     uint32_t time, uint32_t axis)
+{
+}
+
+static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+                                         uint32_t axis, int32_t discrete)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("axis=%#x discrete=%d hwnd=%p\n", axis, discrete, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+        input.mi.mouseData = -WHEEL_DELTA * discrete;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+        input.mi.mouseData = WHEEL_DELTA * discrete;
+        break;
+    default: break;
+    }
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,
+    pointer_handle_leave,
+    pointer_handle_motion,
+    pointer_handle_button,
+    pointer_handle_axis,
+    pointer_handle_frame,
+    pointer_handle_axis_source,
+    pointer_handle_axis_stop,
+    pointer_handle_axis_discrete,
+};
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer)
+{
+    wayland->pointer.wayland = wayland;
+    wayland->pointer.wl_pointer = wl_pointer;
+    wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+}
+
+void wayland_pointer_deinit(struct wayland_pointer *pointer)
+{
+    if (pointer->wl_pointer)
+        wl_pointer_destroy(pointer->wl_pointer);
+
+    memset(pointer, 0, sizeof(*pointer));
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 99c71846488..1bb7da5db16 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -401,8 +401,13 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
+    struct wayland_pointer *pointer = &surface->wayland->pointer;
+
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
+    if (pointer->focused_surface == surface)
+        pointer->focused_surface = NULL;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 620375aa43c..7fbc3a00f78 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -81,6 +81,14 @@ struct wayland_mutex
     const char *name;
 };
 
+struct wayland_pointer
+{
+    struct wayland *wayland;
+    struct wl_pointer *wl_pointer;
+    struct wayland_surface *focused_surface;
+    uint32_t enter_serial;
+};
+
 struct wayland
 {
     struct wl_list thread_link;
@@ -94,10 +102,12 @@ struct wayland
     struct wl_subcompositor *wl_subcompositor;
     struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
+    struct wl_seat *wl_seat;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
+    struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
 };
@@ -336,6 +346,14 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland Pointer
+ */
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
+void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
-- 
2.39.0.rc2

From f15f33758af33ce6afa295a881d3f6fbcd324af2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 13:02:25 +0300
Subject: [PATCH 045/202] winewayland.drv: Implement SetCursor.

Instruct the Wayland compositor to set or update the cursor surface for
the Wayland surface that has the pointer focus when SetCursor is called.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland_cursor.c  | 400 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_pointer.c |  16 +
 dlls/winewayland.drv/waylanddrv.h      |  24 +-
 dlls/winewayland.drv/waylanddrv_main.c |   3 +
 dlls/winewayland.drv/window.c          |   4 +
 6 files changed, 447 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_cursor.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d5d96b2788d..d0148bdf3ab 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	unicode.c \
 	wayland.c \
 	wayland_buffer_queue.c \
+	wayland_cursor.c \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
new file mode 100644
index 00000000000..d55676550cf
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -0,0 +1,400 @@
+/*
+ * Wayland cursor handling
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "waylanddrv.h"
+
+#include "ntgdi.h"
+#include "ntuser.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static HCURSOR last_cursor;
+static HCURSOR invalid_cursor;
+
+/***********************************************************************
+ *           get_icon_info
+ *
+ * Local GetIconInfoExW helper implementation.
+ */
+static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
+{
+    UNICODE_STRING module, res_name;
+    ICONINFO info;
+
+    module.Buffer = ret->szModName;
+    module.MaximumLength = sizeof(ret->szModName) - sizeof(WCHAR);
+    res_name.Buffer = ret->szResName;
+    res_name.MaximumLength = sizeof(ret->szResName) - sizeof(WCHAR);
+    if (!NtUserGetIconInfo(handle, &info, &module, &res_name, NULL, 0)) return FALSE;
+    ret->fIcon = info.fIcon;
+    ret->xHotspot = info.xHotspot;
+    ret->yHotspot = info.yHotspot;
+    ret->hbmColor = info.hbmColor;
+    ret->hbmMask = info.hbmMask;
+    ret->wResID = res_name.Length ? 0 : LOWORD(res_name.Buffer);
+    ret->szModName[module.Length] = 0;
+    ret->szResName[res_name.Length] = 0;
+    return TRUE;
+}
+
+/***********************************************************************
+ *           create_mono_cursor_buffer
+ *
+ * Return a monochrome icon/cursor wl_shm_buffer
+ */
+static struct wayland_shm_buffer *create_mono_cursor_buffer(struct wayland *wayland,
+                                                            HBITMAP bmp)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    BITMAP bm;
+    char *mask = NULL;
+    unsigned int i, j, stride, mask_size, *ptr;
+
+    if (!NtGdiExtGetObjectW(bmp, sizeof(bm), &bm)) return NULL;
+    stride = ((bm.bmWidth + 15) >> 3) & ~1;
+    mask_size = stride * bm.bmHeight;
+    if (!(mask = malloc(mask_size))) return NULL;
+    if (!NtGdiGetBitmapBits(bmp, mask_size, mask)) goto done;
+
+    bm.bmHeight /= 2;
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto done;
+
+    ptr = shm_buffer->map_data;
+    for (i = 0; i < bm.bmHeight; i++)
+    {
+        for (j = 0; j < bm.bmWidth; j++, ptr++)
+        {
+            int and = ((mask[i * stride + j / 8] << (j % 8)) & 0x80);
+            int xor = ((mask[(i + bm.bmHeight) * stride + j / 8] << (j % 8)) & 0x80);
+            if (!xor && and)
+                *ptr = 0;
+            else if (xor && !and)
+                *ptr = 0xffffffff;
+            else
+                /* we can't draw "invert" pixels, so render them as black instead */
+                *ptr = 0xff000000;
+        }
+    }
+
+done:
+    free(mask);
+    return shm_buffer;
+}
+
+/***********************************************************************
+ *           get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icons and cursors.
+ */
+static struct wayland_shm_buffer *create_color_cursor_buffer(struct wayland *wayland,
+                                                             HDC hdc, HBITMAP color,
+                                                             HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        free(mask_bits);
+    }
+
+    /* Wayland requires pre-multiplied alpha values */
+    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
+    {
+        unsigned char alpha = *ptr >> 24;
+        if (alpha == 0)
+        {
+            *ptr = 0;
+        }
+        else if (alpha != 255)
+        {
+            *ptr = (alpha << 24) |
+                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
+                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
+                   (((BYTE)*ptr * alpha / 255));
+        }
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info = { 0 };
+    struct wayland_cursor *wayland_cursor = NULL;
+    struct wayland_shm_buffer *shm_buffer = NULL;
+
+    if (!handle) return NULL;
+
+    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto out;
+
+    if (!get_icon_info(handle, &info)) goto out;
+
+    if (info.hbmColor)
+    {
+        HDC hdc = NtGdiCreateCompatibleDC(0);
+        shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+                                                info.hbmColor, info.hbmMask);
+        NtGdiDeleteObjectApp(hdc);
+    }
+    else
+    {
+        shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+    }
+
+    if (!shm_buffer) goto out;
+
+    wayland_cursor->width = shm_buffer->width;
+    wayland_cursor->height = shm_buffer->height;
+    wayland_cursor->wl_buffer =
+        wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+
+    /* make sure hotspot is valid */
+    if (info.xHotspot >= wayland_cursor->width ||
+        info.yHotspot >= wayland_cursor->height)
+    {
+        info.xHotspot = wayland_cursor->width / 2;
+        info.yHotspot = wayland_cursor->height / 2;
+    }
+
+    if (pointer->focused_surface)
+    {
+        wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                 info.xHotspot, info.yHotspot,
+                                                 &wayland_cursor->hotspot_x,
+                                                 &wayland_cursor->hotspot_y);
+    }
+    else
+    {
+        wayland_cursor->hotspot_x = info.xHotspot;
+        wayland_cursor->hotspot_y = info.yHotspot;
+    }
+
+out:
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (wayland_cursor && !wayland_cursor->wl_buffer)
+    {
+        wayland_cursor_destroy(wayland_cursor);
+        wayland_cursor = NULL;
+    }
+    return wayland_cursor;
+}
+
+/***********************************************************************
+ *           wayland_cursor_destroy
+ *
+ *  Destroy a Wayland cursor and its associated resources.
+ */
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
+{
+    if (!wayland_cursor)
+        return;
+
+    if (wayland_cursor->wl_buffer)
+        wl_buffer_destroy(wayland_cursor->wl_buffer);
+
+    free(wayland_cursor);
+}
+
+/***********************************************************************
+ *           wayland_pointer_update_cursor_from_win32
+ *
+ *  Update a Wayland pointer to use the specified cursor, or NULL
+ *  to hide the cursor.
+ */
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle)
+{
+    struct wayland_cursor *wayland_cursor = pointer->cursor;
+
+    TRACE("pointer=%p pointer->hcursor=%p handle=%p\n",
+          pointer, pointer ? pointer->hcursor : 0, handle);
+
+    if (!pointer->wl_pointer)
+        return;
+
+    if (pointer->hcursor != handle)
+    {
+        wayland_cursor = wayland_cursor_from_win32(pointer, handle);
+        /* If we can't create a cursor from a valid handle, better to keep the
+         * previous cursor than make it disappear completely. */
+        if (!wayland_cursor && handle)
+            return;
+
+        if (pointer->cursor)
+            wayland_cursor_destroy(pointer->cursor);
+    }
+
+    pointer->cursor = wayland_cursor;
+    pointer->hcursor = handle;
+
+    if (!pointer->cursor)
+    {
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  NULL, 0, 0);
+            return;
+    }
+
+    wl_surface_attach(pointer->cursor_wl_surface, pointer->cursor->wl_buffer, 0, 0);
+    wl_surface_damage_buffer(pointer->cursor_wl_surface, 0, 0,
+                             wayland_cursor->width, wayland_cursor->height);
+
+    wl_surface_commit(pointer->cursor_wl_surface);
+
+    wl_pointer_set_cursor(pointer->wl_pointer,
+                          pointer->enter_serial,
+                          pointer->cursor_wl_surface,
+                          pointer->cursor->hotspot_x,
+                          pointer->cursor->hotspot_y);
+}
+
+/***********************************************************************
+ *           wayland_init_set_cursor
+ *
+ *  Initalize internal information, so that we can track the last set
+ *  cursor properly.
+ */
+BOOL wayland_init_set_cursor(void)
+{
+    /* Allocate a handle that we are going to treat as invalid. */
+    SERVER_START_REQ(alloc_user_handle)
+    {
+        if (!wine_server_call_err(req))
+            invalid_cursor = wine_server_ptr_handle(reply->handle);
+    }
+    SERVER_END_REQ;
+
+    TRACE("invalid_cursor=%p\n", invalid_cursor);
+
+    last_cursor = invalid_cursor;
+
+    return invalid_cursor != NULL;
+}
+
+/***********************************************************************
+ *           wayland_invalidate_set_cursor
+ *
+ *  Invalidate the cursor we consider to be set, effectively forcing
+ *  the application of next SetCursor call.
+ */
+void wayland_invalidate_set_cursor(void)
+{
+    __atomic_store_n(&last_cursor, invalid_cursor, __ATOMIC_SEQ_CST);
+}
+
+static HWND wayland_get_thread_cursor_hwnd(void)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND cursor_hwnd;
+
+    if (wayland && wayland->pointer.focused_surface)
+        cursor_hwnd = wayland->pointer.focused_surface->hwnd;
+    else
+        cursor_hwnd = NULL;
+
+    return cursor_hwnd;
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursor
+ */
+void WAYLAND_SetCursor(HCURSOR hcursor)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+
+    TRACE("hcursor=%p last_cursor=%p cursor_hwnd=%p\n",
+          hcursor, last_cursor, cursor_hwnd);
+
+    if (!cursor_hwnd) return;
+
+    if (__atomic_exchange_n(&last_cursor, hcursor, __ATOMIC_SEQ_CST) != hcursor)
+    {
+        send_message(cursor_hwnd, WM_WAYLAND_SET_CURSOR, GetCurrentThreadId(),
+                     (LPARAM)hcursor);
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 26116eeb2f8..6841e8572af 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -104,6 +104,14 @@ static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
         TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
         wayland->pointer.focused_surface = wayland_surface;
         wayland->pointer.enter_serial = serial;
+        /* Invalidate the set cursor cache, so that next update is
+         * unconditionally applied. */
+        wayland_invalidate_set_cursor();
+        /* Reapply the current cursor, using NtUserSetCursor() instead of
+         * directly calling our driver function, so that the per-thread cursor
+         * visibility state (i.e., ShowCursor()), which is difficult to access
+         * otherwise, is taken into account. */
+        NtUserSetCursor(NtUserGetCursor());
         /* Handle the enter as a motion, to account for cases where the
          * window first appears beneath the pointer and won't get a separate
          * motion event. */
@@ -229,6 +237,8 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
     wayland->pointer.wayland = wayland;
     wayland->pointer.wl_pointer = wl_pointer;
     wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+    wayland->pointer.cursor_wl_surface =
+        wl_compositor_create_surface(wayland->wl_compositor);
 }
 
 void wayland_pointer_deinit(struct wayland_pointer *pointer)
@@ -236,5 +246,11 @@ void wayland_pointer_deinit(struct wayland_pointer *pointer)
     if (pointer->wl_pointer)
         wl_pointer_destroy(pointer->wl_pointer);
 
+    if (pointer->cursor_wl_surface)
+        wl_surface_destroy(pointer->cursor_wl_surface);
+
+    if (pointer->cursor)
+        wayland_cursor_destroy(pointer->cursor);
+
     memset(pointer, 0, sizeof(*pointer));
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7fbc3a00f78..87f830eccc1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -52,6 +52,7 @@ extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 enum wayland_window_message
 {
     WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
+    WM_WAYLAND_SET_CURSOR,
 };
 
 enum wayland_surface_role
@@ -73,6 +74,9 @@ enum wayland_configure_flags
  *          Definitions for wayland types
  */
 
+struct wayland_surface;
+struct wayland_shm_buffer;
+
 struct wayland_mutex
 {
     pthread_mutex_t mutex;
@@ -81,12 +85,24 @@ struct wayland_mutex
     const char *name;
 };
 
+struct wayland_cursor
+{
+    struct wl_buffer *wl_buffer;
+    int width;
+    int height;
+    int hotspot_x;
+    int hotspot_y;
+};
+
 struct wayland_pointer
 {
     struct wayland *wayland;
     struct wl_pointer *wl_pointer;
     struct wayland_surface *focused_surface;
+    struct wl_surface *cursor_wl_surface;
     uint32_t enter_serial;
+    struct wayland_cursor *cursor;
+    HCURSOR hcursor;
 };
 
 struct wayland
@@ -347,12 +363,17 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 
 /**********************************************************************
- *          Wayland Pointer
+ *          Wayland Pointer/Cursor
  */
 
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
 void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle) DECLSPEC_HIDDEN;
+BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
+void wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Misc. helpers
@@ -406,6 +427,7 @@ BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
 NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
+void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 4f544fde79d..b2a2cfb0c4f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -119,6 +119,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
+    .pSetCursor = WAYLAND_SetCursor,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
@@ -134,6 +135,8 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
      * our initialization. We clear them on error. */
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
+    if (!wayland_init_set_cursor()) goto err;
+
     if (!wayland_process_init()) goto err;
 
     return 0;
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 7f836829884..8c6f0b456a4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -474,6 +474,10 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_MONITOR_CHANGE:
         handle_wm_wayland_monitor_change(thread_wayland());
         break;
+    case WM_WAYLAND_SET_CURSOR:
+        wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
+                                                 (HCURSOR)lp);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From 5481fbb4d1b698f37544102b5cce0ef51ed0bfc2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 1 Nov 2022 11:02:22 +0200
Subject: [PATCH 046/202] winewayland.drv: Set the XDG app id using the process
 name.

Setting the XDG app id allows compositor to display the proper
name and icon for the application.

Co-authored-by: Ryan Hendrickson <ryan.hendrickson@alum.mit.edu>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c |  3 +++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c | 32 ++++++++++++++++++++++++++
 3 files changed, 36 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 1bb7da5db16..7fb868d3e68 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -180,6 +180,9 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
 
+    if (process_name)
+        xdg_toplevel_set_app_id(surface->xdg_toplevel, process_name);
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 87f830eccc1..37ca86d96b2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -43,6 +43,7 @@
  *          Globals
  */
 
+extern char *process_name DECLSPEC_HIDDEN;
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index b2a2cfb0c4f..65ad3c3ebb5 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -37,6 +37,8 @@
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+char *process_name = NULL;
+
 static void set_queue_fd(struct wayland *wayland)
 {
     HANDLE handle;
@@ -129,12 +131,42 @@ static const struct user_driver_funcs waylanddrv_funcs =
 
 static const struct user_driver_funcs null_funcs = { 0 };
 
+static void wayland_init_process_name(void)
+{
+    WCHAR *p, *appname;
+    WCHAR appname_lower[MAX_PATH];
+    DWORD appname_len;
+    DWORD appnamez_size;
+    DWORD utf8_size;
+    int i;
+
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    appname_len = lstrlenW(appname);
+
+    if (appname_len == 0 || appname_len >= MAX_PATH) return;
+
+    for (i = 0; appname[i]; i++) appname_lower[i] = RtlDowncaseUnicodeChar(appname[i]);
+    appname_lower[i] = 0;
+
+    appnamez_size = (appname_len + 1) * sizeof(WCHAR);
+
+    if (!RtlUnicodeToUTF8N(NULL, 0, &utf8_size, appname_lower, appnamez_size) &&
+        (process_name = malloc(utf8_size)))
+    {
+        RtlUnicodeToUTF8N(process_name, utf8_size, &utf8_size, appname_lower, appnamez_size);
+    }
+}
+
 static NTSTATUS waylanddrv_unix_init(void *arg)
 {
     /* Set the user driver functions now so that they are available during
      * our initialization. We clear them on error. */
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
+    wayland_init_process_name();
+
     if (!wayland_init_set_cursor()) goto err;
 
     if (!wayland_process_init()) goto err;
-- 
2.39.0.rc2

From 72f7c0f21beaf2f7d97b12b31434a57f900f35b7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 27 Apr 2022 15:41:19 +0300
Subject: [PATCH 047/202] winewayland.drv: Introduce helpers for registry
 access.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in  |   1 +
 dlls/winewayland.drv/registry.c   | 167 ++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  10 ++
 3 files changed, 178 insertions(+)
 create mode 100644 dlls/winewayland.drv/registry.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d0148bdf3ab..93c5248b956 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -6,6 +6,7 @@ UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	registry.c \
 	unicode.c \
 	wayland.c \
 	wayland_buffer_queue.c \
diff --git a/dlls/winewayland.drv/registry.c b/dlls/winewayland.drv/registry.c
new file mode 100644
index 00000000000..c511da1a465
--- /dev/null
+++ b/dlls/winewayland.drv/registry.c
@@ -0,0 +1,167 @@
+/*
+ * Registry helpers
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <stdio.h>
+
+/**********************************************************************
+ *          reg_open_key_a
+ *
+ *  Open a registry key with the specified ASCII name.
+ */
+HKEY reg_open_key_a(HKEY root, const char *name)
+{
+    WCHAR nameW[256];
+    if (!name || !*name) return root;
+    if (ascii_to_unicode_maybe_z(nameW, ARRAY_SIZE(nameW), name, -1) > ARRAY_SIZE(nameW))
+        return 0;
+    return reg_open_key_w(root, nameW);
+}
+
+/**********************************************************************
+ *          reg_open_key_w
+ *
+ *  Open a registry key with the specified Unicode name.
+ */
+HKEY reg_open_key_w(HKEY root, const WCHAR *nameW)
+{
+    INT name_len = nameW ? lstrlenW(nameW) * sizeof(WCHAR) : 0;
+    UNICODE_STRING name_unicode = { name_len, name_len, (WCHAR *)nameW };
+    OBJECT_ATTRIBUTES attr;
+    HANDLE ret;
+
+    if (!nameW || !*nameW) return root;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &name_unicode;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
+}
+
+/**********************************************************************
+ *          reg_open_hkcu_key_a
+ *
+ *  Open a registry key under HKCU with the specified ASCII name.
+ */
+HKEY reg_open_hkcu_key_a(const char *name)
+{
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data,
+                                    len, &len))
+        {
+            return 0;
+        }
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = snprintf(buffer, ARRAY_SIZE(buffer), "\\Registry\\User\\S-%u-%u",
+                       sid->Revision,
+                       (int)MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                              sid->IdentifierAuthority.Value[4]),
+                                     MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                              sid->IdentifierAuthority.Value[2])));
+        if (len >= ARRAY_SIZE(buffer)) return 0;
+
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+        {
+            len += snprintf(buffer + len, ARRAY_SIZE(buffer) - len, "-%u",
+                            (UINT)sid->SubAuthority[i]);
+            if (len >= ARRAY_SIZE(buffer)) return 0;
+        }
+
+        hkcu = reg_open_key_a(NULL, buffer);
+    }
+
+    return reg_open_key_a(hkcu, name);
+}
+
+static DWORD reg_get_value_info(HKEY hkey, const WCHAR *nameW, ULONG type,
+                                KEY_VALUE_PARTIAL_INFORMATION *info,
+                                ULONG info_size)
+{
+    unsigned int name_size = lstrlenW(nameW) * sizeof(WCHAR);
+    UNICODE_STRING name_unicode = { name_size, name_size, (WCHAR *)nameW };
+
+    if (NtQueryValueKey(hkey, &name_unicode, KeyValuePartialInformation,
+                        info, info_size, &info_size))
+        return ERROR_FILE_NOT_FOUND;
+
+    if (info->Type != type) return ERROR_DATATYPE_MISMATCH;
+
+    return ERROR_SUCCESS;
+}
+
+/**********************************************************************
+ *          reg_get_value_a
+ *
+ *  Get the value of the specified registry key (or subkey if name is not NULL),
+ *  having the specified type. If the types do not match an error is returned.
+ *  If the stored value is REG_SZ the string is transformed into ASCII before
+ *  being returned.
+ */
+DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
+                      DWORD *buffer_len)
+{
+    WCHAR nameW[256];
+    char info_buf[2048];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)info_buf;
+    ULONG info_size = ARRAY_SIZE(info_buf);
+    DWORD err;
+
+    if (name && ascii_to_unicode_maybe_z(nameW, ARRAY_SIZE(nameW), name, -1) > ARRAY_SIZE(nameW))
+        return ERROR_INSUFFICIENT_BUFFER;
+
+    if ((err = reg_get_value_info(hkey, name ? nameW : NULL, type, info, info_size)))
+        return err;
+
+    if (type == REG_SZ)
+    {
+        size_t nchars = unicode_to_ascii_maybe_z(buffer, *buffer_len, (WCHAR *)info->Data,
+                                                 info->DataLength / sizeof(WCHAR));
+        err = *buffer_len >= nchars ? ERROR_SUCCESS : ERROR_MORE_DATA;
+        *buffer_len = nchars;
+    }
+    else
+    {
+        err = *buffer_len >= info->DataLength ? ERROR_SUCCESS : ERROR_MORE_DATA;
+        if (err == ERROR_SUCCESS) memcpy(buffer, info->Data, info->DataLength);
+        *buffer_len = info->DataLength;
+    }
+
+    return err;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 37ca86d96b2..07b347743d7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -376,6 +376,16 @@ void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
 BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
 void wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Registry helpers
+ */
+
+HKEY reg_open_key_a(HKEY root, const char *name) DECLSPEC_HIDDEN;
+HKEY reg_open_key_w(HKEY root, const WCHAR *nameW) DECLSPEC_HIDDEN;
+HKEY reg_open_hkcu_key_a(const char *name) DECLSPEC_HIDDEN;
+DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
+                      DWORD *buffer_len) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
-- 
2.39.0.rc2

From e99984ceb577b6ea9a59f0010706192737aef163 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:22:32 +0300
Subject: [PATCH 048/202] winewayland.drv: Introduce support for reading driver
 options from the registry.

Add the infrastructure to read driver options from the registry. Future
commits will add support for specific options.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/options.c         | 86 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 4 files changed, 90 insertions(+)
 create mode 100644 dlls/winewayland.drv/options.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 93c5248b956..bae8a496d8f 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -6,6 +6,7 @@ UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	options.c \
 	registry.c \
 	unicode.c \
 	wayland.c \
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
new file mode 100644
index 00000000000..53973893b97
--- /dev/null
+++ b/dlls/winewayland.drv/options.c
@@ -0,0 +1,86 @@
+/*
+ * winewayland.drv options
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Code to read options from the registry, adapted from the X11 driver */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+
+#include <string.h>
+
+/***********************************************************************
+ *		get_config_key
+ *
+ * Get a config key from either the app-specific or the default config
+ */
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   ULONG type, char *buffer, DWORD size)
+{
+    if (appkey && !reg_get_value_a(appkey, name, type, buffer, &size)) return 0;
+    if (defkey && !reg_get_value_a(defkey, name, type, buffer, &size)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/***********************************************************************
+ *		wayland_read_options_from_registry
+ *
+ * Read the Wayland driver options from the registry.
+ */
+void wayland_read_options_from_registry(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    HKEY hkey, appkey = 0;
+    DWORD process_name_len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = reg_open_hkcu_key_a("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    process_name_len = process_name ? strlen(process_name) : 0;
+    if (process_name_len > 0)
+    {
+        WCHAR appname[MAX_PATH + sizeof(waylanddriverW) / sizeof(WCHAR)];
+        DWORD reslen;
+        if (!RtlUTF8ToUnicodeN(appname, MAX_PATH * sizeof(WCHAR), &reslen,
+                               process_name, process_name_len))
+        {
+            HKEY tmpkey;
+            memcpy((char *)appname + reslen, waylanddriverW, sizeof(waylanddriverW));
+            /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+            if ((tmpkey = reg_open_hkcu_key_a("Software\\Wine\\AppDefaults")))
+            {
+                appkey = reg_open_key_w(tmpkey, appname);
+                NtClose(tmpkey);
+            }
+        }
+    }
+
+    if (appkey) NtClose(appkey);
+    if (hkey) NtClose(hkey);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 07b347743d7..bd4d9fa0726 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -255,6 +255,7 @@ BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
 struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
 void wayland_process_release(void) DECLSPEC_HIDDEN;
 void wayland_init_display_devices(void) DECLSPEC_HIDDEN;
+void wayland_read_options_from_registry(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 65ad3c3ebb5..fb542f74ed6 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -167,6 +167,8 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
 
     wayland_init_process_name();
 
+    wayland_read_options_from_registry();
+
     if (!wayland_init_set_cursor()) goto err;
 
     if (!wayland_process_init()) goto err;
-- 
2.39.0.rc2

From 397547f9dfc554db9038b6e9e8764d3845d1be1b Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Tue, 8 Mar 2022 14:22:59 -0300
Subject: [PATCH 049/202] winewayland.drv: Add support for native Wayland
 cursors.

Until now, we were using the cursors provided by Wine. Add native
Wayland cursor support, respecting the theme being used in the system.

The "UseSystemCursors" driver option controls whether to use the
native Wayland cursors (the default) or use the Wine provided
cursors.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                             |  85 ++++++-
 configure.ac                          |   7 +-
 dlls/winewayland.drv/Makefile.in      |   5 +-
 dlls/winewayland.drv/options.c        |  13 +
 dlls/winewayland.drv/wayland.c        |  18 +-
 dlls/winewayland.drv/wayland_cursor.c | 336 +++++++++++++++++++++++---
 dlls/winewayland.drv/waylanddrv.h     |   4 +
 include/config.h.in                   |   3 +
 8 files changed, 432 insertions(+), 39 deletions(-)

diff --git a/configure b/configure
index 96e722f3c47..471c222034f 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+WAYLAND_CURSOR_LIBS
+WAYLAND_CURSOR_CFLAGS
 WAYLAND_SCANNER
 WAYLAND_PROTOCOLS_DATADIR
 WAYLAND_PROTOCOLS_LIBS
@@ -1746,6 +1748,8 @@ WAYLAND_CLIENT_CFLAGS
 WAYLAND_CLIENT_LIBS
 WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_PROTOCOLS_LIBS
+WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2553,6 +2557,10 @@ Some influential environment variables:
               C compiler flags for wayland-protocols, overriding pkg-config
   WAYLAND_PROTOCOLS_LIBS
               Linker flags for wayland-protocols, overriding pkg-config
+  WAYLAND_CURSOR_CFLAGS
+              C compiler flags for wayland-cursor, overriding pkg-config
+  WAYLAND_CURSOR_LIBS
+              Linker flags for wayland-cursor, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -16035,10 +16043,83 @@ printf "%s\n" "no" >&6; }
 fi
 
 
+    if ${WAYLAND_CURSOR_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_CFLAGS=`$PKG_CONFIG --cflags wayland-cursor 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_CURSOR_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_LIBS=`$PKG_CONFIG --libs wayland-cursor 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor cflags: $WAYLAND_CURSOR_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor libs: $WAYLAND_CURSOR_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CURSOR_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-cursor.h" "ac_cv_header_wayland_cursor_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_cursor_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CURSOR_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_cursor_theme_load in -lwayland-cursor" >&5
+printf %s "checking for wl_cursor_theme_load in -lwayland-cursor... " >&6; }
+if test ${ac_cv_lib_wayland_cursor_wl_cursor_theme_load+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-cursor $WAYLAND_CURSOR_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char wl_cursor_theme_load ();
+int
+main (void)
+{
+return wl_cursor_theme_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=yes
+else $as_nop
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&5
+printf "%s\n" "$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&6; }
+if test "x$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" = xyes
+then :
+  :
+else $as_nop
+  WAYLAND_CURSOR_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
 fi
 if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
-                           test -z "$WAYLAND_SCANNER"
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS"
 then :
   case "x$with_wayland" in
   x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
@@ -23411,6 +23492,8 @@ WAYLAND_PROTOCOLS_CFLAGS = $WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_PROTOCOLS_LIBS = $WAYLAND_PROTOCOLS_LIBS
 WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
 WAYLAND_SCANNER = $WAYLAND_SCANNER
+WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index e0a28333cb3..b5fe7581b7f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1419,10 +1419,15 @@ then
                    `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
     AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
                  [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
+    WINE_PACKAGE_FLAGS(WAYLAND_CURSOR,[wayland-cursor],,,,
+        [AC_CHECK_HEADERS([wayland-cursor.h])
+         AC_CHECK_LIB(wayland-cursor,wl_cursor_theme_load,[:],
+                      [WAYLAND_CURSOR_LIBS=""],[$WAYLAND_CURSOR_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
-                           test -z "$WAYLAND_SCANNER"],
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index bae8a496d8f..d76fae2024a 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,8 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
-UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
+UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS)
+UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
+            $(PTHREAD_LIBS)
 
 C_SRCS = \
 	display.c \
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index 53973893b97..9a0b4774688 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -34,6 +34,15 @@
 
 #include <string.h>
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
+ *              Config options
+ */
+
+BOOL option_use_system_cursors = TRUE;
+
 /***********************************************************************
  *		get_config_key
  *
@@ -55,6 +64,7 @@ static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
 void wayland_read_options_from_registry(void)
 {
     static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    char buffer[64];
     HKEY hkey, appkey = 0;
     DWORD process_name_len;
 
@@ -81,6 +91,9 @@ void wayland_read_options_from_registry(void)
         }
     }
 
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
     if (appkey) NtClose(appkey);
     if (hkey) NtClose(hkey);
 }
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 7278f6b4f57..9f6ef5b6cde 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -121,8 +121,13 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wl_list_for_each(output, &wayland->output_list, link)
             wayland_output_use_xdg_extension(output);
     }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
 
-    /* The per-process wayland instance only handles output related globals. */
+    /* The per-process wayland instance only handles output related
+     * and wl_shm globals. */
     if (wayland_is_process(wayland)) return;
 
     if (strcmp(interface, "wl_compositor") == 0)
@@ -144,10 +149,6 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
                              version < 2 ? version : 2);
         xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
     }
-    else if (strcmp(interface, "wl_shm") == 0)
-    {
-        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
-    }
     else if (strcmp(interface, "wl_seat") == 0)
     {
         wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
@@ -251,7 +252,12 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     if (wayland_is_process(wayland)) wayland_process_release();
 
-    if (!wayland_is_process(wayland))
+    if (wayland_is_process(wayland))
+    {
+        if (option_use_system_cursors)
+            wayland_cursor_theme_init(wayland);
+    }
+    else
     {
         /* Thread wayland instances have notification pipes to inform them when
          * there might be new events in their queues. The read part of the pipe
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index d55676550cf..e93aa541d6b 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -41,9 +41,140 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static struct wl_cursor_theme *cursor_theme = NULL;
+
 static HCURSOR last_cursor;
 static HCURSOR invalid_cursor;
 
+/* Mapping between Windows cursors and native Wayland cursors
+ *
+ * Note that we have multiple possible names for each Wayland cursor. This
+ * happens because the names for each cursor may vary across different themes.
+ *
+ * This table was created based on the docs below.
+ *
+ * https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursora
+ * https://bugs.kde.org/attachment.cgi?id=67313
+ */
+static const char *idc_appstarting[] = {"half-busy", "progress", "left_ptr_watch",
+                                        "00000000000000020006000e7e9ffc3f",
+                                        "08e8e1c95fe2fc01f976f1e063a24ccd",
+                                        "3ecb610c1bf2410f44200f48c40d3599",
+                                        "9116a3ea924ed2162ecab71ba103b17f"};
+static const char *idc_arrow[] = {"default", "left_ptr",
+                                  "top_left_arrow", "left-arrow"};
+static const char *idc_cross[] = {"crosshair"};
+static const char *idc_hand[] = {"pointing_hand", "pointer", "hand", "hand2"};
+static const char *idc_help[] = {"help", "question_arrow", "whats_this",
+                                 "5c6cd98b3f3ebcb1f9c7f1c204630408",
+                                 "d9ce0ab605698f320427677b458ad60b"};
+static const char *idc_ibeam[] = {"text", "ibeam", "xterm"};
+static const char *idc_icon[] = {"icon"};
+static const char *idc_no[] = {"forbidden", "not-allowed"};
+static const char *idc_pen[] = {"pencil"};
+static const char *idc_sizeall[] = {"size_all"};
+static const char *idc_sizenesw[] = {"nesw-resize", "size_bdiag",
+                                     "50585d75b494802d0151028115016902",
+                                     "fcf1c3c7cd4491d801f1e1c78f100000"};
+static const char *idc_sizens[] = {"ns-resize", "size_ver", "v_double_arrow",
+                                   "00008160000006810000408080010102"};
+static const char *idc_sizenwse[] = {"nwse-resize", "size_fdiag",
+                                     "38c5dff7c7b8962045400281044508d2",
+                                     "c7088f0f3e6c8088236ef8e1e3e70000"};
+static const char *idc_sizewe[] = {"ew-resize", "size_hor", "h_double_arrow",
+                                   "028006030e0e7ebffc7f7070c0600140"};
+static const char *idc_uparrow[] = {"up_arrow"};
+static const char *idc_wait[] = {"wait", "watch",
+                                 "0426c94ea35c87780ff01dc239897213"};
+
+static struct wl_cursor *_wl_cursor_from_wine_cursor(struct wl_cursor_theme *wl_cursor_theme,
+                                                     unsigned long int wine_cursor_enum)
+{
+    unsigned int i, count;
+    static const char **cursors;
+    struct wl_cursor *cursor;
+
+    switch(wine_cursor_enum)
+    {
+        case IDC_APPSTARTING:
+            cursors = idc_appstarting;
+            count = ARRAY_SIZE(idc_appstarting);
+            break;
+        case IDC_ARROW:
+            cursors = idc_arrow;
+            count = ARRAY_SIZE(idc_arrow);
+            break;
+        case IDC_CROSS:
+            cursors = idc_cross;
+            count = ARRAY_SIZE(idc_cross);
+            break;
+        case IDC_HAND:
+            cursors = idc_hand;
+            count = ARRAY_SIZE(idc_hand);
+            break;
+        case IDC_HELP:
+            cursors = idc_help;
+            count = ARRAY_SIZE(idc_help);
+            break;
+        case IDC_IBEAM:
+            cursors = idc_ibeam;
+            count = ARRAY_SIZE(idc_ibeam);
+            break;
+        case IDC_ICON:
+            cursors = idc_icon;
+            count = ARRAY_SIZE(idc_icon);
+            break;
+        case IDC_NO:
+            cursors = idc_no;
+            count = ARRAY_SIZE(idc_no);
+            break;
+        case IDC_PEN:
+            cursors = idc_pen;
+            count = ARRAY_SIZE(idc_pen);
+            break;
+        case IDC_SIZE:
+        case IDC_SIZEALL:
+            cursors = idc_sizeall;
+            count = ARRAY_SIZE(idc_sizeall);
+            break;
+        case IDC_SIZENESW:
+            cursors = idc_sizenesw;
+            count = ARRAY_SIZE(idc_sizenesw);
+            break;
+        case IDC_SIZENS:
+            cursors = idc_sizens;
+            count = ARRAY_SIZE(idc_sizens);
+            break;
+        case IDC_SIZENWSE:
+            cursors = idc_sizenwse;
+            count = ARRAY_SIZE(idc_sizenwse);
+            break;
+        case IDC_SIZEWE:
+            cursors = idc_sizewe;
+            count = ARRAY_SIZE(idc_sizewe);
+            break;
+        case IDC_UPARROW:
+            cursors = idc_uparrow;
+            count = ARRAY_SIZE(idc_uparrow);
+            break;
+        case IDC_WAIT:
+            cursors = idc_wait;
+            count = ARRAY_SIZE(idc_wait);
+            break;
+        default:
+            return NULL;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        cursor = wl_cursor_theme_get_cursor(wl_cursor_theme, cursors[i]);
+        if (cursor)
+            return cursor;
+    }
+
+    return NULL;
+}
+
 /***********************************************************************
  *           get_icon_info
  *
@@ -199,58 +330,199 @@ failed:
     return NULL;
 }
 
-static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
-                                                        HCURSOR handle)
+/***********************************************************************
+ *           get_wine_cursor_size
+ *
+ * We use the Wine cursor IDC_ARROW to compute the size that we should use in
+ * the Wayland native cursors. The bitmap usually does not have the same
+ * dimensions of the icon, as it uses a margin. So we take the IDC_ARROW and
+ * compute its height.
+ */
+static int get_wine_cursor_size(struct wayland *wayland)
 {
+    HCURSOR handle = NULL;
     ICONINFOEXW info = { 0 };
-    struct wayland_cursor *wayland_cursor = NULL;
     struct wayland_shm_buffer *shm_buffer = NULL;
+    unsigned int *pixels, *row, p, x, y;
+    int first_non_empty_line = -1, last_non_empty_line = -1;
 
-    if (!handle) return NULL;
-
-    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
-    if (!wayland_cursor) goto out;
+    handle = LoadImageW(0, (const WCHAR *)IDC_ARROW, IMAGE_CURSOR, 0, 0,
+                        LR_SHARED | LR_DEFAULTSIZE);
+    if (!handle)
+        goto out;
 
-    if (!get_icon_info(handle, &info)) goto out;
+    if (!get_icon_info(handle, &info))
+        goto out;
 
     if (info.hbmColor)
     {
         HDC hdc = NtGdiCreateCompatibleDC(0);
-        shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+        shm_buffer = create_color_cursor_buffer(wayland, hdc,
                                                 info.hbmColor, info.hbmMask);
         NtGdiDeleteObjectApp(hdc);
     }
     else
     {
-        shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+        shm_buffer = create_mono_cursor_buffer(wayland, info.hbmMask);
     }
 
-    if (!shm_buffer) goto out;
+    if (!shm_buffer)
+        goto out;
 
-    wayland_cursor->width = shm_buffer->width;
-    wayland_cursor->height = shm_buffer->height;
-    wayland_cursor->wl_buffer =
-        wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+    pixels = (unsigned int *) shm_buffer->map_data;
 
-    /* make sure hotspot is valid */
-    if (info.xHotspot >= wayland_cursor->width ||
-        info.yHotspot >= wayland_cursor->height)
+    /* Compute the height of the IDC_ARROW */
+    for (y = 0; y < shm_buffer->height; y++)
     {
-        info.xHotspot = wayland_cursor->width / 2;
-        info.yHotspot = wayland_cursor->height / 2;
+        row = (unsigned int *)((unsigned char *)pixels + y * shm_buffer->stride);
+        for (x = 0; x < shm_buffer->width; x++)
+        {
+            p = row[x];
+            /* alpha 0 means fully transparent, so no content in the
+             * pixel - any other pixel we consider content */
+            if ((p & 0xff000000) == 0)
+                continue;
+            /* it's the first time that we find a content pixel, so we set
+             * the first non empty line variable accordingly */
+            if (first_non_empty_line == -1)
+                first_non_empty_line = y;
+            /* we found a content pixel in a line, so update the latest line
+             * that does have content */
+            last_non_empty_line = y;
+            /* we don't care about the other pixels of the line if we have
+             * already found a content pixel on it */
+            break;
+        }
     }
 
-    if (pointer->focused_surface)
+out:
+    if (handle) NtUserDestroyCursor(handle, 0);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (shm_buffer) wayland_shm_buffer_destroy(shm_buffer);
+
+    if (first_non_empty_line == -1 || last_non_empty_line == -1)
+        return -1;
+
+    return (last_non_empty_line - first_non_empty_line + 1);
+}
+
+void wayland_cursor_theme_init(struct wayland *wayland)
+{
+    char *theme;
+    int size;
+
+    if (!wayland->wl_shm)
+        return;
+
+    size = get_wine_cursor_size(wayland);
+    if (size <= 0)
+       return;
+
+    /* Some compositors set this env var, others don't. But that's fine, if we
+     * call wl_cursor_theme_load() with theme == NULL it will fallback and try
+     * to load the default system theme. */
+    theme = getenv("XCURSOR_THEME");
+
+    cursor_theme = wl_cursor_theme_load(theme, size, wayland->wl_shm);
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info = { 0 };
+    struct wayland_cursor *wayland_cursor = NULL;
+    struct wayland_shm_buffer *shm_buffer = NULL;
+
+    if (!handle) return NULL;
+
+    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto out;
+
+    if (!get_icon_info(handle, &info)) goto out;
+
+    /* First try to get the native Wayland cursor (if the config option is set
+     * and the per-process Wayland instance was able to load the theme) */
+    if (option_use_system_cursors && cursor_theme)
     {
-        wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
-                                                 info.xHotspot, info.yHotspot,
-                                                 &wayland_cursor->hotspot_x,
-                                                 &wayland_cursor->hotspot_y);
+        struct wl_cursor_image *wl_cursor_image;
+        struct wl_cursor *wl_cursor;
+
+        wayland_cursor->owns_wl_buffer = FALSE;
+        wl_cursor = _wl_cursor_from_wine_cursor(cursor_theme, MAKEINTRESOURCE(info.wResID));
+        if (wl_cursor && wl_cursor->image_count > 0)
+        {
+            /* TODO: add animated cursor support
+             * cursor->images[i] for i > 0 is only used by animations. */
+            wl_cursor_image = wl_cursor->images[0];
+            wayland_cursor->wl_buffer = wl_cursor_image_get_buffer(wl_cursor_image);
+            if (wayland_cursor->wl_buffer)
+            {
+                wayland_cursor->width = wl_cursor_image->width;
+                wayland_cursor->height = wl_cursor_image->height;
+
+                if (pointer->focused_surface)
+                {
+                    wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                             wl_cursor_image->hotspot_x,
+                                                             wl_cursor_image->hotspot_y,
+                                                             &wayland_cursor->hotspot_x,
+                                                             &wayland_cursor->hotspot_y);
+                }
+                else
+                {
+                    wayland_cursor->hotspot_x = wl_cursor_image->hotspot_x;
+                    wayland_cursor->hotspot_y = wl_cursor_image->hotspot_y;
+                }
+            }
+        }
     }
-    else
+
+    /* If we couldn't get native Wayland cursor (or we didn't even try,
+     * because the config to use it was not set), we copy the Wine cursor
+     * content to a wl_buffer */
+    if (!wayland_cursor->wl_buffer)
     {
-        wayland_cursor->hotspot_x = info.xHotspot;
-        wayland_cursor->hotspot_y = info.yHotspot;
+        wayland_cursor->owns_wl_buffer = TRUE;
+        if (info.hbmColor)
+        {
+            HDC hdc = NtGdiCreateCompatibleDC(0);
+            shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+                                                    info.hbmColor, info.hbmMask);
+            NtGdiDeleteObjectApp(hdc);
+        }
+        else
+        {
+            shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+        }
+
+        if (!shm_buffer) goto out;
+
+        wayland_cursor->width = shm_buffer->width;
+        wayland_cursor->height = shm_buffer->height;
+        wayland_cursor->wl_buffer =
+            wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+
+        /* make sure hotspot is valid */
+        if (info.xHotspot >= wayland_cursor->width ||
+            info.yHotspot >= wayland_cursor->height)
+        {
+            info.xHotspot = wayland_cursor->width / 2;
+            info.yHotspot = wayland_cursor->height / 2;
+        }
+
+        if (pointer->focused_surface)
+        {
+            wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                    info.xHotspot, info.yHotspot,
+                                                    &wayland_cursor->hotspot_x,
+                                                    &wayland_cursor->hotspot_y);
+        }
+        else
+        {
+            wayland_cursor->hotspot_x = info.xHotspot;
+            wayland_cursor->hotspot_y = info.yHotspot;
+        }
     }
 
 out:
@@ -275,7 +547,13 @@ void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
         return;
 
     if (wayland_cursor->wl_buffer)
-        wl_buffer_destroy(wayland_cursor->wl_buffer);
+    {
+        /* When using Wayland native cursors, we get the cursor wl_buffer from
+         * using wl_cursor_image_get_buffer(). In such case, the compositor owns
+         * the wl_buffer instead of us. So we should not destroy it. */
+        if (wayland_cursor->owns_wl_buffer)
+            wl_buffer_destroy(wayland_cursor->wl_buffer);
+    }
 
     free(wayland_cursor);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index bd4d9fa0726..a3a89d54b09 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <pthread.h>
 #include <stdarg.h>
 #include <wayland-client.h>
+#include <wayland-cursor.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -45,6 +46,7 @@
 
 extern char *process_name DECLSPEC_HIDDEN;
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
+extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
 /**********************************************************************
   *          Internal messages and data
@@ -88,6 +90,7 @@ struct wayland_mutex
 
 struct wayland_cursor
 {
+    BOOL owns_wl_buffer;
     struct wl_buffer *wl_buffer;
     int width;
     int height;
@@ -372,6 +375,7 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
                           struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
 void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
 void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
+void wayland_cursor_theme_init(struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
                                               HCURSOR handle) DECLSPEC_HIDDEN;
 BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
diff --git a/include/config.h.in b/include/config.h.in
index 670ea0210e7..b70689b107d 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -691,6 +691,9 @@
 /* Define to 1 if you have the <wayland-client.h> header file. */
 #undef HAVE_WAYLAND_CLIENT_H
 
+/* Define to 1 if you have the <wayland-cursor.h> header file. */
+#undef HAVE_WAYLAND_CURSOR_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.39.0.rc2

From 7cfb21c326bd96d9e2d69db4871edd5784a96550 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 14 Apr 2022 11:41:31 +0300
Subject: [PATCH 050/202] winewayland.drv: Add
 wayland_surface_from_hwnd_lock/unlock helpers.

Add helpers for safely getting the wayland_surface associated with a
HWND.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 8c6f0b456a4..2af2821fd1f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -157,6 +157,31 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
     return data;
 }
 
+/***********************************************************************
+ *           wayland_surface_for_hwnd_lock
+ *
+ *  Gets the wayland surface for HWND while locking the private window data.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+
+    if (data && data->wayland_surface)
+        return data->wayland_surface;
+
+    wayland_win_data_release(data);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlock
+ */
+static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+{
+    if (surface) wayland_mutex_unlock(&win_data_mutex);
+}
+
 /***********************************************************************
  *           wayland_surface_for_hwnd_unlocked
  *
-- 
2.39.0.rc2

From cec24c3785137a45d5ecaa43fe093f9d02e5ee8d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 22 Nov 2022 12:11:39 +0200
Subject: [PATCH 051/202] winewayland.drv: Introduce mechanism to schedule
 thread callbacks

Introduce an internal driver mechanism to schedule and dispatch thread
callbacks, to be run after the specified time has elapsed.

Note that the current mechanism doesn't wake up threads that are
currently blocked waiting, in order to service any triggered callbacks.
This deficiency will be fixed in the next commit.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 147 ++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |   6 ++
 2 files changed, 153 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9f6ef5b6cde..07d77cf78df 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -34,6 +34,7 @@
 #include <fcntl.h>
 #include <poll.h>
 #include <stdlib.h>
+#include <sys/timerfd.h>
 #include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -51,6 +52,15 @@ static struct wayland_mutex thread_wayland_mutex =
 
 static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
 
+struct wayland_callback
+{
+   struct wl_list link;
+   uintptr_t id;
+   wayland_callback_func func;
+   void *data;
+   uint64_t target_time_ms;
+};
+
 /**********************************************************************
  *          xdg_wm_base handling
  */
@@ -239,6 +249,7 @@ BOOL wayland_init(struct wayland *wayland)
 
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->detached_shm_buffer_list);
+    wl_list_init(&wayland->callback_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -289,6 +300,7 @@ void wayland_deinit(struct wayland *wayland)
 {
     struct wayland_output *output, *output_tmp;
     struct wayland_shm_buffer *shm_buffer, *shm_buffer_tmp;
+    struct wayland_callback *callback, *callback_tmp;
 
     TRACE("%p\n", wayland);
 
@@ -296,6 +308,12 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     wayland_mutex_unlock(&thread_wayland_mutex);
 
+    wl_list_for_each_safe(callback, callback_tmp, &wayland->callback_list, link)
+    {
+        wl_list_remove(&callback->link);
+        free(callback);
+    }
+
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
     if (wayland->event_notification_pipe[1] >= 0)
@@ -558,6 +576,133 @@ BOOL wayland_read_events_and_dispatch_process(void)
     return (wayland_dispatch_queue(process_wayland->wl_event_queue, -1) != -1);
 }
 
+static void wayland_add_callback(struct wayland *wayland, struct wayland_callback *cb)
+{
+    struct wayland_callback *cb_iter;
+
+    /* Keep callbacks ordered by target time and previous scheduling order */
+    wl_list_for_each(cb_iter, &wayland->callback_list, link)
+    {
+        if (cb_iter->target_time_ms > cb->target_time_ms)
+        {
+            wl_list_insert(cb_iter->link.prev, &cb->link);
+            break;
+        }
+    }
+
+    if (wl_list_empty(&cb->link))
+        wl_list_insert(wayland->callback_list.prev, &cb->link);
+}
+
+/**********************************************************************
+ *          wayland_schedule_thread_callback
+ *
+ * Schedule a callback to be run in the context of the current thread after
+ * the specified delay. If there is an existing callback with the specified
+ * id, it is replaced with the new one.
+ */
+void wayland_schedule_thread_callback(uintptr_t id, int delay_ms,
+                                      void (*callback)(void *), void *data)
+{
+    struct wayland *wayland = thread_wayland();
+    struct timespec ts;
+    struct wayland_callback *cb_iter, *cb = NULL;
+    uint64_t target_ms;
+
+    if (!wayland) return;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    target_ms = ts.tv_sec * 1000 + (ts.tv_nsec / 1000000) + delay_ms;
+
+    TRACE("id=%p delay_ms=%d target_ms=%llu callback=%p data=%p\n",
+          (void*)id, delay_ms, (long long unsigned)target_ms, callback, data);
+
+    /* If we have a callback with the same id, we remove it from the list so
+     * that it can be re-added at the appropriate position later in this
+     * function. */
+    wl_list_for_each(cb_iter, &wayland->callback_list, link)
+    {
+        if (cb_iter->id == id)
+        {
+            wl_list_remove(&cb_iter->link);
+            cb = cb_iter;
+            break;
+        }
+    }
+
+    if (!cb) cb = calloc(1, sizeof(*cb));
+    cb->id = id;
+    cb->func = callback;
+    cb->data = data;
+    cb->target_time_ms = target_ms;
+    wl_list_init(&cb->link);
+
+    wayland_add_callback(wayland, cb);
+}
+
+/**********************************************************************
+ *          wayland_cancel_thread_callback
+ *
+ * Cancel a callback previously scheduled in this the current thread.
+ */
+void wayland_cancel_thread_callback(uintptr_t id)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_callback *cb;
+
+    if (!wayland) return;
+
+    TRACE("id=%p\n", (void*)id);
+
+    wl_list_for_each(cb, &wayland->callback_list, link)
+    {
+        if (cb->id == id)
+        {
+            wl_list_remove(&cb->link);
+            free(cb);
+            break;
+        }
+    }
+}
+
+static void wayland_dispatch_thread_callbacks(struct wayland *wayland)
+{
+    struct wayland_callback *cb, *tmp;
+    struct wl_list tmp_list;
+    uint64_t time_now_ms;
+    struct timespec ts;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    time_now_ms = ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
+
+    /* Invoking a callback may result in scheduling additional callbacks.
+     * This can corrupt our callback list iteration, so we first move
+     * the current callbacks to a separate list and iterate over that. */
+    wl_list_init(&tmp_list);
+    wl_list_insert_list(&tmp_list, &wayland->callback_list);
+    wl_list_init(&wayland->callback_list);
+
+    /* Call all triggered callbacks and free them. */
+    wl_list_for_each_safe(cb, tmp, &tmp_list, link)
+    {
+        if (time_now_ms < cb->target_time_ms) break;
+        TRACE("invoking callback id=%p func=%p target_time_ms=%llu\n",
+              (void*)cb->id, cb->func, (long long unsigned)cb->target_time_ms);
+        cb->func(cb->data);
+        wl_list_remove(&cb->link);
+        free(cb);
+    }
+
+    /* Add untriggered callbacks back to the main list (which may now
+     * have new callbacks added from a callback invocation above). */
+    wl_list_for_each_safe(cb, tmp, &tmp_list, link)
+    {
+        wl_list_remove(&cb->link);
+        wl_list_init(&cb->link);
+        wayland_add_callback(wayland, cb);
+    }
+}
+
 static int wayland_dispatch_thread_pending(struct wayland *wayland)
 {
     char buf[64];
@@ -595,6 +740,8 @@ static BOOL wayland_process_thread_events(struct wayland *wayland, DWORD mask)
 
     wayland->last_dispatch_mask = 0;
 
+    wayland_dispatch_thread_callbacks(wayland);
+
     dispatched = wayland_dispatch_thread_pending(wayland);
     if (dispatched)
         wayland->last_dispatch_mask |= QS_SENDMESSAGE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a3a89d54b09..af5b5c876b9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -127,6 +127,7 @@ struct wayland
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
+    struct wl_list callback_list;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
@@ -219,6 +220,8 @@ struct wayland_buffer_queue
     HRGN damage_region;
 };
 
+typedef void (*wayland_callback_func)(void *data);
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -288,6 +291,9 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
 BOOL wayland_read_events_and_dispatch_process(void) DECLSPEC_HIDDEN;
+void wayland_schedule_thread_callback(uintptr_t id, int delay_ms,
+                                      wayland_callback_func func, void *data) DECLSPEC_HIDDEN;
+void wayland_cancel_thread_callback(uintptr_t id) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland surface
-- 
2.39.0.rc2

From 2236b63d76ea04a9f2dcb0a98206a05ab6d43125 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 22 Nov 2022 12:39:32 +0200
Subject: [PATCH 052/202] winewayland.drv: Ensure threads wake up to service
 triggered callbacks

Use the same mechanism we use to notify thread about incoming Wayland
events, to also notify about triggered callbacks.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c | 170 +++++++++++++++++++++++++++++----
 1 file changed, 153 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 07d77cf78df..b07e38496e7 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -61,6 +61,99 @@ struct wayland_callback
    uint64_t target_time_ms;
 };
 
+struct wayland_wakeup
+{
+    struct wl_list link;
+    uintptr_t id;
+    uint64_t target_time_ms;
+};
+static struct wl_list wayland_wakeup_list = {&wayland_wakeup_list, &wayland_wakeup_list};
+static int wayland_wakeup_timerfd = -1;
+
+/**********************************************************************
+ *          Wakeup handling
+ */
+
+static void wayland_add_wakeup_for_callback(struct wayland_callback *cb)
+{
+    struct wayland_wakeup *wakeup;
+
+    wakeup = calloc(1, sizeof(*wakeup));
+    wakeup->target_time_ms = cb->target_time_ms;
+    wakeup->id = cb->id;
+
+    wayland_mutex_lock(&process_wayland_mutex);
+    wl_list_insert(&wayland_wakeup_list, &wakeup->link);
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_remove_wakeup(uintptr_t id)
+{
+    struct wayland_wakeup *wakeup;
+
+    wayland_mutex_lock(&process_wayland_mutex);
+
+    wl_list_for_each(wakeup, &wayland_wakeup_list, link)
+    {
+        if (wakeup->id == id)
+        {
+            wl_list_remove(&wakeup->link);
+            free(wakeup);
+            break;
+        }
+    }
+
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_remove_past_wakeups(void)
+{
+    struct wayland_wakeup *wakeup, *tmp;
+    uint64_t time_now_ms;
+    struct timespec ts;
+
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    time_now_ms = ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
+
+    wayland_mutex_lock(&process_wayland_mutex);
+
+    wl_list_for_each_safe(wakeup, tmp, &wayland_wakeup_list, link)
+    {
+        if (wakeup->target_time_ms <= time_now_ms)
+        {
+            wl_list_remove(&wakeup->link);
+            free(wakeup);
+        }
+    }
+
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_reschedule_wakeup_timerfd(void)
+{
+    uint64_t min = 0;
+    struct itimerspec its = {0};
+    struct wayland_wakeup *wakeup;
+
+    wayland_mutex_lock(&process_wayland_mutex);
+
+    wl_list_for_each(wakeup, &wayland_wakeup_list, link)
+    {
+        uint64_t wakeup_time = wakeup->target_time_ms;
+        if (min == 0 || wakeup_time < min)
+            min = wakeup_time;
+    }
+
+    TRACE("time=%llu\n", (long long unsigned)min);
+
+    its.it_value.tv_sec = min / 1000;
+    its.it_value.tv_nsec = (min % 1000) * 1000000;
+
+    timerfd_settime(wayland_wakeup_timerfd, TFD_TIMER_ABSTIME, &its, NULL);
+
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
 /**********************************************************************
  *          xdg_wm_base handling
  */
@@ -310,9 +403,11 @@ void wayland_deinit(struct wayland *wayland)
 
     wl_list_for_each_safe(callback, callback_tmp, &wayland->callback_list, link)
     {
+        wayland_remove_wakeup(callback->id);
         wl_list_remove(&callback->link);
         free(callback);
     }
+    wayland_reschedule_wakeup_timerfd();
 
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
@@ -374,6 +469,10 @@ BOOL wayland_process_init(void)
     if (!process_wayland)
         return FALSE;
 
+    wayland_wakeup_timerfd = timerfd_create(CLOCK_MONOTONIC, 0);
+    if (!wayland_wakeup_timerfd)
+        return FALSE;
+
     return wayland_init(process_wayland);
 }
 
@@ -478,13 +577,17 @@ void wayland_notify_wine_monitor_change(void)
  */
 int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
 {
-    struct pollfd pfd = {0};
+    /* We need to poll up to two fds and notify threads of potential events:
+     * 1. wl_display fd: events from the compositor
+     * 2. wayland_wakeup_timerfd (per-process instance only): internally
+     *    scheduled callbacks */
+    struct pollfd pfd[2] = {0};
     BOOL is_process_queue = queue == process_wayland->wl_event_queue;
     int ret;
 
     TRACE("waiting for events with timeout=%d ...\n", timeout_ms);
 
-    pfd.fd = wl_display_get_fd(process_wl_display);
+    pfd[0].fd = wl_display_get_fd(process_wl_display);
 
     if (wl_display_prepare_read_queue(process_wl_display, queue) == -1)
     {
@@ -503,8 +606,8 @@ int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
         if (ret != -1 || errno != EAGAIN)
             break;
 
-        pfd.events = POLLOUT;
-        while ((ret = poll(&pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+        pfd[0].events = POLLOUT;
+        while ((ret = poll(pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
 
         if (ret == -1)
         {
@@ -520,36 +623,67 @@ int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
         return -1;
     }
 
-    pfd.events = POLLIN;
-    while ((ret = poll(&pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+    if (is_process_queue)
+    {
+        pfd[1].events = POLLIN;
+        pfd[1].fd = wayland_wakeup_timerfd;
+    }
+
+    pfd[0].events = POLLIN;
+    pfd[0].revents = 0;
+    while ((ret = poll(pfd, pfd[1].events ? 2 : 1, timeout_ms)) == -1 && errno == EINTR)
+        continue;
+
+    if (!(pfd[0].revents & POLLIN))
+        wl_display_cancel_read(process_wl_display);
 
     if (ret == 0)
     {
         TRACE("... done => 0 events (timeout)\n");
-        wl_display_cancel_read(process_wl_display);
         return 0;
     }
 
     if (ret == -1)
     {
         TRACE("... failed poll errno=%d\n", errno);
-        wl_display_cancel_read(process_wl_display);
         return -1;
     }
 
-    if (wl_display_read_events(process_wl_display) == -1)
+    /* Handle wl_display fd input. */
+    if (pfd[0].revents & POLLIN)
     {
-        TRACE("... failed wl_display_read_events errno=%d\n", errno);
-        return -1;
+        if (wl_display_read_events(process_wl_display) == -1)
+        {
+            TRACE("... failed wl_display_read_events errno=%d\n", errno);
+            return -1;
+        }
+        if (is_process_queue) wayland_process_acquire();
+        ret = wl_display_dispatch_queue_pending(process_wl_display, queue);
+        if (is_process_queue) wayland_process_release();
+        if (ret == -1)
+        {
+            TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+            return -1;
+        }
     }
 
-    if (is_process_queue) wayland_process_acquire();
-    ret = wl_display_dispatch_queue_pending(process_wl_display, queue);
-    if (is_process_queue) wayland_process_release();
-    if (ret == -1)
+    /* Handle timerfd input. */
+    if (pfd[1].revents & POLLIN)
     {
-        TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
-        return -1;
+        uint64_t num_expirations;
+        int nread;
+        while ((nread = read(pfd[1].fd, &num_expirations, sizeof(uint64_t))) == -1 &&
+                errno == EINTR)
+        {
+            continue;
+        }
+        if (nread < sizeof(uint64_t))
+        {
+            TRACE("... failed reading timerfd errno=%d\n", errno);
+            return -1;
+        }
+        wayland_remove_past_wakeups();
+        wayland_reschedule_wakeup_timerfd();
     }
 
     /* We may have read and queued events in queues other than the specified
@@ -638,6 +772,8 @@ void wayland_schedule_thread_callback(uintptr_t id, int delay_ms,
     wl_list_init(&cb->link);
 
     wayland_add_callback(wayland, cb);
+    wayland_add_wakeup_for_callback(cb);
+    wayland_reschedule_wakeup_timerfd();
 }
 
 /**********************************************************************
-- 
2.39.0.rc2

From 7f1d01209701048989e1ffc7313eca3787e10f35 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:24:54 +0300
Subject: [PATCH 053/202] winewayland.drv: Basic handling of Wayland keyboard
 events.

Handle Wayland keyboard events and translate them to Windows events,
currently using a hardcoded US key mapping.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                     |  85 +++-
 configure.ac                                  |   6 +-
 dlls/winewayland.drv/Makefile.in              |   5 +-
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_keyboard.c       | 427 ++++++++++++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 287 ++++++++++++
 dlls/winewayland.drv/wayland_surface.c        |   4 +
 dlls/winewayland.drv/waylanddrv.h             |  30 ++
 dlls/winewayland.drv/window.c                 |   9 +
 include/config.h.in                           |   3 +
 10 files changed, 864 insertions(+), 4 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard.c
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.h

diff --git a/configure b/configure
index 471c222034f..c9db642a0e6 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+XKBCOMMON_LIBS
+XKBCOMMON_CFLAGS
 WAYLAND_CURSOR_LIBS
 WAYLAND_CURSOR_CFLAGS
 WAYLAND_SCANNER
@@ -1750,6 +1752,8 @@ WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_PROTOCOLS_LIBS
 WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2561,6 +2565,10 @@ Some influential environment variables:
               C compiler flags for wayland-cursor, overriding pkg-config
   WAYLAND_CURSOR_LIBS
               Linker flags for wayland-cursor, overriding pkg-config
+  XKBCOMMON_CFLAGS
+              C compiler flags for xkbcommon, overriding pkg-config
+  XKBCOMMON_LIBS
+              Linker flags for xkbcommon, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -16113,13 +16121,86 @@ else $as_nop
   WAYLAND_CURSOR_LIBS=""
 fi
 
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${XKBCOMMON_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_CFLAGS=`$PKG_CONFIG --cflags xkbcommon 2>/dev/null`
+fi
+fi
+
+if ${XKBCOMMON_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_LIBS=`$PKG_CONFIG --libs xkbcommon 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon cflags: $XKBCOMMON_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon libs: $XKBCOMMON_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XKBCOMMON_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "xkbcommon/xkbcommon.h" "ac_cv_header_xkbcommon_xkbcommon_h" "$ac_includes_default"
+if test "x$ac_cv_header_xkbcommon_xkbcommon_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_XKBCOMMON_XKBCOMMON_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xkb_context_new in -lxkbcommon" >&5
+printf %s "checking for xkb_context_new in -lxkbcommon... " >&6; }
+if test ${ac_cv_lib_xkbcommon_xkb_context_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxkbcommon $XKBCOMMON_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char xkb_context_new ();
+int
+main (void)
+{
+return xkb_context_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_xkbcommon_xkb_context_new=yes
+else $as_nop
+  ac_cv_lib_xkbcommon_xkb_context_new=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xkbcommon_xkb_context_new" >&5
+printf "%s\n" "$ac_cv_lib_xkbcommon_xkb_context_new" >&6; }
+if test "x$ac_cv_lib_xkbcommon_xkb_context_new" = xyes
+then :
+  :
+else $as_nop
+  XKBCOMMON_LIBS=""
+fi
+
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
 if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
                            test -z "$WAYLAND_SCANNER" ||
-                           test -z "$WAYLAND_CURSOR_LIBS"
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS"
 then :
   case "x$with_wayland" in
   x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
@@ -23494,6 +23575,8 @@ WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
 WAYLAND_SCANNER = $WAYLAND_SCANNER
 WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS = $XKBCOMMON_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index b5fe7581b7f..b633c2a9e53 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1423,11 +1423,15 @@ then
         [AC_CHECK_HEADERS([wayland-cursor.h])
          AC_CHECK_LIB(wayland-cursor,wl_cursor_theme_load,[:],
                       [WAYLAND_CURSOR_LIBS=""],[$WAYLAND_CURSOR_LIBS])])
+    WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
+        [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
+         AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
                            test -z "$WAYLAND_SCANNER" ||
-                           test -z "$WAYLAND_CURSOR_LIBS"],
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d76fae2024a..03427859dd3 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,8 +1,8 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS)
+UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
-            $(PTHREAD_LIBS)
+            $(XKBCOMMON_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
 	display.c \
@@ -13,6 +13,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_keyboard.c \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index b07e38496e7..7377f4e7b50 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -184,6 +184,15 @@ static void seat_handle_capabilities(void *data, struct wl_seat *seat,
     {
         wayland_pointer_deinit(&wayland->pointer);
     }
+
+    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_init(&wayland->keyboard, wayland, wl_seat_get_keyboard(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_deinit(&wayland->keyboard);
+    }
 }
 
 static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
@@ -424,6 +433,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->pointer.wl_pointer)
         wayland_pointer_deinit(&wayland->pointer);
 
+    if (wayland->keyboard.wl_keyboard)
+        wayland_keyboard_deinit(&wayland->keyboard);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
new file mode 100644
index 00000000000..4a858f51c9f
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -0,0 +1,427 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013 Alexandre Julliard
+ * Copyright 2015 Josh DuBois for CodeWeavers Inc.
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+#include <linux/input.h>
+#include <unistd.h>
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
+                                      xkb_keycode_t xkb_keycode)
+{
+    /* Use linux input keycode as scan code for now. */
+    return xkb_keycode - 8;
+}
+
+static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                 xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
+           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+}
+
+/* xkb keycodes are offset by 8 from linux input keycodes. */
+static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
+{
+    return key + 8;
+}
+
+static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
+{
+    INPUT input;
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input(hwnd, &input, NULL);
+}
+
+static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
+{
+    switch (xkb_keycode - 8)
+    {
+    case KEY_KP0: case KEY_KP1: case KEY_KP2: case KEY_KP3:
+    case KEY_KP4: case KEY_KP5: case KEY_KP6: case KEY_KP7:
+    case KEY_KP8: case KEY_KP9: case KEY_KPDOT:
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
+/* Get the vkey corresponding to an xkb keycode, potentially translating it to
+ * take into account the current keyboard state. */
+static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                          xkb_keycode_t xkb_keycode)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    if (_xkb_keycode_is_keypad_num(xkb_keycode) &&
+        xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                     XKB_STATE_MODS_EFFECTIVE))
+    {
+        switch (vkey)
+        {
+        case VK_INSERT: vkey = VK_NUMPAD0; break;
+        case VK_END: vkey = VK_NUMPAD1; break;
+        case VK_DOWN: vkey = VK_NUMPAD2; break;
+        case VK_NEXT: vkey = VK_NUMPAD3; break;
+        case VK_LEFT: vkey = VK_NUMPAD4; break;
+        case VK_CLEAR: vkey = VK_NUMPAD5; break;
+        case VK_RIGHT: vkey = VK_NUMPAD6; break;
+        case VK_HOME: vkey = VK_NUMPAD7; break;
+        case VK_UP: vkey = VK_NUMPAD8; break;
+        case VK_PRIOR: vkey = VK_NUMPAD9; break;
+        case VK_DELETE: vkey = VK_DECIMAL; break;
+        default: break;
+        }
+    }
+    else if (vkey == VK_PAUSE &&
+             xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                          XKB_MOD_NAME_CTRL,
+                                          XKB_STATE_MODS_EFFECTIVE))
+    {
+        vkey = VK_CANCEL;
+    }
+
+    return vkey;
+}
+
+static BOOL wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
+                                  uint32_t state, HWND hwnd)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+    UINT scan = _xkb_keycode_to_scancode(keyboard, xkb_keycode);
+    DWORD flags;
+
+    TRACE_(key)("xkb_keycode=%u vkey=0x%x scan=0x%x state=%d hwnd=%p\n",
+                xkb_keycode, vkey, scan, state, hwnd);
+
+    if (vkey == 0) return FALSE;
+
+    flags = 0;
+    if (state == WL_KEYBOARD_KEY_STATE_RELEASED) flags |= KEYEVENTF_KEYUP;
+    if (scan & 0xff00) flags |= KEYEVENTF_EXTENDEDKEY;
+
+    send_keyboard_input(hwnd, vkey, scan & 0xff, flags);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          Keyboard handling
+ */
+
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                                   uint32_t format, int fd, uint32_t size)
+{
+    close(fd);
+}
+
+static BOOL wayland_surface_for_window_is_mapped(HWND hwnd)
+{
+    DWORD_PTR res;
+
+    if (!send_message_timeout(hwnd, WM_WAYLAND_QUERY_SURFACE_MAPPED,
+                              0, 0, SMTO_BLOCK, 50, &res))
+    {
+        return FALSE;
+    }
+
+    return res;
+}
+
+static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                                  uint32_t serial, struct wl_surface *surface,
+                                  struct wl_array *keys)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since keyboard events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        HWND foreground = NtUserGetForegroundWindow();
+        BOOL foreground_is_visible;
+        BOOL foreground_is_mapped;
+
+        if (foreground == NtUserGetDesktopWindow()) foreground = NULL;
+        if (foreground)
+        {
+            foreground_is_visible =
+                !!(NtUserGetWindowLongW(foreground, GWL_STYLE) & WS_VISIBLE);
+            foreground_is_mapped = wayland_surface_for_window_is_mapped(foreground);
+        }
+        else
+        {
+            foreground_is_visible = FALSE;
+            foreground_is_mapped = FALSE;
+        }
+
+        TRACE("surface=%p hwnd=%p foreground=%p visible=%d mapped=%d\n",
+              wayland_surface, wayland_surface->hwnd, foreground,
+              foreground_is_visible, foreground_is_mapped);
+
+        wayland->keyboard.focused_surface = wayland_surface;
+        wayland->keyboard.enter_serial = serial;
+
+        /* Promote the just entered window to the foreground unless we have a
+         * existing visible foreground window that is not mapped from the
+         * Wayland perspective. In that case the surface may not have had the
+         * chance to acquire the keyboard focus and if we change the foreground
+         * window now, we may cause side effects, e.g., some fullscreen games
+         * minimize if they lose focus. To avoid such side effects, err on the
+         * side of maintaining the Wine foreground state, with the expectation
+         * that the current foreground window will eventually also gain the
+         * Wayland keyboard focus. */
+        if (!foreground || !foreground_is_visible || foreground_is_mapped)
+        {
+            struct wayland_surface *toplevel = wayland_surface;
+            while (toplevel->parent) toplevel = toplevel->parent;
+            NtUserSetForegroundWindow(toplevel->hwnd);
+        }
+    }
+}
+
+static void maybe_unset_from_foreground(void *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND hwnd = (HWND)data;
+
+    TRACE("wayland=%p hwnd=%p\n", wayland, hwnd);
+
+    /* If no enter events have arrived since the previous leave event,
+     * the loss of focus was likely not transient, so drop the foreground state.
+     * We only drop the foreground state if it's ours to drop, i.e., some
+     * other window hasn't become foreground in the meantime. */
+    if (!wayland->keyboard.focused_surface && NtUserGetForegroundWindow() == hwnd)
+        NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+}
+
+static void keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+        uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *focused_surface = wayland->keyboard.focused_surface;
+
+    if (focused_surface && focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n", focused_surface, focused_surface->hwnd);
+        wayland_cancel_thread_callback((uintptr_t)keyboard);
+        /* This leave event may not signify a real loss of focus for the
+         * window. Such a case occurs when the focus changes from the main
+         * surface to a subsurface. Don't be too eager to lose the foreground
+         * state in such cases, as some fullscreen applications may become
+         * minimized. Instead wait a bit in case other enter events targeting a
+         * (sub)surface of the same HWND arrive soon after. */
+        wayland_schedule_thread_callback((uintptr_t)&wayland->keyboard.focused_surface,
+                                         50, maybe_unset_from_foreground,
+                                         focused_surface->hwnd);
+        wayland->keyboard.focused_surface = NULL;
+        wayland->keyboard.enter_serial = 0;
+    }
+}
+
+static void repeat_key(void *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND hwnd = data;
+
+    if (wayland->keyboard.repeat_interval_ms > 0)
+    {
+        wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+
+        wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.last_pressed_key,
+                              WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
+
+        wayland_schedule_thread_callback((uintptr_t)wayland->keyboard.wl_keyboard,
+                                         wayland->keyboard.repeat_interval_ms,
+                                         repeat_key, hwnd);
+    }
+}
+
+static BOOL wayland_keyboard_is_modifier_key(struct wayland_keyboard *keyboard,
+                                             uint32_t key)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    return vkey == VK_CAPITAL || vkey == VK_LWIN || vkey == VK_RWIN ||
+           vkey == VK_NUMLOCK || vkey == VK_SCROLL ||
+           vkey == VK_LSHIFT || vkey == VK_RSHIFT ||
+           vkey == VK_LCONTROL || vkey == VK_RCONTROL ||
+           vkey == VK_LMENU || vkey == VK_RMENU;
+}
+
+static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->keyboard.focused_surface ?
+                        wayland->keyboard.focused_surface->hwnd : 0;
+    uintptr_t repeat_key_timer_id = (uintptr_t)keyboard;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
+
+    wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+
+    if (!wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd))
+        return;
+
+    /* Do not repeat modifier keys. */
+    if (wayland_keyboard_is_modifier_key(&wayland->keyboard, key))
+        return;
+
+    if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+    {
+        wayland->keyboard.last_pressed_key = key;
+        if (wayland->keyboard.repeat_interval_ms > 0)
+        {
+            wayland_schedule_thread_callback(repeat_key_timer_id,
+                                             wayland->keyboard.repeat_delay_ms,
+                                             repeat_key, focused_hwnd);
+        }
+    }
+    else if (key == wayland->keyboard.last_pressed_key)
+    {
+        wayland->keyboard.last_pressed_key = 0;
+        wayland_cancel_thread_callback(repeat_key_timer_id);
+    }
+}
+
+static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched, uint32_t mods_locked,
+                                      uint32_t group)
+{
+    struct wayland *wayland = data;
+
+    TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
+          mods_depressed, mods_latched, mods_locked, group);
+
+    if (!wayland->keyboard.xkb_state) return;
+
+    xkb_state_update_mask(wayland->keyboard.xkb_state,
+                          mods_depressed, mods_latched, mods_locked, 0, 0, group);
+
+    /* TODO: Sync wine modifier state with XKB modifier state. */
+}
+
+static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
+                                        int rate, int delay)
+{
+    struct wayland *wayland = data;
+
+    TRACE("rate=%d delay=%d\n", rate, delay);
+
+    /* Handle non-negative rate values, ignore invalid (negative) values.  A
+     * rate of 0 disables repeat. */
+    if (rate > 1000)
+        wayland->keyboard.repeat_interval_ms = 1;
+    else if (rate > 0)
+        wayland->keyboard.repeat_interval_ms = 1000 / rate;
+    else if (rate == 0)
+        wayland->keyboard.repeat_interval_ms = 0;
+
+    wayland->keyboard.repeat_delay_ms = delay;
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+/***********************************************************************
+ *           wayland_keyboard_init
+ */
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard)
+{
+    keyboard->wl_keyboard = wl_keyboard;
+    /* Some sensible default values for the repeat rate and delay. */
+    keyboard->repeat_interval_ms = 40;
+    keyboard->repeat_delay_ms = 400;
+    keyboard->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (!keyboard->xkb_context)
+    {
+        ERR("Failed to create XKB context\n");
+        return;
+    }
+
+    wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
+}
+
+/***********************************************************************
+ *           wayland_keyboard_deinit
+ */
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
+{
+    if (keyboard->wl_keyboard)
+        wl_keyboard_destroy(keyboard->wl_keyboard);
+
+    xkb_state_unref(keyboard->xkb_state);
+    xkb_context_unref(keyboard->xkb_context);
+
+    memset(keyboard, 0, sizeof(*keyboard));
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
new file mode 100644
index 00000000000..553264e22a4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -0,0 +1,287 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * This header file contains the tables used by keyboard_layout.c
+ * to perform layout mapping.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+#define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+
+static const UINT xkb_keycode_to_vkey_us[] =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,
+    0,                   /* KEY_RESERVED  0 */
+    VK_ESCAPE,           /* KEY_ESC   1 */
+    '1',                 /* KEY_1   2 */
+    '2',                 /* KEY_2   3 */
+    '3',                 /* KEY_3   4 */
+    '4',                 /* KEY_4   5 */
+    '5',                 /* KEY_5   6 */
+    '6',                 /* KEY_6   7 */
+    '7',                 /* KEY_7   8 */
+    '8',                 /* KEY_8   9 */
+    '9',                 /* KEY_9   10 */
+    '0',                 /* KEY_0   11 */
+    VK_OEM_MINUS,        /* KEY_MINUS  12 */
+    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
+    VK_BACK,             /* KEY_BACKSPACE 14 */
+    VK_TAB,              /* KEY_TAB   15 */
+    'Q',                 /* KEY_Q   16 */
+    'W',                 /* KEY_W   17 */
+    'E',                 /* KEY_E   18 */
+    'R',                 /* KEY_R   19 */
+    'T',                 /* KEY_T   20 */
+    'Y',                 /* KEY_Y   21 */
+    'U',                 /* KEY_U   22 */
+    'I',                 /* KEY_I   23 */
+    'O',                 /* KEY_O   24 */
+    'P',                 /* KEY_P   25 */
+    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
+    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
+    VK_RETURN,           /* KEY_ENTER  28 */
+    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
+    'A',                 /* KEY_A   30 */
+    'S',                 /* KEY_S   31 */
+    'D',                 /* KEY_D   32 */
+    'F',                 /* KEY_F   33 */
+    'G',                 /* KEY_G   34 */
+    'H',                 /* KEY_H   35 */
+    'J',                 /* KEY_J   36 */
+    'K',                 /* KEY_K   37 */
+    'L',                 /* KEY_L   38 */
+    VK_OEM_1,            /* KEY_SEMICOLON  39 */
+    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
+    VK_OEM_3,            /* KEY_GRAVE  41 */
+    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
+    VK_OEM_5,            /* KEY_BACKSLASH  43 */
+    'Z',                 /* KEY_Z   44 */
+    'X',                 /* KEY_X   45 */
+    'C',                 /* KEY_C   46 */
+    'V',                 /* KEY_V   47 */
+    'B',                 /* KEY_B   48 */
+    'N',                 /* KEY_N   49 */
+    'M',                 /* KEY_M   50 */
+    VK_OEM_COMMA,        /* KEY_COMMA  51 */
+    VK_OEM_PERIOD,       /* KEY_DOT   52 */
+    VK_OEM_2,            /* KEY_SLASH  53 */
+    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
+    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
+    VK_LMENU,            /* KEY_LEFTALT  56 */
+    VK_SPACE,            /* KEY_SPACE  57 */
+    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
+    VK_F1,               /* KEY_F1   59 */
+    VK_F2,               /* KEY_F2   60 */
+    VK_F3,               /* KEY_F3   61 */
+    VK_F4,               /* KEY_F4   62 */
+    VK_F5,               /* KEY_F5   63 */
+    VK_F6,               /* KEY_F6   64 */
+    VK_F7,               /* KEY_F7   65 */
+    VK_F8,               /* KEY_F8   66 */
+    VK_F9,               /* KEY_F9   67 */
+    VK_F10,              /* KEY_F10   68 */
+    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
+    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
+    VK_HOME,             /* KEY_KP7   71 */
+    VK_UP,               /* KEY_KP8   72 */
+    VK_PRIOR,            /* KEY_KP9   73 */
+    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
+    VK_LEFT,             /* KEY_KP4   75 */
+    VK_CLEAR,            /* KEY_KP5   76 */
+    VK_RIGHT,            /* KEY_KP6   77 */
+    VK_ADD,              /* KEY_KPPLUS  78 */
+    VK_END,              /* KEY_KP1   79 */
+    VK_DOWN,             /* KEY_KP2   80 */
+    VK_NEXT,             /* KEY_KP3   81 */
+    VK_INSERT,           /* KEY_KP0   82 */
+    VK_DELETE,           /* KEY_KPDOT  83 */
+    0,                   /* 84 */
+    0,                   /* KEY_ZENKAKUHANKAKU 85 */
+    VK_OEM_102,          /* KEY_102ND  86 */
+    VK_F11,              /* KEY_F11   87 */
+    VK_F12,              /* KEY_F12   88 */
+    0,                   /* KEY_RO   89 */
+    0,                   /* KEY_KATAKANA  90 */
+    0,                   /* KEY_HIRAGANA  91 */
+    0,                   /* KEY_HENKAN  92 */
+    0,                   /* KEY_KATAKANAHIRAGANA 93 */
+    0,                   /* KEY_MUHENKAN  94 */
+    0,                   /* KEY_KPJPCOMMA  95 */
+    VK_RETURN,           /* KEY_KPENTER  96 */
+    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
+    VK_DIVIDE,           /* KEY_KPSLASH  98 */
+    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
+    VK_RMENU,            /* KEY_RIGHTALT  100 */
+    0,                   /* KEY_LINEFEED  101 */
+    VK_HOME,             /* KEY_HOME  102 */
+    VK_UP,               /* KEY_UP   103 */
+    VK_PRIOR,            /* KEY_PAGEUP  104 */
+    VK_LEFT,             /* KEY_LEFT  105 */
+    VK_RIGHT,            /* KEY_RIGHT  106 */
+    VK_END,              /* KEY_END   107 */
+    VK_DOWN,             /* KEY_DOWN  108 */
+    VK_NEXT,             /* KEY_PAGEDOWN  109 */
+    VK_INSERT,           /* KEY_INSERT  110 */
+    VK_DELETE,           /* KEY_DELETE  111 */
+    0,                   /* KEY_MACRO  112 */
+    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
+    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
+    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
+    0,                   /* KEY_POWER  116  */
+    0,                   /* KEY_KPEQUAL  117 */
+    0,                   /* KEY_KPPLUSMINUS  118 */
+    VK_PAUSE,            /* KEY_PAUSE  119 */
+    0,                   /* KEY_SCALE  120  */
+    0,                   /* KEY_KPCOMMA  121 */
+    0,                   /* KEY_HANGEUL  122 */
+    0,                   /* KEY_HANJA  123 */
+    0,                   /* KEY_YEN   124 */
+    VK_LWIN,             /* KEY_LEFTMETA  125 */
+    VK_RWIN,             /* KEY_RIGHTMETA  126 */
+    0,                   /* KEY_COMPOSE  127 */
+    0,                   /* KEY_STOP  128  */
+    0,                   /* KEY_AGAIN  129 */
+    0,                   /* KEY_PROPS  130  */
+    0,                   /* KEY_UNDO  131  */
+    0,                   /* KEY_FRONT  132 */
+    0,                   /* KEY_COPY  133  */
+    0,                   /* KEY_OPEN  134  */
+    0,                   /* KEY_PASTE  135  */
+    0,                   /* KEY_FIND  136  */
+    0,                   /* KEY_CUT   137  */
+    0,                   /* KEY_HELP  138  */
+    0,                   /* KEY_MENU  139  */
+    0,                   /* KEY_CALC  140  */
+    0,                   /* KEY_SETUP  141 */
+    0,                   /* KEY_SLEEP  142  */
+    0,                   /* KEY_WAKEUP  143  */
+    0,                   /* KEY_FILE  144  */
+    0,                   /* KEY_SENDFILE  145 */
+    0,                   /* KEY_DELETEFILE  146 */
+    0,                   /* KEY_XFER  147 */
+    0,                   /* KEY_PROG1  148 */
+    0,                   /* KEY_PROG2  149 */
+    0,                   /* KEY_WWW   150  */
+    0,                   /* KEY_MSDOS  151 */
+    0,                   /* KEY_COFFEE  152 */
+    0,                   /* KEY_ROTATE_DISPLAY 153  */
+    0,                   /* KEY_CYCLEWINDOWS 154 */
+    0,                   /* KEY_MAIL  155 */
+    0,                   /* KEY_BOOKMARKS  156  */
+    0,                   /* KEY_COMPUTER  157 */
+    0,                   /* KEY_BACK  158  */
+    0,                   /* KEY_FORWARD  159  */
+    0,                   /* KEY_CLOSECD  160 */
+    0,                   /* KEY_EJECTCD  161 */
+    0,                   /* KEY_EJECTCLOSECD 162 */
+    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
+    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
+    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
+    0,                   /* KEY_STOPCD  166 */
+    0,                   /* KEY_RECORD  167 */
+    0,                   /* KEY_REWIND  168 */
+    0,                   /* KEY_PHONE  169  */
+    0,                   /* KEY_ISO   170 */
+    0,                   /* KEY_CONFIG  171  */
+    0,                   /* KEY_HOMEPAGE  172  */
+    0,                   /* KEY_REFRESH  173  */
+    0,                   /* KEY_EXIT  174  */
+    0,                   /* KEY_MOVE  175 */
+    0,                   /* KEY_EDIT  176 */
+    0,                   /* KEY_SCROLLUP  177 */
+    0,                   /* KEY_SCROLLDOWN  178 */
+    0,                   /* KEY_KPLEFTPAREN  179 */
+    0,                   /* KEY_KPRIGHTPAREN 180 */
+    0,                   /* KEY_NEW   181  */
+    0,                   /* KEY_REDO  182  */
+    VK_F13,              /* KEY_F13   183 */
+    VK_F14,              /* KEY_F14   184 */
+    VK_F15,              /* KEY_F15   185 */
+    VK_F16,              /* KEY_F16   186 */
+    VK_F17,              /* KEY_F17   187 */
+    VK_F18,              /* KEY_F18   188 */
+    VK_F19,              /* KEY_F19   189 */
+    VK_F20,              /* KEY_F20   190 */
+    VK_F21,              /* KEY_F21   191 */
+    VK_F22,              /* KEY_F22   192 */
+    VK_F23,              /* KEY_F23   193 */
+    VK_F24,              /* KEY_F24   194 */
+    0,                   /* 195 */
+    0,                   /* 196 */
+    0,                   /* 197 */
+    0,                   /* 198 */
+    0,                   /* 199 */
+    0,                   /* KEY_PLAYCD  200 */
+    0,                   /* KEY_PAUSECD  201 */
+    0,                   /* KEY_PROG3  202 */
+    0,                   /* KEY_PROG4  203 */
+    0,                   /* KEY_DASHBOARD  204  */
+    0,                   /* KEY_SUSPEND  205 */
+    0,                   /* KEY_CLOSE  206  */
+    VK_PLAY,             /* KEY_PLAY  207 */
+    0,                   /* KEY_FASTFORWARD  208 */
+    0,                   /* KEY_BASSBOOST  209 */
+    VK_PRINT,            /* KEY_PRINT  210  */
+    0,                   /* KEY_HP   211 */
+    0,                   /* KEY_CAMERA  212 */
+    0,                   /* KEY_SOUND  213 */
+    0,                   /* KEY_QUESTION  214  */
+    0,                   /* KEY_EMAIL  215 */
+    0,                   /* KEY_CHAT  216 */
+    0,                   /* KEY_SEARCH  217 */
+    0,                   /* KEY_CONNECT  218 */
+    0,                   /* KEY_FINANCE  219  */
+    0,                   /* KEY_SPORT  220 */
+    0,                   /* KEY_SHOP  221 */
+    0,                   /* KEY_ALTERASE  222 */
+    0,                   /* KEY_CANCEL  223  */
+    0,                   /* KEY_BRIGHTNESSDOWN 224 */
+    0,                   /* KEY_BRIGHTNESSUP 225 */
+    0,                   /* KEY_MEDIA  226 */
+    0,                   /* KEY_SWITCHVIDEOMODE 227  */
+    0,                   /* KEY_KBDILLUMTOGGLE 228 */
+    0,                   /* KEY_KBDILLUMDOWN 229 */
+    0,                   /* KEY_KBDILLUMUP  230 */
+    0,                   /* KEY_SEND  231  */
+    0,                   /* KEY_REPLY  232  */
+    0,                   /* KEY_FORWARDMAIL  233  */
+    0,                   /* KEY_SAVE  234  */
+    0,                   /* KEY_DOCUMENTS  235 */
+    0,                   /* KEY_BATTERY  236 */
+    0,                   /* KEY_BLUETOOTH  237 */
+    0,                   /* KEY_WLAN  238 */
+    0,                   /* KEY_UWB   239  */
+    0,                   /* KEY_UNKNOWN  240 */
+    0,                   /* KEY_VIDEO_NEXT  241  */
+    0,                   /* KEY_VIDEO_PREV  242  */
+    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
+    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
+    0,                   /* KEY_DISPLAY_OFF  245  */
+    0,                   /* KEY_WWAN  246  */
+    0,                   /* KEY_RFKILL  247  */
+    0,                   /* KEY_MICMUTE  248  */
+};
+
+#endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 7fb868d3e68..a9d31d439a4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -405,12 +405,16 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
+    struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
     if (pointer->focused_surface == surface)
         pointer->focused_surface = NULL;
 
+    if (keyboard->focused_surface == surface)
+        keyboard->focused_surface = NULL;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index af5b5c876b9..4c6c4df223b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -29,6 +29,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include <wayland-cursor.h>
+#include <xkbcommon/xkbcommon.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -56,6 +57,7 @@ enum wayland_window_message
 {
     WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
     WM_WAYLAND_SET_CURSOR,
+    WM_WAYLAND_QUERY_SURFACE_MAPPED,
 };
 
 enum wayland_surface_role
@@ -88,6 +90,18 @@ struct wayland_mutex
     const char *name;
 };
 
+struct wayland_keyboard
+{
+    struct wl_keyboard *wl_keyboard;
+    struct wayland_surface *focused_surface;
+    int repeat_interval_ms;
+    int repeat_delay_ms;
+    uint32_t last_pressed_key;
+    uint32_t enter_serial;
+    struct xkb_context *xkb_context;
+    struct xkb_state *xkb_state;
+};
+
 struct wayland_cursor
 {
     BOOL owns_wl_buffer;
@@ -128,6 +142,7 @@ struct wayland
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
     struct wl_list callback_list;
+    struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
@@ -373,6 +388,14 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland Keyboard
+ */
+
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Wayland Pointer/Cursor
  */
@@ -397,6 +420,13 @@ HKEY reg_open_hkcu_key_a(const char *name) DECLSPEC_HIDDEN;
 DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
                       DWORD *buffer_len) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          XKB helpers
+ */
+
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state) DECLSPEC_HIDDEN;
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2af2821fd1f..c2bda5f9ca6 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -503,6 +503,15 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
                                                  (HCURSOR)lp);
         break;
+    case WM_WAYLAND_QUERY_SURFACE_MAPPED:
+        {
+            LRESULT res;
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            res = wayland_surface ? wayland_surface->mapped : 0;
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+            return res;
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
diff --git a/include/config.h.in b/include/config.h.in
index b70689b107d..a2b4b97d450 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -748,6 +748,9 @@
 /* Define if you have the XKB extension */
 #undef HAVE_XKB
 
+/* Define to 1 if you have the <xkbcommon/xkbcommon.h> header file. */
+#undef HAVE_XKBCOMMON_XKBCOMMON_H
+
 /* Define if Xrender has the XRenderCreateLinearGradient function */
 #undef HAVE_XRENDERCREATELINEARGRADIENT
 
-- 
2.39.0.rc2

From 7f64257a4589e97773a27fa26a7f04cda1d05e8e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:55:18 +0300
Subject: [PATCH 054/202] winewayland.drv: Basic support for Wayland keymaps.

Handle the keymap information sent by the compositor, and try to match
the keycodes in the keymap to keys from a keyboard layout, in order to
be able to provide to virtual key and scan codes for each keycode.

Keyboard layouts are structures that contain information about the
virtual key code and scan code corresponding to each physical key, as
well as the xkb_keysym_t symbols emitted by each key for the normal and
shift states.

Each Wayland keycode is mapped to a layout key based on the similarity
of the symbols this keycode produces in the active Wayland keymap, to
the symbols for the key in the keyboard layout.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |   2 +
 dlls/winewayland.drv/wayland_keyboard.c       |  51 +-
 .../winewayland.drv/wayland_keyboard_layout.c | 202 ++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 482 +++++++++---------
 dlls/winewayland.drv/waylanddrv.h             |   3 +
 dlls/winewayland.drv/xkb_util.c               |  80 +++
 6 files changed, 563 insertions(+), 257 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.c
 create mode 100644 dlls/winewayland.drv/xkb_util.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 03427859dd3..8dc9a302814 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
 	wayland_keyboard.c \
+	wayland_keyboard_layout.c \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
@@ -24,6 +25,7 @@ C_SRCS = \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
+	xkb_util.c \
 
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 4a858f51c9f..84e452057f6 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -43,25 +43,24 @@
 #include "ntuser.h"
 
 #include <linux/input.h>
+#include <sys/mman.h>
 #include <unistd.h>
 
-#include "wayland_keyboard_layout.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
 static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
                                       xkb_keycode_t xkb_keycode)
 {
-    /* Use linux input keycode as scan code for now. */
-    return xkb_keycode - 8;
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode) ?
+           keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
 }
 
 static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
                                  xkb_keycode_t xkb_keycode)
 {
-    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
-           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey) ?
+           keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
 }
 
 /* xkb keycodes are offset by 8 from linux input keycodes. */
@@ -164,6 +163,40 @@ static BOOL wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t ke
 static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
                                    uint32_t format, int fd, uint32_t size)
 {
+    struct wayland *wayland = data;
+    struct xkb_keymap *xkb_keymap = NULL;
+    struct xkb_state *xkb_state = NULL;
+    char *keymap_str;
+
+    TRACE("format=%d fd=%d size=%d\n", format, fd, size);
+
+    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 ||
+        !wayland->keyboard.xkb_context)
+        goto out;
+
+    keymap_str = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (keymap_str == MAP_FAILED)
+        goto out;
+
+    xkb_keymap = xkb_keymap_new_from_string(wayland->keyboard.xkb_context,
+                                            keymap_str,
+                                            XKB_KEYMAP_FORMAT_TEXT_V1,
+                                            0);
+    munmap(keymap_str, size);
+    if (!xkb_keymap)
+        goto out;
+
+    xkb_state = xkb_state_new(xkb_keymap);
+    xkb_keymap_unref(xkb_keymap);
+    if (!xkb_state)
+        goto out;
+
+    xkb_state_unref(wayland->keyboard.xkb_state);
+    wayland->keyboard.xkb_state = xkb_state;
+
+    wayland_keyboard_update_layout(&wayland->keyboard);
+
+out:
     close(fd);
 }
 
@@ -352,15 +385,21 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
                                       uint32_t group)
 {
     struct wayland *wayland = data;
+    uint32_t last_group;
 
     TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
           mods_depressed, mods_latched, mods_locked, group);
 
     if (!wayland->keyboard.xkb_state) return;
 
+    last_group = _xkb_state_get_active_layout(wayland->keyboard.xkb_state);
+
     xkb_state_update_mask(wayland->keyboard.xkb_state,
                           mods_depressed, mods_latched, mods_locked, 0, 0, group);
 
+    if (group != last_group)
+        wayland_keyboard_update_layout(&wayland->keyboard);
+
     /* TODO: Sync wine modifier state with XKB modifier state. */
 }
 
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
new file mode 100644
index 00000000000..2e7925d7e33
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -0,0 +1,202 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ime.h"
+#include "winuser.h"
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
+                         const xkb_keysym_t ref[MAIN_KEY_SYMBOLS_LEN])
+{
+    int score = 0, i;
+
+    for (i = 0; i < MAIN_KEY_SYMBOLS_LEN && ref[i]; i++)
+    {
+        if (ref[i] != sym[i]) return 0;
+        score++;
+    }
+
+    return score;
+}
+
+static void _xkb_keymap_populate_symbols_for_keycode(
+    struct xkb_keymap *xkb_keymap,
+    xkb_layout_index_t layout,
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+    if (max_xkb_keycode > 255) max_xkb_keycode = 255;
+
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        if (num_levels > MAIN_KEY_SYMBOLS_LEN) num_levels = MAIN_KEY_SYMBOLS_LEN;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+            if (nsyms)
+                symbols_for_keycode[xkb_keycode][level] = syms[0];
+        }
+    }
+}
+
+/* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
+ * the specified main_key layout (see wayland_keyboard_layout.h) and the
+ * xkb_keycode to xkb_keysym_t mappings which have been created from the
+ * currently active Wayland keymap. */
+static void populate_xkb_keycode_maps(struct wayland_keyboard *keyboard, int main_key_layout,
+                                      const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+    const xkb_keysym_t (*lsymbols)[MAIN_KEY_SYMBOLS_LEN] =
+        (*main_key_tab[main_key_layout].symbols);
+    const WORD *lvkey = (*main_key_tab[main_key_layout].vkey);
+    const WORD *lscan = (*main_key_tab[main_key_layout].scan);
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int max_key = -1;
+        int max_score = 0;
+        xkb_keysym_t xkb_keysym = symbols_for_keycode[xkb_keycode][0];
+        UINT vkey = 0;
+        WORD scan = 0;
+
+        if ((xkb_keysym >> 8) == 0xFF)
+        {
+            vkey = xkb_keysym_0xff00_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_0xff00_to_scan[xkb_keysym & 0xff];
+        }
+        else if ((xkb_keysym >> 8) == 0x1008FF)
+        {
+            vkey = xkb_keysym_xfree86_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_xfree86_to_scan[xkb_keysym & 0xff];
+        }
+        else if (xkb_keysym == 0x20)
+        {
+            vkey = VK_SPACE;
+            scan = 0x39;
+        }
+        else
+        {
+            int key;
+
+            for (key = 0; key < MAIN_KEY_LEN; key++)
+            {
+                int score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                          lsymbols[key]);
+                /* Consider this key if it has a better score, or the same
+                 * score as a previous match that is already in use (in order
+                 * to prefer unused keys). */
+                if (score > max_score ||
+                    (max_key >= 0 && score == max_score && key_used[max_key]))
+                {
+                    max_key = key;
+                    max_score = score;
+                }
+            }
+
+            if (max_key >= 0)
+            {
+                vkey = lvkey[max_key];
+                scan = lscan[max_key];
+                key_used[max_key] = 1;
+            }
+        }
+
+        keyboard->xkb_keycode_to_vkey[xkb_keycode] = vkey;
+        keyboard->xkb_keycode_to_scancode[xkb_keycode] = scan;
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols_for_keycode[xkb_keycode],
+                                 MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("Mapped xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' => "
+                        "vkey=0x%x scan=0x%x\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, vkey, scan);
+        }
+    }
+}
+
+/***********************************************************************
+ *           wayland_keyboard_update_layout
+ *
+ * Updates the internal weston_keyboard layout information (xkb keycode
+ * mappings etc) based on the current XKB layout.
+ */
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
+{
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = keyboard->xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+
+    if (!xkb_state)
+    {
+        TRACE("no xkb state, returning\n");
+        return;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE("no active layout, returning\n");
+        return;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+
+    _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, 0, symbols_for_keycode);
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
index 553264e22a4..5fa72329c07 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.h
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -30,258 +30,238 @@
 #ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
 #define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
 
-static const UINT xkb_keycode_to_vkey_us[] =
+#define MAIN_KEY_LEN 50
+/* We currently use two symbols (levels) per key to differentiate layouts. */
+#define MAIN_KEY_SYMBOLS_LEN 2
+
+/* Windows uses PS/2 scan code set 1 for the scan codes sent to applications. */
+static const WORD main_key_scan_ps2_set1[MAIN_KEY_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x7D,
+    /* Row D: AD01-AD12 */
+    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,
+    /* Row C: AC01-AC12 */
+    0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2B,
+    /* Row B: LSGT, AB01-AB11 */
+    0x56,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x73
+};
+
+static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+#define K(x) XKB_KEY_##x
+
+static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+#undef K
+
+/*** Layout table. Add your keyboard mappings to this list */
+static struct {
+    LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
+                 in the appropriate dlls/kernel/nls/.nls file */
+    const char *name;
+    const xkb_keysym_t (*symbols)[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN];
+    const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
+    const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
+} main_key_tab[]={
+    {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+};
+
+const WORD xkb_keysym_0xff00_to_vkey[256] DECLSPEC_HIDDEN =
+{
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF00 */
+    /* special keys */
+    VK_BACK, VK_TAB, 0, VK_CLEAR, 0, VK_RETURN, 0, 0,           /* FF08 */
+    0, 0, 0, VK_PAUSE, VK_SCROLL, VK_SNAPSHOT, 0, 0,            /* FF10 */
+    0, 0, 0, VK_ESCAPE, 0, 0, 0, 0,                             /* FF18 */
+    /* Japanese special keys */
+    0, VK_KANJI, VK_NONCONVERT, VK_CONVERT,                     /* FF20 */
+    VK_DBE_ROMAN, 0, 0, VK_DBE_HIRAGANA,
+    0, 0, VK_DBE_SBCSCHAR, 0, 0, 0, 0, 0,                       /* FF28 */
+    /* Korean special keys (FF31-) */
+    VK_DBE_ALPHANUMERIC, VK_HANGUL, 0, 0, VK_HANJA, 0, 0, 0,    /* FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF38 */
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF48 */
+    /* cursor keys */
+    VK_HOME, VK_LEFT, VK_UP, VK_RIGHT,                          /* FF50 */
+    VK_DOWN, VK_PRIOR, VK_NEXT, VK_END,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF58 */
+    /* misc keys */
+    VK_SELECT, VK_SNAPSHOT, VK_EXECUTE, VK_INSERT, 0,0,0, VK_APPS, /* FF60 */
+    0, VK_CANCEL, VK_HELP, VK_CANCEL, 0, 0, 0, 0,               /* FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF70 */
+    /* keypad keys */
+    0, 0, 0, 0, 0, 0, 0, VK_NUMLOCK,                            /* FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF80 */
+    0, 0, 0, 0, 0, VK_RETURN, 0, 0,                             /* FF88 */
+    0, 0, 0, 0, 0, VK_HOME, VK_LEFT, VK_UP,                     /* FF90 */
+    VK_RIGHT, VK_DOWN, VK_PRIOR, VK_NEXT,                       /* FF98 */
+    VK_END, VK_CLEAR, VK_INSERT, VK_DELETE,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFA0 */
+    0, 0, VK_MULTIPLY, VK_ADD,                                  /* FFA8 */
+    /* Windows always generates VK_DECIMAL for Del/. on keypad while some
+     * X11 keyboard layouts generate XK_KP_Separator instead of XK_KP_Decimal
+     * in order to produce a locale dependent numeric separator.
+     */
+    VK_DECIMAL, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
+    VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3,             /* FFB0 */
+    VK_NUMPAD4, VK_NUMPAD5, VK_NUMPAD6, VK_NUMPAD7,
+    VK_NUMPAD8, VK_NUMPAD9, 0, 0, 0, VK_OEM_NEC_EQUAL,          /* FFB8 */
+    /* function keys */
+    VK_F1, VK_F2,
+    VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10,    /* FFC0 */
+    VK_F11, VK_F12, VK_F13, VK_F14, VK_F15, VK_F16, VK_F17, VK_F18, /* FFC8 */
+    VK_F19, VK_F20, VK_F21, VK_F22, VK_F23, VK_F24, 0, 0,       /* FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFD8 */
+    /* modifier keys */
+    0, VK_LSHIFT, VK_RSHIFT, VK_LCONTROL,                       /* FFE0 */
+    VK_RCONTROL, VK_CAPITAL, 0, VK_LMENU,
+    VK_RMENU, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN, 0, 0, 0,    /* FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFF0 */
+    0, 0, 0, 0, 0, 0, 0, VK_DELETE                              /* FFF8 */
+};
+
+const WORD xkb_keysym_0xff00_to_scan[256] DECLSPEC_HIDDEN =
+{
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF00 */
+    /* special keys */
+    0x0E, 0x0F, 0x00, /*?*/ 0, 0x00, 0x1C, 0x00, 0x00,           /* FF08 */
+    0x00, 0x00, 0x00, 0xE11D, 0x46, 0x54, 0x00, 0x00,            /* FF10 */
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,              /* FF18 */
+    /* Japanese special keys */
+    0x00, 0x29, 0x7B, 0x79, 0x70, 0x00, 0x00, 0x70,              /* FF20 */
+    0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF28 */
+    /* Korean special keys (FF31-) */
+    0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF30 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF38 */
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF40 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF48 */
+    /* cursor keys */
+    0xE047, 0xE04B, 0xE048, 0xE04D, 0xE050, 0xE049, 0xE051, 0xE04F, /* FF50 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF58 */
+    /* misc keys */
+    /*?*/ 0, 0xE037, /*?*/ 0, 0xE052, 0x00, 0x00, 0x00, 0xE05D,  /* FF60 */
+    /*?*/ 0, /*?*/ 0, 0x63, 0xE046, 0x00, 0x00, 0x00, 0x00,      /* FF68 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF70 */
+    /* keypad keys */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45,              /* FF78 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF80 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0xE01C, 0x00, 0x00,            /* FF88 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4B, 0x48,              /* FF90 */
+    0x4D, 0x50, 0x49, 0x51, 0x4F, 0x4C, 0x52, 0x53,              /* FF98 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFA0 */
+    0x00, 0x00, 0x37, 0x4E, 0x53, 0x4A, 0x53, 0xE035,            /* FFA8 */
+    0x52, 0x4F, 0x50, 0x51, 0x4B, 0x4C, 0x4D, 0x47,              /* FFB0 */
+    0x48, 0x49, 0x00, 0x00, 0x00, 0x00,                          /* FFB8 */
+    /* function keys */
+    0x3B, 0x3C,
+    0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44,              /* FFC0 */
+    0x57, 0x58, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,              /* FFC8 */
+    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x76, 0x00, 0x00,              /* FFD0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD8 */
+    /* modifier keys */
+    0x00, 0x2A, 0x36, 0x1D, 0xE01D, 0x3A, 0x00, 0x38,            /* FFE0 */
+    0xE038, 0x38, 0xE038, 0xE05B, 0xE05C, 0x00, 0x00, 0x00,      /* FFE8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFF0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE053             /* FFF8 */
+};
+
+const WORD xkb_keysym_xfree86_to_vkey[256] DECLSPEC_HIDDEN =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, VK_VOLUME_DOWN, VK_VOLUME_MUTE, VK_VOLUME_UP,            /* 1008FF10 */
+    VK_MEDIA_PLAY_PAUSE, VK_MEDIA_STOP,
+    VK_MEDIA_PREV_TRACK, VK_MEDIA_NEXT_TRACK,
+    0, VK_LAUNCH_MAIL, 0, VK_BROWSER_SEARCH,                    /* 1008FF18 */
+    0, 0, 0, VK_BROWSER_HOME,
+    0, 0, 0, 0, 0, 0, VK_BROWSER_BACK, VK_BROWSER_FORWARD,      /* 1008FF20 */
+    VK_BROWSER_STOP, VK_BROWSER_REFRESH, 0, 0, 0, 0, 0, VK_SLEEP, /* 1008FF28 */
+    VK_BROWSER_FAVORITES, 0, VK_LAUNCH_MEDIA_SELECT, 0,         /* 1008FF30 */
+    0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    VK_LAUNCH_APP1, VK_LAUNCH_APP2, 0, 0, 0, 0, 0, 0,           /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
+};
+
+const WORD xkb_keysym_xfree86_to_scan[256] DECLSPEC_HIDDEN =
 {
-    0, 0, 0, 0, 0, 0, 0, 0,
-    0,                   /* KEY_RESERVED  0 */
-    VK_ESCAPE,           /* KEY_ESC   1 */
-    '1',                 /* KEY_1   2 */
-    '2',                 /* KEY_2   3 */
-    '3',                 /* KEY_3   4 */
-    '4',                 /* KEY_4   5 */
-    '5',                 /* KEY_5   6 */
-    '6',                 /* KEY_6   7 */
-    '7',                 /* KEY_7   8 */
-    '8',                 /* KEY_8   9 */
-    '9',                 /* KEY_9   10 */
-    '0',                 /* KEY_0   11 */
-    VK_OEM_MINUS,        /* KEY_MINUS  12 */
-    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
-    VK_BACK,             /* KEY_BACKSPACE 14 */
-    VK_TAB,              /* KEY_TAB   15 */
-    'Q',                 /* KEY_Q   16 */
-    'W',                 /* KEY_W   17 */
-    'E',                 /* KEY_E   18 */
-    'R',                 /* KEY_R   19 */
-    'T',                 /* KEY_T   20 */
-    'Y',                 /* KEY_Y   21 */
-    'U',                 /* KEY_U   22 */
-    'I',                 /* KEY_I   23 */
-    'O',                 /* KEY_O   24 */
-    'P',                 /* KEY_P   25 */
-    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
-    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
-    VK_RETURN,           /* KEY_ENTER  28 */
-    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
-    'A',                 /* KEY_A   30 */
-    'S',                 /* KEY_S   31 */
-    'D',                 /* KEY_D   32 */
-    'F',                 /* KEY_F   33 */
-    'G',                 /* KEY_G   34 */
-    'H',                 /* KEY_H   35 */
-    'J',                 /* KEY_J   36 */
-    'K',                 /* KEY_K   37 */
-    'L',                 /* KEY_L   38 */
-    VK_OEM_1,            /* KEY_SEMICOLON  39 */
-    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
-    VK_OEM_3,            /* KEY_GRAVE  41 */
-    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
-    VK_OEM_5,            /* KEY_BACKSLASH  43 */
-    'Z',                 /* KEY_Z   44 */
-    'X',                 /* KEY_X   45 */
-    'C',                 /* KEY_C   46 */
-    'V',                 /* KEY_V   47 */
-    'B',                 /* KEY_B   48 */
-    'N',                 /* KEY_N   49 */
-    'M',                 /* KEY_M   50 */
-    VK_OEM_COMMA,        /* KEY_COMMA  51 */
-    VK_OEM_PERIOD,       /* KEY_DOT   52 */
-    VK_OEM_2,            /* KEY_SLASH  53 */
-    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
-    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
-    VK_LMENU,            /* KEY_LEFTALT  56 */
-    VK_SPACE,            /* KEY_SPACE  57 */
-    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
-    VK_F1,               /* KEY_F1   59 */
-    VK_F2,               /* KEY_F2   60 */
-    VK_F3,               /* KEY_F3   61 */
-    VK_F4,               /* KEY_F4   62 */
-    VK_F5,               /* KEY_F5   63 */
-    VK_F6,               /* KEY_F6   64 */
-    VK_F7,               /* KEY_F7   65 */
-    VK_F8,               /* KEY_F8   66 */
-    VK_F9,               /* KEY_F9   67 */
-    VK_F10,              /* KEY_F10   68 */
-    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
-    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
-    VK_HOME,             /* KEY_KP7   71 */
-    VK_UP,               /* KEY_KP8   72 */
-    VK_PRIOR,            /* KEY_KP9   73 */
-    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
-    VK_LEFT,             /* KEY_KP4   75 */
-    VK_CLEAR,            /* KEY_KP5   76 */
-    VK_RIGHT,            /* KEY_KP6   77 */
-    VK_ADD,              /* KEY_KPPLUS  78 */
-    VK_END,              /* KEY_KP1   79 */
-    VK_DOWN,             /* KEY_KP2   80 */
-    VK_NEXT,             /* KEY_KP3   81 */
-    VK_INSERT,           /* KEY_KP0   82 */
-    VK_DELETE,           /* KEY_KPDOT  83 */
-    0,                   /* 84 */
-    0,                   /* KEY_ZENKAKUHANKAKU 85 */
-    VK_OEM_102,          /* KEY_102ND  86 */
-    VK_F11,              /* KEY_F11   87 */
-    VK_F12,              /* KEY_F12   88 */
-    0,                   /* KEY_RO   89 */
-    0,                   /* KEY_KATAKANA  90 */
-    0,                   /* KEY_HIRAGANA  91 */
-    0,                   /* KEY_HENKAN  92 */
-    0,                   /* KEY_KATAKANAHIRAGANA 93 */
-    0,                   /* KEY_MUHENKAN  94 */
-    0,                   /* KEY_KPJPCOMMA  95 */
-    VK_RETURN,           /* KEY_KPENTER  96 */
-    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
-    VK_DIVIDE,           /* KEY_KPSLASH  98 */
-    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
-    VK_RMENU,            /* KEY_RIGHTALT  100 */
-    0,                   /* KEY_LINEFEED  101 */
-    VK_HOME,             /* KEY_HOME  102 */
-    VK_UP,               /* KEY_UP   103 */
-    VK_PRIOR,            /* KEY_PAGEUP  104 */
-    VK_LEFT,             /* KEY_LEFT  105 */
-    VK_RIGHT,            /* KEY_RIGHT  106 */
-    VK_END,              /* KEY_END   107 */
-    VK_DOWN,             /* KEY_DOWN  108 */
-    VK_NEXT,             /* KEY_PAGEDOWN  109 */
-    VK_INSERT,           /* KEY_INSERT  110 */
-    VK_DELETE,           /* KEY_DELETE  111 */
-    0,                   /* KEY_MACRO  112 */
-    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
-    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
-    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
-    0,                   /* KEY_POWER  116  */
-    0,                   /* KEY_KPEQUAL  117 */
-    0,                   /* KEY_KPPLUSMINUS  118 */
-    VK_PAUSE,            /* KEY_PAUSE  119 */
-    0,                   /* KEY_SCALE  120  */
-    0,                   /* KEY_KPCOMMA  121 */
-    0,                   /* KEY_HANGEUL  122 */
-    0,                   /* KEY_HANJA  123 */
-    0,                   /* KEY_YEN   124 */
-    VK_LWIN,             /* KEY_LEFTMETA  125 */
-    VK_RWIN,             /* KEY_RIGHTMETA  126 */
-    0,                   /* KEY_COMPOSE  127 */
-    0,                   /* KEY_STOP  128  */
-    0,                   /* KEY_AGAIN  129 */
-    0,                   /* KEY_PROPS  130  */
-    0,                   /* KEY_UNDO  131  */
-    0,                   /* KEY_FRONT  132 */
-    0,                   /* KEY_COPY  133  */
-    0,                   /* KEY_OPEN  134  */
-    0,                   /* KEY_PASTE  135  */
-    0,                   /* KEY_FIND  136  */
-    0,                   /* KEY_CUT   137  */
-    0,                   /* KEY_HELP  138  */
-    0,                   /* KEY_MENU  139  */
-    0,                   /* KEY_CALC  140  */
-    0,                   /* KEY_SETUP  141 */
-    0,                   /* KEY_SLEEP  142  */
-    0,                   /* KEY_WAKEUP  143  */
-    0,                   /* KEY_FILE  144  */
-    0,                   /* KEY_SENDFILE  145 */
-    0,                   /* KEY_DELETEFILE  146 */
-    0,                   /* KEY_XFER  147 */
-    0,                   /* KEY_PROG1  148 */
-    0,                   /* KEY_PROG2  149 */
-    0,                   /* KEY_WWW   150  */
-    0,                   /* KEY_MSDOS  151 */
-    0,                   /* KEY_COFFEE  152 */
-    0,                   /* KEY_ROTATE_DISPLAY 153  */
-    0,                   /* KEY_CYCLEWINDOWS 154 */
-    0,                   /* KEY_MAIL  155 */
-    0,                   /* KEY_BOOKMARKS  156  */
-    0,                   /* KEY_COMPUTER  157 */
-    0,                   /* KEY_BACK  158  */
-    0,                   /* KEY_FORWARD  159  */
-    0,                   /* KEY_CLOSECD  160 */
-    0,                   /* KEY_EJECTCD  161 */
-    0,                   /* KEY_EJECTCLOSECD 162 */
-    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
-    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
-    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
-    0,                   /* KEY_STOPCD  166 */
-    0,                   /* KEY_RECORD  167 */
-    0,                   /* KEY_REWIND  168 */
-    0,                   /* KEY_PHONE  169  */
-    0,                   /* KEY_ISO   170 */
-    0,                   /* KEY_CONFIG  171  */
-    0,                   /* KEY_HOMEPAGE  172  */
-    0,                   /* KEY_REFRESH  173  */
-    0,                   /* KEY_EXIT  174  */
-    0,                   /* KEY_MOVE  175 */
-    0,                   /* KEY_EDIT  176 */
-    0,                   /* KEY_SCROLLUP  177 */
-    0,                   /* KEY_SCROLLDOWN  178 */
-    0,                   /* KEY_KPLEFTPAREN  179 */
-    0,                   /* KEY_KPRIGHTPAREN 180 */
-    0,                   /* KEY_NEW   181  */
-    0,                   /* KEY_REDO  182  */
-    VK_F13,              /* KEY_F13   183 */
-    VK_F14,              /* KEY_F14   184 */
-    VK_F15,              /* KEY_F15   185 */
-    VK_F16,              /* KEY_F16   186 */
-    VK_F17,              /* KEY_F17   187 */
-    VK_F18,              /* KEY_F18   188 */
-    VK_F19,              /* KEY_F19   189 */
-    VK_F20,              /* KEY_F20   190 */
-    VK_F21,              /* KEY_F21   191 */
-    VK_F22,              /* KEY_F22   192 */
-    VK_F23,              /* KEY_F23   193 */
-    VK_F24,              /* KEY_F24   194 */
-    0,                   /* 195 */
-    0,                   /* 196 */
-    0,                   /* 197 */
-    0,                   /* 198 */
-    0,                   /* 199 */
-    0,                   /* KEY_PLAYCD  200 */
-    0,                   /* KEY_PAUSECD  201 */
-    0,                   /* KEY_PROG3  202 */
-    0,                   /* KEY_PROG4  203 */
-    0,                   /* KEY_DASHBOARD  204  */
-    0,                   /* KEY_SUSPEND  205 */
-    0,                   /* KEY_CLOSE  206  */
-    VK_PLAY,             /* KEY_PLAY  207 */
-    0,                   /* KEY_FASTFORWARD  208 */
-    0,                   /* KEY_BASSBOOST  209 */
-    VK_PRINT,            /* KEY_PRINT  210  */
-    0,                   /* KEY_HP   211 */
-    0,                   /* KEY_CAMERA  212 */
-    0,                   /* KEY_SOUND  213 */
-    0,                   /* KEY_QUESTION  214  */
-    0,                   /* KEY_EMAIL  215 */
-    0,                   /* KEY_CHAT  216 */
-    0,                   /* KEY_SEARCH  217 */
-    0,                   /* KEY_CONNECT  218 */
-    0,                   /* KEY_FINANCE  219  */
-    0,                   /* KEY_SPORT  220 */
-    0,                   /* KEY_SHOP  221 */
-    0,                   /* KEY_ALTERASE  222 */
-    0,                   /* KEY_CANCEL  223  */
-    0,                   /* KEY_BRIGHTNESSDOWN 224 */
-    0,                   /* KEY_BRIGHTNESSUP 225 */
-    0,                   /* KEY_MEDIA  226 */
-    0,                   /* KEY_SWITCHVIDEOMODE 227  */
-    0,                   /* KEY_KBDILLUMTOGGLE 228 */
-    0,                   /* KEY_KBDILLUMDOWN 229 */
-    0,                   /* KEY_KBDILLUMUP  230 */
-    0,                   /* KEY_SEND  231  */
-    0,                   /* KEY_REPLY  232  */
-    0,                   /* KEY_FORWARDMAIL  233  */
-    0,                   /* KEY_SAVE  234  */
-    0,                   /* KEY_DOCUMENTS  235 */
-    0,                   /* KEY_BATTERY  236 */
-    0,                   /* KEY_BLUETOOTH  237 */
-    0,                   /* KEY_WLAN  238 */
-    0,                   /* KEY_UWB   239  */
-    0,                   /* KEY_UNKNOWN  240 */
-    0,                   /* KEY_VIDEO_NEXT  241  */
-    0,                   /* KEY_VIDEO_PREV  242  */
-    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
-    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
-    0,                   /* KEY_DISPLAY_OFF  245  */
-    0,                   /* KEY_WWAN  246  */
-    0,                   /* KEY_RFKILL  247  */
-    0,                   /* KEY_MICMUTE  248  */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, 0xE02E, 0xE020, 0xE030, 0xE022, 0xE024, 0xE010, 0xE019,  /* 1008FF10 */
+    0, 0xE06C, 0, 0xE065, 0, 0, 0, 0xE032,                      /* 1008FF18 */
+    0, 0, 0, 0, 0, 0, 0xE06A, 0xE069,                           /* 1008FF20 */
+    0xE068, 0xE067, 0, 0, 0, 0, 0, 0xE05F,                      /* 1008FF28 */
+    0xE066, 0, 0xE06D, 0, 0, 0, 0, 0,                           /* 1008FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    0xE06B, 0xE021, 0, 0, 0, 0, 0, 0,                           /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
 #endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4c6c4df223b..b1cbe692cc4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -100,6 +100,8 @@ struct wayland_keyboard
     uint32_t enter_serial;
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
+    UINT xkb_keycode_to_vkey[256];
+    WORD xkb_keycode_to_scancode[256];
 };
 
 struct wayland_cursor
@@ -395,6 +397,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
                            struct wl_keyboard *wl_keyboard) DECLSPEC_HIDDEN;
 void wayland_keyboard_deinit(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Pointer/Cursor
diff --git a/dlls/winewayland.drv/xkb_util.c b/dlls/winewayland.drv/xkb_util.c
new file mode 100644
index 00000000000..475af4b5bd6
--- /dev/null
+++ b/dlls/winewayland.drv/xkb_util.c
@@ -0,0 +1,80 @@
+/*
+ * XKB related utility functions
+ *
+ * Copyright 2021 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include <xkbcommon/xkbcommon.h>
+
+/**********************************************************************
+ *          _xkb_state_get_active_layout
+ *
+ * Gets the active layout of the xkb state.
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state)
+{
+    struct xkb_keymap *xkb_keymap = xkb_state_get_keymap(xkb_state);
+    xkb_layout_index_t num_layouts = xkb_keymap_num_layouts(xkb_keymap);
+    xkb_layout_index_t layout;
+
+    for (layout = 0; layout < num_layouts; layout++)
+    {
+        if (xkb_state_layout_index_is_active(xkb_state, layout,
+                                             XKB_STATE_LAYOUT_LOCKED))
+            return layout;
+    }
+
+    return XKB_LAYOUT_INVALID;
+}
+
+/**********************************************************************
+ *          _xkb_keysyms_to_utf8
+ *
+ * Get the null-terminated UTF-8 string representation of a sequence of
+ * keysyms. Returns the length of the UTF-8 string written, *not* including
+ * the null byte. If no bytes were produced or in case of error returns 0
+ * and produces a properly null-terminated empty string if possible.
+ */
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size)
+{
+    int i;
+    int utf8_len = 0;
+
+    if (utf8_size == 0) return 0;
+
+    for (i = 0; i < nsyms; i++)
+    {
+        int nwritten = xkb_keysym_to_utf8(syms[i], utf8 + utf8_len,
+                                          utf8_size - utf8_len);
+        if (nwritten <= 0)
+        {
+            utf8_len = 0;
+            break;
+        }
+
+        /* nwritten includes the terminating null byte */
+        utf8_len += nwritten - 1;
+    }
+
+    utf8[utf8_len] = '\0';
+
+    return utf8_len;
+}
-- 
2.39.0.rc2

From c858132e4142113cd6b6927ae21faef8f29f5425 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:57:33 +0300
Subject: [PATCH 055/202] winewayland.drv: Add detection of best keyboard
 layout match.

Add a mechanism to detect the best matching keyboard layout for a given
Wayland keymap, by scoring the similarity of the symbols produced by
Wayland keycodes for that keymap, to the symbols for keys in the layout.

The scoring algorithm takes relative key order into account to provide
better detection of layouts that differ only in their key order.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../winewayland.drv/wayland_keyboard_layout.c | 92 ++++++++++++++++++-
 1 file changed, 91 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
index 2e7925d7e33..6d192b23ed6 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.c
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -56,6 +56,62 @@ static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
     return score;
 }
 
+static int score_layout(int layout,
+                        const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    int score = 0;
+    int prev_key = 1000;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int key, key_score = 0;
+        const xkb_keysym_t *symbols = symbols_for_keycode[xkb_keycode];
+
+        if (*symbols == 0)
+            continue;
+
+        for (key = 0; key < MAIN_KEY_LEN; key++)
+        {
+            if (key_used[key]) continue;
+            key_score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                      (*main_key_tab[layout].symbols)[key]);
+            if (key_score)
+                break;
+        }
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols, MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' key=%d score=%d order=%d\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, key, key_score, key_score && (key > prev_key));
+        }
+
+        if (key_score)
+        {
+            /* Multiply score by 100 to allow the key order bonus to break ties,
+             * while not being a primary decision factor. */
+            score += key_score * 100;
+
+            /* xkb keycodes roughly follow a top left to bottom right direction
+             * on the keyboard as they increase, similarly to the keys in
+             * main_key_tab. Give a bonus to layouts that more closely match
+             * the expected ordering. We compare with the last key to get
+             * some reasonable (although local) measure of the order. */
+            score += (key > prev_key);
+            prev_key = key;
+            key_used[key] = 1;
+        }
+    }
+
+    return score;
+}
+
 static void _xkb_keymap_populate_symbols_for_keycode(
     struct xkb_keymap *xkb_keymap,
     xkb_layout_index_t layout,
@@ -86,6 +142,37 @@ static void _xkb_keymap_populate_symbols_for_keycode(
     }
 }
 
+static int detect_main_key_layout(struct wayland_keyboard *keyboard,
+                                  const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    int max_score = 0;
+    int max_i = 0;
+
+    for (int i = 0; i < ARRAY_SIZE(main_key_tab); i++)
+    {
+        int score = score_layout(i, symbols_for_keycode);
+        if (score > max_score)
+        {
+            max_i = i;
+            max_score = score;
+        }
+        TRACE("evaluated layout '%s' score %d\n", main_key_tab[i].name, score);
+    }
+
+    if (max_score == 0)
+    {
+        max_i = 0;
+        while (strcmp(main_key_tab[max_i].name, "us")) max_i++;
+        TRACE("failed to detect layout, falling back to layout 'us'\n");
+    }
+    else
+    {
+        TRACE("detected layout '%s' (score %d)\n", main_key_tab[max_i].name, max_score);
+    }
+
+    return max_i;
+}
+
 /* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
  * the specified main_key layout (see wayland_keyboard_layout.h) and the
  * xkb_keycode to xkb_keysym_t mappings which have been created from the
@@ -180,6 +267,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
     struct xkb_state *xkb_state = keyboard->xkb_state;
     struct xkb_keymap *xkb_keymap;
     xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+    int main_key_layout;
 
     if (!xkb_state)
     {
@@ -198,5 +286,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
 
     _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
 
-    populate_xkb_keycode_maps(keyboard, 0, symbols_for_keycode);
+    main_key_layout = detect_main_key_layout(keyboard, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, main_key_layout, symbols_for_keycode);
 }
-- 
2.39.0.rc2

From 74ea50210dd2c8d0c8b92d7c7a6f1f0eb5089a46 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:00:11 +0300
Subject: [PATCH 056/202] winewayland.drv: Add support for more keyboard
 layouts.

Add virtual key mappings, scan code mappings, and symbol mappings for
various keyboard layouts and languages.

These mappings were produced automatically by a helper program using
the xkbcommon library.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../winewayland.drv/wayland_keyboard_layout.h | 699 ++++++++++++++++++
 1 file changed, 699 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
index 5fa72329c07..f6ee87dc040 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.h
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -56,8 +56,586 @@ static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
     VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
 };
 
+static const WORD main_key_vkey_qwerty_jp106[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    0,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_7,VK_OEM_5,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_3,VK_OEM_4,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_PLUS,VK_OEM_1,VK_OEM_6,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_v2[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_5,'1','2','3','4','5','6','7','8','9','0',VK_OEM_PLUS,VK_OEM_4,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_3,VK_OEM_7,VK_OEM_2,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_MINUS,
+};
+
+static const WORD main_key_vkey_qwertz[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Z','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Y','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_abnt_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_8,VK_OEM_5,
+    VK_OEM_7,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_102,
+};
+
+static const WORD main_key_vkey_colemak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','F','P','G','J','L','U','Y',VK_OEM_1,VK_OEM_4,VK_OEM_6,
+    'A','R','S','T','D','H','N','E','I','O',VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','K','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_azerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_7,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_PLUS,0,
+    'A','Z','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'Q','S','D','F','G','H','J','K','L','M',VK_OEM_3,VK_OEM_5,
+    VK_OEM_102,'W','X','C','V','B','N',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_8,
+};
+
+static const WORD main_key_vkey_dvorak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_6,0,
+    VK_OEM_7,VK_OEM_COMMA,VK_OEM_PERIOD,'P','Y','F','G','C','R','L',VK_OEM_2,VK_OEM_PLUS,
+    'A','O','E','U','I','D','H','T','N','S',VK_OEM_MINUS,VK_OEM_5,
+    VK_OEM_102,VK_OEM_1,'Q','J','K','X','B','M','W','V','Z',
+};
+
 #define K(x) XKB_KEY_##x
 
+static const xkb_keysym_t main_key_symbols_be[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+   {K(twosuperior), K(threesuperior)}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {K(section), '6'}, {K(egrave), '7'}, {'!', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+   {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', '*'},
+    /* Row C: AC01-AC12 */
+   {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {K(mu), K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+   {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'=', '+'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_bds[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'(', ')'}, {'1', '!'}, {'2', '?'}, {'3', '+'}, {'4', '"'}, {'5', '%'}, {'6', '='}, {'7', ':'}, {'8', '/'}, {'9', K(endash)}, {'0', K(numerosign)}, {'-', '$'}, {'.', K(EuroSign)}, {},
+    /* Row D: AD01-AD12 */
+    {',', K(Cyrillic_yeru)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {';', K(section)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(doublelowquotemark), K(leftdoublequotemark)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_e), K(Cyrillic_E)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_che), K(Cyrillic_CHE)}, {'1', '!'}, {'2', '@'}, {'3', K(numerosign)}, {'4', '$'}, {'5', '%'}, {'6', K(EuroSign)}, {'7', K(section)}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', K(endash)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_yu), K(Cyrillic_YU)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', K(doublelowquotemark)}, {'.', K(leftdoublequotemark)}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_br_abnt2[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', '"'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_diaeresis)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_acute), K(dead_grave)}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(dead_tilde), K(dead_circumflex)}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+   {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {';', ':'}, {'/', '?'},
+};
+
+static const xkb_keysym_t main_key_symbols_by[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Byelorussian_shortu), K(Byelorussian_SHORTU)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {'\'', '\''},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ca[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'#', '|'}, {'1', '!'}, {'2', '"'}, {'3', '/'}, {'4', '$'}, {'5', '%'}, {'6', '?'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_circumflex)}, {K(dead_cedilla), K(dead_diaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_grave), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '\''}, {'.', '.'}, {K(eacute), K(Eacute)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(egrave)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(eacute)}, {K(adiaeresis), K(agrave)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(udiaeresis)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(odiaeresis)}, {K(agrave), K(adiaeresis)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz_qwerty[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_circumflex), K(degree)}, {'1', '!'}, {'2', '"'}, {'3', K(section)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(ssharp), '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'#', '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_dk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(onehalf), K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(oslash), K(Oslash)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ee[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_caron), K(dead_tilde)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {K(otilde), K(Otilde)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_es[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(masculine), K(ordfeminine)}, {'1', '!'}, {'2', '"'}, {'3', K(periodcentered)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(exclamdown), K(questiondown)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_grave), K(dead_circumflex)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ntilde), K(Ntilde)}, {K(dead_acute), K(dead_diaeresis)}, {K(ccedilla), K(Ccedilla)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fi[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(twosuperior), '~'}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {'-', '6'}, {K(egrave), '7'}, {'_', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', K(sterling)},
+    /* Row C: AC01-AC12 */
+    {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {'*', K(mu)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'!', K(section)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gb[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', K(notsign)}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '@'}, {'#', '~'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {K(Greek_finalsmallsigma), K(Greek_SIGMA)}, {K(Greek_epsilon), K(Greek_EPSILON)}, {K(Greek_rho), K(Greek_RHO)}, {K(Greek_tau), K(Greek_TAU)}, {K(Greek_upsilon), K(Greek_UPSILON)}, {K(Greek_theta), K(Greek_THETA)}, {K(Greek_iota), K(Greek_IOTA)}, {K(Greek_omicron), K(Greek_OMICRON)}, {K(Greek_pi), K(Greek_PI)}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {K(Greek_alpha), K(Greek_ALPHA)}, {K(Greek_sigma), K(Greek_SIGMA)}, {K(Greek_delta), K(Greek_DELTA)}, {K(Greek_phi), K(Greek_PHI)}, {K(Greek_gamma), K(Greek_GAMMA)}, {K(Greek_eta), K(Greek_ETA)}, {K(Greek_xi), K(Greek_XI)}, {K(Greek_kappa), K(Greek_KAPPA)}, {K(Greek_lamda), K(Greek_LAMDA)}, {K(dead_acute), K(dead_diaeresis)}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {K(Greek_zeta), K(Greek_ZETA)}, {K(Greek_chi), K(Greek_CHI)}, {K(Greek_psi), K(Greek_PSI)}, {K(Greek_omega), K(Greek_OMEGA)}, {K(Greek_beta), K(Greek_BETA)}, {K(Greek_nu), K(Greek_NU)}, {K(Greek_mu), K(Greek_MU)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hu[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'0', K(section)}, {'1', '\''}, {'2', '"'}, {'3', '+'}, {'4', '!'}, {'5', '%'}, {'6', '/'}, {'7', '='}, {'8', '('}, {'9', ')'}, {K(odiaeresis), K(Odiaeresis)}, {K(udiaeresis), K(Udiaeresis)}, {K(oacute), K(Oacute)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(odoubleacute), K(Odoubleacute)}, {K(uacute), K(Uacute)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(Eacute)}, {K(aacute), K(Aacute)}, {K(udoubleacute), K(Udoubleacute)},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(iacute), K(Iacute)}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', ')'}, {'0', '('}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'/', 'Q'}, {'\'', 'W'}, {K(hebrew_qoph), 'E'}, {K(hebrew_resh), 'R'}, {K(hebrew_aleph), 'T'}, {K(hebrew_tet), 'Y'}, {K(hebrew_waw), 'U'}, {K(hebrew_finalnun), 'I'}, {K(hebrew_finalmem), 'O'}, {K(hebrew_pe), 'P'}, {']', '}'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_shin), 'A'}, {K(hebrew_dalet), 'S'}, {K(hebrew_gimel), 'D'}, {K(hebrew_kaph), 'F'}, {K(hebrew_ayin), 'G'}, {K(hebrew_yod), 'H'}, {K(hebrew_chet), 'J'}, {K(hebrew_lamed), 'K'}, {K(hebrew_finalkaph), 'L'}, {K(hebrew_finalpe), ':'}, {',', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), 'Z'}, {K(hebrew_samech), 'X'}, {K(hebrew_bet), 'C'}, {K(hebrew_he), 'V'}, {K(hebrew_nun), 'B'}, {K(hebrew_mem), 'N'}, {K(hebrew_zade), 'M'}, {K(hebrew_taw), '>'}, {K(hebrew_finalzade), '<'}, {'.', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(hebrew_qoph), K(hebrew_qoph)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_resh), K(hebrew_resh)}, {K(hebrew_taw), K(hebrew_tet)}, {K(hebrew_ayin), K(hebrew_ayin)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_samech), K(hebrew_samech)}, {K(hebrew_pe), K(hebrew_finalpe)}, {}, {},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_shin), K(hebrew_shin)}, {K(hebrew_dalet), K(hebrew_dalet)}, {K(hebrew_pe), K(hebrew_finalpe)}, {K(hebrew_gimel), K(hebrew_gimel)}, {K(hebrew_he), K(hebrew_he)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_kaph), K(hebrew_finalkaph)}, {K(hebrew_lamed), K(hebrew_lamed)}, {}, {}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), K(hebrew_zain)}, {K(hebrew_chet), K(hebrew_chet)}, {K(hebrew_zade), K(hebrew_finalzade)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_bet), K(hebrew_bet)}, {K(hebrew_nun), K(hebrew_finalnun)}, {K(hebrew_mem), K(hebrew_finalmem)}, {}, {}, {}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_is[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_abovering), K(dead_diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(odiaeresis), K(Odiaeresis)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(eth), K(ETH)}, {'\'', '?'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(dead_acute), K(dead_acute)}, {'+', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {K(thorn), K(THORN)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_it[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(igrave), '^'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(eacute)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ograve), K(ccedilla)}, {K(agrave), K(degree)}, {K(ugrave), K(section)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_106[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '~'}, {'-', '='}, {'^', '~'}, {'\\', '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_kana86[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', K(kana_WO)}, {'-', '='}, {'^', '~'}, {K(yen), '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_mac[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {K(kana_NU)}, {K(kana_FU)}, {K(kana_A), K(kana_a)}, {K(kana_U), K(kana_u)}, {K(kana_E), K(kana_e)}, {K(kana_O), K(kana_o)}, {K(kana_YA), K(kana_ya)}, {K(kana_YU), K(kana_yu)}, {K(kana_YO), K(kana_yo)}, {K(kana_WA), K(kana_WO)}, {K(kana_HO)}, {K(kana_HE)}, {K(prolongedsound)},
+    /* Row D: AD01-AD12 */
+    {K(kana_TA)}, {K(kana_TE)}, {K(kana_I), K(kana_i)}, {K(kana_SU)}, {K(kana_KA)}, {K(kana_N)}, {K(kana_NA)}, {K(kana_NI)}, {K(kana_RA)}, {K(kana_SE)}, {K(voicedsound)}, {K(semivoicedsound), K(kana_openingbracket)},
+    /* Row C: AC01-AC12 */
+    {K(kana_CHI)}, {K(kana_TO)}, {K(kana_SHI)}, {K(kana_HA)}, {K(kana_KI)}, {K(kana_KU)}, {K(kana_MA)}, {K(kana_NO)}, {K(kana_RI)}, {K(kana_RE)}, {K(kana_KE)}, {K(kana_MU), K(kana_closingbracket)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(kana_TSU), K(kana_tsu)}, {K(kana_SA)}, {K(kana_SO)}, {K(kana_HI)}, {K(kana_KO)}, {K(kana_MI)}, {K(kana_MO)}, {K(kana_NE), K(kana_comma)}, {K(kana_RU), K(kana_fullstop)}, {K(kana_ME), K(kana_conjunctive)}, {K(kana_RO)},
+};
+
+static const xkb_keysym_t main_key_symbols_lt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {K(aogonek), K(Aogonek)}, {K(ccaron), K(Ccaron)}, {K(eogonek), K(Eogonek)}, {K(eabovedot), K(Eabovedot)}, {K(iogonek), K(Iogonek)}, {K(scaron), K(Scaron)}, {K(uogonek), K(Uogonek)}, {K(umacron), K(Umacron)}, {K(doublelowquotemark), '('}, {K(leftdoublequotemark), ')'}, {'-', '_'}, {K(zcaron), K(Zcaron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(endash), K(EuroSign)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_nl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'@', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '_'}, {'8', '('}, {'9', ')'}, {'0', '\''}, {'/', '?'}, {K(degree), K(dead_tilde)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_diaeresis), K(dead_circumflex)}, {'*', '|'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'+', K(plusminus)}, {K(dead_acute), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {']', '['}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '='}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_no[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'|', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {'\\', K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(oslash), K(Oslash)}, {K(ae), K(AE)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl_dvp[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'$', '~'}, {'&', '%'}, {'[', '7'}, {'{', '5'}, {'}', '3'}, {'(', '1'}, {'=', '9'}, {'*', '0'}, {')', '2'}, {'+', '4'}, {']', '6'}, {'!', '8'}, {'#', '`'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'@', '^'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'\'', '"'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(guillemotleft), K(guillemotright)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'+', '*'}, {K(dead_acute), K(dead_grave)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(masculine), K(ordfeminine)}, {K(dead_tilde), K(dead_circumflex)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_yu), K(Cyrillic_YU)}, {'1', '!'}, {'2', '@'}, {'3', K(Cyrillic_io)}, {'4', K(Cyrillic_IO)}, {'5', K(Cyrillic_hardsign)}, {'6', K(Cyrillic_HARDSIGN)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_e), K(Cyrillic_E)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'|', K(brokenbar)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_rs[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] = {
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_lje), K(Cyrillic_LJE)}, {K(Cyrillic_nje), K(Cyrillic_NJE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Serbian_dje), K(Serbian_DJE)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_je), K(Cyrillic_JE)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Serbian_tshe), K(Serbian_TSHE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_dzhe), K(Cyrillic_DZHE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_se[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_si[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(cedilla), K(diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_sk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(lcaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(tcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {K(adiaeresis), '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ocircumflex), '"'}, {K(section), '!'}, {K(ncaron), ')'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_th[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'_', '%'}, {K(Thai_lakkhangyao), '+'}, {'/', K(Thai_leknung)}, {'-', K(Thai_leksong)}, {K(Thai_phosamphao), K(Thai_leksam)}, {K(Thai_thothung), K(Thai_leksi)}, {K(Thai_sarau), K(Thai_sarauu)}, {K(Thai_saraue), K(Thai_baht)}, {K(Thai_khokhwai), K(Thai_lekha)}, {K(Thai_totao), K(Thai_lekhok)}, {K(Thai_chochan), K(Thai_lekchet)}, {K(Thai_khokhai), K(Thai_lekpaet)}, {K(Thai_chochang), K(Thai_lekkao)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Thai_maiyamok), K(Thai_leksun)}, {K(Thai_saraaimaimalai), '"'}, {K(Thai_saraam), K(Thai_dochada)}, {K(Thai_phophan), K(Thai_thonangmontho)}, {K(Thai_saraa), K(Thai_thothong)}, {K(Thai_maihanakat), K(Thai_nikhahit)}, {K(Thai_saraii), K(Thai_maitri)}, {K(Thai_rorua), K(Thai_nonen)}, {K(Thai_nonu), K(Thai_paiyannoi)}, {K(Thai_yoyak), K(Thai_yoying)}, {K(Thai_bobaimai), K(Thai_thothan)}, {K(Thai_loling), ','},
+    /* Row C: AC01-AC12 */
+    {K(Thai_fofan), K(Thai_ru)}, {K(Thai_hohip), K(Thai_khorakhang)}, {K(Thai_kokai), K(Thai_topatak)}, {K(Thai_dodek), K(Thai_sarao)}, {K(Thai_sarae), K(Thai_chochoe)}, {K(Thai_maitho), K(Thai_maitaikhu)}, {K(Thai_maiek), K(Thai_maichattawa)}, {K(Thai_saraaa), K(Thai_sorusi)}, {K(Thai_sosua), K(Thai_sosala)}, {K(Thai_wowaen), K(Thai_soso)}, {K(Thai_ngongu), '.'}, {K(Thai_khokhuat), K(Thai_khokhon)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Thai_phophung), '('}, {K(Thai_popla), ')'}, {K(Thai_saraae), K(Thai_choching)}, {K(Thai_oang), K(Thai_honokhuk)}, {K(Thai_sarai), K(Thai_phinthu)}, {K(Thai_sarauee), K(Thai_thanthakhat)}, {K(Thai_thothahan), '?'}, {K(Thai_moma), K(Thai_thophuthao)}, {K(Thai_saraaimaimuan), K(Thai_lochula)}, {K(Thai_fofa), K(Thai_lu)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'"', K(eacute)}, {'1', '!'}, {'2', '\''}, {'3', '^'}, {'4', '+'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'*', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {K(idotless), 'I'}, {'o', 'O'}, {'p', 'P'}, {K(gbreve), K(Gbreve)}, {K(udiaeresis), K(Udiaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(scedilla), K(Scedilla)}, {'i', K(Iabovedot)}, {',', ';'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {K(odiaeresis), K(Odiaeresis)}, {K(ccedilla), K(Ccedilla)}, {'.', ':'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr_f[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'+', '*'}, {'1', '!'}, {'2', '"'}, {'3', '^'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '='}, {'/', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'f', 'F'}, {'g', 'G'}, {K(gbreve), K(Gbreve)}, {K(idotless), 'I'}, {'o', 'O'}, {'d', 'D'}, {'r', 'R'}, {'n', 'N'}, {'h', 'H'}, {'p', 'P'}, {'q', 'Q'}, {'w', 'W'},
+    /* Row C: AC01-AC12 */
+    {'u', 'U'}, {'i', K(Iabovedot)}, {'e', 'E'}, {'a', 'A'}, {K(udiaeresis), K(Udiaeresis)}, {'t', 'T'}, {'k', 'K'}, {'m', 'M'}, {'l', 'L'}, {'y', 'Y'}, {K(scedilla), K(Scedilla)}, {'x', 'X'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'j', 'J'}, {K(odiaeresis), K(Odiaeresis)}, {'v', 'V'}, {'c', 'C'}, {K(ccedilla), K(Ccedilla)}, {'z', 'Z'}, {'s', 'S'}, {'b', 'B'}, {'.', ':'}, {',', ';'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ua[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', 0x10002bc}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Ukrainian_yi), K(Ukrainian_YI)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Ukrainian_ie), K(Ukrainian_IE)}, {K(Ukrainian_ghe_with_upturn), K(Ukrainian_GHE_WITH_UPTURN)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
 static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
 {
     /* Row E: TLDE, AE01-AE13 */
@@ -70,8 +648,83 @@ static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN
     {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
 };
 
+
+static const xkb_keysym_t main_key_symbols_us_colemak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'f', 'F'}, {'p', 'P'}, {'g', 'G'}, {'j', 'J'}, {'l', 'L'}, {'u', 'U'}, {'y', 'Y'}, {';', ':'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'d', 'D'}, {'h', 'H'}, {'n', 'N'}, {'e', 'E'}, {'i', 'I'}, {'o', 'O'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'-', '_'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'k', 'K'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_dvorak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'[', '{'}, {']', '}'}, {},
+    /* Row D: AD01-AD12 */
+    {'\'', '"'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'=', '+'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {';', ':'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_intl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_grave), K(dead_tilde)}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_circumflex)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_acute), K(dead_diaeresis)}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
 #undef K
 
+/*** The VNC keyboard layout is a special case */
+
+static const WORD main_key_scan_vnc[MAIN_KEY_LEN] =
+{
+    0x02,0x03,0x04,0x05,0x06,0x07,
+    0x08,0x09,0x0A,0x0B,0x0C,0x0D,
+    0x1A,0x1B,0x27,0x28,0x29,0x33,
+    0x34,0x35,0x2B,0x1E,0x30,0x2E,
+    0x20,0x12,0x21,0x22,0x23,0x17,
+    0x24,0x25,0x26,0x32,0x31,0x18,
+    0x19,0x10,0x13,0x1F,0x14,0x16,
+    0x2F,0x11,0x2D,0x15,0x2C,0x56
+};
+
+static const WORD main_key_vkey_vnc[MAIN_KEY_LEN] =
+{
+    '1','2','3','4','5','6',
+    '7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,
+    VK_OEM_4,VK_OEM_6,VK_OEM_1,VK_OEM_7,VK_OEM_3,VK_OEM_COMMA,
+    VK_OEM_PERIOD,VK_OEM_2,VK_OEM_5, 'A','B','C',
+    'D','E','F','G','H','I',
+    'J','K','L','M','N','O',
+    'P','Q','R','S','T','U',
+    'V','W','X','Y','Z', VK_OEM_102
+};
+
+static const xkb_keysym_t main_key_symbols_vnc[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'},
+    {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'},
+    {'[', '{'}, {']', '}'}, {';', ':'}, {'\'', '"'}, {'`', '~'}, {',', '<'},
+    {'.', '>'}, {'/', '?'}, {'\\', '|'}, {'a', 'A'}, {'b', 'B'}, {'c', 'C'},
+    {'d', 'D'}, {'e', 'E'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'i', 'I'},
+    {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {'n', 'N'}, {'o', 'O'},
+    {'p', 'P'}, {'q', 'Q'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'u', 'U'},
+    {'v', 'V'}, {'w', 'W'}, {'x', 'X'}, {'y', 'Y'}, {'z', 'Z'}
+};
+
 /*** Layout table. Add your keyboard mappings to this list */
 static struct {
     LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
@@ -81,7 +734,53 @@ static struct {
     const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
     const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
 } main_key_tab[]={
+    {0x0402, "bg_bds", &main_key_symbols_bg_bds, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0402, "bg_phonetic", &main_key_symbols_bg_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz", &main_key_symbols_cz, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz_qwerty", &main_key_symbols_cz_qwerty, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0406, "dk", &main_key_symbols_dk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0407, "de", &main_key_symbols_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0408, "gr", &main_key_symbols_gr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
     {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us_colemak", &main_key_symbols_us_colemak, &main_key_scan_ps2_set1, &main_key_vkey_colemak},
+    {0x0409, "us_dvorak", &main_key_symbols_us_dvorak, &main_key_scan_ps2_set1, &main_key_vkey_dvorak},
+    {0x0409, "us_intl", &main_key_symbols_us_intl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "vnc", &main_key_symbols_vnc, &main_key_scan_vnc, &main_key_vkey_vnc},
+    {0x040a, "es", &main_key_symbols_es, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040b, "fi", &main_key_symbols_fi, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040c, "fr", &main_key_symbols_fr, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x040d, "il", &main_key_symbols_il, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040d, "il_phonetic", &main_key_symbols_il_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040e, "hu", &main_key_symbols_hu, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x040f, "is", &main_key_symbols_is, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0410, "it", &main_key_symbols_it, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_106", &main_key_symbols_jp_106, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0411, "jp_kana86", &main_key_symbols_jp_kana86, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_mac", &main_key_symbols_jp_mac, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0413, "nl", &main_key_symbols_nl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0414, "no", &main_key_symbols_no, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0415, "pl_dvp", &main_key_symbols_pl_dvp, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0416, "br_abnt2", &main_key_symbols_br_abnt2, &main_key_scan_ps2_set1, &main_key_vkey_abnt_qwerty},
+    {0x0419, "ru", &main_key_symbols_ru, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0419, "ru_phonetic", &main_key_symbols_ru_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041a, "hr", &main_key_symbols_hr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x041b, "sk", &main_key_symbols_sk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041d, "se", &main_key_symbols_se, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_v2},
+    {0x041e, "th", &main_key_symbols_th, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr_f", &main_key_symbols_tr_f, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr", &main_key_symbols_tr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0422, "ua", &main_key_symbols_ua, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0423, "by", &main_key_symbols_by, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0424, "si", &main_key_symbols_si, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0425, "ee", &main_key_symbols_ee, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0427, "lt", &main_key_symbols_lt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0807, "ch_de", &main_key_symbols_ch_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0809, "gb", &main_key_symbols_gb, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x080c, "be", &main_key_symbols_be, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x0816, "pt", &main_key_symbols_pt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c0c, "ca", &main_key_symbols_ca, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c1a, "rs", &main_key_symbols_rs, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x100c, "ch_fr", &main_key_symbols_ch_fr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
 };
 
 const WORD xkb_keysym_0xff00_to_vkey[256] DECLSPEC_HIDDEN =
-- 
2.39.0.rc2

From 483fa6d810e9cf6826cd2c64327f54134821dc06 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:14:40 +0300
Subject: [PATCH 057/202] winewayland.drv: Implement ToUnicodeEx.

We use the the current XKB layout and XKB compose state to perform the
translation.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 283 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   4 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 288 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 84e452057f6..5f4ce5ac5cd 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -43,6 +43,7 @@
 #include "ntuser.h"
 
 #include <linux/input.h>
+#include <stdlib.h>
 #include <sys/mman.h>
 #include <unistd.h>
 
@@ -63,6 +64,47 @@ static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
            keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
 }
 
+static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    xkb_keycode_t i, candidate = 0;
+
+    if (vkey == 0) return 0;
+
+    switch (vkey)
+    {
+    case VK_NUMPAD0: vkey = VK_INSERT; break;
+    case VK_NUMPAD1: vkey = VK_END; break;
+    case VK_NUMPAD2: vkey = VK_DOWN; break;
+    case VK_NUMPAD3: vkey = VK_NEXT; break;
+    case VK_NUMPAD4: vkey = VK_LEFT; break;
+    case VK_NUMPAD5: vkey = VK_CLEAR; break;
+    case VK_NUMPAD6: vkey = VK_RIGHT; break;
+    case VK_NUMPAD7: vkey = VK_HOME; break;
+    case VK_NUMPAD8: vkey = VK_UP; break;
+    case VK_NUMPAD9: vkey = VK_PRIOR; break;
+    case VK_DECIMAL: vkey = VK_DELETE; break;
+
+    case VK_INSERT: case VK_END: case VK_DOWN: case VK_NEXT:
+    case VK_LEFT: case VK_RIGHT: case VK_HOME: case VK_UP:
+    case VK_PRIOR: case VK_DELETE:
+        vkey |= 0xe000;
+        break;
+    default: break;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey); i++)
+    {
+        if (keyboard->xkb_keycode_to_vkey[i] == (vkey & 0xff))
+        {
+            candidate = i;
+            if ((keyboard->xkb_keycode_to_scancode[i] & 0xff00) == (vkey & 0xff00))
+                break;
+        }
+    }
+
+    return candidate;
+}
+
 /* xkb keycodes are offset by 8 from linux input keycodes. */
 static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 {
@@ -83,6 +125,64 @@ static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
     __wine_send_input(hwnd, &input, NULL);
 }
 
+static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
+{
+    switch (xkb_keysym)
+    {
+    case XKB_KEY_dead_grave: return 0x0060;
+    case XKB_KEY_dead_acute: return 0x00B4;
+    case XKB_KEY_dead_circumflex: return 0x005E;
+    case XKB_KEY_dead_tilde: return 0x007E;
+    case XKB_KEY_dead_macron: return 0x00AF;
+    case XKB_KEY_dead_breve: return 0x02D8;
+    case XKB_KEY_dead_abovedot: return 0x02D9;
+    case XKB_KEY_dead_diaeresis: return 0x00A8;
+    case XKB_KEY_dead_abovering: return 0x02DA;
+    case XKB_KEY_dead_doubleacute: return 0x02DD;
+    case XKB_KEY_dead_caron: return 0x02C7;
+    case XKB_KEY_dead_cedilla: return 0x00B8;
+    case XKB_KEY_dead_ogonek: return 0x02DB;
+    case XKB_KEY_dead_iota: return 0x037A;
+    case XKB_KEY_dead_voiced_sound: return 0x309B;
+    case XKB_KEY_dead_semivoiced_sound: return 0x309C;
+    case XKB_KEY_dead_belowdot: return 0x002E;
+    case XKB_KEY_dead_stroke: return 0x002D;
+    case XKB_KEY_dead_abovecomma: return 0x1FBF;
+    case XKB_KEY_dead_abovereversedcomma: return 0x1FFE;
+    case XKB_KEY_dead_doublegrave: return 0x02F5;
+    case XKB_KEY_dead_belowring: return 0x02F3;
+    case XKB_KEY_dead_belowmacron: return 0x02CD;
+    case XKB_KEY_dead_belowtilde: return 0x02F7;
+    case XKB_KEY_dead_currency: return 0x00A4;
+    case XKB_KEY_dead_lowline: return 0x005F;
+    case XKB_KEY_dead_aboveverticalline: return 0x02C8;
+    case XKB_KEY_dead_belowverticalline: return 0x02CC;
+    case XKB_KEY_dead_longsolidusoverlay: return 0x002F;
+    case XKB_KEY_dead_a: return 0x0061;
+    case XKB_KEY_dead_A: return 0x0041;
+    case XKB_KEY_dead_e: return 0x0065;
+    case XKB_KEY_dead_E: return 0x0045;
+    case XKB_KEY_dead_i: return 0x0069;
+    case XKB_KEY_dead_I: return 0x0049;
+    case XKB_KEY_dead_o: return 0x006F;
+    case XKB_KEY_dead_O: return 0x004F;
+    case XKB_KEY_dead_u: return 0x0075;
+    case XKB_KEY_dead_U: return 0x0055;
+    case XKB_KEY_dead_small_schwa: return 0x0259;
+    case XKB_KEY_dead_capital_schwa: return 0x018F;
+    /* The following are non-spacing characters, couldn't find good
+     * spacing alternatives. */
+    case XKB_KEY_dead_hook: return 0x0309;
+    case XKB_KEY_dead_horn: return 0x031B;
+    case XKB_KEY_dead_belowcircumflex: return 0x032D;
+    case XKB_KEY_dead_belowbreve: return 0x032E;
+    case XKB_KEY_dead_belowdiaeresis: return 0x0324;
+    case XKB_KEY_dead_invertedbreve: return 0x0311;
+    case XKB_KEY_dead_belowcomma: return 0x0326;
+    default: return 0;
+    }
+}
+
 static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
 {
     switch (xkb_keycode - 8)
@@ -156,6 +256,54 @@ static BOOL wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t ke
     return TRUE;
 }
 
+static struct xkb_state *_xkb_state_new_from_wine(struct wayland_keyboard *keyboard,
+                                                  const BYTE *keystate)
+{
+    struct xkb_state *xkb_state;
+    UINT mods[] = {VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU};
+    UINT toggles[] = {VK_CAPITAL, VK_NUMLOCK, VK_SCROLL};
+    int i;
+
+    /* Create a new xkb_state using the currently active layout. */
+    xkb_state = xkb_state_new(xkb_state_get_keymap(keyboard->xkb_state));
+    if (!xkb_state) return NULL;
+    xkb_state_update_mask(xkb_state, 0, 0, 0,
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_DEPRESSED),
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_LATCHED),
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_LOCKED));
+
+    /* Update the xkb_state from the windows keyboard state by simulating
+     * keypresses. */
+    for (i = 0 ; i < ARRAY_SIZE(mods); i++)
+    {
+        if ((keystate[mods[i]] & 0x80))
+        {
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, mods[i]),
+                                 XKB_KEY_DOWN);
+        }
+    }
+
+    for (i = 0 ; i < ARRAY_SIZE(toggles); i++)
+    {
+        if ((keystate[toggles[i]] & 0x01))
+        {
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, toggles[i]),
+                                 XKB_KEY_DOWN);
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, toggles[i]),
+                                 XKB_KEY_UP);
+
+        }
+    }
+
+    return xkb_state;
+}
+
 /**********************************************************************
  *          Keyboard handling
  */
@@ -193,6 +341,8 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
 
     xkb_state_unref(wayland->keyboard.xkb_state);
     wayland->keyboard.xkb_state = xkb_state;
+    if (wayland->keyboard.xkb_compose_state)
+        xkb_compose_state_reset(wayland->keyboard.xkb_compose_state);
 
     wayland_keyboard_update_layout(&wayland->keyboard);
 
@@ -437,6 +587,17 @@ static const struct wl_keyboard_listener keyboard_listener = {
 void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
                            struct wl_keyboard *wl_keyboard)
 {
+    struct xkb_compose_table *compose_table;
+    const char *locale;
+
+    locale = getenv("LC_ALL");
+    if (!locale || !*locale)
+        locale = getenv("LC_CTYPE");
+    if (!locale || !*locale)
+        locale = getenv("LANG");
+    if (!locale || !*locale)
+        locale = "C";
+
     keyboard->wl_keyboard = wl_keyboard;
     /* Some sensible default values for the repeat rate and delay. */
     keyboard->repeat_interval_ms = 40;
@@ -447,6 +608,20 @@ void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wa
         ERR("Failed to create XKB context\n");
         return;
     }
+    compose_table =
+        xkb_compose_table_new_from_locale(keyboard->xkb_context, locale,
+                                          XKB_COMPOSE_COMPILE_NO_FLAGS);
+    if (!compose_table)
+    {
+        ERR("Failed to create XKB compose table\n");
+        return;
+    }
+
+    keyboard->xkb_compose_state =
+        xkb_compose_state_new(compose_table, XKB_COMPOSE_STATE_NO_FLAGS);
+    xkb_compose_table_unref(compose_table);
+    if (!keyboard->xkb_compose_state)
+        ERR("Failed to create XKB compose table\n");
 
     wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
 }
@@ -459,8 +634,116 @@ void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
     if (keyboard->wl_keyboard)
         wl_keyboard_destroy(keyboard->wl_keyboard);
 
+    xkb_compose_state_unref(keyboard->xkb_compose_state);
     xkb_state_unref(keyboard->xkb_state);
     xkb_context_unref(keyboard->xkb_context);
 
     memset(keyboard, 0, sizeof(*keyboard));
 }
+
+/***********************************************************************
+ *           WAYLAND_ToUnicodeEx
+ */
+INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                        LPWSTR buf, int nchars, UINT flags, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    char utf8[64];
+    int utf8_len = 0;
+    struct xkb_compose_state *compose_state = wayland->keyboard.xkb_compose_state;
+    enum xkb_compose_status compose_status = XKB_COMPOSE_NOTHING;
+    xkb_keycode_t xkb_keycode;
+    xkb_keysym_t xkb_keysym;
+    struct xkb_state *xkb_state;
+    INT ret;
+
+    if (!wayland->keyboard.xkb_state) return 0;
+
+    if (scan & 0x8000) return 0;  /* key up */
+
+    xkb_keycode = vkey_to_xkb_keycode(&wayland->keyboard, virt);
+    xkb_state = _xkb_state_new_from_wine(&wayland->keyboard, state);
+    if (!xkb_state) return 0;
+
+    /* Try to compose */
+    xkb_keysym = xkb_state_key_get_one_sym(xkb_state, xkb_keycode);
+    if (xkb_keysym != XKB_KEY_NoSymbol && compose_state &&
+        xkb_compose_state_feed(compose_state, xkb_keysym) == XKB_COMPOSE_FEED_ACCEPTED)
+    {
+        compose_status = xkb_compose_state_get_status(compose_state);
+    }
+
+    TRACE_(key)("vkey=0x%x scan=0x%x xkb_keycode=%d xkb_keysym=0x%x compose_status=%d\n",
+                virt, scan, xkb_keycode, xkb_keysym, compose_status);
+
+    if (compose_status == XKB_COMPOSE_NOTHING)
+    {
+        /* Windows converts some Ctrl modified key combinations to strings in a
+         * way different from Linux/xkbcommon (or doesn't convert them at all).
+         * Handle such combinations manually here. */
+        if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_CTRL,
+                                         XKB_STATE_MODS_EFFECTIVE))
+        {
+            if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_ALT,
+                                             XKB_STATE_MODS_EFFECTIVE))
+            {
+                ret = 0;
+                goto out;
+            }
+            if (((xkb_keysym >= XKB_KEY_exclam) && (xkb_keysym < XKB_KEY_at)) ||
+                (xkb_keysym == XKB_KEY_grave) || (xkb_keysym == XKB_KEY_Tab))
+            {
+                ret = 0;
+                goto out;
+            }
+            if (xkb_keysym == XKB_KEY_Return)
+            {
+                if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_SHIFT,
+                                                 XKB_STATE_MODS_EFFECTIVE))
+                {
+                    ret = 0;
+                }
+                else
+                {
+                    buf[0] = '\n';
+                    ret = 1;
+                }
+                goto out;
+            }
+            if (xkb_keysym == XKB_KEY_space)
+            {
+                buf[0] = ' ';
+                ret = 1;
+                goto out;
+            }
+        }
+
+        utf8_len = xkb_state_key_get_utf8(xkb_state, xkb_keycode, utf8, sizeof(utf8));
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSED)
+    {
+        utf8_len = xkb_compose_state_get_utf8(compose_state, utf8, sizeof(utf8));
+        TRACE_(key)("composed\n");
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSING && nchars > 0)
+    {
+        if ((buf[0] = dead_xkb_keysym_to_wchar(xkb_keysym)))
+        {
+            TRACE_(key)("returning dead char 0x%04x\n", buf[0]);
+            buf[1] = 0;
+            ret = -1;
+            goto out;
+        }
+    }
+
+    TRACE_(key)("utf8 len=%d '%s'\n", utf8_len, utf8_len ? utf8 : "");
+
+    if (RtlUTF8ToUnicodeN(buf, nchars, (DWORD *)&ret, utf8, utf8_len)) ret = 0;
+    else ret /= sizeof(WCHAR);
+
+out:
+    /* Zero terminate the returned string. */
+    if (ret >= 0 && ret < nchars) buf[ret] = 0;
+    xkb_state_unref(xkb_state);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b1cbe692cc4..7492f273623 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -30,6 +30,7 @@
 #include <wayland-client.h>
 #include <wayland-cursor.h>
 #include <xkbcommon/xkbcommon.h>
+#include <xkbcommon/xkbcommon-compose.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -100,6 +101,7 @@ struct wayland_keyboard
     uint32_t enter_serial;
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
+    struct xkb_compose_state *xkb_compose_state;
     UINT xkb_keycode_to_vkey[256];
     WORD xkb_keycode_to_scancode[256];
 };
@@ -483,6 +485,8 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                        LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index fb542f74ed6..d819bdb3d01 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -122,6 +122,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.39.0.rc2

From e185a9f753fcc63d8b603dba9a616ff4ce61bb5f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 1 Dec 2022 14:11:31 +0200
Subject: [PATCH 058/202] winewayland.drv: Take into account the Wayland AltGr
 state in ToUnicodeEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 28 +++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h       |  1 +
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 5f4ce5ac5cd..9884b370bb3 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -262,12 +262,23 @@ static struct xkb_state *_xkb_state_new_from_wine(struct wayland_keyboard *keybo
     struct xkb_state *xkb_state;
     UINT mods[] = {VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU};
     UINT toggles[] = {VK_CAPITAL, VK_NUMLOCK, VK_SCROLL};
+    xkb_mod_mask_t depressed_mods, latched_mods, locked_mods;
     int i;
 
-    /* Create a new xkb_state using the currently active layout. */
+    /* Create a new xkb_state using the currently active layout and the state
+     * of Mod5 (AltGr) only. */
     xkb_state = xkb_state_new(xkb_state_get_keymap(keyboard->xkb_state));
     if (!xkb_state) return NULL;
-    xkb_state_update_mask(xkb_state, 0, 0, 0,
+    depressed_mods = xkb_state_serialize_mods(keyboard->xkb_state,
+                                             XKB_STATE_MODS_DEPRESSED) &
+                     keyboard->xkb_mod5_mask;
+    latched_mods = xkb_state_serialize_mods(keyboard->xkb_state,
+                                           XKB_STATE_MODS_LATCHED) &
+                   keyboard->xkb_mod5_mask;
+    locked_mods = xkb_state_serialize_mods(keyboard->xkb_state,
+                                          XKB_STATE_MODS_LOCKED) &
+                  keyboard->xkb_mod5_mask;
+    xkb_state_update_mask(xkb_state, depressed_mods, latched_mods, locked_mods,
                           xkb_state_serialize_layout(keyboard->xkb_state,
                                                      XKB_STATE_LAYOUT_DEPRESSED),
                           xkb_state_serialize_layout(keyboard->xkb_state,
@@ -315,6 +326,7 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
     struct xkb_keymap *xkb_keymap = NULL;
     struct xkb_state *xkb_state = NULL;
     char *keymap_str;
+    xkb_mod_index_t i, num_mods;
 
     TRACE("format=%d fd=%d size=%d\n", format, fd, size);
 
@@ -334,6 +346,18 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
     if (!xkb_keymap)
         goto out;
 
+    /* Find the Mod5 (i.e., AltGr) mask */
+    wayland->keyboard.xkb_mod5_mask = 0;
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (!strcmp(xkb_keymap_mod_get_name(xkb_keymap, i), "Mod5"))
+        {
+            wayland->keyboard.xkb_mod5_mask = (1 << i);
+            break;
+        }
+    }
+
     xkb_state = xkb_state_new(xkb_keymap);
     xkb_keymap_unref(xkb_keymap);
     if (!xkb_state)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7492f273623..32e7bce8e9f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -104,6 +104,7 @@ struct wayland_keyboard
     struct xkb_compose_state *xkb_compose_state;
     UINT xkb_keycode_to_vkey[256];
     WORD xkb_keycode_to_scancode[256];
+    xkb_mod_mask_t xkb_mod5_mask;
 };
 
 struct wayland_cursor
-- 
2.39.0.rc2

From b98fcdaef42341b2b8a57f9d9d7e81f26295a5ed Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:20:54 +0300
Subject: [PATCH 059/202] winewayland.drv: Implement GetKeyNameText.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 216 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 218 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 9884b370bb3..006e06bc4b1 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -50,6 +50,105 @@
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
+/* xkb_keysym_t fixed maps from wayland_keyboard_layout.h. */
+extern const WORD xkb_keysym_0xff00_to_vkey[256];
+extern const WORD xkb_keysym_0xff00_to_scan[256];
+extern const WORD xkb_keysym_xfree86_to_vkey[256];
+extern const WORD xkb_keysym_xfree86_to_scan[256];
+
+static const struct
+{
+    DWORD       vkey;
+    const char *name;
+} vkey_names[] = {
+    { VK_ADD,                   "Num +" },
+    { VK_BACK,                  "Backspace" },
+    { VK_CAPITAL,               "Caps Lock" },
+    { VK_CONTROL,               "Ctrl" },
+    { VK_DECIMAL,               "Num Del" },
+    { VK_DELETE,                "Delete" },
+    { VK_DIVIDE,                "Num /" },
+    { VK_DOWN,                  "Down" },
+    { VK_END,                   "End" },
+    { VK_ESCAPE,                "Esc" },
+    { VK_F1,                    "F1" },
+    { VK_F2,                    "F2" },
+    { VK_F3,                    "F3" },
+    { VK_F4,                    "F4" },
+    { VK_F5,                    "F5" },
+    { VK_F6,                    "F6" },
+    { VK_F7,                    "F7" },
+    { VK_F8,                    "F8" },
+    { VK_F9,                    "F9" },
+    { VK_F10,                   "F10" },
+    { VK_F11,                   "F11" },
+    { VK_F12,                   "F12" },
+    { VK_F13,                   "F13" },
+    { VK_F14,                   "F14" },
+    { VK_F15,                   "F15" },
+    { VK_F16,                   "F16" },
+    { VK_F17,                   "F17" },
+    { VK_F18,                   "F18" },
+    { VK_F19,                   "F19" },
+    { VK_F20,                   "F20" },
+    { VK_F21,                   "F21" },
+    { VK_F22,                   "F22" },
+    { VK_F23,                   "F23" },
+    { VK_F24,                   "F24" },
+    { VK_HELP,                  "Help" },
+    { VK_HOME,                  "Home" },
+    { VK_INSERT,                "Insert" },
+    { VK_LCONTROL,              "Ctrl" },
+    { VK_LEFT,                  "Left" },
+    { VK_LMENU,                 "Alt" },
+    { VK_LSHIFT,                "Shift" },
+    { VK_LWIN,                  "Win" },
+    { VK_MENU,                  "Alt" },
+    { VK_MULTIPLY,              "Num *" },
+    { VK_NEXT,                  "Page Down" },
+    { VK_NUMLOCK,               "Num Lock" },
+    { VK_NUMPAD0,               "Num 0" },
+    { VK_NUMPAD1,               "Num 1" },
+    { VK_NUMPAD2,               "Num 2" },
+    { VK_NUMPAD3,               "Num 3" },
+    { VK_NUMPAD4,               "Num 4" },
+    { VK_NUMPAD5,               "Num 5" },
+    { VK_NUMPAD6,               "Num 6" },
+    { VK_NUMPAD7,               "Num 7" },
+    { VK_NUMPAD8,               "Num 8" },
+    { VK_NUMPAD9,               "Num 9" },
+    { VK_OEM_CLEAR,             "Num Clear" },
+    { VK_OEM_NEC_EQUAL,         "Num =" },
+    { VK_PRIOR,                 "Page Up" },
+    { VK_RCONTROL,              "Right Ctrl" },
+    { VK_RETURN,                "Return" },
+    { VK_RETURN,                "Num Enter" },
+    { VK_RIGHT,                 "Right" },
+    { VK_RMENU,                 "Right Alt" },
+    { VK_RSHIFT,                "Right Shift" },
+    { VK_RWIN,                  "Right Win" },
+    { VK_SEPARATOR,             "Num ," },
+    { VK_SHIFT,                 "Shift" },
+    { VK_SPACE,                 "Space" },
+    { VK_SUBTRACT,              "Num -" },
+    { VK_TAB,                   "Tab" },
+    { VK_UP,                    "Up" },
+    { VK_VOLUME_DOWN,           "Volume Down" },
+    { VK_VOLUME_MUTE,           "Mute" },
+    { VK_VOLUME_UP,             "Volume Up" },
+    { VK_OEM_MINUS,             "-" },
+    { VK_OEM_PLUS,              "=" },
+    { VK_OEM_1,                 ";" },
+    { VK_OEM_2,                 "/" },
+    { VK_OEM_3,                 "`" },
+    { VK_OEM_4,                 "[" },
+    { VK_OEM_5,                 "\\" },
+    { VK_OEM_6,                 "]" },
+    { VK_OEM_7,                 "'" },
+    { VK_OEM_COMMA,             "," },
+    { VK_OEM_PERIOD,            "." },
+};
+
 static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
                                       xkb_keycode_t xkb_keycode)
 {
@@ -57,6 +156,18 @@ static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
            keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
 }
 
+static xkb_keycode_t scancode_to_xkb_keycode(struct wayland_keyboard *keyboard, WORD scan)
+{
+    UINT j;
+
+    if (scan == 0) return 0;
+
+    for (j = 0; j < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode); j++)
+        if (keyboard->xkb_keycode_to_scancode[j] == scan) return j;
+
+    return 0;
+}
+
 static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
                                  xkb_keycode_t xkb_keycode)
 {
@@ -105,6 +216,51 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return candidate;
 }
 
+static WORD scancode_to_vkey_fixed(UINT scan)
+{
+    int i;
+
+    if (scan == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_scan[i] == scan &&
+            xkb_keysym_0xff00_to_vkey[i] != 0)
+        {
+            return xkb_keysym_0xff00_to_vkey[i];
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_scan[i] == scan &&
+            xkb_keysym_xfree86_to_vkey[i] != 0)
+        {
+            return xkb_keysym_xfree86_to_vkey[i];
+        }
+    }
+
+    return 0;
+}
+
+static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
+    if (!vkey) vkey = scancode_to_vkey_fixed(scan);
+    return vkey;
+}
+
+static const char* vkey_to_name(UINT vkey)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(vkey_names); j++)
+        if (vkey_names[j].vkey == vkey)
+            return vkey_names[j].name;
+
+    return NULL;
+}
+
 /* xkb keycodes are offset by 8 from linux input keycodes. */
 static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 {
@@ -771,3 +927,63 @@ out:
     xkb_state_unref(xkb_state);
     return ret;
 }
+
+/***********************************************************************
+ *           GetKeyNameText
+ */
+INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+{
+    struct wayland *wayland = thread_init_wayland();
+    int scan, vkey, len;
+    const char *name;
+    char key[2];
+
+    scan = (lparam >> 16) & 0x1FF;
+    vkey = scancode_to_vkey(&wayland->keyboard, scan);
+
+    if (lparam & (1 << 25))
+    {
+        /* Caller doesn't care about distinctions between left and
+           right keys. */
+        switch (vkey)
+        {
+        case VK_LSHIFT:
+        case VK_RSHIFT:
+            vkey = VK_SHIFT; break;
+        case VK_LCONTROL:
+        case VK_RCONTROL:
+            vkey = VK_CONTROL; break;
+        case VK_LMENU:
+        case VK_RMENU:
+            vkey = VK_MENU; break;
+        }
+    }
+
+    if ((vkey >= 0x30 && vkey <= 0x39) || (vkey >= 0x41 && vkey <= 0x5a))
+    {
+        key[0] = vkey;
+        if (vkey >= 0x41)
+            key[0] += 0x20;
+        key[1] = 0;
+        name = key;
+    }
+    else
+    {
+        name = vkey_to_name(vkey);
+    }
+
+    if (!name || RtlUTF8ToUnicodeN(buffer, size, (DWORD *)&len, name, strlen(name) + 1)) len = 0;
+    else len = len / sizeof(WCHAR) - 1;
+
+    if (!len)
+    {
+        char buf[16];
+        len = snprintf(buf, sizeof(buf), "Key 0x%02x", vkey);
+        if (len > sizeof(buf)) len = sizeof(buf);
+        len = ascii_to_unicode_z(buffer, size, buf, len);
+        if (len > 0) len--;
+    }
+
+    TRACE_(key)("lparam 0x%08x -> %s\n", (int)lparam, debugstr_w(buffer));
+    return len;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 32e7bce8e9f..b76d06d67cc 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -482,6 +482,7 @@ LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DEC
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
                                        LPDEVMODEW devmode) DECLSPEC_HIDDEN;
+INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
 NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d819bdb3d01..069e9495c0f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -120,6 +120,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
+    .pGetKeyNameText = WAYLAND_GetKeyNameText,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
-- 
2.39.0.rc2

From 08afd430f6ebeeccd83af058420b269b91c2134b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:24:49 +0300
Subject: [PATCH 060/202] winewayland.drv: Implement MapVirtualKeyEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 178 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 180 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 006e06bc4b1..8b68d3ccef2 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -216,6 +216,44 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return candidate;
 }
 
+static WORD vkey_to_scancode_fixed(UINT vkey)
+{
+    int i;
+    WORD scan = 0;
+
+    if (vkey == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_vkey[i] == vkey &&
+            xkb_keysym_0xff00_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_0xff00_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_vkey[i] == vkey &&
+            xkb_keysym_xfree86_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_xfree86_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+out:
+    return scan;
+}
+
+static WORD vkey_to_scancode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WORD scan = _xkb_keycode_to_scancode(keyboard, vkey_to_xkb_keycode(keyboard, vkey));
+    if (!scan || ((scan & 0xff00) != (vkey & 0xff00))) scan = vkey_to_scancode_fixed(vkey);
+    return scan;
+}
+
 static WORD scancode_to_vkey_fixed(UINT scan)
 {
     int i;
@@ -339,6 +377,26 @@ static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
     }
 }
 
+static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
+{
+    char utf8[64];
+    int utf8_len;
+    WCHAR wchars[8];
+    DWORD wbytes;
+
+    /* Windows doesn't emit a character for Delete. */
+    if (nsyms == 1 && syms[0] == XKB_KEY_Delete) return 0;
+
+    utf8_len = _xkb_keysyms_to_utf8(syms, nsyms, utf8, sizeof(utf8));
+
+    if (RtlUTF8ToUnicodeN(wchars, sizeof(wchars), &wbytes, utf8, utf8_len))
+        return 0;
+
+    /* TODO: normalize the keysym unicode representation. */
+
+    return wbytes >= 2 ? wchars[0] : 0;
+}
+
 static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
 {
     switch (xkb_keycode - 8)
@@ -390,6 +448,56 @@ static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
     return vkey;
 }
 
+static UINT map_vkey_to_wchar_with_deadchar_bit(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    UINT wchar;
+    xkb_keycode_t xkb_keycode;
+    struct xkb_keymap *xkb_keymap;
+    xkb_layout_index_t layout;
+    const xkb_keysym_t *syms;
+    int nsyms;
+    int level;
+
+    if (!keyboard->xkb_state) return 0;
+
+    /* Windows seems to handle alphabetical vkeys codes specially, not taking
+     * the layout into account. */
+    if (vkey >= 'A' && vkey <= 'Z') return vkey;
+
+    layout = _xkb_state_get_active_layout(keyboard->xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("no active layout, returning wchar 0\n");
+        return 0;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(keyboard->xkb_state);
+    xkb_keycode = vkey_to_xkb_keycode(keyboard, vkey);
+
+    /* Use level 1 (i.e., numlock) for numpad keys. */
+    level = ((vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9) || vkey == VK_DECIMAL) ? 1 : 0;
+
+    nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                             layout, level, &syms);
+    if (nsyms > 0)
+    {
+        /* Set the high bit to 1 if this is dead char. */
+        if ((wchar = dead_xkb_keysym_to_wchar(syms[0])))
+            wchar |= 0x80000000;
+        else
+            wchar = _xkb_keysyms_to_wchar(syms, nsyms);
+    }
+    else
+    {
+        wchar = 0;
+    }
+
+    TRACE_(key)("vkey=0x%x xkb_keycode=%d nsyms=%d xkb_keysym[0]=0x%x => wchar=0x%x\n",
+                vkey, xkb_keycode, nsyms, nsyms ? syms[0] : 0, wchar);
+
+    return wchar;
+}
+
 static BOOL wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
                                   uint32_t state, HWND hwnd)
 {
@@ -987,3 +1095,73 @@ INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
     TRACE_(key)("lparam 0x%08x -> %s\n", (int)lparam, debugstr_w(buffer));
     return len;
 }
+
+/***********************************************************************
+ *           WAYLAND_MapVirtualKeyEx
+ */
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    UINT ret = 0;
+
+    TRACE_(key)("code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl);
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+
+        if (maptype == MAPVK_VK_TO_VSC) code &= 0xff;
+        ret = vkey_to_scancode(&wayland->keyboard, code);
+        if (maptype == MAPVK_VK_TO_VSC)
+        {
+            UINT scan_prefix = (ret >> 8) & 0xff;
+            if (scan_prefix == 0xe1)
+                ret = 0;
+            else
+                ret &= 0xff;
+        }
+        break;
+    case MAPVK_VSC_TO_VK:
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey(&wayland->keyboard, code);
+        if (maptype == MAPVK_VSC_TO_VK)
+        {
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        ret = map_vkey_to_wchar_with_deadchar_bit(&wayland->keyboard, code);
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b76d06d67cc..c8dde0ffb72 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -483,6 +483,7 @@ void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary,
                                        LPDEVMODEW devmode) DECLSPEC_HIDDEN;
 INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECLSPEC_HIDDEN;
 NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 069e9495c0f..f9051fc86e7 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -121,6 +121,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
     .pGetKeyNameText = WAYLAND_GetKeyNameText,
+    .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
-- 
2.39.0.rc2

From 0838b0c2e1bc3e433e3369a35c037f0dae43beec Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:31:19 +0300
Subject: [PATCH 061/202] winewayland.drv: Implement VkKeyScanEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 93 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |  1 +
 dlls/winewayland.drv/waylanddrv_main.c  |  1 +
 3 files changed, 95 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 8b68d3ccef2..04b110abed2 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -397,6 +397,31 @@ static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
     return wbytes >= 2 ? wchars[0] : 0;
 }
 
+static SHORT _xkb_mod_mask_to_win32(struct xkb_keymap *xkb_keymap,
+                                    xkb_mod_mask_t mod_mask)
+{
+    xkb_mod_index_t num_mods, i;
+    SHORT ret = 0;
+
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (mod_mask & (1 << i))
+        {
+            const char *mod_name = xkb_keymap_mod_get_name(xkb_keymap, i);
+
+            if (!strcmp(mod_name, XKB_MOD_NAME_SHIFT))
+                ret |= 0x0100;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_CTRL))
+                ret |= 0x0200;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_ALT))
+                ret |= 0x0400;
+        }
+    }
+
+    return ret;
+}
+
 static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
 {
     switch (xkb_keycode - 8)
@@ -1165,3 +1190,71 @@ UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
     TRACE_(key)("returning 0x%04x\n", ret);
     return ret;
 }
+
+/***********************************************************************
+ *           WAYLAND_VkKeyScanEx
+ */
+SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = wayland->keyboard.xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    TRACE_(key)("ch %04x hkl %p ...\n", ch, hkl);
+
+    if (!xkb_state)
+    {
+        TRACE_(key)("... no xkb state , returning -1\n");
+        return -1;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("... no active layout, returning -1\n");
+        return -1;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+
+    /* Search through all keycodes and their shift levels for one that
+     * produces a keysym that matches the requested character. */
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+
+            if (_xkb_keysyms_to_wchar(syms, nsyms) == ch)
+            {
+                UINT vkey;
+                xkb_mod_mask_t mod_mask;
+                SHORT ret;
+
+                vkey = _xkb_keycode_to_vkey(&wayland->keyboard, xkb_keycode);
+                if (vkey == 0)
+                    continue;
+
+                xkb_keymap_key_get_mods_for_level(xkb_keymap, xkb_keycode,
+                                                  layout, level, &mod_mask, 1);
+                ret = _xkb_mod_mask_to_win32(xkb_keymap, mod_mask) | vkey;
+
+                TRACE_(key)("... returning %04x\n", ret);
+                return ret;
+            }
+        }
+    }
+
+    TRACE_(key)("... matching vkey not found, returning -1\n");
+    return -1;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c8dde0ffb72..fb10597c678 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -492,6 +492,7 @@ INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
+SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
                               const RECT *window_rect, const RECT *client_rect,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index f9051fc86e7..ceb226d8cef 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -125,6 +125,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.39.0.rc2

From 1a446a6d8697868c0aedd373c545472e84f142e8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 9 Mar 2022 13:32:42 +0200
Subject: [PATCH 062/202] winewayland.drv: Update Wine key state from Wayland
 key state.

In most cases the Wine key state is updated by Wine core as a response
to key events emitted by the Wayland driver. However there are times,
e.g., during program startup, when the Wayland key state may be set
without any corresponding key events. To handle such scenarios, update
the Wine key state whenever a surface gets the keyboard focus and
receives information about already pressed keys, or we are notified
about changes to the Wayland modifier state.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 112 +++++++++++++++++++++++-
 1 file changed, 111 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 04b110abed2..04c67bda89e 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -39,6 +39,7 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/server.h"
 
 #include "ntuser.h"
 
@@ -604,6 +605,110 @@ static struct xkb_state *_xkb_state_new_from_wine(struct wayland_keyboard *keybo
     return xkb_state;
 }
 
+static BOOL get_wine_async_key_state(BYTE state[256])
+{
+    BOOL ret;
+
+    SERVER_START_REQ(get_key_state)
+    {
+        req->async = 1;
+        req->key = -1;
+        wine_server_set_reply(req, state, 256);
+        ret = !wine_server_call(req);
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+static void set_wine_async_key_state(const BYTE state[256])
+{
+    SERVER_START_REQ(set_key_state)
+    {
+        req->async = 1;
+        wine_server_add_data(req, state, 256);
+        wine_server_call(req);
+    }
+    SERVER_END_REQ;
+}
+
+static void update_wine_key_state(BYTE *keystate, WORD vkey, int down, int lock)
+{
+    BYTE old_state = keystate[vkey];
+
+    if (down == 1) keystate[vkey] |= 0x80;
+    else if (down == 0) keystate[vkey] &= ~0x80;
+
+    if (lock == 1) keystate[vkey] |= 0x01;
+    else if (lock == 0) keystate[vkey] &= ~0x01;
+
+    if (TRACE_ON(keyboard) && keystate[vkey] != old_state)
+    {
+        TRACE("vkey=%s down=%d lock=%d state=0x%02x=>0x%02x\n",
+              vkey_to_name(vkey), down, lock, old_state, keystate[vkey]);
+    }
+}
+
+static void update_wine_lock_state(struct wayland_keyboard *keyboard)
+{
+    BYTE keystate[256];
+    struct { const char *modname; WORD vkeys[3]; } mods[] = {
+        { XKB_MOD_NAME_ALT,   { VK_MENU, VK_LMENU, VK_RMENU } },
+        { XKB_MOD_NAME_CTRL,  { VK_CONTROL, VK_LCONTROL, VK_RCONTROL } },
+        { XKB_MOD_NAME_SHIFT, { VK_SHIFT, VK_LSHIFT, VK_RSHIFT } },
+        { XKB_MOD_NAME_CAPS,  { VK_CAPITAL } },
+        { XKB_MOD_NAME_NUM,   { VK_NUMLOCK } },
+    };
+
+    if (!get_wine_async_key_state(keystate)) return;
+
+    for (int i = 0; i < ARRAY_SIZE(mods); i++)
+    {
+        WORD *vkey;
+        BOOL locked = xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                                   mods[i].modname,
+                                                   XKB_STATE_MODS_LOCKED);
+
+        for (vkey = mods[i].vkeys; *vkey; vkey++)
+            update_wine_key_state(keystate, *vkey, -1, locked);
+    }
+
+    update_wine_key_state(keystate, VK_SCROLL, -1,
+                          xkb_state_led_name_is_active(keyboard->xkb_state,
+                                                       XKB_LED_NAME_SCROLL));
+
+    set_wine_async_key_state(keystate);
+}
+
+static void update_wine_pressed_state(struct wayland_keyboard *keyboard,
+                                      struct wl_array *pressed_keys)
+{
+    uint32_t *key;
+    BYTE keystate[256];
+    int pressed[256] = { 0 };
+
+    if (!get_wine_async_key_state(keystate)) return;
+
+    wl_array_for_each(key, pressed_keys)					\
+    {
+        xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(*key);
+        UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+        pressed[vkey & 0xff] = 1;
+    }
+
+    for (WORD vkey = 0; vkey < 256; vkey++)
+        update_wine_key_state(keystate, vkey, pressed[vkey], -1);
+
+    /* Update special left/right-agnostic vkeys */
+    update_wine_key_state(keystate, VK_CONTROL,
+                          (keystate[VK_LCONTROL] | keystate[VK_RCONTROL]) & 0x80, -1);
+    update_wine_key_state(keystate, VK_MENU,
+                          (keystate[VK_LMENU] | keystate[VK_RMENU]) & 0x80, -1);
+    update_wine_key_state(keystate, VK_SHIFT,
+                          (keystate[VK_LSHIFT] | keystate[VK_RSHIFT]) & 0x80, -1);
+
+    set_wine_async_key_state(keystate);
+}
+
 /**********************************************************************
  *          Keyboard handling
  */
@@ -729,6 +834,8 @@ static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
             while (toplevel->parent) toplevel = toplevel->parent;
             NtUserSetForegroundWindow(toplevel->hwnd);
         }
+
+        update_wine_pressed_state(&wayland->keyboard, keys);
     }
 }
 
@@ -863,7 +970,10 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
     if (group != last_group)
         wayland_keyboard_update_layout(&wayland->keyboard);
 
-    /* TODO: Sync wine modifier state with XKB modifier state. */
+    /* Update the wine lock key state, in case the XKB modifier state is set
+     * without previously sending the associated key events (e.g., while another
+     * window has the focus). */
+    update_wine_lock_state(&wayland->keyboard);
 }
 
 static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
-- 
2.39.0.rc2

From 817b03491b7d9bcab761921df423a05c92b3e0ca Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 11:34:08 +0300
Subject: [PATCH 063/202] winewayland.drv: Refine heuristics for relative
 positioning of windows.

Before this commit, the simple heuristic for using a Wayland subsurface
and relative positioning to display a window was: it doesn't have a
caption AND it has an owner.

Since many applications use unowned top-level windows for various kinds
of popups, this commit enhances our heuristic to detect such windows and
use relative positioning for them too. Since for such windows we don't
have a owner window, and thus a Wayland surface parent to attach them
to, we use the most recent surface the user interacted with as the
effective owner.

The updated heuristic is: If a window has an effective owner AND it's
not a child window AND it's not minimized AND it doesn't have a caption,
min/max buttons or sysmenu AND it's relatively small compared to the
monitor size THEN we use subsurface/relative positioning.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c |   2 +
 dlls/winewayland.drv/wayland_pointer.c  |   3 +
 dlls/winewayland.drv/waylanddrv.h       |   8 +
 dlls/winewayland.drv/window.c           | 246 ++++++++++++++++++++++--
 4 files changed, 248 insertions(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 04c67bda89e..ad2753683cd 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -886,6 +886,7 @@ static void repeat_key(void *data)
     if (wayland->keyboard.repeat_interval_ms > 0)
     {
         wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+        wayland->last_event_type = INPUT_KEYBOARD;
 
         wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.last_pressed_key,
                               WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
@@ -924,6 +925,7 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
     TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
 
     wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+    wayland->last_event_type = INPUT_KEYBOARD;
 
     if (!wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd))
         return;
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 6841e8572af..0d426b17956 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -77,6 +77,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
     input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
 
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
@@ -163,6 +164,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
         input.mi.dwFlags <<= 1;
 
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
@@ -215,6 +217,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     }
 
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fb10597c678..d06a2266ec0 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -150,6 +150,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
+    int last_event_type;
     int event_notification_pipe[2];
 };
 
@@ -473,6 +474,13 @@ static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
     return !IsRectEmpty(dst);
 }
 
+static inline HWND get_focus(void)
+{
+    GUITHREADINFO info;
+    info.cbSize = sizeof(info);
+    return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndFocus : 0;
+}
+
 /**********************************************************************
  *          USER driver functions
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index c2bda5f9ca6..a9dc2967bf2 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -45,6 +45,9 @@ struct wayland_win_data
     HWND           hwnd;
     /* parent hwnd for child windows */
     HWND           parent;
+    /* effective parent hwnd (what the driver considers to
+     * be the parent for relative positioning) */
+    HWND           effective_parent;
     /* USER window rectangle relative to parent */
     RECT           window_rect;
     /* client area relative to parent */
@@ -59,6 +62,9 @@ struct wayland_win_data
     BOOL           has_pending_window_surface;
     /* whether this window is visible */
     BOOL           visible;
+    /* Save previous state to be able to decide when to recreate wayland surface */
+    HWND           old_parent;
+    RECT           old_window_rect;
     /* whether a wayland surface update is needed */
     BOOL           wayland_surface_needs_update;
 };
@@ -202,11 +208,230 @@ static struct wayland_surface *wayland_surface_for_hwnd_unlocked(HWND hwnd)
     return NULL;
 }
 
+static BOOL can_be_effective_parent(HWND hwnd, HWND parent_hwnd)
+{
+    struct wayland_surface *surface, *parent_surface;
+
+    if (parent_hwnd == 0)
+        return FALSE;
+
+    if (parent_hwnd == hwnd)
+    {
+        TRACE("hwnd=%p can't use parent=%p since it's itself\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (!(parent_surface = wayland_surface_for_hwnd_unlocked(parent_hwnd)))
+    {
+        TRACE("hwnd=%p can't use parent=%p since we are not tracking it\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (NtUserGetAncestor(hwnd, GA_PARENT) != parent_hwnd &&
+        !(NtUserGetWindowLongW(parent_hwnd, GWL_STYLE) & WS_VISIBLE))
+    {
+        TRACE("hwnd=%p (non-child) can't use parent=%p since it's not visible\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    surface = wayland_surface_for_hwnd_unlocked(hwnd);
+    parent_surface = parent_surface->parent;
+    while (parent_surface)
+    {
+        if (surface == parent_surface)
+        {
+            TRACE("hwnd=%p can't use parent=%p since hwnd is an effective ancestor\n",
+                  hwnd, parent_hwnd);
+            return FALSE;
+        }
+        parent_surface = parent_surface->parent;
+    }
+
+    return TRUE;
+}
+
+static HWND guess_popup_parent(struct wayland *wayland, HWND hwnd)
+{
+    HWND pointer_hwnd;
+    HWND cursor_hwnd;
+    HWND keyboard_hwnd;
+    HWND focus_hwnd;
+    HWND popup_hwnd;
+    POINT cursor;
+
+    pointer_hwnd = wayland->pointer.focused_surface ?
+                   wayland->pointer.focused_surface->hwnd : NULL;
+    if (pointer_hwnd)
+        pointer_hwnd = NtUserGetAncestor(pointer_hwnd, GA_ROOT);
+
+    NtUserGetCursorPos(&cursor);
+    cursor_hwnd = NtUserWindowFromPoint(cursor.x, cursor.y);
+    if (cursor_hwnd)
+        cursor_hwnd = NtUserGetAncestor(cursor_hwnd, GA_ROOT);
+
+    keyboard_hwnd = wayland->keyboard.focused_surface ?
+                    wayland->keyboard.focused_surface->hwnd : NULL;
+    if (keyboard_hwnd)
+        keyboard_hwnd = NtUserGetAncestor(keyboard_hwnd, GA_ROOT);
+
+    focus_hwnd = get_focus();
+    if (focus_hwnd)
+        focus_hwnd = NtUserGetAncestor(focus_hwnd, GA_ROOT);
+
+    TRACE("pointer_hwnd=%p cursor_hwnd=%p keyboard_hwnd=%p focus_hwnd=%p "
+          "last_event_type=%d\n",
+          pointer_hwnd, cursor_hwnd, keyboard_hwnd, focus_hwnd,
+          wayland->last_event_type);
+
+    /* If we have a recent mouse event, the popup parent is likely the window
+     * under the cursor, so prefer it. Otherwise prefer the window with
+     * the keyboard focus. */
+    if (wayland->last_event_type == INPUT_MOUSE)
+    {
+        if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+    else
+    {
+        if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+
+    TRACE("=> popup_hwnd=%p\n", popup_hwnd);
+
+    return popup_hwnd;
+}
+
+/* Whether we consider this window to be a transient popup, so we can
+ * display it as a Wayland subsurface with relative positioning. */
+static BOOL wayland_win_data_can_be_popup(struct wayland_win_data *data)
+{
+    DWORD style;
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    double monitor_width;
+    double monitor_height;
+    int window_width;
+    int window_height;
+
+    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Child windows can't be popups, unless they are children of the desktop
+     * (thus effectively top-level). */
+    if ((style & WS_CHILD) && NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT))
+    {
+        TRACE("hwnd=%p is child => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* Minimized windows can't be popups. */
+    if (style & WS_MINIMIZE)
+    {
+        TRACE("hwnd=%p is minimized => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* If the window has top bar elements, don't consider it a popup candidate. */
+    if ((style & WS_CAPTION) == WS_CAPTION ||
+        (style & (WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)))
+    {
+        TRACE("hwnd=%p style=0x%08x => FALSE\n", data->hwnd, (UINT)style);
+        return FALSE;
+    }
+
+    mi.cbSize = sizeof(mi);
+    if (!(hmonitor = NtUserMonitorFromRect(&data->window_rect, MONITOR_DEFAULTTOPRIMARY)) ||
+        !NtUserGetMonitorInfo(hmonitor, &mi))
+    {
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    monitor_width = mi.rcMonitor.right - mi.rcMonitor.left;
+    monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
+    window_width = data->window_rect.right - data->window_rect.left;
+    window_height = data->window_rect.bottom - data->window_rect.top;
+
+    /* If the window has an unreasonably small size or is too large, don't consider
+     * it a popup candidate. */
+    if (window_width <= 1 || window_height <= 1 ||
+        window_width * window_height > 0.5 * monitor_width * monitor_height)
+    {
+        TRACE("hwnd=%p window=%s monitor=%s => FALSE\n",
+              data->hwnd, wine_dbgstr_rect(&data->window_rect),
+              wine_dbgstr_rect(&mi.rcMonitor));
+        return FALSE;
+    }
+
+    TRACE("hwnd=%p style=0x%08x window=%s monitor=%s => TRUE\n",
+          data->hwnd, (UINT)style, wine_dbgstr_rect(&data->window_rect),
+          wine_dbgstr_rect(&mi.rcMonitor));
+
+    return TRUE;
+}
+
+static HWND wayland_win_data_get_effective_parent(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_init_wayland();
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    HWND parent_hwnd = (HWND)NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    HWND effective_parent_hwnd;
+
+    if (!can_be_effective_parent(data->hwnd, parent_hwnd))
+        parent_hwnd = 0;
+
+    /* Many applications use top level, unowned (or owned by the desktop)
+     * popup windows for menus and tooltips and depend on screen
+     * coordinates for correct positioning. Since wayland can't deal with
+     * screen coordinates, try to guess the effective parent window of such
+     * popups and manage them as wayland subsurfaces. */
+    if (!parent_hwnd && wayland_win_data_can_be_popup(data))
+        effective_parent_hwnd = guess_popup_parent(wayland, data->hwnd);
+    else
+        effective_parent_hwnd = parent_hwnd;
+
+    TRACE("hwnd=%p parent=%p effective_parent=%p\n",
+          data->hwnd, parent_hwnd, effective_parent_hwnd);
+
+    return effective_parent_hwnd;
+}
+
 static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
 {
     if (data->wayland_surface_needs_update)
         return TRUE;
 
+    /* Change of parentage (either actual or effective) requires recreating the
+     * whole win_data to ensure we have a properly owned wayland surface. We
+     * check for change of effective parent only if the window changed in any
+     * way, to avoid spuriously reassigning parent windows when new windows
+     * are created. */
+    if ((!EqualRect(&data->window_rect, &data->old_window_rect) &&
+         data->effective_parent != wayland_win_data_get_effective_parent(data)) ||
+        data->parent != data->old_parent)
+    {
+        return TRUE;
+    }
+
     /* If this is currently or potentially a toplevel surface, and its
      * visibility state has changed, recreate win_data so that we only have
      * xdg_toplevels for visible windows. */
@@ -265,28 +490,25 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     HWND effective_parent_hwnd;
     struct wayland_surface *surface;
     struct wayland_surface *parent_surface;
-    DWORD style;
 
     TRACE("hwnd=%p\n", data->hwnd);
 
     data->wayland_surface_needs_update = FALSE;
 
-    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
-     * and the parent for child windows. */
-    effective_parent_hwnd = (HWND)NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    effective_parent_hwnd = wayland_win_data_get_effective_parent(data);
     parent_surface = NULL;
 
     if (effective_parent_hwnd)
         parent_surface = wayland_surface_for_hwnd_unlocked(effective_parent_hwnd);
 
-    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    data->effective_parent = effective_parent_hwnd;
 
-    /* Use wayland subsurfaces for children windows and windows that are
-     * transient (i.e., don't have a titlebar). Otherwise, if the window is
-     * visible make it wayland toplevel. Finally, if the window is not visible
-     * create a plain (without a role) surface to avoid polluting the
-     * compositor with empty xdg_toplevels. */
-    if ((style & WS_CAPTION) != WS_CAPTION)
+    /* Use wayland subsurfaces for children windows and toplevels that we
+     * consider to be popups and have an effective parent. Otherwise, if the
+     * window is visible make it wayland toplevel. Finally, if the window is
+     * not visible create a plain (without a role) surface to avoid polluting
+     * the compositor with empty xdg_toplevels. */
+    if (parent_surface && (data->parent || wayland_win_data_can_be_popup(data)))
     {
         surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
                                           wayland, parent_surface);
@@ -400,6 +622,8 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
 
     if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
 
+    data->old_parent = data->parent;
+    data->old_window_rect = data->window_rect;
     data->parent = (parent == NtUserGetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
-- 
2.39.0.rc2

From 9cd95b63463e4a4abd31a3dff3b4d593659889b7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Oct 2022 15:16:00 +0300
Subject: [PATCH 064/202] winewayland.drv: Add contains_rect helper.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index d06a2266ec0..3c065541f26 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -474,6 +474,13 @@ static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
     return !IsRectEmpty(dst);
 }
 
+static inline BOOL contains_rect(RECT *outer, const RECT *inner)
+{
+    POINT tl = {inner->left, inner->top};
+    POINT br = {inner->right - 1, inner->bottom - 1};
+    return PtInRect(outer, tl) && PtInRect(outer, br);
+}
+
 static inline HWND get_focus(void)
 {
     GUITHREADINFO info;
-- 
2.39.0.rc2

From 10c9c47074e12baf531f8b6cc96042838ab529d7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:01:12 +0300
Subject: [PATCH 065/202] winewayland.drv: Update Wayland surface state.

When the properties of window change, update the state of the Wayland
surface backing that window. This potentially involves requesting a
state change from the compositor and setting proper values for the
surface geometry and subsurface position, when applicable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c |  92 ++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   5 +
 dlls/winewayland.drv/window.c          | 185 +++++++++++++++++++++++++
 3 files changed, 282 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index a9d31d439a4..fe8d4275618 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -272,6 +272,98 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
     wayland_surface_unmap(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_reconfigure_position
+ *
+ * Configures the position of a wayland surface relative to its parent.
+ * This only applies to surfaces having the subsurface role.
+ *
+ * The coordinates should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int wine_x, int wine_y)
+{
+    int x, y;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d wayland=%d,%d\n",
+          surface, surface->hwnd, wine_x, wine_y, x, y);
+
+    if (surface->wl_subsurface)
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_geometry
+ *
+ * Configures the geometry of a wayland surface, i.e., the rectangle
+ * within that surface that contains the surface's visible bounds.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int wine_x, int wine_y,
+                                          int wine_width, int wine_height)
+{
+    int x, y, width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d+%dx%d wayland=%d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    if (surface->xdg_surface && width != 0 && height != 0)
+    {
+        enum wayland_configure_flags flags = surface->current.configure_flags;
+
+        /* Sometimes rounding errors in our coordinate space transformations
+         * can lead to invalid geometry values, so enforce acceptable geometry
+         * values to avoid causing a protocol error. */
+        if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+        {
+            width = surface->current.width;
+            height = surface->current.height;
+        }
+        else if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+        {
+            if (width > surface->current.width)
+                width = surface->current.width;
+            if (height > surface->current.height)
+                height = surface->current.height;
+        }
+
+        xdg_surface_set_window_geometry(surface->xdg_surface, x, y, width, height);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3c065541f26..d2c2a80dc8c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -333,6 +333,11 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
                                    struct wayland_shm_buffer *shm_buffer,
                                    HRGN surface_damage_region) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int x, int y) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int x, int y, int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index a9dc2967bf2..e11df693ce8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -60,6 +60,10 @@ struct wayland_win_data
     struct window_surface *pending_window_surface;
     /* whether the pending_window_surface value is valid */
     BOOL           has_pending_window_surface;
+    /* whether the window is currently fullscreen */
+    BOOL           fullscreen;
+    /* whether the window is currently maximized */
+    BOOL           maximized;
     /* whether this window is visible */
     BOOL           visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -503,6 +507,10 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     data->effective_parent = effective_parent_hwnd;
 
+    /* Reset window state, so that it can be properly applied again. */
+    data->maximized = FALSE;
+    data->fullscreen = FALSE;
+
     /* Use wayland subsurfaces for children windows and toplevels that we
      * consider to be popups and have an effective parent. Otherwise, if the
      * window is visible make it wayland toplevel. Finally, if the window is
@@ -532,6 +540,180 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     }
 }
 
+static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *data)
+{
+    int wayland_width, wayland_height;
+    BOOL compat_with_current = FALSE;
+    BOOL compat_with_pending = FALSE;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    enum wayland_configure_flags conf_flags = 0;
+    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    HMONITOR hmonitor;
+    MONITORINFOEXW mi;
+    struct wayland_output *output;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        output = wayland_output_get_by_wine_name(wsurface->wayland, mi.szDevice);
+    }
+    else
+    {
+        output = NULL;
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d\n",
+          data->hwnd, width, height,
+          (int)(mi.rcMonitor.right - mi.rcMonitor.left),
+          (int)(mi.rcMonitor.bottom - mi.rcMonitor.top),
+          data->maximized, data->fullscreen);
+
+    /* Set the wayland fullscreen state if the window rect covers the
+     * current monitor. Note that we set/maintain the fullscreen wayland state,
+     * even if the window style is also maximized. */
+    if (contains_rect(&data->window_rect, &mi.rcMonitor) &&
+        !(style & (WS_MINIMIZE|WS_CAPTION)))
+    {
+        conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+    }
+    if (style & WS_MAXIMIZE)
+    {
+        conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+    }
+
+    /* First do all state unsettings, before setting new state. Some wayland
+     * compositors misbehave if the order is reversed. */
+    if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
+        data->maximized = FALSE;
+    }
+
+    if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
+        data->fullscreen = FALSE;
+    }
+
+    if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
+        data->maximized = TRUE;
+    }
+
+   /* Set the fullscreen state after the maximized state on the wayland surface
+    * to ensure compositors apply the final fullscreen state properly. */
+    if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
+                                    output ? output->wl_output : NULL);
+        data->fullscreen = TRUE;
+    }
+
+    TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
+          data->hwnd, data->maximized, data->fullscreen);
+
+    wayland_surface_coords_rounded_from_wine(wsurface, width, height,
+                                             &wayland_width, &wayland_height);
+
+    if (wsurface->current.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->current,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_current = TRUE;
+    }
+
+    if (wsurface->pending.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->pending,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_pending = TRUE;
+    }
+
+    TRACE("current conf serial=%d size=%dx%d flags=%#x\n compat=%d\n",
+          wsurface->current.serial, wsurface->current.width,
+          wsurface->current.height, wsurface->current.configure_flags,
+          compat_with_current);
+    TRACE("pending conf serial=%d size=%dx%d flags=%#x compat=%d\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          compat_with_pending);
+
+    /* Only update the wayland surface state to match the window
+     * configuration if the surface can accept the new config, in order to
+     * avoid transient states that may cause glitches. */
+    if (!compat_with_pending && !compat_with_current)
+    {
+        TRACE("hwnd=%p window state not compatible with current or "
+              "pending wayland surface configuration\n", data->hwnd);
+        return FALSE;
+    }
+
+    if (compat_with_pending)
+        wayland_surface_ack_pending_configure(wsurface);
+
+    return TRUE;
+}
+
+static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
+{
+    RECT screen_rect;
+    RECT parent_screen_rect;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    TRACE("hwnd=%p window=%dx%d style=0x%08x\n", data->hwnd, width, height, (UINT)style);
+
+    if (!(style & WS_VISIBLE))
+    {
+        wayland_surface_unmap(wsurface);
+        return;
+    }
+
+    /* Lock the wayland surface to avoid commits from other threads while we
+     * are setting up the new state. */
+    wayland_mutex_lock(&wsurface->mutex);
+
+    if (wsurface->xdg_toplevel &&
+        !wayland_win_data_update_wayland_xdg_state(data))
+    {
+        wayland_mutex_unlock(&wsurface->mutex);
+        return;
+    }
+
+    if (wsurface->wl_subsurface)
+    {
+        /* In addition to children windows, we manage some top level, popup window
+         * with subsurfaces (see wayland_win_data_get_effective_parent), which use
+         * coordinates relative to their parent surface. */
+        if (!NtUserGetWindowRect(data->hwnd, &screen_rect))
+            SetRectEmpty(&screen_rect);
+        if (!NtUserGetWindowRect(data->effective_parent, &parent_screen_rect))
+            SetRectEmpty(&parent_screen_rect);
+
+        wayland_surface_reconfigure_position(
+            wsurface,
+            screen_rect.left - parent_screen_rect.left,
+            screen_rect.top - parent_screen_rect.top);
+    }
+    else if (wsurface->xdg_surface)
+    {
+        wayland_surface_reconfigure_geometry(wsurface, 0, 0, width, height);
+    }
+
+    wayland_surface_reconfigure_apply(wsurface);
+
+    wayland_mutex_unlock(&wsurface->mutex);
+}
+
 static struct wayland_win_data *update_wayland_state(struct wayland_win_data *data)
 {
     HWND hwnd = data->hwnd;
@@ -562,6 +744,9 @@ static struct wayland_win_data *update_wayland_state(struct wayland_win_data *da
     if (wayland_win_data_wayland_surface_needs_update(data))
         wayland_win_data_update_wayland_surface(data);
 
+    if (data->wayland_surface)
+        wayland_win_data_update_wayland_surface_state(data);
+
     if (data->window_surface)
     {
         wayland_window_surface_update_wayland_surface(data->window_surface,
-- 
2.39.0.rc2

From 337ee997efb8d644aed0ed06861199e3de60785c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 17 Nov 2021 18:12:25 +0200
Subject: [PATCH 066/202] winewayland.drv: Handle window sizes larger than
 required by Wayland.

If the application provides a window larger than what is required by the
current Wayland state, use only the portion of the window visible on its
main monitor to keep Wayland from issuing a protocol error.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 14 ++---
 dlls/winewayland.drv/window.c          | 78 +++++++++++++++++++++++++-
 2 files changed, 83 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index fe8d4275618..5f8cc788999 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -381,20 +381,18 @@ BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *c
     if ((flags & mask) != (conf->configure_flags & mask))
         return FALSE;
 
-    /* The maximized state requires the configured size. */
+    /* The maximized state requires the configured size. During surface
+     * reconfiguration we can use surface geometry to provide smaller areas
+     * from larger sizes, so only smaller sizes are incompatible. */
     if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
-        (width != conf->width || height != conf->height))
+        (width < conf->width || height < conf->height))
     {
         return FALSE;
     }
 
     /* The fullscreen state requires sizes smaller or equal to the configured
-     * size. */
-    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
-        (width > conf->width || height > conf->height))
-    {
-        return FALSE;
-    }
+     * size. We can provide this during surface reconfiguration using surface
+     * geometry, so we are always compatible with a fullscreen state. */
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e11df693ce8..52805b077a0 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -661,6 +661,78 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     return TRUE;
 }
 
+static void wayland_win_data_get_rect_in_monitor(struct wayland_win_data *data,
+                                                 enum wayland_configure_flags flags,
+                                                 RECT *rect)
+{
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    RECT *area = NULL;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+            area = &mi.rcMonitor;
+        else if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+            area = &mi.rcWork;
+    }
+
+    if (area)
+    {
+        intersect_rect(rect, area, &data->window_rect);
+        OffsetRect(rect, -data->window_rect.left, -data->window_rect.top);
+    }
+    else
+    {
+        SetRectEmpty(rect);
+    }
+}
+
+static void wayland_win_data_get_compatible_rect(struct wayland_win_data *data,
+                                                 RECT *rect)
+{
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    int wine_conf_width, wine_conf_height;
+    enum wayland_configure_flags conf_flags =
+        data->wayland_surface->current.configure_flags;
+
+    /* Get the window size corresponding to the Wayland surfaces configuration. */
+    wayland_surface_coords_to_wine(data->wayland_surface,
+                                   data->wayland_surface->current.width,
+                                   data->wayland_surface->current.height,
+                                   &wine_conf_width,
+                                   &wine_conf_height);
+
+    /* If Wayland requires a surface size smaller than what wine provides,
+     * use part of the window contents for the surface. */
+    if (((conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+         (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        (width > wine_conf_width || height > wine_conf_height))
+    {
+        wayland_win_data_get_rect_in_monitor(data, conf_flags, rect);
+        /* If the window rect in the monitor is smaller than required
+         * fall back to an appropriately sized rect at the top-left. */
+        if (rect->right - rect->left < wine_conf_width ||
+            rect->bottom - rect->top < wine_conf_height)
+        {
+            SetRect(rect, 0, 0, wine_conf_width, wine_conf_height);
+        }
+        else
+        {
+            rect->right = min(rect->right, rect->left + wine_conf_width);
+            rect->bottom = min(rect->bottom, rect->top + wine_conf_height);
+        }
+        TRACE("Window is too large for wayland state, using subarea\n");
+    }
+    else
+    {
+        SetRect(rect, 0, 0, width, height);
+    }
+}
+
 static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
 {
     RECT screen_rect;
@@ -706,7 +778,11 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
     }
     else if (wsurface->xdg_surface)
     {
-        wayland_surface_reconfigure_geometry(wsurface, 0, 0, width, height);
+        RECT compat;
+        wayland_win_data_get_compatible_rect(data, &compat);
+        wayland_surface_reconfigure_geometry(wsurface, compat.left, compat.top,
+                                             compat.right - compat.left,
+                                             compat.bottom - compat.top);
     }
 
     wayland_surface_reconfigure_apply(wsurface);
-- 
2.39.0.rc2

From cc26d47cc5853e6380df1f5c6ecb1b3270008e6d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:09:31 +0300
Subject: [PATCH 067/202] winewayland.drv: Disallow commits during state
 transitions.

When a surface transitions to a new state, disallow commits until the
compositor has acknowledged the transition, in order to avoid glitches.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 10 ++++++----
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/window.c          |  3 +++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5f8cc788999..9813fa899e8 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -141,6 +141,7 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
         goto err;
 
     wl_surface_set_user_data(surface->wl_surface, surface);
+    surface->drawing_allowed = TRUE;
 
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
@@ -445,10 +446,11 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
      * they accept. To avoid wayland protocol errors, drop buffers not matching
      * the expected dimensions of such surfaces. This typically happens
      * transiently during resizing operations. */
-    if (!wayland_surface_configure_is_compatible(&surface->current,
-                                                 wayland_width,
-                                                 wayland_height,
-                                                 surface->current.configure_flags))
+    if (!surface->drawing_allowed ||
+        !wayland_surface_configure_is_compatible(&surface->current,
+                                             wayland_width,
+                                             wayland_height,
+                                             surface->current.configure_flags))
     {
         wayland_mutex_unlock(&surface->mutex);
         TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index d2c2a80dc8c..cd286b103e9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -204,6 +204,7 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
+    BOOL drawing_allowed;
 };
 
 struct wayland_native_buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 52805b077a0..e72c4a3ad8d 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -652,6 +652,7 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     {
         TRACE("hwnd=%p window state not compatible with current or "
               "pending wayland surface configuration\n", data->hwnd);
+        wsurface->drawing_allowed = FALSE;
         return FALSE;
     }
 
@@ -787,6 +788,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(wsurface);
 
+    wsurface->drawing_allowed = TRUE;
+
     wayland_mutex_unlock(&wsurface->mutex);
 }
 
-- 
2.39.0.rc2

From e3da2daa16931431b113e2c5892a038917957559 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 18 Nov 2021 14:33:51 +0200
Subject: [PATCH 068/202] winewayland.drv: Disallow commits to unmappable
 surfaces.

Wayland surfaces without a role, which we use for hidden windows, are
not mappable, so any commits on them are never going to be visible.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 9 ++++++++-
 dlls/winewayland.drv/window.c          | 3 ++-
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9813fa899e8..5e834feb2a6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -141,7 +141,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
         goto err;
 
     wl_surface_set_user_data(surface->wl_surface, surface);
-    surface->drawing_allowed = TRUE;
+    /* Plain surfaces are unmappable, so don't draw on them. */
+    surface->drawing_allowed = FALSE;
 
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
@@ -167,6 +168,8 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 
     TRACE("surface=%p parent=%p\n", surface, parent);
 
+    surface->drawing_allowed = TRUE;
+
     surface->xdg_surface =
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
@@ -216,6 +219,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
 
     TRACE("surface=%p parent=%p\n", surface, parent);
 
+    surface->drawing_allowed = TRUE;
+
     surface->parent = wayland_surface_ref(parent);
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
@@ -248,6 +253,8 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 {
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
+    surface->drawing_allowed = FALSE;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e72c4a3ad8d..af136fdb639 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -788,7 +788,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(wsurface);
 
-    wsurface->drawing_allowed = TRUE;
+    if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
+        wsurface->drawing_allowed = TRUE;
 
     wayland_mutex_unlock(&wsurface->mutex);
 }
-- 
2.39.0.rc2

From 743c470e6dcaa75617e05541eae3bb2f35e55716 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:30:53 +0300
Subject: [PATCH 069/202] winewayland.drv: Handle dynamic Wayland surface
 configure events.

When a Wayland configure event arrives, change the window size and
state to match what the compositor has requested.

While resizing, configure events can come continuously and due to the
amount of other message their handling produces (e.g., paints), have the
potential to keep the message loop busy for some time. This may lead
Wine core to think that the app never goes idle (see win.c:
flush_window_surfaces), and thus start flushing at unfortunate times
(e.g., in between partial window paints), causing visual artifacts.

To mitigate this we handle the configure message only if the message
queue is empty, ensuring that the loop has had time to become idle.  If
the queue is not currently empty, we schedule a timer message, which due
to having the lowest priority is guaranteed to be triggered only on
otherwise empty queues.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c |  20 ++-
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window.c          | 231 +++++++++++++++++++++++--
 3 files changed, 237 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5e834feb2a6..581ce36f305 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -37,12 +37,30 @@ static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_sur
                                          uint32_t serial)
 {
     struct wayland_surface *surface = data;
+    uint32_t last_serial = surface->pending.serial;
+    BOOL last_processed = surface->pending.processed;
 
     TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
 
     surface->pending.serial = serial;
+    surface->pending.processed = FALSE;
+
+    /* If we have an unprocessed WM_WAYLAND_CONFIGURE message, no need to
+     * repost. Note that checking only for a valid serial is not enough to
+     * guarantee that there is a pending WM_WAYLAND_CONFIGURE message: we may
+     * have processed the message but not acked the configure request due to
+     * surface size incompatibilities (see window.c:
+     * wayland_win_data_update_wayland_surface_state()). */
+    if (last_serial && !last_processed)
+    {
+        TRACE("not reposting, last_serial=%u\n", last_serial);
+        return;
+    }
 
-    wayland_surface_ack_pending_configure(surface);
+    if (surface->hwnd)
+        NtUserPostMessage(surface->hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+    else
+        wayland_surface_ack_pending_configure(surface);
 }
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index cd286b103e9..7f4f5cdf9e8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -59,6 +59,7 @@ enum wayland_window_message
     WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
     WM_WAYLAND_SET_CURSOR,
     WM_WAYLAND_QUERY_SURFACE_MAPPED,
+    WM_WAYLAND_CONFIGURE,
 };
 
 enum wayland_surface_role
@@ -187,6 +188,7 @@ struct wayland_surface_configure
     int height;
     enum wayland_configure_flags configure_flags;
     uint32_t serial;
+    BOOL processed;
 };
 
 struct wayland_surface
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index af136fdb639..969dc6f52f1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -60,10 +60,18 @@ struct wayland_win_data
     struct window_surface *pending_window_surface;
     /* whether the pending_window_surface value is valid */
     BOOL           has_pending_window_surface;
+    /* whether this window is currently being resized */
+    BOOL           resizing;
+    /* the window_rect this window should be restored to after unmaximizing */
+    RECT           restore_rect;
     /* whether the window is currently fullscreen */
     BOOL           fullscreen;
     /* whether the window is currently maximized */
     BOOL           maximized;
+    /* whether we are currently handling a wayland configure event */
+    BOOL           handling_wayland_configure_event;
+    /* the configure flags for the configure event we are handling */
+    enum wayland_configure_flags wayland_configure_event_flags;
     /* whether this window is visible */
     BOOL           visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -566,42 +574,56 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
         SetRectEmpty(&mi.rcMonitor);
     }
 
-    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d\n",
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d handling_event=%d\n",
           data->hwnd, width, height,
           (int)(mi.rcMonitor.right - mi.rcMonitor.left),
           (int)(mi.rcMonitor.bottom - mi.rcMonitor.top),
-          data->maximized, data->fullscreen);
+          data->maximized, data->fullscreen, data->handling_wayland_configure_event);
 
-    /* Set the wayland fullscreen state if the window rect covers the
-     * current monitor. Note that we set/maintain the fullscreen wayland state,
-     * even if the window style is also maximized. */
-    if (contains_rect(&data->window_rect, &mi.rcMonitor) &&
-        !(style & (WS_MINIMIZE|WS_CAPTION)))
+    /* If we are currently handling a wayland configure event (i.e., we are
+     * being called through handle_wm_wayland_configure() -> SetWindowPos()),
+     * use the event configure flags directly. Otherwise try to infer the flags
+     * from the window style and rectangle. */
+    if (data->handling_wayland_configure_event)
     {
-        conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        conf_flags = data->wayland_configure_event_flags;
     }
-    if (style & WS_MAXIMIZE)
+    else
     {
-        conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        /* Set the wayland fullscreen state if the window rect covers the
+         * current monitor. Note that we set/maintain the fullscreen
+         * wayland state, even if the window style is also maximized. */
+        if (contains_rect(&data->window_rect, &mi.rcMonitor) &&
+            !(style & (WS_MINIMIZE|WS_CAPTION)))
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        }
+        if (style & WS_MAXIMIZE)
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        }
     }
 
     /* First do all state unsettings, before setting new state. Some wayland
      * compositors misbehave if the order is reversed. */
     if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
-        xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
         data->maximized = FALSE;
     }
 
     if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
         data->fullscreen = FALSE;
     }
 
     if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
-        xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
         data->maximized = TRUE;
     }
 
@@ -609,11 +631,23 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     * to ensure compositors apply the final fullscreen state properly. */
     if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
-                                    output ? output->wl_output : NULL);
+        if (!data->handling_wayland_configure_event)
+        {
+            xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
+                                        output ? output->wl_output : NULL);
+        }
         data->fullscreen = TRUE;
     }
 
+    if (!(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        !(style & WS_MINIMIZE))
+    {
+        data->restore_rect = data->window_rect;
+        TRACE("setting hwnd=%p restore_rect=%s\n",
+              data->hwnd, wine_dbgstr_rect(&data->restore_rect));
+    }
+
     TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
           data->hwnd, data->maximized, data->fullscreen);
 
@@ -955,6 +989,143 @@ static void handle_wm_wayland_monitor_change(struct wayland *wayland)
     wayland_update_outputs_from_process(wayland);
 }
 
+static LRESULT handle_wm_wayland_configure(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+    DWORD flags;
+    int width, height, wine_width, wine_height;
+    UINT swp_flags;
+    BOOL needs_enter_size_move = FALSE;
+    BOOL needs_exit_size_move = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return 0;
+    if (!data->wayland_surface || !data->wayland_surface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface = data->wayland_surface;
+
+    TRACE("serial=%d size=%dx%d flags=%#x restore_rect=%s\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          wine_dbgstr_rect(&data->restore_rect));
+
+    if (wsurface->pending.serial == 0)
+    {
+        TRACE("pending configure event already handled, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface->pending.processed = TRUE;
+
+    data->wayland_configure_event_flags = wsurface->pending.configure_flags;
+
+    width = wsurface->pending.width;
+    height = wsurface->pending.height;
+    flags = wsurface->pending.configure_flags;
+
+    /* If we are free to set our size, first try the restore size, then
+     * the current size. */
+    if (width == 0)
+    {
+        int ignore;
+        width = data->restore_rect.right - data->restore_rect.left;
+        if (width == 0)
+            width = data->window_rect.right - data->window_rect.left;
+        wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
+                                                 &width, &ignore);
+        wsurface->pending.width = width;
+    }
+    if (height == 0)
+    {
+        int ignore;
+        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (height == 0)
+            height = data->window_rect.bottom - data->window_rect.top;
+        wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
+                                                 &ignore, &height);
+        wsurface->pending.height = height;
+    }
+
+    wayland_surface_coords_to_wine(wsurface, width, height,
+                                   &wine_width, &wine_height);
+
+    TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
+          data->hwnd, width, height, wine_width, wine_height);
+
+    if ((flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && !data->resizing)
+    {
+        data->resizing = TRUE;
+        needs_enter_size_move = TRUE;
+    }
+
+    if (!(flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && data->resizing)
+    {
+        data->resizing = FALSE;
+        needs_exit_size_move = TRUE;
+    }
+
+    wayland_win_data_release(data);
+
+    if (needs_enter_size_move)
+        send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+
+    if (needs_exit_size_move)
+        send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = TRUE;
+        wayland_win_data_release(data);
+    }
+
+    if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+    {
+        NtUserSetWindowLong(hwnd, GWL_STYLE,
+                            NtUserGetWindowLongW(hwnd, GWL_STYLE) | WS_MAXIMIZE,
+                            FALSE);
+    }
+    else
+    {
+        NtUserSetWindowLong(hwnd, GWL_STYLE,
+                            NtUserGetWindowLongW(hwnd, GWL_STYLE) & ~WS_MAXIMIZE,
+                            FALSE);
+    }
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE;
+
+    if (wine_width > 0 && wine_height > 0)
+        swp_flags |= SWP_FRAMECHANGED;
+    else
+        swp_flags |= SWP_NOSIZE | SWP_NOREDRAW;
+    /* When we are maximized or fullscreen, wayland is particular about the
+     * surface size it accepts, so don't allow the app to change it. */
+    if (flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+        swp_flags |= SWP_NOSENDCHANGING;
+
+    NtUserSetWindowPos(hwnd, 0, 0, 0, wine_width, wine_height, swp_flags);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = FALSE;
+        wayland_win_data_release(data);
+    }
+
+    return 0;
+}
+
+static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    TRACE("hwnd=%p\n", hwnd);
+    NtUserKillTimer(hwnd, timer_id);
+    handle_wm_wayland_configure(hwnd);
+}
+
 /**********************************************************************
  *           WAYLAND_DesktopWindowProc
  */
@@ -1001,6 +1172,36 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             return res;
         }
         break;
+    case WM_WAYLAND_CONFIGURE:
+        /* While resizing, configure events can come continuously and due to the
+         * amount of other message their handling produces (e.g., paints), have
+         * the potential to keep the message loop busy for some time. This may
+         * lead Wine core to think that the app never goes idle (see
+         * win.c:flush_window_surfaces), and thus start flushing at unfortunate
+         * times (e.g., in between partial window paints), causing visual
+         * artifacts.
+         *
+         * To mitigate this we handle the configure message only if the message
+         * queue is empty, ensuring that the loop has had time to become idle.
+         * If the queue is not currently empty, we schedule a timer message,
+         * which due to having the lowest priority is guaranteed to be triggered
+         * only on otherwise empty queues.
+         */
+        if (!NtUserGetQueueStatus(QS_ALLINPUT))
+        {
+            return handle_wm_wayland_configure(hwnd);
+        }
+        else
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface && wayland_surface->xdg_toplevel)
+            {
+                NtUserSetTimer(hwnd, (UINT_PTR)wayland_surface->wl_surface, 10,
+                               post_configure, TIMERV_DEFAULT_COALESCING);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From bba851ea536ea28452f63095686c3de7b2d9a698 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:40:58 +0300
Subject: [PATCH 070/202] winewayland.drv: Handle window minimization and
 restoration.

Request a minimized state from the Wayland compositor when a window
is minimized.

Since Wayland doesn't provide any explicit information about the
minimization state of surfaces, we heurestically infer a restoration
from a minimized state by using the keyboard focus of the surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 15 ++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |  1 +
 dlls/winewayland.drv/waylanddrv_main.c  |  1 +
 dlls/winewayland.drv/window.c           | 32 +++++++++++++++++++++++--
 4 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index ad2753683cd..9ad0fce0052 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -832,6 +832,21 @@ static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
         {
             struct wayland_surface *toplevel = wayland_surface;
             while (toplevel->parent) toplevel = toplevel->parent;
+
+            if (NtUserGetWindowLongW(toplevel->hwnd, GWL_STYLE) & WS_MINIMIZE)
+            {
+                /* If a minimized window is already activated from Wine's
+                 * perspective, reactivating it is a null operation, and thus
+                 * won't trigger any activation side-effects (e.g., many games
+                 * change the display mode when they are activated). In order
+                 * to get those effects properly applied, deactivate the window
+                 * now, so it can be properly reactivated after restoration. */
+                if (foreground == toplevel->hwnd)
+                    NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+                NtUserShowWindow(toplevel->hwnd, SW_RESTORE);
+                NtUserShowOwnedPopups(toplevel->hwnd, TRUE);
+            }
+
             NtUserSetForegroundWindow(toplevel->hwnd);
         }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7f4f5cdf9e8..dea0034da49 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -511,6 +511,7 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index ceb226d8cef..cc849a3b4d8 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -124,6 +124,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pShowWindow = WAYLAND_ShowWindow,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 969dc6f52f1..f23ae22472e 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -984,6 +984,32 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
     wayland_win_data_release(data);
 }
 
+/***********************************************************************
+ *           WAYLAND_ShowWindow
+ */
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+{
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p cmd=%d\n", hwnd, cmd);
+
+    if (IsRectEmpty(rect)) return swp;
+    if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE)) return swp;
+    /* always hide icons off-screen */
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect(rect, -32000 - rect->left, -32000 - rect->top);
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+
+    if ((wsurface = wayland_surface_for_hwnd_lock(hwnd)) && wsurface->xdg_toplevel)
+        xdg_toplevel_set_minimized(wsurface->xdg_toplevel);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+
+    return swp;
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
@@ -1034,7 +1060,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (width == 0)
     {
         int ignore;
-        width = data->restore_rect.right - data->restore_rect.left;
+        if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE))
+            width = data->restore_rect.right - data->restore_rect.left;
         if (width == 0)
             width = data->window_rect.right - data->window_rect.left;
         wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
@@ -1044,7 +1071,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (height == 0)
     {
         int ignore;
-        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE))
+            height = data->restore_rect.bottom - data->restore_rect.top;
         if (height == 0)
             height = data->window_rect.bottom - data->window_rect.top;
         wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
-- 
2.39.0.rc2

From 415b1e13775e306c2b3cc0c38df1d44f4f465d02 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Fri, 4 Nov 2022 11:23:03 +0200
Subject: [PATCH 071/202] winewayland.drv: Ignore Wayland size hints if they
 are too small.

If the Wayland compositor's size hints are smaller than the minimum that
the application supports, ignore them to ensure the window does not
become so small that the user cannot meaningfully interact with it.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/window.c | 33 ++++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f23ae22472e..ca724aa2a42 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1020,10 +1020,11 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     struct wayland_win_data *data;
     struct wayland_surface *wsurface;
     DWORD flags;
-    int width, height, wine_width, wine_height;
+    int width, height, wine_width, wine_height, min_width, min_height;
     UINT swp_flags;
     BOOL needs_enter_size_move = FALSE;
     BOOL needs_exit_size_move = FALSE;
+    MINMAXINFO mm;
 
     if (!(data = wayland_win_data_get(hwnd))) return 0;
     if (!data->wayland_surface || !data->wayland_surface->xdg_toplevel)
@@ -1055,6 +1056,36 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     height = wsurface->pending.height;
     flags = wsurface->pending.configure_flags;
 
+    /* Ask the application for the window minimum width/height. It may not
+     * respond to the message, so we first set the system default values. */
+    memset(&mm, 0, sizeof(MINMAXINFO));
+    mm.ptMinTrackSize.x = NtUserGetSystemMetrics(SM_CXMINTRACK);
+    mm.ptMinTrackSize.y = NtUserGetSystemMetrics(SM_CYMINTRACK);
+    send_message(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&mm);
+    wayland_surface_coords_rounded_from_wine(wsurface,
+                                             mm.ptMinTrackSize.x,
+                                             mm.ptMinTrackSize.y,
+                                             &min_width, &min_height);
+
+    /* If the compositor's size hints are smaller than the minimum that the
+     * application supports, ignore the hints, except if the application is
+     * fullscreen or maximized in which case we always need to respect the
+     * requested size to avoid protocol errors. This fixes bugs in which a
+     * compositor forces applications to become so small that would be
+     * impossible to interact with them: some applications do not allow resize
+     * without going through the menus and changing their resolution. */
+    if (!(flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED |
+                   WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        ((width != 0 && width < min_width) || (height != 0 && height < min_height)))
+    {
+        TRACE("ignoring compositor size hint (%dx%d) that is smaller than " \
+              "application minimum (%dx%d, wine=%dx%d)\n",
+              width, height, min_width, min_height,
+              (int)mm.ptMinTrackSize.x, (int)mm.ptMinTrackSize.y);
+        if (width < min_width) width = wsurface->pending.width = 0;
+        if (height < min_height) height = wsurface->pending.height = 0;
+    }
+
     /* If we are free to set our size, first try the restore size, then
      * the current size. */
     if (width == 0)
-- 
2.39.0.rc2

From 977f41c105141662c443c82ae320726113588ad5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:49:26 +0300
Subject: [PATCH 072/202] winewayland.drv: Handle interactive window resizing.

Propagate resize notification to the Wayland compositor, so it can
update the surface size by sending new Wayland configure events.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_pointer.c |  5 +++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 46 ++++++++++++++++++++++++++
 4 files changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 0d426b17956..b7bebd8e8b0 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -166,6 +166,11 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
     wayland->last_event_type = INPUT_MOUSE;
 
+    if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+        wayland->last_button_serial = serial;
+    else
+        wayland->last_button_serial = 0;
+
     __wine_send_input(focused_hwnd, &input, NULL);
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dea0034da49..eb1d138c6be 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -151,6 +151,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
+    uint32_t last_button_serial;
     int last_event_type;
     int event_notification_pipe[2];
 };
@@ -512,6 +513,7 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
 UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index cc849a3b4d8..fc0947bc09c 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -125,6 +125,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pShowWindow = WAYLAND_ShowWindow,
+    .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ca724aa2a42..c30553ac02a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1015,6 +1015,52 @@ static void handle_wm_wayland_monitor_change(struct wayland *wayland)
     wayland_update_outputs_from_process(wayland);
 }
 
+static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
+{
+    switch (hittest) {
+    case WMSZ_LEFT:        return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
+    case WMSZ_RIGHT:       return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
+    case WMSZ_TOP:         return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
+    case WMSZ_TOPLEFT:     return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
+    case WMSZ_TOPRIGHT:    return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
+    case WMSZ_BOTTOM:      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
+    case WMSZ_BOTTOMLEFT:  return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
+    case WMSZ_BOTTOMRIGHT: return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
+    default:               return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
+    }
+}
+
+/***********************************************************************
+ *          WAYLAND_SysCommand
+ */
+LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
+{
+    LRESULT ret = -1;
+    WPARAM command = wparam & 0xfff0;
+    WPARAM hittest = wparam & 0x0f;
+    struct wayland_surface *wsurface;
+
+    TRACE("cmd=%lx hwnd=%p, %lx, %lx\n", (long)command, hwnd, (long)wparam, lparam);
+
+    if (!(wsurface = wayland_surface_for_hwnd_lock(hwnd)) || !wsurface->xdg_toplevel)
+        goto done;
+
+    if (command == SC_SIZE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_resize(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                                wsurface->wayland->last_button_serial,
+                                hittest_to_resize_edge(hittest));
+        }
+        ret = 0;
+    }
+
+done:
+    wayland_surface_for_hwnd_unlock(wsurface);
+    return ret;
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
-- 
2.39.0.rc2

From c30705fdbaebad7bb39ba8f895109cf7ca5f2b75 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:51:31 +0300
Subject: [PATCH 073/202] winewayland.drv: Handle interactive window movement.

Propagate window movement requests to the compositor. Note that although
the Wayland surface may move on screen, the client (Wine in this case)
is never aware, since such absolute positioning information is not
provided by the Wayland protocol.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index c30553ac02a..4bf929ec1c5 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1055,6 +1055,15 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
         }
         ret = 0;
     }
+    else if (command == SC_MOVE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_move(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                              wsurface->wayland->last_button_serial);
+        }
+        ret = 0;
+    }
 
 done:
     wayland_surface_for_hwnd_unlock(wsurface);
-- 
2.39.0.rc2

From ac937a02e376f4852e43a821992dba4e94d5b896 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 15:53:46 +0300
Subject: [PATCH 074/202] winewayland.drv: Support window and window_surface
 regions.

Use buffers with an alpha channel (ARGB8888) to implement window
regions. Pixels outside the region are left as transparent in the
buffer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  17 +++
 dlls/winewayland.drv/window_surface.c  | 172 +++++++++++++++++++++++--
 4 files changed, 181 insertions(+), 12 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index eb1d138c6be..fd9578ae059 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -402,6 +402,8 @@ void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPE
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -512,6 +514,7 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index fc0947bc09c..8e1d8ca621a 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -124,6 +124,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetWindowRgn = WAYLAND_SetWindowRgn,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 4bf929ec1c5..902eb7ee280 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1010,6 +1010,23 @@ UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index e97426e9340..05a944762eb 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -34,7 +34,7 @@
 #include <stdlib.h>
 
 #include "ntgdi.h"
-#include "winuser.h"
+#include "ntuser.h"
 
 #include "wine/debug.h"
 
@@ -47,6 +47,8 @@ struct wayland_window_surface
     struct wayland_surface *wayland_surface; /* Not owned by us */
     struct wayland_buffer_queue *wayland_buffer_queue;
     RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
@@ -76,6 +78,104 @@ static inline void reset_bounds(RECT *bounds)
     bounds->right = bounds->bottom = INT_MIN;
 }
 
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR))
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) NtGdiDeleteObjectApp(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue || !wws->wayland_surface) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region && NtUserGetWindowRgnEx(wws->hwnd, region, 0) == ERROR)
+        {
+            NtGdiDeleteObjectApp(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region) NtGdiCombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            NtGdiCombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = NtGdiCreateRectRgn(0, 0, 0, 0);
+            if (region) NtGdiCombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
 /***********************************************************************
  *           wayland_window_surface_lock
  */
@@ -122,7 +222,23 @@ static RECT *wayland_window_surface_get_bounds(struct window_surface *window_sur
 static void wayland_window_surface_set_region(struct window_surface *window_surface,
                                               HRGN region)
 {
-    /* TODO */
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) NtGdiDeleteObjectApp(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        NtGdiCombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
 }
 
 /***********************************************************************
@@ -145,6 +261,24 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
           wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
 
     needs_flush = intersect_rect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        RECT total_region_box;
+        surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
+                                                   damage_rect.right, damage_rect.bottom);
+        /* If the total_region is empty we are guaranteed to have empty SHM
+         * buffers. In order for this empty content to take effect, we still
+         * need to commit with non-empty damage, so don't AND with the
+         * total_region in this case, to ensure we don't end up with an empty
+         * surface_damage_region. */
+        if (wws->total_region &&
+            NtGdiGetRgnBox(wws->total_region, &total_region_box) != NULLREGION)
+        {
+            needs_flush = NtGdiCombineRgn(surface_damage_region, surface_damage_region,
+                                          wws->total_region, RGN_AND);
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -156,12 +290,9 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
     if (!needs_flush) goto done;
 
-    surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
-                                               damage_rect.right, damage_rect.bottom);
-
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits);
+          wws->bits, wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -173,7 +304,7 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         wws->last_flush_failed = TRUE;
         goto done;
     }
-    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
@@ -182,7 +313,8 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     for (;rgn_rect < rgn_rect_end; rgn_rect++)
     {
         unsigned int *src, *dst;
-        int y, width, height;
+        int x, y, width, height;
+        BOOL apply_surface_alpha;
 
         TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
 
@@ -198,8 +330,13 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
+        /* If we have an ARGB buffer we need to explicitly apply the surface
+         * alpha (assumed to be 255 currently) to ensure the destination has
+         * sensible alpha values. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+
         /* Fast path for full width rectangles. */
-        if (width == buffer->width)
+        if (width == buffer->width && !apply_surface_alpha)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -207,7 +344,15 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
         for (y = 0; y < height; y++)
         {
-            memcpy(dst, src, width * 4);
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -240,6 +385,8 @@ static void wayland_window_surface_destroy(struct window_surface *window_surface
     TRACE("surface=%p\n", wws);
 
     wayland_mutex_destroy(&wws->mutex);
+    if (wws->region) NtGdiDeleteObjectApp(wws->region);
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
     if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
@@ -285,6 +432,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
     if (!(wws->bits = malloc(wws->info.bmiHeader.biSizeImage)))
@@ -330,7 +478,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
         wws->wayland_buffer_queue =
             wayland_buffer_queue_create(wws->wayland_surface->wayland,
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
-                    WL_SHM_FORMAT_XRGB8888);
+                    get_preferred_format(wws));
     }
     else if (!wws->wayland_surface && wws->wayland_buffer_queue)
     {
-- 
2.39.0.rc2

From 210f3958917b1c2a66339ba6c0d37b32c9ad4a53 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 10:47:53 +0300
Subject: [PATCH 075/202] winewayland.drv: Implement
 SetLayeredWindowAttributes.

Support color-keying and whole window opacity by manipulating the pixel
alpha values of ARGB8888 buffers.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |  7 ++-
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 dlls/winewayland.drv/window.c          | 57 ++++++++++++++++++++++-
 dlls/winewayland.drv/window_surface.c  | 63 ++++++++++++++++++++++----
 4 files changed, 119 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fd9578ae059..e75ee5960fd 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -397,13 +397,16 @@ struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_bu
  *          Wayland window surface
  */
 
-struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect) DECLSPEC_HIDDEN;
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha) DECLSPEC_HIDDEN;
 void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPEC_HIDDEN;
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -514,7 +517,9 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
 UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 8e1d8ca621a..bab2cbc8671 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -124,7 +124,9 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
     .pSetWindowRgn = WAYLAND_SetWindowRgn,
+    .pSetWindowStyle = WAYLAND_SetWindowStyle,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 902eb7ee280..afa19202b85 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -914,6 +914,9 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
     HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
     RECT surface_rect;
+    DWORD flags;
+    COLORREF color_key;
+    BYTE alpha;
 
     TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
@@ -949,7 +952,16 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     }
 
     /* Create new window surface. */
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect);
+    color_key = alpha = flags = 0;
+    if (!(exstyle & WS_EX_LAYERED) ||
+        !NtUserGetLayeredWindowAttributes(hwnd, &color_key, &alpha, &flags))
+    {
+        flags = 0;
+    }
+    if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
 
 done:
     wayland_win_data_release(data);
@@ -1027,6 +1039,49 @@ void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
     }
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowStyle
+ */
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
+{
+    struct wayland_win_data *data;
+    DWORD changed = style->styleNew ^ style->styleOld;
+
+    TRACE("hwnd=%p offset=%d changed=%#x\n", hwnd, offset, (UINT)changed);
+
+    if (hwnd == NtUserGetDesktopWindow()) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED))
+    {
+        TRACE("hwnd=%p changed layered\n", hwnd);
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+    }
+
+    wayland_win_data_release(data);
+}
+
+/***********************************************************************
+ *	     WAYLAND_SetLayeredWindowAttributes
+ */
+void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if (!(flags & LWA_COLORKEY)) key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+        wayland_win_data_release(data);
+    }
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 05a944762eb..a127ef4af3b 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -49,6 +49,8 @@ struct wayland_window_surface
     RECT                  bounds;
     HRGN                  region; /* region set through window_surface funcs */
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
+    COLORREF              color_key;
+    BYTE                  alpha;
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
@@ -88,7 +90,8 @@ static int get_preferred_format(struct wayland_window_surface *wws)
 
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
-    if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR))
+    if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR) ||
+        wws->color_key != CLR_INVALID || wws->alpha != 255)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -290,9 +293,12 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
     if (!needs_flush) goto done;
 
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
+          "alpha %02x compression %u region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->total_region);
+          wws->bits, (UINT)wws->color_key, wws->alpha,
+          (UINT)wws->info.bmiHeader.biCompression,
+          wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -331,12 +337,12 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha (assumed to be 255 currently) to ensure the destination has
-         * sensible alpha values. */
+         * alpha to ensure the destination has sensible alpha values. */
         apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
 
         /* Fast path for full width rectangles. */
-        if (width == buffer->width && !apply_surface_alpha)
+        if (width == buffer->width && !apply_surface_alpha &&
+            wws->color_key == CLR_INVALID)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -348,11 +354,24 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else
+            else if (wws->alpha == 255)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((wws->alpha << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+
+            if (wws->color_key != CLR_INVALID)
+                for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -408,7 +427,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
 /***********************************************************************
  *           wayland_window_surface_create
  */
-struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect)
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -432,6 +452,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wws->color_key    = color_key;
+    wws->alpha        = alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -488,3 +510,28 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_layered
+ */
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (alpha != wws->alpha || color_key != wws->color_key)
+        *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+
+    wws->alpha = alpha;
+    wws->color_key = color_key;
+
+    if (wws->wayland_buffer_queue &&
+        wws->wayland_buffer_queue->format != get_preferred_format(wws))
+    {
+        recreate_wayland_buffer_queue(wws);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.39.0.rc2

From e6b295810d08c859e7b7b84e9a8a978535490562 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 20 May 2022 16:21:37 +0300
Subject: [PATCH 076/202] winewayland.drv: Add union_rect helper.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e75ee5960fd..f4906d61616 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -495,6 +495,20 @@ static inline BOOL contains_rect(RECT *outer, const RECT *inner)
     return PtInRect(outer, tl) && PtInRect(outer, br);
 }
 
+static inline BOOL union_rect(RECT *dst, const RECT *src1, const RECT *src2)
+{
+    if (IsRectEmpty(src1)) *dst = *src2;
+    else if (IsRectEmpty(src2)) *dst = *src1;
+    else
+    {
+        dst->left = min(src1->left, src2->left);
+        dst->top = min(src1->top, src2->top);
+        dst->right = max(src1->right, src2->right);
+        dst->bottom = max(src1->bottom, src2->bottom);
+    }
+    return !IsRectEmpty(dst);
+}
+
 static inline HWND get_focus(void)
 {
     GUITHREADINFO info;
-- 
2.39.0.rc2

From dc2a6a18cf49d222bb14a495899251b0c2809325 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 14:39:51 +0300
Subject: [PATCH 077/202] winewayland.drv: Implement UpdateLayeredWindow.

Support per-pixel alpha values and background blending.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   8 +-
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          | 103 +++++++++++++++++++++++--
 dlls/winewayland.drv/window_surface.c  |  39 +++++++---
 4 files changed, 134 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f4906d61616..03b1cffca68 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -398,7 +398,8 @@ struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_bu
  */
 
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha) DECLSPEC_HIDDEN;
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha) DECLSPEC_HIDDEN;
 void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPEC_HIDDEN;
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
@@ -406,7 +407,8 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha) DECLSPEC_HIDDEN;
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -540,6 +542,8 @@ INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect) DECLSPEC_HIDDEN;
 SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index bab2cbc8671..97aaf6c07c0 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -130,6 +130,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pUpdateLayeredWindow = WAYLAND_UpdateLayeredWindow,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index afa19202b85..b3cdc549a10 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -31,6 +31,7 @@
 
 #include "wine/debug.h"
 
+#include "ntgdi.h"
 #include "ntuser.h"
 
 #include <assert.h>
@@ -961,7 +962,7 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
     if (!(flags & LWA_ALPHA)) alpha = 255;
 
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
 
 done:
     wayland_win_data_release(data);
@@ -1056,7 +1057,7 @@ void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     {
         TRACE("hwnd=%p changed layered\n", hwnd);
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
     }
 
     wayland_win_data_release(data);
@@ -1077,14 +1078,101 @@ void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWO
     if ((data = wayland_win_data_get(hwnd)))
     {
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
         wayland_win_data_release(data);
     }
 }
 
-static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect)
 {
-    wayland_update_outputs_from_process(wayland);
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, (UINT)info->crKey, wine_dbgstr_rect(info->prcDirty), (UINT)info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = NtGdiCreateDIBSection(info->hdcDst, NULL, 0, bmi, DIB_RGB_COLORS, 0, 0, 0, &src_bits))) goto done;
+    if (!(hdc = NtGdiCreateCompatibleDC(0))) goto done;
+
+    NtGdiSelectBitmap(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        intersect_rect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        NtGdiPatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    NtGdiTransformPoints(info->hdcSrc, (POINT *)&src_rect, (POINT *)&src_rect, 2, NtGdiDPtoLP);
+
+    ret = NtGdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                          info->hdcSrc, src_rect.left, src_rect.top,
+                          src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                          (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend, 0);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        union_rect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) NtGdiDeleteObjectApp(hdc);
+    if (dib) NtGdiDeleteObjectApp(dib);
+    return ret;
 }
 
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
@@ -1142,6 +1230,11 @@ done:
     return ret;
 }
 
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+    wayland_update_outputs_from_process(wayland);
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index a127ef4af3b..f254da973d5 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -51,6 +51,7 @@ struct wayland_window_surface
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
     COLORREF              color_key;
     BYTE                  alpha;
+    BOOL                  src_alpha;
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
@@ -91,7 +92,7 @@ static int get_preferred_format(struct wayland_window_surface *wws)
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
     if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR) ||
-        wws->color_key != CLR_INVALID || wws->alpha != 255)
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -294,9 +295,9 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     if (!needs_flush) goto done;
 
     TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
-          "alpha %02x compression %u region %p\n",
+          "alpha %02x src_alpha %d compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, (UINT)wws->color_key, wws->alpha,
+          wws->bits, (UINT)wws->color_key, wws->alpha, wws->src_alpha,
           (UINT)wws->info.bmiHeader.biCompression,
           wws->total_region);
 
@@ -337,8 +338,12 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha to ensure the destination has sensible alpha values. */
-        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+         * alpha to ensure the destination has sensible alpha values. The
+         * exception is when the surface uses source alpha values and the
+         * surface alpha is 255, in which case we can just copy pixel values
+         * as they are. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                              (wws->alpha != 255 || !wws->src_alpha);
 
         /* Fast path for full width rectangles. */
         if (width == buffer->width && !apply_surface_alpha &&
@@ -354,12 +359,12 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else if (wws->alpha == 255)
+            else if (wws->alpha == 255 && !wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
-            else
+            else if (!wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                 {
@@ -369,6 +374,16 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
                               (((BYTE)src[x] * wws->alpha / 255)));
                 }
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
 
             if (wws->color_key != CLR_INVALID)
                 for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
@@ -428,7 +443,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
  *           wayland_window_surface_create
  */
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha)
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -454,6 +470,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->hwnd         = hwnd;
     wws->color_key    = color_key;
     wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -515,17 +532,19 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
  *           wayland_window_surface_update_layered
  */
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha)
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
 
     window_surface->funcs->lock(window_surface);
 
-    if (alpha != wws->alpha || color_key != wws->color_key)
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
         *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
 
     wws->alpha = alpha;
     wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
 
     if (wws->wayland_buffer_queue &&
         wws->wayland_buffer_queue->format != get_preferred_format(wws))
-- 
2.39.0.rc2

From f55c50f325dccb0b3529774bdb60b35e65fef99d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 14:25:25 +0300
Subject: [PATCH 078/202] winewayland.drv: Fix thread safety issue with
 UpdateLayeredWindow.

In some cases, notably when the app calls UpdateLayeredWindow, position
and size changes may be emitted from a thread other than the window
thread. Since in the current implementation updating the Wayland state
needs to happen in the context of the window thread to avoid racy
interactions, post a message to update the state in the right thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 28 +++++++++++++++++++++++++++-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 03b1cffca68..34249507f87 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -60,6 +60,7 @@ enum wayland_window_message
     WM_WAYLAND_SET_CURSOR,
     WM_WAYLAND_QUERY_SURFACE_MAPPED,
     WM_WAYLAND_CONFIGURE,
+    WM_WAYLAND_STATE_UPDATE,
 };
 
 enum wayland_surface_role
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index b3cdc549a10..051922ff1c7 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -80,6 +80,8 @@ struct wayland_win_data
     RECT           old_window_rect;
     /* whether a wayland surface update is needed */
     BOOL           wayland_surface_needs_update;
+    /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
+    BOOL           pending_state_update_message;
 };
 
 static struct wayland_mutex win_data_mutex =
@@ -992,7 +994,20 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
     data->pending_window_surface = surface;
     data->has_pending_window_surface = TRUE;
 
-    data = update_wayland_state(data);
+    /* In some cases, notably when the app calls UpdateLayeredWindow, position
+     * and size changes may be emitted from a thread other than the window
+     * thread. Since in the current implementation updating the wayland state
+     * needs to happen in the context of the window thread to avoid racy
+     * interactions, post a message to update the state in the right thread. */
+    if (GetCurrentThreadId() == NtUserGetWindowThread(hwnd, NULL))
+    {
+        data = update_wayland_state(data);
+    }
+    else if (!data->pending_state_update_message)
+    {
+        NtUserPostMessage(hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+        data->pending_state_update_message = TRUE;
+    }
 
     wayland_win_data_release(data);
 }
@@ -1481,6 +1496,17 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_STATE_UPDATE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data)
+            {
+                data->pending_state_update_message = FALSE;
+                data = update_wayland_state(data);
+                wayland_win_data_release(data);
+            }
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From 708de98420df8a104e88e46fa61ff1272485b0c8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 7 Nov 2022 11:32:52 +0200
Subject: [PATCH 079/202] winewayland.drv: Track thread Wayland surfaces.

Track all created Wayland surfaces in each thread and destroy them on
thread shutdown.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 12 ++++++++++++
 dlls/winewayland.drv/wayland_surface.c |  5 +++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 3 files changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 7377f4e7b50..d4e8def432c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -352,6 +352,7 @@ BOOL wayland_init(struct wayland *wayland)
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->detached_shm_buffer_list);
     wl_list_init(&wayland->callback_list);
+    wl_list_init(&wayland->surface_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -418,6 +419,17 @@ void wayland_deinit(struct wayland *wayland)
     }
     wayland_reschedule_wakeup_timerfd();
 
+    /* Keep getting the first surface in the list and destroy it, which also
+     * removes it from the list. We use this somewhat unusual iteration method
+     * because even wl_list_for_each_safe() is not safe against removals of
+     * arbitrary elements from the list during iteration. */
+    while (wayland->surface_list.next != &wayland->surface_list)
+    {
+        struct wayland_surface *surface =
+            wl_container_of(wayland->surface_list.next, surface, link);
+        wayland_surface_destroy(surface);
+    }
+
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
     if (wayland->event_notification_pipe[1] >= 0)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 581ce36f305..db80fd195a2 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -158,6 +158,7 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->link);
     wl_surface_set_user_data(surface->wl_surface, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
@@ -165,6 +166,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
 
+    wl_list_insert(&wayland->surface_list, &surface->link);
+
     return surface;
 
 err:
@@ -562,6 +565,8 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->parent = NULL;
     }
 
+    wl_list_remove(&surface->link);
+
     wayland_mutex_destroy(&surface->mutex);
 
     wl_display_flush(surface->wayland->wl_display);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 34249507f87..2b333a6eaf4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -149,6 +149,7 @@ struct wayland
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
     struct wl_list callback_list;
+    struct wl_list surface_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
@@ -195,6 +196,7 @@ struct wayland_surface_configure
 
 struct wayland_surface
 {
+    struct wl_list link; /* wayland::surface_list */
     struct wayland *wayland;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
-- 
2.39.0.rc2

From ca263de12017845da272132f60957fa2f65893af Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 15:38:48 +0300
Subject: [PATCH 080/202] winewayland.drv: Store a list of Wayland child
 surfaces.

Make each Wayland surfaces aware of its subsurfaces. This will allow us
to efficiently apply property changes (e.g., changing the output
associated with a surface) to whole surface tree hierarchies in upcoming
commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 35 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index db80fd195a2..1994c399b2b 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -159,6 +159,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
         goto err;
 
     wl_list_init(&surface->link);
+    wl_list_init(&surface->parent_link);
+    wl_list_init(&surface->child_list);
     wl_surface_set_user_data(surface->wl_surface, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
@@ -243,6 +245,11 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     surface->drawing_allowed = TRUE;
 
     surface->parent = wayland_surface_ref(parent);
+
+    wayland_mutex_lock(&parent->mutex);
+    wl_list_insert(&parent->child_list, &surface->parent_link);
+    wayland_mutex_unlock(&parent->mutex);
+
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
                                         surface->wl_surface,
@@ -276,6 +283,17 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 
     surface->drawing_allowed = FALSE;
 
+    if (surface->parent)
+    {
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->parent_link);
+        wl_list_init(&surface->parent_link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -526,6 +544,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_surface *child, *child_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -535,6 +554,18 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (keyboard->focused_surface == surface)
         keyboard->focused_surface = NULL;
 
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    wayland_mutex_lock(&surface->mutex);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, parent_link)
+    {
+        child->parent = NULL;
+        wl_list_remove(&child->parent_link);
+        wl_list_init(&child->parent_link);
+    }
+    wayland_mutex_unlock(&surface->mutex);
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -561,6 +592,10 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     if (surface->parent)
     {
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->parent_link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+
         wayland_surface_unref(surface->parent);
         surface->parent = NULL;
     }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 2b333a6eaf4..340d11f2c10 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -197,6 +197,7 @@ struct wayland_surface_configure
 struct wayland_surface
 {
     struct wl_list link; /* wayland::surface_list */
+    struct wl_list parent_link; /* wayland_surface::child_list */
     struct wayland *wayland;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
@@ -211,6 +212,7 @@ struct wayland_surface
     LONG ref;
     enum wayland_surface_role role;
     BOOL drawing_allowed;
+    struct wl_list child_list;
 };
 
 struct wayland_native_buffer
-- 
2.39.0.rc2

From deb5e2a979291a1a3f8c60b520f78c5d81f6b2cc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 27 Oct 2021 17:41:37 +0300
Subject: [PATCH 081/202] winewayland.drv: Update children surfaces when parent
 is updated

When a parent Wayland surface is recreated, mark the children surfaces
as requiring an update, so that the get eventually recreated using the
new parent.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 051922ff1c7..642938aa750 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -546,7 +546,26 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     if (data->wayland_surface != surface)
     {
         if (data->wayland_surface)
+        {
+            struct wayland_surface *child;
+
+            /* Dependent Wayland surfaces require an update, so that they point
+             * to the updated surface. */
+            wayland_mutex_lock(&data->wayland_surface->mutex);
+            wl_list_for_each(child, &data->wayland_surface->child_list, parent_link)
+            {
+                struct wayland_win_data *child_data;
+                if ((child_data = wayland_win_data_get(child->hwnd)))
+                {
+                    child_data->wayland_surface_needs_update = TRUE;
+                    wayland_win_data_release(child_data);
+                }
+            }
+            wayland_mutex_unlock(&data->wayland_surface->mutex);
+
             wayland_surface_unref(data->wayland_surface);
+        }
+
         data->wayland_surface = surface;
     }
 }
-- 
2.39.0.rc2

From 3feaa454cdf938ada04eed7c784dcc172677f898 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 18:40:24 +0300
Subject: [PATCH 082/202] winewayland.drv: Handle Wayland surface output
 positioning.

Track the output(s) a Wayland surface is visible in, to allow us to
update the position of the associated window in the Windows virtual
screen space.

We always place windows at the top-left origin of their main output. The
main output is updated to be the topleft-most output fully contained by
the surface in the fullscreen case, otherwise it's the topleft-most output
entered by the surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |   8 ++
 dlls/winewayland.drv/wayland_surface.c | 180 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |  12 ++
 dlls/winewayland.drv/window.c          |  38 ++++++
 4 files changed, 237 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index d4e8def432c..24d95613497 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -281,7 +281,15 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         if (output->global_id == id)
         {
+            struct wayland_surface *surface;
+
             TRACE("removing output->name=%s\n", output->name);
+
+            /* Remove the output from surfaces, as some compositors don't send
+             * a leave event if the output is disconnected. */
+            wl_list_for_each(surface, &wayland->surface_list, link)
+                wayland_surface_leave_output(surface, output);
+
             wayland_output_destroy(output);
             if (wayland_is_process(wayland))
             {
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 1994c399b2b..5813f42858f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -33,6 +33,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output);
+
 static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
                                          uint32_t serial)
 {
@@ -134,6 +137,96 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener = {
     handle_xdg_toplevel_close,
 };
 
+/* Gets the output we consider to be the origin of this surface.
+ * If the surface can be fullscreen this is the topleft-most output that
+ * fully contains this surface, otherwise it's the topleft-most output
+ * that partially contains this surface. */
+static struct wayland_output *wayland_surface_get_origin_output(
+        struct wayland_surface *surface)
+{
+    struct wayland_output_ref *ref;
+    struct wayland_output *topleft = NULL;
+    struct wayland_output *containing = NULL;
+    RECT window_rect;
+
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+
+    wl_list_for_each(ref, &surface->output_ref_list, link)
+    {
+        if (surface->window_fullscreen)
+        {
+            RECT monitor_rect;
+            struct wayland_output_mode *mode = ref->output->current_mode;
+
+            SetRect(&monitor_rect, ref->output->x, ref->output->y,
+                    ref->output->x + (mode ? mode->width : 0),
+                    ref->output->y + (mode ? mode->height : 0));
+
+            if ((!containing || ref->output->x < containing->x ||
+                 (ref->output->x == containing->x && ref->output->y < containing->y)) &&
+                contains_rect(&window_rect, &monitor_rect))
+            {
+                containing = ref->output;
+            }
+        }
+
+        if (!topleft || ref->output->x < topleft->x ||
+            (ref->output->x == topleft->x && ref->output->y < topleft->y))
+            topleft = ref->output;
+    }
+
+    return containing ? containing : topleft;
+}
+
+static void handle_wl_surface_enter(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+    struct wayland_output_ref *ref;
+    struct wayland_output *origin;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    ref = calloc(1, sizeof(*ref));
+    if (!ref) { ERR("memory allocation failed"); return; }
+    ref->output = output;
+    wl_list_insert(&surface->output_ref_list, &ref->link);
+
+    origin = wayland_surface_get_origin_output(surface);
+    wayland_surface_set_main_output(surface, origin);
+}
+
+static void handle_wl_surface_leave(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    wayland_surface_leave_output(surface, output);
+}
+
+static const struct wl_surface_listener wl_surface_listener = {
+    handle_wl_surface_enter,
+    handle_wl_surface_leave,
+};
+
 /**********************************************************************
  *          wayland_surface_create_plain
  *
@@ -158,10 +251,11 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->parent_link);
     wl_list_init(&surface->child_list);
-    wl_surface_set_user_data(surface->wl_surface, surface);
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
 
@@ -258,6 +352,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
         goto err;
     wl_subsurface_set_desync(surface->wl_subsurface);
 
+    surface->main_output = parent->main_output;
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
@@ -545,6 +641,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
     struct wayland_surface *child, *child_tmp;
+    struct wayland_output_ref *ref, *ref_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -566,6 +663,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     }
     wayland_mutex_unlock(&surface->mutex);
 
+    wl_list_for_each_safe(ref, ref_tmp, &surface->output_ref_list, link)
+    {
+        wl_list_remove(&ref->link);
+        free(ref);
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -718,3 +821,78 @@ void wayland_surface_unref(struct wayland_surface *surface)
     if (ref == 0)
         wayland_surface_destroy(surface);
 }
+
+static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->main_output = output;
+
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_list_for_each(child, &surface->child_list, parent_link)
+        wayland_surface_tree_set_main_output(child, output);
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_main_output
+ *
+ * Sets the main output for a surface, i.e., the output whose scale will be
+ * used for surface scaling.
+ */
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->main_output != output)
+    {
+        wayland_surface_tree_set_main_output(surface, output);
+        if (surface->hwnd)
+            send_message(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_leave_output
+ *
+ * Removes an output from the set of outputs a surface is presented on.
+ *
+ * It is OK to call this function even if the surface is not presented
+ * on the specified output, in which case this function is a NOP.
+ */
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output)
+{
+    struct wayland_output_ref *ref, *tmp;
+
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    wl_list_for_each_safe(ref, tmp, &surface->output_ref_list, link)
+    {
+        if (ref->output == output)
+        {
+            wl_list_remove(&ref->link);
+            free(ref);
+            break;
+        }
+    }
+
+    if (surface->main_output == output)
+    {
+        struct wayland_output *origin =
+            wayland_surface_get_origin_output(surface);
+
+        wayland_surface_set_main_output(surface, origin);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 340d11f2c10..39be4b92766 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -61,6 +61,7 @@ enum wayland_window_message
     WM_WAYLAND_QUERY_SURFACE_MAPPED,
     WM_WAYLAND_CONFIGURE,
     WM_WAYLAND_STATE_UPDATE,
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
 };
 
 enum wayland_surface_role
@@ -194,6 +195,12 @@ struct wayland_surface_configure
     BOOL processed;
 };
 
+struct wayland_output_ref
+{
+    struct wl_list link;
+    struct wayland_output *output;
+};
+
 struct wayland_surface
 {
     struct wl_list link; /* wayland::surface_list */
@@ -211,8 +218,11 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
+    struct wl_list output_ref_list;
+    struct wayland_output *main_output;
     BOOL drawing_allowed;
     struct wl_list child_list;
+    BOOL window_fullscreen;
 };
 
 struct wayland_native_buffer
@@ -363,6 +373,8 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     int *wine_x, int *wine_y) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland native buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 642938aa750..bd4c743b266 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -670,6 +670,9 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
               data->hwnd, wine_dbgstr_rect(&data->restore_rect));
     }
 
+    /* Mark in the surface whether the associated window is fullscreen. */
+    wsurface->window_fullscreen = data->fullscreen;
+
     TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
           data->hwnd, data->maximized, data->fullscreen);
 
@@ -1439,6 +1442,38 @@ static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWOR
     handle_wm_wayland_configure(hwnd);
 }
 
+static void handle_wm_wayland_surface_output_change(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    data = wayland_win_data_get(hwnd);
+    if (!data || !data->wayland_surface || !data->wayland_surface->xdg_surface)
+    {
+        TRACE("hwnd=%p has no suitable wayland surface, returning\n", hwnd);
+        goto out;
+    }
+
+    wsurface = data->wayland_surface;
+
+    if (wsurface->main_output)
+    {
+        UINT swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER |
+                         SWP_FRAMECHANGED | SWP_NOSENDCHANGING | SWP_NOSIZE;
+        int x = wsurface->main_output->x;
+        int y = wsurface->main_output->y;
+
+        TRACE("moving window to %d,%d\n", x, y);
+
+        NtUserSetWindowPos(hwnd, 0, x, y, 0, 0, swp_flags);
+    }
+
+out:
+    wayland_win_data_release(data);
+}
+
 /**********************************************************************
  *           WAYLAND_DesktopWindowProc
  */
@@ -1526,6 +1561,9 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             }
         }
         break;
+    case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
+        handle_wm_wayland_surface_output_change(hwnd);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From c93448776888b8c3a59cb6ed4656f38ea8be34c9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 12 Oct 2022 16:25:47 +0300
Subject: [PATCH 083/202] winewayland.drv: Move windows to the origin of their
 main output.

To maintain some degree of consistency between the Wayland surface and
Windows window positioning, place top-level windows on the output
dictated by the compositor. We position the window at the origin of that
output to maximize the window area that is accessible by mouse events.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 47 ++++++++++++++++++++++++++++++++---
 1 file changed, 44 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index bd4c743b266..a064e288ca1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -82,6 +82,8 @@ struct wayland_win_data
     BOOL           wayland_surface_needs_update;
     /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
     BOOL           pending_state_update_message;
+    /* The serial of the next expected WM_WAYLAND_SURFACE_OUTPUT_CHANGE message */
+    UINT           pending_surface_output_change_serial;
 };
 
 static struct wayland_mutex win_data_mutex =
@@ -894,6 +896,38 @@ static struct wayland_win_data *update_wayland_state(struct wayland_win_data *da
             wayland_window_surface_flush(data->window_surface);
     }
 
+    if (data->wayland_surface && data->wayland_surface->xdg_toplevel &&
+        data->wayland_surface->main_output)
+    {
+        struct wayland_output *output = data->wayland_surface->main_output;
+        /* We increase the serial even if we don't end up posting
+         * WM_WAYLAND_SURFACE_OUTPUT_CHANGE, to ensure all previous pending
+         * requests are invalidated. */
+        data->pending_surface_output_change_serial++;
+        /* Skip zero if we wrap around, since it has a special meaning. */
+        if (data->pending_surface_output_change_serial == 0)
+            data->pending_surface_output_change_serial++;
+
+        /* To maintain some degree of consistency between the Wayland surface and
+         * Windows window positioning, place top-level windows on the output
+         * dictated by the compositor. We position the window at the origin of that
+         * output to maximize the window area that is accessible by mouse events.
+         * We perform the move if the window:
+         * 1. is not already at origin, and
+         * 2. is not minimized
+         * 3. is not fullscreen */
+        if ((data->window_rect.left != output->x || data->window_rect.top != output->y) &&
+            !(NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_MINIMIZE) &&
+            !data->fullscreen)
+        {
+            TRACE("hwnd=%p window_rect=%s not at origin %dx%d, scheduling move\n",
+                  data->hwnd, wine_dbgstr_rect(&data->window_rect),
+                  output->x, output->y);
+            NtUserPostMessage(hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+                              data->pending_surface_output_change_serial, 0);
+        }
+    }
+
     return data;
 }
 
@@ -1442,7 +1476,7 @@ static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWOR
     handle_wm_wayland_configure(hwnd);
 }
 
-static void handle_wm_wayland_surface_output_change(HWND hwnd)
+static void handle_wm_wayland_surface_output_change(HWND hwnd, UINT serial)
 {
     struct wayland_win_data *data;
     struct wayland_surface *wsurface;
@@ -1450,9 +1484,16 @@ static void handle_wm_wayland_surface_output_change(HWND hwnd)
     TRACE("hwnd=%p\n", hwnd);
 
     data = wayland_win_data_get(hwnd);
+    if (serial == 0) serial = ++data->pending_surface_output_change_serial;
+    if (serial != data->pending_surface_output_change_serial)
+    {
+        TRACE("hwnd=%p output change request has superseded serial", hwnd);
+        goto out;
+
+    }
     if (!data || !data->wayland_surface || !data->wayland_surface->xdg_surface)
     {
-        TRACE("hwnd=%p has no suitable wayland surface, returning\n", hwnd);
+        TRACE("hwnd=%p has no suitable wayland surface\n", hwnd);
         goto out;
     }
 
@@ -1562,7 +1603,7 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         }
         break;
     case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
-        handle_wm_wayland_surface_output_change(hwnd);
+        handle_wm_wayland_surface_output_change(hwnd, wp);
         break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
-- 
2.39.0.rc2

From cc12256c391d346aa8dcd0df21e0c769297185a1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 26 Oct 2021 13:16:38 +0300
Subject: [PATCH 084/202] winewayland.drv: Track the Wine output containing a
 window.

Track the output Wine considers to contain the window backed by a
Wayland surface. Transiently, this may be different from the output
Wayland considers to be the "main" one for this surface. This is useful
in case the Wayland compositor has not yet sent the relevant output
surface enter event(s).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 21 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/window.c          |  2 ++
 3 files changed, 25 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5813f42858f..30ea5bba70f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -896,3 +896,24 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
         wayland_surface_set_main_output(surface, origin);
     }
 }
+
+/**********************************************************************
+ *          wayland_surface_set_wine_output
+ *
+ * Sets the output which Wine considers to contain the window backed by this
+ * surface. Transiently, this may be different from the output Wayland
+ * considers to be the "main" one for this surface.
+ */
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output)
+{
+    /* Don't update non-toplevels or surfaces that already have a main output. */
+    if (!output || surface->parent || surface->main_output) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    wayland_surface_tree_set_main_output(surface, output);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 39be4b92766..97b2c437168 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -375,6 +375,8 @@ struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DEC
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland native buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index a064e288ca1..22e72466668 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -604,6 +604,8 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
           (int)(mi.rcMonitor.bottom - mi.rcMonitor.top),
           data->maximized, data->fullscreen, data->handling_wayland_configure_event);
 
+    wayland_surface_set_wine_output(data->wayland_surface, output);
+
     /* If we are currently handling a wayland configure event (i.e., we are
      * being called through handle_wm_wayland_configure() -> SetWindowPos()),
      * use the event configure flags directly. Otherwise try to infer the flags
-- 
2.39.0.rc2

From 3496023f6fb161b9545eee5ff0b9ebafd540fbb0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Sat, 11 Sep 2021 01:51:44 +0300
Subject: [PATCH 085/202] winewayland.drv: Use output scale on Wayland surface
 buffers.

Use the scale of the main output of each Wayland surface to always
render at the native resolution on that output. This effectively turns
off compositor-side scaling, giving applications/Wine complete control
over how to scale.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_cursor.c  |  5 +++
 dlls/winewayland.drv/wayland_surface.c | 45 ++++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 3 files changed, 42 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index e93aa541d6b..d9bcf77b269 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -601,6 +601,11 @@ void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
     wl_surface_attach(pointer->cursor_wl_surface, pointer->cursor->wl_buffer, 0, 0);
     wl_surface_damage_buffer(pointer->cursor_wl_surface, 0, 0,
                              wayland_cursor->width, wayland_cursor->height);
+    if (pointer->focused_surface)
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface,
+                                    wayland_surface_get_buffer_scale(pointer->focused_surface));
+    else
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface, 1);
 
     wl_surface_commit(pointer->cursor_wl_surface);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 30ea5bba70f..dc478fb85f2 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -353,6 +353,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     wl_subsurface_set_desync(surface->wl_subsurface);
 
     surface->main_output = parent->main_output;
+    wl_surface_set_buffer_scale(surface->wl_surface,
+                                wayland_surface_get_buffer_scale(parent));
 
     wl_surface_commit(surface->wl_surface);
 
@@ -762,8 +764,10 @@ void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y)
 {
-    *wayland_x = wine_x;
-    *wayland_y = wine_y;
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    *wayland_x = wine_x / (double)scale;
+    *wayland_y = wine_y / (double)scale;
 }
 
 /**********************************************************************
@@ -791,8 +795,10 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y)
 {
-    *wine_x = round(wayland_x);
-    *wine_y = round(wayland_y);
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    *wine_x = round(wayland_x * scale);
+    *wine_y = round(wayland_y * scale);
 }
 
 /**********************************************************************
@@ -822,17 +828,19 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
-static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
-                                                 struct wayland_output *output)
+static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
+                                                           struct wayland_output *output,
+                                                           int scale)
 {
     struct wayland_surface *child;
 
     surface->main_output = output;
+    wl_surface_set_buffer_scale(surface->wl_surface, scale);
 
     wayland_mutex_lock(&surface->mutex);
 
     wl_list_for_each(child, &surface->child_list, parent_link)
-        wayland_surface_tree_set_main_output(child, output);
+        wayland_surface_tree_set_main_output_and_scale(child, output, scale);
 
     wayland_mutex_unlock(&surface->mutex);
 }
@@ -856,7 +864,8 @@ static void wayland_surface_set_main_output(struct wayland_surface *surface,
 
     if (surface->main_output != output)
     {
-        wayland_surface_tree_set_main_output(surface, output);
+        wayland_surface_tree_set_main_output_and_scale(surface, output,
+                                                       output ? output->scale : 1);
         if (surface->hwnd)
             send_message(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
     }
@@ -915,5 +924,23 @@ void wayland_surface_set_wine_output(struct wayland_surface *surface,
           surface->main_output ? surface->main_output->name : NULL,
           output ? output->name : NULL);
 
-    wayland_surface_tree_set_main_output(surface, output);
+    wayland_surface_tree_set_main_output_and_scale(surface, output, output->scale);
+}
+
+/**********************************************************************
+ *          wayland_surface_get_buffer_scale
+ *
+ */
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
+{
+    /* Use the toplevel surface to get the scale */
+    struct wayland_surface *toplevel = surface;
+    int scale = 1;
+
+    while (toplevel->parent) toplevel = toplevel->parent;
+
+    if (surface->main_output) scale = surface->main_output->scale;
+
+    TRACE("hwnd=%p (toplevel=%p) => scale=%d\n", surface->hwnd, toplevel->hwnd, scale);
+    return scale;
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 97b2c437168..204a1db26c2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -377,6 +377,7 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
                                      struct wayland_output *output) DECLSPEC_HIDDEN;
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland native buffer
-- 
2.39.0.rc2

From 90325db17887c64a359c1253d12e3e71b948976d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:14:48 +0300
Subject: [PATCH 086/202] winewayland.drv: Support tracking the Wine current
 display mode.

Track the Wine current display mode independently from the Wayland
current display mode, so these two are can be made to differ in upcoming
commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 12 ++++++------
 dlls/winewayland.drv/wayland_output.c  |  6 ++++++
 dlls/winewayland.drv/wayland_surface.c |  2 +-
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 4 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index aceb1dd6930..9af832f89b2 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -148,8 +148,8 @@ static void wayland_add_device_monitor(const struct gdi_device_manager *device_m
     }
 
     SetRect(&monitor.rc_monitor, output->x, output->y,
-            output->x + output->current_mode->width,
-            output->y + output->current_mode->height);
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
 
     /* We don't have a direct way to get the work area in Wayland. */
     monitor.rc_work = monitor.rc_monitor;
@@ -215,7 +215,7 @@ static struct wayland_output *wayland_get_primary_output(struct wayland *wayland
 
     wl_list_for_each(output, &wayland->output_list, link)
     {
-        if (output->current_mode && output->x == 0 && output->y == 0)
+        if (output->current_wine_mode && output->x == 0 && output->y == 0)
             return output;
     }
 
@@ -252,7 +252,7 @@ BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manage
 
     wl_list_for_each(output, &wayland->output_list, link)
     {
-        if (!output->current_mode || output == primary) continue;
+        if (!output->current_wine_mode || output == primary) continue;
         wayland_add_device_output(device_manager, param, output, output_id);
         output_id++;
     }
@@ -270,10 +270,10 @@ static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, D
     if (!output)
         return FALSE;
 
-    if (!output->current_mode)
+    if (!output->current_wine_mode)
         return FALSE;
 
-    populate_devmode(output->current_mode, mode);
+    populate_devmode(output->current_wine_mode, mode);
 
     mode->dmFields |= DM_POSITION;
     mode->dmPosition.x = output->x;
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index af095afa446..7bc28883b1a 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -127,7 +127,10 @@ static void wayland_output_add_mode(struct wayland_output *output,
             /* Upgrade modes from virtual to native, never the reverse. */
             if (native) mode->native = TRUE;
             if (current)
+            {
                 output->current_mode = mode;
+                output->current_wine_mode = mode;
+            }
             return;
         }
         else if (cmp == 1) /* mode > new */
@@ -146,7 +149,10 @@ static void wayland_output_add_mode(struct wayland_output *output,
     mode->native = native;
 
     if (current)
+    {
         output->current_mode = mode;
+        output->current_wine_mode = mode;
+    }
 
     wl_list_insert(insert_after_link, &mode->link);
 }
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index dc478fb85f2..c9abef07195 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -156,7 +156,7 @@ static struct wayland_output *wayland_surface_get_origin_output(
         if (surface->window_fullscreen)
         {
             RECT monitor_rect;
-            struct wayland_output_mode *mode = ref->output->current_mode;
+            struct wayland_output_mode *mode = ref->output->current_wine_mode;
 
             SetRect(&monitor_rect, ref->output->x, ref->output->y,
                     ref->output->x + (mode ? mode->width : 0),
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 204a1db26c2..63d1ce689c2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -177,6 +177,7 @@ struct wayland_output
     struct zxdg_output_v1 *zxdg_output_v1;
     struct wl_list mode_list;
     struct wayland_output_mode *current_mode;
+    struct wayland_output_mode *current_wine_mode;
     int logical_x, logical_y;  /* logical position */
     int logical_w, logical_h;  /* logical size */
     int x, y;  /* position in native pixel coordinate space */
-- 
2.39.0.rc2

From afe54ef5692f6d6ceb837e3b0eabe4ab342174c8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:17:32 +0300
Subject: [PATCH 087/202] winewayland.drv: Update coordinate transformations
 for Wine display modes.

Update coordinate transformation functions to handle the case where the
Wayland display mode and the Wine display mode differ.

This is achieved by introducing an additional transformation scale
factor which will be set in upcoming commits when the Wine display mode
changes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_output.c  |  1 +
 dlls/winewayland.drv/wayland_surface.c | 82 ++++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |  7 +++
 dlls/winewayland.drv/window.c          | 13 +++-
 4 files changed, 97 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 7bc28883b1a..a2fef82637e 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -504,6 +504,7 @@ BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t versio
     wl_list_init(&output->link);
 
     output->scale = 1;
+    output->wine_scale = 1.0;
 
     /* Have a fallback in case xdg_output is not supported or name is not sent. */
     output->name = malloc(20);
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index c9abef07195..9fd92ea7696 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -764,10 +764,23 @@ void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y)
 {
+    struct wayland_output *output = surface->main_output;
     int scale = wayland_surface_get_buffer_scale(surface);
 
-    *wayland_x = wine_x / (double)scale;
-    *wayland_y = wine_y / (double)scale;
+    if (output)
+    {
+        *wayland_x = wine_x * output->wine_scale / scale;
+        *wayland_y = wine_y * output->wine_scale / scale;
+    }
+    else
+    {
+        *wayland_x = wine_x / (double)scale;
+        *wayland_y = wine_y / (double)scale;
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wine=%d,%d => wayland=%.2f,%.2f\n",
+          surface->hwnd, output ? output->wine_scale : -1.0, wine_x, wine_y,
+          *wayland_x, *wayland_y);
 }
 
 /**********************************************************************
@@ -795,10 +808,71 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y)
 {
+    struct wayland_output *output = surface->main_output;
     int scale = wayland_surface_get_buffer_scale(surface);
 
-    *wine_x = round(wayland_x * scale);
-    *wine_y = round(wayland_y * scale);
+    if (output)
+    {
+        *wine_x = round(wayland_x * scale / output->wine_scale);
+        *wine_y = round(wayland_y * scale / output->wine_scale);
+    }
+    else
+    {
+        *wine_x = round(wayland_x * scale);
+        *wine_y = round(wayland_y * scale);
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wayland=%.2f,%.2f => wine=%d,%d\n",
+          surface->hwnd, output ? output->wine_scale : -1.0,
+          wayland_x, wayland_y, *wine_x, *wine_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_find_wine_fullscreen_fit
+ *
+ * Finds the size of a fullscreen Wine window that when scaled best fits into a
+ * wayland surface with the provided size, while maintaining the aspect
+ * ratio of the current Wine display mode.
+ */
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height)
+{
+    struct wayland_output *output = surface->main_output;
+    double subarea_width, subarea_height;
+
+    TRACE("hwnd=%p wayland_width=%d wayland_height=%d\n",
+          surface->hwnd, wayland_width, wayland_height);
+
+    /* If the wine mode doesn't match the wayland mode, Find the largest subarea
+     * within wayland_width x wayland_height that has an aspect ratio equal to
+     * the wine display mode aspect ratio. */
+    if (output)
+    {
+        double aspect = ((double)wayland_width) / wayland_height;
+        double wine_aspect = ((double)output->current_wine_mode->width) /
+                             output->current_wine_mode->height;
+        if (aspect > wine_aspect)
+        {
+            subarea_width = wayland_height * wine_aspect;
+            subarea_height = wayland_height;
+        }
+        else
+        {
+            subarea_width = wayland_width;
+            subarea_height = wayland_width / wine_aspect;
+        }
+    }
+    else
+    {
+        subarea_width = wayland_width;
+        subarea_height = wayland_height;
+    }
+
+    /* Transform the calculated subarea to wine coordinates. */
+    wayland_surface_coords_to_wine(surface,
+                                   subarea_width, subarea_height,
+                                   wine_width, wine_height);
 }
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 63d1ce689c2..d802e9a92a7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -182,6 +182,10 @@ struct wayland_output
     int logical_w, logical_h;  /* logical size */
     int x, y;  /* position in native pixel coordinate space */
     int scale; /* wayland output scale factor for hidpi */
+    /* Scale factor by which we need to multiply values in the wine coordinate
+     * space to get values in the wayland coordinate space for this output. Used
+     * when emulating a display mode change. */
+    double wine_scale;
     char *name;
     WCHAR wine_name[128];
     uint32_t global_id;
@@ -372,6 +376,9 @@ void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
 void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y) DECLSPEC_HIDDEN;
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 22e72466668..f998e066563 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1404,8 +1404,17 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
         wsurface->pending.height = height;
     }
 
-    wayland_surface_coords_to_wine(wsurface, width, height,
-                                   &wine_width, &wine_height);
+    if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_find_wine_fullscreen_fit(wsurface, width, height,
+                                                 &wine_width, &wine_height);
+    }
+    else
+    {
+        wayland_surface_coords_to_wine(wsurface, width, height,
+                                       &wine_width, &wine_height);
+    }
 
     TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
           data->hwnd, width, height, wine_width, wine_height);
-- 
2.39.0.rc2

From b62d839aa90cb5c4d0bda7420c5c292baf53dd5a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:18:46 +0300
Subject: [PATCH 088/202] winewayland.drv: Scale surfaces to apply Wine display
 modes.

Use the viewporter protocol to scale surfaces on the Wayland compositor
side, in order to create the illusion that the monitor has performed a
display mode change.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/wayland.c         |  7 ++++
 dlls/winewayland.drv/wayland_surface.c | 45 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  5 +++
 dlls/winewayland.drv/window.c          |  2 ++
 5 files changed, 60 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 8dc9a302814..4beb8eb6c6d 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -28,6 +28,7 @@ C_SRCS = \
 	xkb_util.c \
 
 WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 24d95613497..f72a346fba2 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -267,6 +267,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
                                             version < 5 ? version : 5);
         wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
     }
+    else if (strcmp(interface, "wp_viewporter") == 0)
+    {
+        wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -459,6 +463,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
+    if (wayland->wp_viewporter)
+        wp_viewporter_destroy(wayland->wp_viewporter);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9fd92ea7696..c2461b304e4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -251,6 +251,13 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    if (surface->wayland->wp_viewporter)
+    {
+        surface->wp_viewport =
+            wp_viewporter_get_viewport(surface->wayland->wp_viewporter,
+                                       surface->wl_surface);
+    }
+
     wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->parent_link);
@@ -494,6 +501,38 @@ void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
     }
 }
 
+/**********************************************************************
+ *          wayland_surface_reconfigure_size
+ *
+ * Configures the size of a wayland surface.
+ *
+ * The sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int wine_width, int wine_height)
+{
+    int width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%dx%d wayland=%dx%d\n",
+          surface, surface->hwnd, wine_width, wine_height, width, height);
+
+    /* Use a viewport, if supported, to handle display mode changes. */
+    if (surface->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(surface->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(surface->wp_viewport, -1, -1);
+    }
+}
+
 /**********************************************************************
  *          wayland_surface_reconfigure_apply
  *
@@ -671,6 +710,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         free(ref);
     }
 
+    if (surface->wp_viewport)
+    {
+        wp_viewport_destroy(surface->wp_viewport);
+        surface->wp_viewport = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index d802e9a92a7..ab26c2ba1e4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,7 @@
 #include <wayland-cursor.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -145,6 +146,7 @@ struct wayland
     struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
+    struct wp_viewporter *wp_viewporter;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -215,6 +217,7 @@ struct wayland_surface
     struct wl_subsurface *wl_subsurface;
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
+    struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
     HWND hwnd;
     struct wayland_mutex mutex;
@@ -361,6 +364,8 @@ void wayland_surface_reconfigure_position(struct wayland_surface *surface,
                                           int x, int y) DECLSPEC_HIDDEN;
 void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
                                           int x, int y, int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int width, int height) DECLSPEC_HIDDEN;
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f998e066563..93c05793272 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -825,6 +825,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         return;
     }
 
+    wayland_surface_reconfigure_size(wsurface, width, height);
+
     if (wsurface->wl_subsurface)
     {
         /* In addition to children windows, we manage some top level, popup window
-- 
2.39.0.rc2

From 6f4b99b99b302975558dd5110596067ba5b1271c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 13:45:18 +0300
Subject: [PATCH 089/202] winewayland.drv: Handle changes to the Wine display
 mode.

When the Wine display mode changes, update any affected outputs and
surfaces to take the new mode into account.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_output.c | 45 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  3 ++
 dlls/winewayland.drv/window.c         | 12 +++++++
 3 files changed, 60 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index a2fef82637e..10a344ca868 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -583,6 +583,8 @@ void wayland_update_outputs_from_process(struct wayland *wayland)
             if (!strcmp(output->name, process_output->name))
             {
                 lstrcpyW(output->wine_name, process_output->wine_name);
+                wayland_output_set_wine_mode(output,
+                                             process_output->current_wine_mode);
                 break;
             }
         }
@@ -610,3 +612,46 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
     return NULL;
 }
+
+/**********************************************************************
+ *          wayland_output_set_wine_mode
+ *
+ * Set the current wine mode for the specified output. Note that
+ * the provided mode struct argument is used only as a reference to get
+ * mode information from.
+ */
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  struct wayland_output_mode *ref_mode)
+{
+    struct wayland_output_mode *output_mode;
+
+    TRACE("output->name=%s %dx%d@%d %dbpp\n",
+          output->name, ref_mode->width, ref_mode->height,
+          ref_mode->refresh, ref_mode->bpp);
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (output_mode->width == ref_mode->width &&
+            output_mode->height == ref_mode->height &&
+            output_mode->bpp == ref_mode->bpp &&
+            output_mode->refresh == ref_mode->refresh)
+        {
+            output->current_wine_mode = output_mode;
+            break;
+        }
+    }
+
+    if (!output->current_wine_mode || !output->current_mode)
+    {
+        output->wine_scale = 1.0;
+    }
+    else
+    {
+        double scale_x = ((double)output->current_mode->width) /
+                         output->current_wine_mode->width;
+        double scale_y = ((double)output->current_mode->height) /
+                         output->current_wine_mode->height;
+        /* We want to keep the aspect ratio of the target mode. */
+        output->wine_scale = fmin(scale_x, scale_y);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ab26c2ba1e4..6a3bc29c498 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -332,6 +332,9 @@ void wayland_notify_wine_monitor_change(void) DECLSPEC_HIDDEN;
 void wayland_update_outputs_from_process(struct wayland *wayland) DECLSPEC_HIDDEN;
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name) DECLSPEC_HIDDEN;
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland, uint32_t id) DECLSPEC_HIDDEN;
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  struct wayland_output_mode *ref_mode) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland event dispatch
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 93c05793272..0485d8b6484 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1307,7 +1307,19 @@ done:
 
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
+    struct wayland_surface *surface;
+
     wayland_update_outputs_from_process(wayland);
+
+    /* Update the state of all surfaces tracked by the wayland thread instance,
+     * in case any surface was affected by the monitor changes (e.g., gained or
+     * lost the fullscreen state). We post the message instead of updating the
+     * state synchronously in order to avoid deadlocks, since:
+     * 1. Wayland state updates may involve queries to the Wine monitor info.
+     * 2. This function is expected to be called as part of our display
+     *    configuration sequence which happens under the win32u display lock. */
+    wl_list_for_each(surface, &wayland->surface_list, link)
+        NtUserPostMessage(surface->hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
 }
 
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
-- 
2.39.0.rc2

From 5e1355bd94fef9bb1ecda85e3b29125071c757b2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 13:47:29 +0300
Subject: [PATCH 090/202] winewayland.drv: Implement ChangeDisplaySettings.

Change the current Wine display mode the and notify all Wayland threads
about the change.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 75 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 78 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 9af832f89b2..3f633a26463 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -33,6 +33,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+#define NEXT_DEVMODEW(mode) ((DEVMODEW *)((char *)((mode) + 1) + (mode)->dmDriverExtra))
+
 static BOOL force_display_devices_refresh;
 
 static void wayland_refresh_display_devices(void)
@@ -311,3 +313,76 @@ BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, BOOL is_primary, LPDEVMODEW
 
     return ret;
 }
+
+static struct wayland_output_mode *get_matching_output_mode(struct wayland_output *output,
+                                                            LPDEVMODEW devmode)
+{
+    struct wayland_output_mode *output_mode;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (devmode->dmPelsWidth == output_mode->width &&
+            devmode->dmPelsHeight == output_mode->height &&
+            output_mode->bpp == devmode->dmBitsPerPel &&
+            output_mode->refresh / 1000 == devmode->dmDisplayFrequency)
+        {
+            return output_mode;
+        }
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *		ChangeDisplaySettings  (WAYLAND.@)
+ *
+ */
+LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW displays, LPCWSTR primary_name,
+                                   HWND hwnd, DWORD flags, LPVOID lpvoid)
+{
+    LONG ret;
+    struct wayland *wayland = wayland_process_acquire();
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+    DEVMODEW *devmode;
+
+    for (devmode = displays; devmode->dmSize; devmode = NEXT_DEVMODEW(devmode))
+    {
+        TRACE("device=%s devmode=%ux%u@%u %ubpp\n",
+              wine_dbgstr_w(devmode->dmDeviceName), (UINT)devmode->dmPelsWidth,
+              (UINT)devmode->dmPelsHeight, (UINT)devmode->dmDisplayFrequency,
+              (UINT)devmode->dmBitsPerPel);
+
+        output = wayland_output_get_by_wine_name(wayland, devmode->dmDeviceName);
+        if (!output)
+        {
+            ret = DISP_CHANGE_BADPARAM;
+            goto out;
+        }
+
+        output_mode = get_matching_output_mode(output, devmode);
+        if (!output_mode)
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+
+        wayland_output_set_wine_mode(output, output_mode);
+
+        TRACE("output=%s (%s) set current wine mode %dx%d wine_scale %f\n",
+              output->name, wine_dbgstr_w(output->wine_name),
+              output_mode->width, output_mode->height, output->wine_scale);
+    }
+
+    /* Release the wayland process instance lock to avoid potential deadlocks
+     * while notifying other thread instances below. */
+    wayland_process_release();
+
+    wayland_notify_wine_monitor_change();
+
+    return DISP_CHANGE_SUCCESSFUL;
+
+out:
+    wayland_process_release();
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6a3bc29c498..accbc07d6b7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -558,6 +558,8 @@ static inline HWND get_focus(void)
  *          USER driver functions
  */
 
+LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW displays, LPCWSTR primary_name,
+                                   HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 97aaf6c07c0..7a67436d343 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -116,6 +116,7 @@ static void WAYLAND_ThreadDetach(void)
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pChangeDisplaySettings = WAYLAND_ChangeDisplaySettings,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
-- 
2.39.0.rc2

From fc01dcedb4531ee2500aea2504dc20610c87d75d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 13 Oct 2022 09:25:28 +0300
Subject: [PATCH 091/202] winewayland.drv: Handle fullscreen windows larger
 than their monitor.

If a window is fullscreen while overshooting the monitor bounds don't
try to resize it. Forcing the Wayland preferred size in such cases may
trigger an endless loop of reconfigurations, while both the compositor
and the app try to continuously enforce their different window
configurations.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 33 ++++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 0485d8b6484..dbdeddf2ad4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -859,6 +859,27 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
     wayland_mutex_unlock(&wsurface->mutex);
 }
 
+static BOOL wayland_win_data_is_fullscreen_with_overshoot(struct wayland_win_data *data)
+{
+    RECT monitor_rect;
+    struct wayland_output *output;
+
+    if (!data->fullscreen) return FALSE;
+    if (!data->wayland_surface) return FALSE;
+
+    output = data->wayland_surface->main_output;
+    if (!output || !output->current_wine_mode) return FALSE;
+
+    SetRect(&monitor_rect, output->x, output->y,
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
+
+    return data->window_rect.left < monitor_rect.left &&
+           data->window_rect.top < monitor_rect.top &&
+           data->window_rect.right >= monitor_rect.right &&
+           data->window_rect.bottom >= monitor_rect.bottom;
+}
+
 static struct wayland_win_data *update_wayland_state(struct wayland_win_data *data)
 {
     HWND hwnd = data->hwnd;
@@ -1419,7 +1440,17 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     }
 
     if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
-        !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        wayland_win_data_is_fullscreen_with_overshoot(data))
+    {
+        /* If the window is fullscreen while overshooting the monitor bounds
+         * don't try to resize it. Forcing the Wayland preferred size in such
+         * cases may trigger an endless loop of resizes while both the
+         * compositor and the app try to enforce different window sizes. */
+        wine_width = 0;
+        wine_height = 0;
+    }
+    else if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+             !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
         wayland_surface_find_wine_fullscreen_fit(wsurface, width, height,
                                                  &wine_width, &wine_height);
-- 
2.39.0.rc2

From fa7931dc3ddb3a6eecf17a6846c8c9bc2d806f44 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 13:41:29 +0300
Subject: [PATCH 092/202] winewayland.drv: Add helper to get client rect in
 window coordinates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 23 +++++++++++++++++++++++
 2 files changed, 24 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index accbc07d6b7..6255f8733d9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -497,6 +497,7 @@ size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
 size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
                           const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
 int wayland_shmfd_create(const char *name, int size) DECLSPEC_HIDDEN;
+void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER32 helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index dbdeddf2ad4..2c58e52906f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1667,3 +1667,26 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     return 0;
 }
+
+/*****************************************************************************
+ *           wayland_get_client_rect_in_win_coords
+ */
+void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect)
+{
+    RECT window_rect;
+    POINT origin = {0, 0};
+
+    if (!NtUserClientToScreen(hwnd, &origin)) goto err;
+    if (!NtUserGetWindowRect(hwnd, &window_rect)) goto err;
+    if (!NtUserGetClientRect(hwnd, client_rect)) goto err;
+
+    OffsetRect(client_rect,
+               origin.x - window_rect.left,
+               origin.y - window_rect.top);
+
+    return;
+
+err:
+    ERR("Failed to get client rect for hwnd %p", hwnd);
+    SetRectEmpty(client_rect);
+}
-- 
2.39.0.rc2

From 0642115ec3c66bc2ac216ce598e236760d44dde4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:48:15 +0300
Subject: [PATCH 093/202] winewayland.drv: Prepare for handling windows with
 OpenGL/VK content.

Use a Wayland subsurface as the target surface for OpenGL/VK rendering
and support reconfiguring it appropriately. The toplevel Wayland surface
is used for all non-client rendering.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 214 +++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |   7 +
 dlls/winewayland.drv/window.c          |  11 +-
 3 files changed, 216 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index c2461b304e4..f5bd30476c1 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -458,6 +458,9 @@ void wayland_surface_reconfigure_position(struct wayland_surface *surface,
  *
  * The coordinates and sizes should be given in wine's coordinate space.
  *
+ * Note that this doesn't configure any associated GL/VK subsurface,
+ * wayland_surface_reconfigure_glvk() needs to be called separately.
+ *
  * This function sets up but doesn't actually apply any new configuration.
  * The wayland_surface_reconfigure_apply() needs to be called for changes
  * to take effect.
@@ -533,21 +536,6 @@ void wayland_surface_reconfigure_size(struct wayland_surface *surface,
     }
 }
 
-/**********************************************************************
- *          wayland_surface_reconfigure_apply
- *
- * Applies the configuration set by previous calls to the
- * wayland_surface_reconfigure{_glvk}() functions.
- */
-void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
-{
-    wl_surface_commit(surface->wl_surface);
-
-    /* Commit the parent so any subsurface repositioning takes effect. */
-    if (surface->parent)
-        wl_surface_commit(surface->parent->wl_surface);
-}
-
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
@@ -759,6 +747,198 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     free(surface);
 }
 
+static struct wayland_surface *wayland_surface_create_glvk_common(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    glvk = wayland_surface_create_plain(surface->wayland);
+    if (!glvk)
+        goto err;
+
+    glvk->parent = wayland_surface_ref(surface);
+
+    wayland_mutex_lock(&glvk->parent->mutex);
+    wl_list_insert(&glvk->parent->child_list, &glvk->parent_link);
+    wayland_mutex_unlock(&glvk->parent->mutex);
+
+    glvk->wl_subsurface =
+        wl_subcompositor_get_subsurface(glvk->wayland->wl_subcompositor,
+                                        glvk->wl_surface,
+                                        surface->wl_surface);
+    if (!glvk->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(glvk->wl_subsurface);
+    /* Place the glvk subsurface just above the parent surface, so that it
+     * doesn't end up obscuring any other subsurfaces. */
+    wl_subsurface_place_above(glvk->wl_subsurface, surface->wl_surface);
+
+    glvk->hwnd = surface->hwnd;
+    glvk->main_output = surface->main_output;
+    wl_surface_set_buffer_scale(glvk->wl_surface, wayland_surface_get_buffer_scale(surface));
+    glvk->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return glvk;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return NULL;
+}
+
+static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = NULL;
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk)
+        glvk = wayland_surface_ref(surface->glvk);
+    wayland_mutex_unlock(&surface->mutex);
+    return glvk;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_glvk
+ *
+ * Creates a GL/VK subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+    RECT client_rect;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (wayland_surface_ref_glvk(surface))
+        return TRUE;
+
+    glvk = wayland_surface_create_glvk_common(surface);
+    if (!glvk)
+        goto err;
+
+    wayland_mutex_lock(&surface->mutex);
+    surface->glvk = glvk;
+    wayland_mutex_unlock(&surface->mutex);
+
+    /* Set initial position in the client area. */
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+
+    wayland_surface_reconfigure_glvk(surface,
+                                     client_rect.left, client_rect.top,
+                                     client_rect.right - client_rect.left,
+                                     client_rect.bottom - client_rect.top);
+
+    wayland_surface_reconfigure_apply(surface);
+
+    return TRUE;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref_glvk
+ *
+ * Unreferences the associated GL/VK subsurface for this wayland surface.
+ */
+void wayland_surface_unref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk_to_destroy = NULL;
+    int ref = -12345;
+
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk && (ref = InterlockedDecrement(&surface->glvk->ref)) == 0)
+    {
+        glvk_to_destroy = surface->glvk;
+        surface->glvk = NULL;
+    }
+    TRACE("surface=%p glvk=%p ref=%d->%d\n",
+          surface, glvk_to_destroy ? glvk_to_destroy : surface->glvk, ref + 1, ref);
+    wayland_mutex_unlock(&surface->mutex);
+
+    if (glvk_to_destroy)
+        wayland_surface_destroy(glvk_to_destroy);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_glvk
+ *
+ * Configures the position and size of the GL/VK subsurface associated with
+ * a wayland surface.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      int wine_width, int wine_height)
+{
+    int x, y, width, height;
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (!glvk)
+        return;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    glvk->offset_x = wine_x;
+    glvk->offset_y = wine_y;
+
+    wl_subsurface_set_position(glvk->wl_subsurface, x, y);
+
+    /* Use a viewport, if supported, to ensure GL surfaces remain inside their
+     * parent's boundaries when resizing and also to handle display mode
+     * changes. If the size is invalid use a 1x1 destination (instead of
+     * unsetting with -1x-1) since many apps don't respect a GL/VK 0x0 size
+     * which can happen, e.g., when an app is minimized. */
+    if (glvk->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(glvk->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(glvk->wp_viewport, 1, 1);
+    }
+
+    wayland_surface_unref_glvk(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (glvk)
+    {
+        wl_surface_commit(glvk->wl_surface);
+        wayland_surface_unref_glvk(surface);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
 /**********************************************************************
  *          wayland_surface_unmap
  *
@@ -792,6 +972,10 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
 
     NtUserGetWindowRect(surface->hwnd, &window_rect);
 
+    /* Some wayland surfaces are offset relative to their window rect,
+     * e.g., GL subsurfaces. */
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
     *screen_x = wine_x + window_rect.left;
     *screen_y = wine_y + window_rect.top;
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6255f8733d9..12799d94890 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -219,6 +219,9 @@ struct wayland_surface
     struct xdg_toplevel *xdg_toplevel;
     struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
+    struct wayland_surface *glvk;
+    /* The offset of this surface relative to its owning win32 window */
+    int offset_x, offset_y;
     HWND hwnd;
     struct wayland_mutex mutex;
     struct wayland_surface_configure pending;
@@ -370,6 +373,10 @@ void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
 void wayland_surface_reconfigure_size(struct wayland_surface *surface,
                                       int width, int height) DECLSPEC_HIDDEN;
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
+                                      int width, int height) DECLSPEC_HIDDEN;
 void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2c58e52906f..77c2a9f50f0 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -851,7 +851,16 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
                                              compat.bottom - compat.top);
     }
 
-    wayland_surface_reconfigure_apply(wsurface);
+    /* The GL/VK subsurface (if any), is positioned over the client area of the
+     * window. The position of the GL/VK subsurface is relative to the window
+     * top-left. */
+    wayland_surface_reconfigure_glvk(wsurface,
+                                     data->client_rect.left - data->window_rect.left,
+                                     data->client_rect.top - data->window_rect.top,
+                                     data->client_rect.right - data->client_rect.left,
+                                     data->client_rect.bottom - data->client_rect.top);
+
+    wayland_surface_reconfigure_apply(data->wayland_surface);
 
     if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
         wsurface->drawing_allowed = TRUE;
-- 
2.39.0.rc2

From c1f03b95e538ef9010b1b7cd680fce1dd2588df6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 18 Mar 2022 15:50:23 +0200
Subject: [PATCH 094/202] winewayland.drv: Introduce support for dmabuf
 buffers.

We will be using dmabuf buffers to implement WGL support in upcoming
commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                             |  83 ++++++++++++++++-
 configure.ac                          |   6 +-
 dlls/winewayland.drv/Makefile.in      |   7 +-
 dlls/winewayland.drv/wayland.c        |  14 ++-
 dlls/winewayland.drv/wayland_dmabuf.c | 128 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  27 ++++++
 include/config.h.in                   |   3 +
 7 files changed, 262 insertions(+), 6 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_dmabuf.c

diff --git a/configure b/configure
index c9db642a0e6..7849a893a4d 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+DRM_LIBS
+DRM_CFLAGS
 XKBCOMMON_LIBS
 XKBCOMMON_CFLAGS
 WAYLAND_CURSOR_LIBS
@@ -1754,6 +1756,8 @@ WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS
 XKBCOMMON_CFLAGS
 XKBCOMMON_LIBS
+DRM_CFLAGS
+DRM_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2569,6 +2573,8 @@ Some influential environment variables:
               C compiler flags for xkbcommon, overriding pkg-config
   XKBCOMMON_LIBS
               Linker flags for xkbcommon, overriding pkg-config
+  DRM_CFLAGS  C compiler flags for libdrm, overriding pkg-config
+  DRM_LIBS    Linker flags for libdrm, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -16193,6 +16199,78 @@ else $as_nop
   XKBCOMMON_LIBS=""
 fi
 
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${DRM_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DRM_CFLAGS=`$PKG_CONFIG --cflags libdrm 2>/dev/null`
+fi
+fi
+
+if ${DRM_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DRM_LIBS=`$PKG_CONFIG --libs libdrm 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdrm cflags: $DRM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdrm libs: $DRM_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $DRM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "drm.h" "ac_cv_header_drm_h" "$ac_includes_default"
+if test "x$ac_cv_header_drm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_DRM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for drmPrimeHandleToFD in -ldrm" >&5
+printf %s "checking for drmPrimeHandleToFD in -ldrm... " >&6; }
+if test ${ac_cv_lib_drm_drmPrimeHandleToFD+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldrm $DRM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char drmPrimeHandleToFD ();
+int
+main (void)
+{
+return drmPrimeHandleToFD ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_drm_drmPrimeHandleToFD=yes
+else $as_nop
+  ac_cv_lib_drm_drmPrimeHandleToFD=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_drm_drmPrimeHandleToFD" >&5
+printf "%s\n" "$ac_cv_lib_drm_drmPrimeHandleToFD" >&6; }
+if test "x$ac_cv_lib_drm_drmPrimeHandleToFD" = xyes
+then :
+  :
+else $as_nop
+  DRM_LIBS=""
+fi
+
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
@@ -16200,7 +16278,8 @@ if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
                            test -z "$WAYLAND_SCANNER" ||
                            test -z "$WAYLAND_CURSOR_LIBS" ||
-                           test -z "$XKBCOMMON_LIBS"
+                           test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$DRM_LIBS"
 then :
   case "x$with_wayland" in
   x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
@@ -23577,6 +23656,8 @@ WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
 XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
 XKBCOMMON_LIBS = $XKBCOMMON_LIBS
+DRM_CFLAGS = $DRM_CFLAGS
+DRM_LIBS = $DRM_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index b633c2a9e53..1eb0995ee07 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1426,12 +1426,16 @@ then
     WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
         [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
          AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
+        [AC_CHECK_HEADERS([drm.h])
+         AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
                            test -z "$WAYLAND_SCANNER" ||
                            test -z "$WAYLAND_CURSOR_LIBS" ||
-                           test -z "$XKBCOMMON_LIBS"],
+                           test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$DRM_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4beb8eb6c6d..5d14f8ac19c 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,8 +1,9 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS)
+UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
+              $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
-            $(XKBCOMMON_LIBS) $(PTHREAD_LIBS)
+            $(XKBCOMMON_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
 	display.c \
@@ -13,6 +14,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_dmabuf.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
 	wayland_mutex.c \
@@ -30,6 +32,7 @@ C_SRCS = \
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f72a346fba2..e027216b3f2 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -237,9 +237,16 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
     }
+    else if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0)
+    {
+        struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1 =
+            wl_registry_bind(registry, id, &zwp_linux_dmabuf_v1_interface,
+                             version < 2 ? version : 2);
+        wayland_dmabuf_init(&wayland->dmabuf, zwp_linux_dmabuf_v1);
+    }
 
-    /* The per-process wayland instance only handles output related
-     * and wl_shm globals. */
+    /* The per-process wayland instance should not handle every global, as there
+     * is no point. Many globals are only needed by the per-thread instances. */
     if (wayland_is_process(wayland)) return;
 
     if (strcmp(interface, "wl_compositor") == 0)
@@ -463,6 +470,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
+    if (wayland->dmabuf.zwp_linux_dmabuf_v1)
+        wayland_dmabuf_deinit(&wayland->dmabuf);
+
     if (wayland->wp_viewporter)
         wp_viewporter_destroy(wayland->wp_viewporter);
 
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
new file mode 100644
index 00000000000..99125c814fc
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -0,0 +1,128 @@
+/*
+ * Wayland dmabuf buffers
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <drm_fourcc.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/***********************************************************************
+ *           wayland_dmabuf_init
+ */
+void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
+                         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+    dmabuf->zwp_linux_dmabuf_v1 = zwp_linux_dmabuf_v1;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_deinit
+ */
+void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
+{
+    if (dmabuf->zwp_linux_dmabuf_v1)
+        zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_from_native
+ *
+ * Creates a wayland dmabuf buffer from the specified native buffer.
+ */
+struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
+                                                                       struct wayland_native_buffer *native)
+{
+    struct wayland_dmabuf_buffer *dmabuf_buffer;
+    struct zwp_linux_buffer_params_v1 *params;
+    int i;
+
+    dmabuf_buffer = calloc(1, sizeof(*dmabuf_buffer));
+    if (!dmabuf_buffer)
+        goto err;
+
+    params = zwp_linux_dmabuf_v1_create_params(wayland->dmabuf.zwp_linux_dmabuf_v1);
+    for (i = 0; i < native->plane_count; i++)
+    {
+        zwp_linux_buffer_params_v1_add(params,
+                                       native->fds[i],
+                                       i,
+                                       native->offsets[i],
+                                       native->strides[i],
+                                       native->modifier >> 32,
+                                       native->modifier & 0xffffffff);
+    }
+
+    dmabuf_buffer->wl_buffer =
+        zwp_linux_buffer_params_v1_create_immed(params,
+                                                native->width,
+                                                native->height,
+                                                native->format,
+                                                0);
+
+    zwp_linux_buffer_params_v1_destroy(params);
+
+    return dmabuf_buffer;
+
+err:
+    if (dmabuf_buffer)
+        wayland_dmabuf_buffer_destroy(dmabuf_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_destroy
+ *
+ * Destroys a dmabuf buffer.
+ */
+void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer)
+{
+    TRACE("%p\n", dmabuf_buffer);
+
+    if (dmabuf_buffer->wl_buffer)
+        wl_buffer_destroy(dmabuf_buffer->wl_buffer);
+
+    free(dmabuf_buffer);
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a dmabuf buffer and destroy the dmabuf buffer.
+ */
+struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = dmabuf_buffer->wl_buffer;
+    dmabuf_buffer->wl_buffer = NULL;
+
+    wayland_dmabuf_buffer_destroy(dmabuf_buffer);
+
+    return wl_buffer;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12799d94890..681069ae54b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,7 @@
 #include <wayland-cursor.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -132,6 +133,11 @@ struct wayland_pointer
     HCURSOR hcursor;
 };
 
+struct wayland_dmabuf
+{
+    struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1;
+};
+
 struct wayland
 {
     struct wl_list thread_link;
@@ -155,6 +161,7 @@ struct wayland
     struct wl_list surface_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
+    struct wayland_dmabuf dmabuf;
     DWORD last_dispatch_mask;
     uint32_t last_button_serial;
     int last_event_type;
@@ -260,6 +267,14 @@ struct wayland_shm_buffer
     BOOL detached;
 };
 
+struct wayland_dmabuf_buffer
+{
+   struct wl_list link;
+   struct wl_buffer *wl_buffer;
+   int width, height, stride;
+   uint32_t format;
+};
+
 struct wayland_buffer_queue
 {
     struct wayland *wayland;
@@ -425,6 +440,18 @@ void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN d
 RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
                                                HRGN clip) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland dmabuf
+ */
+
+void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
+                         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1) DECLSPEC_HIDDEN;
+void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
+                                                                       struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Wayland buffer queue
  */
diff --git a/include/config.h.in b/include/config.h.in
index a2b4b97d450..0c01995f823 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -53,6 +53,9 @@
 /* Define to 1 if you have the `dlinfo' function. */
 #undef HAVE_DLINFO
 
+/* Define to 1 if you have the <drm.h> header file. */
+#undef HAVE_DRM_H
+
 /* Define to 1 if you have the <EGL/egl.h> header file. */
 #undef HAVE_EGL_EGL_H
 
-- 
2.39.0.rc2

From 858a45bf0bff2f7d217eab0ec0d84673f5b81e73 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sergio=20G=C3=B3mez=20Del=20Real?=
 <sergio.gdr@collabora.com>
Date: Sun, 5 Jun 2022 11:13:57 -0500
Subject: [PATCH 095/202] winewayland.drv: Introduce support for format and
 modifier zwp_linux_dmabuf_v1 events.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Sergio Gómez Del Real <sergio.gdr@collabora.com>
---
 dlls/winewayland.drv/wayland.c        |   2 +-
 dlls/winewayland.drv/wayland_dmabuf.c | 109 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |   7 ++
 3 files changed, 117 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index e027216b3f2..8e7b7328a22 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -241,7 +241,7 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1 =
             wl_registry_bind(registry, id, &zwp_linux_dmabuf_v1_interface,
-                             version < 2 ? version : 2);
+                             version < 3 ? version : 3);
         wayland_dmabuf_init(&wayland->dmabuf, zwp_linux_dmabuf_v1);
     }
 
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index 99125c814fc..c00219c237a 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -32,6 +32,111 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/**********************************************************************
+ *          dmabuf private helpers
+ */
+
+static BOOL dmabuf_format_has_modifier(struct wayland_dmabuf_format *format, uint64_t modifier)
+{
+    uint64_t *mod;
+
+    wl_array_for_each(mod, &format->modifiers)
+        if (*mod == modifier) return TRUE;
+
+    return FALSE;
+}
+
+static struct wayland_dmabuf_format *dmabuf_format_array_find_format(struct wl_array *formats,
+                                                                     uint32_t format)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+    BOOL format_found = FALSE;
+
+    wl_array_for_each(dmabuf_format, formats)
+    {
+        if (dmabuf_format->format == format)
+        {
+            format_found = TRUE;
+            break;
+        }
+    }
+
+    if (!format_found) dmabuf_format = NULL;
+
+    return dmabuf_format;
+}
+
+static BOOL dmabuf_format_array_add_format_modifier(struct wl_array *formats,
+                                                    uint32_t format,
+                                                    uint64_t modifier)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+    uint64_t *mod;
+
+    if ((dmabuf_format = dmabuf_format_array_find_format(formats, format)))
+    {
+        /* Avoid a possible duplicate, e.g., if compositor sends both format and
+         * modifier event with a DRM_FORMAT_MOD_INVALID. */
+        if (dmabuf_format_has_modifier(dmabuf_format, modifier))
+            goto out;
+    }
+    else
+    {
+        if (!(dmabuf_format = wl_array_add(formats, sizeof(*dmabuf_format))))
+            goto out;
+        dmabuf_format->format = format;
+        wl_array_init(&dmabuf_format->modifiers);
+    }
+
+    if (!(mod = wl_array_add(&dmabuf_format->modifiers, sizeof(uint64_t))))
+    {
+        dmabuf_format = NULL;
+        goto out;
+    }
+
+    *mod = modifier;
+
+out:
+    return dmabuf_format != NULL;
+}
+
+static void dmabuf_format_array_release(struct wl_array *formats)
+{
+    struct wayland_dmabuf_format *format;
+
+    wl_array_for_each(format, formats)
+        wl_array_release(&format->modifiers);
+
+    wl_array_release(formats);
+}
+
+/**********************************************************************
+ *          zwp_linux_dmabuf_v1 handling
+ */
+
+static void dmabuf_format(void *data, struct zwp_linux_dmabuf_v1 *zwp_dmabuf, uint32_t format)
+{
+    struct wayland_dmabuf *dmabuf = data;
+
+    if (!dmabuf_format_array_add_format_modifier(&dmabuf->formats, format, DRM_FORMAT_MOD_INVALID))
+        WARN("Could not add format 0x%08x\n", format);
+}
+
+static void dmabuf_modifiers(void *data, struct zwp_linux_dmabuf_v1 *zwp_dmabuf, uint32_t format,
+                             uint32_t mod_hi, uint32_t mod_lo)
+{
+    struct wayland_dmabuf *dmabuf = data;
+    const uint64_t modifier = (uint64_t)mod_hi << 32 | mod_lo;
+
+    if (!dmabuf_format_array_add_format_modifier(&dmabuf->formats, format, modifier))
+        WARN("Could not add format/modifier 0x%08x/0x%" PRIx64 "\n", format, modifier);
+}
+
+static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
+    dmabuf_format,
+    dmabuf_modifiers
+};
+
 /***********************************************************************
  *           wayland_dmabuf_init
  */
@@ -39,6 +144,8 @@ void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
                          struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
 {
     dmabuf->zwp_linux_dmabuf_v1 = zwp_linux_dmabuf_v1;
+    wl_array_init(&dmabuf->formats);
+    zwp_linux_dmabuf_v1_add_listener(zwp_linux_dmabuf_v1, &dmabuf_listener, dmabuf);
 }
 
 /***********************************************************************
@@ -46,6 +153,8 @@ void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
  */
 void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
 {
+    dmabuf_format_array_release(&dmabuf->formats);
+
     if (dmabuf->zwp_linux_dmabuf_v1)
         zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 681069ae54b..aa440e57488 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,9 +133,16 @@ struct wayland_pointer
     HCURSOR hcursor;
 };
 
+struct wayland_dmabuf_format
+{
+    uint32_t format;
+    struct wl_array modifiers;
+};
+
 struct wayland_dmabuf
 {
     struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1;
+    struct wl_array formats;
 };
 
 struct wayland
-- 
2.39.0.rc2

From b14c4af4461088e5fca6cfd28c59d79409910a51 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Fri, 29 Apr 2022 16:23:08 -0300
Subject: [PATCH 096/202] winewayland.drv: Introduce support for dmabuf
 feedback.

This bumps dmabuf supported version up to 4, and binds to the dmabuf
feedback interface.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/wayland.c        |   2 +-
 dlls/winewayland.drv/wayland_dmabuf.c | 188 +++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h     |  27 ++++
 3 files changed, 215 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 8e7b7328a22..cc73c70fbc8 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -241,7 +241,7 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1 =
             wl_registry_bind(registry, id, &zwp_linux_dmabuf_v1_interface,
-                             version < 3 ? version : 3);
+                             version < 4 ? version : 4);
         wayland_dmabuf_init(&wayland->dmabuf, zwp_linux_dmabuf_v1);
     }
 
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index c00219c237a..3938963e240 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -29,6 +29,8 @@
 
 #include <drm_fourcc.h>
 #include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
@@ -36,6 +38,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
  *          dmabuf private helpers
  */
 
+static BOOL dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
+{
+    return dmabuf->version >= ZWP_LINUX_DMABUF_V1_GET_DEFAULT_FEEDBACK_SINCE_VERSION;
+}
+
 static BOOL dmabuf_format_has_modifier(struct wayland_dmabuf_format *format, uint64_t modifier)
 {
     uint64_t *mod;
@@ -110,6 +117,20 @@ static void dmabuf_format_array_release(struct wl_array *formats)
     wl_array_release(formats);
 }
 
+static void dmabuf_feedback_tranche_init(struct wayland_dmabuf_feedback_tranche *tranche)
+{
+    memset(tranche, 0, sizeof(*tranche));
+    wl_array_init(&tranche->formats);
+}
+
+/* Moves src tranche to dst, and resets src. */
+static void dmabuf_feedback_tranche_move(struct wayland_dmabuf_feedback_tranche *dst,
+                                         struct wayland_dmabuf_feedback_tranche *src)
+{
+    memcpy(dst, src, sizeof(*dst));
+    dmabuf_feedback_tranche_init(src);
+}
+
 /**********************************************************************
  *          zwp_linux_dmabuf_v1 handling
  */
@@ -137,15 +158,174 @@ static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
     dmabuf_modifiers
 };
 
+/**********************************************************************
+ *          default feedback handling
+ */
+
+static void dmabuf_feedback_main_device(void *data,
+                                        struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                        struct wl_array *device)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    if (device->size != sizeof(feedback->main_device))
+        return;
+
+    memcpy(&feedback->main_device, device->data, device->size);
+}
+
+static void dmabuf_feedback_format_table(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                         int32_t fd, uint32_t size)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    feedback->format_table_entries = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (feedback->format_table_entries == MAP_FAILED)
+    {
+        WARN("Failed to mmap format table entries. fd %d size %u.\n", fd, size);
+        feedback->format_table_entries = NULL;
+        close(fd);
+        return;
+    }
+
+    feedback->format_table_size = size;
+    close(fd);
+}
+
+static void dmabuf_feedback_tranche_target_device(void *data,
+                                                  struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                  struct wl_array *device)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    memcpy(&feedback->pending_tranche.device, device->data, sizeof(dev_t));
+}
+
+static void dmabuf_feedback_tranche_formats(void *data,
+                                            struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                            struct wl_array *indices)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+    struct wayland_dmabuf_feedback_format_table_entry *table_entries = feedback->format_table_entries;
+    uint16_t *index;
+
+    if (!table_entries)
+    {
+        WARN("Could not add formats/modifiers to tranche due to missing format table\n");
+        return;
+    }
+
+    wl_array_for_each(index, indices)
+    {
+        if (!dmabuf_format_array_add_format_modifier(&feedback->pending_tranche.formats,
+                                                     table_entries[*index].format,
+                                                     table_entries[*index].modifier))
+        {
+            WARN("Could not add format/modifier 0x%08x/0x%" PRIx64 "\n",
+                 table_entries[*index].format,
+                 table_entries[*index].modifier);
+        }
+    }
+}
+
+static void dmabuf_feedback_tranche_flags(void *data,
+                                          struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                          uint32_t flags)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    feedback->pending_tranche.flags = flags;
+}
+
+static void dmabuf_feedback_tranche_done(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+    struct wayland_dmabuf_feedback_tranche *tranche;
+
+    if (feedback->pending_tranche.formats.size == 0 ||
+        !(tranche = wl_array_add(&feedback->tranches, sizeof(*tranche))))
+    {
+        WARN("Failed to add tranche with target device %ju\n",
+             (uintmax_t)feedback->pending_tranche.device);
+        dmabuf_format_array_release(&feedback->pending_tranche.formats);
+        dmabuf_feedback_tranche_init(&feedback->pending_tranche);
+        return;
+    }
+    dmabuf_feedback_tranche_move(tranche, &feedback->pending_tranche);
+}
+
+static void dmabuf_feedback_done(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    /* ignore event */
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener dmabuf_feedback_listener =
+{
+    .main_device = dmabuf_feedback_main_device,
+    .format_table = dmabuf_feedback_format_table,
+    .tranche_target_device = dmabuf_feedback_tranche_target_device,
+    .tranche_formats = dmabuf_feedback_tranche_formats,
+    .tranche_flags = dmabuf_feedback_tranche_flags,
+    .tranche_done = dmabuf_feedback_tranche_done,
+    .done = dmabuf_feedback_done,
+};
+
+static void dmabuf_feedback_destroy(struct wayland_dmabuf_feedback *feedback)
+{
+    struct wayland_dmabuf_feedback_tranche *tranche;
+
+    dmabuf_format_array_release(&feedback->pending_tranche.formats);
+
+    wl_array_for_each(tranche, &feedback->tranches)
+        dmabuf_format_array_release(&tranche->formats);
+    wl_array_release(&feedback->tranches);
+
+    free(feedback);
+}
+
+static struct wayland_dmabuf_feedback *dmabuf_feedback_create(void)
+{
+    struct wayland_dmabuf_feedback *feedback;
+
+    feedback = calloc(1, sizeof(*feedback));
+    if (!feedback) return NULL;
+
+    wl_array_init(&feedback->tranches);
+    dmabuf_feedback_tranche_init(&feedback->pending_tranche);
+
+    return feedback;
+}
+
 /***********************************************************************
  *           wayland_dmabuf_init
  */
 void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
                          struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
 {
+    dmabuf->version = wl_proxy_get_version((struct wl_proxy *)zwp_linux_dmabuf_v1);
     dmabuf->zwp_linux_dmabuf_v1 = zwp_linux_dmabuf_v1;
     wl_array_init(&dmabuf->formats);
-    zwp_linux_dmabuf_v1_add_listener(zwp_linux_dmabuf_v1, &dmabuf_listener, dmabuf);
+
+    /* linux-dmabuf feedback events deprecate format/modifier events from
+     * previous versions. Listen to pre-v4 events only if v4 is not supported. */
+    if (dmabuf_has_feedback_support(dmabuf))
+    {
+        if (!(dmabuf->default_feedback = dmabuf_feedback_create()))
+        {
+            WARN("Could not create default dmabuf feedback: Memory allocation failure.\n");
+            return;
+        }
+        dmabuf->zwp_linux_dmabuf_feedback_v1 =
+            zwp_linux_dmabuf_v1_get_default_feedback(dmabuf->zwp_linux_dmabuf_v1);
+        zwp_linux_dmabuf_feedback_v1_add_listener(dmabuf->zwp_linux_dmabuf_feedback_v1,
+                                                  &dmabuf_feedback_listener,
+                                                  dmabuf->default_feedback);
+    }
+    else
+        zwp_linux_dmabuf_v1_add_listener(zwp_linux_dmabuf_v1, &dmabuf_listener, dmabuf);
 }
 
 /***********************************************************************
@@ -153,6 +333,12 @@ void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
  */
 void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
 {
+    if (dmabuf->zwp_linux_dmabuf_feedback_v1)
+    {
+        dmabuf_feedback_destroy(dmabuf->default_feedback);
+        zwp_linux_dmabuf_feedback_v1_destroy(dmabuf->zwp_linux_dmabuf_feedback_v1);
+    }
+
     dmabuf_format_array_release(&dmabuf->formats);
 
     if (dmabuf->zwp_linux_dmabuf_v1)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index aa440e57488..372cfabc507 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -26,6 +26,7 @@
 #endif
 
 #include <pthread.h>
+#include <sys/types.h>
 #include <stdarg.h>
 #include <wayland-client.h>
 #include <wayland-cursor.h>
@@ -139,10 +140,36 @@ struct wayland_dmabuf_format
     struct wl_array modifiers;
 };
 
+struct wayland_dmabuf_feedback_tranche
+{
+    struct wl_array formats;
+    uint32_t flags;
+    dev_t device;
+};
+
+struct wayland_dmabuf_feedback_format_table_entry
+{
+    uint32_t format;
+    uint32_t padding; /* unused */
+    uint64_t modifier;
+};
+
+struct wayland_dmabuf_feedback
+{
+    dev_t main_device;
+    uint32_t format_table_size;
+    struct wayland_dmabuf_feedback_format_table_entry *format_table_entries;
+    struct wayland_dmabuf_feedback_tranche pending_tranche;
+    struct wl_array tranches;
+};
+
 struct wayland_dmabuf
 {
     struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1;
+    uint32_t version;
     struct wl_array formats;
+    struct wayland_dmabuf_feedback *default_feedback;
+    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
 };
 
 struct wayland
-- 
2.39.0.rc2

From c6ae0b10277722f0f4dd12fb06258b3bbe3171a0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sergio=20G=C3=B3mez=20Del=20Real?=
 <sergio.gdr@collabora.com>
Date: Tue, 4 Oct 2022 16:17:49 -0500
Subject: [PATCH 097/202] winewayland.drv: Introduce support for per-surface
 dmabuf feedback.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Sergio Gómez Del Real <sergio.gdr@collabora.com>
---
 dlls/winewayland.drv/wayland_dmabuf.c  | 158 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |   3 +
 dlls/winewayland.drv/waylanddrv.h      |  15 +++
 3 files changed, 176 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index 3938963e240..80881c30acb 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -299,6 +299,106 @@ static struct wayland_dmabuf_feedback *dmabuf_feedback_create(void)
     return feedback;
 }
 
+/**********************************************************************
+ *          per-surface feedback handling
+ */
+
+static void surface_dmabuf_feedback_main_device(void *data,
+                                                struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                struct wl_array *device)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_main_device(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, device);
+}
+
+static void surface_dmabuf_feedback_format_table(void *data,
+                                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                 int32_t fd, uint32_t size)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_format_table(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, fd, size);
+}
+
+static void surface_dmabuf_feedback_tranche_target_device(void *data,
+                                                          struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                          struct wl_array *device)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_tranche_target_device(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, device);
+}
+
+static void surface_dmabuf_feedback_tranche_formats(void *data,
+                                                    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                    struct wl_array *indices)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    if (!surface_feedback->pending_feedback->format_table_entries &&
+        (!(surface_feedback->pending_feedback->format_table_entries = surface_feedback->feedback->format_table_entries)))
+    {
+        WARN("Could not add formats/modifiers to tranche due to missing format table\n");
+        return;
+    }
+    dmabuf_feedback_tranche_formats(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, indices);
+}
+
+static void surface_dmabuf_feedback_tranche_flags(void *data,
+                                                  struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                  uint32_t flags)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    surface_feedback->pending_feedback->pending_tranche.flags = flags;
+}
+
+static void surface_dmabuf_feedback_tranche_done(void *data,
+                                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_tranche_done(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1);
+}
+
+static void surface_dmabuf_feedback_done(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    if (!surface_feedback->pending_feedback->format_table_entries)
+    {
+        WARN("Invalid format table: Ignoring feedback events.\n");
+        dmabuf_feedback_destroy(surface_feedback->pending_feedback);
+        goto out;
+    }
+
+    wayland_dmabuf_surface_feedback_lock(surface_feedback);
+
+    if (surface_feedback->feedback)
+        dmabuf_feedback_destroy(surface_feedback->feedback);
+
+    surface_feedback->feedback = surface_feedback->pending_feedback;
+    surface_feedback->surface_needs_update = TRUE;
+
+    wayland_dmabuf_surface_feedback_unlock(surface_feedback);
+
+out:
+    surface_feedback->pending_feedback = dmabuf_feedback_create();
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener surface_dmabuf_feedback_listener =
+{
+    .main_device = surface_dmabuf_feedback_main_device,
+    .format_table = surface_dmabuf_feedback_format_table,
+    .tranche_target_device = surface_dmabuf_feedback_tranche_target_device,
+    .tranche_formats = surface_dmabuf_feedback_tranche_formats,
+    .tranche_flags = surface_dmabuf_feedback_tranche_flags,
+    .tranche_done = surface_dmabuf_feedback_tranche_done,
+    .done = surface_dmabuf_feedback_done,
+};
+
 /***********************************************************************
  *           wayland_dmabuf_init
  */
@@ -345,6 +445,64 @@ void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
         zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
 }
 
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_create
+ */
+struct wayland_dmabuf_surface_feedback *wayland_dmabuf_surface_feedback_create(struct wayland_dmabuf *dmabuf,
+                                                                               struct wl_surface *wl_surface)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = NULL;
+
+    if (!(surface_feedback = calloc(1, sizeof(*surface_feedback))) ||
+        !(surface_feedback->pending_feedback = dmabuf_feedback_create()))
+    {
+        WARN("Failed to create surface feedback: Memory allocation error.");
+        free(surface_feedback);
+        return NULL;
+    }
+
+    wayland_mutex_init(&surface_feedback->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_dmabuf_surface_feedback");
+
+    surface_feedback->zwp_linux_dmabuf_feedback_v1 =
+        zwp_linux_dmabuf_v1_get_surface_feedback(dmabuf->zwp_linux_dmabuf_v1, wl_surface);
+    zwp_linux_dmabuf_feedback_v1_add_listener(surface_feedback->zwp_linux_dmabuf_feedback_v1,
+                                              &surface_dmabuf_feedback_listener,
+                                              surface_feedback);
+
+    return surface_feedback;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_destroy
+ */
+void wayland_dmabuf_surface_feedback_destroy(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    if (surface_feedback->feedback)
+        dmabuf_feedback_destroy(surface_feedback->feedback);
+
+    dmabuf_feedback_destroy(surface_feedback->pending_feedback);
+    zwp_linux_dmabuf_feedback_v1_destroy(surface_feedback->zwp_linux_dmabuf_feedback_v1);
+    wayland_mutex_destroy(&surface_feedback->mutex);
+    free(surface_feedback);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_lock
+ */
+void wayland_dmabuf_surface_feedback_lock(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    if (surface_feedback) wayland_mutex_lock(&surface_feedback->mutex);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_unlock
+ */
+void wayland_dmabuf_surface_feedback_unlock(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    wayland_mutex_unlock(&surface_feedback->mutex);
+}
+
 /**********************************************************************
  *          wayland_dmabuf_buffer_from_native
  *
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index f5bd30476c1..eb0d2cc9213 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -698,6 +698,9 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         free(ref);
     }
 
+    if (surface->surface_feedback)
+        wayland_dmabuf_surface_feedback_destroy(surface->surface_feedback);
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 372cfabc507..f68b7b4b3f2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -163,6 +163,15 @@ struct wayland_dmabuf_feedback
     struct wl_array tranches;
 };
 
+struct wayland_dmabuf_surface_feedback
+{
+    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
+    struct wayland_dmabuf_feedback *feedback;
+    struct wayland_dmabuf_feedback *pending_feedback;
+    struct wayland_mutex mutex;
+    BOOL surface_needs_update;
+};
+
 struct wayland_dmabuf
 {
     struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1;
@@ -261,6 +270,7 @@ struct wayland_surface
     struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
     struct wayland_surface *glvk;
+    struct wayland_dmabuf_surface_feedback *surface_feedback;
     /* The offset of this surface relative to its owning win32 window */
     int offset_x, offset_y;
     HWND hwnd;
@@ -485,6 +495,11 @@ struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wa
                                                                        struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
 struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_surface_feedback *wayland_dmabuf_surface_feedback_create(struct wayland_dmabuf *dmabuf,
+                                                                               struct wl_surface *wl_surface) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_destroy(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_lock(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_unlock(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland buffer queue
-- 
2.39.0.rc2

From eec068a3ce7ab55a01ea4260acf5768fb2150829 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 5 May 2022 12:46:37 +0300
Subject: [PATCH 098/202] winewayland.drv: Introduce support for GBM.

We will be using GBM to allocate buffers for OpenGL rendering.

GBM requires a valid DRM device. We try to find a suitable device,
prioritizing DRM render nodes over DRM primary nodes. The user
can specify a particular DRM device using the "DRMDevice" driver
registry option.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                    |  81 ++++++++
 configure.ac                                 |   4 +
 dlls/winewayland.drv/Makefile.in             |   5 +-
 dlls/winewayland.drv/gbm.c                   | 185 +++++++++++++++++++
 dlls/winewayland.drv/options.c               |   4 +
 dlls/winewayland.drv/wayland_native_buffer.c |  52 ++++++
 dlls/winewayland.drv/waylanddrv.h            |  11 ++
 include/config.h.in                          |   3 +
 8 files changed, 343 insertions(+), 2 deletions(-)
 create mode 100644 dlls/winewayland.drv/gbm.c

diff --git a/configure b/configure
index 7849a893a4d..d381850891f 100755
--- a/configure
+++ b/configure
@@ -703,6 +703,8 @@ INOTIFY_CFLAGS
 PCAP_LIBS
 DRM_LIBS
 DRM_CFLAGS
+GBM_LIBS
+GBM_CFLAGS
 XKBCOMMON_LIBS
 XKBCOMMON_CFLAGS
 WAYLAND_CURSOR_LIBS
@@ -1756,6 +1758,8 @@ WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS
 XKBCOMMON_CFLAGS
 XKBCOMMON_LIBS
+GBM_CFLAGS
+GBM_LIBS
 DRM_CFLAGS
 DRM_LIBS
 INOTIFY_CFLAGS
@@ -2573,6 +2577,8 @@ Some influential environment variables:
               C compiler flags for xkbcommon, overriding pkg-config
   XKBCOMMON_LIBS
               Linker flags for xkbcommon, overriding pkg-config
+  GBM_CFLAGS  C compiler flags for gbm, overriding pkg-config
+  GBM_LIBS    Linker flags for gbm, overriding pkg-config
   DRM_CFLAGS  C compiler flags for libdrm, overriding pkg-config
   DRM_LIBS    Linker flags for libdrm, overriding pkg-config
   INOTIFY_CFLAGS
@@ -16199,6 +16205,78 @@ else $as_nop
   XKBCOMMON_LIBS=""
 fi
 
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${GBM_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GBM_CFLAGS=`$PKG_CONFIG --cflags gbm 2>/dev/null`
+fi
+fi
+
+if ${GBM_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GBM_LIBS=`$PKG_CONFIG --libs gbm 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm cflags: $GBM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm libs: $GBM_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GBM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gbm.h" "ac_cv_header_gbm_h" "$ac_includes_default"
+if test "x$ac_cv_header_gbm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GBM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gbm_create_device in -lgbm" >&5
+printf %s "checking for gbm_create_device in -lgbm... " >&6; }
+if test ${ac_cv_lib_gbm_gbm_create_device+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgbm $GBM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char gbm_create_device ();
+int
+main (void)
+{
+return gbm_create_device ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gbm_gbm_create_device=yes
+else $as_nop
+  ac_cv_lib_gbm_gbm_create_device=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gbm_gbm_create_device" >&5
+printf "%s\n" "$ac_cv_lib_gbm_gbm_create_device" >&6; }
+if test "x$ac_cv_lib_gbm_gbm_create_device" = xyes
+then :
+  :
+else $as_nop
+  GBM_LIBS=""
+fi
+
 CPPFLAGS=$ac_save_CPPFLAGS
 
     if ${DRM_CFLAGS:+false} :
@@ -16279,6 +16357,7 @@ if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_SCANNER" ||
                            test -z "$WAYLAND_CURSOR_LIBS" ||
                            test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
                            test -z "$DRM_LIBS"
 then :
   case "x$with_wayland" in
@@ -23656,6 +23735,8 @@ WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
 XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
 XKBCOMMON_LIBS = $XKBCOMMON_LIBS
+GBM_CFLAGS = $GBM_CFLAGS
+GBM_LIBS = $GBM_LIBS
 DRM_CFLAGS = $DRM_CFLAGS
 DRM_LIBS = $DRM_LIBS
 PCAP_LIBS = $PCAP_LIBS
diff --git a/configure.ac b/configure.ac
index 1eb0995ee07..74110c9c073 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1426,6 +1426,9 @@ then
     WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
         [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
          AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(GBM,[gbm],,,,
+        [AC_CHECK_HEADERS([gbm.h])
+         AC_CHECK_LIB(gbm,gbm_create_device,[:],[GBM_LIBS=""],[$GBM_LIBS])])
     WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
         [AC_CHECK_HEADERS([drm.h])
          AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
@@ -1435,6 +1438,7 @@ WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_SCANNER" ||
                            test -z "$WAYLAND_CURSOR_LIBS" ||
                            test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
                            test -z "$DRM_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 5d14f8ac19c..1805052161d 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,13 +1,14 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
-              $(DRM_CFLAGS)
+              $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
-            $(XKBCOMMON_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
+            $(XKBCOMMON_LIBS) $(GBM_LIBS) $(UDEV_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	gbm.c \
 	options.c \
 	registry.c \
 	unicode.c \
diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
new file mode 100644
index 00000000000..8123a014a59
--- /dev/null
+++ b/dlls/winewayland.drv/gbm.c
@@ -0,0 +1,185 @@
+/*
+ * Wayland GBM support
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_LIBUDEV_H
+#include <libudev.h>
+#endif
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct gbm_device *process_gbm_device;
+static pthread_once_t init_once;
+
+static const char default_seat[] = "seat0";
+static const char default_render_node[] = "/dev/dri/renderD128";
+static const char default_primary_node[] = "/dev/dri/card0";
+static const char primary_node_sysname[] = "card[0-9]*";
+static const char render_node_sysname[] = "renderD[0-9]*";
+
+#ifdef HAVE_UDEV
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
+{
+    const char *seat;
+    struct udev *udev = NULL;
+    struct udev_enumerate *e = NULL;
+    struct udev_list_entry *entry;
+    int drm_fd = -1;
+
+    seat = getenv("XDG_SEAT");
+    if (!seat) seat = default_seat;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+    udev_enumerate_add_match_subsystem(e, "drm");
+    udev_enumerate_add_match_sysname(e, sysname);
+
+    udev_enumerate_scan_devices(e);
+    udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e))
+    {
+        const char *path, *device_seat, *devnode;
+        struct udev_device *device;
+
+        path = udev_list_entry_get_name(entry);
+        device = udev_device_new_from_syspath(udev, path);
+        if (!device) continue;
+
+        device_seat = udev_device_get_property_value(device, "ID_SEAT");
+        if (!device_seat) device_seat = default_seat;
+        if (strcmp(device_seat, seat))
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        devnode = udev_device_get_devnode(device);
+        if (!devnode)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        drm_fd = open(devnode, O_RDWR);
+        TRACE("Trying to open drm device (%s) %s => fd=%d\n", desc, devnode, drm_fd);
+
+        udev_device_unref(device);
+        if (drm_fd >= 0) break;
+    }
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return drm_fd;
+}
+
+#else
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
+{
+    return -1;
+}
+
+#endif
+
+static void wayland_gbm_init_once(void)
+{
+    int drm_fd = -1;
+    const char *desc;
+
+    if (option_drm_device)
+    {
+        drm_fd = open(option_drm_device, O_RDWR);
+        TRACE("Trying to open drm device (from options) %s => fd=%d\n",
+              option_drm_device, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open device from DRMDevice driver option\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random render node";
+        drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_render_node, O_RDWR);
+        TRACE("Trying to open drm device (default render node) %s => fd=%d\n",
+              default_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random primary node";
+        drm_fd = wayland_gbm_get_drm_fd(primary_node_sysname, desc);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable primary node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_primary_node, O_RDWR);
+        TRACE("Trying to open drm device (default primary node) %s => fd=%d\n",
+              default_primary_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default primary node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        ERR("Failed to find a suitable drm device\n");
+        return;
+    }
+
+    process_gbm_device = gbm_create_device(drm_fd);
+    if (!process_gbm_device)
+    {
+        ERR("Failed to create gbm device (errno=%d)\n", errno);
+        close(drm_fd);
+    }
+}
+
+BOOL wayland_gbm_init(void)
+{
+    pthread_once(&init_once, wayland_gbm_init_once);
+
+    return process_gbm_device != NULL;
+}
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index 9a0b4774688..c06e7e09722 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -41,6 +41,7 @@
  *              Config options
  */
 
+char *option_drm_device = NULL;
 BOOL option_use_system_cursors = TRUE;
 
 /***********************************************************************
@@ -91,6 +92,9 @@ void wayland_read_options_from_registry(void)
         }
     }
 
+    if (!get_config_key(hkey, appkey, "DRMDevice", REG_SZ, buffer, sizeof(buffer)))
+        option_drm_device = strdup(buffer);
+
     if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
         option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
 
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
index 471c636c04a..34277d5f9c5 100644
--- a/dlls/winewayland.drv/wayland_native_buffer.c
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -23,9 +23,13 @@
 #include "config.h"
 
 #include "waylanddrv.h"
+#include "wine/debug.h"
 
 #include <assert.h>
 #include <unistd.h>
+#include <xf86drm.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 /**********************************************************************
  *          wayland_native_buffer_init_shm
@@ -59,6 +63,54 @@ BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
     return TRUE;
 }
 
+/**********************************************************************
+ *          wayland_native_buffer_init_gbm
+ *
+ * Initializes a native buffer from a gbm_bo.
+ */
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo)
+{
+    int i;
+
+    native->plane_count = gbm_bo_get_plane_count(bo);
+    native->width = gbm_bo_get_width(bo);
+    native->height = gbm_bo_get_height(bo);
+    native->format = gbm_bo_get_format(bo);
+    native->modifier = gbm_bo_get_modifier(bo);
+    for (i = 0; i < ARRAY_SIZE(native->fds); i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        int ret;
+        union gbm_bo_handle handle;
+
+        handle = gbm_bo_get_handle_for_plane(bo, i);
+        if (handle.s32 == -1)
+        {
+            ERR("error: failed to get gbm_bo_handle\n");
+            goto err;
+        }
+
+        ret = drmPrimeHandleToFD(gbm_device_get_fd(gbm_bo_get_device(bo)),
+                                 handle.u32, 0, &native->fds[i]);
+        if (ret < 0 || native->fds[i] < 0)
+        {
+            ERR("error: failed to get dmabuf_fd\n");
+            goto err;
+        }
+        native->strides[i] = gbm_bo_get_stride_for_plane(bo, i);
+        native->offsets[i] = gbm_bo_get_offset(bo, i);
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
 /**********************************************************************
  *          wayland_native_buffer_deinit
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f68b7b4b3f2..e4f38abff02 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -25,6 +25,7 @@
 # error You must include config.h to use this header
 #endif
 
+#include <gbm.h>
 #include <pthread.h>
 #include <sys/types.h>
 #include <stdarg.h>
@@ -51,6 +52,8 @@
 
 extern char *process_name DECLSPEC_HIDDEN;
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
+extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
+extern char *option_drm_device DECLSPEC_HIDDEN;
 extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
 /**********************************************************************
@@ -468,6 +471,8 @@ int wayland_surface_get_buffer_scale(struct wayland_surface *surface) DECLSPEC_H
 BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
                                     int width, int height,
                                     enum wl_shm_format format) DECLSPEC_HIDDEN;
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo) DECLSPEC_HIDDEN;
 void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 
 /**********************************************************************
@@ -552,6 +557,12 @@ void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
 BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
 void wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          GBM support
+ */
+
+BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Registry helpers
  */
diff --git a/include/config.h.in b/include/config.h.in
index 0c01995f823..a4847c40e62 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -92,6 +92,9 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gbm.h> header file. */
+#undef HAVE_GBM_H
+
 /* Define to 1 if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
-- 
2.39.0.rc2

From b005f92ef30deb660af637bb5cbb0ee82c8bb7c5 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 4 May 2022 13:38:06 -0300
Subject: [PATCH 099/202] winewayland.drv: Prefer same DRM device that
 compositor is using.

When users don't specify the "DRMDevice" driver registry option, we
don't know exactly the best DRM node to open, so we try to open a random
render node. Instead, start to use the data from dma-buf feedback to try
to open the same DRM device that the compositor is using.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/gbm.c | 36 ++++++++++++++++++++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
index 8123a014a59..3406329c897 100644
--- a/dlls/winewayland.drv/gbm.c
+++ b/dlls/winewayland.drv/gbm.c
@@ -34,6 +34,7 @@
 #endif
 #include <stdlib.h>
 #include <unistd.h>
+#include <xf86drm.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
@@ -115,9 +116,33 @@ static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
 
 #endif
 
+static char *get_compositor_render_node(void)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    char *compositor_render_node = NULL;
+    drmDevicePtr dev_ptr;
+
+    if (!wayland->dmabuf.default_feedback)
+        goto out;
+
+    if (drmGetDeviceFromDevId(wayland->dmabuf.default_feedback->main_device,
+                              0, &dev_ptr) < 0)
+        goto out;
+
+    if (dev_ptr->available_nodes & (1 << DRM_NODE_RENDER))
+        compositor_render_node = strdup(dev_ptr->nodes[DRM_NODE_RENDER]);
+
+    drmFreeDevice(&dev_ptr);
+
+out:
+    wayland_process_release();
+    return compositor_render_node;
+}
+
 static void wayland_gbm_init_once(void)
 {
     int drm_fd = -1;
+    char *compositor_render_node = get_compositor_render_node();
     const char *desc;
 
     if (option_drm_device)
@@ -129,6 +154,15 @@ static void wayland_gbm_init_once(void)
             WARN("Failed to open device from DRMDevice driver option\n");
     }
 
+    if (drm_fd < 0 && compositor_render_node)
+    {
+        drm_fd = open(compositor_render_node, O_RDWR);
+        TRACE("Trying to open drm device (from compositor render node) %s => fd=%d\n",
+              compositor_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open drm device that compositor is using\n");
+    }
+
     if (drm_fd < 0)
     {
         desc = "random render node";
@@ -163,6 +197,8 @@ static void wayland_gbm_init_once(void)
             WARN("Failed to open default primary node\n");
     }
 
+    free(compositor_render_node);
+
     if (drm_fd < 0)
     {
         ERR("Failed to find a suitable drm device\n");
-- 
2.39.0.rc2

From 79e1c84f6fa2494900a62062ae5772107874e7a0 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 4 May 2022 13:52:15 -0300
Subject: [PATCH 100/202] winewayland.drv: Introduce support for DRI_PRIME.

Until now, users could only specify the DRM device that they want us to
use with the "DRMDevice" driver registry option, setting it to the
render node exposed by the GPU that they want to use (e.g.
"/dev/dri/renderD128").

This adds support to open a DRM device based on the value of the
DRI_PRIME environment variable. Users can set it to:

a. "1", and in such case we try to open the non-default device.
   The non-default device is a device that is different from
   whatever the compositor is using. But if the compositor didn't
   advertise dma-buf feedback, we won't be able to get this
   information. In such case, we are going to consider that the
   primary system GPU is the default device.

b. When users want to be more specific, they can set DRI_PRIME to
   the ID_TAG_PATH of the GPU that they want to use, and they can
   easily query this information using "udevadm info". This would
   be the same of setting the "DRMDevice" registry option for the
   Wine Wayland driver, but it is a little less work.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/gbm.c | 162 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 158 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
index 3406329c897..0dab8d0efed 100644
--- a/dlls/winewayland.drv/gbm.c
+++ b/dlls/winewayland.drv/gbm.c
@@ -27,6 +27,7 @@
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
+#include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
 #ifdef HAVE_LIBUDEV_H
@@ -49,7 +50,98 @@ static const char render_node_sysname[] = "renderD[0-9]*";
 
 #ifdef HAVE_UDEV
 
-static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
+typedef BOOL (*filter_func)(struct udev_device *, const char *);
+
+/* returns TRUE for every udev_dev whose devnode is not devnode_to_ignore */
+static BOOL filter_has_different_devnode(struct udev_device *udev_dev,
+                                         const char *devnode_to_ignore)
+{
+    const char *devnode;
+
+    assert(udev_dev && devnode_to_ignore);
+
+    /* If we can't get a devnode from the device, we prefer to filter it out */
+    devnode = udev_device_get_devnode(udev_dev);
+    if (!devnode)
+        return FALSE;
+
+    /* devnode is equal to devnode_to_ignore */
+    if (strcmp(devnode, devnode_to_ignore) == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* returns TRUE for every udev_dev that is not the primary system GPU */
+static BOOL filter_is_not_primary_system_gpu(struct udev_device *udev_dev,
+                                             const char *unused_arg)
+{
+    struct udev_device *pci_device;
+    const char *boot_vga;
+
+    assert(udev_dev);
+
+    /* If we can't get pci_device, we prefer to filter the device out */
+    pci_device = udev_device_get_parent(udev_dev);
+    if (!pci_device)
+        return FALSE;
+
+    /* It is the primary system GPU */
+    boot_vga = udev_device_get_sysattr_value(pci_device, "boot_vga");
+    if (boot_vga && strcmp(boot_vga, "1") == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* returns TRUE for every udev_dev whose ID_PATH_TAG is id_path_tag */
+static BOOL filter_has_same_id_path_tag(struct udev_device *udev_dev,
+                                        const char *id_path_tag)
+{
+    const char *dev_id_path_tag;
+
+    assert(udev_dev && id_path_tag);
+
+    /* If we can't get dev_id_path_tag, we prefer to filter the device out */
+    dev_id_path_tag = udev_device_get_property_value(udev_dev, "ID_PATH_TAG");
+    if (!dev_id_path_tag)
+        return FALSE;
+
+    /* ID_PATH_TAG is different from id_path_tag */
+    if (strcmp(dev_id_path_tag, id_path_tag) != 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+static BOOL is_primary_system_gpu_set(void)
+{
+    struct udev *udev;
+    struct udev_enumerate *e = NULL;
+    BOOL ret = FALSE;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+
+    udev_enumerate_add_match_sysattr(e, "boot_vga", "1");
+
+    /* if list is not empty we have a PCI device with boot_vga set to 1 (i.e. we
+     * have a PCI device marked as the primary system GPU) */
+    udev_enumerate_scan_devices(e);
+    if (udev_enumerate_get_list_entry(e)) ret = TRUE;
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return ret;
+}
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc,
+                                  filter_func filter, const char *filter_arg)
 {
     const char *seat;
     struct udev *udev = NULL;
@@ -93,6 +185,13 @@ static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
             continue;
         }
 
+        /* If we have a filter, we may ignore certain devices */
+        if (filter && filter(device, filter_arg) == FALSE)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
         drm_fd = open(devnode, O_RDWR);
         TRACE("Trying to open drm device (%s) %s => fd=%d\n", desc, devnode, drm_fd);
 
@@ -109,7 +208,27 @@ out:
 
 #else
 
-static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
+typedef void (*filter_func)(void);
+
+static void filter_has_different_devnode(void)
+{
+}
+
+static void filter_is_not_primary_system_gpu(void)
+{
+}
+
+static void filter_has_same_id_path_tag(void)
+{
+}
+
+static BOOL is_primary_system_gpu_set(void)
+{
+    return FALSE;
+}
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc,
+                                  filter_func filter, const char *filter_arg)
 {
     return -1;
 }
@@ -143,6 +262,7 @@ static void wayland_gbm_init_once(void)
 {
     int drm_fd = -1;
     char *compositor_render_node = get_compositor_render_node();
+    const char *dri_prime = getenv("DRI_PRIME");
     const char *desc;
 
     if (option_drm_device)
@@ -154,6 +274,40 @@ static void wayland_gbm_init_once(void)
             WARN("Failed to open device from DRMDevice driver option\n");
     }
 
+    if (drm_fd < 0 && dri_prime)
+    {
+        if (strcmp(dri_prime, "1") == 0)
+        {
+            if (compositor_render_node)
+            {
+                /* DRI_PRIME is 1, so we open the non-default device (device
+                 * that is different from whatever the compositor is using) */
+                desc = "from DRI_PRIME == 1, different from compositor render node";
+                drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                                filter_has_different_devnode, compositor_render_node);
+            }
+            else if (is_primary_system_gpu_set())
+            {
+                /* We don't know what device the compositor is using, so we
+                 * consider that the primary system GPU is the default device. */
+                desc = "from DRI_PRIME == 1, different from primary system GPU";
+                drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                                filter_is_not_primary_system_gpu, NULL);
+            }
+        }
+        else
+        {
+            /* DRI_PRIME should be set to ID_TAG_PATH of the GPU the user wants
+             * us to use. */
+            desc = "from DRI_PRIME == ID_PATH_TAG";
+            drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                            filter_has_same_id_path_tag, dri_prime);
+        }
+
+        if (drm_fd < 0)
+            WARN("Failed to open DRI_PRIME device\n");
+    }
+
     if (drm_fd < 0 && compositor_render_node)
     {
         drm_fd = open(compositor_render_node, O_RDWR);
@@ -166,7 +320,7 @@ static void wayland_gbm_init_once(void)
     if (drm_fd < 0)
     {
         desc = "random render node";
-        drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc);
+        drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc, NULL, NULL);
         if (drm_fd < 0)
             WARN("Failed to find a suitable render node\n");
     }
@@ -183,7 +337,7 @@ static void wayland_gbm_init_once(void)
     if (drm_fd < 0)
     {
         desc = "random primary node";
-        drm_fd = wayland_gbm_get_drm_fd(primary_node_sysname, desc);
+        drm_fd = wayland_gbm_get_drm_fd(primary_node_sysname, desc, NULL, NULL);
         if (drm_fd < 0)
             WARN("Failed to find a suitable primary node\n");
     }
-- 
2.39.0.rc2

From 3863816f7247d384e7ae598b775c36452210ffb7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:17:56 +0300
Subject: [PATCH 101/202] winewayland.drv: Add skeleton OpenGL driver.

The driver opens the EGL and GL libraries and creates stubs for standard
GL functions.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                              | 162 +++++++++++++++++++++++++
 configure.ac                           |   3 +
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/opengl.c          | 130 ++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   1 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 6 files changed, 298 insertions(+)
 create mode 100644 dlls/winewayland.drv/opengl.c

diff --git a/configure b/configure
index d381850891f..5018e79961c 100755
--- a/configure
+++ b/configure
@@ -16351,6 +16351,168 @@ fi
 
 CPPFLAGS=$ac_save_CPPFLAGS
 
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lEGL" >&5
+printf %s "checking for -lEGL... " >&6; }
+if test ${ac_cv_lib_soname_EGL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lEGL  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char eglGetProcAddress ();
+int
+main (void)
+{
+return eglGetProcAddress ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_EGL=`$ac_cv_path_LDD conftest.exe | grep "EGL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_EGL=`$OTOOL -L conftest$ac_exeext | grep "libEGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libEGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_EGL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libEGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libEGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  ac_cv_lib_soname_EGL=`$LDD conftest$ac_exeext | grep "libEGL\\.$LIBEXT" | sed -e "s/^.*\(libEGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_EGL=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_EGL" >&5
+printf "%s\n" "$ac_cv_lib_soname_EGL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBEGL \"$ac_cv_lib_soname_EGL\"" >>confdefs.h
+
+
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGL  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char glFlush ();
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
+  ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_GL=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
+
+
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGLESv2" >&5
+printf %s "checking for -lGLESv2... " >&6; }
+if test ${ac_cv_lib_soname_GLESv2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGLESv2  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char glFlush ();
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GLESv2=`$ac_cv_path_LDD conftest.exe | grep "GLESv2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GLESv2=`$OTOOL -L conftest$ac_exeext | grep "libGLESv2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGLESv2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GLESv2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGLESv2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGLESv2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  ac_cv_lib_soname_GLESv2=`$LDD conftest$ac_exeext | grep "libGLESv2\\.$LIBEXT" | sed -e "s/^.*\(libGLESv2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_GLESv2=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLESv2" >&5
+printf "%s\n" "$ac_cv_lib_soname_GLESv2" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGLESV2 \"$ac_cv_lib_soname_GLESv2\"" >>confdefs.h
+
+
+fi
 fi
 if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
diff --git a/configure.ac b/configure.ac
index 74110c9c073..83c902cf8fc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1432,6 +1432,9 @@ then
     WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
         [AC_CHECK_HEADERS([drm.h])
          AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
+    WINE_CHECK_SONAME(EGL,eglGetProcAddress)
+    WINE_CHECK_SONAME(GL,glFlush)
+    WINE_CHECK_SONAME(GLESv2,glFlush)
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 1805052161d..26409d11f88 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	display.c \
 	dllmain.c \
 	gbm.c \
+	opengl.c \
 	options.c \
 	registry.c \
 	unicode.c \
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
new file mode 100644
index 00000000000..214971b02f7
--- /dev/null
+++ b/dlls/winewayland.drv/opengl.c
@@ -0,0 +1,130 @@
+/*
+ * Wayland OpenGL functions
+ *
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2005 Alex Woods
+ * Copyright 2005 Raphael Junqueira
+ * Copyright 2006-2009 Roderick Colenbrander
+ * Copyright 2006 Tomas Carnecky
+ * Copyright 2013 Matteo Bruni
+ * Copyright 2012, 2013, 2014, 2017 Alexandre Julliard
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+#if defined(SONAME_LIBEGL) && (defined(SONAME_LIBGL) || defined(SONAME_LIBGLESV2))
+
+#define GLAPIENTRY /* nothing */
+#include "wine/wgl.h"
+#undef GLAPIENTRY
+#include "wine/wgl_driver.h"
+
+#include <EGL/egl.h>
+#include <assert.h>
+#include <dlfcn.h>
+
+static void *egl_handle;
+static void *opengl_handle;
+
+static BOOL egl_init(void)
+{
+    static int retval = -1;
+
+    if (retval != -1) return retval;
+    retval = 0;
+
+    if (!(egl_handle = dlopen(SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        ERR("failed to load %s: %s\n", SONAME_LIBEGL, dlerror());
+        return FALSE;
+    }
+
+#ifdef SONAME_LIBGL
+    if (!(opengl_handle = dlopen(SONAME_LIBGL, RTLD_NOW|RTLD_GLOBAL)))
+        WARN("failed to load %s: %s\n", SONAME_LIBGL, dlerror());
+#endif
+
+#ifdef SONAME_LIBGLESV2
+    if (!opengl_handle && (!(opengl_handle = dlopen(SONAME_LIBGLESV2, RTLD_NOW|RTLD_GLOBAL))))
+        WARN("failed to load %s: %s\n", SONAME_LIBGLESV2, dlerror());
+#endif
+
+    if (!opengl_handle)
+    {
+        ERR("failed to load GL or GLESv2 library\n");
+        return FALSE;
+    }
+
+    retval = 1;
+    return TRUE;
+}
+
+/* generate stubs for GL functions that are not exported */
+
+#define USE_GL_FUNC(name) \
+static void glstub_##name(void) \
+{ \
+    ERR(#name " called\n"); \
+    assert(0); \
+    ExitProcess(1); \
+}
+
+ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+static struct opengl_funcs egl_funcs =
+{
+#define USE_GL_FUNC(name) (void *)glstub_##name,
+    .gl = { ALL_WGL_FUNCS }
+#undef USE_GL_FUNC
+};
+
+/**********************************************************************
+ *           WAYLAND_wine_get_wgl_driver
+ */
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
+{
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR("version mismatch, opengl32 wants %u but driver has %u\n",
+            version, WINE_WGL_DRIVER_VERSION);
+        return NULL;
+    }
+    if (!egl_init()) return NULL;
+    return &egl_funcs;
+}
+
+#else /* No GL */
+
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
+{
+    ERR("Wine Wayland was built without OpenGL support.\n");
+    return NULL;
+}
+
+#endif
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e4f38abff02..b07f3d66c54 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -686,5 +686,6 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                const RECT *window_rect, const RECT *client_rect,
                                RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 7a67436d343..a6442d17b03 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -138,6 +138,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pWindowMessage = WAYLAND_WindowMessage,
     .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
+    .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
 
 static const struct user_driver_funcs null_funcs = { 0 };
-- 
2.39.0.rc2

From a13c4c1c04537f39f9ed0ddb96299b781d619288 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:25:46 +0300
Subject: [PATCH 102/202] winewayland.drv: Perform basic EGL initialization.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 214971b02f7..ff784702325 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -50,6 +50,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 static void *egl_handle;
 static void *opengl_handle;
+static EGLDisplay egl_display;
+static EGLint egl_version[2];
+
+#define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglInitialize);
+#undef DECL_FUNCPTR
 
 static BOOL egl_init(void)
 {
@@ -80,6 +87,21 @@ static BOOL egl_init(void)
         return FALSE;
     }
 
+#define LOAD_FUNCPTR(func) do { \
+        if (!(p_##func = dlsym(egl_handle, #func))) \
+        { ERR("can't find symbol %s\n", #func); return FALSE; }    \
+    } while(0)
+    LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglInitialize);
+#undef LOAD_FUNCPTR
+
+    if (!wayland_gbm_init()) return FALSE;
+
+    egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_gbm_device);
+    if (!p_eglInitialize(egl_display, &egl_version[0], &egl_version[1]))
+        return FALSE;
+    TRACE("display %p version %u.%u\n", egl_display, egl_version[0], egl_version[1]);
+
     retval = 1;
     return TRUE;
 }
-- 
2.39.0.rc2

From 98f04b959a8ad9fc137e73f03ff27ccf91aca4d9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:30:53 +0300
Subject: [PATCH 103/202] winewayland.drv: Initialize standard GL and extension
 functions.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 289 ++++++++++++++++++++++++++++++++++
 1 file changed, 289 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index ff784702325..228e0be5999 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -52,12 +52,300 @@ static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
 static EGLint egl_version[2];
+static struct opengl_funcs egl_funcs;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+static void init_extensions(void)
+{
+    void *ptr;
+
+    /* load standard functions and extensions exported from the OpenGL library */
+
+#define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
+    ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+#define LOAD_FUNCPTR(func) egl_funcs.ext.p_##func = dlsym(opengl_handle, #func)
+    LOAD_FUNCPTR(glActiveShaderProgram);
+    LOAD_FUNCPTR(glActiveTexture);
+    LOAD_FUNCPTR(glAttachShader);
+    LOAD_FUNCPTR(glBeginQuery);
+    LOAD_FUNCPTR(glBeginTransformFeedback);
+    LOAD_FUNCPTR(glBindAttribLocation);
+    LOAD_FUNCPTR(glBindBuffer);
+    LOAD_FUNCPTR(glBindBufferBase);
+    LOAD_FUNCPTR(glBindBufferRange);
+    LOAD_FUNCPTR(glBindFramebuffer);
+    LOAD_FUNCPTR(glBindImageTexture);
+    LOAD_FUNCPTR(glBindProgramPipeline);
+    LOAD_FUNCPTR(glBindRenderbuffer);
+    LOAD_FUNCPTR(glBindSampler);
+    LOAD_FUNCPTR(glBindTransformFeedback);
+    LOAD_FUNCPTR(glBindVertexArray);
+    LOAD_FUNCPTR(glBindVertexBuffer);
+    LOAD_FUNCPTR(glBlendBarrierKHR);
+    LOAD_FUNCPTR(glBlendColor);
+    LOAD_FUNCPTR(glBlendEquation);
+    LOAD_FUNCPTR(glBlendEquationSeparate);
+    LOAD_FUNCPTR(glBlendFuncSeparate);
+    LOAD_FUNCPTR(glBlitFramebuffer);
+    LOAD_FUNCPTR(glBufferData);
+    LOAD_FUNCPTR(glBufferSubData);
+    LOAD_FUNCPTR(glCheckFramebufferStatus);
+    LOAD_FUNCPTR(glClearBufferfi);
+    LOAD_FUNCPTR(glClearBufferfv);
+    LOAD_FUNCPTR(glClearBufferiv);
+    LOAD_FUNCPTR(glClearBufferuiv);
+    LOAD_FUNCPTR(glClearDepthf);
+    LOAD_FUNCPTR(glClientWaitSync);
+    LOAD_FUNCPTR(glCompileShader);
+    LOAD_FUNCPTR(glCompressedTexImage2D);
+    LOAD_FUNCPTR(glCompressedTexImage3D);
+    LOAD_FUNCPTR(glCompressedTexSubImage2D);
+    LOAD_FUNCPTR(glCompressedTexSubImage3D);
+    LOAD_FUNCPTR(glCopyBufferSubData);
+    LOAD_FUNCPTR(glCopyTexSubImage3D);
+    LOAD_FUNCPTR(glCreateProgram);
+    LOAD_FUNCPTR(glCreateShader);
+    LOAD_FUNCPTR(glCreateShaderProgramv);
+    LOAD_FUNCPTR(glDeleteBuffers);
+    LOAD_FUNCPTR(glDeleteFramebuffers);
+    LOAD_FUNCPTR(glDeleteProgram);
+    LOAD_FUNCPTR(glDeleteProgramPipelines);
+    LOAD_FUNCPTR(glDeleteQueries);
+    LOAD_FUNCPTR(glDeleteRenderbuffers);
+    LOAD_FUNCPTR(glDeleteSamplers);
+    LOAD_FUNCPTR(glDeleteShader);
+    LOAD_FUNCPTR(glDeleteSync);
+    LOAD_FUNCPTR(glDeleteTransformFeedbacks);
+    LOAD_FUNCPTR(glDeleteVertexArrays);
+    LOAD_FUNCPTR(glDepthRangef);
+    LOAD_FUNCPTR(glDetachShader);
+    LOAD_FUNCPTR(glDisableVertexAttribArray);
+    LOAD_FUNCPTR(glDispatchCompute);
+    LOAD_FUNCPTR(glDispatchComputeIndirect);
+    LOAD_FUNCPTR(glDrawArraysIndirect);
+    LOAD_FUNCPTR(glDrawArraysInstanced);
+    LOAD_FUNCPTR(glDrawBuffers);
+    LOAD_FUNCPTR(glDrawElementsIndirect);
+    LOAD_FUNCPTR(glDrawElementsInstanced);
+    LOAD_FUNCPTR(glDrawRangeElements);
+    LOAD_FUNCPTR(glEnableVertexAttribArray);
+    LOAD_FUNCPTR(glEndQuery);
+    LOAD_FUNCPTR(glEndTransformFeedback);
+    LOAD_FUNCPTR(glFenceSync);
+    LOAD_FUNCPTR(glFlushMappedBufferRange);
+    LOAD_FUNCPTR(glFramebufferParameteri);
+    LOAD_FUNCPTR(glFramebufferRenderbuffer);
+    LOAD_FUNCPTR(glFramebufferTexture2D);
+    LOAD_FUNCPTR(glFramebufferTextureEXT);
+    LOAD_FUNCPTR(glFramebufferTextureLayer);
+    LOAD_FUNCPTR(glGenBuffers);
+    LOAD_FUNCPTR(glGenFramebuffers);
+    LOAD_FUNCPTR(glGenProgramPipelines);
+    LOAD_FUNCPTR(glGenQueries);
+    LOAD_FUNCPTR(glGenRenderbuffers);
+    LOAD_FUNCPTR(glGenSamplers);
+    LOAD_FUNCPTR(glGenTransformFeedbacks);
+    LOAD_FUNCPTR(glGenVertexArrays);
+    LOAD_FUNCPTR(glGenerateMipmap);
+    LOAD_FUNCPTR(glGetActiveAttrib);
+    LOAD_FUNCPTR(glGetActiveUniform);
+    LOAD_FUNCPTR(glGetActiveUniformBlockName);
+    LOAD_FUNCPTR(glGetActiveUniformBlockiv);
+    LOAD_FUNCPTR(glGetActiveUniformsiv);
+    LOAD_FUNCPTR(glGetAttachedShaders);
+    LOAD_FUNCPTR(glGetAttribLocation);
+    LOAD_FUNCPTR(glGetBooleani_v);
+    LOAD_FUNCPTR(glGetBufferParameteri64v);
+    LOAD_FUNCPTR(glGetBufferParameteriv);
+    LOAD_FUNCPTR(glGetBufferPointerv);
+    LOAD_FUNCPTR(glGetFragDataLocation);
+    LOAD_FUNCPTR(glGetFramebufferAttachmentParameteriv);
+    LOAD_FUNCPTR(glGetFramebufferParameteriv);
+    LOAD_FUNCPTR(glGetInteger64i_v);
+    LOAD_FUNCPTR(glGetInteger64v);
+    LOAD_FUNCPTR(glGetIntegeri_v);
+    LOAD_FUNCPTR(glGetInternalformativ);
+    LOAD_FUNCPTR(glGetMultisamplefv);
+    LOAD_FUNCPTR(glGetProgramBinary);
+    LOAD_FUNCPTR(glGetProgramInfoLog);
+    LOAD_FUNCPTR(glGetProgramInterfaceiv);
+    LOAD_FUNCPTR(glGetProgramPipelineInfoLog);
+    LOAD_FUNCPTR(glGetProgramPipelineiv);
+    LOAD_FUNCPTR(glGetProgramResourceIndex);
+    LOAD_FUNCPTR(glGetProgramResourceLocation);
+    LOAD_FUNCPTR(glGetProgramResourceName);
+    LOAD_FUNCPTR(glGetProgramResourceiv);
+    LOAD_FUNCPTR(glGetProgramiv);
+    LOAD_FUNCPTR(glGetQueryObjectuiv);
+    LOAD_FUNCPTR(glGetQueryiv);
+    LOAD_FUNCPTR(glGetRenderbufferParameteriv);
+    LOAD_FUNCPTR(glGetSamplerParameterfv);
+    LOAD_FUNCPTR(glGetSamplerParameteriv);
+    LOAD_FUNCPTR(glGetShaderInfoLog);
+    LOAD_FUNCPTR(glGetShaderPrecisionFormat);
+    LOAD_FUNCPTR(glGetShaderSource);
+    LOAD_FUNCPTR(glGetShaderiv);
+    LOAD_FUNCPTR(glGetStringi);
+    LOAD_FUNCPTR(glGetSynciv);
+    LOAD_FUNCPTR(glGetTexParameterIivEXT);
+    LOAD_FUNCPTR(glGetTexParameterIuivEXT);
+    LOAD_FUNCPTR(glGetTransformFeedbackVarying);
+    LOAD_FUNCPTR(glGetUniformBlockIndex);
+    LOAD_FUNCPTR(glGetUniformIndices);
+    LOAD_FUNCPTR(glGetUniformLocation);
+    LOAD_FUNCPTR(glGetUniformfv);
+    LOAD_FUNCPTR(glGetUniformiv);
+    LOAD_FUNCPTR(glGetUniformuiv);
+    LOAD_FUNCPTR(glGetVertexAttribIiv);
+    LOAD_FUNCPTR(glGetVertexAttribIuiv);
+    LOAD_FUNCPTR(glGetVertexAttribPointerv);
+    LOAD_FUNCPTR(glGetVertexAttribfv);
+    LOAD_FUNCPTR(glGetVertexAttribiv);
+    LOAD_FUNCPTR(glInvalidateFramebuffer);
+    LOAD_FUNCPTR(glInvalidateSubFramebuffer);
+    LOAD_FUNCPTR(glIsBuffer);
+    LOAD_FUNCPTR(glIsFramebuffer);
+    LOAD_FUNCPTR(glIsProgram);
+    LOAD_FUNCPTR(glIsProgramPipeline);
+    LOAD_FUNCPTR(glIsQuery);
+    LOAD_FUNCPTR(glIsRenderbuffer);
+    LOAD_FUNCPTR(glIsSampler);
+    LOAD_FUNCPTR(glIsShader);
+    LOAD_FUNCPTR(glIsSync);
+    LOAD_FUNCPTR(glIsTransformFeedback);
+    LOAD_FUNCPTR(glIsVertexArray);
+    LOAD_FUNCPTR(glLinkProgram);
+    LOAD_FUNCPTR(glMapBufferRange);
+    LOAD_FUNCPTR(glMemoryBarrier);
+    LOAD_FUNCPTR(glMemoryBarrierByRegion);
+    LOAD_FUNCPTR(glPauseTransformFeedback);
+    LOAD_FUNCPTR(glProgramBinary);
+    LOAD_FUNCPTR(glProgramParameteri);
+    LOAD_FUNCPTR(glProgramUniform1f);
+    LOAD_FUNCPTR(glProgramUniform1fv);
+    LOAD_FUNCPTR(glProgramUniform1i);
+    LOAD_FUNCPTR(glProgramUniform1iv);
+    LOAD_FUNCPTR(glProgramUniform1ui);
+    LOAD_FUNCPTR(glProgramUniform1uiv);
+    LOAD_FUNCPTR(glProgramUniform2f);
+    LOAD_FUNCPTR(glProgramUniform2fv);
+    LOAD_FUNCPTR(glProgramUniform2i);
+    LOAD_FUNCPTR(glProgramUniform2iv);
+    LOAD_FUNCPTR(glProgramUniform2ui);
+    LOAD_FUNCPTR(glProgramUniform2uiv);
+    LOAD_FUNCPTR(glProgramUniform3f);
+    LOAD_FUNCPTR(glProgramUniform3fv);
+    LOAD_FUNCPTR(glProgramUniform3i);
+    LOAD_FUNCPTR(glProgramUniform3iv);
+    LOAD_FUNCPTR(glProgramUniform3ui);
+    LOAD_FUNCPTR(glProgramUniform3uiv);
+    LOAD_FUNCPTR(glProgramUniform4f);
+    LOAD_FUNCPTR(glProgramUniform4fv);
+    LOAD_FUNCPTR(glProgramUniform4i);
+    LOAD_FUNCPTR(glProgramUniform4iv);
+    LOAD_FUNCPTR(glProgramUniform4ui);
+    LOAD_FUNCPTR(glProgramUniform4uiv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glReleaseShaderCompiler);
+    LOAD_FUNCPTR(glRenderbufferStorage);
+    LOAD_FUNCPTR(glRenderbufferStorageMultisample);
+    LOAD_FUNCPTR(glResumeTransformFeedback);
+    LOAD_FUNCPTR(glSampleCoverage);
+    LOAD_FUNCPTR(glSampleMaski);
+    LOAD_FUNCPTR(glSamplerParameterf);
+    LOAD_FUNCPTR(glSamplerParameterfv);
+    LOAD_FUNCPTR(glSamplerParameteri);
+    LOAD_FUNCPTR(glSamplerParameteriv);
+    LOAD_FUNCPTR(glShaderBinary);
+    LOAD_FUNCPTR(glShaderSource);
+    LOAD_FUNCPTR(glStencilFuncSeparate);
+    LOAD_FUNCPTR(glStencilMaskSeparate);
+    LOAD_FUNCPTR(glStencilOpSeparate);
+    LOAD_FUNCPTR(glTexBufferEXT);
+    LOAD_FUNCPTR(glTexImage3D);
+    LOAD_FUNCPTR(glTexParameterIivEXT);
+    LOAD_FUNCPTR(glTexParameterIuivEXT);
+    LOAD_FUNCPTR(glTexStorage2D);
+    LOAD_FUNCPTR(glTexStorage2DMultisample);
+    LOAD_FUNCPTR(glTexStorage3D);
+    LOAD_FUNCPTR(glTexSubImage3D);
+    LOAD_FUNCPTR(glTransformFeedbackVaryings);
+    LOAD_FUNCPTR(glUniform1f);
+    LOAD_FUNCPTR(glUniform1fv);
+    LOAD_FUNCPTR(glUniform1i);
+    LOAD_FUNCPTR(glUniform1iv);
+    LOAD_FUNCPTR(glUniform1ui);
+    LOAD_FUNCPTR(glUniform1uiv);
+    LOAD_FUNCPTR(glUniform2f);
+    LOAD_FUNCPTR(glUniform2fv);
+    LOAD_FUNCPTR(glUniform2i);
+    LOAD_FUNCPTR(glUniform2iv);
+    LOAD_FUNCPTR(glUniform2ui);
+    LOAD_FUNCPTR(glUniform2uiv);
+    LOAD_FUNCPTR(glUniform3f);
+    LOAD_FUNCPTR(glUniform3fv);
+    LOAD_FUNCPTR(glUniform3i);
+    LOAD_FUNCPTR(glUniform3iv);
+    LOAD_FUNCPTR(glUniform3ui);
+    LOAD_FUNCPTR(glUniform3uiv);
+    LOAD_FUNCPTR(glUniform4f);
+    LOAD_FUNCPTR(glUniform4fv);
+    LOAD_FUNCPTR(glUniform4i);
+    LOAD_FUNCPTR(glUniform4iv);
+    LOAD_FUNCPTR(glUniform4ui);
+    LOAD_FUNCPTR(glUniform4uiv);
+    LOAD_FUNCPTR(glUniformBlockBinding);
+    LOAD_FUNCPTR(glUniformMatrix2fv);
+    LOAD_FUNCPTR(glUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glUniformMatrix3fv);
+    LOAD_FUNCPTR(glUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glUniformMatrix4fv);
+    LOAD_FUNCPTR(glUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glUnmapBuffer);
+    LOAD_FUNCPTR(glUseProgram);
+    LOAD_FUNCPTR(glUseProgramStages);
+    LOAD_FUNCPTR(glValidateProgram);
+    LOAD_FUNCPTR(glValidateProgramPipeline);
+    LOAD_FUNCPTR(glVertexAttrib1f);
+    LOAD_FUNCPTR(glVertexAttrib1fv);
+    LOAD_FUNCPTR(glVertexAttrib2f);
+    LOAD_FUNCPTR(glVertexAttrib2fv);
+    LOAD_FUNCPTR(glVertexAttrib3f);
+    LOAD_FUNCPTR(glVertexAttrib3fv);
+    LOAD_FUNCPTR(glVertexAttrib4f);
+    LOAD_FUNCPTR(glVertexAttrib4fv);
+    LOAD_FUNCPTR(glVertexAttribBinding);
+    LOAD_FUNCPTR(glVertexAttribDivisor);
+    LOAD_FUNCPTR(glVertexAttribFormat);
+    LOAD_FUNCPTR(glVertexAttribI4i);
+    LOAD_FUNCPTR(glVertexAttribI4iv);
+    LOAD_FUNCPTR(glVertexAttribI4ui);
+    LOAD_FUNCPTR(glVertexAttribI4uiv);
+    LOAD_FUNCPTR(glVertexAttribIFormat);
+    LOAD_FUNCPTR(glVertexAttribIPointer);
+    LOAD_FUNCPTR(glVertexAttribPointer);
+    LOAD_FUNCPTR(glVertexBindingDivisor);
+    LOAD_FUNCPTR(glWaitSync);
+#undef LOAD_FUNCPTR
+}
+
 static BOOL egl_init(void)
 {
     static int retval = -1;
@@ -102,6 +390,7 @@ static BOOL egl_init(void)
         return FALSE;
     TRACE("display %p version %u.%u\n", egl_display, egl_version[0], egl_version[1]);
 
+    init_extensions();
     retval = 1;
     return TRUE;
 }
-- 
2.39.0.rc2

From ad2465cb884d83039884858b3b7a29ee903ceb12 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:33:33 +0300
Subject: [PATCH 104/202] winewayland.drv: Implement
 wglGetExtensionsString{ARB,EXT}.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 228e0be5999..95549f8ce54 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -53,16 +53,48 @@ static void *opengl_handle;
 static EGLDisplay egl_display;
 static EGLint egl_version[2];
 static struct opengl_funcs egl_funcs;
+static char wgl_extensions[4096];
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringARB
+ */
+static const char *wayland_wglGetExtensionsStringARB(HDC hdc)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringEXT
+ */
+static const char *wayland_wglGetExtensionsStringEXT(void)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+static void register_extension(const char *ext)
+{
+    if (wgl_extensions[0]) strcat(wgl_extensions, " ");
+    strcat(wgl_extensions, ext);
+    TRACE("%s\n", ext);
+}
+
 static void init_extensions(void)
 {
     void *ptr;
 
+    register_extension("WGL_ARB_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
+
+    register_extension("WGL_EXT_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
-- 
2.39.0.rc2

From 6e9a02babd13801c8db72dc0b4c753ead7783165 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:37:55 +0300
Subject: [PATCH 105/202] winewayland.drv: Implement wglGetProcAddress.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 95549f8ce54..b4dabde0c4a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -57,9 +57,22 @@ static char wgl_extensions[4096];
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
 DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+/***********************************************************************
+ *		wayland_wglGetProcAddress
+ */
+static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
+{
+    PROC ret;
+    if (!strncmp(name, "wgl", 3)) return NULL;
+    ret = (PROC)p_eglGetProcAddress(name);
+    TRACE("%s -> %p\n", name, ret);
+    return ret;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -412,6 +425,7 @@ static BOOL egl_init(void)
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
     LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
 #undef LOAD_FUNCPTR
 
@@ -442,6 +456,10 @@ ALL_WGL_FUNCS
 
 static struct opengl_funcs egl_funcs =
 {
+    .wgl =
+    {
+        .p_wglGetProcAddress = wayland_wglGetProcAddress,
+    },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
 #undef USE_GL_FUNC
-- 
2.39.0.rc2

From 58bbaabd3fe92f4f63defad5cb2c148e58ff5786 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:26:45 +0300
Subject: [PATCH 106/202] winewayland.drv: Initialize OpenGL pixel formats.

Create an array of supported pixel formats, each backed by an EGLConfig.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 74 +++++++++++++++++++++++++++++++++++
 1 file changed, 74 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b4dabde0c4a..26c7dc3a3b3 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -47,6 +47,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include <EGL/egl.h>
 #include <assert.h>
 #include <dlfcn.h>
+#include <stdlib.h>
+
+struct wgl_pixel_format
+{
+    EGLConfig config;
+    EGLint native_visual_id;
+};
 
 static void *egl_handle;
 static void *opengl_handle;
@@ -54,8 +61,12 @@ static EGLDisplay egl_display;
 static EGLint egl_version[2];
 static struct opengl_funcs egl_funcs;
 static char wgl_extensions[4096];
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetConfigAttrib);
+DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
@@ -391,6 +402,65 @@ static void init_extensions(void)
 #undef LOAD_FUNCPTR
 }
 
+static BOOL init_pixel_formats(void)
+{
+    EGLint count, i, pass;
+    EGLConfig *egl_configs;
+
+    p_eglGetConfigs(egl_display, NULL, 0, &count);
+    egl_configs = malloc(count * sizeof(*egl_configs));
+    pixel_formats = malloc(count * sizeof(*pixel_formats));
+    p_eglGetConfigs(egl_display, egl_configs, count, &count);
+    if (!count || !egl_configs || !pixel_formats)
+    {
+        free(egl_configs);
+        free(pixel_formats);
+        ERR("eglGetConfigs returned no configs\n");
+        return FALSE;
+    }
+
+    /* Use two passes: the first pass adds the onscreen formats to the format list,
+     * the second offscreen ones. */
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_SURFACE_TYPE, &type);
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_COLOR_BUFFER_TYPE, &color);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RED_SIZE, &r);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_GREEN_SIZE, &g);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_BLUE_SIZE, &b);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_DEPTH_SIZE, &d);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_STENCIL_SIZE, &s);
+
+            /* Some drivers expose 10 bit components which are not typically what
+             * applications want. */
+            if (r > 8 || g > 8 || b > 8) continue;
+
+            pixel_formats[nb_pixel_formats].config = egl_configs[i];
+            pixel_formats[nb_pixel_formats].native_visual_id = visual_id;
+            nb_pixel_formats++;
+            TRACE("%u: config %u id %u type %x visual %u native %u render %x "
+                  "colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render,
+                   color, r, g, b, d, s);
+        }
+        if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
+    }
+
+    free(egl_configs);
+
+    return TRUE;
+}
+
 static BOOL egl_init(void)
 {
     static int retval = -1;
@@ -424,6 +494,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglGetConfigAttrib);
+    LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
@@ -436,6 +508,8 @@ static BOOL egl_init(void)
         return FALSE;
     TRACE("display %p version %u.%u\n", egl_display, egl_version[0], egl_version[1]);
 
+    if (!init_pixel_formats()) return FALSE;
+
     init_extensions();
     retval = 1;
     return TRUE;
-- 
2.39.0.rc2

From 88211f6e3e622469d40418d688ab47d776d763fe Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sergio=20G=C3=B3mez=20Del=20Real?=
 <sergio.gdr@collabora.com>
Date: Thu, 4 Aug 2022 15:56:28 -0500
Subject: [PATCH 107/202] winewayland.drv: Ignore GL configs that are not
 supported by the compositor.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Sergio Gómez Del Real <sergio.gdr@collabora.com>
---
 dlls/winewayland.drv/gbm.c            | 17 ++++++++
 dlls/winewayland.drv/opengl.c         | 41 ++++++++++++++-----
 dlls/winewayland.drv/wayland_dmabuf.c | 57 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  2 +
 4 files changed, 108 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
index 0dab8d0efed..e9c2e929b1a 100644
--- a/dlls/winewayland.drv/gbm.c
+++ b/dlls/winewayland.drv/gbm.c
@@ -37,6 +37,9 @@
 #include <unistd.h>
 #include <xf86drm.h>
 
+#include <sys/types.h>
+#include <sys/stat.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct gbm_device *process_gbm_device;
@@ -367,6 +370,20 @@ static void wayland_gbm_init_once(void)
     }
 }
 
+/**********************************************************************
+ *          wayland_gbm_get_render_dev
+ */
+dev_t wayland_gbm_get_render_dev()
+{
+    int dev_fd = gbm_device_get_fd(process_gbm_device);
+    struct stat dev_stat;
+
+    if (dev_fd >= 0 && !fstat(dev_fd, &dev_stat))
+        return dev_stat.st_rdev;
+
+    return 0;
+}
+
 BOOL wayland_gbm_init(void)
 {
     pthread_once(&init_once, wayland_gbm_init_once);
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 26c7dc3a3b3..8d363432213 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -405,20 +405,32 @@ static void init_extensions(void)
 static BOOL init_pixel_formats(void)
 {
     EGLint count, i, pass;
-    EGLConfig *egl_configs;
+    EGLConfig *egl_configs = NULL;
+    struct wayland_dmabuf *dmabuf = NULL;
+    dev_t render_dev;
 
     p_eglGetConfigs(egl_display, NULL, 0, &count);
-    egl_configs = malloc(count * sizeof(*egl_configs));
-    pixel_formats = malloc(count * sizeof(*pixel_formats));
+    if (!count)
+    {
+        ERR("eglGetConfigs returned no configs.\n");
+        goto err;
+    }
+
+    if (!(egl_configs = malloc(count * sizeof(*egl_configs))) ||
+        !(pixel_formats = malloc(count * sizeof(*pixel_formats))))
+    {
+        ERR("Memory allocation failed.\n");
+        goto err;
+    }
     p_eglGetConfigs(egl_display, egl_configs, count, &count);
-    if (!count || !egl_configs || !pixel_formats)
+
+    if (!(render_dev = wayland_gbm_get_render_dev()))
     {
-        free(egl_configs);
-        free(pixel_formats);
-        ERR("eglGetConfigs returned no configs\n");
-        return FALSE;
+        ERR("Failed to get device's dev_t from GBM device.\n");
+        goto err;
     }
 
+    dmabuf = &wayland_process_acquire()->dmabuf;
     /* Use two passes: the first pass adds the onscreen formats to the format list,
      * the second offscreen ones. */
     for (pass = 0; pass < 2; pass++)
@@ -431,6 +443,11 @@ static BOOL init_pixel_formats(void)
             if (!(type & EGL_WINDOW_BIT) == !pass) continue;
 
             p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+
+            /* Ignore formats not supported by the compositor. */
+            if (!wayland_dmabuf_is_format_supported(dmabuf, visual_id, render_dev))
+                continue;
+
             p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
             p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
             p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
@@ -455,10 +472,16 @@ static BOOL init_pixel_formats(void)
         }
         if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
     }
-
+    wayland_process_release();
     free(egl_configs);
 
     return TRUE;
+
+err:
+    free(egl_configs);
+    free(pixel_formats);
+
+    return FALSE;
 }
 
 static BOOL egl_init(void)
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index 80881c30acb..c8aaee8d707 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -34,6 +34,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+enum dmabuf_dev_prio {
+    DMABUF_DEV_NODEV,
+    DMABUF_DEV_SCANOUT,
+    DMABUF_DEV_RENDER,
+    DMABUF_DEV_MAIN
+};
+
 /**********************************************************************
  *          dmabuf private helpers
  */
@@ -43,6 +50,20 @@ static BOOL dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
     return dmabuf->version >= ZWP_LINUX_DMABUF_V1_GET_DEFAULT_FEEDBACK_SINCE_VERSION;
 }
 
+static int dmabuf_feedback_get_tranche_priority(struct wayland_dmabuf_feedback *feedback,
+                                                struct wayland_dmabuf_feedback_tranche *tranche,
+                                                dev_t render_dev)
+{
+    if (tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT)
+        return DMABUF_DEV_SCANOUT;
+    else if (tranche->device == render_dev)
+        return DMABUF_DEV_RENDER;
+    else if (tranche->device == feedback->main_device)
+        return DMABUF_DEV_MAIN;
+
+    return DMABUF_DEV_NODEV;
+}
+
 static BOOL dmabuf_format_has_modifier(struct wayland_dmabuf_format *format, uint64_t modifier)
 {
     uint64_t *mod;
@@ -73,6 +94,31 @@ static struct wayland_dmabuf_format *dmabuf_format_array_find_format(struct wl_a
     return dmabuf_format;
 }
 
+static struct wayland_dmabuf_format *dmabuf_feedback_get_format_from_optimal_tranche(struct wayland_dmabuf_feedback *feedback,
+                                                                                     uint32_t format,
+                                                                                     dev_t render_dev,
+                                                                                     struct wayland_dmabuf_feedback_tranche **out_tranche)
+{
+    struct wayland_dmabuf_format *dmabuf_format = NULL;
+    struct wayland_dmabuf_feedback_tranche *tranche;
+    int prio;
+
+    for (prio = DMABUF_DEV_SCANOUT; prio <= DMABUF_DEV_MAIN; prio++)
+    {
+        wl_array_for_each(tranche, &feedback->tranches)
+        {
+            if (prio == dmabuf_feedback_get_tranche_priority(feedback, tranche, render_dev) &&
+                (dmabuf_format = dmabuf_format_array_find_format(&tranche->formats, format)))
+                break;
+        }
+        if (dmabuf_format) break;
+    }
+
+    if (dmabuf_format && out_tranche) *out_tranche = tranche;
+
+    return dmabuf_format;
+}
+
 static BOOL dmabuf_format_array_add_format_modifier(struct wl_array *formats,
                                                     uint32_t format,
                                                     uint64_t modifier)
@@ -445,6 +491,17 @@ void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
         zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
 }
 
+/***********************************************************************
+ *           wayland_dmabuf_is_format_supported
+ */
+BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev)
+{
+    if (dmabuf_has_feedback_support(dmabuf))
+        return dmabuf_feedback_get_format_from_optimal_tranche(dmabuf->default_feedback, format, render_dev, NULL) != NULL;
+
+    return dmabuf_format_array_find_format(&dmabuf->formats, format) != NULL;
+}
+
 /***********************************************************************
  *           wayland_dmabuf_surface_feedback_create
  */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b07f3d66c54..12ebadea2d3 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -496,6 +496,7 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
 void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
                          struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1) DECLSPEC_HIDDEN;
 void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev) DECLSPEC_HIDDEN;
 struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
                                                                        struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
@@ -562,6 +563,7 @@ void wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
  */
 
 BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
+dev_t wayland_gbm_get_render_dev(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
-- 
2.39.0.rc2

From 79178ddadc1e1358646508d0d78ff74c1f96fbdc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:32:28 +0300
Subject: [PATCH 108/202] winewayland.drv: Implement wglDescribePixelFormat.

Populate the PIXELFORMATDESCRIPTOR using information from the backind
EGLConfig.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 54 +++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 8d363432213..d94e95cd192 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -72,6 +72,59 @@ DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+static inline BOOL is_onscreen_pixel_format(int format)
+{
+    return format > 0 && format <= nb_onscreen_formats;
+}
+
+/***********************************************************************
+ *		wayland_wglDescribePixelFormat
+ */
+static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
+                                                 PIXELFORMATDESCRIPTOR *pfd)
+{
+    EGLint val;
+    EGLConfig config;
+
+    if (!pfd) return nb_onscreen_formats;
+    if (!is_onscreen_pixel_format(fmt)) return 0;
+    if (size < sizeof(*pfd)) return 0;
+    config = pixel_formats[fmt - 1].config;
+
+    memset(pfd, 0, sizeof(*pfd));
+    pfd->nSize = sizeof(*pfd);
+    pfd->nVersion = 1;
+    pfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
+                   PFD_SUPPORT_COMPOSITION;
+    pfd->iPixelType = PFD_TYPE_RGBA;
+    pfd->iLayerType = PFD_MAIN_PLANE;
+
+    p_eglGetConfigAttrib(egl_display, config, EGL_BUFFER_SIZE, &val);
+    pfd->cColorBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_RED_SIZE, &val);
+    pfd->cRedBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_GREEN_SIZE, &val);
+    pfd->cGreenBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_BLUE_SIZE, &val);
+    pfd->cBlueBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_ALPHA_SIZE, &val);
+    pfd->cAlphaBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_DEPTH_SIZE, &val);
+    pfd->cDepthBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_STENCIL_SIZE, &val);
+    pfd->cStencilBits = val;
+
+    pfd->cAlphaShift = 0;
+    pfd->cBlueShift = pfd->cAlphaShift + pfd->cAlphaBits;
+    pfd->cGreenShift = pfd->cBlueShift + pfd->cBlueBits;
+    pfd->cRedShift = pfd->cGreenShift + pfd->cGreenBits;
+
+    TRACE("fmt %u color %u %u/%u/%u/%u depth %u stencil %u\n",
+           fmt, pfd->cColorBits, pfd->cRedBits, pfd->cGreenBits, pfd->cBlueBits,
+           pfd->cAlphaBits, pfd->cDepthBits, pfd->cStencilBits);
+    return nb_onscreen_formats;
+}
+
 /***********************************************************************
  *		wayland_wglGetProcAddress
  */
@@ -555,6 +608,7 @@ static struct opengl_funcs egl_funcs =
 {
     .wgl =
     {
+        .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.39.0.rc2

From e9f7936ce917849eddde095caa4e3beb26c3d404 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:19:52 +0300
Subject: [PATCH 109/202] winewayland.drv: Add infrastructure to associate an
 EGL surface with a window.

Introduce the internal wayland_gl_drawable object, which associates a
window (and its backing Wayland surface) with an EGL surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 136 ++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |   2 +
 dlls/winewayland.drv/window.c     |   4 +-
 3 files changed, 140 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index d94e95cd192..174e061c565 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -44,6 +44,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #undef GLAPIENTRY
 #include "wine/wgl_driver.h"
 
+#include "ntuser.h"
+
 #include <EGL/egl.h>
 #include <assert.h>
 #include <dlfcn.h>
@@ -55,6 +57,18 @@ struct wgl_pixel_format
     EGLint native_visual_id;
 };
 
+struct wayland_gl_drawable
+{
+    struct wl_list  link;
+    HWND            hwnd;
+    int             format;
+    int             width;
+    int             height;
+    struct wayland_surface *wayland_surface;
+    struct gbm_surface *gbm_surface;
+    EGLSurface      surface;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
@@ -64,7 +78,16 @@ static char wgl_extensions[4096];
 static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
 
+static struct wayland_mutex gl_object_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": gl_object_mutex"
+};
+
+static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroySurface);
 DECL_FUNCPTR(eglGetConfigAttrib);
 DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
@@ -77,6 +100,117 @@ static inline BOOL is_onscreen_pixel_format(int format)
     return format > 0 && format <= nb_onscreen_formats;
 }
 
+static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int format)
+{
+    struct wayland_gl_drawable *gl;
+    struct wayland_surface *wayland_surface;
+
+    gl = calloc(1, sizeof(*gl));
+    if (!gl) return NULL;
+
+    wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p wayland_surface=%p\n", hwnd, wayland_surface);
+
+    if (wayland_surface)
+    {
+        BOOL ref_gl = wayland_surface_create_or_ref_glvk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_gl) goto err;
+    }
+
+    gl->hwnd = hwnd;
+    gl->format = format;
+    gl->wayland_surface = wayland_surface;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_insert(&gl_drawables, &gl->link);
+    return gl;
+
+err:
+    if (gl)
+    {
+        if (gl->wayland_surface) wayland_surface_unref_glvk(gl->wayland_surface);
+        free(gl);
+    }
+    return NULL;
+}
+
+static void wayland_destroy_gl_drawable(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd != hwnd) continue;
+        wl_list_remove(&gl->link);
+        if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+        if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+        free(gl);
+        break;
+    }
+    wayland_mutex_unlock(&gl_object_mutex);
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_get(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    if (!hwnd) return NULL;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd == hwnd) return gl;
+    }
+    wayland_mutex_unlock(&gl_object_mutex);
+    return NULL;
+}
+
+static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
+{
+    if (gl) wayland_mutex_unlock(&gl_object_mutex);
+}
+
+static struct gbm_surface *wayland_gl_create_gbm_surface(int width, int height,
+                                                         uint32_t drm_format)
+{
+    return gbm_surface_create(process_gbm_device, width, height, drm_format,
+                              GBM_BO_USE_RENDERING);
+}
+
+static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
+{
+    RECT client_rect;
+
+    TRACE("hwnd=%p\n", gl->hwnd);
+
+    if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+    if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
+
+    NtUserGetClientRect(gl->hwnd, &client_rect);
+    gl->width = client_rect.right;
+    gl->height = client_rect.bottom;
+
+    gl->gbm_surface = wayland_gl_create_gbm_surface(gl->width, gl->height,
+                                                    pixel_formats[gl->format - 1].native_visual_id);
+    if (!gl->gbm_surface)
+        ERR("Failed to create GBM surface\n");
+
+    gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
+                                           (EGLNativeWindowType) gl->gbm_surface, NULL);
+    if (!gl->surface)
+        ERR("Failed to create EGL surface\n");
+
+    TRACE("hwnd=%p gbm_surface=%p egl_surface=%p\n",
+          gl->hwnd, gl->gbm_surface, gl->surface);
+
+    NtUserRedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -570,6 +704,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroySurface);
     LOAD_FUNCPTR(eglGetConfigAttrib);
     LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12ebadea2d3..64060a80ca2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -441,6 +441,8 @@ void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, in
                                       int width, int height) DECLSPEC_HIDDEN;
 void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
                                       double wayland_x, double wayland_y,
                                       int *screen_x, int *screen_y) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 77c2a9f50f0..a42d4dafcc5 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -185,7 +185,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
  *
  *  Gets the wayland surface for HWND while locking the private window data.
  */
-static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
 {
     struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
@@ -200,7 +200,7 @@ static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
 /***********************************************************************
  *           wayland_surface_for_hwnd_unlock
  */
-static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
 {
     if (surface) wayland_mutex_unlock(&win_data_mutex);
 }
-- 
2.39.0.rc2

From ed8575cbbd37554b7e2e34d25596df8d3208db9f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sergio=20G=C3=B3mez=20Del=20Real?=
 <sergio.gdr@collabora.com>
Date: Thu, 4 Aug 2022 15:57:58 -0500
Subject: [PATCH 110/202] winewayland.drv: Use default dmabuf modifiers to
 create GL drawables.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If we have default modifier information about a GL format, use the
modifier list to create the GBM surface backing the GL drawable.

Signed-off-by: Sergio Gómez Del Real <sergio.gdr@collabora.com>
---
 configure                             | 10 +++++
 configure.ac                          |  3 +-
 dlls/winewayland.drv/gbm.c            | 53 +++++++++++++++++++++++++
 dlls/winewayland.drv/opengl.c         | 27 ++++++++++++-
 dlls/winewayland.drv/wayland_dmabuf.c | 56 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     | 12 ++++++
 include/config.h.in                   |  4 ++
 7 files changed, 162 insertions(+), 3 deletions(-)

diff --git a/configure b/configure
index 5018e79961c..a0b99711d82 100755
--- a/configure
+++ b/configure
@@ -16277,6 +16277,16 @@ else $as_nop
   GBM_LIBS=""
 fi
 
+         ac_wine_check_funcs_save_LIBS="$LIBS"
+LIBS="$LIBS $GBM_LIBS"
+ac_fn_c_check_func "$LINENO" "gbm_surface_create_with_modifiers2" "ac_cv_func_gbm_surface_create_with_modifiers2"
+if test "x$ac_cv_func_gbm_surface_create_with_modifiers2" = xyes
+then :
+  printf "%s\n" "#define HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2 1" >>confdefs.h
+
+fi
+
+LIBS="$ac_wine_check_funcs_save_LIBS"
 CPPFLAGS=$ac_save_CPPFLAGS
 
     if ${DRM_CFLAGS:+false} :
diff --git a/configure.ac b/configure.ac
index 83c902cf8fc..b7facb5b134 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1428,7 +1428,8 @@ then
          AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
     WINE_PACKAGE_FLAGS(GBM,[gbm],,,,
         [AC_CHECK_HEADERS([gbm.h])
-         AC_CHECK_LIB(gbm,gbm_create_device,[:],[GBM_LIBS=""],[$GBM_LIBS])])
+         AC_CHECK_LIB(gbm,gbm_create_device,[:],[GBM_LIBS=""],[$GBM_LIBS])
+         WINE_CHECK_LIB_FUNCS(gbm_surface_create_with_modifiers2, [$GBM_LIBS])])
     WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
         [AC_CHECK_HEADERS([drm.h])
          AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
index e9c2e929b1a..4632a32b6ed 100644
--- a/dlls/winewayland.drv/gbm.c
+++ b/dlls/winewayland.drv/gbm.c
@@ -29,6 +29,7 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <drm_fourcc.h>
 #include <fcntl.h>
 #ifdef HAVE_LIBUDEV_H
 #include <libudev.h>
@@ -261,6 +262,58 @@ out:
     return compositor_render_node;
 }
 
+/**********************************************************************
+ *          wayland_gbm_create_surface
+ */
+struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, int height,
+                                               size_t count_modifiers, uint64_t *modifiers,
+                                               BOOL format_is_scanoutable)
+{
+    uint32_t gbm_bo_flags = GBM_BO_USE_RENDERING;
+    size_t i;
+
+    if (TRACE_ON(waylanddrv))
+    {
+        TRACE("%dx%d %.4s scanout=%d count_mods=%zu\n",
+              width, height, (const char *)&drm_format,
+              format_is_scanoutable, count_modifiers);
+
+        for (i = 0; i < count_modifiers; i++)
+            TRACE("    mod: 0x%.16llx\n", (long long)modifiers[i]);
+    }
+
+    if (format_is_scanoutable) gbm_bo_flags |= GBM_BO_USE_SCANOUT;
+
+    if (count_modifiers)
+    {
+        struct gbm_surface *surf;
+
+#ifdef HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2
+        surf = gbm_surface_create_with_modifiers2(process_gbm_device, width, height,
+                                                  drm_format, modifiers, count_modifiers, gbm_bo_flags);
+#else
+        surf = gbm_surface_create_with_modifiers(process_gbm_device, width, height,
+                                                 drm_format, modifiers, count_modifiers);
+#endif
+        if (surf) return surf;
+
+        TRACE("Failed to create gbm surface with explicit modifiers API " \
+              "(errno=%d), falling back to implicit modifiers API\n", errno);
+
+        for (i = 0; i < count_modifiers; i++)
+            if (modifiers[i] == DRM_FORMAT_MOD_INVALID) break;
+
+        if (i == count_modifiers)
+        {
+            ERR("Will not create gbm surface with implicit modifiers API, as " \
+                "that is not supported by the compositor\n");
+            return NULL;
+        }
+    }
+
+    return gbm_surface_create(process_gbm_device, width, height, drm_format, gbm_bo_flags);
+}
+
 static void wayland_gbm_init_once(void)
 {
     int drm_fd = -1;
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 174e061c565..99335d44391 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -178,8 +178,31 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
 static struct gbm_surface *wayland_gl_create_gbm_surface(int width, int height,
                                                          uint32_t drm_format)
 {
-    return gbm_surface_create(process_gbm_device, width, height, drm_format,
-                              GBM_BO_USE_RENDERING);
+    struct wayland_dmabuf_format_info format_info;
+    dev_t render_dev;
+    struct wayland_dmabuf *dmabuf;
+    struct gbm_surface *gbm_surface = NULL;
+
+    if (!(render_dev = wayland_gbm_get_render_dev()))
+    {
+        ERR("Failed to get device's dev_t from GBM device.\n");
+        goto out;
+    }
+
+    dmabuf = &wayland_process_acquire()->dmabuf;
+
+    if (wayland_dmabuf_get_default_format_info(dmabuf, drm_format, render_dev, &format_info))
+    {
+        gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                 format_info.count_modifiers,
+                                                 format_info.modifiers,
+                                                 format_info.scanoutable);
+    }
+
+    wayland_process_release();
+
+out:
+    return gbm_surface;
 }
 
 static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index c8aaee8d707..2427a354878 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -119,6 +119,24 @@ static struct wayland_dmabuf_format *dmabuf_feedback_get_format_from_optimal_tra
     return dmabuf_format;
 }
 
+static size_t dmabuf_format_get_modifiers(struct wayland_dmabuf_format *dmabuf_format, uint64_t **modifiers)
+{
+    uint32_t num_modifiers = dmabuf_format->modifiers.size / sizeof(uint64_t);
+
+    if (num_modifiers == 1)
+    {
+        uint64_t *mod = (uint64_t *) dmabuf_format->modifiers.data;
+        if (*mod == DRM_FORMAT_MOD_INVALID) num_modifiers = 0;
+    }
+
+    if (num_modifiers > 0)
+        *modifiers = dmabuf_format->modifiers.data;
+    else
+        *modifiers = NULL;
+
+    return num_modifiers;
+}
+
 static BOOL dmabuf_format_array_add_format_modifier(struct wl_array *formats,
                                                     uint32_t format,
                                                     uint64_t modifier)
@@ -491,6 +509,44 @@ void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
         zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
 }
 
+/***********************************************************************
+ *           wayland_dmabuf_feedback_get_format_info
+ */
+static BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                                    dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+{
+    struct wayland_dmabuf_feedback_tranche *tranche;
+    struct wayland_dmabuf_format *dmabuf_format =
+        dmabuf_feedback_get_format_from_optimal_tranche(feedback, drm_format, render_dev, &tranche);
+
+    if (!dmabuf_format) return FALSE;
+
+    format_info->scanoutable = tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT;
+    format_info->count_modifiers = dmabuf_format_get_modifiers(dmabuf_format, &format_info->modifiers);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_get_default_format_info
+ */
+BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
+                                            dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+
+    if (dmabuf_has_feedback_support(dmabuf))
+        return wayland_dmabuf_feedback_get_format_info(dmabuf->default_feedback, drm_format, render_dev, format_info);
+
+    dmabuf_format = dmabuf_format_array_find_format(&dmabuf->formats, drm_format);
+    if (!dmabuf_format) return FALSE;
+
+    format_info->scanoutable = FALSE;
+    format_info->count_modifiers = dmabuf_format_get_modifiers(dmabuf_format, &format_info->modifiers);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *           wayland_dmabuf_is_format_supported
  */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 64060a80ca2..dd2256ad6d6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -137,6 +137,13 @@ struct wayland_pointer
     HCURSOR hcursor;
 };
 
+struct wayland_dmabuf_format_info
+{
+    uint64_t *modifiers;
+    size_t count_modifiers;
+    BOOL scanoutable;
+};
+
 struct wayland_dmabuf_format
 {
     uint32_t format;
@@ -499,6 +506,8 @@ void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
                          struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1) DECLSPEC_HIDDEN;
 void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
 BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
+                                            dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
 struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
                                                                        struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
@@ -566,6 +575,9 @@ void wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
 
 BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
 dev_t wayland_gbm_get_render_dev(void) DECLSPEC_HIDDEN;
+struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, int height,
+                                               size_t count_modifiers, uint64_t *modifiers,
+                                               BOOL format_is_scanoutable) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
diff --git a/include/config.h.in b/include/config.h.in
index a4847c40e62..4d567bc667f 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -95,6 +95,10 @@
 /* Define to 1 if you have the <gbm.h> header file. */
 #undef HAVE_GBM_H
 
+/* Define to 1 if you have the `gbm_surface_create_with_modifiers2' function.
+   */
+#undef HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2
+
 /* Define to 1 if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
-- 
2.39.0.rc2

From cb013a396e6df1755df3de25aba82982977ffc2c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sergio=20G=C3=B3mez=20Del=20Real?=
 <sergio.gdr@collabora.com>
Date: Wed, 5 Oct 2022 13:19:48 +0300
Subject: [PATCH 111/202] winewayland.drv: Use per-surface dmabuf modifiers to
 create GL drawables.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If we have per-surface modifier information about a GL format, prefer to
use that information instead of the default modifier information,
to create the GBM surface backing the GL drawable.

Signed-off-by: Sergio Gómez Del Real <sergio.gdr@collabora.com>
---
 dlls/winewayland.drv/opengl.c          | 59 ++++++++++++++++++++------
 dlls/winewayland.drv/wayland_dmabuf.c  | 12 +++++-
 dlls/winewayland.drv/wayland_surface.c |  4 ++
 dlls/winewayland.drv/waylanddrv.h      |  3 ++
 4 files changed, 64 insertions(+), 14 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 99335d44391..02e96c79c17 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -175,12 +175,13 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
     if (gl) wayland_mutex_unlock(&gl_object_mutex);
 }
 
-static struct gbm_surface *wayland_gl_create_gbm_surface(int width, int height,
+static struct gbm_surface *wayland_gl_create_gbm_surface(struct wayland_surface *glvk,
+                                                         int width, int height,
                                                          uint32_t drm_format)
 {
     struct wayland_dmabuf_format_info format_info;
     dev_t render_dev;
-    struct wayland_dmabuf *dmabuf;
+    struct wayland_dmabuf_surface_feedback *surface_feedback = glvk ? glvk->surface_feedback : NULL;
     struct gbm_surface *gbm_surface = NULL;
 
     if (!(render_dev = wayland_gbm_get_render_dev()))
@@ -189,17 +190,49 @@ static struct gbm_surface *wayland_gl_create_gbm_surface(int width, int height,
         goto out;
     }
 
-    dmabuf = &wayland_process_acquire()->dmabuf;
-
-    if (wayland_dmabuf_get_default_format_info(dmabuf, drm_format, render_dev, &format_info))
+    if (surface_feedback)
     {
-        gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
-                                                 format_info.count_modifiers,
-                                                 format_info.modifiers,
-                                                 format_info.scanoutable);
+        wayland_dmabuf_surface_feedback_lock(glvk->surface_feedback);
+        if (surface_feedback->feedback)
+        {
+            if (wayland_dmabuf_feedback_get_format_info(surface_feedback->feedback, drm_format,
+                                                        render_dev, &format_info))
+            {
+                TRACE("Using per-surface feedback format/modifier information\n");
+                gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                         format_info.count_modifiers,
+                                                         format_info.modifiers,
+                                                         format_info.scanoutable);
+            }
+        }
+        else
+        {
+            /*
+             * Compositor supports feedback but we haven't processed surface
+             * feedback events yet, so set surface_feedback to NULL to enter
+             * the default format info code path below.
+             */
+            surface_feedback = NULL;
+        }
+
+        wayland_dmabuf_surface_feedback_unlock(glvk->surface_feedback);
     }
 
-    wayland_process_release();
+    if (!surface_feedback)
+    {
+        struct wayland_dmabuf *dmabuf = &wayland_process_acquire()->dmabuf;
+
+        if (wayland_dmabuf_get_default_format_info(dmabuf, drm_format, render_dev, &format_info))
+        {
+            TRACE("Using default format/modifier information\n");
+            gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                     format_info.count_modifiers,
+                                                     format_info.modifiers,
+                                                     format_info.scanoutable);
+        }
+
+        wayland_process_release();
+    }
 
 out:
     return gbm_surface;
@@ -218,8 +251,10 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
     gl->width = client_rect.right;
     gl->height = client_rect.bottom;
 
-    gl->gbm_surface = wayland_gl_create_gbm_surface(gl->width, gl->height,
-                                                    pixel_formats[gl->format - 1].native_visual_id);
+    gl->gbm_surface =
+        wayland_gl_create_gbm_surface(gl->wayland_surface ? gl->wayland_surface->glvk : NULL,
+                                      gl->width, gl->height,
+                                      pixel_formats[gl->format - 1].native_visual_id);
     if (!gl->gbm_surface)
         ERR("Failed to create GBM surface\n");
 
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index 2427a354878..78c5185d5bf 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -512,8 +512,8 @@ void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
 /***********************************************************************
  *           wayland_dmabuf_feedback_get_format_info
  */
-static BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
-                                                    dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
 {
     struct wayland_dmabuf_feedback_tranche *tranche;
     struct wayland_dmabuf_format *dmabuf_format =
@@ -547,6 +547,14 @@ BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint3
     return TRUE;
 }
 
+/***********************************************************************
+ *           wayland_dmabuf_has_feedback_support
+ */
+BOOL wayland_dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
+{
+    return dmabuf_has_feedback_support(dmabuf);
+}
+
 /***********************************************************************
  *           wayland_dmabuf_is_format_supported
  */
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index eb0d2cc9213..e618959a1d4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -834,6 +834,10 @@ BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface)
 
     wayland_surface_reconfigure_apply(surface);
 
+    if (wayland_dmabuf_has_feedback_support(&surface->wayland->dmabuf))
+        glvk->surface_feedback = wayland_dmabuf_surface_feedback_create(&surface->wayland->dmabuf,
+                                                                        glvk->wl_surface);
+
     return TRUE;
 
 err:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dd2256ad6d6..b8dba68a394 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -508,6 +508,9 @@ void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
 BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev) DECLSPEC_HIDDEN;
 BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
 struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
                                                                        struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
-- 
2.39.0.rc2

From 3dd3e6d80721561851981ba28f72442308cecd93 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:20:22 +0300
Subject: [PATCH 112/202] winewayland.drv: Implement wglSetPixelFormat(WINE).

This is the call which signals that a window requires GL rendering, thus
kickstarting the creation (or update) of a wayland_gl_drawable to
manage GL content.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 72 +++++++++++++++++++++++++++++++++++
 1 file changed, 72 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 02e96c79c17..b816edd8d1e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -269,6 +269,53 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
     NtUserRedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
 }
 
+static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
+{
+    struct wayland_gl_drawable *gl;
+    HWND hwnd = NtUserWindowFromDC(hdc);
+    int prev = 0;
+    BOOL needs_update = FALSE;
+
+    if (!hwnd || hwnd == NtUserGetDesktopWindow())
+    {
+        WARN("not a proper window DC %p/%p\n", hdc, hwnd);
+        return FALSE;
+    }
+    if (!is_onscreen_pixel_format(format))
+    {
+        WARN("Invalid format %d\n", format);
+        return FALSE;
+    }
+    TRACE("%p/%p format %d\n", hdc, hwnd, format);
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        prev = gl->format;
+        /* If we are changing formats, destroy any existing EGL surface so that
+         * it can be recreated by wayland_gl_drawable_update. */
+        if (allow_change && gl->format != format)
+        {
+            gl->format = format;
+            needs_update = TRUE;
+        }
+    }
+    else
+    {
+        gl = wayland_gl_drawable_create(hwnd, format);
+        needs_update = TRUE;
+    }
+
+    if (gl && needs_update) wayland_gl_drawable_update(gl);
+
+    wayland_gl_drawable_release(gl);
+
+    if (prev && prev != format && !allow_change) return FALSE;
+    if (NtUserSetWindowPixelFormat(hwnd, format)) return TRUE;
+
+    wayland_destroy_gl_drawable(hwnd);
+    return FALSE;
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -329,6 +376,23 @@ static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
     return ret;
 }
 
+/***********************************************************************
+ *		wayland_wglSetPixelFormat
+ */
+static BOOL WINAPI wayland_wglSetPixelFormat(HDC hdc, int format,
+                                             const PIXELFORMATDESCRIPTOR *pfd)
+{
+    return set_pixel_format(hdc, format, FALSE);
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormatWINE
+ */
+static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
+{
+    return set_pixel_format(hdc, format, TRUE);
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -364,6 +428,13 @@ static void init_extensions(void)
     register_extension("WGL_EXT_extensions_string");
     egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
 
+    /* In WineD3D we need the ability to set the pixel format more than once
+     * (e.g. after a device reset).  The default wglSetPixelFormat doesn't
+     * allow this, so add our own which allows it.
+     */
+    register_extension("WGL_WINE_pixel_format_passthrough");
+    egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -804,6 +875,7 @@ static struct opengl_funcs egl_funcs =
     {
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.39.0.rc2

From 6d6cf63d42c1c114bb1d24a061c8b1bcab0fa46f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:44:37 +0300
Subject: [PATCH 113/202] winewayland.drv: Implement GL context creation.

Each WGL context is backed by an EGL context.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 88 +++++++++++++++++++++++++++++++++++
 1 file changed, 88 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b816edd8d1e..79638414c78 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -69,6 +69,15 @@ struct wayland_gl_drawable
     EGLSurface      surface;
 };
 
+struct wgl_context
+{
+    struct wl_list link;
+    EGLConfig  config;
+    EGLContext context;
+    HWND       draw_hwnd;
+    HWND       read_hwnd;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
@@ -84,9 +93,13 @@ static struct wayland_mutex gl_object_mutex =
 };
 
 static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+static struct wl_list gl_contexts = { &gl_contexts, &gl_contexts };
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglBindAPI);
+DECL_FUNCPTR(eglCreateContext);
 DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroyContext);
 DECL_FUNCPTR(eglDestroySurface);
 DECL_FUNCPTR(eglGetConfigAttrib);
 DECL_FUNCPTR(eglGetConfigs);
@@ -316,6 +329,75 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     return FALSE;
 }
 
+static struct wgl_context *create_context(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    struct wgl_context *ctx;
+
+    if (!(gl = wayland_gl_drawable_get(NtUserWindowFromDC(hdc)))) return NULL;
+
+    ctx = malloc(sizeof(*ctx));
+    if (!ctx)
+    {
+        ERR("Failed to allocate memory for GL context\n");
+        goto out;
+    }
+
+    ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->context = p_eglCreateContext(egl_display, ctx->config,
+                                      EGL_NO_CONTEXT,
+                                      NULL);
+    ctx->draw_hwnd = 0;
+    ctx->read_hwnd = 0;
+
+    /* The gl_object_mutex, which is locked when we get the gl_drawable,
+     * also guards access to gl_contexts, so it's safe to add the entry here. */
+    wl_list_insert(&gl_contexts, &ctx->link);
+
+out:
+    wayland_gl_drawable_release(gl);
+
+    TRACE("ctx=%p hdc=%p fmt=%d egl_ctx=%p\n",
+          ctx, hdc, gl->format, ctx ? ctx->context : NULL);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglCopyContext
+ */
+static BOOL WINAPI wayland_wglCopyContext(struct wgl_context *src,
+                                          struct wgl_context *dst, UINT mask)
+{
+    FIXME("%p -> %p mask %#x unsupported\n", src, dst, mask);
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContext
+ */
+static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
+{
+    TRACE("hdc=%p\n", hdc);
+
+    p_eglBindAPI(EGL_OPENGL_API);
+
+    return create_context(hdc);
+}
+
+/***********************************************************************
+ *		wayland_wglDeleteContext
+ */
+static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
+{
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_remove(&ctx->link);
+    wayland_mutex_unlock(&gl_object_mutex);
+    p_eglDestroyContext(egl_display, ctx->context);
+    free(ctx);
+    return TRUE;
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -833,7 +915,10 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglBindAPI);
+    LOAD_FUNCPTR(eglCreateContext);
     LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroyContext);
     LOAD_FUNCPTR(eglDestroySurface);
     LOAD_FUNCPTR(eglGetConfigAttrib);
     LOAD_FUNCPTR(eglGetConfigs);
@@ -873,6 +958,9 @@ static struct opengl_funcs egl_funcs =
 {
     .wgl =
     {
+        .p_wglCopyContext = wayland_wglCopyContext,
+        .p_wglCreateContext = wayland_wglCreateContext,
+        .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
-- 
2.39.0.rc2

From e67da90f2ffda978415ff73e09fa110041403381 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:34:46 +0300
Subject: [PATCH 114/202] winewayland.drv: Implement wglMakeCurrent and
 wglMakeContextCurrentARB.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 83 +++++++++++++++++++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 79638414c78..9ca1420b39e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -45,6 +45,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include "wine/wgl_driver.h"
 
 #include "ntuser.h"
+#include "winternl.h"
 
 #include <EGL/egl.h>
 #include <assert.h>
@@ -106,6 +107,7 @@ DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
+DECL_FUNCPTR(eglMakeCurrent);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -188,6 +190,36 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
     if (gl) wayland_mutex_unlock(&gl_object_mutex);
 }
 
+static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HWND read_hwnd)
+{
+    BOOL ret;
+    struct wayland_gl_drawable *draw_gl = NULL, *read_gl = NULL;
+
+    draw_gl = wayland_gl_drawable_get(draw_hwnd);
+    read_gl = wayland_gl_drawable_get(read_hwnd);
+
+    TRACE("%p/%p context %p surface %p/%p\n",
+          draw_hwnd, read_hwnd, ctx->context,
+          draw_gl ? draw_gl->surface : NULL,
+          read_gl ? read_gl->surface : NULL);
+
+    ret = p_eglMakeCurrent(egl_display,
+                           draw_gl ? draw_gl->surface : NULL,
+                           read_gl ? read_gl->surface : NULL,
+                           ctx->context);
+    if (ret)
+    {
+        ctx->draw_hwnd = draw_hwnd;
+        ctx->read_hwnd = read_hwnd;
+        NtCurrentTeb()->glContext = ctx;
+    }
+
+    wayland_gl_drawable_release(read_gl);
+    wayland_gl_drawable_release(draw_gl);
+
+    return ret;
+}
+
 static struct gbm_surface *wayland_gl_create_gbm_surface(struct wayland_surface *glvk,
                                                          int width, int height,
                                                          uint32_t drm_format)
@@ -276,6 +308,20 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
     if (!gl->surface)
         ERR("Failed to create EGL surface\n");
 
+    if (gl->surface)
+    {
+        struct wgl_context *ctx;
+
+        wl_list_for_each(ctx, &gl_contexts, link)
+        {
+            if (ctx->draw_hwnd != gl->hwnd && ctx->read_hwnd != gl->hwnd) continue;
+            TRACE("hwnd %p refreshing %p %scurrent\n",
+                  gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
+            if (NtCurrentTeb()->glContext == ctx)
+                wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        }
+    }
+
     TRACE("hwnd=%p gbm_surface=%p egl_surface=%p\n",
           gl->hwnd, gl->gbm_surface, gl->surface);
 
@@ -398,6 +444,37 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     return TRUE;
 }
 
+/***********************************************************************
+ *		wayland_wglMakeContextCurrentARB
+ */
+static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
+                                             struct wgl_context *ctx)
+{
+    BOOL ret = FALSE;
+
+    TRACE("draw_hdc=%p read_hdc=%p ctx=%p\n", draw_hdc, read_hdc, ctx);
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    ret = wgl_context_make_current(ctx, NtUserWindowFromDC(draw_hdc), NtUserWindowFromDC(read_hdc));
+    if (!ret) RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
+
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeCurrent
+ */
+static BOOL WINAPI wayland_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+{
+    return wayland_wglMakeContextCurrentARB(hdc, hdc, ctx);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -517,6 +594,10 @@ static void init_extensions(void)
     register_extension("WGL_WINE_pixel_format_passthrough");
     egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
 
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -925,6 +1006,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
+    LOAD_FUNCPTR(eglMakeCurrent);
 #undef LOAD_FUNCPTR
 
     if (!wayland_gbm_init()) return FALSE;
@@ -963,6 +1045,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.39.0.rc2

From 06303d89e49783bd0a9c9a66439121320394ed21 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:46:40 +0300
Subject: [PATCH 115/202] winewayland.drv: Implement wglGetPixelFormat.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 9ca1420b39e..2a4cc90fc72 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -523,6 +523,24 @@ static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
     return nb_onscreen_formats;
 }
 
+/***********************************************************************
+ *		wayland_wglGetPixelFormat
+ */
+static int WINAPI wayland_wglGetPixelFormat(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    int ret = 0;
+
+    if ((gl = wayland_gl_drawable_get(NtUserWindowFromDC(hdc))))
+    {
+        ret = gl->format;
+        /* offscreen formats can't be used with traditional WGL calls */
+        if (!is_onscreen_pixel_format(ret)) ret = 1;
+        wayland_gl_drawable_release(gl);
+    }
+    return ret;
+}
+
 /***********************************************************************
  *		wayland_wglGetProcAddress
  */
@@ -1044,6 +1062,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglCreateContext = wayland_wglCreateContext,
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
+        .p_wglGetPixelFormat = wayland_wglGetPixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
-- 
2.39.0.rc2

From d7ef6526c613c490de78d7c349a2f1b6631523f3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:56:36 +0300
Subject: [PATCH 116/202] winewayland.drv: Implement
 wglCreateContextAttribsARB.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 188 +++++++++++++++++++++++++++++++++-
 1 file changed, 184 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 2a4cc90fc72..568f656221e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -48,6 +48,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include "winternl.h"
 
 #include <EGL/egl.h>
+#include <EGL/eglext.h>
 #include <assert.h>
 #include <dlfcn.h>
 #include <stdlib.h>
@@ -77,6 +78,7 @@ struct wgl_context
     EGLContext context;
     HWND       draw_hwnd;
     HWND       read_hwnd;
+    int        *attribs;
 };
 
 static void *egl_handle;
@@ -87,6 +89,7 @@ static struct opengl_funcs egl_funcs;
 static char wgl_extensions[4096];
 static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
+static BOOL has_khr_create_context;
 
 static struct wayland_mutex gl_object_mutex =
 {
@@ -108,6 +111,7 @@ DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 DECL_FUNCPTR(eglMakeCurrent);
+DECL_FUNCPTR(eglQueryString);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -375,7 +379,94 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     return FALSE;
 }
 
-static struct wgl_context *create_context(HDC hdc)
+struct egl_attribs
+{
+    EGLint *data;
+    int count;
+};
+
+static void egl_attribs_init(struct egl_attribs *attribs)
+{
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static void egl_attribs_add(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    EGLint *new_data = realloc(attribs->data,
+                               sizeof(*attribs->data) * (attribs->count + 2));
+    if (!new_data)
+    {
+        ERR("Could not allocate memory for EGL attributes!\n");
+        return;
+    }
+
+    attribs->data = new_data;
+    attribs->data[attribs->count] = name;
+    attribs->data[attribs->count + 1] = value;
+    attribs->count += 2;
+}
+
+
+static void egl_attribs_add_15_khr(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    BOOL has_egl_15 = egl_version[0] == 1 && egl_version[1] >= 5;
+
+    if (!has_egl_15 && !has_khr_create_context)
+    {
+        WARN("Ignoring EGL context attrib %#x not supported by EGL %d.%d\n",
+             name, egl_version[0], egl_version[1]);
+        return;
+    }
+
+    if (name == EGL_CONTEXT_FLAGS_KHR && has_egl_15)
+    {
+        egl_attribs_add(attribs, EGL_CONTEXT_OPENGL_DEBUG,
+                        (value & WGL_CONTEXT_DEBUG_BIT_ARB) ?
+                             EGL_TRUE : EGL_FALSE);
+        egl_attribs_add(attribs,
+                        EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE,
+                        (value & WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB) ?
+                            EGL_TRUE : EGL_FALSE);
+    }
+    else
+    {
+        egl_attribs_add(attribs, name, value);
+    }
+}
+
+static EGLint *egl_attribs_steal_finished_data(struct egl_attribs *attribs)
+{
+    EGLint *data = NULL;
+
+    if (attribs->data)
+    {
+        data = realloc(attribs->data,
+                       sizeof(*attribs->data) * (attribs->count + 1));
+        if (!data)
+        {
+            ERR("Could not allocate memory for EGL attributes!\n");
+        }
+        else
+        {
+            data[attribs->count] = EGL_NONE;
+            attribs->data = NULL;
+            attribs->count = 0;
+        }
+    }
+
+    return data;
+}
+
+static void egl_attribs_deinit(struct egl_attribs *attribs)
+{
+    free(attribs->data);
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
+                                          struct egl_attribs *attribs)
 {
     struct wayland_gl_drawable *gl;
     struct wgl_context *ctx;
@@ -390,9 +481,10 @@ static struct wgl_context *create_context(HDC hdc)
     }
 
     ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->attribs = attribs ? egl_attribs_steal_finished_data(attribs) : NULL;
     ctx->context = p_eglCreateContext(egl_display, ctx->config,
-                                      EGL_NO_CONTEXT,
-                                      NULL);
+                                      share ? share->context : EGL_NO_CONTEXT,
+                                      ctx->attribs);
     ctx->draw_hwnd = 0;
     ctx->read_hwnd = 0;
 
@@ -428,7 +520,69 @@ static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
 
     p_eglBindAPI(EGL_OPENGL_API);
 
-    return create_context(hdc);
+    return create_context(hdc, NULL, NULL);
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContextAttribsARB
+ */
+static struct wgl_context *wayland_wglCreateContextAttribsARB(HDC hdc,
+                                                              struct wgl_context *share,
+                                                              const int *attribs)
+{
+    struct egl_attribs egl_attribs = {0};
+    EGLenum api_type = EGL_OPENGL_API;
+    EGLenum profile_mask;
+    struct wgl_context *ctx;
+
+    egl_attribs_init(&egl_attribs);
+
+    TRACE("hdc=%p share=%p attribs=%p\n", hdc, share, attribs);
+
+    while (attribs && *attribs)
+    {
+        TRACE("%#x %#x\n", attribs[0], attribs[1]);
+        switch (*attribs)
+        {
+        case WGL_CONTEXT_PROFILE_MASK_ARB:
+            profile_mask = 0;
+            if (attribs[1] & WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+                api_type = EGL_OPENGL_ES_API;
+            if (attribs[1] & WGL_CONTEXT_CORE_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT;
+            if (attribs[1] & WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT;
+            /* If the WGL profile mask doesn't have ES2 as the only set bit,
+             * pass the mask to EGL. Note that this will also pass empty
+             * WGL masks, in order to elicit the respective EGL error. */
+            if (attribs[1] != WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+            {
+                egl_attribs_add_15_khr(&egl_attribs,
+                                       EGL_CONTEXT_OPENGL_PROFILE_MASK, profile_mask);
+            }
+            break;
+        case WGL_CONTEXT_MAJOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MAJOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_MINOR_VERSION_ARB:
+            egl_attribs_add_15_khr(&egl_attribs, EGL_CONTEXT_MINOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_FLAGS_ARB:
+            egl_attribs_add_15_khr(&egl_attribs, EGL_CONTEXT_FLAGS_KHR, attribs[1]);
+            break;
+        default:
+            FIXME("Unhandled attributes: %#x %#x\n", attribs[0], attribs[1]);
+        }
+        attribs += 2;
+    }
+
+    p_eglBindAPI(api_type);
+
+    ctx = create_context(hdc, share, &egl_attribs);
+
+    egl_attribs_deinit(&egl_attribs);
+
+    return ctx;
 }
 
 /***********************************************************************
@@ -440,6 +594,7 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     wl_list_remove(&ctx->link);
     wayland_mutex_unlock(&gl_object_mutex);
     p_eglDestroyContext(egl_display, ctx->context);
+    free(ctx->attribs);
     free(ctx);
     return TRUE;
 }
@@ -595,9 +750,26 @@ static void register_extension(const char *ext)
     TRACE("%s\n", ext);
 }
 
+static BOOL has_extension(const char *list, const char *ext)
+{
+    size_t len = strlen(ext);
+    const char *cur = list;
+
+    if (!cur) return FALSE;
+
+    while ((cur = strstr(cur, ext)))
+    {
+        if ((!cur[len] || cur[len] == ' ') && (cur == list || cur[-1] == ' '))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
 static void init_extensions(void)
 {
     void *ptr;
+    const char *egl_exts = p_eglQueryString(egl_display, EGL_EXTENSIONS);
 
     register_extension("WGL_ARB_extensions_string");
     egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
@@ -616,6 +788,13 @@ static void init_extensions(void)
     egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
     egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
 
+    register_extension("WGL_ARB_create_context");
+    register_extension("WGL_ARB_create_context_profile");
+    egl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
+
+    if (has_extension(egl_exts, "EGL_KHR_create_context"))
+        has_khr_create_context = TRUE;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -1025,6 +1204,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
     LOAD_FUNCPTR(eglMakeCurrent);
+    LOAD_FUNCPTR(eglQueryString);
 #undef LOAD_FUNCPTR
 
     if (!wayland_gbm_init()) return FALSE;
-- 
2.39.0.rc2

From 1316015c6abe5731024158939de186b34606bb70 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:57:55 +0300
Subject: [PATCH 117/202] winewayland.drv: Implement wglShareLists.

Sharing of display lists works differently in EGL and WGL. In case of
EGL it is done at context creation time but in case of EGL it can also
be done using wglShareLists.

We handle this by creating an EGL context in wglCreateContext /
wglCreateContextAttribsARB and when a program requests sharing we
recreate the destination context if it hasn't been made current and it
hasn't shared display lists before.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 51 +++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 568f656221e..64ec00604e7 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -78,6 +78,8 @@ struct wgl_context
     EGLContext context;
     HWND       draw_hwnd;
     HWND       read_hwnd;
+    BOOL       has_been_current;
+    BOOL       sharing;
     int        *attribs;
 };
 
@@ -215,6 +217,7 @@ static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HW
     {
         ctx->draw_hwnd = draw_hwnd;
         ctx->read_hwnd = read_hwnd;
+        ctx->has_been_current = TRUE;
         NtCurrentTeb()->glContext = ctx;
     }
 
@@ -487,6 +490,8 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
                                       ctx->attribs);
     ctx->draw_hwnd = 0;
     ctx->read_hwnd = 0;
+    ctx->has_been_current = FALSE;
+    ctx->sharing = FALSE;
 
     /* The gl_object_mutex, which is locked when we get the gl_drawable,
      * also guards access to gl_contexts, so it's safe to add the entry here. */
@@ -725,6 +730,51 @@ static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
     return set_pixel_format(hdc, format, TRUE);
 }
 
+/***********************************************************************
+ *		wayland_wglShareLists
+ */
+static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
+                                         struct wgl_context *dest)
+{
+    TRACE("(%p, %p)\n", org, dest);
+
+    /* Sharing of display lists works differently in EGL and WGL. In case of
+     * EGL it is done at context creation time but in case of EGL it can also
+     * be done using wglShareLists.
+     *
+     * We handle this by creating an EGL context in wglCreateContext /
+     * wglCreateContextAttribsARB and when a program requests sharing we
+     * recreate the destination context if it hasn't been made current and
+     * it hasn't shared display lists before.
+     */
+
+    if (dest->has_been_current)
+    {
+        ERR("Could not share display lists, the hglrc2 context has been current already!\n");
+        return FALSE;
+    }
+    else if (dest->sharing)
+    {
+        ERR("Could not share display lists because hglrc2 has already shared lists before!\n");
+        return FALSE;
+    }
+    else
+    {
+        /* Re-create the EGL context and share display lists */
+        p_eglDestroyContext(egl_display, dest->context);
+        dest->context = p_eglCreateContext(egl_display, dest->config,
+                                           org->context, dest->attribs);
+        TRACE("re-created EGL context (%p) for WGL context %p (config: %p) "
+              "sharing lists with EGL context %p for WGL context %p (config: %p)\n",
+              dest->context, dest, dest->config, org->context, org, org->config);
+        org->sharing = TRUE;
+        dest->sharing = TRUE;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1246,6 +1296,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
+        .p_wglShareLists = wayland_wglShareLists,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.39.0.rc2

From 220ba46344242da099941f2a66fd76c8896d4131 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:25:18 +0300
Subject: [PATCH 118/202] winewayland.drv: Add function to ensure a Wayland
 surface is mapped.

The contents of GL or Vulkan windows are rendered on subsurfaces with
the parent surface used for the decorations. Such GL/VK subsurfaces may
want to commit their contents before the parent surface has had a chance
to commit. In such cases the GL/VK commit will not be displayed, but,
more importantly, will not get a frame callback until the parent surface
is also committed. Depending on the presentation mode, a second GL/VK
buffer swap may indefinitely block waiting on the frame callback. By
calling this function before a GL/VK buffer swap we can avoid this
situation.

If the ancestor surfaces of GL/VK subsurface are subsurfaces themselves
we need to recursively ensure they are also mapped (fix proposed by
Alexander <alexander.>).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 82 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 83 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index e618959a1d4..5743aff164e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1111,6 +1111,88 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                    wine_width, wine_height);
 }
 
+static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    wayland_shm_buffer_destroy(shm_buffer);
+}
+
+static const struct wl_buffer_listener dummy_buffer_listener = {
+    dummy_buffer_release
+};
+
+/**********************************************************************
+ *          wayland_surface_ensure_mapped
+ *
+ * Ensure that the wayland surface is mapped, by committing a dummy
+ * buffer if necessary.
+ *
+ * The contents of GL or Vulkan windows are rendered on subsurfaces
+ * with the parent surface used for the decorations. Such GL/VK
+ * subsurfaces may want to commit their contents before the parent
+ * surface has had a chance to commit. In such cases the GL/VK commit
+ * will not be displayed, but, more importantly, will not get a frame
+ * callback until the parent surface is also committed. Depending on
+ * the presentation mode, a second GL/VK buffer swap may indefinitely
+ * block waiting on the frame callback. By calling this function before a
+ * GL/VK buffer swap we can avoid this situation.
+ */
+void wayland_surface_ensure_mapped(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    /* If this is a subsurface, ensure its parent is also mapped. */
+    if (surface->parent)
+        wayland_surface_ensure_mapped(surface->parent);
+
+    TRACE("surface=%p hwnd=%p mapped=%d\n",
+          surface, surface->hwnd, surface->mapped);
+
+    if (!surface->mapped)
+    {
+        int width = surface->current.width;
+        int height = surface->current.height;
+        int flags = surface->current.configure_flags;
+        int wine_width, wine_height;
+        struct wayland_shm_buffer *dummy_shm_buffer;
+        HRGN damage;
+
+        /* Use a large enough width/height, so even when the target
+         * surface is scaled by the compositor, this will not end up
+         * being 0x0. */
+        if (width == 0) width = 32;
+        if (height == 0) height = 32;
+
+        if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+            !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        {
+            wayland_surface_find_wine_fullscreen_fit(surface, width, height,
+                                                     &wine_width, &wine_height);
+        }
+        else
+        {
+            wayland_surface_coords_to_wine(surface, width, height,
+                                           &wine_width, &wine_height);
+        }
+
+        dummy_shm_buffer = wayland_shm_buffer_create(surface->wayland,
+                                                     wine_width, wine_height,
+                                                     WL_SHM_FORMAT_ARGB8888);
+        wl_buffer_add_listener(dummy_shm_buffer->wl_buffer,
+                               &dummy_buffer_listener, dummy_shm_buffer);
+
+        damage = NtGdiCreateRectRgn(0, 0, wine_width, wine_height);
+        if (!wayland_surface_commit_buffer(surface, dummy_shm_buffer, damage))
+            wayland_shm_buffer_destroy(dummy_shm_buffer);
+        NtGdiDeleteObjectApp(damage);
+    }
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b8dba68a394..c72fef11851 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -465,6 +465,7 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
 void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                               int wayland_width, int wayland_height,
                                               int *wine_width, int *wine_height) DECLSPEC_HIDDEN;
+void wayland_surface_ensure_mapped(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
-- 
2.39.0.rc2

From e6276c560b3c43f93be69887288b78158cf278fe Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:26:32 +0300
Subject: [PATCH 119/202] winewayland.drv: Implement wglSwapBuffers.

Before swapping we check that the target Wayland surface allows drawing,
to avoid commits with incorrectly sized buffers during reconfigurations.
We also ensure that the parent (decoration) Wayland surface is mapped to
avoid blocking.

This commit implements unthrottled swapping behavior. The next commit
will add support for proper SwapInterval handling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 244 ++++++++++++++++++++++++++++++++++
 1 file changed, 244 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 64ec00604e7..15b56b79370 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -69,6 +69,17 @@ struct wayland_gl_drawable
     struct wayland_surface *wayland_surface;
     struct gbm_surface *gbm_surface;
     EGLSurface      surface;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_list  buffer_list;
+};
+
+struct wayland_gl_buffer
+{
+    struct wl_list  link;
+    struct wayland_gl_drawable *gl;
+    struct gbm_bo *gbm_bo;
+    struct gbm_surface *gbm_surface;
+    struct wayland_dmabuf_buffer *dmabuf_buffer;
 };
 
 struct wgl_context
@@ -78,6 +89,7 @@ struct wgl_context
     EGLContext context;
     HWND       draw_hwnd;
     HWND       read_hwnd;
+    LONG       refresh;
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
@@ -114,6 +126,7 @@ DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 DECL_FUNCPTR(eglMakeCurrent);
 DECL_FUNCPTR(eglQueryString);
+DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -143,6 +156,12 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     gl->hwnd = hwnd;
     gl->format = format;
     gl->wayland_surface = wayland_surface;
+    if (gl->wayland_surface)
+    {
+        gl->wl_event_queue = wl_display_create_queue(wayland_surface->wayland->wl_display);
+        if (!gl->wl_event_queue) goto err;
+    }
+    wl_list_init(&gl->buffer_list);
 
     wayland_mutex_lock(&gl_object_mutex);
     wl_list_insert(&gl_drawables, &gl->link);
@@ -152,11 +171,36 @@ err:
     if (gl)
     {
         if (gl->wayland_surface) wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
         free(gl);
     }
     return NULL;
 }
 
+static void wayland_gl_buffer_destroy(struct wayland_gl_buffer *gl_buffer)
+{
+    TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    wl_list_remove(&gl_buffer->link);
+    if (gl_buffer->dmabuf_buffer)
+        wayland_dmabuf_buffer_destroy(gl_buffer->dmabuf_buffer);
+    gbm_bo_set_user_data(gl_buffer->gbm_bo, NULL, NULL);
+    free(gl_buffer);
+}
+
+static void wayland_gl_buffer_release(struct wayland_gl_buffer *gl_buffer)
+{
+    TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
+}
+
+static void wayland_gl_drawable_clear_buffers(struct wayland_gl_drawable *gl)
+{
+    struct wayland_gl_buffer *gl_buffer, *tmp;
+
+    wl_list_for_each_safe(gl_buffer, tmp, &gl->buffer_list, link)
+        wayland_gl_buffer_destroy(gl_buffer);
+}
+
 static void wayland_destroy_gl_drawable(HWND hwnd)
 {
     struct wayland_gl_drawable *gl;
@@ -166,10 +210,12 @@ static void wayland_destroy_gl_drawable(HWND hwnd)
     {
         if (gl->hwnd != hwnd) continue;
         wl_list_remove(&gl->link);
+        wayland_gl_drawable_clear_buffers(gl);
         if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
         if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
         if (gl->wayland_surface)
             wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
         free(gl);
         break;
     }
@@ -217,6 +263,7 @@ static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HW
     {
         ctx->draw_hwnd = draw_hwnd;
         ctx->read_hwnd = read_hwnd;
+        InterlockedExchange(&ctx->refresh, FALSE);
         ctx->has_been_current = TRUE;
         NtCurrentTeb()->glContext = ctx;
     }
@@ -296,6 +343,7 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 
     TRACE("hwnd=%p\n", gl->hwnd);
 
+    wayland_gl_drawable_clear_buffers(gl);
     if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
     if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
 
@@ -326,6 +374,8 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
                   gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
             if (NtCurrentTeb()->glContext == ctx)
                 wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+            else
+                InterlockedExchange(&ctx->refresh, TRUE);
         }
     }
 
@@ -335,6 +385,144 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
     NtUserRedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
 }
 
+static BOOL wayland_gl_surface_feedback_has_update(struct wayland_gl_drawable *gl)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback =
+        gl->wayland_surface ? gl->wayland_surface->glvk->surface_feedback : NULL;
+    BOOL ret = FALSE;
+
+    if (surface_feedback)
+    {
+        wayland_dmabuf_surface_feedback_lock(surface_feedback);
+        ret = surface_feedback->surface_needs_update;
+        surface_feedback->surface_needs_update = FALSE;
+        wayland_dmabuf_surface_feedback_unlock(surface_feedback);
+    }
+
+    TRACE("hwnd=%p => %d\n", gl->hwnd, ret);
+
+    return ret;
+}
+
+static BOOL wayland_gl_drawable_needs_resize(struct wayland_gl_drawable *gl)
+{
+    RECT client_rect;
+    BOOL ret;
+
+    NtUserGetClientRect(gl->hwnd, &client_rect);
+
+    ret = (client_rect.right > 0 && client_rect.bottom > 0 &&
+           (gl->width != client_rect.right || gl->height != client_rect.bottom));
+
+    TRACE("hwnd=%p client=%dx%d gl=%dx%d => %d\n",
+          gl->hwnd, (int)client_rect.right, (int)client_rect.bottom,
+          gl->width, gl->height, ret);
+
+    return ret;
+}
+
+static BOOL wayland_gl_drawable_needs_update(struct wayland_gl_drawable *gl)
+{
+    return wayland_gl_drawable_needs_resize(gl) || wayland_gl_surface_feedback_has_update(gl);
+}
+
+static void gbm_bo_destroy_callback(struct gbm_bo *bo, void *user_data)
+{
+    struct wayland_gl_buffer *gl_buffer = (struct wayland_gl_buffer *) user_data;
+    wayland_gl_buffer_destroy(gl_buffer);
+}
+
+static void dmabuf_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_gl_buffer *gl_buffer = (struct wayland_gl_buffer *) data;
+
+    TRACE("bo=%p\n", gl_buffer->gbm_bo);
+    wayland_gl_buffer_release(gl_buffer);
+}
+
+static const struct wl_buffer_listener dmabuf_buffer_listener = {
+    dmabuf_buffer_release
+};
+
+static struct wayland_gl_buffer *wayland_gl_drawable_track_buffer(struct wayland_gl_drawable *gl,
+                                                                  struct gbm_bo *bo)
+{
+    struct wayland_gl_buffer *gl_buffer =
+        (struct wayland_gl_buffer *) gbm_bo_get_user_data(bo);
+
+    if (!gl_buffer)
+    {
+        struct wayland_native_buffer native_buffer;
+
+        gl_buffer = calloc(1, sizeof(*gl_buffer));
+        if (!gl_buffer) goto err;
+
+        wl_list_init(&gl_buffer->link);
+        gl_buffer->gbm_bo = bo;
+        gl_buffer->gbm_surface = gl->gbm_surface;
+        if (!wayland_native_buffer_init_gbm(&native_buffer, bo)) goto err;
+
+        if (gl->wayland_surface)
+        {
+            gl_buffer->dmabuf_buffer =
+                wayland_dmabuf_buffer_create_from_native(gl->wayland_surface->wayland,
+                                                         &native_buffer);
+            wayland_native_buffer_deinit(&native_buffer);
+            if (!gl_buffer->dmabuf_buffer) goto err;
+
+            wl_proxy_set_queue((struct wl_proxy *) gl_buffer->dmabuf_buffer->wl_buffer,
+                               gl->wl_event_queue);
+            wl_buffer_add_listener(gl_buffer->dmabuf_buffer->wl_buffer,
+                                   &dmabuf_buffer_listener, gl_buffer);
+        }
+
+        gbm_bo_set_user_data(bo, gl_buffer, gbm_bo_destroy_callback);
+        wl_list_insert(&gl->buffer_list, &gl_buffer->link);
+    }
+
+    return gl_buffer;
+
+err:
+    if (gl_buffer) wayland_gl_buffer_destroy(gl_buffer);
+    return NULL;
+}
+
+static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
+                                       struct wayland_gl_buffer *gl_buffer)
+{
+    BOOL committed = FALSE;
+
+    if (!gl->wayland_surface) return FALSE;
+
+    wayland_mutex_lock(&gl->wayland_surface->mutex);
+    if (gl->wayland_surface->drawing_allowed)
+    {
+        struct wl_surface *gl_wl_surface = gl->wayland_surface->glvk->wl_surface;
+        wayland_surface_ensure_mapped(gl->wayland_surface);
+        wl_surface_attach(gl_wl_surface, gl_buffer->dmabuf_buffer->wl_buffer, 0, 0);
+        wl_surface_damage_buffer(gl_wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        wl_surface_commit(gl_wl_surface);
+        committed = TRUE;
+    }
+    wayland_mutex_unlock(&gl->wayland_surface->mutex);
+
+    return committed;
+}
+
+static BOOL wgl_context_refresh(struct wgl_context *ctx)
+{
+    BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
+
+    if (ret)
+    {
+        TRACE("refreshing context %p hwnd %p/%p\n",
+              ctx->context, ctx->draw_hwnd, ctx->read_hwnd);
+        wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        NtUserRedrawWindow(ctx->draw_hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+    }
+    return ret;
+}
+
 static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
 {
     struct wayland_gl_drawable *gl;
@@ -490,6 +678,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
                                       ctx->attribs);
     ctx->draw_hwnd = 0;
     ctx->read_hwnd = 0;
+    ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
 
@@ -775,6 +964,59 @@ static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
     return FALSE;
 }
 
+/***********************************************************************
+ *		wayland_wglSwapBuffers
+ */
+static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    HWND hwnd = NtUserWindowFromDC(hdc);
+    struct wayland_gl_drawable *draw_gl = wayland_gl_drawable_get(hwnd);
+
+    TRACE("hdc %p hwnd %p ctx %p\n", hdc, hwnd, ctx);
+
+    if (draw_gl && wayland_gl_drawable_needs_update(draw_gl))
+    {
+        wayland_gl_drawable_update(draw_gl);
+        goto out;
+    }
+
+    if ((!ctx || !wgl_context_refresh(ctx)) && draw_gl && draw_gl->surface)
+    {
+        struct wayland_gl_buffer *gl_buffer;
+        struct gbm_bo *bo;
+
+        p_eglSwapBuffers(egl_display, draw_gl->surface);
+
+        bo = gbm_surface_lock_front_buffer(draw_gl->gbm_surface);
+        if (!bo)
+        {
+            ERR("Failed to lock front buffer\n");
+            goto out;
+        }
+        gl_buffer = wayland_gl_drawable_track_buffer(draw_gl, bo);
+
+        if (!wayland_gl_drawable_commit(draw_gl, gl_buffer))
+            gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
+
+        /* Wait until we have a free buffer for the application to render into
+         * before we continue. */
+        if (draw_gl->wayland_surface)
+        {
+            while (!gbm_surface_has_free_buffers(draw_gl->gbm_surface) &&
+                   wayland_dispatch_queue(draw_gl->wl_event_queue, -1) != -1)
+            {
+                continue;
+            }
+        }
+    }
+
+out:
+    wayland_gl_drawable_release(draw_gl);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1255,6 +1497,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglInitialize);
     LOAD_FUNCPTR(eglMakeCurrent);
     LOAD_FUNCPTR(eglQueryString);
+    LOAD_FUNCPTR(eglSwapBuffers);
 #undef LOAD_FUNCPTR
 
     if (!wayland_gbm_init()) return FALSE;
@@ -1297,6 +1540,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
         .p_wglShareLists = wayland_wglShareLists,
+        .p_wglSwapBuffers = wayland_wglSwapBuffers,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.39.0.rc2

From 27766f9186331e28f0e739f12dcc920fa80e91a0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Mar 2022 09:37:04 +0200
Subject: [PATCH 120/202] winewayland.drv: Implement WGL_EXT_swap_control.

Implement the wglSwapIntervalEXT and wglGetSwapIntervalEXT extension
functions by using the wl_surface frame callback to throttle
presentation when needed. The current implementation only supports swap
interval values of 0 and 1. Values over 1 are treated as a value of 1.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 121 ++++++++++++++++++++++++++++++++++
 1 file changed, 121 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 15b56b79370..17168fc457a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -71,6 +71,8 @@ struct wayland_gl_drawable
     EGLSurface      surface;
     struct wl_event_queue *wl_event_queue;
     struct wl_list  buffer_list;
+    int             swap_interval;
+    struct wl_callback *throttle_callback;
 };
 
 struct wayland_gl_buffer
@@ -162,6 +164,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
         if (!gl->wl_event_queue) goto err;
     }
     wl_list_init(&gl->buffer_list);
+    gl->swap_interval = 1;
 
     wayland_mutex_lock(&gl_object_mutex);
     wl_list_insert(&gl_drawables, &gl->link);
@@ -215,6 +218,7 @@ static void wayland_destroy_gl_drawable(HWND hwnd)
         if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
         if (gl->wayland_surface)
             wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->throttle_callback) wl_callback_destroy(gl->throttle_callback);
         if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
         free(gl);
         break;
@@ -487,6 +491,19 @@ err:
     return NULL;
 }
 
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_gl_drawable *draw_gl = data;
+
+    TRACE("hwnd=%p\n", draw_gl->hwnd);
+    draw_gl->throttle_callback = NULL;
+    wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
 static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
                                        struct wayland_gl_buffer *gl_buffer)
 {
@@ -501,6 +518,13 @@ static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
         wayland_surface_ensure_mapped(gl->wayland_surface);
         wl_surface_attach(gl_wl_surface, gl_buffer->dmabuf_buffer->wl_buffer, 0, 0);
         wl_surface_damage_buffer(gl_wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (gl->swap_interval > 0)
+        {
+            gl->throttle_callback = wl_surface_frame(gl_wl_surface);
+            wl_proxy_set_queue((struct wl_proxy *) gl->throttle_callback,
+                                gl->wl_event_queue);
+            wl_callback_add_listener(gl->throttle_callback, &throttle_listener, gl);
+        }
         wl_surface_commit(gl_wl_surface);
         committed = TRUE;
     }
@@ -509,6 +533,44 @@ static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
     return committed;
 }
 
+static UINT get_tick_count_since(UINT start)
+{
+    UINT now = NtGetTickCount();
+    /* Handle tick count wrap around to zero. */
+    if (now < start)
+        return 0xffffffff - start + now + 1;
+    else
+        return now - start;
+}
+
+static void wayland_gl_drawable_throttle(struct wayland_gl_drawable *gl)
+{
+    static const UINT timeout = 100;
+    UINT start, elapsed;
+
+    if (gl->swap_interval == 0) goto out;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (gl->throttle_callback && elapsed < timeout &&
+           wayland_dispatch_queue(gl->wl_event_queue, timeout - elapsed) != -1)
+    {
+        elapsed = get_tick_count_since(start);
+    }
+
+out:
+    if (gl->throttle_callback)
+    {
+        wl_callback_destroy(gl->throttle_callback);
+        gl->throttle_callback = NULL;
+    }
+}
+
 static BOOL wgl_context_refresh(struct wgl_context *ctx)
 {
     BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
@@ -986,6 +1048,8 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
         struct wayland_gl_buffer *gl_buffer;
         struct gbm_bo *bo;
 
+        wayland_gl_drawable_throttle(draw_gl);
+
         p_eglSwapBuffers(egl_display, draw_gl->surface);
 
         bo = gbm_surface_lock_front_buffer(draw_gl->gbm_surface);
@@ -1017,6 +1081,59 @@ out:
     return TRUE;
 }
 
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static int wayland_wglGetSwapIntervalEXT(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+    int swap_interval;
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        /* This can't happen because a current WGL context is required to get
+         * here. Likely the application is buggy.
+         */
+        WARN("No GL drawable found, returning swap interval 0\n");
+        return 0;
+    }
+
+    swap_interval = gl->swap_interval;
+    wayland_gl_drawable_release(gl);
+
+    return swap_interval;
+}
+
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static BOOL wayland_wglSwapIntervalEXT(int interval)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+
+    TRACE("(%d)\n", interval);
+
+    if (interval < 0)
+    {
+        RtlSetLastWin32Error(ERROR_INVALID_DATA);
+        return FALSE;
+    }
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
+        return FALSE;
+    }
+
+    gl->swap_interval = interval;
+
+    wayland_gl_drawable_release(gl);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1087,6 +1204,10 @@ static void init_extensions(void)
     if (has_extension(egl_exts, "EGL_KHR_create_context"))
         has_khr_create_context = TRUE;
 
+    register_extension("WGL_EXT_swap_control");
+    egl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
+    egl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
-- 
2.39.0.rc2

From 738a2ab4efabea961b500a2e2371d2eaaa811f08 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:31:10 +0300
Subject: [PATCH 121/202] winewayland.drv: Refresh the context on glFlush and
 glFinish.

Ensure that changes to the backing Wayland surface will be applied
properly.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 17168fc457a..862b1d9db2e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -131,6 +131,9 @@ DECL_FUNCPTR(eglQueryString);
 DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
+static void (*p_glFinish)(void);
+static void (*p_glFlush)(void);
+
 static inline BOOL is_onscreen_pixel_format(int format)
 {
     return format > 0 && format <= nb_onscreen_formats;
@@ -1081,6 +1084,26 @@ out:
     return TRUE;
 }
 
+static void wayland_glFinish(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFinish();
+}
+
+static void wayland_glFlush(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFlush();
+}
+
 /***********************************************************************
  *		wayland_wglGetSwapIntervalEXT
  */
@@ -1489,6 +1512,14 @@ static void init_extensions(void)
     LOAD_FUNCPTR(glVertexBindingDivisor);
     LOAD_FUNCPTR(glWaitSync);
 #undef LOAD_FUNCPTR
+
+    /* Redirect some standard OpenGL functions. */
+
+#define REDIRECT(func) \
+    do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glFinish);
+    REDIRECT(glFlush);
+#undef REDIRECT
 }
 
 static BOOL init_pixel_formats(void)
-- 
2.39.0.rc2

From 7282b8cd262667ccc54cbafd6c95a27e61c20518 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 18:38:22 +0300
Subject: [PATCH 122/202] winewayland.drv: Advertise WGL_EXT_framebuffer_sRGB.

If our EGL version supports GL colorspaces, advertise WGL_EXT_framebuffer_sRGB
and create EGL window surfaces with an sRGB colorspace.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 38 ++++++++++++++++++++++++++++++-----
 1 file changed, 33 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 862b1d9db2e..252488c7bec 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -106,6 +106,7 @@ static char wgl_extensions[4096];
 static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
 static BOOL has_khr_create_context;
+static BOOL has_gl_colorspace;
 
 static struct wayland_mutex gl_object_mutex =
 {
@@ -365,10 +366,31 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
     if (!gl->gbm_surface)
         ERR("Failed to create GBM surface\n");
 
-    gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
-                                           (EGLNativeWindowType) gl->gbm_surface, NULL);
+    /* First try to create a surface with an SRGB colorspace, if supported. */
+    if (has_gl_colorspace)
+    {
+        EGLint attribs[] = { EGL_GL_COLORSPACE, EGL_GL_COLORSPACE_SRGB, EGL_NONE };
+        gl->surface = p_eglCreateWindowSurface(egl_display,
+                                               pixel_formats[gl->format - 1].config,
+                                               (EGLNativeWindowType) gl->gbm_surface,
+                                               attribs);
+        if (!gl->surface)
+        {
+            TRACE("Failed to create EGL surface with SRGB colorspace, "
+                  "trying with default colorspace\n");
+        }
+    }
+
+    /* Try to create a surface with the default colorspace. */
     if (!gl->surface)
-        ERR("Failed to create EGL surface\n");
+    {
+        gl->surface = p_eglCreateWindowSurface(egl_display,
+                                               pixel_formats[gl->format - 1].config,
+                                               (EGLNativeWindowType) gl->gbm_surface,
+                                               NULL);
+        if (!gl->surface)
+            ERR("Failed to create EGL surface\n");
+    }
 
     if (gl->surface)
     {
@@ -1198,7 +1220,7 @@ static BOOL has_extension(const char *list, const char *ext)
     return FALSE;
 }
 
-static void init_extensions(void)
+static void init_extensions(int major, int minor)
 {
     void *ptr;
     const char *egl_exts = p_eglQueryString(egl_display, EGL_EXTENSIONS);
@@ -1231,6 +1253,12 @@ static void init_extensions(void)
     egl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
     egl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
 
+    if ((major == 1 && minor >= 5) || has_extension(egl_exts, "EGL_KHR_gl_colorspace"))
+    {
+        register_extension("WGL_EXT_framebuffer_sRGB");
+        has_gl_colorspace = TRUE;
+    }
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -1661,7 +1689,7 @@ static BOOL egl_init(void)
 
     if (!init_pixel_formats()) return FALSE;
 
-    init_extensions();
+    init_extensions(egl_version[0], egl_version[1]);
     retval = 1;
     return TRUE;
 }
-- 
2.39.0.rc2

From e24a4e74ca673cb69818d6d25baa5b5cee9adaf7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 11:23:00 +0300
Subject: [PATCH 123/202] winewayland.drv: Update GL drawable on surface
 changes.

When the Wayland surface for a window changes, also update
any associated GL drawable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 24 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  6 ++++++
 dlls/winewayland.drv/window.c     |  7 ++++++-
 3 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 252488c7bec..a6523e1bfc3 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1742,6 +1742,26 @@ struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
     return &egl_funcs;
 }
 
+/***********************************************************************
+ *		wayland_update_gl_drawable_surface
+ */
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface)
+{
+    struct wayland_gl_drawable *gl;
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+
+        gl->wayland_surface = wayland_surface;
+        if (gl->wayland_surface)
+            wayland_surface_create_or_ref_glvk(gl->wayland_surface);
+
+        wayland_gl_drawable_release(gl);
+    }
+}
+
 #else /* No GL */
 
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
@@ -1750,4 +1770,8 @@ struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
     return NULL;
 }
 
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface)
+{
+}
+
 #endif
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c72fef11851..40b3b2e2ee8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -583,6 +583,12 @@ struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, i
                                                size_t count_modifiers, uint64_t *modifiers,
                                                BOOL format_is_scanoutable) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          OpenGL support
+ */
+
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Registry helpers
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index a42d4dafcc5..8b4dc5c40d0 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -557,7 +557,10 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
             wl_list_for_each(child, &data->wayland_surface->child_list, parent_link)
             {
                 struct wayland_win_data *child_data;
-                if ((child_data = wayland_win_data_get(child->hwnd)))
+                /* Don't handle glvk subsurfaces here, they are updated specially
+                 * below. */
+                if (child != data->wayland_surface->glvk &&
+                    (child_data = wayland_win_data_get(child->hwnd)))
                 {
                     child_data->wayland_surface_needs_update = TRUE;
                     wayland_win_data_release(child_data);
@@ -569,6 +572,8 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         }
 
         data->wayland_surface = surface;
+
+        wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
     }
 }
 
-- 
2.39.0.rc2

From 8a7b724fd658bb6f14478538392193580bceea8e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 11:24:36 +0300
Subject: [PATCH 124/202] winewayland.drv: Destroy GL drawable on window
 destruction.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 6 +++++-
 dlls/winewayland.drv/waylanddrv.h | 1 +
 dlls/winewayland.drv/window.c     | 1 +
 3 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index a6523e1bfc3..7b16fb69354 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -208,7 +208,7 @@ static void wayland_gl_drawable_clear_buffers(struct wayland_gl_drawable *gl)
         wayland_gl_buffer_destroy(gl_buffer);
 }
 
-static void wayland_destroy_gl_drawable(HWND hwnd)
+void wayland_destroy_gl_drawable(HWND hwnd)
 {
     struct wayland_gl_drawable *gl;
 
@@ -1774,4 +1774,8 @@ void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayla
 {
 }
 
+void wayland_destroy_gl_drawable(HWND hwnd)
+{
+}
+
 #endif
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 40b3b2e2ee8..266aac1702f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -588,6 +588,7 @@ struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, i
  */
 
 void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_destroy_gl_drawable(HWND hwnd) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 8b4dc5c40d0..e9fe298643c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -997,6 +997,7 @@ void WAYLAND_DestroyWindow(HWND hwnd)
     TRACE("%p\n", hwnd);
 
     if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_destroy_gl_drawable(hwnd);
     wayland_win_data_destroy(data);
 }
 
-- 
2.39.0.rc2

From d88e588f7b726cdc96e3bc14f7e1849c007d9b4a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:06:08 +0300
Subject: [PATCH 125/202] winewayland.drv: Support front buffer rendering in
 window_surface.

Implement a front buffer for window_surface, which, when enabled, is
used as a background image on which window surface contents are drawn
over.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h     |   7 ++
 dlls/winewayland.drv/window.c         |  39 +++++++++
 dlls/winewayland.drv/window_surface.c | 118 +++++++++++++++++++++++++-
 3 files changed, 160 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 266aac1702f..564d296be7e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -68,6 +68,7 @@ enum wayland_window_message
     WM_WAYLAND_CONFIGURE,
     WM_WAYLAND_STATE_UPDATE,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+    WM_WAYLAND_WINDOW_SURFACE_FLUSH,
 };
 
 enum wayland_surface_role
@@ -549,6 +550,9 @@ void wayland_window_surface_set_window_region(struct window_surface *window_surf
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
                                            COLORREF color_key, BYTE alpha,
                                            BOOL src_alpha) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height)) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -589,6 +593,9 @@ struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, i
 
 void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 void wayland_destroy_gl_drawable(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height)) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e9fe298643c..861e97350c7 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1676,6 +1676,14 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
         handle_wm_wayland_surface_output_change(hwnd, wp);
         break;
+    case WM_WAYLAND_WINDOW_SURFACE_FLUSH:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data && data->window_surface)
+                wayland_window_surface_flush(data->window_surface);
+            wayland_win_data_release(data);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
@@ -1705,3 +1713,34 @@ err:
     ERR("Failed to get client rect for hwnd %p", hwnd);
     SetRectEmpty(client_rect);
 }
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+
+        /* Trigger a redraw to apply any front buffer changes. */
+        NtUserPostMessage(hwnd, WM_WAYLAND_WINDOW_SURFACE_FLUSH, 0, 0);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index f254da973d5..47a26523593 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -55,6 +55,8 @@ struct wayland_window_surface
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
     BITMAPINFO            info;
 };
 
@@ -283,6 +285,31 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         }
     }
 
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * We also damage the whole surface if we just cleared the front buffer
+     * (i.e., front_bits == NULL and front_bits_dirty == TRUE). */
+    if (wws->front_bits || wws->front_bits_dirty)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                NtGdiSetRectRgn(surface_damage_region,
+                                wws->header.rect.left, wws->header.rect.top,
+                                wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = NtGdiCreateRectRgn(wws->header.rect.left,
+                                                           wws->header.rect.top,
+                                                           wws->header.rect.right,
+                                                           wws->header.rect.bottom);
+            }
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -313,6 +340,30 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     }
     buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
+    /* Copy the whole front buffer to wayland SHM buffer. */
+    if (wws->front_bits)
+    {
+        int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+        int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+        int stride = width * 4;
+        unsigned char *src = wws->front_bits;
+        unsigned char *dst = buffer->map_data;
+        int src_stride = wws->info.bmiHeader.biWidth * 4;
+        int dst_stride = buffer->width * 4;
+        int i;
+
+        TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+        /* Front buffer lines are stored bottom to top, so we need to flip
+         * when copying to our buffer. */
+        for (i = 0; i < height; i++)
+        {
+            memcpy(dst + (height - i - 1) * dst_stride,
+                   src + i * src_stride,
+                   stride);
+        }
+    }
+
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
 
@@ -404,7 +455,11 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     free(buffer_damage);
 
 done:
-    if (!wws->last_flush_failed) reset_bounds(&wws->bounds);
+    if (!wws->last_flush_failed)
+    {
+        reset_bounds(&wws->bounds);
+        wws->front_bits_dirty = FALSE;
+    }
     if (surface_damage_region) NtGdiDeleteObjectApp(surface_damage_region);
     window_surface->funcs->unlock(window_surface);
 }
@@ -425,6 +480,7 @@ static void wayland_window_surface_destroy(struct window_surface *window_surface
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     free(wws->bits);
+    free(wws->front_bits);
     free(wws);
 }
 
@@ -471,6 +527,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->color_key    = color_key;
     wws->alpha        = alpha;
     wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -519,10 +577,16 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
                     get_preferred_format(wws));
     }
-    else if (!wws->wayland_surface && wws->wayland_buffer_queue)
+    else if (!wws->wayland_surface)
     {
-        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
-        wws->wayland_buffer_queue = NULL;
+        if (wws->wayland_buffer_queue)
+        {
+            wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+            wws->wayland_buffer_queue = NULL;
+        }
+        free(wws->front_bits);
+        wws->front_bits = NULL;
+        wws->front_bits_dirty = FALSE;
     }
 
     window_surface->funcs->unlock(window_surface);
@@ -554,3 +618,49 @@ void wayland_window_surface_update_layered(struct window_surface *window_surface
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd=%p front_bits=%p read_pixels=%p size=%dx%d\n",
+          wws->hwnd, wws->front_bits, read_pixels,
+          (int)wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        if (wws->front_bits)
+        {
+            free(wws->front_bits);
+            wws->front_bits = NULL;
+            /* When the front_bits are first invalidated, we mark them as dirty
+             * to force the next window_surface flush. */
+            wws->front_bits_dirty = TRUE;
+        }
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = malloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.39.0.rc2

From 489375516e94e1076af452dfcea00be97230bdf1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:34:39 +0300
Subject: [PATCH 126/202] winewayland.drv: Support front buffer rendering in
 OpenGL.

Mesa Wayland EGL, and Wayland in general, doesn't natively support front
buffer rendering. Emulate it by manually updating the window_surface
front buffer pixels, which are then used as a background during
window_surface flushes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 86 +++++++++++++++++++++++++++++++++++
 1 file changed, 86 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 7b16fb69354..13e0ee10fba 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -95,6 +95,7 @@ struct wgl_context
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
+    BOOL       is_draw_buffer_front;
 };
 
 static void *egl_handle;
@@ -134,6 +135,7 @@ DECL_FUNCPTR(eglSwapBuffers);
 
 static void (*p_glFinish)(void);
 static void (*p_glFlush)(void);
+static void (*p_glDrawBuffer)(GLenum);
 
 static inline BOOL is_onscreen_pixel_format(int format)
 {
@@ -768,6 +770,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
     ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
+    ctx->is_draw_buffer_front = FALSE;
 
     /* The gl_object_mutex, which is locked when we get the gl_drawable,
      * also guards access to gl_contexts, so it's safe to add the entry here. */
@@ -1106,6 +1109,76 @@ out:
     return TRUE;
 }
 
+static void wayland_glDrawBuffer(GLenum mode)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    GLint draw_fbo = -1;
+
+    if (!ctx) return;
+
+    egl_funcs.gl.p_glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &draw_fbo);
+
+    TRACE("hwnd %p egl_context %p mode 0x%x draw_fbo %d\n",
+          ctx->draw_hwnd, ctx->context, mode, draw_fbo);
+
+    if (draw_fbo == 0)
+    {
+        BOOL is_draw_buffer_front = (mode == GL_FRONT || mode == GL_FRONT_LEFT);
+        /* Disable the window front buffer if we have one and it's not needed
+         * any longer.  */
+        if (ctx->is_draw_buffer_front && !is_draw_buffer_front)
+            wayland_update_front_buffer(ctx->draw_hwnd, NULL);
+        ctx->is_draw_buffer_front = is_draw_buffer_front;
+    }
+
+    p_glDrawBuffer(mode);
+}
+
+static void read_front_buffer_pixels(void *pixels_out, int width, int height)
+{
+    GLenum prev_read_buffer;
+    GLint prev_read_framebuffer;
+    GLint prev_row_length;
+    GLint prev_image_height;
+    GLint prev_skip_rows;
+    GLint prev_skip_pixels;
+    GLint prev_skip_images;
+    GLint prev_alignment;
+
+    /* Store state we might change */
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_BUFFER, (GLint*)&prev_read_buffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &prev_read_framebuffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ROW_LENGTH, &prev_row_length);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_IMAGE_HEIGHT, &prev_image_height);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_ROWS, &prev_skip_rows);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_PIXELS, &prev_skip_pixels);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_IMAGES, &prev_skip_images);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ALIGNMENT, &prev_alignment);
+
+    /* Set state we need for reading the pixels */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+    egl_funcs.gl.p_glReadBuffer(GL_FRONT);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    egl_funcs.gl.p_glReadPixels(0, 0, width, height, GL_BGRA,  GL_UNSIGNED_BYTE,
+                                pixels_out);
+
+    /* Restore prev state */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, prev_read_framebuffer);
+    egl_funcs.gl.p_glReadBuffer(prev_read_buffer);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, prev_row_length);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, prev_image_height);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, prev_skip_rows);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, prev_skip_pixels);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, prev_skip_images);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, prev_alignment);
+}
+
 static void wayland_glFinish(void)
 {
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
@@ -1114,6 +1187,12 @@ static void wayland_glFinish(void)
     TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
     wgl_context_refresh(ctx);
     p_glFinish();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
 }
 
 static void wayland_glFlush(void)
@@ -1124,6 +1203,12 @@ static void wayland_glFlush(void)
     TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
     wgl_context_refresh(ctx);
     p_glFlush();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
 }
 
 /***********************************************************************
@@ -1545,6 +1630,7 @@ static void init_extensions(int major, int minor)
 
 #define REDIRECT(func) \
     do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glDrawBuffer);
     REDIRECT(glFinish);
     REDIRECT(glFlush);
 #undef REDIRECT
-- 
2.39.0.rc2

From 265969575e5e66af3195c7e22bbdcc26537e2720 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 8 Apr 2022 11:03:16 +0300
Subject: [PATCH 127/202] winewayland.drv: Expose
 wayland_shm_buffer_create_from_native.

This will be need for the upcoming cross-process rendering functionality.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_shm.c | 9 +++++++--
 dlls/winewayland.drv/waylanddrv.h  | 2 ++
 2 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
index 254f574f33b..ef2b65abb2d 100644
--- a/dlls/winewayland.drv/wayland_shm.c
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -35,8 +35,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
-static struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
-                                                                        struct wayland_native_buffer *native)
+/**********************************************************************
+ *          wayland_shm_buffer_create_from_native
+ *
+ * Creates a wayland SHM buffer from the specified native buffer.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                 struct wayland_native_buffer *native)
 {
     struct wayland_shm_buffer *shm_buffer;
     struct wl_shm_pool *pool;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 564d296be7e..696fad56bb6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -490,6 +490,8 @@ void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC
  *          Wayland SHM buffer
  */
 
+struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                 struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
                                                      int width, int height,
                                                      enum wl_shm_format format) DECLSPEC_HIDDEN;
-- 
2.39.0.rc2

From 4c190121703e459d1cbad7b97b72ec4017f62bab Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 29 Mar 2022 11:41:50 +0300
Subject: [PATCH 128/202] winewayland.drv: Add infrastructure for cross-process
 rendering.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   1 +
 dlls/winewayland.drv/wayland_remote.c | 709 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  21 +
 dlls/winewayland.drv/window.c         |   9 +
 4 files changed, 740 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_remote.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 26409d11f88..74b746642ae 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -23,6 +23,7 @@ C_SRCS = \
 	wayland_native_buffer.c \
 	wayland_output.c \
 	wayland_pointer.c \
+	wayland_remote.c \
 	wayland_shm.c \
 	wayland_shmfd.c \
 	wayland_surface.c \
diff --git a/dlls/winewayland.drv/wayland_remote.c b/dlls/winewayland.drv/wayland_remote.c
new file mode 100644
index 00000000000..8a3eef1e080
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_remote.c
@@ -0,0 +1,709 @@
+/*
+ * Wayland remote (cross-process) rendering
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <inttypes.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+enum wayland_remote_surface_message
+{
+    WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS,
+};
+
+struct wayland_remote_surface
+{
+    struct wl_list link;
+    int ref;
+    enum wayland_remote_surface_type type;
+    struct wl_event_queue *wl_event_queue;
+    struct wayland_surface *wayland_surface;
+    struct wl_list buffer_list;
+    struct wl_list throttle_list;
+};
+
+struct wayland_remote_buffer
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wl_buffer *wl_buffer;
+    HANDLE released_event;
+};
+
+struct wayland_remote_throttle
+{
+    struct wl_list link;
+    struct wl_callback *wl_callback;
+    HANDLE event;
+};
+
+struct params_type
+{
+    enum wayland_remote_surface_type type;
+};
+
+struct params_buffer
+{
+    struct params_type params_type;
+    enum wayland_remote_buffer_type buffer_type;
+    int plane_count;
+    HANDLE fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    int width, height;
+    int format;
+    uint64_t modifier;
+    HANDLE released_event;
+    HANDLE throttle_event;
+};
+
+static struct wayland_mutex wayland_remote_surface_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": wayland_remote_surface_mutex"
+};
+
+static struct wl_list wayland_remote_surfaces = { &wayland_remote_surfaces, &wayland_remote_surfaces };
+static struct wl_list wayland_remote_buffers = { &wayland_remote_buffers, &wayland_remote_buffers};
+
+static void wayland_remote_buffer_destroy(struct wayland_remote_buffer *remote_buffer)
+{
+    TRACE("remote_buffer=%p released_event=%p\n",
+          remote_buffer, remote_buffer->released_event);
+    if (remote_buffer->released_event)
+    {
+        wl_list_remove(&remote_buffer->link);
+        NtSetEvent(remote_buffer->released_event, NULL);
+        NtClose(remote_buffer->released_event);
+    }
+    else
+    {
+        /* Detached remote buffers are stored in the global
+         * wayland_remote_buffers list, and require locking. */
+        wayland_mutex_lock(&wayland_remote_surface_mutex);
+        wl_list_remove(&remote_buffer->link);
+        wayland_mutex_unlock(&wayland_remote_surface_mutex);
+    }
+    wl_buffer_destroy(remote_buffer->wl_buffer);
+    free(remote_buffer);
+}
+
+static void remote_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_remote_buffer *remote_buffer =
+        (struct wayland_remote_buffer *) data;
+
+    TRACE("released_event=%p\n", remote_buffer->released_event);
+    wayland_remote_buffer_destroy(remote_buffer);
+}
+
+static const struct wl_buffer_listener remote_buffer_listener = {
+    remote_buffer_release
+};
+
+static struct wayland_remote_buffer *wayland_remote_buffer_create(struct wayland_remote_surface *remote,
+                                                                  struct wl_buffer *wl_buffer,
+                                                                  HANDLE released_event)
+{
+    struct wayland_remote_buffer *remote_buffer = calloc(1, sizeof(*remote_buffer));
+    if (!remote_buffer)
+    {
+        ERR("Failed to allocate memory for remote buffer\n");
+        return NULL;
+    }
+
+    remote_buffer->hwnd = remote->wayland_surface->hwnd;
+    remote_buffer->wl_buffer = wl_buffer;
+
+    if (released_event)
+    {
+        /* Non-detached buffers are dispatched from remote surface event queue
+         * so that we can dispatch events on demand (see
+         * WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS). */
+        wl_proxy_set_queue((struct wl_proxy *) remote_buffer->wl_buffer,
+                           remote->wl_event_queue);
+        wl_list_insert(&remote->buffer_list, &remote_buffer->link);
+        remote_buffer->released_event = released_event;
+    }
+    else
+    {
+        /* Detached buffers are dispatched from the default thread queue and
+         * are stored in wayland_remote_buffers, in order to not be destroyed
+         * along with their remote surface. We don't need to explicitly lock to
+         * insert to this list at this point, since having a remote surface
+         * implies a locked wayland_remote_surface_mutex. */
+        wl_list_insert(&wayland_remote_buffers, &remote_buffer->link);
+    }
+
+    wl_buffer_add_listener(remote_buffer->wl_buffer,
+                           &remote_buffer_listener, remote_buffer);
+
+    return remote_buffer;
+}
+
+static void wayland_remote_throttle_destroy(struct wayland_remote_throttle *remote_throttle)
+{
+    wl_list_remove(&remote_throttle->link);
+
+    wl_callback_destroy(remote_throttle->wl_callback);
+
+    if (remote_throttle->event)
+    {
+        NtSetEvent(remote_throttle->event, NULL);
+        NtClose(remote_throttle->event);
+    }
+
+    free(remote_throttle);
+}
+
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_remote_throttle *remote_throttle = data;
+
+    TRACE("throttle_event=%p\n", remote_throttle->event);
+
+    wayland_remote_throttle_destroy(remote_throttle);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
+static struct wayland_remote_throttle *wayland_remote_throttle_create(struct wayland_remote_surface *remote,
+                                                                      struct wl_callback *wl_callback,
+                                                                      HANDLE throttle_event)
+{
+    struct wayland_remote_throttle *remote_throttle = calloc(1, sizeof(*remote_throttle));
+    if (!remote_throttle)
+    {
+        ERR("Failed to allocate memory for remote throttle\n");
+        return NULL;
+    }
+    remote_throttle->wl_callback = wl_callback;
+    remote_throttle->event = throttle_event;
+
+    wl_proxy_set_queue((struct wl_proxy *) remote_throttle->wl_callback,
+                        remote->wl_event_queue);
+    wl_callback_add_listener(remote_throttle->wl_callback, &throttle_listener,
+                             remote_throttle);
+    wl_list_insert(&remote->throttle_list, &remote_throttle->link);
+
+    return remote_throttle;
+}
+
+static void wayland_remote_surface_destroy(struct wayland_remote_surface *remote)
+{
+    struct wayland_remote_buffer *buffer, *buffer_tmp;
+    struct wayland_remote_throttle *throttle, *throttle_tmp;
+
+    TRACE("remote=%p\n", remote);
+
+    wl_list_remove(&remote->link);
+
+    wl_list_for_each_safe(buffer, buffer_tmp, &remote->buffer_list, link)
+        wayland_remote_buffer_destroy(buffer);
+
+    wl_list_for_each_safe(throttle, throttle_tmp, &remote->throttle_list, link)
+        wayland_remote_throttle_destroy(throttle);
+
+    if (remote->wl_event_queue) wl_event_queue_destroy(remote->wl_event_queue);
+    if (remote->wayland_surface)
+    {
+        switch (remote->type)
+        {
+        case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+            wayland_surface_unref(remote->wayland_surface);
+            break;
+        case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+            wayland_surface_unref_glvk(remote->wayland_surface);
+            break;
+        default:
+            ERR("Invalid surface type %d\n", remote->type);
+            break;
+        }
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+    free(remote);
+}
+
+static struct wayland_remote_surface *wayland_remote_surface_create(struct wayland_surface *wayland_surface,
+                                                                    enum wayland_remote_surface_type type)
+{
+    struct wayland_remote_surface *remote;
+
+    remote = calloc(1, sizeof(*remote));
+    if (!remote)
+    {
+        ERR("Failed to allocate memory for remote surface hwnd=%p type=%d\n",
+            wayland_surface->hwnd, type);
+        goto err;
+    }
+
+    remote->ref = 1;
+    remote->type = type;
+    wl_list_init(&remote->buffer_list);
+    wl_list_init(&remote->throttle_list);
+
+    remote->wl_event_queue = wl_display_create_queue(wayland_surface->wayland->wl_display);
+    if (!remote->wl_event_queue)
+    {
+        ERR("Failed to create wl_event_queue for remote surface hwnd=%p type=%d\n",
+            wayland_surface->hwnd, type);
+        goto err;
+    }
+
+    switch (type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wayland_surface_ref(wayland_surface);
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        if (!wayland_surface_create_or_ref_glvk(wayland_surface))
+        {
+            ERR("Failed to create GL/VK for remote surface hwnd=%p type=%d\n",
+                wayland_surface->hwnd, type);
+            goto err;
+        }
+        break;
+    default:
+        ERR("Invalid surface type %d\n", type);
+        goto err;
+    }
+
+    remote->wayland_surface = wayland_surface;
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    wl_list_insert(&wayland_remote_surfaces, &remote->link);
+
+    return remote;
+
+err:
+    if (remote) wayland_remote_surface_destroy(remote);
+    return NULL;
+}
+
+static struct wayland_remote_surface *wayland_remote_surface_get(HWND hwnd,
+                                                                 enum wayland_remote_surface_type type)
+{
+    struct wayland_remote_surface *remote;
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    wl_list_for_each(remote, &wayland_remote_surfaces, link)
+    {
+        if (remote->wayland_surface->hwnd == hwnd && remote->type == type)
+            return remote;
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+
+    return NULL;
+}
+
+static void wayland_remote_surface_release(struct wayland_remote_surface *remote)
+{
+    if (remote) wayland_mutex_unlock(&wayland_remote_surface_mutex);
+}
+
+static void wayland_remote_surface_ref(struct wayland_remote_surface *remote)
+{
+    remote->ref++;
+}
+
+static void wayland_remote_surface_unref(struct wayland_remote_surface *remote)
+{
+    remote->ref--;
+    if (remote->ref == 0)
+        wayland_remote_surface_destroy(remote);
+    else
+        wayland_remote_surface_release(remote);
+}
+
+static BOOL wayland_remote_surface_commit(struct wayland_remote_surface *remote,
+                                          struct wayland_remote_buffer *remote_buffer,
+                                          HANDLE throttle_event)
+{
+    BOOL ret = FALSE;
+    struct wl_surface *wl_surface;
+
+    wayland_mutex_lock(&remote->wayland_surface->mutex);
+
+    TRACE("remote=%p wayland_surface=%p glvk=%p drawing_allowed=%d\n",
+          remote, remote->wayland_surface, remote->wayland_surface->glvk,
+          remote->wayland_surface->drawing_allowed);
+
+    switch (remote->type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wl_surface = remote->wayland_surface->wl_surface;
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        wl_surface = remote->wayland_surface->glvk ?
+                     remote->wayland_surface->glvk->wl_surface : NULL;
+        break;
+    default:
+        ERR("Invalid surface type %d\n", remote->type);
+        goto out;
+    }
+
+    if (remote->wayland_surface->drawing_allowed && wl_surface)
+    {
+        wayland_surface_ensure_mapped(remote->wayland_surface);
+        wl_surface_attach(wl_surface, remote_buffer->wl_buffer, 0, 0);
+        wl_surface_damage_buffer(wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (throttle_event &&
+            !wayland_remote_throttle_create(remote, wl_surface_frame(wl_surface),
+                                            throttle_event))
+        {
+            NtSetEvent(throttle_event, NULL);
+            NtClose(throttle_event);
+        }
+        wl_surface_commit(wl_surface);
+        ret = TRUE;
+    }
+
+out:
+    wayland_mutex_unlock(&remote->wayland_surface->mutex);
+
+    return ret;
+}
+
+static void *map_shm_from_handle(HANDLE params, size_t size)
+{
+    int shm_fd = -1;
+    void *data = NULL;
+
+    if (wine_server_handle_to_fd(params, FILE_READ_DATA, &shm_fd, NULL) != STATUS_SUCCESS)
+    {
+        ERR("Failed to get SHM fd from Wine handle.\n");
+        goto out;
+    }
+
+    data = mmap(NULL, size, PROT_READ, MAP_SHARED, shm_fd, 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("Failed to map SHM fd.\n");
+        data = NULL;
+    }
+
+out:
+    if (shm_fd >= 0) close(shm_fd);
+
+    return data;
+}
+
+static void wayland_remote_surface_update_wayland_surface(struct wayland_remote_surface *remote,
+                                                          struct wayland_surface *wayland_surface)
+{
+    switch (remote->type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wayland_surface_ref(wayland_surface);
+        wayland_surface_unref(remote->wayland_surface);
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        if (!wayland_surface_create_or_ref_glvk(wayland_surface)) return;
+        wayland_surface_unref_glvk(remote->wayland_surface);
+        break;
+    default:
+        ERR("Invalid surface type %d\n", remote->type);
+        return;
+    }
+    remote->wayland_surface = wayland_surface;
+}
+
+static void wayland_remote_surface_handle_create(struct wayland_remote_surface *remote,
+                                                 struct wayland_surface *wayland_surface,
+                                                 struct params_type *params)
+{
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (remote)
+    {
+        wayland_remote_surface_ref(remote);
+        return;
+    }
+
+    remote = wayland_remote_surface_create(wayland_surface, params->type);
+    if (!remote)
+    {
+        ERR("Failed to create remote surface for hwnd=%p type=%d\n",
+            wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_remote_surface_release(remote);
+}
+
+static void wayland_remote_surface_handle_destroy(struct wayland_remote_surface *remote,
+                                                  struct wayland_surface *wayland_surface,
+                                                  struct params_type *params)
+{
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_remote_surface_unref(remote);
+}
+
+static BOOL _wayland_native_buffer_init_params(struct wayland_native_buffer *native,
+                                               struct params_buffer *params)
+{
+    int i;
+
+    native->plane_count = params->plane_count;
+    native->width = params->width;
+    native->height = params->height;
+    native->format = params->format;
+    native->modifier = params->modifier;
+
+    for (i = 0; i < native->plane_count; i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        NTSTATUS ret;
+
+        ret = wine_server_handle_to_fd(params->fds[i], GENERIC_READ | SYNCHRONIZE,
+                                       &native->fds[i], NULL);
+        if (ret != STATUS_SUCCESS)
+        {
+            ERR("Failed to get fd from handle ret=%#x\n", (int)ret);
+            goto err;
+        }
+
+        native->strides[i] = params->strides[i];
+        native->offsets[i] = params->offsets[i];
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
+static void wayland_remote_surface_handle_commit(struct wayland_remote_surface *remote,
+                                                 struct wayland_surface *wayland_surface,
+                                                 struct params_buffer *params)
+{
+    struct wayland_native_buffer native;
+    struct wl_buffer *wl_buffer = NULL;
+    struct wayland_remote_buffer *remote_buffer = NULL;
+
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->params_type.type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->params_type.type);
+        goto err;
+    }
+
+    if (!_wayland_native_buffer_init_params(&native, params))
+    {
+        ERR("Failed to initialize native buffer\n");
+        goto err;
+    }
+
+    switch (params->buffer_type)
+    {
+    case WAYLAND_REMOTE_BUFFER_TYPE_SHM:
+        {
+            struct wayland_shm_buffer *shm_buffer =
+                wayland_shm_buffer_create_from_native(remote->wayland_surface->wayland,
+                                                      &native);
+            if (shm_buffer)
+                wl_buffer = wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+        }
+        break;
+    case WAYLAND_REMOTE_BUFFER_TYPE_DMABUF:
+        {
+            struct wayland_dmabuf_buffer *dmabuf_buffer =
+                wayland_dmabuf_buffer_create_from_native(remote->wayland_surface->wayland,
+                                                         &native);
+            if (dmabuf_buffer)
+                wl_buffer = wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(dmabuf_buffer);
+        }
+        break;
+    default:
+        ERR("Invalid buffer type %d\n", params->buffer_type);
+        goto err;
+    }
+
+    wayland_native_buffer_deinit(&native);
+    if (!wl_buffer)
+    {
+        ERR("Failed to create wl_buffer\n");
+        goto err;
+    }
+
+    remote_buffer = wayland_remote_buffer_create(remote, wl_buffer, params->released_event);
+
+    if (!wayland_remote_surface_commit(remote, remote_buffer, params->throttle_event))
+        goto err;
+
+    return;
+
+err:
+    if (params->released_event)
+    {
+        NtSetEvent(params->released_event, NULL);
+        NtClose(params->released_event);
+    }
+    if (params->throttle_event)
+    {
+        NtSetEvent(params->throttle_event, NULL);
+        NtClose(params->throttle_event);
+    }
+    if (remote_buffer) wayland_remote_buffer_destroy(remote_buffer);
+}
+
+static void wayland_remote_surface_handle_dispatch_events(struct wayland_remote_surface *remote,
+                                                          struct wayland_surface *wayland_surface,
+                                                          struct params_type *params)
+{
+
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_dispatch_queue(remote->wl_event_queue, 0);
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_handle_message
+ *
+ *  Handles a message sent to our remote surface infrastructure.
+ */
+void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
+                                           WPARAM message, LPARAM params_long)
+{
+    HANDLE params_handle = LongToHandle(params_long);
+    void *params = NULL;
+    size_t params_size;
+    struct wayland_remote_surface *remote = NULL;
+
+    TRACE("message=%ld params=%p\n", (long)message, params_handle);
+
+    switch (message)
+    {
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE:
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY:
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS:
+        params_size = sizeof(struct params_type);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT:
+        params_size = sizeof(struct params_buffer);
+        break;
+    default:
+        goto out;
+    }
+
+    params = map_shm_from_handle(params_handle, sizeof(struct params_type));
+    if (!params) goto out;
+
+    remote = wayland_remote_surface_get(wayland_surface->hwnd,
+                                        ((struct params_type *) params)->type);
+    if (remote)
+        wayland_remote_surface_update_wayland_surface(remote, wayland_surface);
+
+    switch (message)
+    {
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE:
+        wayland_remote_surface_handle_create(remote, wayland_surface, params);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY:
+        wayland_remote_surface_handle_destroy(remote, wayland_surface, params);
+        remote = NULL;
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT:
+        wayland_remote_surface_handle_commit(remote, wayland_surface, params);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS:
+        wayland_remote_surface_handle_dispatch_events(remote, wayland_surface, params);
+        break;
+    }
+
+out:
+    if (remote) wayland_remote_surface_release(remote);
+    if (params) munmap(params, params_size);
+    if (params_handle) NtClose(params_handle);
+}
+
+/**********************************************************************
+ *          wayland_destroy_remote_surfaces
+ *
+ *  Destroys remote surfaces targeting a window.
+ */
+void wayland_destroy_remote_surfaces(HWND hwnd)
+{
+    struct wayland_remote_surface *remote, *tmp;
+    struct wayland_remote_buffer *remote_buf, *tmp_buf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    /* Destroy any detached remote buffers for the window. */
+    wl_list_for_each_safe(remote_buf, tmp_buf, &wayland_remote_buffers, link)
+    {
+        if (remote_buf->hwnd == hwnd)
+            wayland_remote_buffer_destroy(remote_buf);
+    }
+    /* Destroy any remote surfaces for the window. */
+    wl_list_for_each_safe(remote, tmp, &wayland_remote_surfaces, link)
+    {
+        if (remote->wayland_surface->hwnd == hwnd)
+        {
+            /* wayland_remote_surface_destroy() unlocks the surface mutex,
+             * since it assumes that that the passed remote was acquired
+             * with wayland_remote_surface_get(). Lock the mutex manually
+             * to maintain the proper lock count. */
+            wayland_mutex_lock(&wayland_remote_surface_mutex);
+            wayland_remote_surface_destroy(remote);
+        }
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 696fad56bb6..0c380470cc2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -69,6 +69,7 @@ enum wayland_window_message
     WM_WAYLAND_STATE_UPDATE,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
     WM_WAYLAND_WINDOW_SURFACE_FLUSH,
+    WM_WAYLAND_REMOTE_SURFACE,
 };
 
 enum wayland_surface_role
@@ -86,6 +87,18 @@ enum wayland_configure_flags
     WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
 };
 
+enum wayland_remote_surface_type
+{
+    WAYLAND_REMOTE_SURFACE_TYPE_NORMAL,
+    WAYLAND_REMOTE_SURFACE_TYPE_GLVK,
+};
+
+enum wayland_remote_buffer_type
+{
+    WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+    WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -616,6 +629,14 @@ DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
 xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state) DECLSPEC_HIDDEN;
 int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland remote (cross-process) rendering
+ */
+
+void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
+                                           WPARAM message, LPARAM params) DECLSPEC_HIDDEN;
+void wayland_destroy_remote_surfaces(HWND hwnd) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 861e97350c7..16c3c54424d 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -998,6 +998,7 @@ void WAYLAND_DestroyWindow(HWND hwnd)
 
     if (!(data = wayland_win_data_get(hwnd))) return;
     wayland_destroy_gl_drawable(hwnd);
+    wayland_destroy_remote_surfaces(hwnd);
     wayland_win_data_destroy(data);
 }
 
@@ -1684,6 +1685,14 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_win_data_release(data);
         }
         break;
+    case WM_WAYLAND_REMOTE_SURFACE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+                wayland_remote_surface_handle_message(wayland_surface, wp, lp);
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From abcd1b58ff30176a5bee47d9bd9fa5fee9a38019 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 30 Mar 2022 13:55:02 +0300
Subject: [PATCH 129/202] winewayland.drv: Introduce proxies for interacting
 with remote surfaces.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_remote.c | 281 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  19 ++
 2 files changed, 300 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_remote.c b/dlls/winewayland.drv/wayland_remote.c
index 8a3eef1e080..306368efc9b 100644
--- a/dlls/winewayland.drv/wayland_remote.c
+++ b/dlls/winewayland.drv/wayland_remote.c
@@ -92,6 +92,12 @@ struct params_buffer
     HANDLE throttle_event;
 };
 
+struct wayland_remote_surface_proxy
+{
+    HWND hwnd;
+    enum wayland_remote_surface_type type;
+};
+
 static struct wayland_mutex wayland_remote_surface_mutex =
 {
     PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": wayland_remote_surface_mutex"
@@ -707,3 +713,278 @@ void wayland_destroy_remote_surfaces(HWND hwnd)
     }
     wayland_mutex_unlock(&wayland_remote_surface_mutex);
 }
+
+static HANDLE remote_handle_from_local(HANDLE local_handle, HWND remote_hwnd)
+{
+    HANDLE remote_handle = 0;
+    HANDLE remote_process = 0;
+    DWORD remote_process_id;
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(OBJECT_ATTRIBUTES) };
+    CLIENT_ID cid;
+
+    if (!NtUserGetWindowThread(remote_hwnd, &remote_process_id)) return 0;
+
+    cid.UniqueProcess = ULongToHandle(remote_process_id);
+
+    if (NtOpenProcess(&remote_process, PROCESS_DUP_HANDLE, &attr, &cid) ||
+        !remote_process)
+    {
+        ERR("Failed to open process with id %#x\n", (UINT)remote_process_id);
+        return 0;
+    }
+
+    if (NtDuplicateObject(GetCurrentProcess(), local_handle, remote_process,
+                          &remote_handle, 0, 0, DUPLICATE_SAME_ACCESS))
+    {
+        ERR("Failed to duplicate handle in remote process\n");
+    }
+
+    NtClose(remote_process);
+
+    return remote_handle;
+}
+
+static HANDLE remote_handle_from_fd(int fd, HWND remote_hwnd)
+{
+    HANDLE local_fd_handle = 0;
+    HANDLE remote_fd_handle = 0;
+
+    if (wine_server_fd_to_handle(fd, GENERIC_READ | SYNCHRONIZE, 0,
+                                 &local_fd_handle) != STATUS_SUCCESS)
+    {
+        ERR("Failed to get handle from fd\n");
+        goto out;
+    }
+
+    remote_fd_handle = remote_handle_from_local(local_fd_handle, remote_hwnd);
+
+out:
+    if (local_fd_handle) NtClose(local_fd_handle);
+
+    return remote_fd_handle;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_create
+ *
+ *  Creates a proxy for rendering to a remote surface.
+ */
+struct wayland_remote_surface_proxy *wayland_remote_surface_proxy_create(HWND hwnd,
+                                                                         enum wayland_remote_surface_type type)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+    struct wayland_remote_surface_proxy *proxy;
+
+    TRACE("hwnd=%p type=%d\n", hwnd, type);
+
+    proxy = calloc(1, sizeof(*proxy));
+    if (!proxy) return NULL;
+
+    proxy->hwnd = hwnd;
+    proxy->type = type;
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-create-glvk", sizeof(*params));
+    if (params_fd < 0) goto err;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto err;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, hwnd);
+    if (!remote_params_handle) goto err;
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE,
+                      HandleToLong(remote_params_handle));
+
+    close(params_fd);
+
+    TRACE("hwnd=%p type=%d => proxy=%p\n", hwnd, type, proxy);
+
+    return proxy;
+
+err:
+    if (params_fd >= 0) close(params_fd);
+    if (proxy) free(proxy);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_destroy
+ *
+ *  Destroys a proxy to a remote surface.
+ */
+void wayland_remote_surface_proxy_destroy(struct wayland_remote_surface_proxy *proxy)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+
+    TRACE("proxy=%p hwnd=%p type=%d\n", proxy, proxy->hwnd, proxy->type);
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-destroy", sizeof(*params));
+    if (params_fd < 0) goto out;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto out;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto out;
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY,
+                      HandleToLong(remote_params_handle));
+
+out:
+    if (params_fd >= 0) close(params_fd);
+    free(proxy);
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_commit
+ *
+ *  Commits a dmabuf to the surface targeted by the remote surface proxy.
+ *
+ *  Returns a handle to an Event that will be set when the committed buffer
+ *  can be reused.
+ */
+BOOL wayland_remote_surface_proxy_commit(struct wayland_remote_surface_proxy *proxy,
+                                         struct wayland_native_buffer *native,
+                                         enum wayland_remote_buffer_type buffer_type,
+                                         enum wayland_remote_buffer_commit commit,
+                                         HANDLE *buffer_released_event_out,
+                                         HANDLE *throttle_event_out)
+{
+    int params_fd;
+    struct params_buffer *params = MAP_FAILED;
+    HANDLE local_released_event = 0;
+    HANDLE local_throttle_event = 0;
+    HANDLE remote_params_handle;
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(attr), .Attributes = OBJ_OPENIF };
+    int i;
+
+    TRACE("proxy=%p hwnd=%p type=%d commit=%d\n",
+          proxy, proxy->hwnd, proxy->type, commit);
+
+    /* Create buffer params */
+    params_fd = wayland_shmfd_create("wayland-remote-surface-commit", sizeof(*params));
+    if (params_fd < 0) goto err;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto err;
+
+    /* Populate buffer params */
+    params->params_type.type = proxy->type;
+    params->buffer_type = buffer_type;
+    params->plane_count = native->plane_count;
+    for (i = 0; i < native->plane_count; i++)
+    {
+        params->fds[i] = remote_handle_from_fd(native->fds[i], proxy->hwnd);
+        if (!params->fds[i]) goto err;
+        params->strides[i] = native->strides[i];
+        params->offsets[i] = native->offsets[i];
+    }
+    params->width = native->width;
+    params->height = native->height;
+    params->format = native->format;
+    params->modifier = native->modifier;
+
+    if (commit != WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED)
+    {
+        if (NtCreateEvent(&local_released_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE) ||
+            !local_released_event)
+        {
+            goto err;
+        }
+        params->released_event = remote_handle_from_local(local_released_event, proxy->hwnd);
+        if (!params->released_event) goto err;
+    }
+
+    if (commit == WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED)
+    {
+        if (NtCreateEvent(&local_throttle_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE) ||
+            !local_throttle_event)
+        {
+            goto err;
+        }
+        params->throttle_event = remote_handle_from_local(local_throttle_event, proxy->hwnd);
+        if (!params->throttle_event) goto err;
+    }
+
+    /* Create remote handle for params and post message. */
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto err;
+
+    TRACE("proxy=%p hwnd=%p type=%d commit=%d => local_released=%p "
+          "remote_released=%p, local_throttle=%p remote_throttle=%p\n",
+          proxy, proxy->hwnd, proxy->type, commit, local_released_event,
+          params->released_event, local_throttle_event, params->throttle_event);
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT,
+                      HandleToLong(remote_params_handle));
+
+    munmap(params, sizeof(*params));
+    close(params_fd);
+
+    if (buffer_released_event_out)
+        *buffer_released_event_out = local_released_event;
+    else if (local_released_event)
+        NtClose(local_released_event);
+
+    if (throttle_event_out)
+        *throttle_event_out = local_throttle_event;
+    else if (local_throttle_event)
+        NtClose(local_throttle_event);
+
+    return TRUE;
+
+err:
+    if (params != MAP_FAILED)
+    {
+        for (i = 0; i < native->plane_count; i++)
+            if (params->fds[i]) NtClose(params->fds[i]);
+        if (params->released_event) NtClose(params->released_event);
+        munmap(params, sizeof(*params));
+    }
+    if (params_fd >= 0) close(params_fd);
+    if (local_released_event) NtClose(local_released_event);
+    if (local_throttle_event) NtClose(local_throttle_event);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_dispatch_events
+ *
+ *  Dispatches events (e.g., buffer release events) from the remote surface.
+ */
+BOOL wayland_remote_surface_proxy_dispatch_events(struct wayland_remote_surface_proxy *proxy)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+    BOOL ret = FALSE;
+
+    TRACE("proxy=%p hwnd=%p type=%d\n", proxy, proxy->hwnd, proxy->type);
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-dispatch", sizeof(*params));
+    if (params_fd < 0) goto out;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto out;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto out;
+
+    ret = NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                            WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS,
+                            HandleToLong(remote_params_handle));
+
+out:
+    if (params_fd >= 0) close(params_fd);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0c380470cc2..94d33df6e67 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -99,6 +99,13 @@ enum wayland_remote_buffer_type
     WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
 };
 
+enum wayland_remote_buffer_commit
+{
+    WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL,
+    WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED,
+    WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -356,6 +363,8 @@ struct wayland_buffer_queue
 
 typedef void (*wayland_callback_func)(void *data);
 
+struct wayland_remote_surface_proxy;
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -636,6 +645,16 @@ int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int ut
 void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
                                            WPARAM message, LPARAM params) DECLSPEC_HIDDEN;
 void wayland_destroy_remote_surfaces(HWND hwnd) DECLSPEC_HIDDEN;
+struct wayland_remote_surface_proxy *wayland_remote_surface_proxy_create(HWND hwnd,
+                                                                         enum wayland_remote_surface_type type) DECLSPEC_HIDDEN;
+void wayland_remote_surface_proxy_destroy(struct wayland_remote_surface_proxy *proxy) DECLSPEC_HIDDEN;
+BOOL wayland_remote_surface_proxy_commit(struct wayland_remote_surface_proxy *proxy,
+                                         struct wayland_native_buffer *native,
+                                         enum wayland_remote_buffer_type buffer_type,
+                                         enum wayland_remote_buffer_commit commit,
+                                         HANDLE *buffer_released_event,
+                                         HANDLE *throttle_event) DECLSPEC_HIDDEN;
+BOOL wayland_remote_surface_proxy_dispatch_events(struct wayland_remote_surface_proxy *proxy) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Misc. helpers
-- 
2.39.0.rc2

From 8cec194399d3502a771aa6857ffd646d0aeeea68 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 30 Mar 2022 19:16:34 +0300
Subject: [PATCH 130/202] winewayland.drv: Support cross-process OpenGL
 rendering.

Use the cross-process remote surface infrastructure to present buffers
to HWNDs belonging in different processes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 162 ++++++++++++++++++++++++++++++++--
 1 file changed, 153 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 13e0ee10fba..4603ec76b97 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -73,6 +73,8 @@ struct wayland_gl_drawable
     struct wl_list  buffer_list;
     int             swap_interval;
     struct wl_callback *throttle_callback;
+    struct wayland_remote_surface_proxy *remote_surface_proxy;
+    HANDLE remote_throttle_event;
 };
 
 struct wayland_gl_buffer
@@ -81,7 +83,9 @@ struct wayland_gl_buffer
     struct wayland_gl_drawable *gl;
     struct gbm_bo *gbm_bo;
     struct gbm_surface *gbm_surface;
+    struct wayland_native_buffer native_buffer;
     struct wayland_dmabuf_buffer *dmabuf_buffer;
+    HANDLE remote_buffer_released_event;
 };
 
 struct wgl_context
@@ -160,6 +164,12 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
         wayland_surface_for_hwnd_unlock(wayland_surface);
         if (!ref_gl) goto err;
     }
+    else
+    {
+        gl->remote_surface_proxy =
+            wayland_remote_surface_proxy_create(hwnd, WAYLAND_REMOTE_SURFACE_TYPE_GLVK);
+        if (!gl->remote_surface_proxy) goto err;
+    }
 
     gl->hwnd = hwnd;
     gl->format = format;
@@ -181,6 +191,8 @@ err:
     {
         if (gl->wayland_surface) wayland_surface_unref_glvk(gl->wayland_surface);
         if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
+        if (gl->remote_surface_proxy)
+            wayland_remote_surface_proxy_destroy(gl->remote_surface_proxy);
         free(gl);
     }
     return NULL;
@@ -190,8 +202,11 @@ static void wayland_gl_buffer_destroy(struct wayland_gl_buffer *gl_buffer)
 {
     TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
     wl_list_remove(&gl_buffer->link);
+    wayland_native_buffer_deinit(&gl_buffer->native_buffer);
     if (gl_buffer->dmabuf_buffer)
         wayland_dmabuf_buffer_destroy(gl_buffer->dmabuf_buffer);
+    if (gl_buffer->remote_buffer_released_event)
+        NtClose(gl_buffer->remote_buffer_released_event);
     gbm_bo_set_user_data(gl_buffer->gbm_bo, NULL, NULL);
     free(gl_buffer);
 }
@@ -199,6 +214,11 @@ static void wayland_gl_buffer_destroy(struct wayland_gl_buffer *gl_buffer)
 static void wayland_gl_buffer_release(struct wayland_gl_buffer *gl_buffer)
 {
     TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    if (gl_buffer->remote_buffer_released_event)
+    {
+        NtClose(gl_buffer->remote_buffer_released_event);
+        gl_buffer->remote_buffer_released_event = 0;
+    }
     gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
 }
 
@@ -225,6 +245,9 @@ void wayland_destroy_gl_drawable(HWND hwnd)
         if (gl->wayland_surface)
             wayland_surface_unref_glvk(gl->wayland_surface);
         if (gl->throttle_callback) wl_callback_destroy(gl->throttle_callback);
+        if (gl->remote_surface_proxy)
+            wayland_remote_surface_proxy_destroy(gl->remote_surface_proxy);
+        if (gl->remote_throttle_event) NtClose(gl->remote_throttle_event);
         if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
         free(gl);
         break;
@@ -483,22 +506,20 @@ static struct wayland_gl_buffer *wayland_gl_drawable_track_buffer(struct wayland
 
     if (!gl_buffer)
     {
-        struct wayland_native_buffer native_buffer;
-
         gl_buffer = calloc(1, sizeof(*gl_buffer));
         if (!gl_buffer) goto err;
 
         wl_list_init(&gl_buffer->link);
         gl_buffer->gbm_bo = bo;
         gl_buffer->gbm_surface = gl->gbm_surface;
-        if (!wayland_native_buffer_init_gbm(&native_buffer, bo)) goto err;
+        if (!wayland_native_buffer_init_gbm(&gl_buffer->native_buffer, bo)) goto err;
 
         if (gl->wayland_surface)
         {
             gl_buffer->dmabuf_buffer =
                 wayland_dmabuf_buffer_create_from_native(gl->wayland_surface->wayland,
-                                                         &native_buffer);
-            wayland_native_buffer_deinit(&native_buffer);
+                                                         &gl_buffer->native_buffer);
+            wayland_native_buffer_deinit(&gl_buffer->native_buffer);
             if (!gl_buffer->dmabuf_buffer) goto err;
 
             wl_proxy_set_queue((struct wl_proxy *) gl_buffer->dmabuf_buffer->wl_buffer,
@@ -536,7 +557,26 @@ static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
 {
     BOOL committed = FALSE;
 
-    if (!gl->wayland_surface) return FALSE;
+    if (gl->remote_surface_proxy)
+    {
+        enum wayland_remote_buffer_commit buffer_commit =
+            gl->swap_interval > 0 ? WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED :
+                                    WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL;
+
+        if (!wayland_remote_surface_proxy_commit(gl->remote_surface_proxy,
+                                                 &gl_buffer->native_buffer,
+                                                 WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+                                                 buffer_commit,
+                                                 &gl_buffer->remote_buffer_released_event,
+                                                 &gl->remote_throttle_event))
+        {
+            gl_buffer->remote_buffer_released_event = 0;
+            gl->remote_throttle_event = 0;
+            return FALSE;
+        }
+
+        return TRUE;
+    }
 
     wayland_mutex_lock(&gl->wayland_surface->mutex);
     if (gl->wayland_surface->drawing_allowed)
@@ -560,6 +600,40 @@ static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
     return committed;
 }
 
+/* Convert timeout in ms to the timeout format used by ntdll which is:
+ * 100ns units, negative for monotonic time. */
+static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
+{
+    if (timeout_ms == -1) return NULL;
+    time->QuadPart = (ULONGLONG)timeout_ms * -10000;
+    return time;
+}
+
+static DWORD wayland_gl_drawable_wait_remote_throttle(struct wayland_gl_drawable *gl,
+                                                      int timeout_ms)
+{
+    UINT ret;
+    LARGE_INTEGER timeout;
+
+    TRACE("gl->remote_throttle_event=%p timeout_ms=%d\n", gl->remote_throttle_event, timeout_ms);
+    if (!wayland_remote_surface_proxy_dispatch_events(gl->remote_surface_proxy))
+    {
+        ERR("Failed to dispatch remote events\n");
+        return WAIT_FAILED;
+    }
+
+    ret = NtWaitForSingleObject(gl->remote_throttle_event, FALSE,
+                                get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_OBJECT_0)
+    {
+        NtClose(gl->remote_throttle_event);
+        gl->remote_throttle_event = 0;
+    }
+
+    TRACE("=> ret=%d\n", ret);
+    return ret;
+}
+
 static UINT get_tick_count_since(UINT start)
 {
     UINT now = NtGetTickCount();
@@ -580,22 +654,69 @@ static void wayland_gl_drawable_throttle(struct wayland_gl_drawable *gl)
     start = NtGetTickCount();
     elapsed = 0;
 
+    TRACE("throttle_callback=%p throttle_event=%p\n",
+          gl->throttle_callback, gl->remote_throttle_event);
+
     /* The compositor may at any time decide to not display the surface on
      * screen and thus not send any frame events. Until we have a better way to
      * deal with this, wait for a maximum of timeout for the frame event to
      * arrive, in order to avoid blocking the GL thread indefinitely. */
-    while (gl->throttle_callback && elapsed < timeout &&
-           wayland_dispatch_queue(gl->wl_event_queue, timeout - elapsed) != -1)
+    while (elapsed < timeout &&
+           ((gl->throttle_callback &&
+             wayland_dispatch_queue(gl->wl_event_queue, timeout - elapsed) != -1) ||
+            (gl->remote_throttle_event &&
+             wayland_gl_drawable_wait_remote_throttle(gl, 10) != WAIT_FAILED)))
     {
         elapsed = get_tick_count_since(start);
     }
 
+    TRACE("throttle_callback=%p throttle_event=%p => elapsed=%u\n",
+          gl->throttle_callback, gl->remote_throttle_event,
+          elapsed);
+
 out:
     if (gl->throttle_callback)
     {
         wl_callback_destroy(gl->throttle_callback);
         gl->throttle_callback = NULL;
     }
+    if (gl->remote_throttle_event)
+    {
+        NtClose(gl->remote_throttle_event);
+        gl->remote_throttle_event = 0;
+    }
+}
+
+static DWORD wayland_gl_drawable_wait_remote(struct wayland_gl_drawable *gl,
+                                             int timeout_ms)
+{
+    struct wayland_gl_buffer *gl_buffer;
+    HANDLE handles[8];
+    struct wayland_gl_buffer *gl_buffers[8];
+    int count = 0;
+    LARGE_INTEGER timeout;
+    UINT ret;
+
+    if (!wayland_remote_surface_proxy_dispatch_events(gl->remote_surface_proxy))
+        return WAIT_FAILED;
+
+    wl_list_for_each(gl_buffer, &gl->buffer_list, link)
+    {
+        if (!gl_buffer->remote_buffer_released_event) continue;
+        handles[count] = gl_buffer->remote_buffer_released_event;
+        gl_buffers[count] = gl_buffer;
+        count++;
+    }
+
+    TRACE("count=%d handles=%p,%p,%p,%p\n",
+         count, handles[0], handles[1], handles[2], handles[3]);
+    ret = NtWaitForMultipleObjects(count, handles, TRUE, FALSE,
+                                   get_nt_timeout(&timeout, timeout_ms));
+    TRACE("count=%d => ret=%d\n", count, ret);
+    if (ret < WAIT_OBJECT_0 + count)
+        wayland_gl_buffer_release(gl_buffers[ret - WAIT_OBJECT_0]);
+
+    return ret;
 }
 
 static BOOL wgl_context_refresh(struct wgl_context *ctx)
@@ -653,7 +774,8 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     wayland_gl_drawable_release(gl);
 
     if (prev && prev != format && !allow_change) return FALSE;
-    if (NtUserSetWindowPixelFormat(hwnd, format)) return TRUE;
+    if (gl->remote_surface_proxy || NtUserSetWindowPixelFormat(hwnd, format))
+        return TRUE;
 
     wayland_destroy_gl_drawable(hwnd);
     return FALSE;
@@ -1101,6 +1223,28 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
                 continue;
             }
         }
+        else if (draw_gl->remote_surface_proxy)
+        {
+            static const DWORD wait_timeout = 100;
+            DWORD wait_start = NtGetTickCount();
+            /* If we don't get a free buffer within the specified timeout, drop
+             * one of the previous buffers to ensure we can continue and avoid
+             * potential cross-process deadlocks (e.g., the render process
+             * waiting for the window process to dispatch buffer release messages,
+             * while the window process is waiting for the render process to finish
+             * rendering). */
+            while (!gbm_surface_has_free_buffers(draw_gl->gbm_surface) &&
+                   wayland_gl_drawable_wait_remote(draw_gl, 10) != WAIT_FAILED)
+            {
+                if (get_tick_count_since(wait_start) > wait_timeout)
+                {
+                    struct wayland_gl_buffer *to_release;
+                    wl_list_for_each(to_release, &draw_gl->buffer_list, link)
+                        if (to_release != gl_buffer) break;
+                    wayland_gl_buffer_release(to_release);
+                }
+            }
+        }
     }
 
 out:
-- 
2.39.0.rc2

From 9cab1f634caed19a131070fdf30513819688f427 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 16:59:19 +0300
Subject: [PATCH 131/202] winewayland.drv: Add skeleton GDI driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/gdi.c             | 88 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 10 +++
 dlls/winewayland.drv/waylanddrv_main.c |  7 +-
 4 files changed, 105 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/gdi.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 74b746642ae..40f7ecc3e4a 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	display.c \
 	dllmain.c \
 	gbm.c \
+	gdi.c \
 	opengl.c \
 	options.c \
 	registry.c \
diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
new file mode 100644
index 00000000000..3b4e2727106
--- /dev/null
+++ b/dlls/winewayland.drv/gdi.c
@@ -0,0 +1,88 @@
+/*
+ * Wayland gdi functions
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <stdlib.h>
+
+typedef struct
+{
+    struct gdi_physdev dev;
+} WAYLAND_PDEVICE;
+
+static inline WAYLAND_PDEVICE *get_wayland_dev(PHYSDEV dev)
+{
+    return (WAYLAND_PDEVICE *)dev;
+}
+
+static WAYLAND_PDEVICE *create_wayland_physdev(void)
+{
+    WAYLAND_PDEVICE *physDev;
+
+    physDev = calloc(1, sizeof(*physDev));
+
+    return physDev;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateDC
+ */
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateCompatibleDC
+ */
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_DeleteDC
+ */
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
+{
+    WAYLAND_PDEVICE *physDev = get_wayland_dev(dev);
+
+    free(physDev);
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 94d33df6e67..71529503d50 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -53,6 +53,7 @@
 extern char *process_name DECLSPEC_HIDDEN;
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
+extern const struct user_driver_funcs waylanddrv_funcs DECLSPEC_HIDDEN;
 extern char *option_drm_device DECLSPEC_HIDDEN;
 extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
@@ -764,4 +765,13 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          GDI driver functions
+ */
+
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData) DECLSPEC_HIDDEN;
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index a6442d17b03..dde1a039086 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -114,8 +114,13 @@ static void WAYLAND_ThreadDetach(void)
     }
 }
 
-static const struct user_driver_funcs waylanddrv_funcs =
+const struct user_driver_funcs waylanddrv_funcs =
 {
+    .dc_funcs.pCreateDC = WAYLAND_CreateDC,
+    .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
+    .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
+
     .pChangeDisplaySettings = WAYLAND_ChangeDisplaySettings,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
-- 
2.39.0.rc2

From 5e8e740f891809a86c238e40797bdc08bd8806c2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 8 Apr 2022 12:46:48 +0300
Subject: [PATCH 132/202] winewayland.drv: Support limited cross-process GDI
 PutImage.

This is a fallback implementation for when the dibdrv cannot perform
this task, typically because the destination belongs to a different
process. In such a case the implementation utilizes the remote surface
infrastructure to commit content to the remote HWND.

The implementation is very limited, supporting only simple full copies,
but that's enough for some typical cross-process cases, notably software
rendered content on Chrome/CEF.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/gdi.c             | 145 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 3 files changed, 149 insertions(+)

diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
index 3b4e2727106..054ac1ce06e 100644
--- a/dlls/winewayland.drv/gdi.c
+++ b/dlls/winewayland.drv/gdi.c
@@ -25,8 +25,12 @@
 #include "config.h"
 
 #include "waylanddrv.h"
+#include "wine/debug.h"
 
 #include <stdlib.h>
+#include <sys/mman.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 typedef struct
 {
@@ -86,3 +90,144 @@ BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
     free(physDev);
     return TRUE;
 }
+
+/**********************************************************************
+ *           WAYLAND_PutImage
+ *
+ * This is a fallback implementation for when the dibdrv cannot perform
+ * this task, typically because the destination belongs to a different
+ * process. In such a case the implementation utilizes the remote surface
+ * infrastructure to commit content to the remote HWND.
+ *
+ * The implementation is very limited, supporting only simple full copies,
+ * but that's enough for some typical cross-process cases, notably software
+ * rendered content in Chrome/CEF.
+ */
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop)
+{
+    HWND hwnd;
+    struct wayland_native_buffer native;
+    struct wayland_remote_surface_proxy *remote = NULL;
+    size_t shm_size;
+    void *shm_data;
+    DWORD ret = ERROR_SUCCESS;
+
+    hwnd = NtUserWindowFromDC(dev->hdc);
+
+    TRACE("hwnd=%p rop=%#x biBitCount=%d compr=%u size=%dx%d "
+          "src=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "dst=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "clip=%p\n",
+          hwnd, (UINT)rop, info->bmiHeader.biBitCount,
+          (UINT)info->bmiHeader.biCompression,
+          (int)info->bmiHeader.biWidth, (int)info->bmiHeader.biHeight,
+          src->log_x, src->log_y, src->log_width, src->log_height,
+          src->x, src->y, src->width, src->height,
+          wine_dbgstr_rect(&src->visrect),
+          dst->log_x, dst->log_y, dst->log_width, dst->log_height,
+          dst->x, dst->y, dst->width, dst->height,
+          wine_dbgstr_rect(&dst->visrect), clip);
+
+    if (info->bmiHeader.biPlanes != 1)
+    {
+        TRACE("Multiplanar buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biBitCount != 32)
+    {
+        TRACE("Non 32-bit buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biCompression != BI_RGB)
+    {
+        TRACE("Non RGB not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biHeight > 0)
+    {
+        TRACE("Bottom-up buffers not supported\n");
+        goto update_format;
+    }
+
+    if (!bits) return ERROR_SUCCESS;  /* just querying the format */
+
+    if (!hwnd)
+    {
+        TRACE("Invalid hwnd=%p\n", hwnd);
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (clip)
+    {
+        TRACE("Clipping not supported\n");
+        return ERROR_CLIPPING_NOT_SUPPORTED;
+    }
+
+    if ((src->width != dst->width) || (src->height != dst->height))
+    {
+        TRACE("Image stretching is not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if ((src->width != info->bmiHeader.biWidth) ||
+        (src->height != -info->bmiHeader.biHeight))
+    {
+        TRACE("Partial blits are not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (rop != SRCCOPY)
+    {
+        TRACE("Raster operations other than SRCCOPY are not supported\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (!wayland_native_buffer_init_shm(&native, src->width, src->height, 
+                                        WL_SHM_FORMAT_ARGB8888))
+    {
+        TRACE("Failed to create native shm buffer %dx%d\n", src->width, src->height);
+        return ERROR_OUTOFMEMORY;
+    }
+
+    shm_size = native.strides[0] * native.height;
+    shm_data = mmap(NULL, shm_size, PROT_WRITE, MAP_SHARED, native.fds[0], 0);
+    if (shm_data == MAP_FAILED)
+    {
+        TRACE("Failed to mmap shm buffer size=%zu\n", shm_size);
+        ret = ERROR_OUTOFMEMORY;
+        goto out;
+    }
+    memcpy(shm_data, bits->ptr, shm_size);
+    munmap(shm_data, shm_size);
+
+    remote = wayland_remote_surface_proxy_create(hwnd,
+                                                 WAYLAND_REMOTE_SURFACE_TYPE_NORMAL);
+    if (!remote)
+    {
+        TRACE("Failed to create remote surface proxy\n");
+        ret =  ERROR_OUTOFMEMORY;
+        goto out;
+    }
+
+    wayland_remote_surface_proxy_commit(remote, &native,
+                                        WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+                                        WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+                                        NULL, NULL);
+
+    wayland_remote_surface_proxy_destroy(remote);
+
+out:
+    wayland_native_buffer_deinit(&native);
+    return ret;
+
+update_format:
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    if (info->bmiHeader.biHeight > 0) info->bmiHeader.biHeight = -info->bmiHeader.biHeight;
+    return ERROR_BAD_FORMAT;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 71529503d50..2acbc8e4d20 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -773,5 +773,8 @@ BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
                             LPCWSTR output, const DEVMODEW* initData) DECLSPEC_HIDDEN;
 BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
 BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index dde1a039086..424d59a7e19 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -119,6 +119,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .dc_funcs.pCreateDC = WAYLAND_CreateDC,
     .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
     .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.pPutImage = WAYLAND_PutImage,
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
     .pChangeDisplaySettings = WAYLAND_ChangeDisplaySettings,
-- 
2.39.0.rc2

From 4d7b7a05de7efbbba5a7bd7ea5c7b7926dfac591 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 15:40:50 +0300
Subject: [PATCH 133/202] winewayland.drv: Support setting Wayland pointer to
 relative event mode.

Introduce a function to set the Wayland pointer event mode, emitting
either absolute coordinates (the default) or relative coordinates (i.e.,
just differences from previous positions). Relative mode requires and
uses the zwp_relative_pointer_manager_v1 Wayland extension.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/wayland.c         |  8 +++
 dlls/winewayland.drv/wayland_pointer.c | 80 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  4 ++
 4 files changed, 93 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 40f7ecc3e4a..ce396b07cd2 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -37,6 +37,7 @@ WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index cc73c70fbc8..1dec82db084 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -278,6 +278,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
+    {
+        wayland->zwp_relative_pointer_manager_v1 =
+            wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -473,6 +478,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->dmabuf.zwp_linux_dmabuf_v1)
         wayland_dmabuf_deinit(&wayland->dmabuf);
 
+    if (wayland->zwp_relative_pointer_manager_v1)
+        zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
+
     if (wayland->wp_viewporter)
         wp_viewporter_destroy(wayland->wp_viewporter);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index b7bebd8e8b0..40bfc12b8f8 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -85,6 +85,12 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
 static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
                                   uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
 {
+    struct wayland *wayland = data;
+
+    /* Don't handle absolute motion events if we are in relative mode. */
+    if (wayland->pointer.zwp_relative_pointer_v1)
+        return;
+
     pointer_handle_motion_internal(data, pointer, time, sx, sy);
 }
 
@@ -239,6 +245,47 @@ static const struct wl_pointer_listener pointer_listener = {
     pointer_handle_axis_discrete,
 };
 
+static void relative_pointer_handle_motion(void *data,
+                                           struct zwp_relative_pointer_v1 *rpointer,
+                                           uint32_t utime_hi,
+                                           uint32_t utime_lo,
+                                           wl_fixed_t dx,
+                                           wl_fixed_t dy,
+                                           wl_fixed_t dx_unaccel,
+                                           wl_fixed_t dy_unaccel)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    int wine_dx, wine_dy;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_wine(wayland->pointer.focused_surface,
+                                   wl_fixed_to_int(dx), wl_fixed_to_int(dy),
+                                   &wine_dx, &wine_dy);
+
+    TRACE("surface=%p hwnd=%p wayland_dxdy=%d,%d wine_dxdy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_int(dx), wl_fixed_to_int(dy), wine_dx, wine_dy);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = wine_dx;
+    input.mi.dy          = wine_dy;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
+    relative_pointer_handle_motion,
+};
+
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer)
 {
@@ -247,10 +294,14 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
     wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
     wayland->pointer.cursor_wl_surface =
         wl_compositor_create_surface(wayland->wl_compositor);
+    pointer->zwp_relative_pointer_v1 = NULL;
 }
 
 void wayland_pointer_deinit(struct wayland_pointer *pointer)
 {
+    if (pointer->zwp_relative_pointer_v1)
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+
     if (pointer->wl_pointer)
         wl_pointer_destroy(pointer->wl_pointer);
 
@@ -262,3 +313,32 @@ void wayland_pointer_deinit(struct wayland_pointer *pointer)
 
     memset(pointer, 0, sizeof(*pointer));
 }
+
+/**********************************************************************
+ *          wayland_pointer_set_relative
+ *
+ * Set whether the pointer emits relative (if able) or absolute motion events.
+ * The default is to emit absolute motion events.
+ */
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative)
+{
+    if (!pointer->wayland->zwp_relative_pointer_manager_v1)
+        return;
+
+    if (!pointer->zwp_relative_pointer_v1 && relative)
+    {
+        pointer->zwp_relative_pointer_v1 =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+                pointer->wayland->zwp_relative_pointer_manager_v1,
+                pointer->wl_pointer);
+
+        zwp_relative_pointer_v1_add_listener(pointer->zwp_relative_pointer_v1,
+                                             &zwp_relative_pointer_v1_listener,
+                                             pointer->wayland);
+    }
+    else if (pointer->zwp_relative_pointer_v1 && !relative)
+    {
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+        pointer->zwp_relative_pointer_v1 = NULL;
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 2acbc8e4d20..f00029b6286 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -34,6 +34,7 @@
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -157,6 +158,7 @@ struct wayland_pointer
     uint32_t enter_serial;
     struct wayland_cursor *cursor;
     HCURSOR hcursor;
+    struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
 };
 
 struct wayland_dmabuf_format_info
@@ -228,6 +230,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -595,6 +598,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard) DECLSPEC_
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
 void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative) DECLSPEC_HIDDEN;
 void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
 void wayland_cursor_theme_init(struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
-- 
2.39.0.rc2

From 276ff523a94bd89caeb90f1f98e845087526ba4b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:06:48 +0300
Subject: [PATCH 134/202] winewayland.drv: Introduce function to get Wayland
 surface coords from screen.

Introduce the wayland_surface_coords_from_screen function to transform
Wine screen coords to Wayland surfaces coords. This will be useful in an
upcoming commit which will need to set the pointer position hint when
leaving relative pointer event mode.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 28 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5743aff164e..10027cdd0f9 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -991,6 +991,34 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
           *screen_x, *screen_y);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_from_screen
+ *
+ * Converts the Windows screen coordinates to surface-local coordinates.
+ */
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y)
+{
+    int wine_x, wine_y;
+    RECT window_rect = {0};
+
+    /* Screen to window */
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    wine_x = screen_x - window_rect.left;
+    wine_y = screen_y - window_rect.top;
+
+    /* Window to wayland surface */
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y,
+                                     wayland_x, wayland_y);
+
+    TRACE("hwnd=%p screen=%d,%d rect=%s => wayland=%.2f,%.2f\n",
+          surface->hwnd, screen_x, screen_y, wine_dbgstr_rect(&window_rect),
+          *wayland_x, *wayland_y);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f00029b6286..1a437736aeb 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -480,6 +480,9 @@ void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface) DECLSPEC_H
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
                                       double wayland_x, double wayland_y,
                                       int *screen_x, int *screen_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
-- 
2.39.0.rc2

From 30041d4b42c0f0d066792e6203844ce2f8ad85be Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:18:20 +0300
Subject: [PATCH 135/202] winewayland.drv: Implement ClipCursor.

Implement cursor clipping by using the zwp_pointer_constraints_v1
and the zwp_relative_pointer_v1 Wayland protocols.

We use a set of heurestics to decide when to constrain the Wayland
pointer and which form of constraint to use for the focused surface:

1. If the cursor isn't visible (i.e., we don't have a current cursor)
   and we have an effective clip for a window, lock the pointer in
   the corresponding Wayland surface and emit relative events (typical
   case for first/third-person perspective 3D games).

2. If the cursor is visible, and we have an effective clip for a window,
   confine the cursor to the clipped area within the corresponding
   Wayland surface and emit absolute events.

3. Otherwise, don't constrain.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland.c         |  11 ++
 dlls/winewayland.drv/wayland_cursor.c  |  21 +++
 dlls/winewayland.drv/wayland_pointer.c |   4 +
 dlls/winewayland.drv/wayland_surface.c | 193 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  15 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  23 +++
 8 files changed, 269 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index ce396b07cd2..56c5988d214 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -37,6 +37,7 @@ WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1dec82db084..edcaf44fb26 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -32,6 +32,7 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <poll.h>
 #include <stdlib.h>
 #include <sys/timerfd.h>
@@ -278,6 +279,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
+    {
+        wayland->zwp_pointer_constraints_v1 =
+            wl_registry_bind(registry, id, &zwp_pointer_constraints_v1_interface, 1);
+    }
     else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
     {
         wayland->zwp_relative_pointer_manager_v1 =
@@ -378,6 +384,8 @@ BOOL wayland_init(struct wayland *wayland)
     wl_list_init(&wayland->callback_list);
     wl_list_init(&wayland->surface_list);
 
+    SetRect(&wayland->cursor_clip, INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
 
@@ -478,6 +486,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->dmabuf.zwp_linux_dmabuf_v1)
         wayland_dmabuf_deinit(&wayland->dmabuf);
 
+    if (wayland->zwp_pointer_constraints_v1)
+        zwp_pointer_constraints_v1_destroy(wayland->zwp_pointer_constraints_v1);
+
     if (wayland->zwp_relative_pointer_manager_v1)
         zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
 
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index d9bcf77b269..fd6f7e70f05 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -679,5 +679,26 @@ void WAYLAND_SetCursor(HCURSOR hcursor)
     {
         send_message(cursor_hwnd, WM_WAYLAND_SET_CURSOR, GetCurrentThreadId(),
                      (LPARAM)hcursor);
+        /* Cursor visibility affects pointer confinement mode. */
+        send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+                     WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP, 0);
     }
 }
+
+/***********************************************************************
+ *           WAYLAND_ClipCursor
+ */
+BOOL WAYLAND_ClipCursor(const RECT *clip)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+    WPARAM constrain;
+
+    if (!cursor_hwnd) return TRUE;
+
+    constrain = clip ? WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP :
+                       WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP;
+
+    send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE, constrain, 0);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 40bfc12b8f8..255d2d4af5f 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -101,6 +101,7 @@ static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
     struct wayland *wayland = data;
     struct wayland_surface *wayland_surface =
         surface ? wl_surface_get_user_data(surface) : NULL;
+    RECT clip;
 
     /* Since pointer events can arrive in multiple threads, ensure we only
      * handle them in the thread that owns the surface, to avoid passing
@@ -119,6 +120,9 @@ static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
          * visibility state (i.e., ShowCursor()), which is difficult to access
          * otherwise, is taken into account. */
         NtUserSetCursor(NtUserGetCursor());
+        /* Reapply the current cursor clip, so that the wayland pointer
+         * constraint is updated for the newly entered window. */
+        NtUserClipCursor(NtUserGetClipCursor(&clip) ? &clip : NULL);
         /* Handle the enter as a motion, to account for cases where the
          * window first appears beneath the pointer and won't get a separate
          * motion event. */
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 10027cdd0f9..fbae08ea9a5 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -701,6 +701,18 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (surface->surface_feedback)
         wayland_dmabuf_surface_feedback_destroy(surface->surface_feedback);
 
+    if (surface->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
@@ -1248,6 +1260,187 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_update_pointer_constraint
+ *
+ * Update the pointer constraint on the surface. Constraint mode depends
+ * on the current Windows cursor clip and cursor visibility.
+ */
+void wayland_surface_update_pointer_constraint(struct wayland_surface *surface)
+{
+    struct wayland *wayland = surface->wayland;
+    struct wayland_surface *glvk;
+    struct wl_region *region;
+    RECT vscreen_rect;
+    RECT clip_rect = wayland->cursor_clip;
+    RECT client_rect = {0};
+    RECT client_clip_rect;
+    BOOL needs_lock = FALSE;
+    BOOL needs_confine = FALSE;
+
+    if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
+        return;
+
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+    NtUserMapWindowPoints(surface->hwnd, NULL, (POINT*)&client_rect, 2);
+
+    vscreen_rect.top = NtUserGetSystemMetrics(SM_YVIRTUALSCREEN);
+    vscreen_rect.left = NtUserGetSystemMetrics(SM_XVIRTUALSCREEN);
+    vscreen_rect.bottom = vscreen_rect.top + NtUserGetSystemMetrics(SM_CYVIRTUALSCREEN);
+    vscreen_rect.right = vscreen_rect.left + NtUserGetSystemMetrics(SM_CXVIRTUALSCREEN);
+
+    /* Get the effective clip area, if any. */
+    intersect_rect(&clip_rect, &clip_rect, &vscreen_rect);
+    intersect_rect(&client_clip_rect, &clip_rect, &client_rect);
+
+    TRACE("wayland=%p surface=%p (glvk=%p) clip_rect=%s client_clip_rect=%s "
+          "client=%s vscreen=%s hcursor=%p\n",
+          wayland, surface, surface->glvk,
+          wine_dbgstr_rect(&clip_rect), wine_dbgstr_rect(&client_clip_rect),
+          wine_dbgstr_rect(&client_rect),
+          wine_dbgstr_rect(&vscreen_rect),
+          wayland->pointer.hcursor);
+
+    /* If there is a GL/VK subsurface use that to apply the pointer constaints,
+     * since it's covering the whole client area. */
+    glvk = wayland_surface_ref_glvk(surface);
+    if (glvk)
+    {
+        if (surface->zwp_locked_pointer_v1)
+        {
+            zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+            surface->zwp_locked_pointer_v1 = NULL;
+        }
+        if (surface->zwp_confined_pointer_v1)
+        {
+            zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+            surface->zwp_confined_pointer_v1 = NULL;
+        }
+        surface = glvk;
+    }
+
+    /* Only handle confinement or locking if the cursor is actually clipped
+     * within this window, or if the clip rect is empty. */
+    if (!IsRectEmpty(&client_clip_rect) || IsRectEmpty(&clip_rect))
+    {
+        /* Having an effective clip (i.e., clip is not the whole screen) is
+         * a prerequisite for locking the pointer. If the client rect is
+         * the whole screen (i.e., application is fullscreen), we can't
+         * differentiate between an explicit fullscreen clip and no effective
+         * clip (i.e., clip is the whole screen), so also consider locking. */
+        BOOL lock_clip = !EqualRect(&clip_rect, &vscreen_rect) ||
+                         EqualRect(&client_rect, &vscreen_rect);
+        /* To consider confining the pointer we must have an effective clip,
+         * otherwise confininement makes no difference. */
+        BOOL confine_clip = !EqualRect(&clip_rect, &vscreen_rect);
+
+        /* If the cursor is not visible, and we have an lock clip, lock.
+         * Otherwise if the cursor is visible check if we need to confine. */
+        if (!wayland->pointer.hcursor && lock_clip)
+        {
+            needs_lock = TRUE;
+        }
+        else if (wayland->pointer.hcursor && confine_clip)
+        {
+            needs_confine = TRUE;
+        }
+    }
+
+    /* Destroy unneeded interface objects. */
+    if (!needs_lock && surface->zwp_locked_pointer_v1)
+    {
+        POINT cursor_pos;
+
+        if (NtUserGetCursorPos(&cursor_pos) && PtInRect(&client_rect, cursor_pos))
+        {
+            double wayland_x, wayland_y;
+            wayland_surface_coords_from_screen(surface,
+                                               cursor_pos.x, cursor_pos.y,
+                                               &wayland_x, &wayland_y);
+
+            zwp_locked_pointer_v1_set_cursor_position_hint(
+                    surface->zwp_locked_pointer_v1,
+                    wl_fixed_from_double(wayland_x),
+                    wl_fixed_from_double(wayland_y));
+
+            wl_surface_commit(surface->wl_surface);
+        }
+
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (!needs_confine && surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    /* Set up (or update) pointer confinement or lock. */
+    if (needs_confine)
+    {
+        double top, left, bottom, right;
+
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.left,
+                                           client_clip_rect.top,
+                                           &left, &top);
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.right,
+                                           client_clip_rect.bottom,
+                                           &right, &bottom);
+
+        region = wl_compositor_create_region(wayland->wl_compositor);
+        wl_region_add(region, round(left), round(top),
+                      round(right - left), round(bottom - top));
+
+        if (!surface->zwp_confined_pointer_v1)
+        {
+            surface->zwp_confined_pointer_v1 =
+                zwp_pointer_constraints_v1_confine_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    region,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_confined_pointer_v1_set_region(surface->zwp_confined_pointer_v1,
+                                               region);
+        }
+
+        wl_region_destroy(region);
+    }
+    else if (needs_lock)
+    {
+        if (!surface->zwp_locked_pointer_v1)
+        {
+            surface->zwp_locked_pointer_v1 =
+                zwp_pointer_constraints_v1_lock_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    NULL,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_locked_pointer_v1_set_region(surface->zwp_locked_pointer_v1,
+                                             NULL);
+        }
+    }
+
+    if (wayland->pointer.focused_surface == surface)
+        wayland_pointer_set_relative(&wayland->pointer, needs_lock);
+
+    if (needs_confine || needs_lock)
+        wl_surface_commit(surface->wl_surface);
+
+    if (glvk)
+        wayland_surface_unref_glvk(glvk->parent);
+}
+
 static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
                                                            struct wayland_output *output,
                                                            int scale)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1a437736aeb..7e22b20292a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -34,6 +34,7 @@
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
@@ -72,6 +73,7 @@ enum wayland_window_message
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
     WM_WAYLAND_WINDOW_SURFACE_FLUSH,
     WM_WAYLAND_REMOTE_SURFACE,
+    WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
 };
 
 enum wayland_surface_role
@@ -108,6 +110,13 @@ enum wayland_remote_buffer_commit
     WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
 };
 
+enum wayland_pointer_constraint
+{
+    WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -230,6 +239,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
@@ -244,6 +254,7 @@ struct wayland
     uint32_t last_button_serial;
     int last_event_type;
     int event_notification_pipe[2];
+    RECT cursor_clip;
 };
 
 struct wayland_output_mode
@@ -306,6 +317,8 @@ struct wayland_surface
     struct wayland_surface *parent;
     struct wayland_surface *glvk;
     struct wayland_dmabuf_surface_feedback *surface_feedback;
+    struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
+    struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     /* The offset of this surface relative to its owning win32 window */
     int offset_x, offset_y;
     HWND hwnd;
@@ -498,6 +511,7 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
 void wayland_surface_ensure_mapped(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_update_pointer_constraint(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
@@ -739,6 +753,7 @@ static inline HWND get_focus(void)
 
 LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW displays, LPCWSTR primary_name,
                                    HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
+BOOL WAYLAND_ClipCursor(const RECT *clip) DECLSPEC_HIDDEN;
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 424d59a7e19..d9ccae6eeac 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -123,6 +123,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
     .pChangeDisplaySettings = WAYLAND_ChangeDisplaySettings,
+    .pClipCursor = WAYLAND_ClipCursor,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 16c3c54424d..12ae7859cb3 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -37,6 +37,8 @@
 #include <assert.h>
 #include <stdlib.h>
 
+#include <limits.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 /* private window data */
@@ -871,6 +873,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         wsurface->drawing_allowed = TRUE;
 
     wayland_mutex_unlock(&wsurface->mutex);
+
+    wayland_surface_update_pointer_constraint(wsurface);
 }
 
 static BOOL wayland_win_data_is_fullscreen_with_overshoot(struct wayland_win_data *data)
@@ -1693,6 +1697,25 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_POINTER_CONSTRAINT_UPDATE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+            {
+                if (wp == WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP)
+                {
+                    NtUserGetClipCursor(&wayland_surface->wayland->cursor_clip);
+                }
+                else if (wp == WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP)
+                {
+                    SetRect(&wayland_surface->wayland->cursor_clip,
+                            INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+                }
+                wayland_surface_update_pointer_constraint(wayland_surface);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From 338757e2eaa2a9b5de8667ea91618800656f2dac Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Tue, 18 Oct 2022 18:27:28 -0300
Subject: [PATCH 136/202] winewayland.drv: Implement SetCursorPos for pointer
 constraint heuristics.

Implement the SetCursorPos driver callback to improve our pointer
constraint and relative motion heuristics. Note that we don't
support actually setting the cursor position, since this is not
supported by Wayland.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/wayland_cursor.c  | 17 +++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c | 18 +++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      | 11 +++++++++++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          |  4 ++++
 5 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index fd6f7e70f05..7b5906740a3 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -702,3 +702,20 @@ BOOL WAYLAND_ClipCursor(const RECT *clip)
 
     return TRUE;
 }
+
+/***********************************************************************
+ *           WAYLAND_SetCursorPos
+ */
+BOOL WAYLAND_SetCursorPos(int x, int y)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+
+    TRACE("cursor_hwnd=%p, x=%d, y=%d\n", cursor_hwnd, x, y);
+
+    if (!cursor_hwnd) return TRUE;
+
+    send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+                 WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS, 0);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index fbae08ea9a5..61229066438 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1277,6 +1277,10 @@ void wayland_surface_update_pointer_constraint(struct wayland_surface *surface)
     RECT client_clip_rect;
     BOOL needs_lock = FALSE;
     BOOL needs_confine = FALSE;
+    BOOL set_cursor_pos = surface->set_cursor_pos;
+
+    /* Treat constraint updates triggered by SetCursorPos as single-shot. */
+    surface->set_cursor_pos = FALSE;
 
     if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
         return;
@@ -1333,11 +1337,21 @@ void wayland_surface_update_pointer_constraint(struct wayland_surface *surface)
         /* To consider confining the pointer we must have an effective clip,
          * otherwise confininement makes no difference. */
         BOOL confine_clip = !EqualRect(&clip_rect, &vscreen_rect);
+        /* We may need to unlock the cursor if it is visible or we locked
+         * because it was clipped but now the clip is gone. */
+        BOOL needs_unlock =
+            wayland->pointer.locked_reason != WAYLAND_POINTER_LOCKED_REASON_NONE &&
+            (wayland->pointer.hcursor ||
+             ((wayland->pointer.locked_reason & WAYLAND_POINTER_LOCKED_REASON_CLIP) && !lock_clip));
 
         /* If the cursor is not visible, and we have an lock clip, lock.
          * Otherwise if the cursor is visible check if we need to confine. */
-        if (!wayland->pointer.hcursor && lock_clip)
+        if (!needs_unlock && !wayland->pointer.hcursor && (lock_clip || set_cursor_pos))
         {
+            if (lock_clip)
+                wayland->pointer.locked_reason |= WAYLAND_POINTER_LOCKED_REASON_CLIP;
+            if (set_cursor_pos)
+                wayland->pointer.locked_reason |= WAYLAND_POINTER_LOCKED_REASON_SET_CURSOR_POS;
             needs_lock = TRUE;
         }
         else if (wayland->pointer.hcursor && confine_clip)
@@ -1346,6 +1360,8 @@ void wayland_surface_update_pointer_constraint(struct wayland_surface *surface)
         }
     }
 
+    if (!needs_lock) wayland->pointer.locked_reason = WAYLAND_POINTER_LOCKED_REASON_NONE;
+
     /* Destroy unneeded interface objects. */
     if (!needs_lock && surface->zwp_locked_pointer_v1)
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7e22b20292a..3871dbe0889 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,14 @@ enum wayland_pointer_constraint
     WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP,
     WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP,
     WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS,
+};
+
+enum wayland_pointer_locked_reason
+{
+    WAYLAND_POINTER_LOCKED_REASON_NONE = 0,
+    WAYLAND_POINTER_LOCKED_REASON_SET_CURSOR_POS = (1 << 0),
+    WAYLAND_POINTER_LOCKED_REASON_CLIP = (1 << 1),
 };
 
 /**********************************************************************
@@ -166,6 +174,7 @@ struct wayland_pointer
     struct wl_surface *cursor_wl_surface;
     uint32_t enter_serial;
     struct wayland_cursor *cursor;
+    enum wayland_pointer_locked_reason locked_reason;
     HCURSOR hcursor;
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
 };
@@ -333,6 +342,7 @@ struct wayland_surface
     BOOL drawing_allowed;
     struct wl_list child_list;
     BOOL window_fullscreen;
+    BOOL set_cursor_pos;
 };
 
 struct wayland_native_buffer
@@ -765,6 +775,7 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+BOOL WAYLAND_SetCursorPos(int x, int y) DECLSPEC_HIDDEN;
 void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d9ccae6eeac..dd71436d425 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -131,6 +131,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .pGetKeyNameText = WAYLAND_GetKeyNameText,
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
+    .pSetCursorPos = WAYLAND_SetCursorPos,
     .pSetCursor = WAYLAND_SetCursor,
     .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
     .pSetWindowRgn = WAYLAND_SetWindowRgn,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 12ae7859cb3..186f1e3d28a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1711,6 +1711,10 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
                     SetRect(&wayland_surface->wayland->cursor_clip,
                             INT_MIN, INT_MIN, INT_MAX, INT_MAX);
                 }
+                else if (wp == WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS)
+                {
+                    wayland_surface->set_cursor_pos = TRUE;
+                }
                 wayland_surface_update_pointer_constraint(wayland_surface);
             }
             wayland_surface_for_hwnd_unlock(wayland_surface);
-- 
2.39.0.rc2

From f6aedd3e1d3d5ed5cee2e3ee96c3a8610106a3a0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 17:16:49 +0300
Subject: [PATCH 137/202] winewayland.drv: Implement SetWindowText.

Inform the Wayland compositor of the window title for toplevel windows,
transforming the title to the expected UTF-8 encoding.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 27 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 23 ++++++++++++++++++++++
 4 files changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 61229066438..9768839a984 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1573,3 +1573,30 @@ int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
     TRACE("hwnd=%p (toplevel=%p) => scale=%d\n", surface->hwnd, toplevel->hwnd, scale);
     return scale;
 }
+
+/**********************************************************************
+ *          wayland_surface_set_title
+ */
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
+{
+    DWORD text_len;
+    DWORD utf8_count;
+    char *utf8 = NULL;
+
+    if (!surface->xdg_toplevel)
+        return;
+
+    TRACE("surface=%p hwnd=%p text='%s'\n",
+          surface, surface->hwnd, wine_dbgstr_w(text));
+
+    text_len = (lstrlenW(text) + 1) * sizeof(WCHAR);
+
+    if (!RtlUnicodeToUTF8N(NULL, 0, &utf8_count, text, text_len) &&
+        (utf8 = malloc(utf8_count)))
+    {
+        RtlUnicodeToUTF8N(utf8, utf8_count, &utf8_count, text, text_len);
+        xdg_toplevel_set_title(surface->xdg_toplevel, utf8);
+    }
+
+    free(utf8);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3871dbe0889..c54c3629ce4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -527,6 +527,7 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
                                      struct wayland_output *output) DECLSPEC_HIDDEN;
 int wayland_surface_get_buffer_scale(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland native buffer
@@ -780,6 +781,8 @@ void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWO
 void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
 UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index dd71436d425..c2391c96e7a 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -136,6 +136,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
     .pSetWindowRgn = WAYLAND_SetWindowRgn,
     .pSetWindowStyle = WAYLAND_SetWindowStyle,
+    .pSetWindowText = WAYLAND_SetWindowText,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 186f1e3d28a..e3ca64c9e93 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -547,6 +547,14 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
                                           wayland, parent_surface);
     }
 
+    if (surface && surface->xdg_toplevel)
+    {
+        WCHAR text[1024];
+        if (!NtUserInternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text)))
+            text[0] = 0;
+        wayland_surface_set_title(data->wayland_surface, text);
+    }
+
     if (data->wayland_surface != surface)
     {
         if (data->wayland_surface)
@@ -1179,6 +1187,21 @@ void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     wayland_win_data_release(data);
 }
 
+/*****************************************************************
+ *		WAYLAND_SetWindowText
+ */
+void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
+{
+    struct wayland_surface *wsurface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p text=%s\n", hwnd, wine_dbgstr_w(text));
+
+    if (wsurface && wsurface->xdg_toplevel)
+        wayland_surface_set_title(wsurface, text);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
 /***********************************************************************
  *	     WAYLAND_SetLayeredWindowAttributes
  */
-- 
2.39.0.rc2

From 4e13f17a8afc92ae782e06b2b2e3294253808eac Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:33:07 +0300
Subject: [PATCH 138/202] winewayland.drv: Add skeleton Vulkan driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/vulkan.c          | 81 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 4 files changed, 84 insertions(+)
 create mode 100644 dlls/winewayland.drv/vulkan.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 56c5988d214..76e64602c4a 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	options.c \
 	registry.c \
 	unicode.c \
+	vulkan.c \
 	wayland.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
new file mode 100644
index 00000000000..d4dc608c7e7
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan.c
@@ -0,0 +1,81 @@
+/* WAYLANDDRV Vulkan implementation
+ *
+ * Copyright 2017 Roderick Colenbrander
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+#include <dlfcn.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+#ifdef SONAME_LIBVULKAN
+
+static void *vulkan_handle;
+
+static void wine_vk_init(void)
+{
+    if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+        ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+}
+
+static const struct vulkan_funcs vulkan_funcs;
+
+/**********************************************************************
+ *           WAYLAND_wine_get_vulkan_driver
+ */
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+
+    if (version != WINE_VULKAN_DRIVER_VERSION)
+    {
+        ERR("version mismatch, vulkan wants %u but driver has %u\n", version, WINE_VULKAN_DRIVER_VERSION);
+        return NULL;
+    }
+
+    pthread_once(&init_once, wine_vk_init);
+    if (vulkan_handle)
+        return &vulkan_funcs;
+
+    return NULL;
+}
+
+#else /* No vulkan */
+
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    ERR("Wine was built without Vulkan support.\n");
+    return NULL;
+}
+
+#endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c54c3629ce4..5b9b17acb3e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -799,6 +799,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                const RECT *window_rect, const RECT *client_rect,
                                RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version) DECLSPEC_HIDDEN;
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index c2391c96e7a..5c57e5e6f22 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -147,6 +147,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .pWindowMessage = WAYLAND_WindowMessage,
     .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
+    .pwine_get_vulkan_driver = WAYLAND_wine_get_vulkan_driver,
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
 
-- 
2.39.0.rc2

From dad12fe653577d6a3ad319ba5636ecd7b54aa2c6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:41:32 +0300
Subject: [PATCH 139/202] winewayland.drv: Implement vkCreateInstance.

Create a Vulkan instance, ensuring we use the proper (Wayland)
SurfaceKHR extension when forwarding the request to the native Vulkan
platform.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 93 ++++++++++++++++++++++++++++++++++-
 1 file changed, 92 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index d4dc608c7e7..be064348c9c 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -35,20 +35,111 @@
 #include "wine/vulkan_driver.h"
 
 #include <dlfcn.h>
+#include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+
 static void *vulkan_handle;
 
+/* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
+ * Caller is responsible for allocation and cleanup of 'dst'.
+ */
+static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
+                                                     VkInstanceCreateInfo *dst)
+{
+    unsigned int i;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pApplicationInfo = src->pApplicationInfo;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions = calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+        {
+            /* Substitute extension with Wayland ones else copy. Long-term, when we
+             * support more extensions, we should store these in a list.
+             */
+            if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_surface"))
+                enabled_extensions[i] = "VK_KHR_wayland_surface";
+            else
+                enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+        }
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = src->enabledExtensionCount;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
+                                         const VkAllocationCallbacks *allocator,
+                                         VkInstance *instance)
+{
+    VkInstanceCreateInfo create_info_host;
+    VkResult res;
+    TRACE("create_info %p, allocator %p, instance %p\n", create_info, allocator, instance);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Perform a second pass on converting VkInstanceCreateInfo. Winevulkan
+     * performed a first pass in which it handles everything except for WSI
+     * functionality such as VK_KHR_win32_surface. Handle this now.
+     */
+    res = wine_vk_instance_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to convert instance create info, res=%d\n", res);
+        return res;
+    }
+
+    res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    {
         ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+    LOAD_FUNCPTR(vkCreateInstance);
+#undef LOAD_FUNCPTR
+
+    return;
+
+fail:
+    dlclose(vulkan_handle);
+    vulkan_handle = NULL;
 }
 
-static const struct vulkan_funcs vulkan_funcs;
+static const struct vulkan_funcs vulkan_funcs =
+{
+    .p_vkCreateInstance = wayland_vkCreateInstance,
+};
 
 /**********************************************************************
  *           WAYLAND_wine_get_vulkan_driver
-- 
2.39.0.rc2

From f1e753ec28ae4096d748a5253c8d248802702dd6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:44:10 +0300
Subject: [PATCH 140/202] winewayland.drv: Implement vkDestroyInstance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index be064348c9c..213c1a02c43 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -42,6 +42,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 #ifdef SONAME_LIBVULKAN
 
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -117,6 +118,16 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
+{
+    TRACE("%p %p\n", instance, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    pvkDestroyInstance(instance, NULL /* allocator */);
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -127,6 +138,7 @@ static void wine_vk_init(void)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkDestroyInstance);
 #undef LOAD_FUNCPTR
 
     return;
@@ -139,6 +151,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkDestroyInstance = wayland_vkDestroyInstance,
 };
 
 /**********************************************************************
-- 
2.39.0.rc2

From 48444546ae9873587b36fb6b4913695c68c9aecb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 19:08:53 +0300
Subject: [PATCH 141/202] winewayland.drv: Implement vkCreateWin32SurfaceKHR.

Create Win32 VkSurfaceKHR objects which are backed by native Wayland
VkSurfaceKHR objects. These native objects are associated with a
dedicated subsurface we use for Vulkan rendering (see
wayland_surface_create_or_ref_vk). We use the native VkSurfaceKHR handle
as the Win32 VkSurfaceKHR handle, to ensure transparent compatibility
with all extensions (current *and* future) that accept VkSurfaceKHR
handles.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 122 ++++++++++++++++++++++++++++++++++
 1 file changed, 122 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 213c1a02c43..7233206e891 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -41,11 +41,62 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+#define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
+
+typedef struct VkWaylandSurfaceCreateInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkWaylandSurfaceCreateFlagsKHR flags;
+    struct wl_display *display;
+    struct wl_surface *surface;
+} VkWaylandSurfaceCreateInfoKHR;
+
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
+static struct wayland_mutex wine_vk_object_mutex =
+{
+    PTHREAD_MUTEX_INITIALIZER, 0, 0, __FILE__ ": wine_vk_object_mutex"
+};
+
+static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+
+struct wine_vk_surface
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_surface *wayland_surface;
+    VkSurfaceKHR native_vk_surface;
+};
+
+static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
+{
+    wayland_mutex_lock(&wine_vk_object_mutex);
+    wl_list_insert(list, link);
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+static inline void wine_vk_list_remove(struct wl_list *link)
+{
+    wayland_mutex_lock(&wine_vk_object_mutex);
+    wl_list_remove(link);
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
+{
+    wine_vk_list_remove(&wine_vk_surface->link);
+
+    if (wine_vk_surface->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_surface->wayland_surface);
+
+    free(wine_vk_surface);
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -118,6 +169,75 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
+                                                const VkWin32SurfaceCreateInfoKHR *create_info,
+                                                const VkAllocationCallbacks *allocator,
+                                                VkSurfaceKHR *vk_surface)
+{
+    VkResult res;
+    VkWaylandSurfaceCreateInfoKHR create_info_host;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wayland_surface *wayland_surface;
+    BOOL ref_vk;
+
+    TRACE("%p %p %p %p\n", instance, create_info, allocator, vk_surface);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_surface = calloc(1, sizeof(*wine_vk_surface));
+    if (!wine_vk_surface)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_surface->link);
+
+    wayland_surface = wayland_surface_for_hwnd_lock(create_info->hwnd);
+    if (!wayland_surface)
+    {
+        ERR("Failed to find wayland surface for hwnd=%p\n", create_info->hwnd);
+        /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    ref_vk = wayland_surface_create_or_ref_glvk(wayland_surface);
+    wayland_surface_for_hwnd_unlock(wayland_surface);
+    if (!ref_vk)
+    {
+        ERR("Failed to create or ref vulkan surface for hwnd=%p\n", create_info->hwnd);
+        /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    wine_vk_surface->wayland_surface = wayland_surface;
+
+    create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
+    create_info_host.pNext = NULL;
+    create_info_host.flags = 0; /* reserved */
+    create_info_host.display = process_wl_display;
+    create_info_host.surface = wayland_surface->glvk->wl_surface;
+
+    res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host, NULL /* allocator */, vk_surface);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create vulkan wayland surface, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_surface->hwnd = create_info->hwnd;
+    wine_vk_surface->native_vk_surface = *vk_surface;
+
+    wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
+
+    TRACE("Created surface=0x%s\n", wine_dbgstr_longlong(*vk_surface));
+    return VK_SUCCESS;
+
+err:
+    wine_vk_surface_destroy(wine_vk_surface);
+    return res;
+}
+
 static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
 {
     TRACE("%p %p\n", instance, allocator);
@@ -138,6 +258,7 @@ static void wine_vk_init(void)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
 #undef LOAD_FUNCPTR
 
@@ -151,6 +272,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
 };
 
-- 
2.39.0.rc2

From e1e4498ba60ab4ec0da49e13e64049b8b8c133fa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:02:59 +0300
Subject: [PATCH 142/202] winewayland.drv: Implement vkDestroySurfaceKHR.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 37 +++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 7233206e891..5a055a11a15 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -55,6 +55,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
+static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -97,6 +98,22 @@ static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
     free(wine_vk_surface);
 }
 
+static struct wine_vk_surface *wine_vk_surface_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *surf;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+        if (surf->native_vk_surface == handle) goto out;
+
+    surf = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return surf;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -248,6 +265,24 @@ static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCal
     pvkDestroyInstance(instance, NULL /* allocator */);
 }
 
+static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
+                                        const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+
+    TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_surface)
+    {
+        pvkDestroySurfaceKHR(instance, wine_vk_surface->native_vk_surface,
+                             NULL /* allocator */);
+        wine_vk_surface_destroy(wine_vk_surface);
+    }
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -260,6 +295,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
+    LOAD_FUNCPTR(vkDestroySurfaceKHR);
 #undef LOAD_FUNCPTR
 
     return;
@@ -274,6 +310,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateInstance = wayland_vkCreateInstance,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
 };
 
 /**********************************************************************
-- 
2.39.0.rc2

From 2fa2caa06cac2501dfb9d9f7138d2fd6e1b85ec8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:21:29 +0300
Subject: [PATCH 143/202] winewayland.drv: Implement vkCreateSwapchainKHR.

Create Win32 VkSwapchainKHR objects which are backed by native Wayland
VkSwapchainKHR objects. We use the native VkSwapchainKHR handle as the
Win32 VkSwapchainKHR handle, to ensure transparent compatibility with
all extensions (current *and* future) that accept VkSwapchainKHR
handles.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 79 +++++++++++++++++++++++++++++++++++
 1 file changed, 79 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 5a055a11a15..4e92d719de9 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -53,6 +53,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 } VkWaylandSurfaceCreateInfoKHR;
 
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
@@ -65,6 +66,7 @@ static struct wayland_mutex wine_vk_object_mutex =
 };
 
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
 
 struct wine_vk_surface
 {
@@ -74,6 +76,14 @@ struct wine_vk_surface
     VkSurfaceKHR native_vk_surface;
 };
 
+struct wine_vk_swapchain
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_surface *wayland_surface;
+    VkSwapchainKHR native_vk_swapchain;
+};
+
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
 {
     wayland_mutex_lock(&wine_vk_object_mutex);
@@ -114,6 +124,16 @@ out:
     return surf;
 }
 
+static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    wine_vk_list_remove(&wine_vk_swapchain->link);
+
+    if (wine_vk_swapchain->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
+
+    free(wine_vk_swapchain);
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -158,6 +178,11 @@ static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo
     return VK_SUCCESS;
 }
 
+#define RETURN_VK_ERROR_SURFACE_LOST_KHR { \
+    TRACE("VK_ERROR_SURFACE_LOST_KHR\n"); \
+    return VK_ERROR_SURFACE_LOST_KHR; \
+}
+
 static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
                                          const VkAllocationCallbacks *allocator,
                                          VkInstance *instance)
@@ -186,6 +211,58 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
+                                             const VkSwapchainCreateInfoKHR *create_info,
+                                             const VkAllocationCallbacks *allocator,
+                                             VkSwapchainKHR *swapchain)
+{
+    VkResult res;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    VkSwapchainCreateInfoKHR info = *create_info;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Wayland can't deal with 0x0 swapchains, use the minimum 1x1. */
+    if (info.imageExtent.width == 0)
+        info.imageExtent.width = 1;
+    if (info.imageExtent.height == 0)
+        info.imageExtent.height = 1;
+
+    wine_vk_surface = wine_vk_surface_from_handle(info.surface);
+    if (!wine_vk_surface)
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    wine_vk_swapchain = calloc(1, sizeof(*wine_vk_swapchain));
+    if (!wine_vk_swapchain)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_swapchain->link);
+
+    res = pvkCreateSwapchainKHR(device, &info, NULL /* allocator */, swapchain);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    wine_vk_swapchain->hwnd = wine_vk_surface->hwnd;
+    if (wine_vk_surface->wayland_surface)
+    {
+        wayland_surface_create_or_ref_glvk(wine_vk_surface->wayland_surface);
+        wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
+    }
+    wine_vk_swapchain->native_vk_swapchain = *swapchain;
+
+    wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
+
+    return res;
+
+err:
+    wine_vk_swapchain_destroy(wine_vk_swapchain);
+    return res;
+}
+
 static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
                                                 const VkWin32SurfaceCreateInfoKHR *create_info,
                                                 const VkAllocationCallbacks *allocator,
@@ -293,6 +370,7 @@ static void wine_vk_init(void)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
@@ -308,6 +386,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
-- 
2.39.0.rc2

From 144317c4d51c1a817ca8dfb7184bbd8e931fa11d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:35:30 +0300
Subject: [PATCH 144/202] winewayland.drv: Implement vkDestroySwapchainKHR.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 38 +++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 4e92d719de9..ed7856e7a57 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -57,6 +57,7 @@ static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKH
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
+static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -134,6 +135,22 @@ static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchai
     free(wine_vk_swapchain);
 }
 
+static struct wine_vk_swapchain *wine_vk_swapchain_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_swapchain *swap;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+        if (swap->native_vk_swapchain == handle) goto out;
+
+    swap = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return swap;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -360,6 +377,25 @@ static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surfac
     }
 }
 
+static void wayland_vkDestroySwapchainKHR(VkDevice device,
+                                          VkSwapchainKHR swapchain,
+                                          const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_swapchain)
+    {
+        pvkDestroySwapchainKHR(device, wine_vk_swapchain->native_vk_swapchain,
+                               NULL /* allocator */);
+        wine_vk_swapchain_destroy(wine_vk_swapchain);
+    }
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -374,6 +410,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
+    LOAD_FUNCPTR(vkDestroySwapchainKHR);
 #undef LOAD_FUNCPTR
 
     return;
@@ -390,6 +427,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
 };
 
 /**********************************************************************
-- 
2.39.0.rc2

From d892851abe82fa71ab5ace5d25a2cc0b4e123a7c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 13:22:11 +0300
Subject: [PATCH 145/202] winewayland.drv: Implement vkQueuePresentKHR.

Before presenting ensure that the parent Wayland surface of the
subsurface used for VK content has been mapped, otherwise the Vulkan
content won't be visible and will block any throttled/vsynced rendering
loops which rely on wl_frame events.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 86 +++++++++++++++++++++++++++++++++++
 1 file changed, 86 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index ed7856e7a57..929141f66df 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -58,6 +58,7 @@ static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurface
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
 
@@ -396,6 +397,89 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
+{
+    uint32_t i;
+    VkResult res = VK_SUCCESS;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+        BOOL drawing_allowed =
+            (wine_vk_swapchain && wine_vk_swapchain->wayland_surface) ?
+            wine_vk_swapchain->wayland_surface->drawing_allowed : TRUE;
+
+        TRACE("swapchain[%d] vk=0x%s wine=%p wayland_surface=%p "
+               "drawing_allowed=%d\n",
+               i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
+               drawing_allowed);
+
+        if (!wine_vk_swapchain)
+            res = VK_ERROR_SURFACE_LOST_KHR;
+        else if (!drawing_allowed)
+            if (res == VK_SUCCESS) res = VK_ERROR_OUT_OF_DATE_KHR;
+
+        /* Since Vulkan content is presented on a Wayland subsurface, we need
+         * to ensure the parent Wayland surface is mapped for the Vulkan
+         * content to be visible. */
+        if (wine_vk_swapchain->wayland_surface && drawing_allowed)
+            wayland_surface_ensure_mapped(wine_vk_swapchain->wayland_surface);
+    }
+
+    /* In case of error in any swapchain, we are not going to present at all,
+     * so mark all swapchains as failures. */
+    if (res != VK_SUCCESS && present_info->pResults)
+    {
+        for (i = 0; i < present_info->swapchainCount; ++i)
+            present_info->pResults[i] = res;
+    }
+
+    return res;
+}
+
+static void lock_swapchain_wayland_surfaces(const VkPresentInfoKHR *present_info,
+                                            BOOL lock)
+{
+    uint32_t i;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+
+        if (wine_vk_swapchain && wine_vk_swapchain->wayland_surface)
+        {
+            if (lock)
+                wayland_mutex_lock(&wine_vk_swapchain->wayland_surface->mutex);
+            else
+                wayland_mutex_unlock(&wine_vk_swapchain->wayland_surface->mutex);
+        }
+    }
+}
+
+static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *present_info)
+{
+    VkResult res;
+
+    TRACE("%p, %p\n", queue, present_info);
+
+    /* Lock the surfaces to ensure we don't present while reconfiguration is
+     * taking place, so we don't inadvertently commit an in-progress,
+     * incomplete configuration state. */
+    lock_swapchain_wayland_surfaces(present_info, TRUE);
+
+    if ((res = validate_present_info(present_info)) == VK_SUCCESS)
+        res = pvkQueuePresentKHR(queue, present_info);
+
+    lock_swapchain_wayland_surfaces(present_info, FALSE);
+
+    return res;
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -411,6 +495,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 
     return;
@@ -428,6 +513,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
 /**********************************************************************
-- 
2.39.0.rc2

From b4f1ff4fa31e8617296e2d50d39840442e24fb88 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 13:30:46 +0300
Subject: [PATCH 146/202] winewayland.drv: Handle window resizes under Vulkan.

Return the VK_ERROR_OUT_OF_DATE_KHR soft error to notify callers of
vkQueuePresent that the image(s) they are presenting don't match the
current window size.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 929141f66df..1dc74d0a5f0 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -28,6 +28,8 @@
 
 #include "wine/debug.h"
 
+#include "ntuser.h"
+
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
 
@@ -84,6 +86,7 @@ struct wine_vk_swapchain
     HWND hwnd;
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
+    VkExtent2D extent;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -271,6 +274,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
     }
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
+    wine_vk_swapchain->extent = info.imageExtent;
 
     wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
 
@@ -410,17 +414,27 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
         BOOL drawing_allowed =
             (wine_vk_swapchain && wine_vk_swapchain->wayland_surface) ?
             wine_vk_swapchain->wayland_surface->drawing_allowed : TRUE;
+        RECT client;
 
-        TRACE("swapchain[%d] vk=0x%s wine=%p wayland_surface=%p "
+        TRACE("swapchain[%d] vk=0x%s wine=%p extent=%dx%d wayland_surface=%p "
                "drawing_allowed=%d\n",
                i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.width : 0,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.height : 0,
                wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
                drawing_allowed);
 
-        if (!wine_vk_swapchain)
+        if (!wine_vk_swapchain ||
+            !NtUserGetClientRect(wine_vk_swapchain->hwnd, &client))
+        {
             res = VK_ERROR_SURFACE_LOST_KHR;
-        else if (!drawing_allowed)
+        }
+        else if (client.right != wine_vk_swapchain->extent.width ||
+                 client.bottom != wine_vk_swapchain->extent.height ||
+                 !drawing_allowed)
+        {
             if (res == VK_SUCCESS) res = VK_ERROR_OUT_OF_DATE_KHR;
+        }
 
         /* Since Vulkan content is presented on a Wayland subsurface, we need
          * to ensure the parent Wayland surface is mapped for the Vulkan
-- 
2.39.0.rc2

From 305b087c25a3e067ec567bd75c4d8ed8de3fb19b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:43:33 +0300
Subject: [PATCH 147/202] winewayland.drv: Add mechanism to invalidate Vulkan
 objects.

When the Wayland surface associated with a Vulkan surface or swapchain
is scheduled for destruction, we mark such Vulkan objects as invalidated
in the driver and callers are notified with the
VK_ERROR_SURFACE_LOST_KHR hard error when they try to use such objects.

Note that the Vulkan objects hold a reference to the associated Wayland
surface, so there is no danger of time-of-check to time-of-use (TOCTOU)
related bugs/races when checking for invalidation.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c     | 35 ++++++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h |  6 ++++++
 2 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 1dc74d0a5f0..8eb8572f7e2 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -78,6 +78,7 @@ struct wine_vk_surface
     HWND hwnd;
     struct wayland_surface *wayland_surface;
     VkSurfaceKHR native_vk_surface;
+    BOOL valid;
 };
 
 struct wine_vk_swapchain
@@ -87,6 +88,7 @@ struct wine_vk_swapchain
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
     VkExtent2D extent;
+    BOOL valid;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -254,7 +256,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         info.imageExtent.height = 1;
 
     wine_vk_surface = wine_vk_surface_from_handle(info.surface);
-    if (!wine_vk_surface)
+    if (!wine_vk_surface || !__atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST))
         RETURN_VK_ERROR_SURFACE_LOST_KHR;
 
     wine_vk_swapchain = calloc(1, sizeof(*wine_vk_swapchain));
@@ -275,6 +277,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
     }
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
     wine_vk_swapchain->extent = info.imageExtent;
+    wine_vk_swapchain->valid = TRUE;
 
     wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
 
@@ -343,6 +346,7 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
 
     wine_vk_surface->hwnd = create_info->hwnd;
     wine_vk_surface->native_vk_surface = *vk_surface;
+    wine_vk_surface->valid = TRUE;
 
     wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
 
@@ -425,6 +429,7 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
                drawing_allowed);
 
         if (!wine_vk_swapchain ||
+            !__atomic_load_n(&wine_vk_swapchain->valid, __ATOMIC_SEQ_CST) ||
             !NtUserGetClientRect(wine_vk_swapchain->hwnd, &client))
         {
             res = VK_ERROR_SURFACE_LOST_KHR;
@@ -550,6 +555,30 @@ const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
     return NULL;
 }
 
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+    struct wine_vk_swapchain *swap;
+    struct wine_vk_surface *surf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+    {
+        if (swap->hwnd == hwnd)
+            __atomic_store_n(&swap->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+    {
+        if (surf->hwnd == hwnd)
+            __atomic_store_n(&surf->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
 #else /* No vulkan */
 
 const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
@@ -558,4 +587,8 @@ const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
     return NULL;
 }
 
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+}
+
 #endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5b9b17acb3e..a9386e997e2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -654,6 +654,12 @@ void wayland_update_front_buffer(HWND hwnd,
                                  void (*read_pixels)(void *pixels_out,
                                                      int width, int height)) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Vulkan support
+ */
+
+void wayland_invalidate_vulkan_objects(HWND hwnd) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Registry helpers
  */
-- 
2.39.0.rc2

From 56d6a5343a0da1c6b28244235ee340b26305e0ca Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:34:43 +0300
Subject: [PATCH 148/202] winewayland.drv: Implement
 vkEnumerateInstanceExtensionProperties.

Return the native instance extension properties, substituting
VK_KHR_wayland_surface for VK_KHR_win32_surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 45 +++++++++++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 8eb8572f7e2..cf6b014bb7e 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -60,6 +60,7 @@ static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurface
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -405,6 +406,48 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer_name,
+                                                               uint32_t *count,
+                                                               VkExtensionProperties* properties)
+{
+    unsigned int i;
+    VkResult res;
+
+    TRACE("layer_name %s, count %p, properties %p\n", debugstr_a(layer_name), count, properties);
+
+    /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
+    if (layer_name)
+    {
+        ERR("Layer enumeration not supported from ICD.\n");
+        return VK_ERROR_LAYER_NOT_PRESENT;
+    }
+
+    /* We will return the same number of instance extensions reported by the host back to
+     * winevulkan. Along the way we may replace xlib extensions with their win32 equivalents.
+     * Winevulkan will perform more detailed filtering as it knows whether it has thunks
+     * for a particular extension.
+     */
+    res = pvkEnumerateInstanceExtensionProperties(layer_name, count, properties);
+    if (!properties || res < 0)
+        return res;
+
+    for (i = 0; i < *count; i++)
+    {
+        /* For now the only wayland extension we need to fixup. Long-term we may need an array. */
+        if (!strcmp(properties[i].extensionName, "VK_KHR_wayland_surface"))
+        {
+            TRACE("Substituting VK_KHR_wayland_surface for VK_KHR_win32_surface\n");
+
+            snprintf(properties[i].extensionName, sizeof(properties[i].extensionName),
+                    VK_KHR_WIN32_SURFACE_EXTENSION_NAME);
+            properties[i].specVersion = VK_KHR_WIN32_SURFACE_SPEC_VERSION;
+        }
+    }
+
+    TRACE("Returning %u extensions.\n", *count);
+    return res;
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -514,6 +557,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 
@@ -532,6 +576,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 991c93504cd3636d74df98adfb9b7b34236189d7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:58:45 +0300
Subject: [PATCH 149/202] winewayland.drv: Implement
 vkGetDeviceGroupSurfacePresentModesKHR.

This is a simple passthrough implementation to the native Vulkan driver,
with the addition of a VkSurfaceKHR invalidation check.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index cf6b014bb7e..60cb9a88757 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -61,6 +61,7 @@ static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -132,6 +133,12 @@ out:
     return surf;
 }
 
+static BOOL wine_vk_surface_handle_is_valid(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(handle);
+    return wine_vk_surface && __atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST);
+}
+
 static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
 {
     wine_vk_list_remove(&wine_vk_swapchain->link);
@@ -448,6 +455,18 @@ static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer
     return res;
 }
 
+static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
+                                                               VkSurfaceKHR surface,
+                                                               VkDeviceGroupPresentModeFlagsKHR *flags)
+{
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(surface), flags);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -551,6 +570,7 @@ static void wine_vk_init(void)
     }
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+#define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
@@ -558,8 +578,10 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
+    LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
+#undef LOAD_OPTIONAL_FUNCPTR
 
     return;
 
@@ -577,6 +599,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
     .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 527540a9ec2f1d1fa9aad38894cd6cdd1fde85ab Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:56:18 +0300
Subject: [PATCH 150/202] winewayland.drv: Implement vkGetDeviceProcAddr and
 vkGetInstanceProcAddr.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 60cb9a88757..50a5a205d41 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -62,6 +62,8 @@ static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocation
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
+static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
+static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -74,6 +76,8 @@ static struct wayland_mutex wine_vk_object_mutex =
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
 static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
 
+static const struct vulkan_funcs vulkan_funcs;
+
 struct wine_vk_surface
 {
     struct wl_list link;
@@ -467,6 +471,30 @@ static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
     return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
 }
 
+static void *wayland_vkGetDeviceProcAddr(VkDevice device, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", device, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_device_proc_addr(&vulkan_funcs, name)))
+        return proc_addr;
+
+    return pvkGetDeviceProcAddr(device, name);
+}
+
+static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", instance, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_instance_proc_addr(&vulkan_funcs, instance, name)))
+        return proc_addr;
+
+    return pvkGetInstanceProcAddr(instance, name);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -579,6 +607,8 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetDeviceProcAddr);
+    LOAD_FUNCPTR(vkGetInstanceProcAddr);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -600,6 +630,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
     .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
     .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 140e27ed9af6808fb6fa674e62fe752c0ac258d7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 11:04:58 +0300
Subject: [PATCH 151/202] winewayland.drv: Implement
 vkGetPhysicalDevicePresentRectanglesKHR.

This is a simple passthrough implementation to the native Vulkan driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 50a5a205d41..2328d3e1e3b 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -64,6 +64,7 @@ static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
 static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
+static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -495,6 +496,15 @@ static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name
     return pvkGetInstanceProcAddr(instance, name);
 }
 
+static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice phys_dev,
+                                                                VkSurfaceKHR surface,
+                                                                uint32_t *count, VkRect2D *rects)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, rects);
+
+    return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -609,6 +619,7 @@ static void wine_vk_init(void)
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
     LOAD_FUNCPTR(vkGetInstanceProcAddr);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -632,6 +643,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
     .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
     .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 23db8c90ec9a1af5c692d5e6d9a9aabb0cdaae45 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 11:11:41 +0300
Subject: [PATCH 152/202] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceCapabilities(2)KHR.

Passthrough implementations with three additions:

1. Checking for invalidated VkSurfaceKHR.
2. Try to emulate vkGetPhysicalDeviceSurfaceCapabilities2KHR with
   vkGetPhysicalDeviceSurfaceCapabilitiesKHR if needed.
3. Set the capabilities' image extent values to match what the Vulkan Win32 WSI
   typically provides.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 106 ++++++++++++++++++++++++++++++++++
 1 file changed, 106 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 2328d3e1e3b..017903e6c70 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -65,6 +65,8 @@ static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKH
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
 static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -505,6 +507,106 @@ static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice
     return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
 }
 
+/* Set the image extent in the capabilities to match what Windows expects. */
+static void set_image_extent(VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *caps)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    BOOL zero_extents = FALSE;
+
+    if (!wine_vk_surface || !wine_vk_surface->wayland_surface)
+        return;
+
+    wayland_mutex_lock(&wine_vk_surface->wayland_surface->mutex);
+    if (!wine_vk_surface->wayland_surface->drawing_allowed)
+        zero_extents = TRUE;
+    wayland_mutex_unlock(&wine_vk_surface->wayland_surface->mutex);
+
+    if (NtUserGetWindowLongW(wine_vk_surface->hwnd, GWL_STYLE) & WS_MINIMIZE)
+        zero_extents = TRUE;
+
+    if (zero_extents)
+    {
+        caps->minImageExtent.width = 0;
+        caps->minImageExtent.height = 0;
+        caps->maxImageExtent.width = 0;
+        caps->maxImageExtent.height = 0;
+        caps->currentExtent.width = 0;
+        caps->currentExtent.height = 0;
+    }
+    else
+    {
+        RECT client;
+        NtUserGetClientRect(wine_vk_surface->hwnd, &client);
+
+        caps->minImageExtent.width = client.right;
+        caps->minImageExtent.height = client.bottom;
+        caps->maxImageExtent.width = client.right;
+        caps->maxImageExtent.height = client.bottom;
+        caps->currentExtent.width = client.right;
+        caps->currentExtent.height = client.bottom;
+    }
+
+    TRACE("vk_surface=%s hwnd=%p wayland_surface=%p extent=%dx%d\n",
+          wine_dbgstr_longlong(surface), wine_vk_surface->hwnd,
+          wine_vk_surface->wayland_surface, caps->currentExtent.width,
+          caps->currentExtent.height);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice phys_dev,
+                                                                   const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                                   VkSurfaceCapabilities2KHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceCapabilities2KHR)
+    {
+        res = pvkGetPhysicalDeviceSurfaceCapabilities2KHR(phys_dev, surface_info,
+                                                          capabilities);
+        goto out;
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext || capabilities->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with "
+              "vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface_info->surface,
+                                                     &capabilities->surfaceCapabilities);
+
+out:
+    if (res == VK_SUCCESS)
+        set_image_extent(surface_info->surface, &capabilities->surfaceCapabilities);
+
+    return res;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  VkSurfaceCapabilitiesKHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
+
+    if (res == VK_SUCCESS)
+        set_image_extent(surface, capabilities);
+
+    return res;
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -620,6 +722,8 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
     LOAD_FUNCPTR(vkGetInstanceProcAddr);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -644,6 +748,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
     .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 9b41941eb1bea4cd4e34016081e2f4652a75c237 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:27:03 +0300
Subject: [PATCH 153/202] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceFormats(2)KHR.

Passthrough implementations with two additions:

1. Checking for invalidated VkSurfaceKHR.
2. Try to emulate vkGetPhysicalDeviceSurfaceFormats2KHR with
   vkGetPhysicalDeviceSurfaceFormatsKHR if needed.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 66 +++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 017903e6c70..ba0da3ea2c4 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -67,6 +67,8 @@ static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -607,6 +609,66 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevi
     return res;
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
+                                                              const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                              uint32_t *count,
+                                                              VkSurfaceFormat2KHR *formats)
+{
+    VkSurfaceFormatKHR *formats_host;
+    uint32_t i;
+    VkResult result;
+    TRACE("%p, %p, %p, %p\n", phys_dev, surface_info, count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceFormats2KHR with "
+              "vkGetPhysicalDeviceSurfaceFormatsKHR, pNext is ignored.\n");
+    }
+
+    if (!formats)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                     count, NULL);
+    }
+
+    formats_host = calloc(*count, sizeof(*formats_host));
+    if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    result = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                   count, formats_host);
+    if (result == VK_SUCCESS || result == VK_INCOMPLETE)
+    {
+        for (i = 0; i < *count; i++)
+            formats[i].surfaceFormat = formats_host[i];
+    }
+
+    free(formats_host);
+    return result;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice phys_dev,
+                                                             VkSurfaceKHR surface,
+                                                             uint32_t *count,
+                                                             VkSurfaceFormatKHR *formats)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -724,6 +786,8 @@ static void wine_vk_init(void)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -750,6 +814,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 69837e2c6be11eac11bdd1097dc08a5ea2ecf375 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:40:48 +0300
Subject: [PATCH 154/202] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfacePresentModesKHR

This is a simple passthrough implementation to the native Vulkan driver,
with the addition of a VkSurfaceKHR invalidation check.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index ba0da3ea2c4..14a3740a99b 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -69,6 +69,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice,
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -669,6 +670,19 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice ph
     return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  uint32_t *count,
+                                                                  VkPresentModeKHR *modes)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, modes);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -788,6 +802,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -816,6 +831,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From c3290ec63d6b6397039381d5f23fb24fd435d1c4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:42:03 +0300
Subject: [PATCH 155/202] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceSupportKHR.

This is a simple passthrough implementation to the native Vulkan driver,
with the addition of a VkSurfaceKHR invalidation check.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 14a3740a99b..b46dcba0c4c 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -70,6 +70,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice,
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -683,6 +684,19 @@ static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevi
     return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice phys_dev,
+                                                             uint32_t index,
+                                                             VkSurfaceKHR surface,
+                                                             VkBool32 *supported)
+{
+    TRACE("%p, %u, 0x%s, %p\n", phys_dev, index, wine_dbgstr_longlong(surface), supported);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -803,6 +817,7 @@ static void wine_vk_init(void)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -832,6 +847,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 783c3751809c5ab50513b7222f4d9593b70d8246 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:45:12 +0300
Subject: [PATCH 156/202] winewayland.drv: Implement
 vkGetPhysicalDeviceWin32PresentationSupportKHR.

This is a simple passthrough implementation to the corresponding Vulkan
Wayland extension.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index b46dcba0c4c..bd8a8d165ab 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -71,6 +71,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, cons
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
+static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -697,6 +698,15 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice ph
     return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
 }
 
+static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice phys_dev,
+                                                                       uint32_t index)
+{
+    TRACE("%p %u\n", phys_dev, index);
+
+    return pvkGetPhysicalDeviceWaylandPresentationSupportKHR(phys_dev, index,
+                                                             process_wl_display);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -818,6 +828,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -848,6 +859,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 1c18d8e6b987b222549bc91621f19b181f6c272b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:59:01 +0300
Subject: [PATCH 157/202] winewayland.drv: Implement vkGetSwapchainImagesKHR.

This is a simple passthrough implementation to the native Vulkan driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index bd8a8d165ab..5eb91c05964 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -72,6 +72,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSur
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
 static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
+static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -707,6 +708,14 @@ static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysica
                                                              process_wl_display);
 }
 
+static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    TRACE("%p, 0x%s %p %p\n", device, wine_dbgstr_longlong(swapchain), count, images);
+
+    return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -829,6 +838,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
+    LOAD_FUNCPTR(vkGetSwapchainImagesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -860,6 +870,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.39.0.rc2

From 9b2d728da44d10d685874ec79b8f0bb3fa94e63c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 16:35:45 +0300
Subject: [PATCH 158/202] winewayland.drv: Implement wine_get_native_surface.

The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
native VkSurfaceKHR, so the implementation is trivial.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 5eb91c05964..6400f91453d 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -810,6 +810,14 @@ static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR
     return res;
 }
 
+/* The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
+ * native surface. */
+static VkSurfaceKHR wayland_wine_get_native_surface(VkSurfaceKHR surface)
+{
+    TRACE("0x%s\n", wine_dbgstr_longlong(surface));
+    return surface;
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -872,6 +880,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
     .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
+    .p_wine_get_native_surface = wayland_wine_get_native_surface,
 };
 
 /**********************************************************************
-- 
2.39.0.rc2

From 2d0a610002ce406980107d5e1138096905364f8f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 17:04:04 +0300
Subject: [PATCH 159/202] winewayland.drv: Invalidate Vulkan objects on Wayland
 surface update.

When the Wayland surface is updated (including when it changes to NULL,
i.e., when it is destroyed), we need to notify the application so that
it can deal with it accordingly.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e3ca64c9e93..5fc3ec725ec 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -584,6 +584,9 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         data->wayland_surface = surface;
 
         wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
+        /* Force client to recreate any Vulkan objects so that we use the updated
+         * backing Wayland surface in our internal Vulkan representations. */
+        wayland_invalidate_vulkan_objects(data->hwnd);
     }
 }
 
@@ -1010,6 +1013,7 @@ void WAYLAND_DestroyWindow(HWND hwnd)
 
     if (!(data = wayland_win_data_get(hwnd))) return;
     wayland_destroy_gl_drawable(hwnd);
+    wayland_invalidate_vulkan_objects(hwnd);
     wayland_destroy_remote_surfaces(hwnd);
     wayland_win_data_destroy(data);
 }
-- 
2.39.0.rc2

From e3a9afe7de25f2ca4dbd1c531056aa5149bedb8f Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Tue, 12 Jul 2022 23:04:45 -0300
Subject: [PATCH 160/202] winex11.drv: Use designated initializers for
 vulkan_funcs fields.

With this change we don't need to implement all the functions from
struct vulkan_funcs on the X11 driver. This is safe to do because
Wine has fallbacks for them.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winex11.drv/vulkan.c | 44 +++++++++++++++++++--------------------
 1 file changed, 22 insertions(+), 22 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 101504a7887..08e57c4def0 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -683,28 +683,28 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
-    X11DRV_vkCreateInstance,
-    X11DRV_vkCreateSwapchainKHR,
-    X11DRV_vkCreateWin32SurfaceKHR,
-    X11DRV_vkDestroyInstance,
-    X11DRV_vkDestroySurfaceKHR,
-    X11DRV_vkDestroySwapchainKHR,
-    X11DRV_vkEnumerateInstanceExtensionProperties,
-    X11DRV_vkGetDeviceGroupSurfacePresentModesKHR,
-    X11DRV_vkGetDeviceProcAddr,
-    X11DRV_vkGetInstanceProcAddr,
-    X11DRV_vkGetPhysicalDevicePresentRectanglesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceFormatsKHR,
-    X11DRV_vkGetPhysicalDeviceSurfacePresentModesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceSupportKHR,
-    X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
-    X11DRV_vkGetSwapchainImagesKHR,
-    X11DRV_vkQueuePresentKHR,
-
-    X11DRV_wine_get_native_surface,
+    .p_vkCreateInstance = X11DRV_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = X11DRV_vkCreateSwapchainKHR,
+    .p_vkCreateWin32SurfaceKHR = X11DRV_vkCreateWin32SurfaceKHR,
+    .p_vkDestroyInstance = X11DRV_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = X11DRV_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = X11DRV_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = X11DRV_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = X11DRV_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = X11DRV_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = X11DRV_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = X11DRV_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = X11DRV_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = X11DRV_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = X11DRV_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = X11DRV_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = X11DRV_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = X11DRV_vkGetSwapchainImagesKHR,
+    .p_vkQueuePresentKHR = X11DRV_vkQueuePresentKHR,
+
+    .p_wine_get_native_surface = X11DRV_wine_get_native_surface,
 };
 
 static void *X11DRV_get_vk_device_proc_addr(const char *name)
-- 
2.39.0.rc2

From e8b76ef81a9ac04f26938dbe781681683d5e2882 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Thu, 15 Sep 2022 10:30:34 -0300
Subject: [PATCH 161/202] winevulkan: Expose more functions and extensions to
 drivers.

This makes some Vulkan extensions available to driver and allows
them to override a few more Vulkan functions.

This will be needed by the Wine Wayland driver in the following commits,
in which we introduce support for cross-process Vulkan rendering.

Extensions:
    VK_EXT_external_memory_dma_buf
    VK_EXT_image_drm_format_modifier
    VK_KHR_external_fence_fd
    VK_KHR_external_memory_fd
    VK_KHR_external_semaphore_fd

Functions:
    vkCreateDevice
    vkDestroyDevice
    vkAcquireNextImageKHR

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winevulkan/make_vulkan     |  18 ++-
 dlls/winevulkan/vulkan_thunks.c | 266 ++++++++++++++++++++++++++++++--
 include/wine/vulkan.h           | 167 ++++++++++++++++++++
 include/wine/vulkan_driver.h    |   9 ++
 4 files changed, 443 insertions(+), 17 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 45418e362c5..2697a9b82a1 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -106,14 +106,9 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_NV_external_memory_rdma", # Needs shared resources work.
 
     # Extensions for other platforms
-    "VK_EXT_external_memory_dma_buf",
-    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_objects",
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
-    "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
-    "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
 
     # Extensions which require callback handling
@@ -129,6 +124,11 @@ UNSUPPORTED_EXTENSIONS = [
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
     "VK_KHR_external_memory_win32",
+    "VK_EXT_external_memory_dma_buf",
+    "VK_EXT_image_drm_format_modifier",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory_fd",
+    "VK_KHR_external_semaphore_fd",
 }
 
 # The Vulkan loader provides entry-points for core functionality and important
@@ -187,7 +187,7 @@ FUNCTION_OVERRIDES = {
     "vkGetInstanceProcAddr": {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
 
     # Instance functions
-    "vkCreateDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
+    "vkCreateDevice" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
     "vkDestroyInstance" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkEnumerateDeviceExtensionProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkEnumerateDeviceLayerProperties": {"dispatch": True, "driver": False, "thunk": ThunkType.NONE},
@@ -204,7 +204,7 @@ FUNCTION_OVERRIDES = {
     "vkAllocateCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkCreateCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
-    "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
+    "vkDestroyDevice" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetDeviceProcAddr" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
     "vkGetDeviceQueue" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -227,6 +227,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceWin32PresentationSupportKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
 
     # VK_KHR_swapchain
+    "vkAcquireNextImageKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
@@ -1901,7 +1902,8 @@ class VkStruct(Sequence):
         # Those structs seem to be broken in spec, they are specified as
         # returned only, but documented as input structs.
         if name in ["VkSubpassShadingPipelineCreateInfoHUAWEI",
-                    "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"]:
+                    "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo",
+                    "VkSubresourceLayout"]:
             returnedonly = False
 
         # Those structs don't have returnedonly in spec, but they could (should?).
diff --git a/dlls/winevulkan/vulkan_thunks.c b/dlls/winevulkan/vulkan_thunks.c
index dad8991e095..199606342bf 100644
--- a/dlls/winevulkan/vulkan_thunks.c
+++ b/dlls/winevulkan/vulkan_thunks.c
@@ -108,6 +108,14 @@ typedef struct VkExportMemoryWin32HandleInfoKHR32
     LPCWSTR name;
 } VkExportMemoryWin32HandleInfoKHR32;
 
+typedef struct VkImportMemoryFdInfoKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+} VkImportMemoryFdInfoKHR32;
+
 typedef struct VkMemoryAllocateFlagsInfo32
 {
     VkStructureType sType;
@@ -3202,6 +3210,15 @@ typedef struct VkGraphicsPipelineCreateInfo32
     int32_t basePipelineIndex;
 } VkGraphicsPipelineCreateInfo32;
 
+typedef struct VkSubresourceLayout32
+{
+    VkDeviceSize DECLSPEC_ALIGN(8) offset;
+    VkDeviceSize DECLSPEC_ALIGN(8) size;
+    VkDeviceSize DECLSPEC_ALIGN(8) rowPitch;
+    VkDeviceSize DECLSPEC_ALIGN(8) arrayPitch;
+    VkDeviceSize DECLSPEC_ALIGN(8) depthPitch;
+} VkSubresourceLayout32;
+
 typedef struct VkDedicatedAllocationImageCreateInfoNV32
 {
     VkStructureType sType;
@@ -3233,6 +3250,23 @@ typedef struct VkImageFormatListCreateInfo32
 } VkImageFormatListCreateInfo32;
 typedef VkImageFormatListCreateInfo32 VkImageFormatListCreateInfoKHR32;
 
+typedef struct VkImageDrmFormatModifierListCreateInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t drmFormatModifierCount;
+    PTR32 pDrmFormatModifiers;
+} VkImageDrmFormatModifierListCreateInfoEXT32;
+
+typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    PTR32 pPlaneLayouts;
+} VkImageDrmFormatModifierExplicitCreateInfoEXT32;
+
 typedef struct VkImageStencilUsageCreateInfo32
 {
     VkStructureType sType;
@@ -4246,15 +4280,6 @@ typedef struct VkImageSparseMemoryRequirementsInfo232
 } VkImageSparseMemoryRequirementsInfo232;
 typedef VkImageSparseMemoryRequirementsInfo232 VkImageSparseMemoryRequirementsInfo2KHR32;
 
-typedef struct VkSubresourceLayout32
-{
-    VkDeviceSize DECLSPEC_ALIGN(8) offset;
-    VkDeviceSize DECLSPEC_ALIGN(8) size;
-    VkDeviceSize DECLSPEC_ALIGN(8) rowPitch;
-    VkDeviceSize DECLSPEC_ALIGN(8) arrayPitch;
-    VkDeviceSize DECLSPEC_ALIGN(8) depthPitch;
-} VkSubresourceLayout32;
-
 typedef struct VkImageSubresource2EXT32
 {
     VkStructureType sType;
@@ -4400,6 +4425,28 @@ typedef struct VkExternalSemaphoreProperties32
 } VkExternalSemaphoreProperties32;
 typedef VkExternalSemaphoreProperties32 VkExternalSemaphorePropertiesKHR32;
 
+typedef struct VkDrmFormatModifierPropertiesEXT32
+{
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierPropertiesEXT32;
+
+typedef struct VkDrmFormatModifierProperties2EXT32
+{
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierProperties2EXT32;
+
+typedef struct VkDrmFormatModifierPropertiesListEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t drmFormatModifierCount;
+    PTR32 pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesListEXT32;
+
 typedef struct VkSubpassResolvePerformanceQueryEXT32
 {
     VkStructureType sType;
@@ -4417,6 +4464,14 @@ typedef struct VkFormatProperties332
 } VkFormatProperties332;
 typedef VkFormatProperties332 VkFormatProperties3KHR32;
 
+typedef struct VkDrmFormatModifierPropertiesList2EXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t drmFormatModifierCount;
+    PTR32 pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesList2EXT32;
+
 typedef struct VkFormatProperties232
 {
     VkStructureType sType;
@@ -4450,6 +4505,16 @@ typedef struct VkPhysicalDeviceExternalImageFormatInfo32
 } VkPhysicalDeviceExternalImageFormatInfo32;
 typedef VkPhysicalDeviceExternalImageFormatInfo32 VkPhysicalDeviceExternalImageFormatInfoKHR32;
 
+typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint64_t DECLSPEC_ALIGN(8) drmFormatModifier;
+    VkSharingMode sharingMode;
+    uint32_t queueFamilyIndexCount;
+    PTR32 pQueueFamilyIndices;
+} VkPhysicalDeviceImageDrmFormatModifierInfoEXT32;
+
 typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT32
 {
     VkStructureType sType;
@@ -6205,6 +6270,18 @@ static inline void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
+        {
+            VkImportMemoryFdInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImportMemoryFdInfoKHR32 *in_ext = (const VkImportMemoryFdInfoKHR32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+            out_ext->pNext = NULL;
+            out_ext->handleType = in_ext->handleType;
+            out_ext->fd = in_ext->fd;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
         {
             VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -14365,6 +14442,33 @@ static inline void convert_VkGraphicsPipelineCreateInfo_array_host_to_win32(cons
     }
 }
 
+static inline void convert_VkSubresourceLayout_win32_to_host(const VkSubresourceLayout32 *in, VkSubresourceLayout *out)
+{
+    if (!in) return;
+
+    out->offset = in->offset;
+    out->size = in->size;
+    out->rowPitch = in->rowPitch;
+    out->arrayPitch = in->arrayPitch;
+    out->depthPitch = in->depthPitch;
+}
+
+static inline const VkSubresourceLayout *convert_VkSubresourceLayout_array_win32_to_host(struct conversion_context *ctx, const VkSubresourceLayout32 *in, uint32_t count)
+{
+    VkSubresourceLayout *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        convert_VkSubresourceLayout_win32_to_host(&in[i], &out[i]);
+    }
+
+    return out;
+}
+
 static inline void convert_VkImageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, VkImageCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -14437,6 +14541,31 @@ static inline void convert_VkImageCreateInfo_win32_to_host(struct conversion_con
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
+        {
+            VkImageDrmFormatModifierListCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImageDrmFormatModifierListCreateInfoEXT32 *in_ext = (const VkImageDrmFormatModifierListCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->drmFormatModifierCount = in_ext->drmFormatModifierCount;
+            out_ext->pDrmFormatModifiers = (const uint64_t *)UlongToPtr(in_ext->pDrmFormatModifiers);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
+        {
+            VkImageDrmFormatModifierExplicitCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImageDrmFormatModifierExplicitCreateInfoEXT32 *in_ext = (const VkImageDrmFormatModifierExplicitCreateInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->drmFormatModifier = in_ext->drmFormatModifier;
+            out_ext->drmFormatModifierPlaneCount = in_ext->drmFormatModifierPlaneCount;
+            out_ext->pPlaneLayouts = convert_VkSubresourceLayout_array_win32_to_host(ctx, (const VkSubresourceLayout32 *)UlongToPtr(in_ext->pPlaneLayouts), in_ext->drmFormatModifierPlaneCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
         {
             VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -20815,6 +20944,68 @@ static inline void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysi
     }
 }
 
+static inline void convert_VkDrmFormatModifierPropertiesEXT_host_to_win32(const VkDrmFormatModifierPropertiesEXT *in, VkDrmFormatModifierPropertiesEXT32 *out)
+{
+    if (!in) return;
+
+    out->drmFormatModifier = in->drmFormatModifier;
+    out->drmFormatModifierPlaneCount = in->drmFormatModifierPlaneCount;
+    out->drmFormatModifierTilingFeatures = in->drmFormatModifierTilingFeatures;
+}
+
+static inline VkDrmFormatModifierPropertiesEXT *convert_VkDrmFormatModifierPropertiesEXT_array_win32_to_host(struct conversion_context *ctx, const VkDrmFormatModifierPropertiesEXT32 *in, uint32_t count)
+{
+    VkDrmFormatModifierPropertiesEXT *out;
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+
+    return out;
+}
+
+static inline void convert_VkDrmFormatModifierPropertiesEXT_array_host_to_win32(const VkDrmFormatModifierPropertiesEXT *in, VkDrmFormatModifierPropertiesEXT32 *out, uint32_t count)
+{
+    unsigned int i;
+
+    if (!in) return;
+
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDrmFormatModifierPropertiesEXT_host_to_win32(&in[i], &out[i]);
+    }
+}
+
+static inline void convert_VkDrmFormatModifierProperties2EXT_host_to_win32(const VkDrmFormatModifierProperties2EXT *in, VkDrmFormatModifierProperties2EXT32 *out)
+{
+    if (!in) return;
+
+    out->drmFormatModifier = in->drmFormatModifier;
+    out->drmFormatModifierPlaneCount = in->drmFormatModifierPlaneCount;
+    out->drmFormatModifierTilingFeatures = in->drmFormatModifierTilingFeatures;
+}
+
+static inline VkDrmFormatModifierProperties2EXT *convert_VkDrmFormatModifierProperties2EXT_array_win32_to_host(struct conversion_context *ctx, const VkDrmFormatModifierProperties2EXT32 *in, uint32_t count)
+{
+    VkDrmFormatModifierProperties2EXT *out;
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+
+    return out;
+}
+
+static inline void convert_VkDrmFormatModifierProperties2EXT_array_host_to_win32(const VkDrmFormatModifierProperties2EXT *in, VkDrmFormatModifierProperties2EXT32 *out, uint32_t count)
+{
+    unsigned int i;
+
+    if (!in) return;
+
+    for (i = 0; i < count; i++)
+    {
+        convert_VkDrmFormatModifierProperties2EXT_host_to_win32(&in[i], &out[i]);
+    }
+}
+
 static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_context *ctx, const VkFormatProperties232 *in, VkFormatProperties2 *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -20829,6 +21020,17 @@ static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_c
     {
         switch (in_header->sType)
         {
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
+        {
+            VkDrmFormatModifierPropertiesListEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDrmFormatModifierPropertiesListEXT32 *in_ext = (const VkDrmFormatModifierPropertiesListEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pDrmFormatModifierProperties = convert_VkDrmFormatModifierPropertiesEXT_array_win32_to_host(ctx, (VkDrmFormatModifierPropertiesEXT32 *)UlongToPtr(in_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
         {
             VkSubpassResolvePerformanceQueryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -20847,6 +21049,17 @@ static inline void convert_VkFormatProperties2_win32_to_host(struct conversion_c
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
+        {
+            VkDrmFormatModifierPropertiesList2EXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDrmFormatModifierPropertiesList2EXT32 *in_ext = (const VkDrmFormatModifierPropertiesList2EXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
+            out_ext->pNext = NULL;
+            out_ext->pDrmFormatModifierProperties = convert_VkDrmFormatModifierProperties2EXT_array_win32_to_host(ctx, (VkDrmFormatModifierProperties2EXT32 *)UlongToPtr(in_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         default:
             FIXME("Unhandled sType %u.", in_header->sType);
             break;
@@ -20867,6 +21080,16 @@ static inline void convert_VkFormatProperties2_host_to_win32(const VkFormatPrope
     {
         switch (in_header->sType)
         {
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
+        {
+            VkDrmFormatModifierPropertiesListEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT);
+            const VkDrmFormatModifierPropertiesListEXT *in_ext = (const VkDrmFormatModifierPropertiesListEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
+            out_ext->drmFormatModifierCount = in_ext->drmFormatModifierCount;
+            convert_VkDrmFormatModifierPropertiesEXT_array_host_to_win32(in_ext->pDrmFormatModifierProperties, (VkDrmFormatModifierPropertiesEXT32 *)UlongToPtr(out_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
         {
             VkSubpassResolvePerformanceQueryEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT);
@@ -20887,6 +21110,16 @@ static inline void convert_VkFormatProperties2_host_to_win32(const VkFormatPrope
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
+        {
+            VkDrmFormatModifierPropertiesList2EXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT);
+            const VkDrmFormatModifierPropertiesList2EXT *in_ext = (const VkDrmFormatModifierPropertiesList2EXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
+            out_ext->drmFormatModifierCount = in_ext->drmFormatModifierCount;
+            convert_VkDrmFormatModifierProperties2EXT_array_host_to_win32(in_ext->pDrmFormatModifierProperties, (VkDrmFormatModifierProperties2EXT32 *)UlongToPtr(out_ext->pDrmFormatModifierProperties), in_ext->drmFormatModifierCount);
+            out_header = (void *)out_ext;
+            break;
+        }
         default:
             break;
         }
@@ -20992,6 +21225,20 @@ static inline void convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(struct
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
+        {
+            VkPhysicalDeviceImageDrmFormatModifierInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkPhysicalDeviceImageDrmFormatModifierInfoEXT32 *in_ext = (const VkPhysicalDeviceImageDrmFormatModifierInfoEXT32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
+            out_ext->pNext = NULL;
+            out_ext->drmFormatModifier = in_ext->drmFormatModifier;
+            out_ext->sharingMode = in_ext->sharingMode;
+            out_ext->queueFamilyIndexCount = in_ext->queueFamilyIndexCount;
+            out_ext->pQueueFamilyIndices = (const uint32_t *)UlongToPtr(in_ext->pQueueFamilyIndices);
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
         {
             VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -36852,6 +37099,7 @@ static NTSTATUS thunk32_vkGetImageSubresourceLayout(void *args)
 
     TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);
 
+    convert_VkSubresourceLayout_win32_to_host((VkSubresourceLayout32 *)UlongToPtr(params->pLayout), &pLayout_host);
     wine_device_from_handle((VkDevice)UlongToPtr(params->device))->funcs.p_vkGetImageSubresourceLayout(wine_device_from_handle((VkDevice)UlongToPtr(params->device))->device, params->image, (const VkImageSubresource *)UlongToPtr(params->pSubresource), &pLayout_host);
     convert_VkSubresourceLayout_host_to_win32(&pLayout_host, (VkSubresourceLayout32 *)UlongToPtr(params->pLayout));
     return STATUS_SUCCESS;
diff --git a/include/wine/vulkan.h b/include/wine/vulkan.h
index fd24fe0fad3..e66c03d30f7 100644
--- a/include/wine/vulkan.h
+++ b/include/wine/vulkan.h
@@ -150,10 +150,14 @@
 #define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
+#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
 #define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
+#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
 #define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
 #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
 #define VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION 2
@@ -194,6 +198,8 @@
 #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
 #define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
+#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
 #define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
 #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
 #define VK_KHR_MAINTENANCE2_SPEC_VERSION VK_KHR_MAINTENANCE_2_SPEC_VERSION
@@ -204,6 +210,8 @@
 #define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"
 #define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
 #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
+#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
+#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
 #define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
@@ -248,6 +256,8 @@
 #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
 #define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
 #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
+#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 2
+#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
 #define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
 #define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
 #define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
@@ -1849,6 +1859,7 @@ typedef enum VkExternalMemoryHandleTypeFlagBits
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
@@ -2434,6 +2445,10 @@ typedef enum VkImageAspectFlagBits
     VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
     VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
     VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
     VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
     VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
     VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
@@ -2549,6 +2564,7 @@ typedef enum VkImageTiling
 {
     VK_IMAGE_TILING_OPTIMAL = 0,
     VK_IMAGE_TILING_LINEAR = 1,
+    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
     VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
 } VkImageTiling;
 
@@ -3420,6 +3436,7 @@ typedef enum VkResult
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
     VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
     VK_ERROR_FRAGMENTATION = -1000161000,
+    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
     VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
     VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
     VK_ERROR_INVALID_SHADER_NV = -1000012000,
@@ -3833,9 +3850,14 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
     VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
     VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
+    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
+    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
+    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
     VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
     VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
+    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
+    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
@@ -3867,6 +3889,8 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
     VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
     VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
+    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
+    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
@@ -3943,6 +3967,12 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
     VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
     VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
+    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
+    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
     VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
     VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
@@ -5805,6 +5835,36 @@ typedef struct VkDrawMeshTasksIndirectCommandNV
     uint32_t firstTask;
 } VkDrawMeshTasksIndirectCommandNV;
 
+typedef struct VkDrmFormatModifierProperties2EXT
+{
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags2 WINE_VK_ALIGN(8) drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierProperties2EXT;
+
+typedef struct VkDrmFormatModifierPropertiesEXT
+{
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierPropertiesEXT;
+
+typedef struct VkDrmFormatModifierPropertiesList2EXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t drmFormatModifierCount;
+    VkDrmFormatModifierProperties2EXT *pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesList2EXT;
+
+typedef struct VkDrmFormatModifierPropertiesListEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t drmFormatModifierCount;
+    VkDrmFormatModifierPropertiesEXT *pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesListEXT;
+
 typedef struct VkEventCreateInfo
 {
     VkStructureType sType;
@@ -5915,6 +5975,14 @@ typedef struct VkFenceCreateInfo
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo;
 
+typedef struct VkFenceGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence WINE_VK_ALIGN(8) fence;
+    VkExternalFenceHandleTypeFlagBits handleType;
+} VkFenceGetFdInfoKHR;
+
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
 {
     VkStructureType sType;
@@ -6089,6 +6157,21 @@ typedef struct VkImageCreateInfo
     VkImageLayout initialLayout;
 } VkImageCreateInfo;
 
+typedef struct VkImageDrmFormatModifierListCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t drmFormatModifierCount;
+    const uint64_t *pDrmFormatModifiers;
+} VkImageDrmFormatModifierListCreateInfoEXT;
+
+typedef struct VkImageDrmFormatModifierPropertiesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+} VkImageDrmFormatModifierPropertiesEXT;
+
 typedef struct VkImageFormatListCreateInfo
 {
     VkStructureType sType;
@@ -6243,6 +6326,24 @@ typedef struct VkImageViewUsageCreateInfo
 } VkImageViewUsageCreateInfo;
 typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;
 
+typedef struct VkImportFenceFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence WINE_VK_ALIGN(8) fence;
+    VkFenceImportFlags flags;
+    VkExternalFenceHandleTypeFlagBits handleType;
+    int fd;
+} VkImportFenceFdInfoKHR;
+
+typedef struct VkImportMemoryFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+} VkImportMemoryFdInfoKHR;
+
 typedef struct VkImportMemoryHostPointerInfoEXT
 {
     VkStructureType sType;
@@ -6260,6 +6361,16 @@ typedef struct VkImportMemoryWin32HandleInfoKHR
     LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR;
 
+typedef struct VkImportSemaphoreFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore WINE_VK_ALIGN(8) semaphore;
+    VkSemaphoreImportFlags flags;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+    int fd;
+} VkImportSemaphoreFdInfoKHR;
+
 typedef struct VkIndirectCommandsLayoutTokenNV
 {
     VkStructureType sType;
@@ -6383,6 +6494,21 @@ typedef struct VkMemoryDedicatedRequirements
 } VkMemoryDedicatedRequirements;
 typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;
 
+typedef struct VkMemoryFdPropertiesKHR
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t memoryTypeBits;
+} VkMemoryFdPropertiesKHR;
+
+typedef struct VkMemoryGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkDeviceMemory WINE_VK_ALIGN(8) memory;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+} VkMemoryGetFdInfoKHR;
+
 typedef struct VkMemoryGetWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -7523,6 +7649,16 @@ typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
     VkBool32 imageCompressionControlSwapchain;
 } VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
 
+typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    VkSharingMode sharingMode;
+    uint32_t queueFamilyIndexCount;
+    const uint32_t *pQueueFamilyIndices;
+} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
+
 typedef struct VkPhysicalDeviceImageFormatInfo2
 {
     VkStructureType sType;
@@ -9847,6 +9983,14 @@ typedef struct VkSemaphoreCreateInfo
     VkSemaphoreCreateFlags flags;
 } VkSemaphoreCreateInfo;
 
+typedef struct VkSemaphoreGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore WINE_VK_ALIGN(8) semaphore;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+} VkSemaphoreGetFdInfoKHR;
+
 typedef struct VkSemaphoreSignalInfo
 {
     VkStructureType sType;
@@ -10862,6 +11006,15 @@ typedef struct VkImageCopy2
 } VkImageCopy2;
 typedef VkImageCopy2 VkImageCopy2KHR;
 
+typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    const VkSubresourceLayout *pPlaneLayouts;
+} VkImageDrmFormatModifierExplicitCreateInfoEXT;
+
 typedef struct VkImageMemoryBarrier
 {
     VkStructureType sType;
@@ -11843,9 +11996,11 @@ typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue2)(VkDevice, const VkDeviceQueueInf
 typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)(VkDevice, VkRenderPass, VkExtent2D *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice, const VkRenderingInfo *, VkTilePropertiesQCOM *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice, VkEvent);
+typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice, VkFence);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV *, VkMemoryRequirements2 *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice, VkImage, VkMemoryRequirements *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
@@ -11859,6 +12014,8 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewAddressNVX)(VkDevice, VkImageView
 typedef uint32_t (VKAPI_PTR *PFN_vkGetImageViewHandleNVX)(VkDevice, const VkImageViewHandleInfoNVX *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)(VkDevice, const VkImageViewCaptureDescriptorDataInfoEXT *, void *);
 typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance, const char *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice, const VkMemoryGetFdInfoKHR *, int *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, int, VkMemoryFdPropertiesKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryHostPointerPropertiesEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice, const VkMemoryGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, VkMemoryWin32HandlePropertiesKHR *);
@@ -11926,11 +12083,14 @@ typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice, VkRenderPass,
 typedef VkResult (VKAPI_PTR *PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)(VkDevice, const VkSamplerCaptureDescriptorDataInfoEXT *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice, VkSemaphore, uint64_t *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice, VkSemaphore, uint64_t *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice, const VkSemaphoreGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, size_t *, void *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice, const VkShaderModuleCreateInfo *, VkShaderModuleIdentifierEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleIdentifierEXT)(VkDevice, VkShaderModule, VkShaderModuleIdentifierEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
+typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR *);
+typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
 typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice, uint32_t, const VkMappedMemoryRange *);
 typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, void **);
@@ -12376,9 +12536,11 @@ void VKAPI_CALL vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQu
 VkResult VKAPI_CALL vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize);
 VkResult VKAPI_CALL vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties);
 VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event);
+VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence);
 VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties);
 void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
@@ -12392,6 +12554,8 @@ VkResult VKAPI_CALL vkGetImageViewAddressNVX(VkDevice device, VkImageView imageV
 uint32_t VKAPI_CALL vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo);
 VkResult VKAPI_CALL vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(VkInstance instance, const char *pName);
+VkResult VKAPI_CALL vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd);
+VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties);
 VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties);
 VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties);
@@ -12459,11 +12623,14 @@ void VKAPI_CALL vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderP
 VkResult VKAPI_CALL vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
+VkResult VKAPI_CALL vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo);
 void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier);
 void VKAPI_CALL vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier);
 VkResult VKAPI_CALL vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages);
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
+VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo);
+VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo);
 VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo);
 VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges);
 VkResult VKAPI_CALL vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData);
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index f5269d554fb..99d301061aa 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,9 +21,12 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
+    VkResult (*p_vkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
+    void (*p_vkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
     void (*p_vkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
     void (*p_vkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
     void (*p_vkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
@@ -55,8 +58,12 @@ static inline void *get_vulkan_driver_device_proc_addr(
 
     name += 2;
 
+    if (!strcmp(name, "AcquireNextImageKHR"))
+        return vulkan_funcs->p_vkAcquireNextImageKHR;
     if (!strcmp(name, "CreateSwapchainKHR"))
         return vulkan_funcs->p_vkCreateSwapchainKHR;
+    if (!strcmp(name, "DestroyDevice"))
+        return vulkan_funcs->p_vkDestroyDevice;
     if (!strcmp(name, "DestroySwapchainKHR"))
         return vulkan_funcs->p_vkDestroySwapchainKHR;
     if (!strcmp(name, "GetDeviceGroupSurfacePresentModesKHR"))
@@ -85,6 +92,8 @@ static inline void *get_vulkan_driver_instance_proc_addr(
 
     if (!instance) return NULL;
 
+    if (!strcmp(name, "CreateDevice"))
+        return vulkan_funcs->p_vkCreateDevice;
     if (!strcmp(name, "CreateWin32SurfaceKHR"))
         return vulkan_funcs->p_vkCreateWin32SurfaceKHR;
     if (!strcmp(name, "DestroyInstance"))
-- 
2.39.0.rc2

From 04bddefbd8373d3f5f2ca7cefbd4093ce08827a3 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 3 Aug 2022 11:37:19 -0300
Subject: [PATCH 162/202] winewayland.drv: Bind to wl_compositor interface in
 the per-process instance.

In the following commits we'll introduce an internal swapchain in order
to support Vulkan cross-process rendering. In order to do that, we'll
need to create wl_surface objects from the per-process instance. So bind
to wl_compositor on the per-process instance as well.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/wayland.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index edcaf44fb26..e0717acfe0d 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -245,17 +245,17 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
                              version < 4 ? version : 4);
         wayland_dmabuf_init(&wayland->dmabuf, zwp_linux_dmabuf_v1);
     }
+    else if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
 
     /* The per-process wayland instance should not handle every global, as there
      * is no point. Many globals are only needed by the per-thread instances. */
     if (wayland_is_process(wayland)) return;
 
-    if (strcmp(interface, "wl_compositor") == 0)
-    {
-        wayland->wl_compositor =
-            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
-    }
-    else if (strcmp(interface, "wl_subcompositor") == 0)
+    if (strcmp(interface, "wl_subcompositor") == 0)
     {
         wayland->wl_subcompositor =
             wl_registry_bind(registry, id, &wl_subcompositor_interface, 1);
-- 
2.39.0.rc2

From 92dd1f8883d541d89a5b9ddfdf87d2a895038e63 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Tue, 2 Aug 2022 12:28:57 -0300
Subject: [PATCH 163/202] winewayland.drv: Implement vkCreateDevice and
 vkDestroyDevice.

Implement vkCreateDevice and vkDestroyDevice so that:

1. We can track the mapping between physical and logical Vulkan devices.
2. We can enable some additional host VkDevice extensions.

Both of the above are required to support cross-process rendering in
upcoming commits.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 139 ++++++++++++++++++++++++++++++++++
 1 file changed, 139 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 6400f91453d..a63fb2fcf8f 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -54,9 +54,11 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
     struct wl_surface *surface;
 } VkWaylandSurfaceCreateInfoKHR;
 
+static VkResult (*pvkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
+static void(*pvkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
@@ -84,9 +86,17 @@ static struct wayland_mutex wine_vk_object_mutex =
 
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
 static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
+static struct wl_list wine_vk_device_list = { &wine_vk_device_list, &wine_vk_device_list };
 
 static const struct vulkan_funcs vulkan_funcs;
 
+struct wine_vk_device
+{
+    struct wl_list link;
+    VkDevice dev;
+    VkPhysicalDevice phys_dev;
+};
+
 struct wine_vk_surface
 {
     struct wl_list link;
@@ -255,6 +265,114 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src,
+                                                   VkDeviceCreateInfo *dst)
+{
+    unsigned int i;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+    dst->pEnabledFeatures = src->pEnabledFeatures;
+    dst->pQueueCreateInfos = src->pQueueCreateInfos;
+    dst->queueCreateInfoCount = src->queueCreateInfoCount;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions = calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+            enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = src->enabledExtensionCount;
+    }
+
+    return VK_SUCCESS;
+}
+
+static struct wine_vk_device *wine_vk_device_from_handle(VkDevice handle)
+{
+    struct wine_vk_device *wine_vk_device;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(wine_vk_device, &wine_vk_device_list, link)
+        if (wine_vk_device->dev == handle) goto out;
+
+    wine_vk_device = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return wine_vk_device;
+}
+
+static void wine_vk_device_destroy(struct wine_vk_device *wine_vk_device)
+{
+    wine_vk_list_remove(&wine_vk_device->link);
+    free(wine_vk_device);
+}
+
+static VkResult wayland_vkCreateDevice(VkPhysicalDevice physical_device,
+                                       const VkDeviceCreateInfo *create_info,
+                                       const VkAllocationCallbacks *allocator,
+                                       VkDevice *device)
+{
+    VkDeviceCreateInfo create_info_host = {0};
+    VkResult res;
+    struct wine_vk_device *wine_vk_device;
+
+    TRACE("%p %p %p %p\n", physical_device, create_info, allocator, device);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_device = calloc(1, sizeof(*wine_vk_device));
+    if (!wine_vk_device)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    res = wine_vk_device_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    res = pvkCreateDevice(physical_device, &create_info_host, NULL /* allocator */, device);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create VkDevice, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_device->dev = *device;
+    wine_vk_device->phys_dev = physical_device;
+
+    wl_list_init(&wine_vk_device->link);
+
+    wine_vk_list_add(&wine_vk_device_list, &wine_vk_device->link);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+
+err:
+    ERR("Failed to create VkDevice\n");
+    free(wine_vk_device);
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
 static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
                                              const VkSwapchainCreateInfoKHR *create_info,
                                              const VkAllocationCallbacks *allocator,
@@ -426,6 +544,23 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static void wayland_vkDestroyDevice(VkDevice device,
+                                    const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_device *wine_vk_device = wine_vk_device_from_handle(device);
+
+    TRACE("%p %p\n", device, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_device)
+    {
+        pvkDestroyDevice(device, NULL /* allocator */);
+        wine_vk_device_destroy(wine_vk_device);
+    }
+}
+
 static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer_name,
                                                                uint32_t *count,
                                                                VkExtensionProperties* properties)
@@ -828,9 +963,11 @@ static void wine_vk_init(void)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
 #define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkCreateDevice);
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
+    LOAD_FUNCPTR(vkDestroyDevice);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
@@ -860,9 +997,11 @@ fail:
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    .p_vkCreateDevice = wayland_vkCreateDevice,
     .p_vkCreateInstance = wayland_vkCreateInstance,
     .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
+    .p_vkDestroyDevice = wayland_vkDestroyDevice,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
-- 
2.39.0.rc2

From 31dcd7af20bae7a3524597da2f668a1be29e78ab Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Thu, 22 Sep 2022 11:30:23 +0300
Subject: [PATCH 164/202] winewayland.drv: Introduce mechanism to enable
 required VkDevice extensions.

Introduce a mechanism to check and enable VkDevice extensions required
to support cross-process rendering in upcoming commits.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 95 ++++++++++++++++++++++++++++++++---
 1 file changed, 89 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index a63fb2fcf8f..36de3f56357 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -62,6 +62,7 @@ static void(*pvkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkEnumerateDeviceExtensionProperties)(VkPhysicalDevice, const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
@@ -90,11 +91,18 @@ static struct wl_list wine_vk_device_list = { &wine_vk_device_list, &wine_vk_dev
 
 static const struct vulkan_funcs vulkan_funcs;
 
+/* These device extensions are required to support Vulkan remote. Some of them
+ * might not be supported by the device, so we must check. */
+const static char *device_extensions_remote_vulkan[] =
+{
+};
+
 struct wine_vk_device
 {
     struct wl_list link;
     VkDevice dev;
     VkPhysicalDevice phys_dev;
+    BOOL supports_remote_vulkan;
 };
 
 struct wine_vk_surface
@@ -188,6 +196,32 @@ out:
     return swap;
 }
 
+static BOOL vk_extension_props_contain_all(uint32_t count_props,
+                                           VkExtensionProperties *props,
+                                           uint32_t count_required,
+                                           const char * const *required)
+{
+    BOOL supported;
+    unsigned int i, j;
+
+    for (i = 0; i < count_required; i++)
+    {
+        supported = FALSE;
+        for (j = 0; j < count_props; j++)
+        {
+            if (strcmp(props[j].extensionName, required[i]) == 0)
+            {
+                supported = TRUE;
+                break;
+            }
+        }
+        if (!supported)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -265,10 +299,12 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
-static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src,
+static VkResult wine_vk_device_convert_create_info(struct wine_vk_device *wine_vk_device,
+                                                   const VkDeviceCreateInfo *src,
                                                    VkDeviceCreateInfo *dst)
 {
-    unsigned int i;
+    unsigned int i, j;
+    uint32_t enabled_extensions_count;
     const char **enabled_extensions = NULL;
 
     dst->sType = src->sType;
@@ -284,21 +320,37 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
 
     if (src->enabledExtensionCount > 0)
     {
-        enabled_extensions = calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        enabled_extensions_count = src->enabledExtensionCount;
+        if (wine_vk_device->supports_remote_vulkan)
+            enabled_extensions_count += ARRAY_SIZE(device_extensions_remote_vulkan);
+
+        enabled_extensions = calloc(enabled_extensions_count, sizeof(*src->ppEnabledExtensionNames));
         if (!enabled_extensions)
         {
             ERR("Failed to allocate memory for enabled extensions\n");
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
         }
 
         for (i = 0; i < src->enabledExtensionCount; i++)
             enabled_extensions[i] = src->ppEnabledExtensionNames[i];
 
+        if (wine_vk_device->supports_remote_vulkan)
+        {
+            /* Add the extensions required to support remote Vulkan */
+            for (j = 0; j < ARRAY_SIZE(device_extensions_remote_vulkan); j++, i++)
+                enabled_extensions[i] = device_extensions_remote_vulkan[j];
+        }
+
         dst->ppEnabledExtensionNames = enabled_extensions;
-        dst->enabledExtensionCount = src->enabledExtensionCount;
+        dst->enabledExtensionCount = enabled_extensions_count;
     }
 
     return VK_SUCCESS;
+
+err:
+    ERR("Failed to convert device create info\n");
+    free(enabled_extensions);
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
 
 static struct wine_vk_device *wine_vk_device_from_handle(VkDevice handle)
@@ -331,6 +383,8 @@ static VkResult wayland_vkCreateDevice(VkPhysicalDevice physical_device,
     VkDeviceCreateInfo create_info_host = {0};
     VkResult res;
     struct wine_vk_device *wine_vk_device;
+    VkExtensionProperties *props = NULL;
+    uint32_t count_props;
 
     TRACE("%p %p %p %p\n", physical_device, create_info, allocator, device);
 
@@ -345,7 +399,35 @@ static VkResult wayland_vkCreateDevice(VkPhysicalDevice physical_device,
         goto err;
     }
 
-    res = wine_vk_device_convert_create_info(create_info, &create_info_host);
+    res = pvkEnumerateDeviceExtensionProperties(physical_device, NULL, &count_props, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateDeviceExtensionProperties failed, res=%d\n", res);
+        goto err;
+    }
+    props = calloc(count_props, sizeof(*props));
+    if (!props)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+    res = pvkEnumerateDeviceExtensionProperties(physical_device, NULL, &count_props, props);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateDeviceExtensionProperties failed, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_device->supports_remote_vulkan =
+        vk_extension_props_contain_all(count_props, props,
+                                       ARRAY_SIZE(device_extensions_remote_vulkan),
+                                       device_extensions_remote_vulkan);
+
+    free(props);
+    props = NULL;
+
+    res = wine_vk_device_convert_create_info(wine_vk_device, create_info, &create_info_host);
     if (res != VK_SUCCESS)
         goto err;
 
@@ -971,6 +1053,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkEnumerateDeviceExtensionProperties);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
-- 
2.39.0.rc2

From cf077fc330b036f7b2777f2a7abe88cc090e4eca Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Thu, 22 Sep 2022 19:15:46 +0300
Subject: [PATCH 165/202] winewayland.drv: Introduce mechanism to enable
 required VkInstance extensions.

Introduce a mechanism to check and enable VkInstance extensions required
to support cross-process rendering in upcoming commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 79 ++++++++++++++++++++++++++++++++---
 1 file changed, 73 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 36de3f56357..e697afc5173 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -91,6 +91,12 @@ static struct wl_list wine_vk_device_list = { &wine_vk_device_list, &wine_vk_dev
 
 static const struct vulkan_funcs vulkan_funcs;
 
+/* These instance extensions are required to support Vulkan remote. Some of them
+ * might not be supported by the device, so we must check. */
+const static char *instance_extensions_remote_vulkan[] =
+{
+};
+
 /* These device extensions are required to support Vulkan remote. Some of them
  * might not be supported by the device, so we must check. */
 const static char *device_extensions_remote_vulkan[] =
@@ -222,13 +228,55 @@ static BOOL vk_extension_props_contain_all(uint32_t count_props,
     return TRUE;
 }
 
+static BOOL vulkan_instance_supports(size_t num_exts, const char **exts)
+{
+    VkExtensionProperties *props = NULL;
+    uint32_t count_props;
+    VkResult vk_res;
+    BOOL res = TRUE;
+
+    vk_res = pvkEnumerateInstanceExtensionProperties(NULL, &count_props, NULL);
+    if (vk_res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateInstanceExtensionProperties failed, res=%d\n", vk_res);
+        res = FALSE;
+        goto out;
+    }
+    props = calloc(count_props, sizeof(*props));
+    if (!props)
+    {
+        ERR("Failed to allocate memory\n");
+        res = FALSE;
+        goto out;
+    }
+    vk_res = pvkEnumerateInstanceExtensionProperties(NULL, &count_props, props);
+    if (vk_res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateInstanceExtensionProperties failed, res=%d\n", vk_res);
+        res = FALSE;
+        goto out;
+    }
+
+    /* These extensions are required to support the remote Vulkan, but may
+     * not be present. */
+    res = vk_extension_props_contain_all(count_props, props, num_exts, exts);
+
+out:
+    free(props);
+    return res;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
 static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
                                                      VkInstanceCreateInfo *dst)
 {
-    unsigned int i;
+    BOOL supports_remote_vulkan =
+        vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                            instance_extensions_remote_vulkan);
+    unsigned int i, j;
+    uint32_t enabled_extensions_count;
     const char **enabled_extensions = NULL;
 
     dst->sType = src->sType;
@@ -242,11 +290,15 @@ static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo
 
     if (src->enabledExtensionCount > 0)
     {
-        enabled_extensions = calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        enabled_extensions_count = src->enabledExtensionCount;
+        if (supports_remote_vulkan)
+            enabled_extensions_count += ARRAY_SIZE(instance_extensions_remote_vulkan);
+
+        enabled_extensions = calloc(enabled_extensions_count, sizeof(*src->ppEnabledExtensionNames));
         if (!enabled_extensions)
         {
             ERR("Failed to allocate memory for enabled extensions\n");
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
         }
 
         for (i = 0; i < src->enabledExtensionCount; i++)
@@ -259,11 +311,24 @@ static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo
             else
                 enabled_extensions[i] = src->ppEnabledExtensionNames[i];
         }
-        dst->ppEnabledExtensionNames = enabled_extensions;
-        dst->enabledExtensionCount = src->enabledExtensionCount;
+
+        if (supports_remote_vulkan)
+        {
+            /* Add the extensions required to support remote Vulkan */
+            for (j = 0; j < ARRAY_SIZE(instance_extensions_remote_vulkan); j++, i++)
+                enabled_extensions[i] = instance_extensions_remote_vulkan[j];
+        }
+
+         dst->ppEnabledExtensionNames = enabled_extensions;
+         dst->enabledExtensionCount = enabled_extensions_count;
     }
 
     return VK_SUCCESS;
+
+err:
+    ERR("Failed to convert instance create info\n");
+    free(enabled_extensions);
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
 
 #define RETURN_VK_ERROR_SURFACE_LOST_KHR { \
@@ -422,7 +487,9 @@ static VkResult wayland_vkCreateDevice(VkPhysicalDevice physical_device,
     wine_vk_device->supports_remote_vulkan =
         vk_extension_props_contain_all(count_props, props,
                                        ARRAY_SIZE(device_extensions_remote_vulkan),
-                                       device_extensions_remote_vulkan);
+                                       device_extensions_remote_vulkan) &&
+        vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                 instance_extensions_remote_vulkan);
 
     free(props);
     props = NULL;
-- 
2.39.0.rc2

From c2067b18be42932efe515a11d74eac2e80cbedf7 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 21 Sep 2022 12:07:47 +0300
Subject: [PATCH 166/202] winewayland.drv: Implement cross-process
 vkCreateWin32SurfaceKHR.

When the target window for a Win32 VkSurfaceKHR is not owned by the
current process, we don't have access to the corresponding wayland
surface to use as the target for creating the host VkSurfaceKHR. In such
cases create a dummy wl_surface and use it to allow VkSurfaceKHR to
conclude successfully.

Note that no content targeting this dummy wl_surface will ever become
visible, but we will fix this in upcoming commits when we introduce a
cross-process swapchain implementation that forwards images to the right
process for presentation.

For now the cross-process code path is not used (notice the constant
allowed_to_create_remote_swapchain in the code), because we still don't
have all the pieces to make the cross-process swapchain work. So we
won't even allow the dummy wl_surface to be created. When we put all the
pieces together, we'll drop this constant and allow the code to run.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 60 +++++++++++++++++++++++++++--------
 1 file changed, 46 insertions(+), 14 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index e697afc5173..ba8d8fe7de2 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -45,6 +45,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
 
+/* This is temporary until we fully support remote (cross-process) Vulkan
+ * rendering, as we are progressively adding commits that add the support. */
+static const BOOL remote_rendering_supported = FALSE;
+
 typedef struct VkWaylandSurfaceCreateInfoKHR
 {
     VkStructureType sType;
@@ -116,6 +120,9 @@ struct wine_vk_surface
     struct wl_list link;
     HWND hwnd;
     struct wayland_surface *wayland_surface;
+    /* Used when we are rendering cross-process and we don't have the real
+     * wayland surface available. */
+    struct wl_surface *dummy_wl_surface;
     VkSurfaceKHR native_vk_surface;
     BOOL valid;
 };
@@ -150,6 +157,8 @@ static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
 
     if (wine_vk_surface->wayland_surface)
         wayland_surface_unref_glvk(wine_vk_surface->wayland_surface);
+    if (wine_vk_surface->dummy_wl_surface)
+        wl_surface_destroy(wine_vk_surface->dummy_wl_surface);
 
     free(wine_vk_surface);
 }
@@ -599,31 +608,54 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
     wl_list_init(&wine_vk_surface->link);
 
     wayland_surface = wayland_surface_for_hwnd_lock(create_info->hwnd);
-    if (!wayland_surface)
+    if (wayland_surface)
     {
-        ERR("Failed to find wayland surface for hwnd=%p\n", create_info->hwnd);
-        /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
-        res = VK_ERROR_OUT_OF_HOST_MEMORY;
-        goto err;
+        ref_vk = wayland_surface_create_or_ref_glvk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_vk)
+        {
+            ERR("Failed to create or ref vulkan surface for hwnd=%p\n", create_info->hwnd);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_surface->wayland_surface = wayland_surface;
     }
-
-    ref_vk = wayland_surface_create_or_ref_glvk(wayland_surface);
-    wayland_surface_for_hwnd_unlock(wayland_surface);
-    if (!ref_vk)
+    else if (remote_rendering_supported)
     {
-        ERR("Failed to create or ref vulkan surface for hwnd=%p\n", create_info->hwnd);
-        /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
+        struct wayland *wayland;
+        if (!vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                      instance_extensions_remote_vulkan))
+        {
+            ERR("Failed to create remote Vulkan surface, required extensions " \
+                "not supported by VkInstance %p\n", instance);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wayland = wayland_process_acquire();
+        wine_vk_surface->dummy_wl_surface =
+            wl_compositor_create_surface(wayland->wl_compositor);
+        wayland_process_release();
+        if (!wine_vk_surface->dummy_wl_surface)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+    else
+    {
+        ERR("Failed to create surface, cross-process Vulkan rendering not supported yet\n");
         res = VK_ERROR_OUT_OF_HOST_MEMORY;
         goto err;
     }
 
-    wine_vk_surface->wayland_surface = wayland_surface;
-
     create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
     create_info_host.flags = 0; /* reserved */
     create_info_host.display = process_wl_display;
-    create_info_host.surface = wayland_surface->glvk->wl_surface;
+    if (wine_vk_surface->wayland_surface)
+        create_info_host.surface = wine_vk_surface->wayland_surface->glvk->wl_surface;
+    else
+        create_info_host.surface = wine_vk_surface->dummy_wl_surface;
 
     res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host, NULL /* allocator */, vk_surface);
     if (res != VK_SUCCESS)
-- 
2.39.0.rc2

From 20911e4d52e7f85df2c04d5e0e6e49567127b2ca Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 21 Sep 2022 12:41:46 +0300
Subject: [PATCH 167/202] winewayland.drv: Implement cross-process
 vkCreateSwapchainKHR.

Introduce the remote swapchain object, currently with a stub
implementation, that we are going to use for cross-process Vulkan
rendering.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in     |  1 +
 dlls/winewayland.drv/vulkan.c        | 37 ++++++++++++++++-
 dlls/winewayland.drv/vulkan_remote.c | 61 ++++++++++++++++++++++++++++
 dlls/winewayland.drv/vulkan_remote.h | 37 +++++++++++++++++
 4 files changed, 135 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/vulkan_remote.c
 create mode 100644 dlls/winewayland.drv/vulkan_remote.h

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 76e64602c4a..4e3cc595109 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -15,6 +15,7 @@ C_SRCS = \
 	registry.c \
 	unicode.c \
 	vulkan.c \
+	vulkan_remote.c \
 	wayland.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index ba8d8fe7de2..dbc9ad6b7b2 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -35,6 +35,7 @@
 
 #include "wine/vulkan.h"
 #include "wine/vulkan_driver.h"
+#include "vulkan_remote.h"
 
 #include <dlfcn.h>
 #include <stdlib.h>
@@ -135,6 +136,8 @@ struct wine_vk_swapchain
     VkSwapchainKHR native_vk_swapchain;
     VkExtent2D extent;
     BOOL valid;
+    /* Only used for cross-process Vulkan rendering apps. */
+    struct wayland_remote_vk_swapchain *remote_vk_swapchain;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -192,6 +195,9 @@ static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchai
     if (wine_vk_swapchain->wayland_surface)
         wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
 
+    if (wine_vk_swapchain->remote_vk_swapchain)
+        wayland_remote_vk_swapchain_destroy(wine_vk_swapchain->remote_vk_swapchain);
+
     free(wine_vk_swapchain);
 }
 
@@ -537,6 +543,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
                                              VkSwapchainKHR *swapchain)
 {
     VkResult res;
+    struct wine_vk_device *wine_vk_device;
     struct wine_vk_surface *wine_vk_surface;
     struct wine_vk_swapchain *wine_vk_swapchain;
     VkSwapchainCreateInfoKHR info = *create_info;
@@ -552,6 +559,10 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
     if (info.imageExtent.height == 0)
         info.imageExtent.height = 1;
 
+    wine_vk_device = wine_vk_device_from_handle(device);
+    if (!wine_vk_device)
+        return VK_ERROR_DEVICE_LOST;
+
     wine_vk_surface = wine_vk_surface_from_handle(info.surface);
     if (!wine_vk_surface || !__atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST))
         RETURN_VK_ERROR_SURFACE_LOST_KHR;
@@ -569,9 +580,33 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
     wine_vk_swapchain->hwnd = wine_vk_surface->hwnd;
     if (wine_vk_surface->wayland_surface)
     {
-        wayland_surface_create_or_ref_glvk(wine_vk_surface->wayland_surface);
+        if (!wayland_surface_create_or_ref_glvk(wine_vk_surface->wayland_surface))
+        {
+            ERR("Failed to create or ref vulkan surface owned by " \
+                "wine_vk_surface=%p\n", wine_vk_surface);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
         wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
     }
+    else
+    {
+        if (!wine_vk_device->supports_remote_vulkan)
+        {
+            ERR("Failed to create remote Vulkan swapchain, required extensions " \
+                "not supported by VkDevice %p\n", wine_vk_device->dev);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->remote_vk_swapchain =
+            wayland_remote_vk_swapchain_create(wine_vk_swapchain->hwnd);
+        if (!wine_vk_swapchain->remote_vk_swapchain)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
     wine_vk_swapchain->extent = info.imageExtent;
     wine_vk_swapchain->valid = TRUE;
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
new file mode 100644
index 00000000000..f4796c8f9a8
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -0,0 +1,61 @@
+/* WAYLANDDRV Vulkan remote implementation
+ *
+ * Copyright 2022 Leandro Ribeiro
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+struct wayland_remote_vk_swapchain
+{
+};
+
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain)
+{
+    free(swapchain);
+}
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd)
+{
+    struct wayland_remote_vk_swapchain *swapchain;
+
+    swapchain = calloc(1, sizeof(*swapchain));
+    if (!swapchain)
+    {
+        ERR("Failed to allocate memory\n");
+        goto err;
+    }
+
+    return swapchain;
+
+err:
+    ERR("Failed to create remote swapchain\n");
+    if (swapchain)
+        wayland_remote_vk_swapchain_destroy(swapchain);
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
new file mode 100644
index 00000000000..0f5bef740a5
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -0,0 +1,37 @@
+/* WAYLANDDRV Vulkan remote implementation
+ *
+ * Copyright 2022 Leandro Ribeiro
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_VULKAN_REMOTE_H
+#define __WINE_WAYLANDDRV_VULKAN_REMOTE_H
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+
+struct wayland_remote_vk_swapchain;
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
-- 
2.39.0.rc2

From d1c37342bff14ca6ccd46746721810a97b17832f Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 21 Sep 2022 13:37:36 +0300
Subject: [PATCH 168/202] winewayland.drv: Implement cross-process
 vkGetSwapchainImagesKHR.

Create images to be used for cross-process Vulkan rendering, and
return them through vkGetSwapchainImagesKHR.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c        |  25 ++-
 dlls/winewayland.drv/vulkan_remote.c | 294 ++++++++++++++++++++++++++-
 dlls/winewayland.drv/vulkan_remote.h |  14 +-
 3 files changed, 325 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index dbc9ad6b7b2..a98ff5dfdde 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -120,6 +120,7 @@ struct wine_vk_surface
 {
     struct wl_list link;
     HWND hwnd;
+    VkInstance instance;
     struct wayland_surface *wayland_surface;
     /* Used when we are rendering cross-process and we don't have the real
      * wayland surface available. */
@@ -132,6 +133,7 @@ struct wine_vk_swapchain
 {
     struct wl_list link;
     HWND hwnd;
+    struct wine_vk_device *wine_vk_device;
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
     VkExtent2D extent;
@@ -196,7 +198,8 @@ static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchai
         wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
 
     if (wine_vk_swapchain->remote_vk_swapchain)
-        wayland_remote_vk_swapchain_destroy(wine_vk_swapchain->remote_vk_swapchain);
+        wayland_remote_vk_swapchain_destroy(wine_vk_swapchain->remote_vk_swapchain,
+                                            wine_vk_swapchain->wine_vk_device->dev);
 
     free(wine_vk_swapchain);
 }
@@ -217,6 +220,11 @@ out:
     return swap;
 }
 
+static BOOL wine_vk_swapchain_is_remote(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    return wine_vk_swapchain && wine_vk_swapchain->remote_vk_swapchain;
+}
+
 static BOOL vk_extension_props_contain_all(uint32_t count_props,
                                            VkExtensionProperties *props,
                                            uint32_t count_required,
@@ -599,7 +607,12 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
             goto err;
         }
         wine_vk_swapchain->remote_vk_swapchain =
-            wayland_remote_vk_swapchain_create(wine_vk_swapchain->hwnd);
+            wayland_remote_vk_swapchain_create(wine_vk_swapchain->hwnd,
+                                               wine_vk_surface->instance,
+                                               wine_vk_device->phys_dev,
+                                               wine_vk_device->dev,
+                                               &vulkan_funcs,
+                                               &info);
         if (!wine_vk_swapchain->remote_vk_swapchain)
         {
             res = VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -607,6 +620,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         }
     }
 
+    wine_vk_swapchain->wine_vk_device = wine_vk_device;
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
     wine_vk_swapchain->extent = info.imageExtent;
     wine_vk_swapchain->valid = TRUE;
@@ -700,6 +714,7 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
     }
 
     wine_vk_surface->hwnd = create_info->hwnd;
+    wine_vk_surface->instance = instance;
     wine_vk_surface->native_vk_surface = *vk_surface;
     wine_vk_surface->valid = TRUE;
 
@@ -1062,8 +1077,14 @@ static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysica
 static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
                                                 uint32_t *count, VkImage *images)
 {
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
     TRACE("%p, 0x%s %p %p\n", device, wine_dbgstr_longlong(swapchain), count, images);
 
+    if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        return wayland_remote_vk_swapchain_get_images(wine_vk_swapchain->remote_vk_swapchain,
+                                                      count, images);
+
     return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
 }
 
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
index f4796c8f9a8..9cff6d33d26 100644
--- a/dlls/winewayland.drv/vulkan_remote.c
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -27,22 +27,248 @@
 
 #include "wine/debug.h"
 
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+#include "vulkan_remote.h"
+
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
+struct vk_funcs
+{
+    PFN_vkCreateImage p_vkCreateImage;
+    PFN_vkDestroyImage p_vkDestroyImage;
+    PFN_vkAllocateMemory p_vkAllocateMemory;
+    PFN_vkFreeMemory p_vkFreeMemory;
+    PFN_vkBindImageMemory p_vkBindImageMemory;
+    PFN_vkGetImageMemoryRequirements p_vkGetImageMemoryRequirements;
+    PFN_vkGetPhysicalDeviceMemoryProperties p_vkGetPhysicalDeviceMemoryProperties;
+};
+
+struct wayland_remote_vk_image
+{
+    VkImage native_vk_image;
+    VkDeviceMemory native_vk_image_memory;
+    VkFormat format;
+    uint32_t width, height;
+};
+
 struct wayland_remote_vk_swapchain
 {
+    struct vk_funcs vk_funcs;
+    uint32_t count_images;
+    struct wayland_remote_vk_image *images;
 };
 
-void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain)
+static int get_image_create_flags(VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    uint32_t flags = 0;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_PROTECTED_BIT;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
+
+    return flags;
+}
+
+static VkImage create_vulkan_image(VkDevice device, struct vk_funcs *vk_funcs,
+                                   VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    VkExternalMemoryImageCreateInfo external_memory_create_info = {0};
+    VkImageCreateInfo image_create_info = {0};
+    VkResult res;
+    VkImage image;
+
+    external_memory_create_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+    external_memory_create_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+
+    image_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+    image_create_info.pNext = &external_memory_create_info;
+    image_create_info.imageType = VK_IMAGE_TYPE_2D;
+    image_create_info.format = chain_create_info->imageFormat;
+    image_create_info.extent.width = chain_create_info->imageExtent.width;
+    image_create_info.extent.height = chain_create_info->imageExtent.height;
+    image_create_info.extent.depth = 1;
+    image_create_info.arrayLayers = chain_create_info->imageArrayLayers;
+    image_create_info.sharingMode = chain_create_info->imageSharingMode;
+    image_create_info.usage = chain_create_info->imageUsage;
+    image_create_info.mipLevels = 1;
+    image_create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    image_create_info.samples = VK_SAMPLE_COUNT_1_BIT;
+    /* We'll create dma-buf buffers for these images, and so we'll need to know
+     * the layout of them on memory. When VK_EXT_image_drm_format_modifier is
+     * not supported, we can't use TILING_DRM_FORMAT_MODIFIER_EXT, so that
+     * leaves us with TILING_LINEAR or TILING_OPTIMAL available. If we choose
+     * TILING_OPTIMAL, we are not able to query the modifier chosen by the
+     * driver and the number of planes (because we don't have the extension to
+     * do so). So it'd be impossible to create dma-buf buffers. This leaves us
+     * with TILING_LINEAR, and that makes drivers decisions predictable and we
+     * can assume that they'll pick DRM_FORMAT_MOD_LINEAR and there'll be a
+     * single plane. This might fail for drivers that do not support modifiers
+     * at all, but we can't do better than that. */
+    image_create_info.tiling = VK_IMAGE_TILING_LINEAR;
+    image_create_info.flags = get_image_create_flags(chain_create_info);
+
+    res = vk_funcs->p_vkCreateImage(device, &image_create_info, NULL, &image);
+    if (res != VK_SUCCESS)
+    {
+        ERR("vkCreateImage failed, res=%d\n", res);
+        goto err;
+    }
+
+    return image;
+
+err:
+    ERR("Failed to create Vulkan image\n");
+    return VK_NULL_HANDLE;
+}
+
+static int get_memory_property_flags(VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    uint32_t flags = 0;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR)
+        flags |= VK_MEMORY_PROPERTY_PROTECTED_BIT;
+
+    return flags;
+}
+
+static VkDeviceMemory create_vulkan_image_memory(VkInstance instance, VkPhysicalDevice physical_device,
+                                                 VkDevice device, struct vk_funcs *vk_funcs,
+                                                 VkSwapchainCreateInfoKHR *chain_create_info,
+                                                 VkImage image)
 {
+    int32_t mem_type_index = -1;
+    uint32_t flags;
+    unsigned int i;
+    VkMemoryRequirements mem_reqs;
+    VkPhysicalDeviceMemoryProperties mem_props;
+    VkExportMemoryAllocateInfo export_alloc_info = {0};
+    VkMemoryAllocateInfo alloc_info = {0};
+    VkResult res;
+    VkDeviceMemory image_mem;
+
+    export_alloc_info.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
+    export_alloc_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+
+    alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+    alloc_info.pNext = &export_alloc_info;
+
+    vk_funcs->p_vkGetImageMemoryRequirements(device, image, &mem_reqs);
+    vk_funcs->p_vkGetPhysicalDeviceMemoryProperties(physical_device, &mem_props);
+
+    flags = get_memory_property_flags(chain_create_info);
+    for (i = 0; i < mem_props.memoryTypeCount; i++)
+        if ((mem_reqs.memoryTypeBits & (1 << i)) &&
+            (mem_props.memoryTypes[i].propertyFlags & flags) == flags)
+                mem_type_index = i;
+
+    if (mem_type_index == -1)
+    {
+        ERR("Failed to find memoryTypeIndex\n");
+        goto err;
+    }
+
+    alloc_info.memoryTypeIndex = mem_type_index;
+    alloc_info.allocationSize = mem_reqs.size;
+
+    res = vk_funcs->p_vkAllocateMemory(device, &alloc_info, NULL, &image_mem);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pfn_vkAllocateMemory failed, res=%d\n", res);
+        goto err;
+    }
+
+    return image_mem;
+
+err:
+    ERR("Failed to create Vulkan image memory\n");
+    return VK_NULL_HANDLE;
+}
+
+static void wayland_remote_vk_image_deinit(VkDevice device, struct vk_funcs *vk_funcs,
+                                           struct wayland_remote_vk_image *image)
+{
+    vk_funcs->p_vkDestroyImage(device, image->native_vk_image, NULL);
+    vk_funcs->p_vkFreeMemory(device, image->native_vk_image_memory, NULL);
+}
+
+
+static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice physical_device,
+                                        VkDevice device, struct vk_funcs *vk_funcs,
+                                        VkSwapchainCreateInfoKHR *create_info,
+                                        struct wayland_remote_vk_image *image)
+{
+    VkResult res;
+
+    image->native_vk_image = VK_NULL_HANDLE;
+    image->native_vk_image_memory = VK_NULL_HANDLE;
+    image->format = create_info->imageFormat;
+    image->width = create_info->imageExtent.width;
+    image->height = create_info->imageExtent.height;
+
+    image->native_vk_image = create_vulkan_image(device, vk_funcs, create_info);
+    if (image->native_vk_image == VK_NULL_HANDLE)
+        goto err;
+
+    image->native_vk_image_memory =
+        create_vulkan_image_memory(instance, physical_device, device,
+                                   vk_funcs, create_info, image->native_vk_image);
+    if (image->native_vk_image_memory == VK_NULL_HANDLE)
+        goto err;
+
+    res = vk_funcs->p_vkBindImageMemory(device, image->native_vk_image,
+                                        image->native_vk_image_memory, 0);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pfn_vkBindImageMemory failed, res=%d\n", res);
+        goto err;
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to create remote swapchain image\n");
+    wayland_remote_vk_image_deinit(device, vk_funcs, image);
+    return -1;
+}
+
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
+                                         VkDevice device)
+{
+    if (swapchain->images)
+    {
+        unsigned int i;
+        for (i = 0; i < swapchain->count_images; i++)
+        {
+            wayland_remote_vk_image_deinit(device, &swapchain->vk_funcs,
+                                           &swapchain->images[i]);
+        }
+        free(swapchain->images);
+    }
     free(swapchain);
 }
 
-struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd)
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd, VkInstance instance,
+                                                                       VkPhysicalDevice physical_device,
+                                                                       VkDevice device,
+                                                                       const struct vulkan_funcs *vulkan_funcs,
+                                                                       VkSwapchainCreateInfoKHR *create_info)
 {
+    static const uint32_t min_number_images = 4;
     struct wayland_remote_vk_swapchain *swapchain;
+    unsigned int i;
+    int res = 0;
 
     swapchain = calloc(1, sizeof(*swapchain));
     if (!swapchain)
@@ -51,11 +277,73 @@ struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd
         goto err;
     }
 
+#define LOAD_DEVICE_FUNCPTR(f) \
+    if (!(swapchain->vk_funcs.p_##f = vulkan_funcs->p_vkGetDeviceProcAddr(device, #f))) \
+        goto err
+
+#define LOAD_INSTANCE_FUNCPTR(f) \
+    if (!(swapchain->vk_funcs.p_##f = vulkan_funcs->p_vkGetInstanceProcAddr(instance, #f))) \
+        goto err
+
+    LOAD_DEVICE_FUNCPTR(vkCreateImage);
+    LOAD_DEVICE_FUNCPTR(vkDestroyImage);
+    LOAD_DEVICE_FUNCPTR(vkAllocateMemory);
+    LOAD_DEVICE_FUNCPTR(vkFreeMemory);
+    LOAD_DEVICE_FUNCPTR(vkBindImageMemory);
+    LOAD_DEVICE_FUNCPTR(vkGetImageMemoryRequirements);
+    LOAD_INSTANCE_FUNCPTR(vkGetPhysicalDeviceMemoryProperties);
+
+#undef LOAD_DEVICE_FUNCPTR
+#undef LOAD_INSTANCE_FUNCPTR
+
+    swapchain->count_images = max(create_info->minImageCount, min_number_images);
+    swapchain->images = calloc(swapchain->count_images, sizeof(*swapchain->images));
+    if (!swapchain->images)
+    {
+        ERR("Failed to allocate memory\n");
+        goto err;
+    }
+
+    for (i = 0; i < swapchain->count_images; i++)
+        res |= wayland_remote_vk_image_init(instance, physical_device, device,
+                                            &swapchain->vk_funcs, create_info,
+                                            &swapchain->images[i]);
+    if (res < 0)
+        goto err;
+
+
     return swapchain;
 
 err:
     ERR("Failed to create remote swapchain\n");
     if (swapchain)
-        wayland_remote_vk_swapchain_destroy(swapchain);
+        wayland_remote_vk_swapchain_destroy(swapchain, device);
     return NULL;
 }
+
+VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    unsigned int i;
+    VkResult res = VK_SUCCESS;
+
+    if (!images)
+    {
+        *count = swapchain->count_images;
+        return VK_SUCCESS;
+    }
+
+    if (*count < swapchain->count_images)
+        res = VK_INCOMPLETE;
+
+    /* The client want us to fill images, but for some reason the size of the
+     * array is larger than the number of formats that we support. So we correct
+     * that size. */
+    if (*count > swapchain->count_images)
+        *count = swapchain->count_images;
+
+    for (i = 0; i < (*count); i++)
+        images[i] = swapchain->images[i].native_vk_image;
+
+    return res;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
index 0f5bef740a5..ea3b2a7975e 100644
--- a/dlls/winewayland.drv/vulkan_remote.h
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -30,8 +30,16 @@
 #include "wine/vulkan.h"
 
 struct wayland_remote_vk_swapchain;
-
-struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd) DECLSPEC_HIDDEN;
-void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain) DECLSPEC_HIDDEN;
+struct vulkan_funcs;
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd, VkInstance instance,
+                                                                       VkPhysicalDevice physical_device,
+                                                                       VkDevice device,
+                                                                       const struct vulkan_funcs *vulkan_funcs,
+                                                                       VkSwapchainCreateInfoKHR *create_info) DECLSPEC_HIDDEN;
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
+                                         VkDevice device) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
+                                                uint32_t *count, VkImage *images) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
-- 
2.39.0.rc2

From 23896d26a6d1b4e80a2263af7a77fc041dc80946 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 21 Sep 2022 15:12:17 +0300
Subject: [PATCH 169/202] winewayland.drv: Implement vkAcquireNextImageKHR.

This is a simple passthrough implementation to the native Vulkan driver,
but will be extended to support cross-process rendering.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index a98ff5dfdde..19a3e85985a 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -59,6 +59,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
     struct wl_surface *surface;
 } VkWaylandSurfaceCreateInfoKHR;
 
+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
 static VkResult (*pvkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
@@ -1088,6 +1089,17 @@ static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR
     return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
 }
 
+static VkResult wayland_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                              uint64_t timeout, VkSemaphore semaphore,
+                                              VkFence fence, uint32_t *image_index)
+{
+    TRACE("%p 0x%s 0x%s 0x%s 0x%s %p\n",
+          device, wine_dbgstr_longlong(swapchain), wine_dbgstr_longlong(timeout),
+          wine_dbgstr_longlong(semaphore), wine_dbgstr_longlong(fence), image_index);
+
+    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -1200,6 +1212,7 @@ static void wine_vk_init(void)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
 #define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkAcquireNextImageKHR);
     LOAD_FUNCPTR(vkCreateDevice);
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
@@ -1235,6 +1248,7 @@ fail:
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    .p_vkAcquireNextImageKHR = wayland_vkAcquireNextImageKHR,
     .p_vkCreateDevice = wayland_vkCreateDevice,
     .p_vkCreateInstance = wayland_vkCreateInstance,
     .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
-- 
2.39.0.rc2

From 08c31fbf9ec97163a6ee0236824c3a8054de6fdc Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 21 Sep 2022 15:34:30 +0300
Subject: [PATCH 170/202] winewayland.drv: Implement cross-process
 vkAcquireNextImageKHR.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c        |  14 ++
 dlls/winewayland.drv/vulkan_remote.c | 229 ++++++++++++++++++++++++++-
 dlls/winewayland.drv/vulkan_remote.h |   4 +
 3 files changed, 246 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 19a3e85985a..b813939bcc6 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -101,12 +101,19 @@ static const struct vulkan_funcs vulkan_funcs;
  * might not be supported by the device, so we must check. */
 const static char *instance_extensions_remote_vulkan[] =
 {
+    "VK_KHR_external_fence_capabilities",
+    "VK_KHR_external_semaphore_capabilities",
+    "VK_KHR_get_physical_device_properties2",
 };
 
 /* These device extensions are required to support Vulkan remote. Some of them
  * might not be supported by the device, so we must check. */
 const static char *device_extensions_remote_vulkan[] =
 {
+    "VK_KHR_external_fence",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_semaphore",
+    "VK_KHR_external_semaphore_fd",
 };
 
 struct wine_vk_device
@@ -1093,10 +1100,17 @@ static VkResult wayland_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR sw
                                               uint64_t timeout, VkSemaphore semaphore,
                                               VkFence fence, uint32_t *image_index)
 {
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
     TRACE("%p 0x%s 0x%s 0x%s 0x%s %p\n",
           device, wine_dbgstr_longlong(swapchain), wine_dbgstr_longlong(timeout),
           wine_dbgstr_longlong(semaphore), wine_dbgstr_longlong(fence), image_index);
 
+    if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        return wayland_remote_vk_swapchain_acquire_next_image(wine_vk_swapchain->remote_vk_swapchain,
+                                                              wine_vk_swapchain->wine_vk_device->dev,
+                                                              timeout, semaphore, fence, image_index);
+
     return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
 }
 
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
index 9cff6d33d26..65ef27d7fa2 100644
--- a/dlls/winewayland.drv/vulkan_remote.c
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -48,6 +48,8 @@ struct vk_funcs
     PFN_vkBindImageMemory p_vkBindImageMemory;
     PFN_vkGetImageMemoryRequirements p_vkGetImageMemoryRequirements;
     PFN_vkGetPhysicalDeviceMemoryProperties p_vkGetPhysicalDeviceMemoryProperties;
+    PFN_vkImportSemaphoreFdKHR p_vkImportSemaphoreFdKHR;
+    PFN_vkImportFenceFdKHR p_vkImportFenceFdKHR;
 };
 
 struct wayland_remote_vk_image
@@ -56,15 +58,40 @@ struct wayland_remote_vk_image
     VkDeviceMemory native_vk_image_memory;
     VkFormat format;
     uint32_t width, height;
+    BOOL busy;
+    HANDLE remote_buffer_released_event;
 };
 
 struct wayland_remote_vk_swapchain
 {
     struct vk_funcs vk_funcs;
+    struct wayland_remote_surface_proxy *remote_surface_proxy;
     uint32_t count_images;
     struct wayland_remote_vk_image *images;
 };
 
+/* Convert timeout in ms to the timeout format used by ntdll which is:
+ * 100ns units, negative for monotonic time. */
+static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
+{
+    if (timeout_ms == -1)
+        return NULL;
+
+    time->QuadPart = (ULONGLONG)timeout_ms * -10000;
+
+    return time;
+}
+
+static UINT get_tick_count_since(UINT start)
+{
+    UINT now = NtGetTickCount();
+    /* Handle tick count wrap around to zero. */
+    if (now < start)
+        return 0xffffffff - start + now + 1;
+    else
+        return now - start;
+}
+
 static int get_image_create_flags(VkSwapchainCreateInfoKHR *chain_create_info)
 {
     uint32_t flags = 0;
@@ -201,8 +228,10 @@ static void wayland_remote_vk_image_deinit(VkDevice device, struct vk_funcs *vk_
 {
     vk_funcs->p_vkDestroyImage(device, image->native_vk_image, NULL);
     vk_funcs->p_vkFreeMemory(device, image->native_vk_image_memory, NULL);
-}
 
+    if (image->remote_buffer_released_event)
+        NtClose(image->remote_buffer_released_event);
+}
 
 static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice physical_device,
                                         VkDevice device, struct vk_funcs *vk_funcs,
@@ -216,6 +245,8 @@ static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice ph
     image->format = create_info->imageFormat;
     image->width = create_info->imageExtent.width;
     image->height = create_info->imageExtent.height;
+    image->busy = FALSE;
+    image->remote_buffer_released_event = 0;
 
     image->native_vk_image = create_vulkan_image(device, vk_funcs, create_info);
     if (image->native_vk_image == VK_NULL_HANDLE)
@@ -243,9 +274,23 @@ err:
     return -1;
 }
 
+static void wayland_remote_vk_image_release(struct wayland_remote_vk_image *image)
+{
+    if (image->remote_buffer_released_event)
+    {
+        NtClose(image->remote_buffer_released_event);
+        image->remote_buffer_released_event = 0;
+    }
+
+    image->busy = FALSE;
+}
+
 void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
                                          VkDevice device)
 {
+    if (swapchain->remote_surface_proxy)
+        wayland_remote_surface_proxy_destroy(swapchain->remote_surface_proxy);
+
     if (swapchain->images)
     {
         unsigned int i;
@@ -292,10 +337,20 @@ struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd
     LOAD_DEVICE_FUNCPTR(vkBindImageMemory);
     LOAD_DEVICE_FUNCPTR(vkGetImageMemoryRequirements);
     LOAD_INSTANCE_FUNCPTR(vkGetPhysicalDeviceMemoryProperties);
+    LOAD_DEVICE_FUNCPTR(vkImportSemaphoreFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkImportFenceFdKHR);
 
 #undef LOAD_DEVICE_FUNCPTR
 #undef LOAD_INSTANCE_FUNCPTR
 
+    swapchain->remote_surface_proxy =
+        wayland_remote_surface_proxy_create(hwnd, WAYLAND_REMOTE_SURFACE_TYPE_GLVK);
+    if (!swapchain->remote_surface_proxy)
+    {
+        ERR("Failed to create remote surface proxy for remote swapchain\n");
+        goto err;
+    }
+
     swapchain->count_images = max(create_info->minImageCount, min_number_images);
     swapchain->images = calloc(swapchain->count_images, sizeof(*swapchain->images));
     if (!swapchain->images)
@@ -347,3 +402,175 @@ VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapcha
 
     return res;
 }
+
+static DWORD wait_remote_release_buffer_events(struct wayland_remote_vk_swapchain *swapchain,
+                                               int timeout_ms)
+{
+    int count = 0;
+    HANDLE *handles;
+    struct wayland_remote_vk_image *image;
+    struct wayland_remote_vk_image **images;
+    unsigned int i;
+    LARGE_INTEGER timeout;
+    UINT ret = WAIT_OBJECT_0;
+
+    handles = calloc(swapchain->count_images, sizeof(*handles));
+    images = calloc(swapchain->count_images, sizeof(*images));
+    if (!handles || !images)
+    {
+        ERR("Failed to allocate memory\n");
+        ret = WAIT_FAILED;
+        goto out;
+    }
+
+    if (!wayland_remote_surface_proxy_dispatch_events(swapchain->remote_surface_proxy))
+    {
+        ret = WAIT_FAILED;
+        goto out;
+    }
+
+    for (i = 0; i < swapchain->count_images; i++)
+    {
+        image = &swapchain->images[i];
+        if (!image->remote_buffer_released_event)
+            continue;
+        images[count] = image;
+        handles[count] = image->remote_buffer_released_event;
+        count++;
+    }
+    TRACE("count handles=%d\n", count);
+    for (i = 0; i < count; i++)
+        TRACE("handle%d=%p\n", i, handles[i]);
+
+    /* Nothing to wait for, so just return */
+    if (count == 0)
+        goto out;
+
+    ret = NtWaitForMultipleObjects(count, handles, TRUE, FALSE,
+                                   get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_FAILED)
+    {
+        ERR("Failed on NtWaitForMultipleObjects() call, ret=%d\n", ret);
+        goto out;
+    }
+    TRACE("count=%d => ret=%d\n", count, ret);
+
+    i = ret - WAIT_OBJECT_0;
+    if (i < count)
+        wayland_remote_vk_image_release(images[i]);
+
+out:
+    if (ret == WAIT_FAILED)
+        ERR("Failed to wait for remote release buffer event\n");
+    free(handles);
+    free(images);
+    return ret;
+}
+
+VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk_swapchain *swapchain,
+                                                        VkDevice device, uint64_t timeout_ns,
+                                                        VkSemaphore semaphore, VkFence fence,
+                                                        uint32_t *image_index)
+{
+    struct vk_funcs *vk_funcs = &swapchain->vk_funcs;
+    unsigned int i;
+    BOOL free_image_found = FALSE;
+    VkImportSemaphoreFdInfoKHR import_semaphore_fd_info = {0};
+    VkImportFenceFdInfoKHR import_fence_fd_info = {0};
+    VkResult res;
+    static const UINT wait_timeout = 100;
+    UINT wait_start = NtGetTickCount();
+
+    /* As we are not the Vulkan driver, we don't have much information about the
+     * semaphore. But the spec of VkImportSemaphoreFdInfoKHR states the
+     * following:
+     *
+     * If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT, the
+     * special value -1 for fd is treated like a valid sync file descriptor
+     * referring to an object that has already signaled. The import operation
+     * will succeed and the VkSemaphore will have a temporarily imported payload
+     * as if a valid file descriptor had been provided.
+     *
+     * This special behavior allows us to signal the semaphore by setting
+     * import_semaphore_fd_info.fd to -1. Same thing applies to VkFence, so we
+     * set import_fence_fd_info.fd to -1 */
+
+    import_semaphore_fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    import_semaphore_fd_info.fd = -1;
+    import_semaphore_fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+    import_semaphore_fd_info.semaphore = semaphore;
+    import_semaphore_fd_info.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
+
+    import_fence_fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
+    import_fence_fd_info.fd = -1;
+    import_fence_fd_info.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
+    import_fence_fd_info.fence = fence;
+    import_fence_fd_info.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
+
+    /* Wait until we have a free image. If we don't get a free buffer within
+     * wait_timeout, drop the first buffer to ensure we can continue and avoid
+     * potential cross-process deadlocks (e.g., the render process waiting for
+     * the window process to dispatch buffer release messages, while the window
+     * process is waiting for the render process to finish rendering). */
+    while (!free_image_found)
+    {
+        for (i = 0; i < swapchain->count_images; i++)
+            if (!swapchain->images[i].busy)
+            {
+                free_image_found = TRUE;
+                break;
+            }
+
+        if (!free_image_found)
+        {
+            /* If timeout is 0, the spec says that we should return VK_NOT_READY
+             * when no images are available. */
+            if (timeout_ns == 0)
+                return VK_NOT_READY;
+
+            if (wait_remote_release_buffer_events(swapchain, 10) == WAIT_FAILED)
+                goto err;
+
+            /* Release image so that we can continue */
+            if (get_tick_count_since(wait_start) > wait_timeout)
+            {
+                i = 0;
+                free_image_found = TRUE;
+                wayland_remote_vk_image_release(&swapchain->images[i]);
+            }
+        }
+
+        /* If applications defined a timeout, we must respect it */
+        if (!free_image_found && timeout_ns > 0 &&
+            get_tick_count_since(wait_start) > (timeout_ns / 1000000))
+            return VK_TIMEOUT;
+    }
+
+    if (semaphore != VK_NULL_HANDLE)
+    {
+        res = vk_funcs->p_vkImportSemaphoreFdKHR(device, &import_semaphore_fd_info);
+        if (res != VK_SUCCESS)
+        {
+            ERR("pfn_vkImportSemaphoreFdKHR failed, res=%d\n", res);
+            goto err;
+        }
+    }
+    if (fence != VK_NULL_HANDLE)
+    {
+        res = vk_funcs->p_vkImportFenceFdKHR(device, &import_fence_fd_info);
+        if (res != VK_SUCCESS)
+        {
+            ERR("pfn_vkImportFenceFdKHR failed, res=%d\n", res);
+            goto err;
+        }
+    }
+
+    *image_index = i;
+    swapchain->images[*image_index].busy = TRUE;
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to acquire image from remote Vulkan swapchain");
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
index ea3b2a7975e..37c69f73a3e 100644
--- a/dlls/winewayland.drv/vulkan_remote.h
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -41,5 +41,9 @@ void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swa
                                          VkDevice device) DECLSPEC_HIDDEN;
 VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
                                                 uint32_t *count, VkImage *images) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk_swapchain *swapchain,
+                                                        VkDevice device, uint64_t timeout_ns,
+                                                        VkSemaphore semaphore, VkFence fence,
+                                                        uint32_t *image_index) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
-- 
2.39.0.rc2

From 450fc288205365ab1323c47a4e73a3c7d496a116 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Wed, 21 Sep 2022 16:17:08 +0300
Subject: [PATCH 171/202] winewayland.drv: Implement cross-process
 vkQueuePresentKHR.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c        | 159 +++++++++++++++++++++++++--
 dlls/winewayland.drv/vulkan_remote.c | 120 ++++++++++++++++++++
 dlls/winewayland.drv/vulkan_remote.h |   2 +
 3 files changed, 274 insertions(+), 7 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index b813939bcc6..c17c22a02d4 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -37,8 +37,12 @@
 #include "wine/vulkan_driver.h"
 #include "vulkan_remote.h"
 
+#include <assert.h>
 #include <dlfcn.h>
+#include <errno.h>
+#include <poll.h>
 #include <stdlib.h>
+#include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
@@ -102,6 +106,7 @@ static const struct vulkan_funcs vulkan_funcs;
 const static char *instance_extensions_remote_vulkan[] =
 {
     "VK_KHR_external_fence_capabilities",
+    "VK_KHR_external_memory_capabilities",
     "VK_KHR_external_semaphore_capabilities",
     "VK_KHR_get_physical_device_properties2",
 };
@@ -112,6 +117,8 @@ const static char *device_extensions_remote_vulkan[] =
 {
     "VK_KHR_external_fence",
     "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory",
+    "VK_KHR_external_memory_fd",
     "VK_KHR_external_semaphore",
     "VK_KHR_external_semaphore_fd",
 };
@@ -148,6 +155,7 @@ struct wine_vk_swapchain
     BOOL valid;
     /* Only used for cross-process Vulkan rendering apps. */
     struct wayland_remote_vk_swapchain *remote_vk_swapchain;
+    PFN_vkGetSemaphoreFdKHR p_vkGetSemaphoreFdKHR;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -626,6 +634,13 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
             res = VK_ERROR_OUT_OF_HOST_MEMORY;
             goto err;
         }
+        wine_vk_swapchain->p_vkGetSemaphoreFdKHR =
+            pvkGetDeviceProcAddr(device, "vkGetSemaphoreFdKHR");
+        if (!wine_vk_swapchain->p_vkGetSemaphoreFdKHR)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
     }
 
     wine_vk_swapchain->wine_vk_device = wine_vk_device;
@@ -1124,17 +1139,37 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
         const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
         struct wine_vk_swapchain *wine_vk_swapchain =
             wine_vk_swapchain_from_handle(vk_swapchain);
-        BOOL drawing_allowed =
-            (wine_vk_swapchain && wine_vk_swapchain->wayland_surface) ?
-            wine_vk_swapchain->wayland_surface->drawing_allowed : TRUE;
+        BOOL drawing_allowed;
         RECT client;
 
+        if (!wine_vk_swapchain)
+        {
+            drawing_allowed = FALSE;
+        }
+        else
+        {
+            if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+            {
+                /* For cross-process swapchains, we don't have the information
+                 * of drawing_allowed. So we assume it is TRUE. That is safe to
+                 * do because the process that will call wl_surface_commit()
+                 * won't commit anything when drawing_allowed == FALSE. */
+                drawing_allowed = TRUE;
+            }
+            else
+            {
+                assert(wine_vk_swapchain->wayland_surface);
+                drawing_allowed = wine_vk_swapchain->wayland_surface->drawing_allowed;
+            }
+        }
+
         TRACE("swapchain[%d] vk=0x%s wine=%p extent=%dx%d wayland_surface=%p "
-               "drawing_allowed=%d\n",
+               "remote_swapchain=%p drawing_allowed=%d\n",
                i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
                wine_vk_swapchain ? wine_vk_swapchain->extent.width : 0,
                wine_vk_swapchain ? wine_vk_swapchain->extent.height : 0,
                wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
+               wine_vk_swapchain ? wine_vk_swapchain->remote_vk_swapchain : NULL,
                drawing_allowed);
 
         if (!wine_vk_swapchain ||
@@ -1153,7 +1188,7 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
         /* Since Vulkan content is presented on a Wayland subsurface, we need
          * to ensure the parent Wayland surface is mapped for the Vulkan
          * content to be visible. */
-        if (wine_vk_swapchain->wayland_surface && drawing_allowed)
+        if (drawing_allowed && !wine_vk_swapchain_is_remote(wine_vk_swapchain))
             wayland_surface_ensure_mapped(wine_vk_swapchain->wayland_surface);
     }
 
@@ -1189,9 +1224,77 @@ static void lock_swapchain_wayland_surfaces(const VkPresentInfoKHR *present_info
     }
 }
 
+static int queue_present_wait_semaphores(struct wine_vk_swapchain *swapchain,
+                                         const VkPresentInfoKHR *present_info)
+{
+    struct pollfd pollfd;
+    int semaphore_fd = -1;
+    unsigned int i;
+    int ret;
+    VkSemaphoreGetFdInfoKHR get_fd_info = {0};
+    VkResult res;
+
+    if (present_info->waitSemaphoreCount == 0)
+        return 0;
+
+    get_fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    get_fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+
+    for (i = 0; i < present_info->waitSemaphoreCount; i++)
+    {
+        /* Current semaphore to wait for */
+        get_fd_info.semaphore = present_info->pWaitSemaphores[i];
+
+        res = swapchain->p_vkGetSemaphoreFdKHR(swapchain->wine_vk_device->dev,
+                                               &get_fd_info, &semaphore_fd);
+        if (res != VK_SUCCESS)
+        {
+            ERR("vkGetSemaphoreFdKHR failed, res=%d\n", res);
+            semaphore_fd = -1;
+            goto err;
+        }
+        if (semaphore_fd < 0)
+        {
+            ERR("Invalid semaphore fd\n");
+            goto err;
+        }
+
+        pollfd.fd = semaphore_fd;
+        pollfd.events = POLLIN;
+
+        while ((ret = poll(&pollfd, 1, -1)) == -1 && errno == EINTR)
+            continue;
+
+        if (ret < 0)
+        {
+            ERR("Poll fd failed errno=%d\n", errno);
+            goto err;
+        }
+        if (pollfd.revents & (POLLERR | POLLHUP | POLLNVAL))
+        {
+            ERR("Poll fd failed\n");
+            goto err;
+        }
+
+        close(semaphore_fd);
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to wait for semaphores before presenting queue\n");
+    if (semaphore_fd >= 0)
+        close(semaphore_fd);
+    return -1;
+}
+
 static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *present_info)
 {
     VkResult res;
+    unsigned int i;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    int res_chain;
+    BOOL failed = FALSE;
 
     TRACE("%p, %p\n", queue, present_info);
 
@@ -1201,10 +1304,52 @@ static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR
     lock_swapchain_wayland_surfaces(present_info, TRUE);
 
     if ((res = validate_present_info(present_info)) == VK_SUCCESS)
-        res = pvkQueuePresentKHR(queue, present_info);
+    {
+        wine_vk_swapchain = wine_vk_swapchain_from_handle(present_info->pSwapchains[0]);
+        if (!wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        {
+            /* We are not dealing with cross-process swapchains, so we don't
+             * have to use our remote Vulkan implementation to present */
+            res = pvkQueuePresentKHR(queue, present_info);
+        }
+        else
+        {
+            /* We are dealing with cross-process swapchains, so use our remote
+             * Vulkan implementation to present */
+            if (present_info->swapchainCount == 0 || !present_info->pSwapchains)
+            {
+                ERR("Invalid number of swapchains to present: 0\n");
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                goto out;
+            }
+            for (i = 0; i < present_info->swapchainCount; i++)
+            {
+                wine_vk_swapchain = wine_vk_swapchain_from_handle(present_info->pSwapchains[i]);
+
+                /* Before presenting the 1st swapchain, wait for the semaphores */
+                if (i == 0 && queue_present_wait_semaphores(wine_vk_swapchain, present_info) < 0)
+                {
+                    res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                    goto out;
+                }
+
+                res_chain = wayland_remote_vk_swapchain_present(wine_vk_swapchain->remote_vk_swapchain,
+                                                                present_info->pImageIndices[i]);
+                if (res_chain < 0)
+                    failed = TRUE;
+
+                if (present_info->pResults)
+                    present_info->pResults[i] = failed ? VK_ERROR_OUT_OF_HOST_MEMORY : VK_SUCCESS;
+            }
 
-    lock_swapchain_wayland_surfaces(present_info, FALSE);
+            /* If presenting any of the swapchains fails, this function fails */
+            if (failed)
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
 
+out:
+    lock_swapchain_wayland_surfaces(present_info, FALSE);
     return res;
 }
 
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
index 65ef27d7fa2..a199dfe0f38 100644
--- a/dlls/winewayland.drv/vulkan_remote.c
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -35,6 +35,7 @@
 
 #include "vulkan_remote.h"
 
+#include <drm_fourcc.h>
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
@@ -50,6 +51,8 @@ struct vk_funcs
     PFN_vkGetPhysicalDeviceMemoryProperties p_vkGetPhysicalDeviceMemoryProperties;
     PFN_vkImportSemaphoreFdKHR p_vkImportSemaphoreFdKHR;
     PFN_vkImportFenceFdKHR p_vkImportFenceFdKHR;
+    PFN_vkGetMemoryFdKHR p_vkGetMemoryFdKHR;
+    PFN_vkGetImageSubresourceLayout p_vkGetImageSubresourceLayout;
 };
 
 struct wayland_remote_vk_image
@@ -59,6 +62,7 @@ struct wayland_remote_vk_image
     VkFormat format;
     uint32_t width, height;
     BOOL busy;
+    struct wayland_native_buffer native_buffer;
     HANDLE remote_buffer_released_event;
 };
 
@@ -70,6 +74,21 @@ struct wayland_remote_vk_swapchain
     struct wayland_remote_vk_image *images;
 };
 
+struct drm_vk_format
+{
+    VkFormat vk_format;
+    VkFormat vk_format_srgb;
+    uint32_t drm_format;
+    uint32_t drm_format_alpha;
+};
+
+/* List of Vulkan formats that we know, and the corresponding DRM formats */
+const static struct drm_vk_format format_table[] =
+{
+    {VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, DRM_FORMAT_XBGR8888, DRM_FORMAT_ABGR8888},
+    {VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_B8G8R8A8_SRGB, DRM_FORMAT_XRGB8888, DRM_FORMAT_ARGB8888},
+};
+
 /* Convert timeout in ms to the timeout format used by ntdll which is:
  * 100ns units, negative for monotonic time. */
 static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
@@ -92,6 +111,68 @@ static UINT get_tick_count_since(UINT start)
         return now - start;
 }
 
+static uint32_t vulkan_format_to_drm_format(VkFormat format, BOOL ignore_alpha)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(format_table); i++)
+    {
+        const struct drm_vk_format *dvf = &format_table[i];
+        if (dvf->vk_format == format || dvf->vk_format_srgb == format)
+            return ignore_alpha ? dvf->drm_format : dvf->drm_format_alpha;
+    }
+
+    return DRM_FORMAT_INVALID;
+}
+
+static int wayland_native_buffer_init_vk(VkInstance instance, VkPhysicalDevice physical_device,
+                                         VkDevice device, struct vk_funcs *vk_funcs,
+                                         BOOL ignore_alpha, struct wayland_remote_vk_image *image)
+{
+    struct wayland_native_buffer *buffer = &image->native_buffer;
+    VkMemoryGetFdInfoKHR memory_get_fd_info = {0};
+    VkSubresourceLayout layout;
+    VkImageSubresource image_subresource = {0};
+    VkResult res;
+
+    buffer->modifier = DRM_FORMAT_MOD_LINEAR;
+    buffer->plane_count = 1;
+
+    memory_get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+    memory_get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+    memory_get_fd_info.memory = image->native_vk_image_memory;
+
+    res = vk_funcs->p_vkGetMemoryFdKHR(device, &memory_get_fd_info, &buffer->fds[0]);
+    if (res != VK_SUCCESS)
+    {
+        buffer->fds[0] = -1;
+        ERR("pfn_vkGetMemoryFdKHR failed, res=%d\n", res);
+        goto err;
+    }
+
+    image_subresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    vk_funcs->p_vkGetImageSubresourceLayout(device, image->native_vk_image,
+                                            &image_subresource, &layout);
+    buffer->offsets[0] = layout.offset;
+    buffer->strides[0] = layout.rowPitch;
+
+    buffer->format = vulkan_format_to_drm_format(image->format, ignore_alpha);
+    if (buffer->format == DRM_FORMAT_INVALID)
+    {
+        ERR("Failed to get corresponding DRM format for Vulkan format %d\n", image->format);
+        goto err;
+    }
+    buffer->width = image->width;
+    buffer->height = image->height;
+
+    return 0;
+
+err:
+    wayland_native_buffer_deinit(buffer);
+    ERR("Failed to init wayland_native_buffer for Vulkan image\n");
+    return -1;
+}
+
 static int get_image_create_flags(VkSwapchainCreateInfoKHR *chain_create_info)
 {
     uint32_t flags = 0;
@@ -231,6 +312,8 @@ static void wayland_remote_vk_image_deinit(VkDevice device, struct vk_funcs *vk_
 
     if (image->remote_buffer_released_event)
         NtClose(image->remote_buffer_released_event);
+
+    wayland_native_buffer_deinit(&image->native_buffer);
 }
 
 static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice physical_device,
@@ -239,6 +322,8 @@ static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice ph
                                         struct wayland_remote_vk_image *image)
 {
     VkResult res;
+    BOOL ignore_alpha;
+    unsigned int i;
 
     image->native_vk_image = VK_NULL_HANDLE;
     image->native_vk_image_memory = VK_NULL_HANDLE;
@@ -247,6 +332,8 @@ static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice ph
     image->height = create_info->imageExtent.height;
     image->busy = FALSE;
     image->remote_buffer_released_event = 0;
+    for (i = 0; i < ARRAY_SIZE(image->native_buffer.fds); i++)
+        image->native_buffer.fds[i] = -1;
 
     image->native_vk_image = create_vulkan_image(device, vk_funcs, create_info);
     if (image->native_vk_image == VK_NULL_HANDLE)
@@ -266,6 +353,11 @@ static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice ph
         goto err;
     }
 
+    ignore_alpha = create_info->compositeAlpha & VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
+    if (wayland_native_buffer_init_vk(instance, physical_device, device, vk_funcs,
+                                      ignore_alpha, image) < 0)
+        goto err;
+
     return 0;
 
 err:
@@ -339,6 +431,8 @@ struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd
     LOAD_INSTANCE_FUNCPTR(vkGetPhysicalDeviceMemoryProperties);
     LOAD_DEVICE_FUNCPTR(vkImportSemaphoreFdKHR);
     LOAD_DEVICE_FUNCPTR(vkImportFenceFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkGetMemoryFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkGetImageSubresourceLayout);
 
 #undef LOAD_DEVICE_FUNCPTR
 #undef LOAD_INSTANCE_FUNCPTR
@@ -574,3 +668,29 @@ err:
     ERR("Failed to acquire image from remote Vulkan swapchain");
     return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
+
+int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
+                                        uint32_t image_index)
+{
+    struct wayland_remote_vk_image *image;
+
+    image = &swapchain->images[image_index];
+    image->busy = TRUE;
+
+    if (!wayland_remote_surface_proxy_commit(swapchain->remote_surface_proxy,
+                                             &image->native_buffer,
+                                             WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+                                             WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL,
+                                             &image->remote_buffer_released_event,
+                                             NULL))
+    {
+        wayland_remote_vk_image_release(image);
+        goto err;
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to present remote Vulkan swapchain\n");
+    return -1;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
index 37c69f73a3e..aa6909035b5 100644
--- a/dlls/winewayland.drv/vulkan_remote.h
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -45,5 +45,7 @@ VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk
                                                         VkDevice device, uint64_t timeout_ns,
                                                         VkSemaphore semaphore, VkFence fence,
                                                         uint32_t *image_index) DECLSPEC_HIDDEN;
+int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
+                                        uint32_t image_index) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
-- 
2.39.0.rc2

From 4e6a32ad221b2e5168dcf755dc091c2e4cfaff4a Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Thu, 22 Sep 2022 10:54:19 +0300
Subject: [PATCH 172/202] winewayland.drv: Implement cross-process
 vkGetPhysicalDeviceSurfaceFormats(2)KHR.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c        | 128 ++++++++++++++++++++++++---
 dlls/winewayland.drv/vulkan_remote.c |  49 ++++++++++
 dlls/winewayland.drv/vulkan_remote.h |   6 ++
 3 files changed, 172 insertions(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index c17c22a02d4..7c4301957b3 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -206,6 +206,11 @@ static BOOL wine_vk_surface_handle_is_valid(VkSurfaceKHR handle)
     return wine_vk_surface && __atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST);
 }
 
+static BOOL wine_vk_surface_is_remote(struct wine_vk_surface *wine_vk_surface)
+{
+    return wine_vk_surface && wine_vk_surface->dummy_wl_surface;
+}
+
 static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
 {
     wine_vk_list_remove(&wine_vk_swapchain->link);
@@ -1002,6 +1007,114 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevi
     return res;
 }
 
+static VkResult get_surface_formats2(VkPhysicalDevice phys_dev,
+                                     const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                     uint32_t *count, VkSurfaceFormat2KHR *formats)
+{
+    struct wine_vk_surface *wine_vk_surface =
+        wine_vk_surface_from_handle(surface_info->surface);
+    uint32_t count_host_formats;
+    VkSurfaceFormat2KHR *host_formats = NULL;
+    VkResult res = VK_SUCCESS;
+
+    if (!wine_vk_surface_is_remote(wine_vk_surface))
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+
+    res = pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                 &count_host_formats, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormats2KHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    host_formats = calloc(count_host_formats, sizeof(*host_formats));
+    if (!host_formats)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto out;
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                 &count_host_formats, host_formats);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormats2KHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    res = wayland_remote_vk_filter_supported_formats(count, formats,
+                                                     count_host_formats, host_formats,
+                                                     sizeof(VkSurfaceFormat2KHR),
+                                                     offsetof(VkSurfaceFormat2KHR,
+                                                              surfaceFormat));
+    if (*count == 0)
+    {
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        ERR("Failed to find formats supported by both host and remote Vulkan\n");
+    }
+
+out:
+    if (res != VK_SUCCESS && res != VK_INCOMPLETE)
+        ERR("Failed to get surface formats\n");
+    free(host_formats);
+    return res;
+}
+
+static VkResult get_surface_formats(VkPhysicalDevice phys_dev, VkSurfaceKHR surface,
+                                    uint32_t *count, VkSurfaceFormatKHR *formats)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    uint32_t count_host_formats;
+    VkSurfaceFormatKHR *host_formats = NULL;
+    VkResult res = VK_SUCCESS;
+
+    if (!wine_vk_surface_is_remote(wine_vk_surface))
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                     count, formats);
+
+    res = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                &count_host_formats, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormatsKHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    host_formats = calloc(count_host_formats, sizeof(*host_formats));
+    if (!host_formats)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto out;
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                &count_host_formats, host_formats);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormatsKHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    res = wayland_remote_vk_filter_supported_formats(count, formats,
+                                                     count_host_formats, host_formats,
+                                                     sizeof(VkSurfaceFormatKHR), 0);
+    if (*count == 0)
+    {
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        ERR("Failed to find formats supported by both host and remote Vulkan\n");
+    }
+
+out:
+    if (res != VK_SUCCESS && res != VK_INCOMPLETE)
+        ERR("Failed to get surface formats\n");
+    free(host_formats);
+    return res;
+}
+
 static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
                                                               const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
                                                               uint32_t *count,
@@ -1016,10 +1129,7 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice p
         RETURN_VK_ERROR_SURFACE_LOST_KHR;
 
     if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
-    {
-        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
-                                                      count, formats);
-    }
+        return get_surface_formats2(phys_dev, surface_info, count, formats);
 
     /* Until the loader version exporting this function is common, emulate it
      * using the older non-2 version. */
@@ -1030,15 +1140,11 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice p
     }
 
     if (!formats)
-    {
-        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
-                                                     count, NULL);
-    }
+        return get_surface_formats(phys_dev, surface_info->surface, count, NULL);
 
     formats_host = calloc(*count, sizeof(*formats_host));
     if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
-    result = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
-                                                   count, formats_host);
+    result = get_surface_formats(phys_dev, surface_info->surface, count, formats_host);
     if (result == VK_SUCCESS || result == VK_INCOMPLETE)
     {
         for (i = 0; i < *count; i++)
@@ -1059,7 +1165,7 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice ph
     if (!wine_vk_surface_handle_is_valid(surface))
         RETURN_VK_ERROR_SURFACE_LOST_KHR;
 
-    return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
+    return get_surface_formats(phys_dev, surface, count, formats);
 }
 
 static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice phys_dev,
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
index a199dfe0f38..0851be94094 100644
--- a/dlls/winewayland.drv/vulkan_remote.c
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -694,3 +694,52 @@ err:
     ERR("Failed to present remote Vulkan swapchain\n");
     return -1;
 }
+
+VkResult wayland_remote_vk_filter_supported_formats(uint32_t *count_filtered_formats,
+                                                    void *filtered_formats,
+                                                    uint32_t count_formats_to_filter,
+                                                    void *formats_to_filter,
+                                                    size_t format_size,
+                                                    size_t vk_surface_format_offset)
+{
+    VkFormat format;
+    VkResult res = VK_SUCCESS;
+    uint32_t count_intersect;
+    unsigned int i;
+
+    for (count_intersect = 0, i = 0; i < count_formats_to_filter; i++)
+    {
+        format = *(VkFormat *)((char *)formats_to_filter +
+                               (i * format_size) + vk_surface_format_offset);
+        if (vulkan_format_to_drm_format(format, FALSE) != DRM_FORMAT_INVALID)
+        {
+            if (filtered_formats)
+            {
+                if (count_intersect < *count_filtered_formats)
+                {
+                    /* There's room for a format on the array, so add it */
+                    memcpy((char *)filtered_formats + (count_intersect * format_size),
+                           (char *)formats_to_filter + (i * format_size),
+                           format_size);
+                }
+                else
+                {
+                    /* Array size is not enough to accommodate all the formats
+                     * we support, so we must return VK_INCOMPLETE */
+                    res = VK_INCOMPLETE;
+                    break;
+                }
+            }
+            count_intersect++;
+        }
+    }
+
+    /* We just set count_filtered_formats when the client want us to do that
+     * (i.e., filtered_formats == NULL) and when the client want us to fill
+     * filtered_formats but for some reason the size of the array is larger than
+     * the number of formats that we support. */
+    if (!filtered_formats || *count_filtered_formats > count_intersect)
+        *count_filtered_formats = count_intersect;
+
+    return res;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
index aa6909035b5..5be34f4e28a 100644
--- a/dlls/winewayland.drv/vulkan_remote.h
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -47,5 +47,11 @@ VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk
                                                         uint32_t *image_index) DECLSPEC_HIDDEN;
 int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
                                         uint32_t image_index) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_filter_supported_formats(uint32_t *count_filtered_formats,
+                                                    void *filtered_formats,
+                                                    uint32_t count_formats_to_filter,
+                                                    void *formats_to_filter,
+                                                    size_t format_size,
+                                                    size_t vk_surface_format_offset) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
-- 
2.39.0.rc2

From b43380d8cb68ff67d3d3837fc4001c06d5ea96c1 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Thu, 22 Sep 2022 11:04:06 +0300
Subject: [PATCH 173/202] winewayland.drv: Set Vulkan image extents for
 cross-process rendering.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 7c4301957b3..61c2f226a10 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -913,13 +913,25 @@ static void set_image_extent(VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *cap
     struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
     BOOL zero_extents = FALSE;
 
-    if (!wine_vk_surface || !wine_vk_surface->wayland_surface)
+    if (!wine_vk_surface)
         return;
 
-    wayland_mutex_lock(&wine_vk_surface->wayland_surface->mutex);
-    if (!wine_vk_surface->wayland_surface->drawing_allowed)
-        zero_extents = TRUE;
-    wayland_mutex_unlock(&wine_vk_surface->wayland_surface->mutex);
+    if (wine_vk_surface_is_remote(wine_vk_surface))
+    {
+        /* For cross-process surfaces, we don't have the information of
+         * drawing_allowed. So we set zero_extents to FALSE. That is safe to do
+         * because the process that will call wl_surface_commit() won't commit
+         * anything when drawing_allowed == FALSE. */
+        zero_extents = FALSE;
+    }
+    else
+    {
+        assert(wine_vk_surface->wayland_surface);
+        wayland_mutex_lock(&wine_vk_surface->wayland_surface->mutex);
+        if (!wine_vk_surface->wayland_surface->drawing_allowed)
+            zero_extents = TRUE;
+        wayland_mutex_unlock(&wine_vk_surface->wayland_surface->mutex);
+    }
 
     if (NtUserGetWindowLongW(wine_vk_surface->hwnd, GWL_STYLE) & WS_MINIMIZE)
         zero_extents = TRUE;
@@ -946,10 +958,10 @@ static void set_image_extent(VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *cap
         caps->currentExtent.height = client.bottom;
     }
 
-    TRACE("vk_surface=%s hwnd=%p wayland_surface=%p extent=%dx%d\n",
+    TRACE("vk_surface=%s hwnd=%p wayland_surface=%p dummy_wl_surface=%p extent=%dx%d\n",
           wine_dbgstr_longlong(surface), wine_vk_surface->hwnd,
-          wine_vk_surface->wayland_surface, caps->currentExtent.width,
-          caps->currentExtent.height);
+          wine_vk_surface->wayland_surface, wine_vk_surface->dummy_wl_surface,
+          caps->currentExtent.width, caps->currentExtent.height);
 }
 
 static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice phys_dev,
-- 
2.39.0.rc2

From 7c47dcda1b9b8124a20d837f705f2027f5d3e511 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Fri, 23 Sep 2022 11:54:55 +0300
Subject: [PATCH 174/202] winewayland.drv: Implement cross-process Vulkan
 throttling.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan_remote.c | 76 +++++++++++++++++++++++++++-
 1 file changed, 74 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
index 0851be94094..726f064d1b1 100644
--- a/dlls/winewayland.drv/vulkan_remote.c
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -72,6 +72,8 @@ struct wayland_remote_vk_swapchain
     struct wayland_remote_surface_proxy *remote_surface_proxy;
     uint32_t count_images;
     struct wayland_remote_vk_image *images;
+    enum wayland_remote_buffer_commit buffer_commit;
+    HANDLE remote_throttle_event;
 };
 
 struct drm_vk_format
@@ -393,6 +395,10 @@ void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swa
         }
         free(swapchain->images);
     }
+
+    if (swapchain->remote_throttle_event)
+        NtClose(swapchain->remote_throttle_event);
+
     free(swapchain);
 }
 
@@ -460,6 +466,12 @@ struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd
     if (res < 0)
         goto err;
 
+    swapchain->buffer_commit =
+        (create_info->presentMode == VK_PRESENT_MODE_FIFO_KHR) ?
+            WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED :
+            WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL;
+
+    swapchain->remote_throttle_event = 0;
 
     return swapchain;
 
@@ -669,6 +681,63 @@ err:
     return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
 
+static DWORD wayland_remote_vk_swapchain_wait_throttle(struct wayland_remote_vk_swapchain *swapchain,
+                                                       int timeout_ms)
+{
+    UINT ret;
+    LARGE_INTEGER timeout;
+
+    TRACE("remote_throttle_event=%p timeout_ms=%d\n",
+          swapchain->remote_throttle_event, timeout_ms);
+
+    if (!wayland_remote_surface_proxy_dispatch_events(swapchain->remote_surface_proxy))
+    {
+        ERR("Failed to dispatch remote events\n");
+        return WAIT_FAILED;
+    }
+
+    ret = NtWaitForSingleObject(swapchain->remote_throttle_event, FALSE,
+                                get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_OBJECT_0)
+    {
+        NtClose(swapchain->remote_throttle_event);
+        swapchain->remote_throttle_event = 0;
+    }
+
+    TRACE("=> ret=%d\n", ret);
+    return ret;
+}
+
+static void wayland_remote_vk_swapchain_throttle(struct wayland_remote_vk_swapchain *swapchain)
+{
+    static const UINT timeout = 100;
+    UINT start, elapsed;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    TRACE("throttle_event=%p\n", swapchain->remote_throttle_event);
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (elapsed < timeout && swapchain->remote_throttle_event &&
+           wayland_remote_vk_swapchain_wait_throttle(swapchain, 10) != WAIT_FAILED)
+    {
+        elapsed = get_tick_count_since(start);
+    }
+
+    TRACE("throttle_event=%p => elapsed=%d\n",
+          swapchain->remote_throttle_event, elapsed);
+
+    if (swapchain->remote_throttle_event)
+    {
+        NtClose(swapchain->remote_throttle_event);
+        swapchain->remote_throttle_event = 0;
+    }
+}
+
 int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
                                         uint32_t image_index)
 {
@@ -677,12 +746,15 @@ int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swap
     image = &swapchain->images[image_index];
     image->busy = TRUE;
 
+    if (swapchain->remote_throttle_event)
+        wayland_remote_vk_swapchain_throttle(swapchain);
+
     if (!wayland_remote_surface_proxy_commit(swapchain->remote_surface_proxy,
                                              &image->native_buffer,
                                              WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
-                                             WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL,
+                                             swapchain->buffer_commit,
                                              &image->remote_buffer_released_event,
-                                             NULL))
+                                             &swapchain->remote_throttle_event))
     {
         wayland_remote_vk_image_release(image);
         goto err;
-- 
2.39.0.rc2

From ccffb07a7234cbf1e20c248a99c14b4fef58e40d Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Mon, 26 Sep 2022 19:26:22 -0300
Subject: [PATCH 175/202] winewayland.drv: Allow applications to render using
 cross-process Vulkan.

Now that we have all the pieces together, allow applications to render
using the cross-process Vulkan swapchain.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 +-----------
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 61c2f226a10..c968842608f 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -50,10 +50,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
 
-/* This is temporary until we fully support remote (cross-process) Vulkan
- * rendering, as we are progressively adding commits that add the support. */
-static const BOOL remote_rendering_supported = FALSE;
-
 typedef struct VkWaylandSurfaceCreateInfoKHR
 {
     VkStructureType sType;
@@ -697,7 +693,7 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
         }
         wine_vk_surface->wayland_surface = wayland_surface;
     }
-    else if (remote_rendering_supported)
+    else
     {
         struct wayland *wayland;
         if (!vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
@@ -718,12 +714,6 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
             goto err;
         }
     }
-    else
-    {
-        ERR("Failed to create surface, cross-process Vulkan rendering not supported yet\n");
-        res = VK_ERROR_OUT_OF_HOST_MEMORY;
-        goto err;
-    }
 
     create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
-- 
2.39.0.rc2

From 1c873b359a3da43e822e77c1d961d70d1e2fe597 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 10:59:51 +0300
Subject: [PATCH 176/202] winewayland.drv: Add skeleton Wayland data device
 support.

This will evolve to support clipboard and drag-and-drop operations in
upcoming commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |   1 +
 dlls/winewayland.drv/wayland.c             |  15 +++
 dlls/winewayland.drv/wayland_data_device.c | 101 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |  16 ++++
 4 files changed, 133 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4e3cc595109..6d7d362c7d9 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -19,6 +19,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_data_device.c \
 	wayland_dmabuf.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index e0717acfe0d..6fd32db66df 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -279,6 +279,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        wayland->wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface,
+                             version < 3 ? version : 3);
+    }
     else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
     {
         wayland->zwp_pointer_constraints_v1 =
@@ -405,6 +411,9 @@ BOOL wayland_init(struct wayland *wayland)
     }
     else
     {
+        if (wayland->wl_data_device_manager && wayland->wl_seat)
+            wayland_data_device_init(&wayland->data_device, wayland);
+
         /* Thread wayland instances have notification pipes to inform them when
          * there might be new events in their queues. The read part of the pipe
          * is also used as the wine server queue fd. */
@@ -480,6 +489,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->keyboard.wl_keyboard)
         wayland_keyboard_deinit(&wayland->keyboard);
 
+    if (wayland->data_device.wl_data_device)
+        wayland_data_device_deinit(&wayland->data_device);
+
+    if (wayland->wl_data_device_manager)
+        wl_data_device_manager_destroy(wayland->wl_data_device_manager);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..531aa6c79b8
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,101 @@
+/*
+ * Wayland data device (clipboard and DnD) handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void data_device_data_offer(void *data,
+                                   struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_selection(void *data,
+                                  struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+}
+
+static const struct wl_data_device_listener data_device_listener = {
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection
+};
+
+/**********************************************************************
+ *          wayland_data_device_init
+ *
+ * Initializes the data_device extension in order to support clipboard
+ * operations.
+ */
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland)
+{
+    data_device->wayland = wayland;
+    data_device->wl_data_device =
+        wl_data_device_manager_get_data_device(wayland->wl_data_device_manager,
+                                               wayland->wl_seat);
+
+    wl_data_device_add_listener(data_device->wl_data_device, &data_device_listener,
+                                data_device);
+}
+
+/**********************************************************************
+ *          wayland_data_device_deinit
+ */
+void wayland_data_device_deinit(struct wayland_data_device *data_device)
+{
+    if (data_device->wl_data_device)
+        wl_data_device_destroy(data_device->wl_data_device);
+
+    memset(data_device, 0, sizeof(*data_device));
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a9386e997e2..34e3e4da2f1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -233,6 +233,12 @@ struct wayland_dmabuf
     struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
 };
 
+struct wayland_data_device
+{
+    struct wayland *wayland;
+    struct wl_data_device *wl_data_device;
+};
+
 struct wayland
 {
     struct wl_list thread_link;
@@ -248,6 +254,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct wl_data_device_manager *wl_data_device_manager;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
@@ -259,6 +266,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     struct wayland_dmabuf dmabuf;
+    struct wayland_data_device data_device;
     DWORD last_dispatch_mask;
     uint32_t last_button_serial;
     int last_event_type;
@@ -660,6 +668,14 @@ void wayland_update_front_buffer(HWND hwnd,
 
 void wayland_invalidate_vulkan_objects(HWND hwnd) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_data_device_deinit(struct wayland_data_device *data_device) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Registry helpers
  */
-- 
2.39.0.rc2

From febcef52b601fee9b571c899e30edabe57ad81df Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 12:04:01 +0300
Subject: [PATCH 177/202] winewayland.drv: Basic tracking of Wayland data
 offers.

Keep track of the wl_data_offer objects sent by the Wayland compositor,
and their properties.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 162 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 2 files changed, 164 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 531aa6c79b8..a8198fac3d8 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -26,14 +26,155 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+struct wayland_data_offer
+{
+    struct wayland *wayland;
+    struct wl_data_offer *wl_data_offer;
+    struct wl_array types;
+    uint32_t source_actions;
+    uint32_t action;
+};
+
+/* Normalize the mime type by skipping inconsequential characters, such as
+ * spaces and double quotes, and converting to lower case. */
+static char *normalize_mime_type(const char *mime)
+{
+    char *new_mime;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    cur_read = mime;
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime = malloc(new_mime_len + 1);
+    if (!new_mime) return NULL;
+    cur_read = mime;
+    cur_write = new_mime;
+
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime;
+}
+
+/**********************************************************************
+ *          wl_data_offer handling
+ */
+
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer,
+                             const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    char **p;
+
+    p = wl_array_add(&data_offer->types, sizeof *p);
+    *p = normalize_mime_type(type);
+}
+
+static void data_offer_source_actions(void *data,
+                                      struct wl_data_offer *wl_data_offer,
+                                      uint32_t source_actions)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->source_actions = source_actions;
+}
+
+static void data_offer_action(void *data, struct wl_data_offer *wl_data_offer,
+                              uint32_t dnd_action)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->action = dnd_action;
+}
+
+static const struct wl_data_offer_listener data_offer_listener = {
+    data_offer_offer,
+    data_offer_source_actions,
+    data_offer_action
+};
+
+static void wayland_data_offer_create(struct wayland *wayland,
+                                      struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_offer *data_offer;
+
+    data_offer = calloc(1, sizeof(*data_offer));
+    if (!data_offer)
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->wayland = wayland;
+    data_offer->wl_data_offer = wl_data_offer;
+    wl_array_init(&data_offer->types);
+    wl_data_offer_add_listener(data_offer->wl_data_offer,
+                               &data_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+
+    wl_data_offer_destroy(data_offer->wl_data_offer);
+    wl_array_for_each(p, &data_offer->types)
+        free(*p);
+    wl_array_release(&data_offer->types);
+
+    free(data_offer);
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
 
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+}
+
+static void wayland_data_device_destroy_dnd_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->dnd_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->dnd_wl_data_offer = NULL;
+    }
+}
+
 static void data_device_data_offer(void *data,
                                    struct wl_data_device *wl_data_device,
                                    struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_offer_create(data_device->wayland, wl_data_offer);
 }
 
 static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
@@ -41,10 +182,19 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
                               wl_fixed_t x_w, wl_fixed_t y_w,
                               struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    /* Any previous dnd offer should have been freed by a drop or leave event. */
+    assert(data_device->dnd_wl_data_offer == NULL);
+
+    data_device->dnd_wl_data_offer = wl_data_offer;
 }
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
 static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
@@ -54,12 +204,21 @@ static void data_device_motion(void *data, struct wl_data_device *wl_data_device
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
 static void data_device_selection(void *data,
                                   struct wl_data_device *wl_data_device,
                                   struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    /* Destroy any previous data offer. */
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+
+    data_device->clipboard_wl_data_offer = wl_data_offer;
 }
 
 static const struct wl_data_device_listener data_device_listener = {
@@ -94,6 +253,9 @@ void wayland_data_device_init(struct wayland_data_device *data_device,
  */
 void wayland_data_device_deinit(struct wayland_data_device *data_device)
 {
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    wayland_data_device_destroy_dnd_data_offer(data_device);
+
     if (data_device->wl_data_device)
         wl_data_device_destroy(data_device->wl_data_device);
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 34e3e4da2f1..4c5d9d26e15 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -237,6 +237,8 @@ struct wayland_data_device
 {
     struct wayland *wayland;
     struct wl_data_device *wl_data_device;
+    struct wl_data_offer *clipboard_wl_data_offer;
+    struct wl_data_offer *dnd_wl_data_offer;
 };
 
 struct wayland
-- 
2.39.0.rc2

From 79c271c5cfd9940f9853c23e833b813e6bdd2cec Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Jun 2022 12:39:39 +0300
Subject: [PATCH 178/202] winewayland.drv: Introduce infrastructure for driver
 kernel callbacks.

This mechanism allows the unixlib code of the driver to call back into
the PE code.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/dllmain.c         | 12 ++++++++++++
 dlls/winewayland.drv/unixlib.h         | 12 ++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |  9 +++++++++
 dlls/winewayland.drv/waylanddrv_main.c | 11 +++++++++++
 4 files changed, 42 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index 4aee1d6b948..d7abdf25b38 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -20,6 +20,13 @@
 
 #include "waylanddrv_dll.h"
 
+typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
+static const kernel_callback kernel_callbacks[] =
+{
+};
+
+C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == waylanddrv_client_func_last);
+
 static DWORD WINAPI wayland_read_events_thread(void *arg)
 {
     WAYLANDDRV_UNIX_CALL(read_events, NULL);
@@ -32,12 +39,17 @@ static DWORD WINAPI wayland_read_events_thread(void *arg)
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     DWORD tid;
+    void **callback_table;
 
     if (reason != DLL_PROCESS_ATTACH) return TRUE;
 
     DisableThreadLibraryCalls(instance);
     if (__wine_init_unix_call()) return FALSE;
 
+    callback_table = NtCurrentTeb()->Peb->KernelCallbackTable;
+    memcpy(callback_table + NtUserDriverCallbackFirst, kernel_callbacks,
+           sizeof(kernel_callbacks));
+
     if (WAYLANDDRV_UNIX_CALL(init, NULL))
         return FALSE;
 
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index dc3bfdf8893..4c70e876223 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -19,8 +19,8 @@
 #ifndef __WINE_WAYLANDDRV_UNIXLIB_H
 #define __WINE_WAYLANDDRV_UNIXLIB_H
 
-#include <stdarg.h>
-#include "winternl.h"
+#include "windef.h"
+#include "ntuser.h"
 #include "wine/unixlib.h"
 
 enum waylanddrv_unix_func
@@ -30,4 +30,12 @@ enum waylanddrv_unix_func
     waylanddrv_unix_func_count,
 };
 
+/* driver client callbacks exposed with KernelCallbackTable interface */
+enum waylanddrv_client_func
+{
+    waylanddrv_client_func_last = NtUserDriverCallbackFirst
+};
+
+C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
+
 #endif /* __WINE_WAYLANDDRV_UNIXLIB_H */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4c5d9d26e15..49652f38731 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -48,6 +48,8 @@
 #include "unixlib.h"
 #include "wine/gdi_driver.h"
 
+#define WAYLANDDRV_CLIENT_CALL(func, params, size) waylanddrv_client_call(waylanddrv_client_func_ ## func, params, size)
+
 /**********************************************************************
  *          Globals
  */
@@ -782,6 +784,13 @@ static inline HWND get_focus(void)
     return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndFocus : 0;
 }
 
+/**********************************************************************
+ *          PE/unixlib support
+ */
+
+NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
+                                ULONG size) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          USER driver functions
  */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5c57e5e6f22..5728dece440 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -217,3 +217,14 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
+
+/***********************************************************************
+ *           waylanddrv_client_call
+ */
+NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
+                                ULONG size)
+{
+    void *ret_ptr;
+    ULONG ret_len;
+    return KeUserModeCallback(func, params, size, &ret_ptr, &ret_len);
+}
-- 
2.39.0.rc2

From d1a1b17bf6cf24c069793b82fd1c3fb450704080 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 12:35:18 +0300
Subject: [PATCH 179/202] winewayland.drv: Create dedicated window to handle
 clipboard messages.

The clipboard window is created in the PE code, initiated by a driver
kernel callback invoked from the unixlib side. Clipboard messages
are received in the PE side and forwarded to the unixlib side to
be handled there.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |  2 +
 dlls/winewayland.drv/dllmain.c                |  1 +
 dlls/winewayland.drv/unixlib.h                | 12 ++-
 dlls/winewayland.drv/wayland_data_device.c    | 32 ++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 78 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             |  4 +
 dlls/winewayland.drv/waylanddrv_dll.h         |  2 +
 dlls/winewayland.drv/waylanddrv_main.c        |  9 +++
 dlls/winewayland.drv/window.c                 |  3 +
 9 files changed, 142 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_data_device_dll.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 6d7d362c7d9..b4d547d5cfb 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,6 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
+IMPORTS = user32
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
               $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
@@ -20,6 +21,7 @@ C_SRCS = \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
 	wayland_data_device.c \
+	wayland_data_device_dll.c \
 	wayland_dmabuf.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index d7abdf25b38..ca2a2087381 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -23,6 +23,7 @@
 typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
 static const kernel_callback kernel_callbacks[] =
 {
+    waylanddrv_client_create_clipboard_window,
 };
 
 C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == waylanddrv_client_func_last);
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 4c70e876223..7c9f55d2356 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -27,13 +27,23 @@ enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
     waylanddrv_unix_func_read_events,
+    waylanddrv_unix_func_clipboard_message,
     waylanddrv_unix_func_count,
 };
 
+struct waylanddrv_unix_clipboard_message_params
+{
+    HWND hwnd;
+    UINT msg;
+    WPARAM wparam;
+    LPARAM lparam;
+};
+
 /* driver client callbacks exposed with KernelCallbackTable interface */
 enum waylanddrv_client_func
 {
-    waylanddrv_client_func_last = NtUserDriverCallbackFirst
+    waylanddrv_client_func_create_clipboard_window = NtUserDriverCallbackFirst,
+    waylanddrv_client_func_last
 };
 
 C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index a8198fac3d8..326a981e709 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -261,3 +261,35 @@ void wayland_data_device_deinit(struct wayland_data_device *data_device)
 
     memset(data_device, 0, sizeof(*data_device));
 }
+
+/**********************************************************************
+ *          waylanddrv_unix_clipboard_message
+ */
+NTSTATUS waylanddrv_unix_clipboard_message(void *arg)
+{
+    struct waylanddrv_unix_clipboard_message_params *params = arg;
+
+    switch (params->msg)
+    {
+    case WM_NCCREATE:
+        return TRUE;
+    }
+
+    return NtUserMessageCall(params->hwnd, params->msg, params->wparam,
+                             params->lparam, NULL, NtUserDefWindowProc, FALSE);
+}
+
+/**********************************************************************
+ *          wayland_data_device_ensure_clipboard_window
+ *
+ * Creates (if not already created) the window which handles clipboard
+ * messages for the specified wayland instance.
+ */
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
+{
+    if (!wayland->clipboard_hwnd)
+    {
+        wayland->clipboard_hwnd =
+            ULongToHandle(WAYLANDDRV_CLIENT_CALL(create_clipboard_window, NULL, 0));
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
new file mode 100644
index 00000000000..01ee6bc2a0f
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -0,0 +1,78 @@
+/*
+ * Wayland data device (clipboard and DnD) handling (DLL code)
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "waylanddrv_dll.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    struct waylanddrv_unix_clipboard_message_params params;
+
+    switch (msg)
+    {
+    case WM_NCCREATE:
+    case WM_CLIPBOARDUPDATE:
+    case WM_RENDERFORMAT:
+    case WM_DESTROYCLIPBOARD:
+        params.hwnd = hwnd;
+        params.msg = msg;
+        params.wparam = wp;
+        params.lparam = lp;
+        return WAYLANDDRV_UNIX_CALL(clipboard_message, &params);
+    }
+
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size)
+{
+    static const WCHAR clipboard_classname[] = {
+        '_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d',
+        '_','m','a','n','a','g','e','r',0
+    };
+    WNDCLASSW class;
+    HWND clipboard_hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW(&class) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %lu\n", GetLastError());
+        return 0;
+    }
+
+    if (!(clipboard_hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                         HWND_MESSAGE, 0, 0, NULL)))
+    {
+        ERR("failed to create clipboard window err %lu\n", GetLastError());
+        return 0;
+    }
+
+    if (!AddClipboardFormatListener(clipboard_hwnd))
+        ERR("failed to set clipboard listener %lu\n", GetLastError());
+
+    TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
+    return HandleToUlong(clipboard_hwnd);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 49652f38731..f780f916571 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -76,6 +76,7 @@ enum wayland_window_message
     WM_WAYLAND_WINDOW_SURFACE_FLUSH,
     WM_WAYLAND_REMOTE_SURFACE,
     WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+    WM_WAYLAND_CLIPBOARD_WINDOW_CREATE,
 };
 
 enum wayland_surface_role
@@ -275,6 +276,7 @@ struct wayland
     uint32_t last_button_serial;
     int last_event_type;
     int event_notification_pipe[2];
+    HWND clipboard_hwnd;
     RECT cursor_clip;
 };
 
@@ -679,6 +681,7 @@ void wayland_invalidate_vulkan_objects(HWND hwnd) DECLSPEC_HIDDEN;
 void wayland_data_device_init(struct wayland_data_device *data_device,
                               struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_data_device_deinit(struct wayland_data_device *data_device) DECLSPEC_HIDDEN;
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
@@ -790,6 +793,7 @@ static inline HWND get_focus(void)
 
 NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
                                 ULONG size) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_clipboard_message(void *arg) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER driver functions
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
index 123b6cd5a61..68d04d34be7 100644
--- a/dlls/winewayland.drv/waylanddrv_dll.h
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -29,4 +29,6 @@
 
 #define WAYLANDDRV_UNIX_CALL(func, params) WINE_UNIX_CALL(waylanddrv_unix_func_ ## func, params)
 
+NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size);
+
 #endif /* __WINE_WAYLANDDRV_DLL_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5728dece440..d714d74fa43 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -95,6 +95,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
     set_queue_fd(&data->wayland);
     NtUserGetThreadInfo()->driver_data = (UINT_PTR)data;
 
+    /* Create the clipboard window outside of thread init. We delay window
+     * creation since the thread init function may be invoked from within the
+     * context of a user32 function which holds the internal Wine user32 lock.
+     * In such a case creating the clipboard window would cause an internal
+     * user32 lock error. */
+    NtUserPostThreadMessage(data->wayland.thread_id,
+                            WM_WAYLAND_CLIPBOARD_WINDOW_CREATE, 0, 0);
+
     return data;
 }
 
@@ -214,6 +222,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_clipboard_message,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 5fc3ec725ec..8eecb6e90d8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1747,6 +1747,9 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_CLIPBOARD_WINDOW_CREATE:
+        wayland_data_device_ensure_clipboard_window(thread_wayland());
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, (long)wp, lp);
     }
-- 
2.39.0.rc2

From cc4d7de40c8a0c92ca9c73b37e5de8e3dfdf6aea Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:00:10 +0300
Subject: [PATCH 180/202] winewayland.drv: Add skeleton data device format
 infrastructure.

Introduce infrastructure to convert clipboard/drag-and-drop data
between what Wayland understands and what Wine understands.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |  1 +
 .../wayland_data_device_format.c              | 97 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             | 17 ++++
 dlls/winewayland.drv/waylanddrv_main.c        |  2 +
 4 files changed, 117 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device_format.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index b4d547d5cfb..b73422ffa1b 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -22,6 +22,7 @@ C_SRCS = \
 	wayland_cursor.c \
 	wayland_data_device.c \
 	wayland_data_device_dll.c \
+	wayland_data_device_format.c \
 	wayland_dmabuf.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
new file mode 100644
index 00000000000..395e918a7bb
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -0,0 +1,97 @@
+/*
+ * Wayland data device format handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winternl.h"
+
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct wayland_data_device_format supported_formats[] =
+{
+    {NULL, 0, NULL, NULL, NULL, 0},
+};
+
+static ATOM register_clipboard_format(const WCHAR *name)
+{
+    ATOM atom;
+    if (NtAddAtom(name, lstrlenW(name) * sizeof(WCHAR), &atom)) return 0;
+    return atom;
+}
+
+void wayland_data_device_init_formats(void)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = register_clipboard_format(format->register_name);
+        format++;
+    }
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (!strcmp(mime, format->mime_type))
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
+
+static BOOL string_array_contains(struct wl_array *array, const char *str)
+{
+    char **p;
+
+    wl_array_for_each(p, array)
+        if (!strcmp(*p, str)) return TRUE;
+
+    return FALSE;
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                                   struct wl_array *mimes)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == clipboard_format &&
+            (!mimes || string_array_contains(mimes, format->mime_type)))
+        {
+             return format;
+        }
+        format++;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f780f916571..1a4ff88d826 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -244,6 +244,19 @@ struct wayland_data_device
     struct wl_data_offer *dnd_wl_data_offer;
 };
 
+struct wayland_data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    const WCHAR *register_name;
+    /* In case of failure, 'ret_size' is left unchanged. */
+    void *(*import)(struct wayland_data_device_format *format,
+                    const void *data, size_t data_size, size_t *ret_size);
+    void (*export)(struct wayland_data_device_format *format, int fd,
+                   void *data, size_t size);
+    UINT_PTR extra;
+};
+
 struct wayland
 {
     struct wl_list thread_link;
@@ -682,6 +695,10 @@ void wayland_data_device_init(struct wayland_data_device *data_device,
                               struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_data_device_deinit(struct wayland_data_device *data_device) DECLSPEC_HIDDEN;
 void wayland_data_device_ensure_clipboard_window(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_data_device_init_formats(void) DECLSPEC_HIDDEN;
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime) DECLSPEC_HIDDEN;
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                                   struct wl_array *mimes) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d714d74fa43..e1824120e53 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -199,6 +199,8 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
 
     wayland_read_options_from_registry();
 
+    wayland_data_device_init_formats();
+
     if (!wayland_init_set_cursor()) goto err;
 
     if (!wayland_process_init()) goto err;
-- 
2.39.0.rc2

From ce7fc157803cd04aa1c969ced5a567f296c0aaaa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 5 Oct 2021 10:08:26 +0300
Subject: [PATCH 181/202] winewayland.drv: Add helper to write all data to a
 file descriptor.

Add a function that ensures that all data is written to a file
descriptor, resuming in case of interruptions or partial writes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 27 +++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 395e918a7bb..efaa4ec22b8 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -26,8 +26,35 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
 #include "winternl.h"
 
+#include <errno.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+
+    while (nwritten < count)
+    {
+        ssize_t ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR)
+        {
+            WARN("Failed to write all data, had %zu bytes, wrote %zu bytes (errno: %d)\n",
+                 count, nwritten, errno);
+            break;
+        }
+        else if (ret > 0)
+        {
+            nwritten += ret;
+        }
+    }
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct wayland_data_device_format supported_formats[] =
-- 
2.39.0.rc2

From ea88cf1bd29508668b027ff7f1d9b1e56299e5e7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:04:39 +0300
Subject: [PATCH 182/202] winewayland.drv: Support text/plain data device
 formats.

Convert between CF_UNICODETEXT clipboard format and common
"text/plain" Wayland clipboard formats.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 82 +++++++++++++++++++
 1 file changed, 82 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index efaa4ec22b8..e5cf0aacadb 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -29,8 +29,10 @@
 #include "wine/debug.h"
 
 #include "winternl.h"
+#include "winnls.h"
 
 #include <errno.h>
+#include <stdlib.h>
 #include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
@@ -55,10 +57,90 @@ static void write_all(int fd, const void *buf, size_t count)
     }
 }
 
+#define NLS_SECTION_CODEPAGE 11
+
+static BOOL get_cp_tableinfo(ULONG cp, CPTABLEINFO *cptable)
+{
+    USHORT *ptr;
+    SIZE_T nls_size;
+
+    if (!NtGetNlsSectionPtr(NLS_SECTION_CODEPAGE, cp, NULL, (void **)&ptr, &nls_size))
+    {
+        RtlInitCodePageTable(ptr, cptable);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void *import_text_as_unicode(struct wayland_data_device_format *format,
+                                    const void *data, size_t data_size, size_t *ret_size)
+{
+    DWORD wsize;
+    void *ret;
+
+    if (format->extra == CP_UTF8)
+    {
+        RtlUTF8ToUnicodeN(NULL, 0, &wsize, data, data_size);
+        if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+        RtlUTF8ToUnicodeN(ret, wsize, &wsize, data, data_size);
+    }
+    else
+    {
+        CPTABLEINFO cptable;
+        /* In the worst case, each byte of the input text data corresponds
+         * to a single character, which may need up to two WCHAR for UTF-16
+         * encoding. */
+        wsize = data_size * sizeof(WCHAR) * 2;
+        if (!get_cp_tableinfo(format->extra, &cptable)) return NULL;
+        if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+        RtlCustomCPToUnicodeN(&cptable, ret, wsize, &wsize, data, data_size);
+    }
+    ((WCHAR *)ret)[wsize / sizeof(WCHAR)] = 0;
+
+    if (ret_size) *ret_size = wsize + sizeof(WCHAR);
+
+    return ret;
+}
+
+static void export_text(struct wayland_data_device_format *format, int fd, void *data, size_t size)
+{
+    DWORD byte_count;
+    char *bytes;
+
+    /* Wayland apps expect strings to not be zero-terminated, so avoid
+     * zero-terminating the resulting converted string. */
+    if (((WCHAR *)data)[size / sizeof(WCHAR) - 1] == 0) size -= sizeof(WCHAR);
+
+    if (format->extra == CP_UTF8)
+    {
+        RtlUnicodeToUTF8N(NULL, 0, &byte_count, data, size);
+        if (!(bytes = malloc(byte_count))) return;
+        RtlUnicodeToUTF8N(bytes, byte_count, &byte_count, data, size);
+    }
+    else
+    {
+        CPTABLEINFO cptable;
+        if (!get_cp_tableinfo(format->extra, &cptable)) return;
+        byte_count = size / sizeof(WCHAR) * cptable.MaximumCharacterSize;
+        if (!(bytes = malloc(byte_count))) return;
+        RtlUnicodeToCustomCPN(&cptable, bytes, byte_count, &byte_count, data, size);
+    }
+
+    write_all(fd, bytes, byte_count);
+
+    free(bytes);
+}
+
+#define CP_ASCII 20127
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct wayland_data_device_format supported_formats[] =
 {
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
+    {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {NULL, 0, NULL, NULL, NULL, 0},
 };
 
-- 
2.39.0.rc2

From 8efe1ba47ef4a883449f23275254336b36ca3a12 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:06:57 +0300
Subject: [PATCH 183/202] winewayland.drv: Support RTF data device format.

Import and export RTF clipboard/drag-and-drop data.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 24 +++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index e5cf0aacadb..4f5640e0aee 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -132,8 +132,30 @@ static void export_text(struct wayland_data_device_format *format, int fd, void
     free(bytes);
 }
 
+static void *import_data(struct wayland_data_device_format *format,
+                         const void *data, size_t data_size, size_t *ret_size)
+{
+    void *ret;
+
+    ret = malloc(data_size);
+    if (ret)
+    {
+        memcpy(ret, data, data_size);
+        if (ret_size) *ret_size = data_size;
+    }
+
+    return ret;
+}
+
+static void export_data(struct wayland_data_device_format *format, int fd, void *data, size_t size)
+{
+    write_all(fd, data, size);
+}
+
 #define CP_ASCII 20127
 
+static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct wayland_data_device_format supported_formats[] =
@@ -141,6 +163,8 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
     {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/rtf", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/richtext", 0, rich_text_formatW, import_data, export_data, 0},
     {NULL, 0, NULL, NULL, NULL, 0},
 };
 
-- 
2.39.0.rc2

From ce4acbcdbbd9736838c6264b67fd0aa5bbbe00a7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:12:09 +0300
Subject: [PATCH 184/202] winewayland.drv: Support text/uri-list data device
 format.

Convert between CF_HDROP Windows clipboard format and "text/uri-list"
Wayland clipboard format.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 362 ++++++++++++++++++
 1 file changed, 362 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 4f5640e0aee..bf7f3d68467 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -24,10 +24,14 @@
 
 #include "config.h"
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
 
+#include "shlobj.h"
 #include "winternl.h"
 #include "winnls.h"
 
@@ -152,6 +156,363 @@ static void export_data(struct wayland_data_device_format *format, int fd, void
     write_all(fd, data, size);
 }
 
+/* Adapted from winex11.drv/clipboard.c */
+static char *decode_uri(const char *uri, size_t uri_length)
+{
+    char *decoded = malloc(uri_length + 1);
+    size_t uri_i = 0;
+    size_t decoded_i = 0;
+
+    if (decoded == NULL)
+        goto err;
+
+    while (uri_i < uri_length)
+    {
+        if (uri[uri_i] == '%')
+        {
+            unsigned long number;
+            char buffer[3];
+
+            if (uri_i + 1 == uri_length || uri_i + 2 == uri_length)
+                goto err;
+
+            buffer[0] = uri[uri_i + 1];
+            buffer[1] = uri[uri_i + 2];
+            buffer[2] = '\0';
+            errno = 0;
+            number = strtoul(buffer, NULL, 16);
+            if (errno != 0) goto err;
+            decoded[decoded_i] = number;
+
+            uri_i += 3;
+            decoded_i++;
+        }
+        else
+        {
+            decoded[decoded_i++] = uri[uri_i++];
+        }
+    }
+
+    decoded[decoded_i] = '\0';
+
+    return decoded;
+
+err:
+    free(decoded);
+    return NULL;
+}
+
+/* based on wine_get_dos_file_name */
+static WCHAR *get_dos_file_name(const char *path)
+{
+    ULONG len = strlen(path) + 9; /* \??\unix prefix */
+    WCHAR *ret;
+
+    if (!(ret = malloc(len * sizeof(WCHAR)))) return NULL;
+    if (wine_unix_to_nt_file_name(path, ret, &len))
+    {
+        free(ret);
+        return NULL;
+    }
+
+    if (ret[5] == ':')
+    {
+        /* get rid of the \??\ prefix */
+        memmove(ret, ret + 4, (len - 4) * sizeof(WCHAR));
+    }
+    else
+    {
+        ret[1] = '\\';
+    }
+    return ret;
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static WCHAR* decoded_uri_to_dos(const char *uri)
+{
+    WCHAR *ret = NULL;
+
+    if (strncmp(uri, "file:/", 6))
+        return NULL;
+
+    if (uri[6] == '/')
+    {
+        if (uri[7] == '/')
+        {
+            /* file:///path/to/file (nautilus, thunar) */
+            ret = get_dos_file_name(&uri[7]);
+        }
+        else if (uri[7])
+        {
+            /* file://hostname/path/to/file (X file drag spec) */
+            char hostname[256];
+            char *path = strchr(&uri[7], '/');
+            if (path)
+            {
+                *path = '\0';
+                if (strcmp(&uri[7], "localhost") == 0)
+                {
+                    *path = '/';
+                    ret = get_dos_file_name(path);
+                }
+                else if (gethostname(hostname, sizeof(hostname)) == 0)
+                {
+                    if (strcmp(hostname, &uri[7]) == 0)
+                    {
+                        *path = '/';
+                        ret = get_dos_file_name(path);
+                    }
+                }
+            }
+        }
+    }
+    else if (uri[6])
+    {
+        /* file:/path/to/file (konqueror) */
+        ret = get_dos_file_name(&uri[5]);
+    }
+
+    return ret;
+}
+
+static void *import_uri_list(struct wayland_data_device_format *format,
+                             const void *data, size_t data_size, size_t *ret_size)
+{
+    DROPFILES *drop_files = NULL;
+    size_t drop_size;
+    const char *data_end = (const char *) data + data_size;
+    const char *line_start = data;
+    const char *line_end;
+    WCHAR **path;
+    struct wl_array paths;
+    size_t total_chars = 0;
+    WCHAR *dst;
+
+    TRACE("data=%p size=%lu\n", data, (unsigned long)data_size);
+
+    wl_array_init(&paths);
+
+    while (line_start < data_end)
+    {
+        /* RFC 2483 requires CRLF for text/uri-list line termination, but
+         * some applications send LF. Accept both line terminators. */
+        line_end = strchr(line_start, '\n');
+        if (line_end == NULL)
+        {
+            WARN("URI list line doesn't end in (\\r)\\n\n");
+            break;
+        }
+
+        if (line_end > line_start && line_end[-1] == '\r') line_end--;
+
+        if (line_start[0] != '#')
+        {
+            char *decoded_uri = decode_uri(line_start, line_end - line_start);
+            TRACE("decoded_uri=%s\n", decoded_uri);
+            path = wl_array_add(&paths, sizeof *path);
+            if (!path) goto out;
+            *path = decoded_uri_to_dos(decoded_uri);
+            total_chars += lstrlenW(*path) + 1;
+            free(decoded_uri);
+        }
+
+        line_start = line_end + (*line_end == '\r' ? 2 : 1);
+    }
+
+    /* DROPFILES points to an array of consecutive null terminated WCHAR strings,
+     * followed by a final 0 WCHAR to denote the end of the array. We place that
+     * array just after the DROPFILE struct itself. */
+    drop_size = sizeof(DROPFILES) + (total_chars + 1) * sizeof(WCHAR);
+    if (!(drop_files = malloc(drop_size)))
+        goto out;
+
+    drop_files->pFiles = sizeof(*drop_files);
+    drop_files->pt.x = 0;
+    drop_files->pt.y = 0;
+    drop_files->fNC = FALSE;
+    drop_files->fWide = TRUE;
+
+    dst = (WCHAR *)(drop_files + 1);
+    wl_array_for_each(path, &paths)
+    {
+        lstrcpyW(dst, *path);
+        dst += lstrlenW(*path) + 1;
+    }
+    *dst = 0;
+
+    if (ret_size) *ret_size = drop_size;
+
+out:
+    wl_array_for_each(path, &paths)
+        free(*path);
+
+    wl_array_release(&paths);
+
+    return drop_files;
+}
+
+static CPTABLEINFO *get_ansi_cp(void)
+{
+    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
+    static CPTABLEINFO cp;
+    if (!cp.CodePage)
+    {
+        if (NtCurrentTeb()->Peb->AnsiCodePageData)
+            RtlInitCodePageTable(NtCurrentTeb()->Peb->AnsiCodePageData, &cp);
+        else
+            RtlInitCodePageTable(utf8_hdr, &cp);
+    }
+    return &cp;
+}
+
+/* Helper functions to implement export_hdrop, adapted from winex11.drv */
+
+static BOOL get_nt_pathname(const WCHAR *name, UNICODE_STRING *nt_name)
+{
+    static const WCHAR ntprefixW[] = {'\\','?','?','\\'};
+    static const WCHAR uncprefixW[] = {'U','N','C','\\'};
+    size_t len = lstrlenW(name);
+    WCHAR *ptr;
+
+    nt_name->MaximumLength = (len + 8) * sizeof(WCHAR);
+    if (!(ptr = malloc(nt_name->MaximumLength))) return FALSE;
+    nt_name->Buffer = ptr;
+
+    memcpy(ptr, ntprefixW, sizeof(ntprefixW));
+    ptr += ARRAYSIZE(ntprefixW);
+    if (name[0] == '\\' && name[1] == '\\')
+    {
+        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
+        {
+            name += 4;
+            len -= 4;
+        }
+        else
+        {
+            memcpy(ptr, uncprefixW, sizeof(uncprefixW));
+            ptr += ARRAYSIZE(uncprefixW);
+            name += 2;
+            len -= 2;
+        }
+    }
+    memcpy(ptr, name, (len + 1) * sizeof(WCHAR));
+    ptr += len;
+    nt_name->Length = (ptr - nt_name->Buffer) * sizeof(WCHAR);
+    return TRUE;
+}
+
+static char *get_unix_file_name(const WCHAR *dosW)
+{
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    ULONG size = 256;
+    char *buffer;
+
+    if (!get_nt_pathname(dosW, &nt_name)) return NULL;
+    InitializeObjectAttributes(&attr, &nt_name, 0, 0, NULL);
+    for (;;)
+    {
+        if (!(buffer = malloc(size)))
+        {
+            free(nt_name.Buffer);
+            return NULL;
+        }
+        status = wine_nt_to_unix_file_name(&attr, buffer, &size, FILE_OPEN_IF);
+        if (status != STATUS_BUFFER_TOO_SMALL) break;
+        free(buffer);
+    }
+    free(nt_name.Buffer);
+    if (status)
+    {
+        free(buffer);
+        return NULL;
+    }
+    return buffer;
+}
+
+/* Export text/uri-list to CF_HDROP, adapted from winex11.drv */
+static void export_hdrop(struct wayland_data_device_format *format, int fd,
+                         void *data, size_t size)
+{
+    char *textUriList = NULL;
+    UINT textUriListSize = 32;
+    UINT next = 0;
+    const WCHAR *ptr;
+    WCHAR *unicode_data = NULL;
+    DROPFILES *drop_files = data;
+
+    if (!drop_files->fWide)
+    {
+        char *files = (char *)data + drop_files->pFiles;
+        CPTABLEINFO *cp = get_ansi_cp();
+        DWORD len = 0;
+
+        while (files[len]) len += strlen(files + len) + 1;
+        len++;
+
+        if (!(ptr = unicode_data = malloc(len * sizeof(WCHAR)))) goto out;
+
+        if (cp->CodePage == CP_UTF8)
+            RtlUTF8ToUnicodeN(unicode_data, len * sizeof(WCHAR), &len, files, len);
+        else
+            RtlCustomCPToUnicodeN(cp, unicode_data, len * sizeof(WCHAR), &len, files, len);
+    }
+    else ptr = (const WCHAR *)((char *)data + drop_files->pFiles);
+
+    if (!(textUriList = malloc(textUriListSize))) goto out;
+
+    while (*ptr)
+    {
+        char *unixFilename = NULL;
+        UINT uriSize;
+        UINT u;
+
+        unixFilename = get_unix_file_name(ptr);
+        if (unixFilename == NULL) goto out;
+        ptr += lstrlenW(ptr) + 1;
+
+        uriSize = 8 + /* file:/// */
+                  3 * (lstrlenA(unixFilename) - 1) + /* "%xy" per char except first '/' */
+                  2; /* \r\n */
+        if ((next + uriSize) > textUriListSize)
+        {
+            UINT biggerSize = max(2 * textUriListSize, next + uriSize);
+            void *bigger = realloc(textUriList, biggerSize);
+            if (bigger)
+            {
+                textUriList = bigger;
+                textUriListSize = biggerSize;
+            }
+            else
+            {
+                free(unixFilename);
+                goto out;
+            }
+        }
+        lstrcpyA(&textUriList[next], "file:///");
+        next += 8;
+        /* URL encode everything - unnecessary, but easier/lighter than
+         * linking in shlwapi, and can't hurt */
+        for (u = 1; unixFilename[u]; u++)
+        {
+            static const char hex_table[] = "0123456789abcdef";
+            textUriList[next++] = '%';
+            textUriList[next++] = hex_table[unixFilename[u] >> 4];
+            textUriList[next++] = hex_table[unixFilename[u] & 0xf];
+        }
+        textUriList[next++] = '\r';
+        textUriList[next++] = '\n';
+        free(unixFilename);
+    }
+
+    write_all(fd, textUriList, next);
+
+out:
+    free(unicode_data);
+    free(textUriList);
+}
+
 #define CP_ASCII 20127
 
 static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
@@ -165,6 +526,7 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/rtf", 0, rich_text_formatW, import_data, export_data, 0},
     {"text/richtext", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_hdrop, 0},
     {NULL, 0, NULL, NULL, NULL, 0},
 };
 
-- 
2.39.0.rc2

From 8e4bd4021232f4e3e809ec73a404eee01d7435fe Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:14:04 +0300
Subject: [PATCH 185/202] winewayland.drv: Support common image data device
 format.

Import and export TIFF, PNG, JPEG and GIF image formats.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device_format.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index bf7f3d68467..069a4157cbe 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -516,6 +516,9 @@ out:
 #define CP_ASCII 20127
 
 static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+static const WCHAR pngW[] = {'P','N','G',0};
+static const WCHAR jfifW[] = {'J','F','I','F',0};
+static const WCHAR gifW[] = {'G','I','F',0};
 
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
@@ -527,6 +530,10 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/rtf", 0, rich_text_formatW, import_data, export_data, 0},
     {"text/richtext", 0, rich_text_formatW, import_data, export_data, 0},
     {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_hdrop, 0},
+    {"image/tiff", CF_TIFF, NULL, import_data, export_data, 0},
+    {"image/png", 0, pngW, import_data, export_data, 0},
+    {"image/jpeg", 0, jfifW, import_data, export_data, 0},
+    {"image/gif", 0, gifW, import_data, export_data, 0},
     {NULL, 0, NULL, NULL, NULL, 0},
 };
 
-- 
2.39.0.rc2

From 780419e5c9d097b555e17bdcfcea5b249f04770b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:22:00 +0300
Subject: [PATCH 186/202] winewayland.drv: Handle WM_CLIPBOARDUPDATE message.

When the Windows clipboard is updated, create a new Wayland data source
that exports the update clipboard data, and make it the current
Wayland data selection.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 161 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 162 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 326a981e709..495d9075ac9 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -30,9 +30,12 @@
 
 #include <assert.h>
 #include <stdlib.h>
+#include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
 struct wayland_data_offer
 {
     struct wayland *wayland;
@@ -256,12 +259,165 @@ void wayland_data_device_deinit(struct wayland_data_device *data_device)
     wayland_data_device_destroy_clipboard_data_offer(data_device);
     wayland_data_device_destroy_dnd_data_offer(data_device);
 
+    if (data_device->wl_data_source)
+        wl_data_source_destroy(data_device->wl_data_source);
     if (data_device->wl_data_device)
         wl_data_device_destroy(data_device->wl_data_device);
 
     memset(data_device, 0, sizeof(*data_device));
 }
 
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void wayland_data_source_export(struct wayland_data_device_format *format, int32_t fd)
+{
+    struct get_clipboard_params params = { .data_only = TRUE, .data_size = 0 };
+    static const size_t buffer_size = 1024;
+
+    if (!(params.data = malloc(buffer_size))) return;
+
+    if (!NtUserOpenClipboard(thread_wayland()->clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for export\n");
+        goto out;
+    }
+
+    params.size = buffer_size;
+    if (NtUserGetClipboardData(format->clipboard_format, &params))
+    {
+        format->export(format, fd, params.data, params.size);
+    }
+    else if (params.data_size)
+    {
+        /* If 'buffer_size' is too small, NtUserGetClipboardData writes the
+         * minimum size in 'params.data_size', so we retry with that. */
+        free(params.data);
+        params.data = malloc(params.data_size);
+        if (params.data)
+        {
+            params.size = params.data_size;
+            if (NtUserGetClipboardData(format->clipboard_format, &params))
+                format->export(format, fd, params.data, params.size);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+out:
+    free(params.data);
+}
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct wayland_data_device_format *format =
+        wayland_data_device_format_for_mime_type(mime_type);
+
+    TRACE("source=%p mime_type=%s\n", source, mime_type);
+
+    if (format) wayland_data_source_export(format, fd);
+
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    TRACE("source=%p\n", source);
+    wl_data_source_destroy(source);
+    data_device->wl_data_source = NULL;
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener = {
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
+/**********************************************************************
+ *          clipboard window handling
+ */
+
+static void clipboard_update(void)
+{
+    struct wayland *wayland = thread_wayland();
+    uint32_t enter_serial;
+    struct wl_data_source *source;
+    UINT clipboard_format = 0;
+
+    TRACE("WM_CLIPBOARDUPDATE wayland %p enter_serial=%d/%d\n",
+          wayland,
+          wayland ? wayland->keyboard.enter_serial : -1,
+          wayland ? wayland->pointer.enter_serial : -1);
+
+    if (!wayland)
+        return;
+
+    enter_serial = wayland->keyboard.enter_serial ? wayland->keyboard.enter_serial
+                                                  : wayland->pointer.enter_serial;
+
+    if (!enter_serial)
+        return;
+
+    if (!NtUserOpenClipboard(wayland->clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard\n");
+        return;
+    }
+
+    source = wl_data_device_manager_create_data_source(wayland->wl_data_device_manager);
+    /* Track the current wl_data_source, so we can properly destroy it during thread
+     * deinitilization, in case it has not been cancelled before that. */
+    if (wayland->data_device.wl_data_source)
+        wl_data_source_destroy(wayland->data_device.wl_data_source);
+    wayland->data_device.wl_data_source = source;
+
+    while ((clipboard_format = NtUserEnumClipboardFormats(clipboard_format)))
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_clipboard_format(clipboard_format, NULL);
+        if (format)
+        {
+            TRACE("Offering source=%p mime=%s\n", source, format->mime_type);
+            wl_data_source_offer(source, format->mime_type);
+        }
+    }
+
+    /* Add a special entry so that we can detect when an offer is coming from us. */
+    wl_data_source_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
+
+    wl_data_source_add_listener(source, &data_source_listener, &wayland->data_device);
+    wl_data_device_set_selection(wayland->data_device.wl_data_device, source,
+                                 enter_serial);
+
+    NtUserCloseClipboard();
+}
+
 /**********************************************************************
  *          waylanddrv_unix_clipboard_message
  */
@@ -273,6 +429,11 @@ NTSTATUS waylanddrv_unix_clipboard_message(void *arg)
     {
     case WM_NCCREATE:
         return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        TRACE("WM_CLIPBOARDUPDATE\n");
+        /* Ignore our own updates */
+        if (NtUserGetClipboardOwner() != params->hwnd) clipboard_update();
+        break;
     }
 
     return NtUserMessageCall(params->hwnd, params->msg, params->wparam,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1a4ff88d826..99c708a858c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -242,6 +242,7 @@ struct wayland_data_device
     struct wl_data_device *wl_data_device;
     struct wl_data_offer *clipboard_wl_data_offer;
     struct wl_data_offer *dnd_wl_data_offer;
+    struct wl_data_source *wl_data_source;
 };
 
 struct wayland_data_device_format
-- 
2.39.0.rc2

From a569775cd33668f27746dcdaa88d491c27dd0dea Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:33:25 +0300
Subject: [PATCH 187/202] winewayland.drv: Handle WM_RENDERFORMAT message.

Import into Windows clipboard data we got from other Wayland clients,
for a particular Windows clipboard format. This allow us to fetch
clipboard data and populate the Windows clipboard contents on demand.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 139 +++++++++++++++++++++
 1 file changed, 139 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 495d9075ac9..23ce76ea72c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -29,6 +29,9 @@
 #include "wine/debug.h"
 
 #include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -145,6 +148,111 @@ static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
     free(data_offer);
 }
 
+static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
+                                             const char *mime_type,
+                                             size_t *size_out)
+{
+    int data_pipe[2] = {-1, -1};
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    buffer = malloc(buffer_size);
+    if (buffer == NULL)
+    {
+        ERR("failed to allocate read buffer for data offer\n");
+        goto out;
+    }
+
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+        goto out;
+
+    TRACE("mime_type=%s\n", mime_type);
+
+    wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(data_offer->wayland->wl_display);
+
+    do
+    {
+        struct pollfd pfd = { .fd = data_pipe[0], .events = POLLIN };
+        int ret;
+
+        /* Wait a limited amount of time for the data to arrive, since otherwise
+         * a misbehaving data source could block us indefinitely. */
+        while ((ret = poll(&pfd, 1, 3000)) == -1 && errno == EINTR) continue;
+        if (ret <= 0 || !(pfd.revents & (POLLIN | POLLHUP)))
+        {
+            TRACE("failed polling data offer pipe ret=%d errno=%d revents=0x%x\n",
+                  ret, ret == -1 ? errno : 0, pfd.revents);
+            total = 0;
+            goto out;
+        }
+
+        nread = read(data_pipe[0], buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            ERR("failed to read data offer pipe\n");
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                unsigned char *new_buffer;
+                buffer_size += 4096;
+                new_buffer = realloc(buffer, buffer_size);
+                if (!new_buffer)
+                {
+                    ERR("failed to reallocate read buffer for data offer\n");
+                    total = 0;
+                    goto out;
+                }
+                buffer = new_buffer;
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("received %d bytes\n", total);
+
+out:
+    if (data_pipe[0] >= 0)
+        close(data_pipe[0]);
+
+    if (total == 0 && buffer != NULL)
+    {
+        free(buffer);
+        buffer = NULL;
+    }
+
+    *size_out = total;
+
+    return buffer;
+}
+
+static void *wayland_data_offer_import_format(struct wayland_data_offer *data_offer,
+                                              struct wayland_data_device_format *format,
+                                              size_t *ret_size)
+{
+    size_t data_size;
+    void *data, *ret;
+
+    data = wayland_data_offer_receive_data(data_offer, format->mime_type, &data_size);
+    if (!data)
+        return NULL;
+
+    ret = format->import(format, data, data_size, ret_size);
+
+    free(data);
+
+    return ret;
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
@@ -418,6 +526,33 @@ static void clipboard_update(void)
     NtUserCloseClipboard();
 }
 
+static void clipboard_render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device;
+    struct wayland_data_offer *data_offer;
+    struct wayland_data_device_format *format;
+
+    data_device = wl_data_device_get_user_data(thread_wayland()->data_device.wl_data_device);
+    if (!data_device->clipboard_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    if (!data_offer)
+        return;
+
+    format = wayland_data_device_format_for_clipboard_format(clipboard_format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        struct set_clipboard_params params = { 0 };
+        if ((params.data = wayland_data_offer_import_format(data_offer, format, &params.size)))
+        {
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+            free(params.data);
+        }
+    }
+}
+
 /**********************************************************************
  *          waylanddrv_unix_clipboard_message
  */
@@ -434,6 +569,10 @@ NTSTATUS waylanddrv_unix_clipboard_message(void *arg)
         /* Ignore our own updates */
         if (NtUserGetClipboardOwner() != params->hwnd) clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        TRACE("WM_RENDERFORMAT: %ld\n", (long)params->wparam);
+        clipboard_render_format(params->wparam);
+        break;
     }
 
     return NtUserMessageCall(params->hwnd, params->msg, params->wparam,
-- 
2.39.0.rc2

From 31d34936b0119ced73864235e2810f4d56323036 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:35:36 +0300
Subject: [PATCH 188/202] winewayland.drv: Handle WM_DESTROYCLIPBOARD message.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 23ce76ea72c..06abdcfe0cf 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -553,6 +553,14 @@ static void clipboard_render_format(UINT clipboard_format)
     }
 }
 
+static void clipboard_destroy(void)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_device *data_device =
+        wl_data_device_get_user_data(wayland->data_device.wl_data_device);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+}
+
 /**********************************************************************
  *          waylanddrv_unix_clipboard_message
  */
@@ -573,6 +581,10 @@ NTSTATUS waylanddrv_unix_clipboard_message(void *arg)
         TRACE("WM_RENDERFORMAT: %ld\n", (long)params->wparam);
         clipboard_render_format(params->wparam);
         break;
+    case WM_DESTROYCLIPBOARD:
+        TRACE("WM_DESTROYCLIPBOARD: clipboard_hwnd=%p\n", params->hwnd);
+        clipboard_destroy();
+        break;
     }
 
     return NtUserMessageCall(params->hwnd, params->msg, params->wparam,
-- 
2.39.0.rc2

From dc8e0fd719b24ae969db42c0592992516f1be61c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:27:47 +0300
Subject: [PATCH 189/202] winewayland.drv: Handle Wayland data device selection
 event.

Handle the Wayland event which informs us of the new current clipboard
selection. We use the provided event information to update the available
formats in the Windows clipboard, without populating them with any
actual data. We populate the clipboard data on demand through the
handling of the WM_RENDERFORMAT message.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 67 ++++++++++++++++++++++
 1 file changed, 67 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 06abdcfe0cf..80f39600763 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -325,11 +325,78 @@ static void data_device_selection(void *data,
                                   struct wl_data_offer *wl_data_offer)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    TRACE("wl_data_offer=%u\n",
+          wl_data_offer ? wl_proxy_get_id((struct wl_proxy*)wl_data_offer) : 0);
+
+    /* We may get a selection event before we have had a chance to create the
+     * clipboard window after thread init (see wayland_init_thread_data), so
+     * we need to ensure we have a valid window here. */
+    wayland_data_device_ensure_clipboard_window(wayland);
 
     /* Destroy any previous data offer. */
     wayland_data_device_destroy_clipboard_data_offer(data_device);
 
+    /* If we didn't get an offer and we are the clipboard owner, empty the
+     * clipboard. Otherwise ignore the empty offer completely. */
+    if (!wl_data_offer)
+    {
+        if (NtUserGetClipboardOwner() == wayland->clipboard_hwnd)
+        {
+            NtUserOpenClipboard(NULL, 0);
+            NtUserEmptyClipboard();
+            NtUserCloseClipboard();
+        }
+        return;
+    }
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * from us to notify external wayland clients about a wine clipboard update.
+     * The clipboard already contains all the required data, plus we need to ignore
+     * this in order to avoid an endless notification loop. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("ignoring offer produced by winewayland\n");
+            goto ignore_selection;
+        }
+    }
+
+    if (!NtUserOpenClipboard(data_offer->wayland->clipboard_hwnd, 0))
+    {
+        WARN("failed to open clipboard for selection\n");
+        goto ignore_selection;
+    }
+
+    NtUserEmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            struct set_clipboard_params params = { .data = NULL };
+            TRACE("Avalaible clipboard format for %s => %u\n", *p, format->clipboard_format);
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+        }
+    }
+
+    NtUserCloseClipboard();
+
     data_device->clipboard_wl_data_offer = wl_data_offer;
+
+    return;
+
+ignore_selection:
+    wayland_data_offer_destroy(data_offer);
 }
 
 static const struct wl_data_device_listener data_device_listener = {
-- 
2.39.0.rc2

From 1a5cb271b7c7004766821be7d9207ba9f1f7ec28 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:27:13 +0300
Subject: [PATCH 190/202] winewayland.drv: Add skeleton IDataObject for data
 offers.

This IDataObject will be used to integrate with drag-and-drop
from other Wayland clients.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |   2 +-
 dlls/winewayland.drv/wayland_data_device.c    |  27 +++-
 .../winewayland.drv/wayland_data_device_dll.c | 133 ++++++++++++++++++
 3 files changed, 156 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index b73422ffa1b..be2f6e71f62 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,6 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-IMPORTS = user32
+IMPORTS = user32 uuid
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
               $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 80f39600763..f5e486b1de7 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -28,6 +28,8 @@
 
 #include "wine/debug.h"
 
+#include "objidl.h"
+
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -41,6 +43,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
 struct wayland_data_offer
 {
+    IDataObject data_object;
     struct wayland *wayland;
     struct wl_data_offer *wl_data_offer;
     struct wl_array types;
@@ -117,13 +120,26 @@ static const struct wl_data_offer_listener data_offer_listener = {
     data_offer_action
 };
 
+static ULONG_PTR zero_bits(void)
+{
+#ifdef _WIN64
+    return !NtCurrentTeb()->WowTebOffset ? 0 : 0x7fffffff;
+#else
+    return 0;
+#endif
+}
+
 static void wayland_data_offer_create(struct wayland *wayland,
                                       struct wl_data_offer *wl_data_offer)
 {
-    struct wayland_data_offer *data_offer;
-
-    data_offer = calloc(1, sizeof(*data_offer));
-    if (!data_offer)
+    struct wayland_data_offer *data_offer = NULL;
+    SIZE_T size = sizeof(*data_offer);
+
+    /* Ensure that the PE side can access the 'data_object' member, by
+     * allocating wayland_data_offer in Windows virtual memory. */
+    if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&data_offer,
+                                zero_bits(), &size, MEM_COMMIT, PAGE_READWRITE) ||
+        !data_offer)
     {
         ERR("Failed to allocate memory for data offer\n");
         return;
@@ -139,13 +155,14 @@ static void wayland_data_offer_create(struct wayland *wayland,
 static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
 {
     char **p;
+    SIZE_T size = 0;
 
     wl_data_offer_destroy(data_offer->wl_data_offer);
     wl_array_for_each(p, &data_offer->types)
         free(*p);
     wl_array_release(&data_offer->types);
 
-    free(data_offer);
+    NtFreeVirtualMemory(GetCurrentProcess(), (void **)&data_offer, &size, MEM_RELEASE);
 }
 
 static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index 01ee6bc2a0f..e934a5a5d3a 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -20,10 +20,15 @@
 
 #include "waylanddrv_dll.h"
 
+#define COBJMACROS
+#include "objidl.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+static IDataObjectVtbl dataOfferDataObjectVtbl;
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     struct waylanddrv_unix_clipboard_message_params params;
@@ -76,3 +81,131 @@ NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size)
     TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
     return HandleToUlong(clipboard_hwnd);
 }
+
+/*********************************************************
+ * Implementation of IDataObject for wayland data offers *
+ *********************************************************/
+
+static HRESULT WINAPI dataOfferDataObject_QueryInterface(IDataObject *data_object,
+                                                         REFIID riid, void **object)
+{
+    TRACE("(%p, %s, %p)\n", data_object, debugstr_guid(riid), object);
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDataObject))
+    {
+        *object = data_object;
+        IDataObject_AddRef(data_object);
+        return S_OK;
+    }
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI dataOfferDataObject_AddRef(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when the data_offer is destroyed, so we don't care about proper
+     * reference tracking. */
+    return 2;
+}
+
+static ULONG WINAPI dataOfferDataObject_Release(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when, so we don't care about proper reference tracking. */
+    return 1;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium)
+{
+    TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
+
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
+                                                      FORMATETC *format_etc,
+                                                      STGMEDIUM *medium)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, medium);
+    return DATA_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
+                                                       FORMATETC *format_etc)
+{
+    TRACE("(%p, %p={.tymed=0x%lx, .dwAspect=%ld, .cfFormat=%d}\n",
+          data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
+          format_etc->cfFormat);
+
+    return DV_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetCanonicalFormatEtc(IDataObject *data_object,
+                                                                FORMATETC *format_etc,
+                                                                FORMATETC *format_etc_out)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, format_etc_out);
+    format_etc_out->ptd = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium, BOOL release)
+{
+    FIXME("(%p, %p, %p, %s): stub\n", data_object, format_etc,
+          medium, release ? "TRUE" : "FALSE");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
+                                                        DWORD direction,
+                                                        IEnumFORMATETC **enum_format_etc)
+{
+    TRACE("(%p, %lu, %p)\n", data_object, direction, enum_format_etc);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
+                                                  FORMATETC *format_etc, DWORD advf,
+                                                  IAdviseSink *advise_sink,
+                                                  DWORD *connection)
+{
+    FIXME("(%p, %p, %lu, %p, %p): stub\n", data_object, format_etc, advf,
+          advise_sink, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DUnadvise(IDataObject *data_object,
+                                                    DWORD connection)
+{
+    FIXME("(%p, %lu): stub\n", data_object, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumDAdvise(IDataObject *data_object,
+                                                      IEnumSTATDATA **enum_advise)
+{
+    FIXME("(%p, %p): stub\n", data_object, enum_advise);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static IDataObjectVtbl dataOfferDataObjectVtbl =
+{
+    dataOfferDataObject_QueryInterface,
+    dataOfferDataObject_AddRef,
+    dataOfferDataObject_Release,
+    dataOfferDataObject_GetData,
+    dataOfferDataObject_GetDataHere,
+    dataOfferDataObject_QueryGetData,
+    dataOfferDataObject_GetCanonicalFormatEtc,
+    dataOfferDataObject_SetData,
+    dataOfferDataObject_EnumFormatEtc,
+    dataOfferDataObject_DAdvise,
+    dataOfferDataObject_DUnadvise,
+    dataOfferDataObject_EnumDAdvise
+};
-- 
2.39.0.rc2

From fbf33a44c892956886ddc91cfd28c7446fe4cee6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:30:21 +0300
Subject: [PATCH 191/202] winewayland.drv: Implement IDataObject::QueryGetData
 for data offers.

Check if for any of the available mime types of the associated data
offer we support converting from that mime type to the requested Windows
clipboard format.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/unixlib.h                | 11 ++++++++
 dlls/winewayland.drv/wayland_data_device.c    | 26 +++++++++++++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 15 +++++++++++
 dlls/winewayland.drv/waylanddrv.h             |  1 +
 dlls/winewayland.drv/waylanddrv_main.c        |  1 +
 5 files changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 7c9f55d2356..b724cac412e 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -23,11 +23,16 @@
 #include "ntuser.h"
 #include "wine/unixlib.h"
 
+/* A pointer to memory that is guaranteed to be usable by both 32-bit and
+ * 64-bit processes. */
+typedef UINT PTR32;
+
 enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
     waylanddrv_unix_func_read_events,
     waylanddrv_unix_func_clipboard_message,
+    waylanddrv_unix_func_data_offer_accept_format,
     waylanddrv_unix_func_count,
 };
 
@@ -39,6 +44,12 @@ struct waylanddrv_unix_clipboard_message_params
     LPARAM lparam;
 };
 
+struct waylanddrv_unix_data_offer_accept_format_params
+{
+    PTR32 data_offer;
+    UINT format;
+};
+
 /* driver client callbacks exposed with KernelCallbackTable interface */
 enum waylanddrv_client_func
 {
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index f5e486b1de7..8e90392d9a8 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -24,6 +24,10 @@
 
 #include "config.h"
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
@@ -49,6 +53,7 @@ struct wayland_data_offer
     struct wl_array types;
     uint32_t source_actions;
     uint32_t action;
+    const char *accepted_mime_type;
 };
 
 /* Normalize the mime type by skipping inconsequential characters, such as
@@ -689,3 +694,24 @@ void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
             ULongToHandle(WAYLANDDRV_CLIENT_CALL(create_clipboard_window, NULL, 0));
     }
 }
+
+NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg)
+{
+    struct waylanddrv_unix_data_offer_accept_format_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    struct wayland_data_device_format *format;
+
+    TRACE("data_offer=%p clipboard_format=%d\n", data_offer, p->format);
+
+    format = wayland_data_device_format_for_clipboard_format(p->format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        TRACE("found offer %s for clipboard format %u\n",
+              format->mime_type, format->clipboard_format);
+        data_offer->accepted_mime_type = format->mime_type;
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index e934a5a5d3a..8940c16196a 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -137,10 +137,25 @@ static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
 static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
                                                        FORMATETC *format_etc)
 {
+    struct waylanddrv_unix_data_offer_accept_format_params params;
+
     TRACE("(%p, %p={.tymed=0x%lx, .dwAspect=%ld, .cfFormat=%d}\n",
           data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
           format_etc->cfFormat);
 
+    if (format_etc->tymed && !(format_etc->tymed & TYMED_HGLOBAL))
+    {
+        FIXME("only HGLOBAL medium types supported right now\n");
+        return DV_E_TYMED;
+    }
+
+    params.data_offer = PtrToUint(data_object);
+    params.format = format_etc->cfFormat;
+
+    if (WAYLANDDRV_UNIX_CALL(data_offer_accept_format, &params) == 0)
+        return S_OK;
+
+    TRACE("didn't find offer for clipboard format %u\n", format_etc->cfFormat);
     return DV_E_FORMATETC;
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 99c708a858c..fd2cad65e1c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -812,6 +812,7 @@ static inline HWND get_focus(void)
 NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
                                 ULONG size) DECLSPEC_HIDDEN;
 NTSTATUS waylanddrv_unix_clipboard_message(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER driver functions
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index e1824120e53..aebb2e5874c 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -225,6 +225,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
     waylanddrv_unix_clipboard_message,
+    waylanddrv_unix_data_offer_accept_format,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
-- 
2.39.0.rc2

From 46eec92893606164140f766e2c6951c7b3bde818 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Jul 2022 12:08:04 +0300
Subject: [PATCH 192/202] winewayland.drv: Implement IDataObject::GetData for
 data offers.

If the associated data offer has a mime type matching the requested
Windows clipboard format, import the data into a HGLOBAL memory object.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/unixlib.h                |  9 +++++
 dlls/winewayland.drv/wayland_data_device.c    | 36 +++++++++++++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 31 +++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h             |  1 +
 dlls/winewayland.drv/waylanddrv_main.c        |  1 +
 5 files changed, 77 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index b724cac412e..454bd5e442a 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -33,6 +33,7 @@ enum waylanddrv_unix_func
     waylanddrv_unix_func_read_events,
     waylanddrv_unix_func_clipboard_message,
     waylanddrv_unix_func_data_offer_accept_format,
+    waylanddrv_unix_func_data_offer_import_format,
     waylanddrv_unix_func_count,
 };
 
@@ -50,6 +51,14 @@ struct waylanddrv_unix_data_offer_accept_format_params
     UINT format;
 };
 
+struct waylanddrv_unix_data_offer_import_format_params
+{
+    PTR32 data_offer;
+    UINT format;
+    PTR32 data;
+    UINT size;
+};
+
 /* driver client callbacks exposed with KernelCallbackTable interface */
 enum waylanddrv_client_func
 {
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 8e90392d9a8..7fad54d2dab 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -715,3 +715,39 @@ NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg)
 
     return STATUS_UNSUCCESSFUL;
 }
+
+NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg)
+{
+    struct waylanddrv_unix_data_offer_import_format_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    struct wayland_data_device_format *format;
+
+    TRACE("data_offer=%p clipboard_format=%d\n", data_offer, p->format);
+
+    format = wayland_data_device_format_for_clipboard_format(p->format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        void *data, *vdata = NULL;
+        size_t size;
+        SIZE_T vsize;
+
+        if (!(data = wayland_data_offer_import_format(data_offer, format, &size)))
+            return STATUS_UNSUCCESSFUL;
+        vsize = size;
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&vdata,
+                                    zero_bits(), &vsize, MEM_COMMIT, PAGE_READWRITE) ||
+            !vdata)
+        {
+            free(data);
+            return STATUS_UNSUCCESSFUL;
+        }
+        memcpy(vdata, data, size);
+        p->data = PtrToUint(vdata);
+        p->size = size;
+        free(data);
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index 8940c16196a..071bd76420c 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -121,9 +121,38 @@ static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
                                                   FORMATETC *format_etc,
                                                   STGMEDIUM *medium)
 {
+    HRESULT hr;
+    struct waylanddrv_unix_data_offer_import_format_params params;
+    void *data;
+
     TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
 
-    return E_UNEXPECTED;
+    hr = IDataObject_QueryGetData(data_object, format_etc);
+    if (!SUCCEEDED(hr))
+        return hr;
+
+    params.data_offer = PtrToUint(data_object);
+    params.format = format_etc->cfFormat;
+    params.data = 0;
+    params.size = 0;
+
+    if (WAYLANDDRV_UNIX_CALL(data_offer_import_format, &params) != 0 || !params.data)
+        return E_UNEXPECTED;
+
+    data = UIntToPtr(params.data);
+
+    medium->hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, params.size);
+    if (medium->hGlobal == NULL)
+        return E_OUTOFMEMORY;
+    memcpy(GlobalLock(medium->hGlobal), data, params.size);
+    GlobalUnlock(medium->hGlobal);
+
+    medium->tymed = TYMED_HGLOBAL;
+    medium->pUnkForRelease = 0;
+
+    VirtualFree(data, params.size, MEM_RELEASE);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fd2cad65e1c..22d96bf8968 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -813,6 +813,7 @@ NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *pa
                                 ULONG size) DECLSPEC_HIDDEN;
 NTSTATUS waylanddrv_unix_clipboard_message(void *arg) DECLSPEC_HIDDEN;
 NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER driver functions
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index aebb2e5874c..117ad2adc66 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -226,6 +226,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     waylanddrv_unix_read_events,
     waylanddrv_unix_clipboard_message,
     waylanddrv_unix_data_offer_accept_format,
+    waylanddrv_unix_data_offer_import_format,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
-- 
2.39.0.rc2

From 2a4b8e7ef8c20387f7eb6c1d8e8ac2c9afb1a5ad Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 18:36:38 +0300
Subject: [PATCH 193/202] winewayland.drv: Implement IDataObject::EnumFormatEtc
 for data offers.

For each mime type of the associated data offer we provid a FORMATETC
entry with the matching Windows clipboard format. We ensure that there
are no duplicate FORMATETC entries.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |  1 +
 dlls/winewayland.drv/unixlib.h                |  8 +++
 dlls/winewayland.drv/wayland_data_device.c    | 24 +++++++
 .../winewayland.drv/wayland_data_device_dll.c | 66 ++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h             |  1 +
 dlls/winewayland.drv/waylanddrv_main.c        |  1 +
 6 files changed, 100 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index be2f6e71f62..bfe662ca989 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,7 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 IMPORTS = user32 uuid
+DELAYIMPORTS = shell32
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
               $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 454bd5e442a..40bda21b0e0 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -33,6 +33,7 @@ enum waylanddrv_unix_func
     waylanddrv_unix_func_read_events,
     waylanddrv_unix_func_clipboard_message,
     waylanddrv_unix_func_data_offer_accept_format,
+    waylanddrv_unix_func_data_offer_enum_formats,
     waylanddrv_unix_func_data_offer_import_format,
     waylanddrv_unix_func_count,
 };
@@ -51,6 +52,13 @@ struct waylanddrv_unix_data_offer_accept_format_params
     UINT format;
 };
 
+struct waylanddrv_unix_data_offer_enum_formats_params
+{
+    PTR32 data_offer;
+    UINT *formats;
+    UINT num_formats;
+};
+
 struct waylanddrv_unix_data_offer_import_format_params
 {
     PTR32 data_offer;
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 7fad54d2dab..7b6a5c10082 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -716,6 +716,30 @@ NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg)
     return STATUS_UNSUCCESSFUL;
 }
 
+NTSTATUS waylanddrv_unix_data_offer_enum_formats(void *arg)
+{
+    struct waylanddrv_unix_data_offer_enum_formats_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    char **mime;
+    UINT count = 0;
+
+    wl_array_for_each(mime, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*mime);
+        if (format)
+        {
+            if (p->formats && p->num_formats < count)
+                p->formats[count] = format->clipboard_format;
+            count++;
+        }
+    }
+
+    p->num_formats = count;
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg)
 {
     struct waylanddrv_unix_data_offer_import_format_params *p = arg;
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index 071bd76420c..f76605e8cbd 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -22,6 +22,7 @@
 
 #define COBJMACROS
 #include "objidl.h"
+#include "shlobj.h"
 
 #include "wine/debug.h"
 
@@ -206,12 +207,75 @@ static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
     return E_NOTIMPL;
 }
 
+static BOOL formats_etc_contains_clipboard_format(FORMATETC *formats_etc,
+                                                  size_t formats_etc_count,
+                                                  UINT clipboard_format)
+{
+    size_t i;
+
+    for (i = 0; i < formats_etc_count; i++)
+        if (formats_etc[i].cfFormat == clipboard_format) return TRUE;
+
+    return FALSE;
+}
+
 static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
                                                         DWORD direction,
                                                         IEnumFORMATETC **enum_format_etc)
 {
+    HRESULT hr;
+    FORMATETC *formats_etc;
+    size_t formats_etc_count = 0;
+    struct waylanddrv_unix_data_offer_enum_formats_params params;
+
     TRACE("(%p, %lu, %p)\n", data_object, direction, enum_format_etc);
-    return E_NOTIMPL;
+
+    if (direction != DATADIR_GET)
+    {
+        FIXME("only the get direction is implemented\n");
+        return E_NOTIMPL;
+    }
+
+    params.data_offer = PtrToUint(data_object);
+    params.formats = NULL;
+    params.num_formats = 0;
+
+    WAYLANDDRV_UNIX_CALL(data_offer_enum_formats, &params);
+    params.formats = HeapAlloc(GetProcessHeap(), 0, params.num_formats * sizeof(UINT));
+    WAYLANDDRV_UNIX_CALL(data_offer_enum_formats, &params);
+    if (!params.formats)
+        return E_OUTOFMEMORY;
+
+    /* Allocate space for all offered mime types, although we may not use them all */
+    formats_etc = HeapAlloc(GetProcessHeap(), 0, params.num_formats * sizeof(FORMATETC));
+    if (!formats_etc)
+    {
+        HeapFree(GetProcessHeap(), 0, params.formats);
+        return E_OUTOFMEMORY;
+    }
+
+    for (int i = 0; i < params.num_formats; i++)
+    {
+        if (!formats_etc_contains_clipboard_format(formats_etc, formats_etc_count,
+                                                   params.formats[i]))
+        {
+            FORMATETC *current= &formats_etc[formats_etc_count];
+
+            current->cfFormat = params.formats[i];
+            current->ptd = NULL;
+            current->dwAspect = DVASPECT_CONTENT;
+            current->lindex = -1;
+            current->tymed = TYMED_HGLOBAL;
+
+            formats_etc_count += 1;
+        }
+    }
+
+    hr = SHCreateStdEnumFmtEtc(formats_etc_count, formats_etc, enum_format_etc);
+    HeapFree(GetProcessHeap(), 0, params.formats);
+    HeapFree(GetProcessHeap(), 0, formats_etc);
+
+    return hr;
 }
 
 static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 22d96bf8968..7d9f64aed7c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -813,6 +813,7 @@ NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *pa
                                 ULONG size) DECLSPEC_HIDDEN;
 NTSTATUS waylanddrv_unix_clipboard_message(void *arg) DECLSPEC_HIDDEN;
 NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_enum_formats(void *arg) DECLSPEC_HIDDEN;
 NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg) DECLSPEC_HIDDEN;
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 117ad2adc66..265c96b553d 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -226,6 +226,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     waylanddrv_unix_read_events,
     waylanddrv_unix_clipboard_message,
     waylanddrv_unix_data_offer_accept_format,
+    waylanddrv_unix_data_offer_enum_formats,
     waylanddrv_unix_data_offer_import_format,
 };
 
-- 
2.39.0.rc2

From 3c3a341b3e57e5602743eb8d039dc39ccc28ff44 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 12:43:19 +0300
Subject: [PATCH 194/202] winewayland.drv: Introduce functions for IDropTarget
 discovery.

Implement functions to find the IDropTarget for a particular point in a
window.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |   2 +-
 .../winewayland.drv/wayland_data_device_dll.c | 100 ++++++++++++++++++
 2 files changed, 101 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index bfe662ca989..d65cc8bc022 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 IMPORTS = user32 uuid
-DELAYIMPORTS = shell32
+DELAYIMPORTS = ole32 shell32
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
               $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index f76605e8cbd..761e9bc1fe4 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -83,6 +83,106 @@ NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size)
     return HandleToUlong(clipboard_hwnd);
 }
 
+/**********************************************************************
+ *          IDropTarget discovery
+ *
+ * Based on functions in dlls/ole32/ole2.c
+ */
+
+static HANDLE get_drop_target_local_handle(HWND hwnd)
+{
+    static const WCHAR prop_marshalleddrop_target[] =
+        {'W','i','n','e','M','a','r','s','h','a','l','l','e','d',
+         'D','r','o','p','T','a','r','g','e','t',0};
+    HANDLE handle;
+    HANDLE local_handle = 0;
+
+    handle = GetPropW(hwnd, prop_marshalleddrop_target);
+    if (handle)
+    {
+        DWORD pid;
+        HANDLE process;
+
+        GetWindowThreadProcessId(hwnd, &pid);
+        process = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid);
+        if (process)
+        {
+            DuplicateHandle(process, handle, GetCurrentProcess(), &local_handle,
+                            0, FALSE, DUPLICATE_SAME_ACCESS);
+            CloseHandle(process);
+        }
+    }
+    return local_handle;
+}
+
+static HRESULT create_stream_from_map(HANDLE map, IStream **stream)
+{
+    HRESULT hr = E_OUTOFMEMORY;
+    HGLOBAL hmem;
+    void *data;
+    MEMORY_BASIC_INFORMATION info;
+
+    data = MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
+    if(!data) return hr;
+
+    VirtualQuery(data, &info, sizeof(info));
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, info.RegionSize);
+    if(hmem)
+    {
+        memcpy(GlobalLock(hmem), data, info.RegionSize);
+        GlobalUnlock(hmem);
+        hr = CreateStreamOnHGlobal(hmem, TRUE, stream);
+    }
+    UnmapViewOfFile(data);
+    return hr;
+}
+
+static IDropTarget* get_drop_target_pointer(HWND hwnd)
+{
+    IDropTarget *drop_target = NULL;
+    HANDLE map;
+    IStream *stream;
+
+    map = get_drop_target_local_handle(hwnd);
+    if(!map) return NULL;
+
+    if(SUCCEEDED(create_stream_from_map(map, &stream)))
+    {
+        CoUnmarshalInterface(stream, &IID_IDropTarget, (void**)&drop_target);
+        IStream_Release(stream);
+    }
+    CloseHandle(map);
+    return drop_target;
+}
+
+static IDropTarget *drop_target_from_window_point(HWND hwnd, POINT point)
+{
+    HWND child;
+    IDropTarget *drop_target;
+    HWND orig_hwnd = hwnd;
+    POINT orig_point = point;
+
+    /* Find the deepest child window. */
+    ScreenToClient(hwnd, &point);
+    while ((child = ChildWindowFromPointEx(hwnd, point, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE)) &&
+            child != hwnd)
+    {
+        MapWindowPoints(hwnd, child, &point, 1);
+        hwnd = child;
+    }
+
+    /* Ascend the children hierarchy until we find one that accepts drops. */
+    do
+    {
+        drop_target = get_drop_target_pointer(hwnd);
+    } while (drop_target == NULL && (hwnd = GetParent(hwnd)) != NULL);
+
+    TRACE("hwnd=%p point=(%ld,%ld) => dnd_hwnd=%p drop_target=%p\n",
+          orig_hwnd, orig_point.x, orig_point.y, hwnd, drop_target);
+    return drop_target;
+}
+
 /*********************************************************
  * Implementation of IDataObject for wayland data offers *
  *********************************************************/
-- 
2.39.0.rc2

From ca3b449624fa8a1d7b02195fc7add0b80131d2c2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 12:52:27 +0300
Subject: [PATCH 195/202] winewayland.drv: Handle the wl_data_device::enter
 event.

Relay the event to the IDropTarget at the enter position, and notify the
Wayland compositor of any accepted format/mime type and actions.

The accepted mime type is set indirectly through IDropTarget_DragEnter
eventually calling our IDataObject_(Query)GetData implementation for the
associated data offer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/dllmain.c                |  1 +
 dlls/winewayland.drv/unixlib.h                | 18 ++++++
 dlls/winewayland.drv/wayland_data_device.c    | 60 +++++++++++++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 42 +++++++++++++
 dlls/winewayland.drv/wayland_surface.c        |  4 ++
 dlls/winewayland.drv/waylanddrv.h             |  4 ++
 dlls/winewayland.drv/waylanddrv_dll.h         |  1 +
 7 files changed, 130 insertions(+)

diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index ca2a2087381..e557c3a3b98 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -24,6 +24,7 @@ typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
 static const kernel_callback kernel_callbacks[] =
 {
     waylanddrv_client_create_clipboard_window,
+    waylanddrv_client_dnd,
 };
 
 C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == waylanddrv_client_func_last);
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 40bda21b0e0..315c2565506 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -26,6 +26,9 @@
 /* A pointer to memory that is guaranteed to be usable by both 32-bit and
  * 64-bit processes. */
 typedef UINT PTR32;
+/* A handle value that is guaranteed to be usable by both 32-bit and 64-bit
+ * processes. */
+typedef UINT HANDLE32;
 
 enum waylanddrv_unix_func
 {
@@ -71,9 +74,24 @@ struct waylanddrv_unix_data_offer_import_format_params
 enum waylanddrv_client_func
 {
     waylanddrv_client_func_create_clipboard_window = NtUserDriverCallbackFirst,
+    waylanddrv_client_func_dnd,
     waylanddrv_client_func_last
 };
 
 C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
 
+enum waylanddrv_client_dnd_event
+{
+    CLIENT_DND_EVENT_ENTER,
+};
+
+struct waylanddrv_client_dnd_params
+{
+    UINT event;
+    HANDLE32 hwnd;
+    POINT point;
+    DWORD drop_effect;
+    PTR32 data_object;
+};
+
 #endif /* __WINE_WAYLANDDRV_UNIXLIB_H */
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 7b6a5c10082..9350a82652f 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -88,6 +88,20 @@ static char *normalize_mime_type(const char *mime)
     return new_mime;
 }
 
+static DWORD dnd_actions_to_drop_effect(uint32_t actions)
+{
+    DWORD drop_effect = 0;
+
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+        drop_effect |= DROPEFFECT_COPY;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+        drop_effect |= DROPEFFECT_MOVE;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+        drop_effect |= DROPEFFECT_COPY | DROPEFFECT_MOVE;
+
+    return drop_effect;
+}
+
 /**********************************************************************
  *          wl_data_offer handling
  */
@@ -315,12 +329,58 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
                               wl_fixed_t x_w, wl_fixed_t y_w,
                               struct wl_data_offer *wl_data_offer)
 {
+    struct waylanddrv_client_dnd_params params;
     struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    struct wayland_surface *wayland_surface;
+    POINT point;
 
     /* Any previous dnd offer should have been freed by a drop or leave event. */
     assert(data_device->dnd_wl_data_offer == NULL);
 
     data_device->dnd_wl_data_offer = wl_data_offer;
+
+    if (!wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    wayland_surface = wl_surface_get_user_data(wl_surface);
+
+    if (!wayland_surface || !wayland_surface->hwnd)
+        return;
+
+    data_device->dnd_enter_serial = serial;
+    data_device->dnd_surface = wayland_surface;
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    /* Clear accepted_mime_type here. It should be eventually set by
+     * the DnD client call below. */
+    data_offer->accepted_mime_type = NULL;
+
+    params.event = CLIENT_DND_EVENT_ENTER;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) != 0)
+        return;
+
+    wl_data_offer_set_actions(wl_data_offer, data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
 }
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index 761e9bc1fe4..6be8033a5e1 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -18,6 +18,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
 #include "waylanddrv_dll.h"
 
 #define COBJMACROS
@@ -183,6 +186,45 @@ static IDropTarget *drop_target_from_window_point(HWND hwnd, POINT point)
     return drop_target;
 }
 
+static NTSTATUS WINAPI waylanddrv_client_dnd_enter(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    IDataObject *data_object = UIntToPtr(p->data_object);
+    HRESULT hr;
+
+    /* If unixlib is 64 bits and PE is 32 bits, this will write a 32 bit
+     * pointer value to the bottom of 64 bit pointer variable, which works out
+     * fine due to little-endianness and the fact that lpVtbl has been zero
+     * initialized. */
+    data_object->lpVtbl = &dataOfferDataObjectVtbl;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragEnter(drop_target, data_object, MK_LBUTTON,
+                               *(POINTL*)&p->point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+
+    switch (p->event) {
+    case CLIENT_DND_EVENT_ENTER:
+        return waylanddrv_client_dnd_enter(params, size);
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
 /*********************************************************
  * Implementation of IDataObject for wayland data offers *
  *********************************************************/
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9768839a984..2a4aaea7a76 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -669,6 +669,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_data_device *data_device = &surface->wayland->data_device;
     struct wayland_surface *child, *child_tmp;
     struct wayland_output_ref *ref, *ref_tmp;
 
@@ -680,6 +681,9 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (keyboard->focused_surface == surface)
         keyboard->focused_surface = NULL;
 
+    if (data_device->dnd_surface == surface)
+        data_device->dnd_surface = NULL;
+
     /* There are children left only when we force a destruction during
      * thread deinitialization, otherwise the children hold a reference
      * to the parent and won't let it be destroyed. */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7d9f64aed7c..830ed172003 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -243,6 +243,10 @@ struct wayland_data_device
     struct wl_data_offer *clipboard_wl_data_offer;
     struct wl_data_offer *dnd_wl_data_offer;
     struct wl_data_source *wl_data_source;
+    uint32_t dnd_enter_serial;
+    struct wayland_surface *dnd_surface;
+    int dnd_x;
+    int dnd_y;
 };
 
 struct wayland_data_device_format
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
index 68d04d34be7..a33e212e24b 100644
--- a/dlls/winewayland.drv/waylanddrv_dll.h
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -30,5 +30,6 @@
 #define WAYLANDDRV_UNIX_CALL(func, params) WINE_UNIX_CALL(waylanddrv_unix_func_ ## func, params)
 
 NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size);
+NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size);
 
 #endif /* __WINE_WAYLANDDRV_DLL_H */
-- 
2.39.0.rc2

From ddbc94fe95baefb552f6a72c2719c23026d056a5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:02:14 +0300
Subject: [PATCH 196/202] winewayland.drv: Handle the wl_data_device::leave
 event.

Relay the event to the IDropTarget at the current drag-and-drop
position.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/unixlib.h                |  1 +
 dlls/winewayland.drv/wayland_data_device.c    | 22 +++++++++++++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 20 +++++++++++++++++
 3 files changed, 43 insertions(+)

diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 315c2565506..c911bd030aa 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -83,6 +83,7 @@ C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
 enum waylanddrv_client_dnd_event
 {
     CLIENT_DND_EVENT_ENTER,
+    CLIENT_DND_EVENT_LEAVE,
 };
 
 struct waylanddrv_client_dnd_params
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 9350a82652f..38b53c2a38e 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -385,8 +385,30 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 {
+    struct waylanddrv_client_dnd_params params;
     struct wayland_data_device *data_device = data;
+    POINT point;
+
+    TRACE("surface=%p hwnd=%p\n",
+          data_device->dnd_surface,
+          data_device->dnd_surface ? data_device->dnd_surface->hwnd : 0);
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
 
+    params.event = CLIENT_DND_EVENT_LEAVE;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = 0;
+    params.data_object = 0;
+
+    WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params));
+
+out:
     wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index 6be8033a5e1..2f6412a32a1 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -213,6 +213,24 @@ static NTSTATUS WINAPI waylanddrv_client_dnd_enter(void *params, ULONG size)
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS WINAPI waylanddrv_client_dnd_leave(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragLeave(drop_target);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
 {
     struct waylanddrv_client_dnd_params *p = params;
@@ -220,6 +238,8 @@ NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
     switch (p->event) {
     case CLIENT_DND_EVENT_ENTER:
         return waylanddrv_client_dnd_enter(params, size);
+    case CLIENT_DND_EVENT_LEAVE:
+        return waylanddrv_client_dnd_leave(params, size);
     }
 
     return STATUS_UNSUCCESSFUL;
-- 
2.39.0.rc2

From 45ab903cf7b2c0085b2ba2fa79bad7487f98e412 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:03:47 +0300
Subject: [PATCH 197/202] winewayland.drv: Handle the wl_data_device::motion
 event.

Relay the event to the IDropTarget at the new drag-and-drop position,
and notify the Wayland compositor of any accepted format/mime type and
actions.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/unixlib.h                |  1 +
 dlls/winewayland.drv/wayland_data_device.c    | 36 +++++++++++++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 22 ++++++++++++
 3 files changed, 59 insertions(+)

diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index c911bd030aa..500c1acb043 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -84,6 +84,7 @@ enum waylanddrv_client_dnd_event
 {
     CLIENT_DND_EVENT_ENTER,
     CLIENT_DND_EVENT_LEAVE,
+    CLIENT_DND_EVENT_MOTION,
 };
 
 struct waylanddrv_client_dnd_params
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 38b53c2a38e..99da01bb13f 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -415,6 +415,42 @@ out:
 static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
                                uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
 {
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    POINT point;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    params.event = CLIENT_DND_EVENT_MOTION;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) != 0)
+        return;
+
+    wl_data_offer_set_actions(data_device->dnd_wl_data_offer,
+                              data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(data_device->dnd_wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
 }
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index 2f6412a32a1..df05fdea9db 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -231,6 +231,26 @@ static NTSTATUS WINAPI waylanddrv_client_dnd_leave(void *params, ULONG size)
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS WINAPI waylanddrv_client_dnd_motion(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragOver(drop_target, MK_LBUTTON, *(POINTL*)&p->point,
+                              &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
 {
     struct waylanddrv_client_dnd_params *p = params;
@@ -240,6 +260,8 @@ NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
         return waylanddrv_client_dnd_enter(params, size);
     case CLIENT_DND_EVENT_LEAVE:
         return waylanddrv_client_dnd_leave(params, size);
+    case CLIENT_DND_EVENT_MOTION:
+        return waylanddrv_client_dnd_motion(params, size);
     }
 
     return STATUS_UNSUCCESSFUL;
-- 
2.39.0.rc2

From 25be6e2e37623ca0f34e877f8ca502583cbffb1d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:05:09 +0300
Subject: [PATCH 198/202] winewayland.drv: Handle the wl_data_device::drop
 event.

Relay the event to the IDropTarget at the current drag-and-drop position,
which will then initiate a data transfer by using the IDataObject_GetData
implementation for the associated Wayland data offer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/unixlib.h                |  1 +
 dlls/winewayland.drv/wayland_data_device.c    | 26 +++++++++++++++++++
 .../winewayland.drv/wayland_data_device_dll.c | 23 ++++++++++++++++
 3 files changed, 50 insertions(+)

diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 500c1acb043..24b79ca6e70 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -85,6 +85,7 @@ enum waylanddrv_client_dnd_event
     CLIENT_DND_EVENT_ENTER,
     CLIENT_DND_EVENT_LEAVE,
     CLIENT_DND_EVENT_MOTION,
+    CLIENT_DND_EVENT_DROP,
 };
 
 struct waylanddrv_client_dnd_params
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 99da01bb13f..50fc426e126 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -455,8 +455,34 @@ static void data_device_motion(void *data, struct wl_data_device *wl_data_device
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
 {
+    struct waylanddrv_client_dnd_params params;
     struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    POINT point;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     (int *)&point.x, (int *)&point.y);
 
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    params.event = CLIENT_DND_EVENT_DROP;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) == 0)
+        wl_data_offer_finish(data_device->dnd_wl_data_offer);
+
+out:
     wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
index df05fdea9db..7f5019fe4b7 100644
--- a/dlls/winewayland.drv/wayland_data_device_dll.c
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -251,6 +251,27 @@ static NTSTATUS WINAPI waylanddrv_client_dnd_motion(void *params, ULONG size)
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS WINAPI waylanddrv_client_dnd_drop(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    IDataObject *data_object = UIntToPtr(p->data_object);
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (drop_target)
+    {
+        hr = IDropTarget_Drop(drop_target, data_object, MK_LBUTTON,
+                              *(POINTL*)&p->point, &drop_effect);
+        IDropTarget_Release(drop_target);
+        if (SUCCEEDED(hr) && drop_effect != DROPEFFECT_NONE)
+            return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
 NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
 {
     struct waylanddrv_client_dnd_params *p = params;
@@ -262,6 +283,8 @@ NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
         return waylanddrv_client_dnd_leave(params, size);
     case CLIENT_DND_EVENT_MOTION:
         return waylanddrv_client_dnd_motion(params, size);
+    case CLIENT_DND_EVENT_DROP:
+        return waylanddrv_client_dnd_drop(params, size);
     }
 
     return STATUS_UNSUCCESSFUL;
-- 
2.39.0.rc2

From b6dc6f01c62ed91339f87fc1d26c60e4f85476d0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:13:42 +0300
Subject: [PATCH 199/202] winewayland.drv: Support compositor-side scaling.

Introduce a mechanism to select whether we should use application-side
or composidor-side scaling. This is controlled by the "HiDPIScaling"
global or per-app driver option, either "Application" (the default) or
"Compositor".

With application-side scaling, which is the default, the application has
access to the full/native resolution of the outputs, and needs to manage
scaling manually (e.g., by using the Wine DPI options).

With compositor-side scaling, the application has access only to the
scaled resolution of the outputs, and the compositor automatically
scales the provided buffers.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/options.c        |  9 +++++++++
 dlls/winewayland.drv/wayland_output.c | 27 ++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h     |  7 +++++++
 3 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index c06e7e09722..a0036b99cd7 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -42,6 +42,7 @@
  */
 
 char *option_drm_device = NULL;
+enum wayland_hidpi_scaling option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
 BOOL option_use_system_cursors = TRUE;
 
 /***********************************************************************
@@ -95,6 +96,14 @@ void wayland_read_options_from_registry(void)
     if (!get_config_key(hkey, appkey, "DRMDevice", REG_SZ, buffer, sizeof(buffer)))
         option_drm_device = strdup(buffer);
 
+    if (!get_config_key(hkey, appkey, "HiDPIScaling", REG_SZ, buffer, sizeof(buffer)))
+    {
+        if (!strcasecmp(buffer, "Application"))
+            option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+        else if (!strcasecmp(buffer, "Compositor"))
+            option_hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
+    }
+
     if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
         option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 10a344ca868..ecb9c6cfa13 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -273,6 +273,11 @@ static void wayland_output_list_update_physical_coords(struct wl_list *output_li
         cur->y = cur->logical_y;
     }
 
+    /* When compositor scaling is used, we treat logical coordinates as
+     * physical. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
     /* Sort and process the outputs from left to right. */
     cur_p = sorted_x = wayland_output_list_sorted(output_list, wayland_output_cmp_x);
     if (!sorted_x) return;
@@ -340,6 +345,17 @@ static void wayland_output_done(struct wayland_output *output)
 
     TRACE("output->name=%s\n", output->name);
 
+    /* When compositor scaling is used, the current and only native mode
+     * corresponds to the logical width and height. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+    {
+        int32_t current_refresh =
+            output->current_mode ? output->current_mode->refresh : default_refresh;
+        wayland_output_clear_modes(output);
+        wayland_output_add_mode_all_bpp(output, output->logical_w, output->logical_h,
+                                        current_refresh, TRUE, TRUE);
+    }
+
     wayland_output_add_default_modes(output);
     wayland_output_list_update_physical_coords(&output->wayland->output_list);
 
@@ -389,6 +405,12 @@ static void output_handle_mode(void *data, struct wl_output *wl_output,
 {
     struct wayland_output *output = data;
 
+    /* When compositor scaling is used, we don't use physical width/height
+     * for modes and the current mode will be set based on logical width
+     * and height (see wayland_output_done()). */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
     /* Windows apps don't expect a zero refresh rate, so use a default value. */
     if (refresh == 0) refresh = default_refresh;
 
@@ -412,7 +434,10 @@ static void output_handle_scale(void *data, struct wl_output *wl_output,
 {
     struct wayland_output *output = data;
     TRACE("output=%p scale=%d\n", output, scale);
-    output->scale = scale;
+    /* When compositor scaling is used, we ignore the output scale, to
+     * allow the the compositor to scale us. */
+    if (option_hidpi_scaling != WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        output->scale = scale;
 }
 
 static const struct wl_output_listener output_listener = {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 830ed172003..3d656b4edcc 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -59,6 +59,7 @@ extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
 extern const struct user_driver_funcs waylanddrv_funcs DECLSPEC_HIDDEN;
 extern char *option_drm_device DECLSPEC_HIDDEN;
+extern enum wayland_hidpi_scaling option_hidpi_scaling DECLSPEC_HIDDEN;
 extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
 /**********************************************************************
@@ -128,6 +129,12 @@ enum wayland_pointer_locked_reason
     WAYLAND_POINTER_LOCKED_REASON_CLIP = (1 << 1),
 };
 
+enum wayland_hidpi_scaling
+{
+    WAYLAND_HIDPI_SCALING_APPLICATION,
+    WAYLAND_HIDPI_SCALING_COMPOSITOR,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
-- 
2.39.0.rc2

From f90398bbec24fa01aff2eaa5cd7faf7ff64fbf4e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 13:36:40 +0300
Subject: [PATCH 200/202] winewayland.drv: Add debugging helpers for pixel
 buffer contents.

During development it's often useful to be able inspect the contents and
window or damage regions of the various buffers involved in software
rendering.

This commit adds helper functions to dump buffer contents to disk, and
uses them to dump the window buffer at flush time, the wayland SHM
buffers at commit time, and the front buffer at update/glFlush time.

These helpers are turned off by default and can be enabled by changing
the value of the corresponding preprocessor define.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/dump_pixels.c     | 174 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |  12 ++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window_surface.c  |  25 ++++
 5 files changed, 214 insertions(+)
 create mode 100644 dlls/winewayland.drv/dump_pixels.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d65cc8bc022..69584115cd5 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -10,6 +10,7 @@ UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	dump_pixels.c \
 	gbm.c \
 	gdi.c \
 	opengl.c \
diff --git a/dlls/winewayland.drv/dump_pixels.c b/dlls/winewayland.drv/dump_pixels.c
new file mode 100644
index 00000000000..5c3904b6b3d
--- /dev/null
+++ b/dlls/winewayland.drv/dump_pixels.c
@@ -0,0 +1,174 @@
+/*
+ * Debugging functions for pixel buffer contents
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntgdi.h"
+#include "winuser.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!region) return NULL;
+
+    if (!(size = NtGdiGetRegionData(region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+
+    if (!NtGdiGetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    free(data);
+    return NULL;
+}
+
+/* Dump the contents of a pixel buffer, along with the outlines of damage
+ * and window regions, to a netpbm .pam file. */
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels,
+                 int width, int height, BOOL alpha, HRGN damage, HRGN win_region)
+{
+    char fname[128] = {0};
+    RGNDATA *damage_data;
+    RGNDATA *win_region_data;
+    FILE *fp;
+    int x, y;
+
+    damage_data = get_region_data(damage);
+    win_region_data = get_region_data(win_region);
+
+    snprintf(fname, sizeof(fname), fpattern, dbgid);
+    TRACE("dumping pixels to %s\n", fname);
+
+    fp = fopen(fname, "w");
+    assert(fp && "Failed to open target file for dump pixels. Does the target directory exist?");
+
+    fprintf(fp, "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
+            width, height);
+
+    for (y = 0; y < height; ++y)
+    {
+        for (x = 0; x < width; ++x)
+        {
+            BOOL draw_damage = FALSE;
+            BOOL draw_win_region = FALSE;
+            RECT *rgn_rect;
+            RECT *end;
+
+            if (damage_data)
+            {
+                rgn_rect = (RECT *)damage_data->Buffer;
+                end = rgn_rect + damage_data->rdh.nCount;
+
+                /* Draw the outlines of damaged areas. */
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (win_region_data)
+            {
+                /* Draw the outlines of window region areas. */
+                rgn_rect = (RECT *)win_region_data->Buffer;
+                end = rgn_rect + win_region_data->rdh.nCount;
+
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (draw_damage || draw_win_region)
+            {
+                unsigned char rgba[4] = {
+                    draw_damage ? 0xff : 0x00,
+                    draw_win_region ? 0xff : 0x00,
+                    0x00, 0xff
+                };
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+            else
+            {
+                unsigned int *pixel = (unsigned int *)((char *)pixels +
+                                                       width * 4 * y + 4 * x);
+                unsigned char rgba[4] = {
+                    (*pixel & 0x00ff0000) >> 16,
+                    (*pixel & 0x0000ff00) >> 8,
+                    (*pixel & 0xff),
+                    alpha ? (*pixel & 0xff000000) >> 24 : 0xff,
+                };
+
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+        }
+    }
+
+    fflush(fp);
+    fclose(fp);
+
+    free(damage_data);
+    free(win_region_data);
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2a4aaea7a76..06251bd5319 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -33,6 +33,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump committed buffer contents to disk */
+#define DEBUG_DUMP_COMMIT_BUFFER 0
+
 static void wayland_surface_set_main_output(struct wayland_surface *surface,
                                             struct wayland_output *output);
 
@@ -629,6 +632,15 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
         return FALSE;
     }
 
+    if (DEBUG_DUMP_COMMIT_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/commit-%.4d.pam", dbgid++, shm_buffer->map_data,
+                    shm_buffer->width, shm_buffer->height,
+                    shm_buffer->format == WL_SHM_FORMAT_ARGB8888,
+                    shm_buffer->damage_region, NULL);
+    }
+
     wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
 
     /* Add surface damage, i.e., which parts of the surface have changed since
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3d656b4edcc..26b7cd1731a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -759,6 +759,8 @@ size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
                           const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
 int wayland_shmfd_create(const char *name, int size) DECLSPEC_HIDDEN;
 void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect) DECLSPEC_HIDDEN;
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels, int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          USER32 helpers
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 47a26523593..123edd20197 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -40,6 +40,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump flushed surface buffer contents to disk */
+#define DEBUG_DUMP_FLUSH_SURFACE_BUFFER 0
+
+/* Change to 1 to dump front buffer contents to disk when performing front
+ * buffer rendering. */
+#define DEBUG_DUMP_FRONT_BUFFER 0
+
 struct wayland_window_surface
 {
     struct window_surface header;
@@ -330,6 +337,15 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
     assert(wws->wayland_buffer_queue);
 
+    if (DEBUG_DUMP_FLUSH_SURFACE_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/flush-%.4d.pam", dbgid++, wws->bits,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    wws->wayland_buffer_queue->format == WL_SHM_FORMAT_ARGB8888,
+                    surface_damage_region, wws->total_region);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
     buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
     if (!buffer)
@@ -661,6 +677,15 @@ void wayland_window_surface_update_front_buffer(struct window_surface *window_su
         WARN("Failed to allocate memory for front buffer pixels\n");
     }
 
+    if (DEBUG_DUMP_FRONT_BUFFER && wws->front_bits)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/front-%.4d.pam", dbgid++,
+                    wws->front_bits, wws->info.bmiHeader.biWidth,
+                    abs(wws->info.bmiHeader.biHeight),
+                    FALSE, NULL, NULL);
+    }
+
 out:
     window_surface->funcs->unlock(window_surface);
 }
-- 
2.39.0.rc2

From 3e009b2f1a3591810fa42220b69626976ce15703 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Dec 2021 13:04:55 +0200
Subject: [PATCH 201/202] winewayland.drv: Experimental support for systray.

Use a standalone systray, adapted from winex11, to present icons for
applications.

Because the context menu on icons is drawn using global positioning
across process boundaries, we cannot currently anchor the menu window
properly to its effective parent (i.e., the icon), and we draw it as a
toplevel instead. Practically this has the effect that the menu window
will be placed at arbitrary locations on the screen by the Wayland
compositor.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in          |   5 +-
 dlls/winewayland.drv/dllmain.c            |   7 +-
 dlls/winewayland.drv/options.c            |   4 +
 dlls/winewayland.drv/systray.c            | 744 ++++++++++++++++++++++
 dlls/winewayland.drv/unixlib.h            |   5 +
 dlls/winewayland.drv/waylanddrv.h         |   1 +
 dlls/winewayland.drv/waylanddrv_dll.h     |   1 +
 dlls/winewayland.drv/waylanddrv_main.c    |   4 +
 dlls/winewayland.drv/winewayland.drv.spec |   2 +
 9 files changed, 770 insertions(+), 3 deletions(-)
 create mode 100644 dlls/winewayland.drv/systray.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 69584115cd5..7551d44f67e 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-IMPORTS = user32 uuid
-DELAYIMPORTS = ole32 shell32
+IMPORTS = gdi32 user32 uuid
+DELAYIMPORTS = comctl32 ole32 shell32
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
               $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
@@ -16,6 +16,7 @@ C_SRCS = \
 	opengl.c \
 	options.c \
 	registry.c \
+	systray.c \
 	unicode.c \
 	vulkan.c \
 	vulkan_remote.c \
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index e557c3a3b98..79463f29f14 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -20,6 +20,8 @@
 
 #include "waylanddrv_dll.h"
 
+BOOL option_show_systray;
+
 typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
 static const kernel_callback kernel_callbacks[] =
 {
@@ -40,6 +42,7 @@ static DWORD WINAPI wayland_read_events_thread(void *arg)
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
+    struct waylanddrv_unix_init_params init_params;
     DWORD tid;
     void **callback_table;
 
@@ -52,9 +55,11 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
     memcpy(callback_table + NtUserDriverCallbackFirst, kernel_callbacks,
            sizeof(kernel_callbacks));
 
-    if (WAYLANDDRV_UNIX_CALL(init, NULL))
+    if (WAYLANDDRV_UNIX_CALL(init, &init_params))
         return FALSE;
 
+    option_show_systray = init_params.option_show_systray;
+
     /* Read wayland events from a dedicated thread. */
     CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid);
 
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index a0036b99cd7..e7aa2e40b3b 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -43,6 +43,7 @@
 
 char *option_drm_device = NULL;
 enum wayland_hidpi_scaling option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+BOOL option_show_systray = TRUE;
 BOOL option_use_system_cursors = TRUE;
 
 /***********************************************************************
@@ -104,6 +105,9 @@ void wayland_read_options_from_registry(void)
             option_hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
     }
 
+    if (!get_config_key(hkey, appkey, "ShowSystray", REG_SZ, buffer, sizeof(buffer)))
+        option_show_systray = IS_OPTION_TRUE(buffer[0]);
+
     if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
         option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
 
diff --git a/dlls/winewayland.drv/systray.c b/dlls/winewayland.drv/systray.c
new file mode 100644
index 00000000000..bc4bc1d783d
--- /dev/null
+++ b/dlls/winewayland.drv/systray.c
@@ -0,0 +1,744 @@
+/*
+ * Wayland system tray management
+ *
+ * Copyright (C) 2004 Mike Hearn, for CodeWeavers
+ * Copyright (C) 2005 Robert Shearman
+ * Copyright (C) 2008 Alexandre Julliard
+ * Copyright (C) 2021 Alexandros Frantzis, for Collabora
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Adapted from winex11.drv/systray.c */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "commctrl.h"
+#include "shellapi.h"
+
+#include "waylanddrv_dll.h"
+#include "wine/list.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(systray);
+
+/* an individual systray icon */
+struct tray_icon
+{
+    struct list    entry;
+    HICON          image;    /* the image to render */
+    HWND           owner;    /* the HWND passed in to the Shell_NotifyIcon call */
+    HWND           window;   /* the adaptor window */
+    BOOL           layered;  /* whether we are using a layered window */
+    HWND           tooltip;  /* Icon tooltip */
+    UINT           state;    /* state flags */
+    UINT           id;       /* the unique id given by the app */
+    UINT           callback_message;
+    int            display;  /* display index, or -1 if hidden */
+    WCHAR          tiptext[128];    /* tooltip text */
+    WCHAR          info_text[256];  /* info balloon text */
+    WCHAR          info_title[64];  /* info balloon title */
+    UINT           info_flags;      /* flags for info balloon */
+    UINT           info_timeout;    /* timeout for info balloon */
+    HICON          info_icon;       /* info balloon icon */
+    UINT           version;         /* notify icon api version */
+};
+
+static struct list icon_list = LIST_INIT( icon_list );
+
+static const WCHAR icon_classname[] = {'_','_','w','i','n','e','w','a','y','l','a','n','d','_','t','r','a','y','_','i','c','o','n',0};
+static const WCHAR tray_classname[] = {'_','_','w','i','n','e','w','a','y','l','a','n','d','_','s','t','a','n','d','a','l','o','n','e','_','t','r','a','y',0};
+
+static BOOL show_icon( struct tray_icon *icon );
+static BOOL hide_icon( struct tray_icon *icon );
+static BOOL delete_icon( struct tray_icon *icon );
+
+#define SYSTEM_TRAY_REQUEST_DOCK  0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+
+#define MIN_DISPLAYED 8
+#define ICON_BORDER 2
+
+#define BALLOON_CREATE_TIMER 1
+#define BALLOON_SHOW_TIMER   2
+
+#define BALLOON_CREATE_TIMEOUT   2000
+#define BALLOON_SHOW_MIN_TIMEOUT 10000
+#define BALLOON_SHOW_MAX_TIMEOUT 30000
+
+static struct tray_icon *balloon_icon;
+static HWND balloon_window;
+static POINT balloon_pos;
+
+/* stand-alone tray window */
+static HWND standalone_tray;
+static int icon_cx, icon_cy;
+static unsigned int nb_displayed;
+
+/* retrieves icon record by owner window and ID */
+static struct tray_icon *get_icon(HWND owner, UINT id)
+{
+    struct tray_icon *this;
+
+    LIST_FOR_EACH_ENTRY( this, &icon_list, struct tray_icon, entry )
+        if ((this->id == id) && (this->owner == owner)) return this;
+    return NULL;
+}
+
+static void init_common_controls(void)
+{
+    static BOOL initialized = FALSE;
+
+    if (!initialized)
+    {
+        INITCOMMONCONTROLSEX init_tooltip;
+
+        init_tooltip.dwSize = sizeof(INITCOMMONCONTROLSEX);
+        init_tooltip.dwICC = ICC_TAB_CLASSES;
+
+        InitCommonControlsEx(&init_tooltip);
+        initialized = TRUE;
+    }
+}
+
+/* create tooltip window for icon */
+static void create_tooltip(struct tray_icon *icon)
+{
+    init_common_controls();
+    icon->tooltip = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                     WS_POPUP | TTS_ALWAYSTIP,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     icon->window, NULL, NULL, NULL);
+    if (icon->tooltip)
+    {
+        TTTOOLINFOW ti;
+        ZeroMemory(&ti, sizeof(ti));
+        ti.cbSize = sizeof(TTTOOLINFOW);
+        ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+        ti.hwnd = icon->window;
+        ti.uId = (UINT_PTR)icon->window;
+        ti.lpszText = icon->tiptext;
+        SendMessageW(icon->tooltip, TTM_ADDTOOLW, 0, (LPARAM)&ti);
+    }
+}
+
+void update_systray_balloon_position(void)
+{
+    RECT rect;
+    POINT pos;
+
+    if (!balloon_icon) return;
+    GetWindowRect( balloon_icon->window, &rect );
+    pos.x = (rect.left + rect.right) / 2;
+    pos.y = (rect.top + rect.bottom) / 2;
+    if (pos.x == balloon_pos.x && pos.y == balloon_pos.y) return;  /* nothing changed */
+    balloon_pos = pos;
+    SendMessageW( balloon_window, TTM_TRACKPOSITION, 0, MAKELONG( pos.x, pos.y ));
+}
+
+static void balloon_create_timer( struct tray_icon *icon )
+{
+    TTTOOLINFOW ti;
+
+    init_common_controls();
+    balloon_window = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                      WS_POPUP | TTS_ALWAYSTIP | TTS_NOPREFIX | TTS_BALLOON | TTS_CLOSE,
+                                      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+                                      icon->window, NULL, NULL, NULL);
+
+    memset( &ti, 0, sizeof(ti) );
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.uFlags = TTF_TRACK | TTF_IDISHWND;
+    ti.lpszText = icon->info_text;
+    SendMessageW( balloon_window, TTM_ADDTOOLW, 0, (LPARAM)&ti );
+    if ((icon->info_flags & NIIF_ICONMASK) == NIIF_USER)
+        SendMessageW( balloon_window, TTM_SETTITLEW, (WPARAM)icon->info_icon, (LPARAM)icon->info_title );
+    else
+        SendMessageW( balloon_window, TTM_SETTITLEW, icon->info_flags, (LPARAM)icon->info_title );
+    balloon_icon = icon;
+    balloon_pos.x = balloon_pos.y = MAXLONG;
+    update_systray_balloon_position();
+    SendMessageW( balloon_window, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti );
+    KillTimer( icon->window, BALLOON_CREATE_TIMER );
+    SetTimer( icon->window, BALLOON_SHOW_TIMER, icon->info_timeout, NULL );
+}
+
+static BOOL show_balloon( struct tray_icon *icon )
+{
+    if (standalone_tray && !option_show_systray) return FALSE;  /* no systray window */
+    if (!icon->window) return FALSE;  /* not displayed */
+    if (!icon->info_text[0]) return FALSE;  /* no balloon */
+    balloon_icon = icon;
+    SetTimer( icon->window, BALLOON_CREATE_TIMER, BALLOON_CREATE_TIMEOUT, NULL );
+    return TRUE;
+}
+
+static void hide_balloon(void)
+{
+    if (!balloon_icon) return;
+    if (balloon_window)
+    {
+        KillTimer( balloon_icon->window, BALLOON_SHOW_TIMER );
+        DestroyWindow( balloon_window );
+        balloon_window = 0;
+    }
+    else KillTimer( balloon_icon->window, BALLOON_CREATE_TIMER );
+    balloon_icon = NULL;
+}
+
+static void show_next_balloon(void)
+{
+    struct tray_icon *icon;
+
+    LIST_FOR_EACH_ENTRY( icon, &icon_list, struct tray_icon, entry )
+        if (show_balloon( icon )) break;
+}
+
+static void update_balloon( struct tray_icon *icon )
+{
+    if (balloon_icon == icon)
+    {
+        hide_balloon();
+        show_balloon( icon );
+    }
+    else if (!balloon_icon)
+    {
+        if (!show_balloon( icon )) return;
+    }
+    if (!balloon_icon) show_next_balloon();
+}
+
+static void balloon_timer(void)
+{
+    if (balloon_icon) balloon_icon->info_text[0] = 0;  /* clear text now that balloon has been shown */
+    hide_balloon();
+    show_next_balloon();
+}
+
+/* synchronize tooltip text with tooltip window */
+static void update_tooltip_text(struct tray_icon *icon)
+{
+    TTTOOLINFOW ti;
+
+    ZeroMemory(&ti, sizeof(ti));
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.lpszText = icon->tiptext;
+
+    SendMessageW(icon->tooltip, TTM_UPDATETIPTEXTW, 0, (LPARAM)&ti);
+}
+
+/* get the size of the stand-alone tray window */
+static SIZE get_window_size(void)
+{
+    SIZE size;
+    RECT rect;
+
+    rect.left = 0;
+    rect.top = 0;
+    rect.right = icon_cx * max( nb_displayed, MIN_DISPLAYED );
+    rect.bottom = icon_cy;
+    AdjustWindowRect( &rect, WS_CAPTION, FALSE );
+    size.cx = rect.right - rect.left;
+    size.cy = rect.bottom - rect.top;
+    return size;
+}
+
+/* get the position of an icon in the stand-alone tray */
+static POINT get_icon_pos( struct tray_icon *icon )
+{
+    POINT pos;
+
+    pos.x = icon_cx * icon->display;
+    pos.y = 0;
+    return pos;
+}
+
+/* window procedure for the standalone tray window */
+static LRESULT WINAPI standalone_tray_wndproc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    switch (msg)
+    {
+    case WM_MOVE:
+        update_systray_balloon_position();
+        break;
+    case WM_CLOSE:
+        ShowWindow( hwnd, SW_HIDE );
+        hide_balloon();
+        option_show_systray = FALSE;
+        return 0;
+    case WM_DESTROY:
+        standalone_tray = 0;
+        break;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+/* add an icon to the standalone tray window */
+static void add_to_standalone_tray( struct tray_icon *icon )
+{
+    SIZE size;
+    POINT pos;
+
+    if (!standalone_tray)
+    {
+        static const WCHAR winname[] = {'W','i','n','e',' ','S','y','s','t','e','m',' ','T','r','a','y',0};
+
+        size = get_window_size();
+        standalone_tray = CreateWindowExW( 0, tray_classname, winname, WS_CAPTION | WS_SYSMENU,
+                                           CW_USEDEFAULT, CW_USEDEFAULT, size.cx, size.cy, 0, 0, 0, 0 );
+        if (!standalone_tray) return;
+    }
+
+    icon->display = nb_displayed;
+    pos = get_icon_pos( icon );
+    icon->window = CreateWindowW( icon_classname, NULL, WS_CHILD | WS_VISIBLE,
+                                  pos.x, pos.y, icon_cx, icon_cy, standalone_tray, NULL, NULL, icon );
+    if (!icon->window)
+    {
+        icon->display = -1;
+        return;
+    }
+    create_tooltip( icon );
+
+    nb_displayed++;
+    size = get_window_size();
+    SetWindowPos( standalone_tray, 0, 0, 0, size.cx, size.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER );
+    if (nb_displayed == 1 && option_show_systray) ShowWindow( standalone_tray, SW_SHOWNA );
+    TRACE( "added %u now %d icons\n", icon->id, nb_displayed );
+}
+
+/* remove an icon from the stand-alone tray */
+static void remove_from_standalone_tray( struct tray_icon *icon )
+{
+    struct tray_icon *ptr;
+    POINT pos;
+
+    if (icon->display == -1) return;
+
+    LIST_FOR_EACH_ENTRY( ptr, &icon_list, struct tray_icon, entry )
+    {
+        if (ptr == icon) continue;
+        if (ptr->display < icon->display) continue;
+        ptr->display--;
+        pos = get_icon_pos( ptr );
+        SetWindowPos( ptr->window, 0, pos.x, pos.y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER );
+    }
+    icon->display = -1;
+    if (!--nb_displayed) ShowWindow( standalone_tray, SW_HIDE );
+    TRACE( "removed %u now %d icons\n", icon->id, nb_displayed );
+}
+
+static void repaint_tray_icon( struct tray_icon *icon )
+{
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
+    int width = GetSystemMetrics( SM_CXSMICON );
+    int height = GetSystemMetrics( SM_CYSMICON );
+    BITMAPINFO *info;
+    HBITMAP dib, mask;
+    HDC hdc;
+    RECT rc;
+    SIZE size;
+    POINT pos;
+    int i, x, y;
+    void *color_bits, *mask_bits;
+    DWORD *ptr;
+    BOOL has_alpha = FALSE;
+
+    GetWindowRect( icon->window, &rc );
+    size.cx = rc.right - rc.left;
+    size.cy = rc.bottom - rc.top;
+    pos.x = (size.cx - width) / 2;
+    pos.y = (size.cy - height) / 2;
+
+    info = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, FIELD_OFFSET( BITMAPINFO, bmiColors[2] ));
+    if (!info) return;
+    info->bmiHeader.biSize = sizeof(info->bmiHeader);
+    info->bmiHeader.biWidth = size.cx;
+    info->bmiHeader.biHeight = size.cy;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biCompression = BI_RGB;
+
+    hdc = CreateCompatibleDC( 0 );
+    if (!(dib = CreateDIBSection( 0, info, DIB_RGB_COLORS, &color_bits, NULL, 0 ))) goto done;
+    SelectObject( hdc, dib );
+    DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_NORMAL );
+
+    /* check if the icon was drawn with an alpha channel */
+    for (i = 0, ptr = color_bits; i < size.cx * size.cy; i++)
+        if ((has_alpha = (ptr[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (size.cx + 31) / 32 * 4;
+
+        info->bmiHeader.biBitCount = 1;
+        info->bmiColors[0].rgbRed      = 0;
+        info->bmiColors[0].rgbGreen    = 0;
+        info->bmiColors[0].rgbBlue     = 0;
+        info->bmiColors[0].rgbReserved = 0;
+        info->bmiColors[1].rgbRed      = 0xff;
+        info->bmiColors[1].rgbGreen    = 0xff;
+        info->bmiColors[1].rgbBlue     = 0xff;
+        info->bmiColors[1].rgbReserved = 0;
+
+        if (!(mask = CreateDIBSection( 0, info, DIB_RGB_COLORS, &mask_bits, NULL, 0 ))) goto done;
+        memset( mask_bits, 0xff, width_bytes * size.cy );
+        SelectObject( hdc, mask );
+        DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_MASK );
+
+        for (y = 0, ptr = color_bits; y < size.cy; y++)
+            for (x = 0; x < size.cx; x++, ptr++)
+                if (!((((BYTE *)mask_bits)[y * width_bytes + x / 8] << (x % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+
+        SelectObject( hdc, dib );
+        DeleteObject( mask );
+    }
+
+    UpdateLayeredWindow( icon->window, 0, NULL, NULL, hdc, NULL, 0, &blend, ULW_ALPHA );
+done:
+    HeapFree (GetProcessHeap(), 0, info);
+    if (hdc) DeleteDC( hdc );
+    if (dib) DeleteObject( dib );
+}
+
+static BOOL notify_owner( struct tray_icon *icon, UINT msg, LPARAM lparam )
+{
+    WPARAM wp = icon->id;
+    LPARAM lp = msg;
+
+    if (icon->version >= NOTIFYICON_VERSION_4)
+    {
+        POINT pt = { (short)LOWORD(lparam), (short)HIWORD(lparam) };
+
+        ClientToScreen( icon->window, &pt );
+        wp = MAKEWPARAM( pt.x, pt.y );
+        lp = MAKELPARAM( msg, icon->id );
+    }
+
+    TRACE( "relaying 0x%x\n", msg );
+    if (!SendNotifyMessageW( icon->owner, icon->callback_message, wp, lp ) &&
+        (GetLastError() == ERROR_INVALID_WINDOW_HANDLE))
+    {
+        WARN( "application window was destroyed, removing icon %u\n", icon->id );
+        delete_icon( icon );
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/* window procedure for the individual tray icon window */
+static LRESULT WINAPI tray_icon_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    struct tray_icon *icon = NULL;
+
+    TRACE("hwnd=%p, msg=0x%x\n", hwnd, msg);
+
+    /* set the icon data for the window from the data passed into CreateWindow */
+    if (msg == WM_NCCREATE)
+        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LPARAM)((const CREATESTRUCTW *)lparam)->lpCreateParams);
+
+    icon = (struct tray_icon *) GetWindowLongPtrW(hwnd, GWLP_USERDATA);
+
+    switch (msg)
+    {
+    case WM_SIZE:
+        if (icon->window && icon->layered) repaint_tray_icon( icon );
+        break;
+
+    case WM_PAINT:
+        if (!icon->layered)
+        {
+            PAINTSTRUCT ps;
+            RECT rc;
+            HDC hdc;
+            int cx = GetSystemMetrics( SM_CXSMICON );
+            int cy = GetSystemMetrics( SM_CYSMICON );
+
+            hdc = BeginPaint(hwnd, &ps);
+            GetClientRect(hwnd, &rc);
+            TRACE("painting rect %s\n", wine_dbgstr_rect(&rc));
+            DrawIconEx( hdc, (rc.left + rc.right - cx) / 2, (rc.top + rc.bottom - cy) / 2,
+                        icon->image, cx, cy, 0, 0, DI_DEFAULTSIZE|DI_NORMAL );
+            EndPaint(hwnd, &ps);
+            return 0;
+        }
+        break;
+
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_RBUTTONDOWN:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_LBUTTONDBLCLK:
+    case WM_RBUTTONDBLCLK:
+    case WM_MBUTTONDBLCLK:
+        notify_owner( icon, msg, lparam );
+        break;
+
+    case WM_LBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, NIN_SELECT, lparam );
+        break;
+
+    case WM_RBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, WM_CONTEXTMENU, lparam );
+        break;
+
+    case WM_WINDOWPOSCHANGED:
+        update_systray_balloon_position();
+        break;
+
+    case WM_TIMER:
+        switch (wparam)
+        {
+        case BALLOON_CREATE_TIMER:
+            balloon_create_timer( icon );
+            break;
+        case BALLOON_SHOW_TIMER:
+            balloon_timer();
+            break;
+        }
+        return 0;
+
+    case WM_CLOSE:
+        if (icon->display == -1)
+        {
+            TRACE( "icon %u no longer embedded\n", icon->id );
+            hide_icon( icon );
+            add_to_standalone_tray( icon );
+        }
+        return 0;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static BOOL init_systray(void)
+{
+    static BOOL init_done;
+    WNDCLASSEXW class;
+
+    if (init_done) return TRUE;
+
+    icon_cx = GetSystemMetrics( SM_CXSMICON ) + 2 * ICON_BORDER;
+    icon_cy = GetSystemMetrics( SM_CYSMICON ) + 2 * ICON_BORDER;
+
+    memset( &class, 0, sizeof(class) );
+    class.cbSize        = sizeof(class);
+    class.lpfnWndProc   = tray_icon_wndproc;
+    class.hIcon         = LoadIconW(0, (LPCWSTR)IDI_WINLOGO);
+    class.hCursor       = LoadCursorW( 0, (LPCWSTR)IDC_ARROW );
+    class.lpszClassName = icon_classname;
+    class.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register icon tray window class\n" );
+        return FALSE;
+    }
+
+    class.lpfnWndProc   = standalone_tray_wndproc;
+    class.hbrBackground = (HBRUSH)COLOR_WINDOW;
+    class.lpszClassName = tray_classname;
+    class.style         = CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register standalone tray window class\n" );
+        return FALSE;
+    }
+
+    init_done = TRUE;
+    return TRUE;
+}
+
+/* hide a tray icon */
+static BOOL hide_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (!icon->window) return TRUE;  /* already hidden */
+
+    DestroyWindow(icon->window);
+    DestroyWindow(icon->tooltip);
+    icon->window = 0;
+    icon->layered = FALSE;
+    icon->tooltip = 0;
+    remove_from_standalone_tray( icon );
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* make the icon visible */
+static BOOL show_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (icon->window) return TRUE;  /* already shown */
+
+    add_to_standalone_tray( icon );
+
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* Modifies an existing icon record */
+static BOOL modify_icon( struct tray_icon *icon, NOTIFYICONDATAW *nid )
+{
+    TRACE( "id=0x%x hwnd=%p flags=%x\n", nid->uID, nid->hWnd, nid->uFlags );
+
+    if (nid->uFlags & NIF_STATE)
+    {
+        icon->state = (icon->state & ~nid->dwStateMask) | (nid->dwState & nid->dwStateMask);
+    }
+
+    if (nid->uFlags & NIF_ICON)
+    {
+        if (icon->image) DestroyIcon(icon->image);
+        icon->image = CopyIcon(nid->hIcon);
+        if (icon->window)
+        {
+            if (icon->display != -1) InvalidateRect( icon->window, NULL, TRUE );
+            else if (icon->layered) repaint_tray_icon( icon );
+        }
+    }
+
+    if (nid->uFlags & NIF_MESSAGE)
+    {
+        icon->callback_message = nid->uCallbackMessage;
+    }
+    if (nid->uFlags & NIF_TIP)
+    {
+        lstrcpynW(icon->tiptext, nid->szTip, ARRAY_SIZE( icon->tiptext ));
+        if (icon->tooltip) update_tooltip_text(icon);
+    }
+    if (nid->uFlags & NIF_INFO && nid->cbSize >= NOTIFYICONDATAA_V2_SIZE)
+    {
+        lstrcpynW( icon->info_text, nid->szInfo, ARRAY_SIZE( icon->info_text ));
+        lstrcpynW( icon->info_title, nid->szInfoTitle, ARRAY_SIZE( icon->info_title ));
+        icon->info_flags = nid->dwInfoFlags;
+        icon->info_timeout = max(min(nid->u.uTimeout, BALLOON_SHOW_MAX_TIMEOUT), BALLOON_SHOW_MIN_TIMEOUT);
+        icon->info_icon = nid->hBalloonIcon;
+        update_balloon( icon );
+    }
+    if (icon->state & NIS_HIDDEN) hide_icon( icon );
+    else show_icon( icon );
+    return TRUE;
+}
+
+/* Adds a new icon record to the list */
+static BOOL add_icon(NOTIFYICONDATAW *nid)
+{
+    struct tray_icon  *icon;
+
+    TRACE("id=0x%x, hwnd=%p\n", nid->uID, nid->hWnd);
+
+    if ((icon = get_icon(nid->hWnd, nid->uID)))
+    {
+        WARN("duplicate tray icon add, buggy app?\n");
+        return FALSE;
+    }
+
+    if (!(icon = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*icon))))
+    {
+        ERR("out of memory\n");
+        return FALSE;
+    }
+
+    icon->id     = nid->uID;
+    icon->owner  = nid->hWnd;
+    icon->display = -1;
+
+    list_add_tail(&icon_list, &icon->entry);
+
+    return modify_icon( icon, nid );
+}
+
+/* delete tray icon window and icon structure */
+static BOOL delete_icon( struct tray_icon *icon )
+{
+    hide_icon( icon );
+    list_remove( &icon->entry );
+    DestroyIcon( icon->image );
+    HeapFree( GetProcessHeap(), 0, icon );
+    return TRUE;
+}
+
+/* cleanup all icons for a given window */
+static void cleanup_icons( HWND owner )
+{
+    struct tray_icon *this, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( this, next, &icon_list, struct tray_icon, entry )
+        if (this->owner == owner) delete_icon( this );
+}
+
+
+/***********************************************************************
+ *              wine_notify_icon
+ *
+ * Driver-side implementation of Shell_NotifyIcon.
+ */
+int CDECL wine_notify_icon( DWORD msg, NOTIFYICONDATAW *data )
+{
+    BOOL ret = FALSE;
+    struct tray_icon *icon;
+
+    switch (msg)
+    {
+    case NIM_ADD:
+        if (!init_systray()) return -1;  /* fall back to default handling */
+        ret = add_icon( data );
+        break;
+    case NIM_DELETE:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = delete_icon( icon );
+        break;
+    case NIM_MODIFY:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = modify_icon( icon, data );
+        break;
+    case NIM_SETVERSION:
+        if ((icon = get_icon( data->hWnd, data->uID )))
+        {
+            icon->version = data->u.uVersion;
+            ret = TRUE;
+        }
+        break;
+    case 0xdead:  /* Wine extension: owner window has died */
+        cleanup_icons( data->hWnd );
+        break;
+    default:
+        FIXME( "unhandled tray message: %lu\n", msg );
+        break;
+    }
+    return ret;
+}
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index 24b79ca6e70..989d8d044db 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -41,6 +41,11 @@ enum waylanddrv_unix_func
     waylanddrv_unix_func_count,
 };
 
+struct waylanddrv_unix_init_params
+{
+    BOOL option_show_systray;
+};
+
 struct waylanddrv_unix_clipboard_message_params
 {
     HWND hwnd;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 26b7cd1731a..fce2f4967ed 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -60,6 +60,7 @@ extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
 extern const struct user_driver_funcs waylanddrv_funcs DECLSPEC_HIDDEN;
 extern char *option_drm_device DECLSPEC_HIDDEN;
 extern enum wayland_hidpi_scaling option_hidpi_scaling DECLSPEC_HIDDEN;
+extern BOOL option_show_systray DECLSPEC_HIDDEN;
 extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
index a33e212e24b..cb9b695a62b 100644
--- a/dlls/winewayland.drv/waylanddrv_dll.h
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -28,6 +28,7 @@
 #include "unixlib.h"
 
 #define WAYLANDDRV_UNIX_CALL(func, params) WINE_UNIX_CALL(waylanddrv_unix_func_ ## func, params)
+extern BOOL option_show_systray DECLSPEC_HIDDEN;
 
 NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size);
 NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 265c96b553d..318c0c28c8f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -191,6 +191,8 @@ static void wayland_init_process_name(void)
 
 static NTSTATUS waylanddrv_unix_init(void *arg)
 {
+    struct waylanddrv_unix_init_params *params = arg;
+
     /* Set the user driver functions now so that they are available during
      * our initialization. We clear them on error. */
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
@@ -205,6 +207,8 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
 
     if (!wayland_process_init()) goto err;
 
+    params->option_show_systray = option_show_systray;
+
     return 0;
 
 err:
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index e69de29bb2d..5f086f5c4e5 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -0,0 +1,2 @@
+# System tray
+@ cdecl wine_notify_icon(long ptr)
-- 
2.39.0.rc2

From 9969b8b8f9a8624a4c0702ebd46b77b05ea40e7d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Dec 2021 16:30:05 +0200
Subject: [PATCH 202/202] winewayland.drv: Input event compatibility with
 wine-staging

The rawinput patches in wine-staging require the drivers to send
INPUT_MOUSE and INPUT_KEYBOARD events with a non-NULL rawinput
parameter. Since the rawinput parameter is currently ignored in
upstream for such events, apply this change to maintain a unified
codebase across upstream and staging.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c |  3 ++-
 dlls/winewayland.drv/wayland_pointer.c  | 12 ++++++++----
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 9ad0fce0052..5aa5d99c660 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -309,6 +309,7 @@ static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
 {
     INPUT input;
+    RAWINPUT rawinput = { 0 };
 
     input.type             = INPUT_KEYBOARD;
     input.u.ki.wVk         = vkey;
@@ -317,7 +318,7 @@ static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
     input.u.ki.time        = 0;
     input.u.ki.dwExtraInfo = 0;
 
-    __wine_send_input(hwnd, &input, NULL);
+    __wine_send_input(hwnd, &input, &rawinput);
 }
 
 static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 255d2d4af5f..cd46072eec7 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -47,6 +47,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
     INPUT input = {0};
     int screen_x, screen_y;
     RECT screen_rect;
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -79,7 +80,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
     wayland->last_event_type = INPUT_MOUSE;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
@@ -154,6 +155,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     HWND focused_hwnd = wayland->pointer.focused_surface ?
                         wayland->pointer.focused_surface->hwnd : 0;
     INPUT input = {0};
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -181,7 +183,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     else
         wayland->last_button_serial = 0;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
@@ -210,6 +212,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     HWND focused_hwnd = wayland->pointer.focused_surface ?
                         wayland->pointer.focused_surface->hwnd : 0;
     INPUT input = {0};
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -234,7 +237,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
     wayland->last_event_type = INPUT_MOUSE;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static const struct wl_pointer_listener pointer_listener = {
@@ -263,6 +266,7 @@ static void relative_pointer_handle_motion(void *data,
                         wayland->pointer.focused_surface->hwnd : 0;
     int wine_dx, wine_dy;
     INPUT input = {0};
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -283,7 +287,7 @@ static void relative_pointer_handle_motion(void *data,
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
     wayland->last_event_type = INPUT_MOUSE;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
-- 
2.39.0.rc2

