diff --git a/configure b/configure
index 500b0d81911..11658d018a0 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,20 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+DRM_LIBS
+DRM_CFLAGS
+GBM_LIBS
+GBM_CFLAGS
+XKBCOMMON_LIBS
+XKBCOMMON_CFLAGS
+WAYLAND_CURSOR_LIBS
+WAYLAND_CURSOR_CFLAGS
+WAYLAND_SCANNER
+WAYLAND_PROTOCOLS_DATADIR
+WAYLAND_PROTOCOLS_LIBS
+WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_CLIENT_LIBS
+WAYLAND_CLIENT_CFLAGS
 X_EXTRA_LIBS
 X_LIBS
 X_PRE_LIBS
@@ -922,6 +936,7 @@ with_xrender
 with_xshape
 with_xshm
 with_xxf86vm
+with_wayland
 with_system_dllpath
 with_wine_tools
 with_wine64
@@ -1438,6 +1453,7 @@ enable_wineps_drv
 enable_winepulse_drv
 enable_wineusb_sys
 enable_winevulkan
+enable_winewayland_drv
 enable_winex11_drv
 enable_winexinput_sys
 enable_wing32
@@ -1700,6 +1716,18 @@ ZLIB_PE_CFLAGS
 ZLIB_PE_LIBS
 XMKMF
 CPP
+WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS
+WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_PROTOCOLS_LIBS
+WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS
+GBM_CFLAGS
+GBM_LIBS
+DRM_CFLAGS
+DRM_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2426,6 +2454,7 @@ Optional Packages:
   --without-xshape        do not use the Xshape extension
   --without-xshm          do not use XShm (shared memory extension)
   --without-xxf86vm       do not use XFree video mode extension
+  --with-wayland          build with wayland support
   --with-system-dllpath=PATH
                           load external PE dependencies from colon-separated
                           path PATH
@@ -2496,6 +2525,26 @@ Some influential environment variables:
               Linker flags for the PE zlib, overriding the bundled version
   XMKMF       Path to xmkmf, Makefile generator for X Window System
   CPP         C preprocessor
+  WAYLAND_CLIENT_CFLAGS
+              C compiler flags for wayland-client, overriding pkg-config
+  WAYLAND_CLIENT_LIBS
+              Linker flags for wayland-client, overriding pkg-config
+  WAYLAND_PROTOCOLS_CFLAGS
+              C compiler flags for wayland-protocols, overriding pkg-config
+  WAYLAND_PROTOCOLS_LIBS
+              Linker flags for wayland-protocols, overriding pkg-config
+  WAYLAND_CURSOR_CFLAGS
+              C compiler flags for wayland-cursor, overriding pkg-config
+  WAYLAND_CURSOR_LIBS
+              Linker flags for wayland-cursor, overriding pkg-config
+  XKBCOMMON_CFLAGS
+              C compiler flags for xkbcommon, overriding pkg-config
+  XKBCOMMON_LIBS
+              Linker flags for xkbcommon, overriding pkg-config
+  GBM_CFLAGS  C compiler flags for gbm, overriding pkg-config
+  GBM_LIBS    Linker flags for gbm, overriding pkg-config
+  DRM_CFLAGS  C compiler flags for libdrm, overriding pkg-config
+  DRM_LIBS    Linker flags for libdrm, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -4447,6 +4496,13 @@ then :
 fi
 
 
+# Check whether --with-wayland was given.
+if test ${with_wayland+y}
+then :
+  withval=$with_wayland;
+fi
+
+
 
 # Check whether --with-system-dllpath was given.
 if test ${with_system_dllpath+y}
@@ -15683,6 +15739,629 @@ enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 fi
 
+if test "x$with_wayland" = "xyes"
+then
+    if ${WAYLAND_CLIENT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_CFLAGS=`$PKG_CONFIG --cflags wayland-client 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_CLIENT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_LIBS=`$PKG_CONFIG --libs wayland-client 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client cflags: $WAYLAND_CLIENT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client libs: $WAYLAND_CLIENT_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CLIENT_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-client.h" "ac_cv_header_wayland_client_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_client_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CLIENT_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_display_connect in -lwayland-client" >&5
+printf %s "checking for wl_display_connect in -lwayland-client... " >&6; }
+if test ${ac_cv_lib_wayland_client_wl_display_connect+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-client $WAYLAND_CLIENT_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char wl_display_connect ();
+int
+main (void)
+{
+return wl_display_connect ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_client_wl_display_connect=yes
+else $as_nop
+  ac_cv_lib_wayland_client_wl_display_connect=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_client_wl_display_connect" >&5
+printf "%s\n" "$ac_cv_lib_wayland_client_wl_display_connect" >&6; }
+if test "x$ac_cv_lib_wayland_client_wl_display_connect" = xyes
+then :
+  :
+else $as_nop
+  WAYLAND_CLIENT_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${WAYLAND_PROTOCOLS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_PROTOCOLS_CFLAGS=`$PKG_CONFIG --cflags wayland-protocols 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_PROTOCOLS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_PROTOCOLS_LIBS=`$PKG_CONFIG --libs wayland-protocols 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-protocols cflags: $WAYLAND_PROTOCOLS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-protocols libs: $WAYLAND_PROTOCOLS_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_PROTOCOLS_CFLAGS"
+WAYLAND_PROTOCOLS_DATADIR=`$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    # Extract the first word of "wayland-scanner", so it can be a program name with args.
+set dummy wayland-scanner; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_WAYLAND_SCANNER+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  case $WAYLAND_SCANNER in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_WAYLAND_SCANNER="$WAYLAND_SCANNER" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_WAYLAND_SCANNER="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_WAYLAND_SCANNER" && ac_cv_path_WAYLAND_SCANNER="`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`"
+  ;;
+esac
+fi
+WAYLAND_SCANNER=$ac_cv_path_WAYLAND_SCANNER
+if test -n "$WAYLAND_SCANNER"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $WAYLAND_SCANNER" >&5
+printf "%s\n" "$WAYLAND_SCANNER" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+    if ${WAYLAND_CURSOR_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_CFLAGS=`$PKG_CONFIG --cflags wayland-cursor 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_CURSOR_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_LIBS=`$PKG_CONFIG --libs wayland-cursor 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor cflags: $WAYLAND_CURSOR_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor libs: $WAYLAND_CURSOR_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CURSOR_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-cursor.h" "ac_cv_header_wayland_cursor_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_cursor_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CURSOR_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_cursor_theme_load in -lwayland-cursor" >&5
+printf %s "checking for wl_cursor_theme_load in -lwayland-cursor... " >&6; }
+if test ${ac_cv_lib_wayland_cursor_wl_cursor_theme_load+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-cursor $WAYLAND_CURSOR_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char wl_cursor_theme_load ();
+int
+main (void)
+{
+return wl_cursor_theme_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=yes
+else $as_nop
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&5
+printf "%s\n" "$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&6; }
+if test "x$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" = xyes
+then :
+  :
+else $as_nop
+  WAYLAND_CURSOR_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${XKBCOMMON_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_CFLAGS=`$PKG_CONFIG --cflags xkbcommon 2>/dev/null`
+fi
+fi
+
+if ${XKBCOMMON_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_LIBS=`$PKG_CONFIG --libs xkbcommon 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon cflags: $XKBCOMMON_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon libs: $XKBCOMMON_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XKBCOMMON_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "xkbcommon/xkbcommon.h" "ac_cv_header_xkbcommon_xkbcommon_h" "$ac_includes_default"
+if test "x$ac_cv_header_xkbcommon_xkbcommon_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_XKBCOMMON_XKBCOMMON_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xkb_context_new in -lxkbcommon" >&5
+printf %s "checking for xkb_context_new in -lxkbcommon... " >&6; }
+if test ${ac_cv_lib_xkbcommon_xkb_context_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxkbcommon $XKBCOMMON_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char xkb_context_new ();
+int
+main (void)
+{
+return xkb_context_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_xkbcommon_xkb_context_new=yes
+else $as_nop
+  ac_cv_lib_xkbcommon_xkb_context_new=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xkbcommon_xkb_context_new" >&5
+printf "%s\n" "$ac_cv_lib_xkbcommon_xkb_context_new" >&6; }
+if test "x$ac_cv_lib_xkbcommon_xkb_context_new" = xyes
+then :
+  :
+else $as_nop
+  XKBCOMMON_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${GBM_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GBM_CFLAGS=`$PKG_CONFIG --cflags gbm 2>/dev/null`
+fi
+fi
+
+if ${GBM_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GBM_LIBS=`$PKG_CONFIG --libs gbm 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm cflags: $GBM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm libs: $GBM_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GBM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gbm.h" "ac_cv_header_gbm_h" "$ac_includes_default"
+if test "x$ac_cv_header_gbm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GBM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gbm_create_device in -lgbm" >&5
+printf %s "checking for gbm_create_device in -lgbm... " >&6; }
+if test ${ac_cv_lib_gbm_gbm_create_device+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgbm $GBM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char gbm_create_device ();
+int
+main (void)
+{
+return gbm_create_device ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gbm_gbm_create_device=yes
+else $as_nop
+  ac_cv_lib_gbm_gbm_create_device=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gbm_gbm_create_device" >&5
+printf "%s\n" "$ac_cv_lib_gbm_gbm_create_device" >&6; }
+if test "x$ac_cv_lib_gbm_gbm_create_device" = xyes
+then :
+  :
+else $as_nop
+  GBM_LIBS=""
+fi
+
+         ac_wine_check_funcs_save_LIBS="$LIBS"
+LIBS="$LIBS $GBM_LIBS"
+ac_fn_c_check_func "$LINENO" "gbm_surface_create_with_modifiers2" "ac_cv_func_gbm_surface_create_with_modifiers2"
+if test "x$ac_cv_func_gbm_surface_create_with_modifiers2" = xyes
+then :
+  printf "%s\n" "#define HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2 1" >>confdefs.h
+
+fi
+
+LIBS="$ac_wine_check_funcs_save_LIBS"
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${DRM_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DRM_CFLAGS=`$PKG_CONFIG --cflags libdrm 2>/dev/null`
+fi
+fi
+
+if ${DRM_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DRM_LIBS=`$PKG_CONFIG --libs libdrm 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdrm cflags: $DRM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdrm libs: $DRM_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $DRM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "drm.h" "ac_cv_header_drm_h" "$ac_includes_default"
+if test "x$ac_cv_header_drm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_DRM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for drmPrimeHandleToFD in -ldrm" >&5
+printf %s "checking for drmPrimeHandleToFD in -ldrm... " >&6; }
+if test ${ac_cv_lib_drm_drmPrimeHandleToFD+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldrm $DRM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char drmPrimeHandleToFD ();
+int
+main (void)
+{
+return drmPrimeHandleToFD ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_drm_drmPrimeHandleToFD=yes
+else $as_nop
+  ac_cv_lib_drm_drmPrimeHandleToFD=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_drm_drmPrimeHandleToFD" >&5
+printf "%s\n" "$ac_cv_lib_drm_drmPrimeHandleToFD" >&6; }
+if test "x$ac_cv_lib_drm_drmPrimeHandleToFD" = xyes
+then :
+  :
+else $as_nop
+  DRM_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lEGL" >&5
+printf %s "checking for -lEGL... " >&6; }
+if test ${ac_cv_lib_soname_EGL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lEGL  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char eglGetProcAddress ();
+int
+main (void)
+{
+return eglGetProcAddress ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_EGL=`$ac_cv_path_LDD conftest.exe | grep "EGL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_EGL=`$OTOOL -L conftest$ac_exeext | grep "libEGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libEGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_EGL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libEGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libEGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  ac_cv_lib_soname_EGL=`$LDD conftest$ac_exeext | grep "libEGL\\.$LIBEXT" | sed -e "s/^.*\(libEGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_EGL=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_EGL" >&5
+printf "%s\n" "$ac_cv_lib_soname_EGL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBEGL \"$ac_cv_lib_soname_EGL\"" >>confdefs.h
+
+
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGL  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char glFlush ();
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
+  ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_GL=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
+
+
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGLESv2" >&5
+printf %s "checking for -lGLESv2... " >&6; }
+if test ${ac_cv_lib_soname_GLESv2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGLESv2  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char glFlush ();
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GLESv2=`$ac_cv_path_LDD conftest.exe | grep "GLESv2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GLESv2=`$OTOOL -L conftest$ac_exeext | grep "libGLESv2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGLESv2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GLESv2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGLESv2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGLESv2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  ac_cv_lib_soname_GLESv2=`$LDD conftest$ac_exeext | grep "libGLESv2\\.$LIBEXT" | sed -e "s/^.*\(libGLESv2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_GLESv2=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLESv2" >&5
+printf "%s\n" "$ac_cv_lib_soname_GLESv2" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGLESV2 \"$ac_cv_lib_soname_GLESv2\"" >>confdefs.h
+
+
+fi
+fi
+if test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
+                           test -z "$DRM_LIBS"
+then :
+  case "x$with_wayland" in
+  x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.
+This is an error since --with-wayland was requested." "$LINENO" 5 ;;
+esac
+enable_winewayland_drv=${enable_winewayland_drv:-no}
+fi
+
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
@@ -21943,6 +22622,7 @@ wine_fn_config_makefile dlls/wineps16.drv16 enable_win16
 wine_fn_config_makefile dlls/winepulse.drv enable_winepulse_drv
 wine_fn_config_makefile dlls/wineusb.sys enable_wineusb_sys
 wine_fn_config_makefile dlls/winevulkan enable_winevulkan
+wine_fn_config_makefile dlls/winewayland.drv enable_winewayland_drv
 wine_fn_config_makefile dlls/winex11.drv enable_winex11_drv
 wine_fn_config_makefile dlls/winexinput.sys enable_winexinput_sys
 wine_fn_config_makefile dlls/wing.dll16 enable_win16
@@ -23201,6 +23881,20 @@ X_CFLAGS = $X_CFLAGS
 X_PRE_LIBS = $X_PRE_LIBS
 X_LIBS = $X_LIBS
 X_EXTRA_LIBS = $X_EXTRA_LIBS
+WAYLAND_CLIENT_CFLAGS = $WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS = $WAYLAND_CLIENT_LIBS
+WAYLAND_PROTOCOLS_CFLAGS = $WAYLAND_PROTOCOLS_CFLAGS
+WAYLAND_PROTOCOLS_LIBS = $WAYLAND_PROTOCOLS_LIBS
+WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
+WAYLAND_SCANNER = $WAYLAND_SCANNER
+WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS = $XKBCOMMON_LIBS
+GBM_CFLAGS = $GBM_CFLAGS
+GBM_LIBS = $GBM_LIBS
+DRM_CFLAGS = $DRM_CFLAGS
+DRM_LIBS = $DRM_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index 10c773908be..2552f5159db 100644
--- a/configure.ac
+++ b/configure.ac
@@ -86,6 +86,7 @@ AC_ARG_WITH(xshm,      AS_HELP_STRING([--without-xshm],[do not use XShm (shared
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XShm_h=no; fi])
 AC_ARG_WITH(xxf86vm,   AS_HELP_STRING([--without-xxf86vm],[do not use XFree video mode extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi])
+AC_ARG_WITH(wayland,   AS_HELP_STRING([--with-wayland],[build with wayland support]))
 
 AC_ARG_WITH(system-dllpath,AS_HELP_STRING([--with-system-dllpath=PATH],[load external PE dependencies from colon-separated path PATH]),
             AC_SUBST(system_dllpath,[$withval]))
@@ -1367,6 +1368,45 @@ else
                      [enable_winex11_drv])
 fi
 
+if test "x$with_wayland" = "xyes"
+then
+    WINE_PACKAGE_FLAGS(WAYLAND_CLIENT,[wayland-client],,,,
+        [AC_CHECK_HEADERS([wayland-client.h])
+         AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
+                      [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_PROTOCOLS, [wayland-protocols],,,,
+         [AC_SUBST(WAYLAND_PROTOCOLS_DATADIR,
+                   `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
+    AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
+                 [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
+    WINE_PACKAGE_FLAGS(WAYLAND_CURSOR,[wayland-cursor],,,,
+        [AC_CHECK_HEADERS([wayland-cursor.h])
+         AC_CHECK_LIB(wayland-cursor,wl_cursor_theme_load,[:],
+                      [WAYLAND_CURSOR_LIBS=""],[$WAYLAND_CURSOR_LIBS])])
+    WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
+        [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
+         AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(GBM,[gbm],,,,
+        [AC_CHECK_HEADERS([gbm.h])
+         AC_CHECK_LIB(gbm,gbm_create_device,[:],[GBM_LIBS=""],[$GBM_LIBS])
+         WINE_CHECK_LIB_FUNCS(gbm_surface_create_with_modifiers2, [$GBM_LIBS])])
+    WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
+        [AC_CHECK_HEADERS([drm.h])
+         AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
+    WINE_CHECK_SONAME(EGL,eglGetProcAddress)
+    WINE_CHECK_SONAME(GL,glFlush)
+    WINE_CHECK_SONAME(GLESv2,glFlush)
+fi
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
+                           test -z "$DRM_LIBS"],
+                 [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
+                 [enable_winewayland_drv])
+
 dnl **** Check for OpenCL ****
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
@@ -3181,6 +3221,7 @@ WINE_CONFIG_MAKEFILE(dlls/wineps16.drv16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/winepulse.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineusb.sys)
 WINE_CONFIG_MAKEFILE(dlls/winevulkan)
+WINE_CONFIG_MAKEFILE(dlls/winewayland.drv)
 WINE_CONFIG_MAKEFILE(dlls/winex11.drv)
 WINE_CONFIG_MAKEFILE(dlls/winexinput.sys)
 WINE_CONFIG_MAKEFILE(dlls/wing.dll16,enable_win16)
diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index 7c60466d9ee..434b0cbf778 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -731,7 +731,6 @@ struct windrv_physdev
     struct gdi_physdev     dev;
     struct dibdrv_physdev *dibdrv;
     struct window_surface *surface;
-    DWORD                  start_ticks;
 };
 
 static const struct gdi_dc_funcs window_driver;
@@ -745,13 +744,15 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     /* gdi_lock should not be locked */
     dev->surface->funcs->lock( dev->surface );
-    if (IsRectEmpty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (IsRectEmpty( dev->dibdrv->bounds ) || dev->surface->draw_start_ticks == 0)
+        dev->surface->draw_start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
 {
+    BOOL should_flush = NtGetTickCount() - dev->surface->draw_start_ticks > FLUSH_PERIOD;
     dev->surface->funcs->unlock( dev->surface );
-    if (NtGetTickCount() - dev->start_ticks > FLUSH_PERIOD) dev->surface->funcs->flush( dev->surface );
+    if (should_flush) dev->surface->funcs->flush( dev->surface );
 }
 
 static void CDECL unlock_bits_surface( struct gdi_image_bits *bits )
diff --git a/dlls/win32u/gdiobj.c b/dlls/win32u/gdiobj.c
index f8a1bd96f8f..b5be55e60c1 100644
--- a/dlls/win32u/gdiobj.c
+++ b/dlls/win32u/gdiobj.c
@@ -1151,6 +1151,7 @@ static struct unix_funcs unix_funcs =
     __wine_get_icm_profile,
     __wine_get_wgl_driver,
     __wine_send_input,
+    __wine_send_internal_message_timeout,
 };
 
 void gdi_init(void)
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index caffd837c8b..a7eda62f623 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -3095,6 +3095,20 @@ static BOOL send_message_callback( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lp
     return process_message( &info, NULL, ansi );
 }
 
+/***********************************************************************
+ *		     __wine_send_internal_message_timeout  (win32u.@)
+ *
+ * Same as SendMessageTimeoutW but sends the message to a specific thread
+ * without requiring a window handle. Only works for internal Wine messages.
+ */
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    return send_internal_message_timeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                          flags, timeout, res_ptr );
+}
+
 /***********************************************************************
  *           NtUserPostMessage  (win32u.@)
  */
diff --git a/dlls/win32u/win32u.spec b/dlls/win32u/win32u.spec
index 3771dafcf76..fce30479f28 100644
--- a/dlls/win32u/win32u.spec
+++ b/dlls/win32u/win32u.spec
@@ -1331,3 +1331,6 @@
 @ cdecl __wine_get_brush_bitmap_info(long ptr ptr ptr)
 @ cdecl __wine_get_icm_profile(long long ptr ptr)
 @ cdecl __wine_get_file_outline_text_metric(wstr ptr)
+
+# message
+@ cdecl __wine_send_internal_message_timeout(long long long long long long long ptr)
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 4be068b968d..34c72a3b11f 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -209,6 +209,9 @@ struct unix_funcs
     BOOL (CDECL *get_icm_profile)( HDC hdc, BOOL allow_default, DWORD *size, WCHAR *filename );
     struct opengl_funcs * (CDECL *get_wgl_driver)( HDC hdc, UINT version );
     BOOL (CDECL *wine_send_input)( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+    LRESULT (CDECL *wine_send_internal_message_timeout)( DWORD dest_pid, DWORD dest_tid,
+                                                         UINT msg, WPARAM wparam, LPARAM lparam,
+                                                         UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 };
 
 /* clipboard.c */
diff --git a/dlls/win32u/wrappers.c b/dlls/win32u/wrappers.c
index c5078c8a7f7..6843a9d1d5d 100644
--- a/dlls/win32u/wrappers.c
+++ b/dlls/win32u/wrappers.c
@@ -810,6 +810,15 @@ BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *raw
     return unix_funcs->wine_send_input( hwnd, input, rawinput );
 }
 
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    if (!unix_funcs) return 0;
+    return unix_funcs->wine_send_internal_message_timeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                                           flags, timeout, res_ptr );
+}
+
 extern void wrappers_init( unixlib_handle_t handle )
 {
     const void *args;
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 2dbb2d18bd0..349ef41c893 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -105,14 +105,9 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_NV_external_memory_rdma", # Needs shared resources work.
 
     # Extensions for other platforms
-    "VK_EXT_external_memory_dma_buf",
-    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_objects",
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
-    "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
-    "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
 
     # Extensions which require callback handling
@@ -128,6 +123,11 @@ UNSUPPORTED_EXTENSIONS = [
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
     "VK_KHR_external_memory_win32",
+    "VK_EXT_external_memory_dma_buf",
+    "VK_EXT_image_drm_format_modifier",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory_fd",
+    "VK_KHR_external_semaphore_fd",
 }
 
 # The Vulkan loader provides entry-points for core functionality and important
@@ -186,7 +186,7 @@ FUNCTION_OVERRIDES = {
     "vkGetInstanceProcAddr": {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
 
     # Instance functions
-    "vkCreateDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
+    "vkCreateDevice" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE, "extra_param" : "client_ptr"},
     "vkDestroyInstance" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkEnumerateDeviceExtensionProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkEnumerateDeviceLayerProperties": {"dispatch": True, "driver": False, "thunk": ThunkType.NONE},
@@ -205,7 +205,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateGraphicsPipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
-    "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
+    "vkDestroyDevice" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetDeviceProcAddr" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
     "vkGetDeviceQueue" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -227,6 +227,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceWin32PresentationSupportKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
 
     # VK_KHR_swapchain
+    "vkAcquireNextImageKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
diff --git a/dlls/winevulkan/vulkan_thunks.c b/dlls/winevulkan/vulkan_thunks.c
index 98cabee0aae..477046b916f 100644
--- a/dlls/winevulkan/vulkan_thunks.c
+++ b/dlls/winevulkan/vulkan_thunks.c
@@ -1750,6 +1750,18 @@ static inline void convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host(
 }
 #endif /* USE_STRUCT_CONVERSION */
 
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkFenceGetFdInfoKHR_win32_to_host(const VkFenceGetFdInfoKHR *in, VkFenceGetFdInfoKHR_host *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->fence = in->fence;
+    out->handleType = in->handleType;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
 #if defined(USE_STRUCT_CONVERSION)
 static inline void convert_VkGeneratedCommandsMemoryRequirementsInfoNV_win32_to_host(const VkGeneratedCommandsMemoryRequirementsInfoNV *in, VkGeneratedCommandsMemoryRequirementsInfoNV_host *out)
 {
@@ -1764,6 +1776,27 @@ static inline void convert_VkGeneratedCommandsMemoryRequirementsInfoNV_win32_to_
 }
 #endif /* USE_STRUCT_CONVERSION */
 
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkImageDrmFormatModifierPropertiesEXT_win32_to_host(const VkImageDrmFormatModifierPropertiesEXT *in, VkImageDrmFormatModifierPropertiesEXT_host *out)
+{
+    if (!in) return;
+
+    out->pNext = in->pNext;
+    out->sType = in->sType;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkImageDrmFormatModifierPropertiesEXT_host_to_win32(const VkImageDrmFormatModifierPropertiesEXT_host *in, VkImageDrmFormatModifierPropertiesEXT *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->drmFormatModifier = in->drmFormatModifier;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
 #if defined(USE_STRUCT_CONVERSION)
 static inline void convert_VkImageMemoryRequirementsInfo2_win32_to_host(const VkImageMemoryRequirementsInfo2 *in, VkImageMemoryRequirementsInfo2_host *out)
 {
@@ -1855,6 +1888,18 @@ static inline void convert_VkImageViewHandleInfoNVX_win32_to_host(const VkImageV
 }
 #endif /* USE_STRUCT_CONVERSION */
 
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkMemoryGetFdInfoKHR_win32_to_host(const VkMemoryGetFdInfoKHR *in, VkMemoryGetFdInfoKHR_host *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->memory = in->memory;
+    out->handleType = in->handleType;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
 #if defined(USE_STRUCT_CONVERSION)
 static inline void convert_VkMemoryGetWin32HandleInfoKHR_win32_to_host(const VkMemoryGetWin32HandleInfoKHR *in, VkMemoryGetWin32HandleInfoKHR_host *out)
 {
@@ -2191,6 +2236,46 @@ static inline void convert_VkPipelineInfoEXT_win32_to_host(const VkPipelineInfoE
 }
 #endif /* USE_STRUCT_CONVERSION */
 
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkSemaphoreGetFdInfoKHR_win32_to_host(const VkSemaphoreGetFdInfoKHR *in, VkSemaphoreGetFdInfoKHR_host *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->semaphore = in->semaphore;
+    out->handleType = in->handleType;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkImportFenceFdInfoKHR_win32_to_host(const VkImportFenceFdInfoKHR *in, VkImportFenceFdInfoKHR_host *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->fence = in->fence;
+    out->flags = in->flags;
+    out->handleType = in->handleType;
+    out->fd = in->fd;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkImportSemaphoreFdInfoKHR_win32_to_host(const VkImportSemaphoreFdInfoKHR *in, VkImportSemaphoreFdInfoKHR_host *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->semaphore = in->semaphore;
+    out->flags = in->flags;
+    out->handleType = in->handleType;
+    out->fd = in->fd;
+}
+#endif /* USE_STRUCT_CONVERSION */
+
 #if defined(USE_STRUCT_CONVERSION)
 static inline VkSparseMemoryBind_host *convert_VkSparseMemoryBind_array_win32_to_host(struct conversion_context *ctx, const VkSparseMemoryBind *in, uint32_t count)
 {
diff --git a/dlls/winevulkan/vulkan_thunks.h b/dlls/winevulkan/vulkan_thunks.h
index 6e87550854a..685d2c5bbb5 100644
--- a/dlls/winevulkan/vulkan_thunks.h
+++ b/dlls/winevulkan/vulkan_thunks.h
@@ -1309,6 +1309,18 @@ typedef VkDeviceMemoryOpaqueCaptureAddressInfo VkDeviceMemoryOpaqueCaptureAddres
 typedef VkDeviceMemoryOpaqueCaptureAddressInfo VkDeviceMemoryOpaqueCaptureAddressInfo_host;
 #endif
 
+#if defined(USE_STRUCT_CONVERSION)
+typedef struct VkFenceGetFdInfoKHR_host
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence fence;
+    VkExternalFenceHandleTypeFlagBits handleType;
+} VkFenceGetFdInfoKHR_host;
+#else
+typedef VkFenceGetFdInfoKHR VkFenceGetFdInfoKHR_host;
+#endif
+
 #if defined(USE_STRUCT_CONVERSION)
 typedef struct VkGeneratedCommandsMemoryRequirementsInfoNV_host
 {
@@ -1323,6 +1335,17 @@ typedef struct VkGeneratedCommandsMemoryRequirementsInfoNV_host
 typedef VkGeneratedCommandsMemoryRequirementsInfoNV VkGeneratedCommandsMemoryRequirementsInfoNV_host;
 #endif
 
+#if defined(USE_STRUCT_CONVERSION)
+typedef struct VkImageDrmFormatModifierPropertiesEXT_host
+{
+    VkStructureType sType;
+    void *pNext;
+    uint64_t drmFormatModifier;
+} VkImageDrmFormatModifierPropertiesEXT_host;
+#else
+typedef VkImageDrmFormatModifierPropertiesEXT VkImageDrmFormatModifierPropertiesEXT_host;
+#endif
+
 #if defined(USE_STRUCT_CONVERSION)
 typedef struct VkImageMemoryRequirementsInfo2_host
 {
@@ -1396,6 +1419,18 @@ typedef struct VkImageViewHandleInfoNVX_host
 typedef VkImageViewHandleInfoNVX VkImageViewHandleInfoNVX_host;
 #endif
 
+#if defined(USE_STRUCT_CONVERSION)
+typedef struct VkMemoryGetFdInfoKHR_host
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkDeviceMemory memory;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+} VkMemoryGetFdInfoKHR_host;
+#else
+typedef VkMemoryGetFdInfoKHR VkMemoryGetFdInfoKHR_host;
+#endif
+
 #if defined(USE_STRUCT_CONVERSION)
 typedef struct VkMemoryGetWin32HandleInfoKHR_host
 {
@@ -1669,6 +1704,46 @@ typedef struct VkPipelineInfoEXT_host
 typedef VkPipelineInfoEXT VkPipelineInfoEXT_host;
 #endif
 
+#if defined(USE_STRUCT_CONVERSION)
+typedef struct VkSemaphoreGetFdInfoKHR_host
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore semaphore;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+} VkSemaphoreGetFdInfoKHR_host;
+#else
+typedef VkSemaphoreGetFdInfoKHR VkSemaphoreGetFdInfoKHR_host;
+#endif
+
+#if defined(USE_STRUCT_CONVERSION)
+typedef struct VkImportFenceFdInfoKHR_host
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence fence;
+    VkFenceImportFlags flags;
+    VkExternalFenceHandleTypeFlagBits handleType;
+    int fd;
+} VkImportFenceFdInfoKHR_host;
+#else
+typedef VkImportFenceFdInfoKHR VkImportFenceFdInfoKHR_host;
+#endif
+
+#if defined(USE_STRUCT_CONVERSION)
+typedef struct VkImportSemaphoreFdInfoKHR_host
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore semaphore;
+    VkSemaphoreImportFlags flags;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+    int fd;
+} VkImportSemaphoreFdInfoKHR_host;
+#else
+typedef VkImportSemaphoreFdInfoKHR VkImportSemaphoreFdInfoKHR_host;
+#endif
+
 #if defined(USE_STRUCT_CONVERSION)
 typedef struct VkSparseMemoryBind_host
 {
@@ -2307,9 +2382,11 @@ struct vulkan_device_funcs
     VkResult (*p_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)(VkDevice, VkRenderPass, VkExtent2D *);
     VkResult (*p_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice, const VkRenderingInfo_host *, VkTilePropertiesQCOM *);
     VkResult (*p_vkGetEventStatus)(VkDevice, VkEvent);
+    VkResult (*p_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR_host *, int *);
     VkResult (*p_vkGetFenceStatus)(VkDevice, VkFence);
     VkResult (*p_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
     void (*p_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV_host *, VkMemoryRequirements2_host *);
+    VkResult (*p_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT_host *);
     void (*p_vkGetImageMemoryRequirements)(VkDevice, VkImage, VkMemoryRequirements_host *);
     void (*p_vkGetImageMemoryRequirements2)(VkDevice, const VkImageMemoryRequirementsInfo2_host *, VkMemoryRequirements2_host *);
     void (*p_vkGetImageMemoryRequirements2KHR)(VkDevice, const VkImageMemoryRequirementsInfo2_host *, VkMemoryRequirements2_host *);
@@ -2320,6 +2397,8 @@ struct vulkan_device_funcs
     void (*p_vkGetImageSubresourceLayout2EXT)(VkDevice, VkImage, const VkImageSubresource2EXT *, VkSubresourceLayout2EXT_host *);
     VkResult (*p_vkGetImageViewAddressNVX)(VkDevice, VkImageView, VkImageViewAddressPropertiesNVX_host *);
     uint32_t (*p_vkGetImageViewHandleNVX)(VkDevice, const VkImageViewHandleInfoNVX_host *);
+    VkResult (*p_vkGetMemoryFdKHR)(VkDevice, const VkMemoryGetFdInfoKHR_host *, int *);
+    VkResult (*p_vkGetMemoryFdPropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, int, VkMemoryFdPropertiesKHR *);
     VkResult (*p_vkGetMemoryHostPointerPropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryHostPointerPropertiesEXT *);
     VkResult (*p_vkGetMemoryWin32HandleKHR)(VkDevice, const VkMemoryGetWin32HandleInfoKHR_host *, HANDLE *);
     VkResult (*p_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, VkMemoryWin32HandlePropertiesKHR *);
@@ -2342,11 +2421,14 @@ struct vulkan_device_funcs
     void (*p_vkGetRenderAreaGranularity)(VkDevice, VkRenderPass, VkExtent2D *);
     VkResult (*p_vkGetSemaphoreCounterValue)(VkDevice, VkSemaphore, uint64_t *);
     VkResult (*p_vkGetSemaphoreCounterValueKHR)(VkDevice, VkSemaphore, uint64_t *);
+    VkResult (*p_vkGetSemaphoreFdKHR)(VkDevice, const VkSemaphoreGetFdInfoKHR_host *, int *);
     VkResult (*p_vkGetShaderInfoAMD)(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, size_t *, void *);
     void (*p_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice, const VkShaderModuleCreateInfo *, VkShaderModuleIdentifierEXT *);
     void (*p_vkGetShaderModuleIdentifierEXT)(VkDevice, VkShaderModule, VkShaderModuleIdentifierEXT *);
     VkResult (*p_vkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
     VkResult (*p_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
+    VkResult (*p_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR_host *);
+    VkResult (*p_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR_host *);
     VkResult (*p_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
     VkResult (*p_vkInvalidateMappedMemoryRanges)(VkDevice, uint32_t, const VkMappedMemoryRange_host *);
     VkResult (*p_vkMapMemory)(VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, void **);
@@ -2818,9 +2900,11 @@ struct vulkan_instance_funcs
     USE_VK_FUNC(vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI) \
     USE_VK_FUNC(vkGetDynamicRenderingTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetEventStatus) \
+    USE_VK_FUNC(vkGetFenceFdKHR) \
     USE_VK_FUNC(vkGetFenceStatus) \
     USE_VK_FUNC(vkGetFramebufferTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsNV) \
+    USE_VK_FUNC(vkGetImageDrmFormatModifierPropertiesEXT) \
     USE_VK_FUNC(vkGetImageMemoryRequirements) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2KHR) \
@@ -2831,6 +2915,8 @@ struct vulkan_instance_funcs
     USE_VK_FUNC(vkGetImageSubresourceLayout2EXT) \
     USE_VK_FUNC(vkGetImageViewAddressNVX) \
     USE_VK_FUNC(vkGetImageViewHandleNVX) \
+    USE_VK_FUNC(vkGetMemoryFdKHR) \
+    USE_VK_FUNC(vkGetMemoryFdPropertiesKHR) \
     USE_VK_FUNC(vkGetMemoryHostPointerPropertiesEXT) \
     USE_VK_FUNC(vkGetMemoryWin32HandleKHR) \
     USE_VK_FUNC(vkGetMemoryWin32HandlePropertiesKHR) \
@@ -2853,11 +2939,14 @@ struct vulkan_instance_funcs
     USE_VK_FUNC(vkGetRenderAreaGranularity) \
     USE_VK_FUNC(vkGetSemaphoreCounterValue) \
     USE_VK_FUNC(vkGetSemaphoreCounterValueKHR) \
+    USE_VK_FUNC(vkGetSemaphoreFdKHR) \
     USE_VK_FUNC(vkGetShaderInfoAMD) \
     USE_VK_FUNC(vkGetShaderModuleCreateInfoIdentifierEXT) \
     USE_VK_FUNC(vkGetShaderModuleIdentifierEXT) \
     USE_VK_FUNC(vkGetSwapchainImagesKHR) \
     USE_VK_FUNC(vkGetValidationCacheDataEXT) \
+    USE_VK_FUNC(vkImportFenceFdKHR) \
+    USE_VK_FUNC(vkImportSemaphoreFdKHR) \
     USE_VK_FUNC(vkInitializePerformanceApiINTEL) \
     USE_VK_FUNC(vkInvalidateMappedMemoryRanges) \
     USE_VK_FUNC(vkMapMemory) \
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
new file mode 100644
index 00000000000..e145b30bf11
--- /dev/null
+++ b/dlls/winewayland.drv/Makefile.in
@@ -0,0 +1,54 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
+MODULE = winewayland.drv
+UNIXLIB = winewayland.so
+IMPORTS = gdi32 user32 uuid
+DELAYIMPORTS = comctl32 ole32 shell32
+UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
+              $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
+UNIX_LIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
+            $(XKBCOMMON_LIBS) $(GBM_LIBS) $(UDEV_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
+
+C_SRCS = \
+	display.c \
+	dllmain.c \
+	dump_pixels.c \
+	gbm.c \
+	gdi.c \
+	opengl.c \
+	options.c \
+	registry.c \
+	systray.c \
+	unicode.c \
+	vulkan.c \
+	vulkan_remote.c \
+	wayland.c \
+	wayland_buffer_queue.c \
+	wayland_cursor.c \
+	wayland_data_device.c \
+	wayland_data_device_dll.c \
+	wayland_data_device_format.c \
+	wayland_dmabuf.c \
+	wayland_keyboard.c \
+	wayland_keyboard_layout.c \
+	wayland_mutex.c \
+	wayland_native_buffer.c \
+	wayland_output.c \
+	wayland_pointer.c \
+	wayland_remote.c \
+	wayland_shm.c \
+	wayland_shmfd.c \
+	wayland_surface.c \
+	waylanddrv_main.c \
+	window.c \
+	window_surface.c \
+	xkb_util.c \
+
+WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
+
+RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..360f0185dad
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,388 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+#define NEXT_DEVMODEW(mode) ((DEVMODEW *)((char *)((mode) + 1) + (mode)->dmDriverExtra))
+
+static BOOL force_display_devices_refresh;
+
+static void wayland_refresh_display_devices(void)
+{
+    UINT32 num_path, num_mode;
+    force_display_devices_refresh = TRUE;
+    /* Trigger refresh in win32u */
+    NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
+}
+
+static void wayland_resize_desktop_window(void)
+{
+    BOOL wayland_initialized = wayland_process_acquire()->initialized;
+    wayland_process_release();
+
+    /* During process wayland initialization we will get our initial output
+     * information and init the display devices. There is no need to resize the
+     * desktop in this case, since this is the initial display state.
+     * Additionally, initialization may occur in a context that has acquired
+     * the internal Wine user32 lock, and sending messages would lead to an
+     * internal user32 lock error. */
+    if (wayland_initialized)
+        send_message(NtUserGetDesktopWindow(), WM_DISPLAYCHANGE, 0, 0);
+}
+
+/* Initialize registry display settings when new display devices are added */
+static void wayland_init_registry_display_settings(void)
+{
+    DEVMODEW dm = {.dmSize = sizeof(dm)};
+    DISPLAY_DEVICEW dd = {sizeof(dd)};
+    UNICODE_STRING device_name;
+    DWORD i = 0;
+    LONG ret;
+
+    while (!NtUserEnumDisplayDevices(NULL, i++, &dd, 0))
+    {
+        RtlInitUnicodeString(&device_name, dd.DeviceName);
+
+        /* Skip if the device already has registry display settings */
+        if (NtUserEnumDisplaySettings(&device_name, ENUM_REGISTRY_SETTINGS, &dm, 0))
+            continue;
+
+        if (!NtUserEnumDisplaySettings(&device_name, ENUM_CURRENT_SETTINGS, &dm, 0))
+        {
+            ERR("Failed to query current display settings for %s.\n", wine_dbgstr_w(dd.DeviceName));
+            continue;
+        }
+
+        TRACE("Device %s current display mode %ux%u %ubits %uHz at %d,%d.\n",
+              wine_dbgstr_w(dd.DeviceName), dm.dmPelsWidth, dm.dmPelsHeight, dm.dmBitsPerPel,
+              dm.dmDisplayFrequency, dm.dmPosition.x, dm.dmPosition.y);
+
+        ret = NtUserChangeDisplaySettings(&device_name, &dm, NULL,
+                                          CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL);
+        if (ret != DISP_CHANGE_SUCCESSFUL)
+        {
+            ERR("Failed to save registry display settings for %s, returned %d.\n",
+                wine_dbgstr_w(dd.DeviceName), ret);
+        }
+    }
+}
+
+void wayland_init_display_devices()
+{
+    wayland_refresh_display_devices();
+    wayland_notify_wine_monitor_change();
+    wayland_init_registry_display_settings();
+    wayland_resize_desktop_window();
+}
+
+static void wayland_add_device_gpu(const struct gdi_device_manager *device_manager,
+                                   void *param)
+{
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    struct gdi_gpu gpu = {0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    /* TODO: Fill in gpu information from vulkan. */
+
+    TRACE("id=0x%s name=%s\n",
+          wine_dbgstr_longlong(gpu.id), wine_dbgstr_w(gpu.name));
+
+    device_manager->add_gpu(&gpu, param);
+}
+
+static void wayland_add_device_adapter(const struct gdi_device_manager *device_manager,
+                                       void *param, INT output_id)
+{
+    struct gdi_adapter adapter;
+    adapter.id = output_id;
+    adapter.state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
+    if (output_id == 0)
+        adapter.state_flags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    TRACE("id=0x%s state_flags=0x%x\n",
+          wine_dbgstr_longlong(adapter.id), adapter.state_flags);
+
+    device_manager->add_adapter(&adapter, param);
+}
+
+static void wayland_add_device_monitor(const struct gdi_device_manager *device_manager,
+                                       void *param, struct wayland_output *output)
+{
+
+    struct gdi_monitor monitor = {0};
+    DWORD len = 0;
+
+    if (RtlUTF8ToUnicodeN(monitor.name, sizeof(monitor.name), &len,
+                          output->name, strlen(output->name) + 1))
+    {
+        monitor.name[0] = 0;
+    }
+
+    SetRect(&monitor.rc_monitor, output->x, output->y,
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
+
+    /* We don't have a direct way to get the work area in Wayland. */
+    monitor.rc_work = monitor.rc_monitor;
+
+    monitor.state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+
+    TRACE("name=%s rc_monitor=rc_work=%s state_flags=0x%x\n",
+          wine_dbgstr_w(monitor.name), wine_dbgstr_rect(&monitor.rc_monitor),
+          monitor.state_flags);
+
+    device_manager->add_monitor(&monitor, param);
+}
+
+static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
+{
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY;
+    mode->dmDisplayOrientation = DMDO_DEFAULT;
+    mode->dmDisplayFlags = 0;
+    mode->dmBitsPerPel = output_mode->bpp;
+    mode->dmPelsWidth = output_mode->width;
+    mode->dmPelsHeight = output_mode->height;
+    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+}
+
+static void wayland_add_device_modes(const struct gdi_device_manager *device_manager,
+                                     void *param, struct wayland_output *output)
+{
+
+    struct wayland_output_mode *output_mode;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        DEVMODEW mode;
+        populate_devmode(output_mode, &mode);
+        device_manager->add_mode(&mode, param);
+    }
+}
+
+static void wayland_add_device_output(const struct gdi_device_manager *device_manager,
+                                      void *param, struct wayland_output *output,
+                                      INT output_id)
+{
+    char buf[16];
+    int len;
+
+    /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+    wayland_add_device_adapter(device_manager, param, output_id);
+    wayland_add_device_monitor(device_manager, param, output);
+    wayland_add_device_modes(device_manager, param, output);
+
+    /* Set the wine name in wayland_output so that we can look it up. */
+    len = snprintf(buf, sizeof(buf), "\\\\.\\DISPLAY%u", output_id + 1);
+    if (len > sizeof(buf)) len = sizeof(buf);
+    ascii_to_unicode_z(output->wine_name, ARRAY_SIZE(output->wine_name), buf, len);
+    TRACE("name=%s wine_name=%s\n",
+          output->name, wine_dbgstr_w(output->wine_name));
+}
+
+static struct wayland_output *wayland_get_primary_output(struct wayland *wayland)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (output->current_wine_mode && output->x == 0 && output->y == 0)
+            return output;
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *      UpdateDisplayDevices (WAYLAND.@)
+ */
+BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param)
+{
+    struct wayland *wayland;
+    struct wayland_output *output, *primary;
+    INT output_id = 0;
+
+    if (!force && !force_display_devices_refresh) return TRUE;
+
+    TRACE("force=%d force_refresh=%d\n", force, force_display_devices_refresh);
+
+    force_display_devices_refresh = FALSE;
+
+    wayland = wayland_process_acquire();
+
+    wayland_add_device_gpu(device_manager, param);
+
+    /* Get the primary output (i.e., positioned at 0,0) and add it with id 0. */
+    primary = wayland_get_primary_output(wayland);
+    if (primary)
+    {
+        wayland_add_device_output(device_manager, param, primary, output_id);
+        output_id++;
+    }
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_wine_mode || output == primary) continue;
+        wayland_add_device_output(device_manager, param, output, output_id);
+        output_id++;
+    }
+
+    wayland_process_release();
+
+    return TRUE;
+}
+
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_wine_mode)
+        return FALSE;
+
+    populate_devmode(output->current_wine_mode, mode);
+
+    mode->dmFields |= DM_POSITION;
+    mode->dmPosition.x = output->x;
+    mode->dmPosition.y = output->y;
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *             GetCurrentDisplaySettings  (WAYLAND.@)
+ *
+ */
+BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, LPDEVMODEW devmode)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    BOOL ret;
+
+    TRACE("(%s,%p) wayland=%p\n", debugstr_w(name), devmode, wayland);
+
+    ret = wayland_get_current_devmode(wayland, name, devmode);
+
+    wayland_process_release();
+
+    if (ret)
+    {
+        TRACE("=> %d,%d+%dx%d@%d %dbpp\n", devmode->dmPosition.x, devmode->dmPosition.y,
+              devmode->dmPelsWidth, devmode->dmPelsHeight,
+              devmode->dmDisplayFrequency, devmode->dmBitsPerPel);
+    }
+    else
+    {
+        ERR("Failed to get %s current display settings.\n", wine_dbgstr_w(name));
+    }
+
+    return ret;
+}
+
+static struct wayland_output_mode *get_matching_output_mode(struct wayland_output *output,
+                                                            LPDEVMODEW devmode)
+{
+    struct wayland_output_mode *output_mode;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (devmode->dmPelsWidth == output_mode->width &&
+            devmode->dmPelsHeight == output_mode->height &&
+            output_mode->bpp == devmode->dmBitsPerPel &&
+            output_mode->refresh / 1000 == devmode->dmDisplayFrequency)
+        {
+            return output_mode;
+        }
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *		ChangeDisplaySettings  (WAYLAND.@)
+ *
+ */
+LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW displays, HWND hwnd, DWORD flags,
+                                   LPVOID lpvoid)
+{
+    LONG ret;
+    struct wayland *wayland = wayland_process_acquire();
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+    DEVMODEW *devmode;
+
+    for (devmode = displays; devmode->dmSize; devmode = NEXT_DEVMODEW(devmode))
+    {
+        TRACE("device=%s devmode=%dx%d@%d %dbpp\n",
+              wine_dbgstr_w(devmode->dmDeviceName), devmode->dmPelsWidth,
+              devmode->dmPelsHeight, devmode->dmDisplayFrequency,
+              devmode->dmBitsPerPel);
+
+        output = wayland_output_get_by_wine_name(wayland, devmode->dmDeviceName);
+        if (!output)
+        {
+            ret = DISP_CHANGE_BADPARAM;
+            goto out;
+        }
+
+        output_mode = get_matching_output_mode(output, devmode);
+        if (!output_mode)
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+
+        wayland_output_set_wine_mode(output, output_mode);
+
+        TRACE("output=%s (%s) set current wine mode %dx%d wine_scale %f\n",
+              output->name, wine_dbgstr_w(output->wine_name),
+              output_mode->width, output_mode->height, output->wine_scale);
+    }
+
+    wayland_refresh_display_devices();
+
+    /* Release the wayland process instance lock to avoid potential deadlocks
+     * while notifying other thread instances below. */
+    wayland_process_release();
+
+    wayland_notify_wine_monitor_change();
+
+    return DISP_CHANGE_SUCCESSFUL;
+
+out:
+    wayland_process_release();
+    return ret;
+}
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
new file mode 100644
index 00000000000..86ce435077f
--- /dev/null
+++ b/dlls/winewayland.drv/dllmain.c
@@ -0,0 +1,70 @@
+/*
+ * winewayland.drv entry points
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "waylanddrv_dll.h"
+
+unixlib_handle_t waylanddrv_handle;
+BOOL option_show_systray;
+
+typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
+static const kernel_callback kernel_callbacks[] =
+{
+    waylanddrv_client_create_clipboard_window,
+    waylanddrv_client_dnd,
+};
+
+C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == waylanddrv_client_func_last);
+
+static DWORD WINAPI wayland_read_events_thread(void *arg)
+{
+    WAYLANDDRV_UNIX_CALL(read_events, NULL);
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    TerminateProcess(GetCurrentProcess(), 1);
+    return 0;
+}
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    struct waylanddrv_unix_init_params init_params;
+    DWORD tid;
+    void **callback_table;
+
+    if (reason != DLL_PROCESS_ATTACH) return TRUE;
+
+    DisableThreadLibraryCalls(instance);
+    if (NtQueryVirtualMemory(GetCurrentProcess(), instance, MemoryWineUnixFuncs,
+                             &waylanddrv_handle, sizeof(waylanddrv_handle), NULL))
+        return FALSE;
+
+    callback_table = NtCurrentTeb()->Peb->KernelCallbackTable;
+    memcpy(callback_table + NtUserDriverCallbackFirst, kernel_callbacks,
+           sizeof(kernel_callbacks));
+
+    if (WAYLANDDRV_UNIX_CALL(init, &init_params))
+        return FALSE;
+
+    option_show_systray = init_params.option_show_systray;
+
+    /* Read wayland events from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/dump_pixels.c b/dlls/winewayland.drv/dump_pixels.c
new file mode 100644
index 00000000000..5c3904b6b3d
--- /dev/null
+++ b/dlls/winewayland.drv/dump_pixels.c
@@ -0,0 +1,174 @@
+/*
+ * Debugging functions for pixel buffer contents
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntgdi.h"
+#include "winuser.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!region) return NULL;
+
+    if (!(size = NtGdiGetRegionData(region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+
+    if (!NtGdiGetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    free(data);
+    return NULL;
+}
+
+/* Dump the contents of a pixel buffer, along with the outlines of damage
+ * and window regions, to a netpbm .pam file. */
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels,
+                 int width, int height, BOOL alpha, HRGN damage, HRGN win_region)
+{
+    char fname[128] = {0};
+    RGNDATA *damage_data;
+    RGNDATA *win_region_data;
+    FILE *fp;
+    int x, y;
+
+    damage_data = get_region_data(damage);
+    win_region_data = get_region_data(win_region);
+
+    snprintf(fname, sizeof(fname), fpattern, dbgid);
+    TRACE("dumping pixels to %s\n", fname);
+
+    fp = fopen(fname, "w");
+    assert(fp && "Failed to open target file for dump pixels. Does the target directory exist?");
+
+    fprintf(fp, "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
+            width, height);
+
+    for (y = 0; y < height; ++y)
+    {
+        for (x = 0; x < width; ++x)
+        {
+            BOOL draw_damage = FALSE;
+            BOOL draw_win_region = FALSE;
+            RECT *rgn_rect;
+            RECT *end;
+
+            if (damage_data)
+            {
+                rgn_rect = (RECT *)damage_data->Buffer;
+                end = rgn_rect + damage_data->rdh.nCount;
+
+                /* Draw the outlines of damaged areas. */
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (win_region_data)
+            {
+                /* Draw the outlines of window region areas. */
+                rgn_rect = (RECT *)win_region_data->Buffer;
+                end = rgn_rect + win_region_data->rdh.nCount;
+
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (draw_damage || draw_win_region)
+            {
+                unsigned char rgba[4] = {
+                    draw_damage ? 0xff : 0x00,
+                    draw_win_region ? 0xff : 0x00,
+                    0x00, 0xff
+                };
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+            else
+            {
+                unsigned int *pixel = (unsigned int *)((char *)pixels +
+                                                       width * 4 * y + 4 * x);
+                unsigned char rgba[4] = {
+                    (*pixel & 0x00ff0000) >> 16,
+                    (*pixel & 0x0000ff00) >> 8,
+                    (*pixel & 0xff),
+                    alpha ? (*pixel & 0xff000000) >> 24 : 0xff,
+                };
+
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+        }
+    }
+
+    fflush(fp);
+    fclose(fp);
+
+    free(damage_data);
+    free(win_region_data);
+}
diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
new file mode 100644
index 00000000000..82cb99c45e3
--- /dev/null
+++ b/dlls/winewayland.drv/gbm.c
@@ -0,0 +1,429 @@
+/*
+ * Wayland GBM support
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_LIBUDEV_H
+#include <libudev.h>
+#endif
+#include <stdlib.h>
+#include <unistd.h>
+#include <xf86drm.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct gbm_device *process_gbm_device;
+static pthread_once_t init_once;
+
+static const char default_seat[] = "seat0";
+static const char default_render_node[] = "/dev/dri/renderD128";
+static const char default_primary_node[] = "/dev/dri/card0";
+static const char primary_node_sysname[] = "card[0-9]*";
+static const char render_node_sysname[] = "renderD[0-9]*";
+
+#ifdef HAVE_UDEV
+
+typedef BOOL (*filter_func)(struct udev_device *, const char *);
+
+/* returns TRUE for every udev_dev whose devnode is not devnode_to_ignore */
+static BOOL filter_has_different_devnode(struct udev_device *udev_dev,
+                                         const char *devnode_to_ignore)
+{
+    const char *devnode;
+
+    assert(udev_dev && devnode_to_ignore);
+
+    /* If we can't get a devnode from the device, we prefer to filter it out */
+    devnode = udev_device_get_devnode(udev_dev);
+    if (!devnode)
+        return FALSE;
+
+    /* devnode is equal to devnode_to_ignore */
+    if (strcmp(devnode, devnode_to_ignore) == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* returns TRUE for every udev_dev that is not the primary system GPU */
+static BOOL filter_is_not_primary_system_gpu(struct udev_device *udev_dev,
+                                             const char *unused_arg)
+{
+    struct udev_device *pci_device;
+    const char *boot_vga;
+
+    assert(udev_dev);
+
+    /* If we can't get pci_device, we prefer to filter the device out */
+    pci_device = udev_device_get_parent(udev_dev);
+    if (!pci_device)
+        return FALSE;
+
+    /* It is the primary system GPU */
+    boot_vga = udev_device_get_sysattr_value(pci_device, "boot_vga");
+    if (boot_vga && strcmp(boot_vga, "1") == 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* returns TRUE for every udev_dev whose ID_PATH_TAG is id_path_tag */
+static BOOL filter_has_same_id_path_tag(struct udev_device *udev_dev,
+                                        const char *id_path_tag)
+{
+    const char *dev_id_path_tag;
+
+    assert(udev_dev && id_path_tag);
+
+    /* If we can't get dev_id_path_tag, we prefer to filter the device out */
+    dev_id_path_tag = udev_device_get_property_value(udev_dev, "ID_PATH_TAG");
+    if (!dev_id_path_tag)
+        return FALSE;
+
+    /* ID_PATH_TAG is different from id_path_tag */
+    if (strcmp(dev_id_path_tag, id_path_tag) != 0)
+        return FALSE;
+
+    return TRUE;
+}
+
+static BOOL is_primary_system_gpu_set(void)
+{
+    struct udev *udev;
+    struct udev_enumerate *e = NULL;
+    BOOL ret = FALSE;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+
+    udev_enumerate_add_match_sysattr(e, "boot_vga", "1");
+
+    /* if list is not empty we have a PCI device with boot_vga set to 1 (i.e. we
+     * have a PCI device marked as the primary system GPU) */
+    udev_enumerate_scan_devices(e);
+    if (udev_enumerate_get_list_entry(e)) ret = TRUE;
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return ret;
+}
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc,
+                                  filter_func filter, const char *filter_arg)
+{
+    const char *seat;
+    struct udev *udev = NULL;
+    struct udev_enumerate *e = NULL;
+    struct udev_list_entry *entry;
+    int drm_fd = -1;
+
+    seat = getenv("XDG_SEAT");
+    if (!seat) seat = default_seat;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+    udev_enumerate_add_match_subsystem(e, "drm");
+    udev_enumerate_add_match_sysname(e, sysname);
+
+    udev_enumerate_scan_devices(e);
+    udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e))
+    {
+        const char *path, *device_seat, *devnode;
+        struct udev_device *device;
+
+        path = udev_list_entry_get_name(entry);
+        device = udev_device_new_from_syspath(udev, path);
+        if (!device) continue;
+
+        device_seat = udev_device_get_property_value(device, "ID_SEAT");
+        if (!device_seat) device_seat = default_seat;
+        if (strcmp(device_seat, seat))
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        devnode = udev_device_get_devnode(device);
+        if (!devnode)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        /* If we have a filter, we may ignore certain devices */
+        if (filter && filter(device, filter_arg) == FALSE)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        drm_fd = open(devnode, O_RDWR);
+        TRACE("Trying to open drm device (%s) %s => fd=%d\n", desc, devnode, drm_fd);
+
+        udev_device_unref(device);
+        if (drm_fd >= 0) break;
+    }
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return drm_fd;
+}
+
+#else
+
+typedef void (*filter_func)(void);
+
+static void filter_has_different_devnode(void)
+{
+}
+
+static void filter_is_not_primary_system_gpu(void)
+{
+}
+
+static void filter_has_same_id_path_tag(void)
+{
+}
+
+static BOOL is_primary_system_gpu_set(void)
+{
+    return FALSE;
+}
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc,
+                                  filter_func filter, const char *filter_arg)
+{
+    return -1;
+}
+
+#endif
+
+static char *get_compositor_render_node(void)
+{
+    struct wayland *wayland = wayland_process_acquire();
+    char *compositor_render_node = NULL;
+    drmDevicePtr dev_ptr;
+
+    if (!wayland->dmabuf.default_feedback)
+        goto out;
+
+    if (drmGetDeviceFromDevId(wayland->dmabuf.default_feedback->main_device,
+                              0, &dev_ptr) < 0)
+        goto out;
+
+    if (dev_ptr->available_nodes & (1 << DRM_NODE_RENDER))
+        compositor_render_node = strdup(dev_ptr->nodes[DRM_NODE_RENDER]);
+
+    drmFreeDevice(&dev_ptr);
+
+out:
+    wayland_process_release();
+    return compositor_render_node;
+}
+
+/**********************************************************************
+ *          wayland_gbm_create_surface
+ */
+struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, int height,
+                                               size_t count_modifiers, uint64_t *modifiers,
+                                               BOOL format_is_scanoutable)
+{
+    uint32_t gbm_bo_flags = GBM_BO_USE_RENDERING;
+
+    if (TRACE_ON(waylanddrv))
+    {
+        size_t i;
+
+        TRACE("%dx%d %.4s scanout=%d count_mods=%zu\n",
+              width, height, (const char *)&drm_format,
+              format_is_scanoutable, count_modifiers);
+
+        for (i = 0; i < count_modifiers; i++)
+            TRACE("    mod: 0x%.16llx\n", (long long)modifiers[i]);
+    }
+
+    if (format_is_scanoutable) gbm_bo_flags |= GBM_BO_USE_SCANOUT;
+
+    if (count_modifiers)
+    {
+#ifdef HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2
+        return gbm_surface_create_with_modifiers2(process_gbm_device, width, height,
+                                                  drm_format, modifiers, count_modifiers, gbm_bo_flags);
+#else
+        return gbm_surface_create_with_modifiers(process_gbm_device, width, height,
+                                                 drm_format, modifiers, count_modifiers);
+#endif
+    }
+
+    return gbm_surface_create(process_gbm_device, width, height, drm_format, gbm_bo_flags);
+}
+
+static void wayland_gbm_init_once(void)
+{
+    int drm_fd = -1;
+    char *compositor_render_node = get_compositor_render_node();
+    const char *dri_prime = getenv("DRI_PRIME");
+    const char *desc;
+
+    if (option_drm_device)
+    {
+        drm_fd = open(option_drm_device, O_RDWR);
+        TRACE("Trying to open drm device (from options) %s => fd=%d\n",
+              option_drm_device, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open device from DRMDevice driver option\n");
+    }
+
+    if (drm_fd < 0 && dri_prime)
+    {
+        if (strcmp(dri_prime, "1") == 0)
+        {
+            if (compositor_render_node)
+            {
+                /* DRI_PRIME is 1, so we open the non-default device (device
+                 * that is different from whatever the compositor is using) */
+                desc = "from DRI_PRIME == 1, different from compositor render node";
+                drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                                filter_has_different_devnode, compositor_render_node);
+            }
+            else if (is_primary_system_gpu_set())
+            {
+                /* We don't know what device the compositor is using, so we
+                 * consider that the primary system GPU is the default device. */
+                desc = "from DRI_PRIME == 1, different from primary system GPU";
+                drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                                filter_is_not_primary_system_gpu, NULL);
+            }
+        }
+        else
+        {
+            /* DRI_PRIME should be set to ID_TAG_PATH of the GPU the user wants
+             * us to use. */
+            desc = "from DRI_PRIME == ID_PATH_TAG";
+            drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc,
+                                            filter_has_same_id_path_tag, dri_prime);
+        }
+
+        if (drm_fd < 0)
+            WARN("Failed to open DRI_PRIME device\n");
+    }
+
+    if (drm_fd < 0 && compositor_render_node)
+    {
+        drm_fd = open(compositor_render_node, O_RDWR);
+        TRACE("Trying to open drm device (from compositor render node) %s => fd=%d\n",
+              compositor_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open drm device that compositor is using\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random render node";
+        drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc, NULL, NULL);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_render_node, O_RDWR);
+        TRACE("Trying to open drm device (default render node) %s => fd=%d\n",
+              default_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random primary node";
+        drm_fd = wayland_gbm_get_drm_fd(primary_node_sysname, desc, NULL, NULL);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable primary node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_primary_node, O_RDWR);
+        TRACE("Trying to open drm device (default primary node) %s => fd=%d\n",
+              default_primary_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default primary node\n");
+    }
+
+    free(compositor_render_node);
+
+    if (drm_fd < 0)
+    {
+        ERR("Failed to find a suitable drm device\n");
+        return;
+    }
+
+    process_gbm_device = gbm_create_device(drm_fd);
+    if (!process_gbm_device)
+    {
+        ERR("Failed to create gbm device (errno=%d)\n", errno);
+        close(drm_fd);
+    }
+}
+
+/**********************************************************************
+ *          wayland_gbm_get_render_dev
+ */
+dev_t wayland_gbm_get_render_dev()
+{
+    int dev_fd = gbm_device_get_fd(process_gbm_device);
+    struct stat dev_stat;
+
+    if (dev_fd >= 0 && !fstat(dev_fd, &dev_stat))
+        return dev_stat.st_rdev;
+
+    return 0;
+}
+
+BOOL wayland_gbm_init(void)
+{
+    pthread_once(&init_once, wayland_gbm_init_once);
+
+    return process_gbm_device != NULL;
+}
diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
new file mode 100644
index 00000000000..8397b6b39d7
--- /dev/null
+++ b/dlls/winewayland.drv/gdi.c
@@ -0,0 +1,233 @@
+/*
+ * Wayland gdi functions
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <stdlib.h>
+#include <sys/mman.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+typedef struct
+{
+    struct gdi_physdev dev;
+} WAYLAND_PDEVICE;
+
+static inline WAYLAND_PDEVICE *get_wayland_dev(PHYSDEV dev)
+{
+    return (WAYLAND_PDEVICE *)dev;
+}
+
+static WAYLAND_PDEVICE *create_wayland_physdev(void)
+{
+    WAYLAND_PDEVICE *physDev;
+
+    physDev = calloc(1, sizeof(*physDev));
+
+    return physDev;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateDC
+ */
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateCompatibleDC
+ */
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_DeleteDC
+ */
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
+{
+    WAYLAND_PDEVICE *physDev = get_wayland_dev(dev);
+
+    free(physDev);
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_PutImage
+ *
+ * This is a fallback implementation for when the dibdrv cannot perform
+ * this task, typically because the destination belongs to a different
+ * process. In such a case the implementation utilizes the remote surface
+ * infrastructure to commit content to the remote HWND.
+ *
+ * The implementation is very limited, supporting only simple full copies,
+ * but that's enough for some typical cross-process cases, notably software
+ * rendered content in Chrome/CEF.
+ */
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop)
+{
+    HWND hwnd;
+    struct wayland_native_buffer native;
+    struct wayland_remote_surface_proxy *remote = NULL;
+    size_t shm_size;
+    void *shm_data;
+    DWORD ret = ERROR_SUCCESS;
+
+    hwnd = NtUserWindowFromDC(dev->hdc);
+
+    TRACE("hwnd=%p rop=%#x biBitCount=%d compr=%d size=%dx%d "
+          "src=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "dst=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "clip=%p\n",
+          hwnd, rop, info->bmiHeader.biBitCount,
+          info->bmiHeader.biCompression,
+          info->bmiHeader.biWidth, info->bmiHeader.biHeight,
+          src->log_x, src->log_y, src->log_width, src->log_height,
+          src->x, src->y, src->width, src->height,
+          wine_dbgstr_rect(&src->visrect),
+          dst->log_x, dst->log_y, dst->log_width, dst->log_height,
+          dst->x, dst->y, dst->width, dst->height,
+          wine_dbgstr_rect(&dst->visrect), clip);
+
+    if (info->bmiHeader.biPlanes != 1)
+    {
+        TRACE("Multiplanar buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biBitCount != 32)
+    {
+        TRACE("Non 32-bit buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biCompression != BI_RGB)
+    {
+        TRACE("Non RGB not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biHeight > 0)
+    {
+        TRACE("Bottom-up buffers not supported\n");
+        goto update_format;
+    }
+
+    if (!bits) return ERROR_SUCCESS;  /* just querying the format */
+
+    if (!hwnd)
+    {
+        TRACE("Invalid hwnd=%p\n", hwnd);
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (clip)
+    {
+        TRACE("Clipping not supported\n");
+        return ERROR_CLIPPING_NOT_SUPPORTED;
+    }
+
+    if ((src->width != dst->width) || (src->height != dst->height))
+    {
+        TRACE("Image stretching is not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if ((src->width != info->bmiHeader.biWidth) ||
+        (src->height != -info->bmiHeader.biHeight))
+    {
+        TRACE("Partial blits are not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (rop != SRCCOPY)
+    {
+        TRACE("Raster operations other than SRCCOPY are not supported\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (!wayland_native_buffer_init_shm(&native, src->width, src->height, 
+                                        WL_SHM_FORMAT_ARGB8888))
+    {
+        TRACE("Failed to create native shm buffer %dx%d\n", src->width, src->height);
+        return ERROR_OUTOFMEMORY;
+    }
+
+    shm_size = native.strides[0] * native.height;
+    shm_data = mmap(NULL, shm_size, PROT_WRITE, MAP_SHARED, native.fds[0], 0);
+    if (shm_data == MAP_FAILED)
+    {
+        TRACE("Failed to mmap shm buffer size=%zu\n", shm_size);
+        ret = ERROR_OUTOFMEMORY;
+        goto out;
+    }
+    memcpy(shm_data, bits->ptr, shm_size);
+    munmap(shm_data, shm_size);
+
+    remote = wayland_remote_surface_proxy_create(hwnd,
+                                                 WAYLAND_REMOTE_SURFACE_TYPE_NORMAL);
+    if (!remote)
+    {
+        TRACE("Failed to create remote surface proxy\n");
+        ret =  ERROR_OUTOFMEMORY;
+        goto out;
+    }
+
+    wayland_remote_surface_proxy_commit(remote, &native,
+                                        WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+                                        WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+                                        NULL, NULL);
+
+    wayland_remote_surface_proxy_destroy(remote);
+
+out:
+    wayland_native_buffer_deinit(&native);
+    return ret;
+
+update_format:
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    if (info->bmiHeader.biHeight > 0) info->bmiHeader.biHeight = -info->bmiHeader.biHeight;
+    return ERROR_BAD_FORMAT;
+}
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
new file mode 100644
index 00000000000..c35c49c5f88
--- /dev/null
+++ b/dlls/winewayland.drv/opengl.c
@@ -0,0 +1,2011 @@
+/*
+ * Wayland OpenGL functions
+ *
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2005 Alex Woods
+ * Copyright 2005 Raphael Junqueira
+ * Copyright 2006-2009 Roderick Colenbrander
+ * Copyright 2006 Tomas Carnecky
+ * Copyright 2013 Matteo Bruni
+ * Copyright 2012, 2013, 2014, 2017 Alexandre Julliard
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+#if defined(SONAME_LIBEGL) && (defined(SONAME_LIBGL) || defined(SONAME_LIBGLESV2))
+
+#define GLAPIENTRY /* nothing */
+#include "wine/wgl.h"
+#undef GLAPIENTRY
+#include "wine/wgl_driver.h"
+
+#include "ntuser.h"
+#include "winternl.h"
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <assert.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+
+struct wgl_pixel_format
+{
+    EGLConfig config;
+    EGLint native_visual_id;
+};
+
+struct wayland_gl_drawable
+{
+    struct wl_list  link;
+    HWND            hwnd;
+    int             format;
+    int             width;
+    int             height;
+    struct wayland_surface *wayland_surface;
+    struct gbm_surface *gbm_surface;
+    EGLSurface      surface;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_list  buffer_list;
+    int             swap_interval;
+    struct wl_callback *throttle_callback;
+    struct wayland_remote_surface_proxy *remote_surface_proxy;
+    HANDLE remote_throttle_event;
+};
+
+struct wayland_gl_buffer
+{
+    struct wl_list  link;
+    struct wayland_gl_drawable *gl;
+    struct gbm_bo *gbm_bo;
+    struct gbm_surface *gbm_surface;
+    struct wayland_native_buffer native_buffer;
+    struct wayland_dmabuf_buffer *dmabuf_buffer;
+    HANDLE remote_buffer_released_event;
+};
+
+struct wgl_context
+{
+    struct wl_list link;
+    EGLConfig  config;
+    EGLContext context;
+    HWND       draw_hwnd;
+    HWND       read_hwnd;
+    BOOL       refresh;
+    BOOL       has_been_current;
+    BOOL       sharing;
+    int        *attribs;
+    BOOL       is_draw_buffer_front;
+};
+
+static void *egl_handle;
+static void *opengl_handle;
+static EGLDisplay egl_display;
+static EGLint egl_version[2];
+static struct opengl_funcs egl_funcs;
+static char wgl_extensions[4096];
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
+static BOOL has_khr_create_context;
+static BOOL has_gl_colorspace;
+
+static struct wayland_mutex gl_object_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": gl_object_mutex"
+};
+
+static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+static struct wl_list gl_contexts = { &gl_contexts, &gl_contexts };
+
+#define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglBindAPI);
+DECL_FUNCPTR(eglCreateContext);
+DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroyContext);
+DECL_FUNCPTR(eglDestroySurface);
+DECL_FUNCPTR(eglGetConfigAttrib);
+DECL_FUNCPTR(eglGetConfigs);
+DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglGetProcAddress);
+DECL_FUNCPTR(eglInitialize);
+DECL_FUNCPTR(eglMakeCurrent);
+DECL_FUNCPTR(eglQueryString);
+DECL_FUNCPTR(eglSwapBuffers);
+#undef DECL_FUNCPTR
+
+static void (*p_glFinish)(void);
+static void (*p_glFlush)(void);
+static void (*p_glDrawBuffer)(GLenum);
+
+static inline BOOL is_onscreen_pixel_format(int format)
+{
+    return format > 0 && format <= nb_onscreen_formats;
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int format)
+{
+    struct wayland_gl_drawable *gl;
+    struct wayland_surface *wayland_surface;
+
+    gl = calloc(1, sizeof(*gl));
+    if (!gl) return NULL;
+
+    wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p wayland_surface=%p\n", hwnd, wayland_surface);
+
+    if (wayland_surface)
+    {
+        BOOL ref_gl = wayland_surface_create_or_ref_glvk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_gl) goto err;
+    }
+    else
+    {
+        gl->remote_surface_proxy =
+            wayland_remote_surface_proxy_create(hwnd, WAYLAND_REMOTE_SURFACE_TYPE_GLVK);
+        if (!gl->remote_surface_proxy) goto err;
+    }
+
+    gl->hwnd = hwnd;
+    gl->format = format;
+    gl->wayland_surface = wayland_surface;
+    if (gl->wayland_surface)
+    {
+        gl->wl_event_queue = wl_display_create_queue(wayland_surface->wayland->wl_display);
+        if (!gl->wl_event_queue) goto err;
+    }
+    wl_list_init(&gl->buffer_list);
+    gl->swap_interval = 1;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_insert(&gl_drawables, &gl->link);
+    return gl;
+
+err:
+    if (gl)
+    {
+        if (gl->wayland_surface) wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
+        if (gl->remote_surface_proxy)
+            wayland_remote_surface_proxy_destroy(gl->remote_surface_proxy);
+        free(gl);
+    }
+    return NULL;
+}
+
+static void wayland_gl_buffer_destroy(struct wayland_gl_buffer *gl_buffer)
+{
+    TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    wl_list_remove(&gl_buffer->link);
+    wayland_native_buffer_deinit(&gl_buffer->native_buffer);
+    if (gl_buffer->dmabuf_buffer)
+        wayland_dmabuf_buffer_destroy(gl_buffer->dmabuf_buffer);
+    if (gl_buffer->remote_buffer_released_event)
+        NtClose(gl_buffer->remote_buffer_released_event);
+    gbm_bo_set_user_data(gl_buffer->gbm_bo, NULL, NULL);
+    free(gl_buffer);
+}
+
+static void wayland_gl_buffer_release(struct wayland_gl_buffer *gl_buffer)
+{
+    TRACE("gl_buffer=%p bo=%p\n", gl_buffer, gl_buffer->gbm_bo);
+    if (gl_buffer->remote_buffer_released_event)
+    {
+        NtClose(gl_buffer->remote_buffer_released_event);
+        gl_buffer->remote_buffer_released_event = 0;
+    }
+    gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
+}
+
+static void wayland_gl_drawable_clear_buffers(struct wayland_gl_drawable *gl)
+{
+    struct wayland_gl_buffer *gl_buffer, *tmp;
+
+    wl_list_for_each_safe(gl_buffer, tmp, &gl->buffer_list, link)
+        wayland_gl_buffer_destroy(gl_buffer);
+}
+
+void wayland_destroy_gl_drawable(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd != hwnd) continue;
+        wl_list_remove(&gl->link);
+        wayland_gl_drawable_clear_buffers(gl);
+        if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+        if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->throttle_callback) wl_callback_destroy(gl->throttle_callback);
+        if (gl->remote_surface_proxy)
+            wayland_remote_surface_proxy_destroy(gl->remote_surface_proxy);
+        if (gl->remote_throttle_event) NtClose(gl->remote_throttle_event);
+        if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
+        free(gl);
+        break;
+    }
+    wayland_mutex_unlock(&gl_object_mutex);
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_get(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    if (!hwnd) return NULL;
+
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd == hwnd) return gl;
+    }
+    wayland_mutex_unlock(&gl_object_mutex);
+    return NULL;
+}
+
+static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
+{
+    if (gl) wayland_mutex_unlock(&gl_object_mutex);
+}
+
+static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HWND read_hwnd)
+{
+    BOOL ret;
+    struct wayland_gl_drawable *draw_gl = NULL, *read_gl = NULL;
+
+    draw_gl = wayland_gl_drawable_get(draw_hwnd);
+    read_gl = wayland_gl_drawable_get(read_hwnd);
+
+    TRACE("%p/%p context %p surface %p/%p\n",
+          draw_hwnd, read_hwnd, ctx->context,
+          draw_gl ? draw_gl->surface : NULL,
+          read_gl ? read_gl->surface : NULL);
+
+    ret = p_eglMakeCurrent(egl_display,
+                           draw_gl ? draw_gl->surface : NULL,
+                           read_gl ? read_gl->surface : NULL,
+                           ctx->context);
+    if (ret)
+    {
+        ctx->draw_hwnd = draw_hwnd;
+        ctx->read_hwnd = read_hwnd;
+        InterlockedExchange(&ctx->refresh, FALSE);
+        ctx->has_been_current = TRUE;
+        NtCurrentTeb()->glContext = ctx;
+    }
+
+    wayland_gl_drawable_release(read_gl);
+    wayland_gl_drawable_release(draw_gl);
+
+    return ret;
+}
+
+static struct gbm_surface *wayland_gl_create_gbm_surface(struct wayland_surface *glvk,
+                                                         int width, int height,
+                                                         uint32_t drm_format)
+{
+    struct wayland_dmabuf_format_info format_info;
+    dev_t render_dev;
+    struct wayland_dmabuf_surface_feedback *surface_feedback = glvk ? glvk->surface_feedback : NULL;
+    struct gbm_surface *gbm_surface = NULL;
+
+    if (!(render_dev = wayland_gbm_get_render_dev()))
+    {
+        ERR("Failed to get device's dev_t from GBM device.\n");
+        goto out;
+    }
+
+    if (surface_feedback)
+    {
+        wayland_dmabuf_surface_feedback_lock(glvk->surface_feedback);
+        if (surface_feedback->feedback)
+        {
+            if (wayland_dmabuf_feedback_get_format_info(surface_feedback->feedback, drm_format,
+                                                        render_dev, &format_info))
+            {
+                TRACE("Using per-surface feedback format/modifier information\n");
+                gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                         format_info.count_modifiers,
+                                                         format_info.modifiers,
+                                                         format_info.scanoutable);
+            }
+        }
+        else
+        {
+            /*
+             * Compositor supports feedback but we haven't processed surface
+             * feedback events yet, so set surface_feedback to NULL to enter
+             * the default format info code path below.
+             */
+            surface_feedback = NULL;
+        }
+
+        wayland_dmabuf_surface_feedback_unlock(glvk->surface_feedback);
+    }
+
+    if (!surface_feedback)
+    {
+        struct wayland_dmabuf *dmabuf = &wayland_process_acquire()->dmabuf;
+
+        if (wayland_dmabuf_get_default_format_info(dmabuf, drm_format, render_dev, &format_info))
+        {
+            TRACE("Using default format/modifier information\n");
+            gbm_surface = wayland_gbm_create_surface(drm_format, width, height,
+                                                     format_info.count_modifiers,
+                                                     format_info.modifiers,
+                                                     format_info.scanoutable);
+        }
+
+        wayland_process_release();
+    }
+
+out:
+    return gbm_surface;
+}
+
+static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
+{
+    RECT client_rect;
+
+    TRACE("hwnd=%p\n", gl->hwnd);
+
+    wayland_gl_drawable_clear_buffers(gl);
+    if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+    if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
+
+    NtUserGetClientRect(gl->hwnd, &client_rect);
+    gl->width = client_rect.right;
+    gl->height = client_rect.bottom;
+
+    gl->gbm_surface =
+        wayland_gl_create_gbm_surface(gl->wayland_surface ? gl->wayland_surface->glvk : NULL,
+                                      gl->width, gl->height,
+                                      pixel_formats[gl->format - 1].native_visual_id);
+    if (!gl->gbm_surface)
+        ERR("Failed to create GBM surface\n");
+
+    /* First try to create a surface with an SRGB colorspace, if supported. */
+    if (has_gl_colorspace)
+    {
+        EGLint attribs[] = { EGL_GL_COLORSPACE, EGL_GL_COLORSPACE_SRGB, EGL_NONE };
+        gl->surface = p_eglCreateWindowSurface(egl_display,
+                                               pixel_formats[gl->format - 1].config,
+                                               (EGLNativeWindowType) gl->gbm_surface,
+                                               attribs);
+        if (!gl->surface)
+        {
+            TRACE("Failed to create EGL surface with SRGB colorspace, "
+                  "trying with default colorspace\n");
+        }
+    }
+
+    /* Try to create a surface with the default colorspace. */
+    if (!gl->surface)
+    {
+        gl->surface = p_eglCreateWindowSurface(egl_display,
+                                               pixel_formats[gl->format - 1].config,
+                                               (EGLNativeWindowType) gl->gbm_surface,
+                                               NULL);
+        if (!gl->surface)
+            ERR("Failed to create EGL surface\n");
+    }
+
+    if (gl->surface)
+    {
+        struct wgl_context *ctx;
+
+        wl_list_for_each(ctx, &gl_contexts, link)
+        {
+            if (ctx->draw_hwnd != gl->hwnd && ctx->read_hwnd != gl->hwnd) continue;
+            TRACE("hwnd %p refreshing %p %scurrent\n",
+                  gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
+            if (NtCurrentTeb()->glContext == ctx)
+                wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+            else
+                InterlockedExchange(&ctx->refresh, TRUE);
+        }
+    }
+
+    TRACE("hwnd=%p gbm_surface=%p egl_surface=%p\n",
+          gl->hwnd, gl->gbm_surface, gl->surface);
+
+    NtUserRedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+}
+
+static BOOL wayland_gl_surface_feedback_has_update(struct wayland_gl_drawable *gl)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback =
+        gl->wayland_surface ? gl->wayland_surface->glvk->surface_feedback : NULL;
+    BOOL ret = FALSE;
+
+    if (surface_feedback)
+    {
+        wayland_dmabuf_surface_feedback_lock(surface_feedback);
+        ret = surface_feedback->surface_needs_update;
+        surface_feedback->surface_needs_update = FALSE;
+        wayland_dmabuf_surface_feedback_unlock(surface_feedback);
+    }
+
+    TRACE("hwnd=%p => %d\n", gl->hwnd, ret);
+
+    return ret;
+}
+
+static BOOL wayland_gl_drawable_needs_resize(struct wayland_gl_drawable *gl)
+{
+    RECT client_rect;
+    BOOL ret;
+
+    NtUserGetClientRect(gl->hwnd, &client_rect);
+
+    ret = (client_rect.right > 0 && client_rect.bottom > 0 &&
+           (gl->width != client_rect.right || gl->height != client_rect.bottom));
+
+    TRACE("hwnd=%p client=%dx%d gl=%dx%d => %d\n",
+          gl->hwnd, client_rect.right, client_rect.bottom,
+          gl->width, gl->height, ret);
+
+    return ret;
+}
+
+static BOOL wayland_gl_drawable_needs_update(struct wayland_gl_drawable *gl)
+{
+    return wayland_gl_drawable_needs_resize(gl) || wayland_gl_surface_feedback_has_update(gl);
+}
+
+static void gbm_bo_destroy_callback(struct gbm_bo *bo, void *user_data)
+{
+    struct wayland_gl_buffer *gl_buffer = (struct wayland_gl_buffer *) user_data;
+    wayland_gl_buffer_destroy(gl_buffer);
+}
+
+static void dmabuf_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_gl_buffer *gl_buffer = (struct wayland_gl_buffer *) data;
+
+    TRACE("bo=%p\n", gl_buffer->gbm_bo);
+    wayland_gl_buffer_release(gl_buffer);
+}
+
+static const struct wl_buffer_listener dmabuf_buffer_listener = {
+    dmabuf_buffer_release
+};
+
+static struct wayland_gl_buffer *wayland_gl_drawable_track_buffer(struct wayland_gl_drawable *gl,
+                                                                  struct gbm_bo *bo)
+{
+    struct wayland_gl_buffer *gl_buffer =
+        (struct wayland_gl_buffer *) gbm_bo_get_user_data(bo);
+
+    if (!gl_buffer)
+    {
+        gl_buffer = calloc(1, sizeof(*gl_buffer));
+        if (!gl_buffer) goto err;
+
+        wl_list_init(&gl_buffer->link);
+        gl_buffer->gbm_bo = bo;
+        gl_buffer->gbm_surface = gl->gbm_surface;
+        if (!wayland_native_buffer_init_gbm(&gl_buffer->native_buffer, bo)) goto err;
+
+        if (gl->wayland_surface)
+        {
+            gl_buffer->dmabuf_buffer =
+                wayland_dmabuf_buffer_create_from_native(gl->wayland_surface->wayland,
+                                                         &gl_buffer->native_buffer);
+            wayland_native_buffer_deinit(&gl_buffer->native_buffer);
+            if (!gl_buffer->dmabuf_buffer) goto err;
+
+            wl_proxy_set_queue((struct wl_proxy *) gl_buffer->dmabuf_buffer->wl_buffer,
+                               gl->wl_event_queue);
+            wl_buffer_add_listener(gl_buffer->dmabuf_buffer->wl_buffer,
+                                   &dmabuf_buffer_listener, gl_buffer);
+        }
+
+        gbm_bo_set_user_data(bo, gl_buffer, gbm_bo_destroy_callback);
+        wl_list_insert(&gl->buffer_list, &gl_buffer->link);
+    }
+
+    return gl_buffer;
+
+err:
+    if (gl_buffer) wayland_gl_buffer_destroy(gl_buffer);
+    return NULL;
+}
+
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_gl_drawable *draw_gl = data;
+
+    TRACE("hwnd=%p\n", draw_gl->hwnd);
+    draw_gl->throttle_callback = NULL;
+    wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
+static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
+                                       struct wayland_gl_buffer *gl_buffer)
+{
+    BOOL committed = FALSE;
+
+    if (gl->remote_surface_proxy)
+    {
+        enum wayland_remote_buffer_commit buffer_commit =
+            gl->swap_interval > 0 ? WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED :
+                                    WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL;
+
+        if (!wayland_remote_surface_proxy_commit(gl->remote_surface_proxy,
+                                                 &gl_buffer->native_buffer,
+                                                 WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+                                                 buffer_commit,
+                                                 &gl_buffer->remote_buffer_released_event,
+                                                 &gl->remote_throttle_event))
+        {
+            gl_buffer->remote_buffer_released_event = 0;
+            gl->remote_throttle_event = 0;
+            return FALSE;
+        }
+
+        return TRUE;
+    }
+
+    wayland_mutex_lock(&gl->wayland_surface->mutex);
+    if (gl->wayland_surface->drawing_allowed)
+    {
+        struct wl_surface *gl_wl_surface = gl->wayland_surface->glvk->wl_surface;
+        wayland_surface_ensure_mapped(gl->wayland_surface);
+        wl_surface_attach(gl_wl_surface, gl_buffer->dmabuf_buffer->wl_buffer, 0, 0);
+        wl_surface_damage_buffer(gl_wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (gl->swap_interval > 0)
+        {
+            gl->throttle_callback = wl_surface_frame(gl_wl_surface);
+            wl_proxy_set_queue((struct wl_proxy *) gl->throttle_callback,
+                                gl->wl_event_queue);
+            wl_callback_add_listener(gl->throttle_callback, &throttle_listener, gl);
+        }
+        wl_surface_commit(gl_wl_surface);
+        committed = TRUE;
+    }
+    wayland_mutex_unlock(&gl->wayland_surface->mutex);
+
+    return committed;
+}
+
+/* Convert timeout in ms to the timeout format used by ntdll which is:
+ * 100ns units, negative for monotonic time. */
+static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
+{
+    if (timeout_ms == -1) return NULL;
+    time->QuadPart = (ULONGLONG)timeout_ms * -10000;
+    return time;
+}
+
+static DWORD wayland_gl_drawable_wait_remote_throttle(struct wayland_gl_drawable *gl,
+                                                      int timeout_ms)
+{
+    DWORD ret;
+    LARGE_INTEGER timeout;
+
+    TRACE("gl->remote_throttle_event=%p timeout_ms=%d\n", gl->remote_throttle_event, timeout_ms);
+    if (!wayland_remote_surface_proxy_dispatch_events(gl->remote_surface_proxy))
+    {
+        ERR("Failed to dispatch remote events\n");
+        return WAIT_FAILED;
+    }
+
+    ret = NtWaitForSingleObject(gl->remote_throttle_event, FALSE,
+                                get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_OBJECT_0)
+    {
+        NtClose(gl->remote_throttle_event);
+        gl->remote_throttle_event = 0;
+    }
+
+    TRACE("=> ret=%d\n", ret);
+    return ret;
+}
+
+static DWORD get_tick_count_since(DWORD start)
+{
+    DWORD now = NtGetTickCount();
+    /* Handle tick count wrap around to zero. */
+    if (now < start)
+        return 0xffffffff - start + now + 1;
+    else
+        return now - start;
+}
+
+static void wayland_gl_drawable_throttle(struct wayland_gl_drawable *gl)
+{
+    static const DWORD timeout = 100;
+    DWORD start, elapsed;
+
+    if (gl->swap_interval == 0) goto out;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    TRACE("throttle_callback=%p throttle_event=%p\n",
+          gl->throttle_callback, gl->remote_throttle_event);
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (elapsed < timeout &&
+           ((gl->throttle_callback &&
+             wayland_dispatch_queue(gl->wl_event_queue, timeout - elapsed) != -1) ||
+            (gl->remote_throttle_event &&
+             wayland_gl_drawable_wait_remote_throttle(gl, 10) != WAIT_FAILED)))
+    {
+        elapsed = get_tick_count_since(start);
+    }
+
+    TRACE("throttle_callback=%p throttle_event=%p => elapsed=%d\n",
+          gl->throttle_callback, gl->remote_throttle_event,
+          elapsed);
+
+out:
+    if (gl->throttle_callback)
+    {
+        wl_callback_destroy(gl->throttle_callback);
+        gl->throttle_callback = NULL;
+    }
+    if (gl->remote_throttle_event)
+    {
+        NtClose(gl->remote_throttle_event);
+        gl->remote_throttle_event = 0;
+    }
+}
+
+static DWORD wayland_gl_drawable_wait_remote(struct wayland_gl_drawable *gl,
+                                             int timeout_ms)
+{
+    struct wayland_gl_buffer *gl_buffer;
+    HANDLE handles[8];
+    struct wayland_gl_buffer *gl_buffers[8];
+    int count = 0;
+    LARGE_INTEGER timeout;
+    DWORD ret;
+
+    if (!wayland_remote_surface_proxy_dispatch_events(gl->remote_surface_proxy))
+        return WAIT_FAILED;
+
+    wl_list_for_each(gl_buffer, &gl->buffer_list, link)
+    {
+        if (!gl_buffer->remote_buffer_released_event) continue;
+        handles[count] = gl_buffer->remote_buffer_released_event;
+        gl_buffers[count] = gl_buffer;
+        count++;
+    }
+
+    TRACE("count=%d handles=%p,%p,%p,%p\n",
+         count, handles[0], handles[1], handles[2], handles[3]);
+    ret = NtWaitForMultipleObjects(count, handles, TRUE, FALSE,
+                                   get_nt_timeout(&timeout, timeout_ms));
+    TRACE("count=%d => ret=%d\n", count, ret);
+    if (ret < WAIT_OBJECT_0 + count)
+        wayland_gl_buffer_release(gl_buffers[ret - WAIT_OBJECT_0]);
+
+    return ret;
+}
+
+static BOOL wgl_context_refresh(struct wgl_context *ctx)
+{
+    BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
+
+    if (ret)
+    {
+        TRACE("refreshing context %p hwnd %p/%p\n",
+              ctx->context, ctx->draw_hwnd, ctx->read_hwnd);
+        wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        NtUserRedrawWindow(ctx->draw_hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+    }
+    return ret;
+}
+
+static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
+{
+    struct wayland_gl_drawable *gl;
+    HWND hwnd = NtUserWindowFromDC(hdc);
+    int prev = 0;
+    BOOL needs_update = FALSE;
+
+    if (!hwnd || hwnd == NtUserGetDesktopWindow())
+    {
+        WARN("not a proper window DC %p/%p\n", hdc, hwnd);
+        return FALSE;
+    }
+    if (!is_onscreen_pixel_format(format))
+    {
+        WARN("Invalid format %d\n", format);
+        return FALSE;
+    }
+    TRACE("%p/%p format %d\n", hdc, hwnd, format);
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        prev = gl->format;
+        /* If we are changing formats, destroy any existing EGL surface so that
+         * it can be recreated by wayland_gl_drawable_update. */
+        if (allow_change && gl->format != format)
+        {
+            gl->format = format;
+            needs_update = TRUE;
+        }
+    }
+    else
+    {
+        gl = wayland_gl_drawable_create(hwnd, format);
+        needs_update = TRUE;
+    }
+
+    if (gl && needs_update) wayland_gl_drawable_update(gl);
+
+    wayland_gl_drawable_release(gl);
+
+    if (prev && prev != format && !allow_change) return FALSE;
+    if (gl->remote_surface_proxy || NtUserSetWindowPixelFormat(hwnd, format))
+        return TRUE;
+
+    wayland_destroy_gl_drawable(hwnd);
+    return FALSE;
+}
+
+struct egl_attribs
+{
+    EGLint *data;
+    int count;
+};
+
+static void egl_attribs_init(struct egl_attribs *attribs)
+{
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static void egl_attribs_add(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    EGLint *new_data = realloc(attribs->data,
+                               sizeof(*attribs->data) * (attribs->count + 2));
+    if (!new_data)
+    {
+        ERR("Could not allocate memory for EGL attributes!\n");
+        return;
+    }
+
+    attribs->data = new_data;
+    attribs->data[attribs->count] = name;
+    attribs->data[attribs->count + 1] = value;
+    attribs->count += 2;
+}
+
+
+static void egl_attribs_add_15_khr(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    BOOL has_egl_15 = egl_version[0] == 1 && egl_version[1] >= 5;
+
+    if (!has_egl_15 && !has_khr_create_context)
+    {
+        WARN("Ignoring EGL context attrib %#x not supported by EGL %d.%d\n",
+             name, egl_version[0], egl_version[1]);
+        return;
+    }
+
+    if (name == EGL_CONTEXT_FLAGS_KHR && has_egl_15)
+    {
+        egl_attribs_add(attribs, EGL_CONTEXT_OPENGL_DEBUG,
+                        (value & WGL_CONTEXT_DEBUG_BIT_ARB) ?
+                             EGL_TRUE : EGL_FALSE);
+        egl_attribs_add(attribs,
+                        EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE,
+                        (value & WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB) ?
+                            EGL_TRUE : EGL_FALSE);
+    }
+    else
+    {
+        egl_attribs_add(attribs, name, value);
+    }
+}
+
+static EGLint *egl_attribs_steal_finished_data(struct egl_attribs *attribs)
+{
+    EGLint *data = NULL;
+
+    if (attribs->data)
+    {
+        data = realloc(attribs->data,
+                       sizeof(*attribs->data) * (attribs->count + 1));
+        if (!data)
+        {
+            ERR("Could not allocate memory for EGL attributes!\n");
+        }
+        else
+        {
+            data[attribs->count] = EGL_NONE;
+            attribs->data = NULL;
+            attribs->count = 0;
+        }
+    }
+
+    return data;
+}
+
+static void egl_attribs_deinit(struct egl_attribs *attribs)
+{
+    free(attribs->data);
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
+                                          struct egl_attribs *attribs)
+{
+    struct wayland_gl_drawable *gl;
+    struct wgl_context *ctx;
+
+    if (!(gl = wayland_gl_drawable_get(NtUserWindowFromDC(hdc)))) return NULL;
+
+    ctx = malloc(sizeof(*ctx));
+    if (!ctx)
+    {
+        ERR("Failed to allocate memory for GL context\n");
+        goto out;
+    }
+
+    ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->attribs = attribs ? egl_attribs_steal_finished_data(attribs) : NULL;
+    ctx->context = p_eglCreateContext(egl_display, ctx->config,
+                                      share ? share->context : EGL_NO_CONTEXT,
+                                      ctx->attribs);
+    ctx->draw_hwnd = 0;
+    ctx->read_hwnd = 0;
+    ctx->refresh = FALSE;
+    ctx->has_been_current = FALSE;
+    ctx->sharing = FALSE;
+    ctx->is_draw_buffer_front = FALSE;
+
+    /* The gl_object_mutex, which is locked when we get the gl_drawable,
+     * also guards access to gl_contexts, so it's safe to add the entry here. */
+    wl_list_insert(&gl_contexts, &ctx->link);
+
+out:
+    wayland_gl_drawable_release(gl);
+
+    TRACE("ctx=%p hdc=%p fmt=%d egl_ctx=%p\n",
+          ctx, hdc, gl->format, ctx ? ctx->context : NULL);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglCopyContext
+ */
+static BOOL WINAPI wayland_wglCopyContext(struct wgl_context *src,
+                                          struct wgl_context *dst, UINT mask)
+{
+    FIXME("%p -> %p mask %#x unsupported\n", src, dst, mask);
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContext
+ */
+static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
+{
+    TRACE("hdc=%p\n", hdc);
+
+    p_eglBindAPI(EGL_OPENGL_API);
+
+    return create_context(hdc, NULL, NULL);
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContextAttribsARB
+ */
+static struct wgl_context *wayland_wglCreateContextAttribsARB(HDC hdc,
+                                                              struct wgl_context *share,
+                                                              const int *attribs)
+{
+    struct egl_attribs egl_attribs = {0};
+    EGLenum api_type = EGL_OPENGL_API;
+    EGLenum profile_mask;
+    struct wgl_context *ctx;
+
+    egl_attribs_init(&egl_attribs);
+
+    TRACE("hdc=%p share=%p attribs=%p\n", hdc, share, attribs);
+
+    while (attribs && *attribs)
+    {
+        TRACE("%#x %#x\n", attribs[0], attribs[1]);
+        switch (*attribs)
+        {
+        case WGL_CONTEXT_PROFILE_MASK_ARB:
+            profile_mask = 0;
+            if (attribs[1] & WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+                api_type = EGL_OPENGL_ES_API;
+            if (attribs[1] & WGL_CONTEXT_CORE_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT;
+            if (attribs[1] & WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT;
+            /* If the WGL profile mask doesn't have ES2 as the only set bit,
+             * pass the mask to EGL. Note that this will also pass empty
+             * WGL masks, in order to elicit the respective EGL error. */
+            if (attribs[1] != WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+            {
+                egl_attribs_add_15_khr(&egl_attribs,
+                                       EGL_CONTEXT_OPENGL_PROFILE_MASK, profile_mask);
+            }
+            break;
+        case WGL_CONTEXT_MAJOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MAJOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_MINOR_VERSION_ARB:
+            egl_attribs_add_15_khr(&egl_attribs, EGL_CONTEXT_MINOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_FLAGS_ARB:
+            egl_attribs_add_15_khr(&egl_attribs, EGL_CONTEXT_FLAGS_KHR, attribs[1]);
+            break;
+        default:
+            FIXME("Unhandled attributes: %#x %#x\n", attribs[0], attribs[1]);
+        }
+        attribs += 2;
+    }
+
+    p_eglBindAPI(api_type);
+
+    ctx = create_context(hdc, share, &egl_attribs);
+
+    egl_attribs_deinit(&egl_attribs);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglDeleteContext
+ */
+static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
+{
+    wayland_mutex_lock(&gl_object_mutex);
+    wl_list_remove(&ctx->link);
+    wayland_mutex_unlock(&gl_object_mutex);
+    p_eglDestroyContext(egl_display, ctx->context);
+    free(ctx->attribs);
+    free(ctx);
+    return TRUE;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeContextCurrentARB
+ */
+static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
+                                             struct wgl_context *ctx)
+{
+    BOOL ret = FALSE;
+
+    TRACE("draw_hdc=%p read_hdc=%p ctx=%p\n", draw_hdc, read_hdc, ctx);
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    ret = wgl_context_make_current(ctx, NtUserWindowFromDC(draw_hdc), NtUserWindowFromDC(read_hdc));
+    if (!ret) RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
+
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeCurrent
+ */
+static BOOL WINAPI wayland_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+{
+    return wayland_wglMakeContextCurrentARB(hdc, hdc, ctx);
+}
+
+/***********************************************************************
+ *		wayland_wglDescribePixelFormat
+ */
+static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
+                                                 PIXELFORMATDESCRIPTOR *pfd)
+{
+    EGLint val;
+    EGLConfig config;
+
+    if (!pfd) return nb_onscreen_formats;
+    if (!is_onscreen_pixel_format(fmt)) return 0;
+    if (size < sizeof(*pfd)) return 0;
+    config = pixel_formats[fmt - 1].config;
+
+    memset(pfd, 0, sizeof(*pfd));
+    pfd->nSize = sizeof(*pfd);
+    pfd->nVersion = 1;
+    pfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
+                   PFD_SUPPORT_COMPOSITION;
+    pfd->iPixelType = PFD_TYPE_RGBA;
+    pfd->iLayerType = PFD_MAIN_PLANE;
+
+    p_eglGetConfigAttrib(egl_display, config, EGL_BUFFER_SIZE, &val);
+    pfd->cColorBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_RED_SIZE, &val);
+    pfd->cRedBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_GREEN_SIZE, &val);
+    pfd->cGreenBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_BLUE_SIZE, &val);
+    pfd->cBlueBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_ALPHA_SIZE, &val);
+    pfd->cAlphaBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_DEPTH_SIZE, &val);
+    pfd->cDepthBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_STENCIL_SIZE, &val);
+    pfd->cStencilBits = val;
+
+    pfd->cAlphaShift = 0;
+    pfd->cBlueShift = pfd->cAlphaShift + pfd->cAlphaBits;
+    pfd->cGreenShift = pfd->cBlueShift + pfd->cBlueBits;
+    pfd->cRedShift = pfd->cGreenShift + pfd->cGreenBits;
+
+    TRACE("fmt %u color %u %u/%u/%u/%u depth %u stencil %u\n",
+           fmt, pfd->cColorBits, pfd->cRedBits, pfd->cGreenBits, pfd->cBlueBits,
+           pfd->cAlphaBits, pfd->cDepthBits, pfd->cStencilBits);
+    return nb_onscreen_formats;
+}
+
+/***********************************************************************
+ *		wayland_wglGetPixelFormat
+ */
+static int WINAPI wayland_wglGetPixelFormat(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    int ret = 0;
+
+    if ((gl = wayland_gl_drawable_get(NtUserWindowFromDC(hdc))))
+    {
+        ret = gl->format;
+        /* offscreen formats can't be used with traditional WGL calls */
+        if (!is_onscreen_pixel_format(ret)) ret = 1;
+        wayland_gl_drawable_release(gl);
+    }
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglGetProcAddress
+ */
+static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
+{
+    PROC ret;
+    if (!strncmp(name, "wgl", 3)) return NULL;
+    ret = (PROC)p_eglGetProcAddress(name);
+    TRACE("%s -> %p\n", name, ret);
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormat
+ */
+static BOOL WINAPI wayland_wglSetPixelFormat(HDC hdc, int format,
+                                             const PIXELFORMATDESCRIPTOR *pfd)
+{
+    return set_pixel_format(hdc, format, FALSE);
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormatWINE
+ */
+static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
+{
+    return set_pixel_format(hdc, format, TRUE);
+}
+
+/***********************************************************************
+ *		wayland_wglShareLists
+ */
+static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
+                                         struct wgl_context *dest)
+{
+    TRACE("(%p, %p)\n", org, dest);
+
+    /* Sharing of display lists works differently in EGL and WGL. In case of
+     * EGL it is done at context creation time but in case of EGL it can also
+     * be done using wglShareLists.
+     *
+     * We handle this by creating an EGL context in wglCreateContext /
+     * wglCreateContextAttribsARB and when a program requests sharing we
+     * recreate the destination context if it hasn't been made current and
+     * it hasn't shared display lists before.
+     */
+
+    if (dest->has_been_current)
+    {
+        ERR("Could not share display lists, the hglrc2 context has been current already!\n");
+        return FALSE;
+    }
+    else if (dest->sharing)
+    {
+        ERR("Could not share display lists because hglrc2 has already shared lists before!\n");
+        return FALSE;
+    }
+    else
+    {
+        /* Re-create the EGL context and share display lists */
+        p_eglDestroyContext(egl_display, dest->context);
+        dest->context = p_eglCreateContext(egl_display, dest->config,
+                                           org->context, dest->attribs);
+        TRACE("re-created EGL context (%p) for WGL context %p (config: %p) "
+              "sharing lists with EGL context %p for WGL context %p (config: %p)\n",
+              dest->context, dest, dest->config, org->context, org, org->config);
+        org->sharing = TRUE;
+        dest->sharing = TRUE;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglSwapBuffers
+ */
+static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    HWND hwnd = NtUserWindowFromDC(hdc);
+    struct wayland_gl_drawable *draw_gl = wayland_gl_drawable_get(hwnd);
+
+    TRACE("hdc %p hwnd %p ctx %p\n", hdc, hwnd, ctx);
+
+    if (draw_gl && wayland_gl_drawable_needs_update(draw_gl))
+    {
+        wayland_gl_drawable_update(draw_gl);
+        goto out;
+    }
+
+    if ((!ctx || !wgl_context_refresh(ctx)) && draw_gl && draw_gl->surface)
+    {
+        struct wayland_gl_buffer *gl_buffer;
+        struct gbm_bo *bo;
+
+        wayland_gl_drawable_throttle(draw_gl);
+
+        p_eglSwapBuffers(egl_display, draw_gl->surface);
+
+        bo = gbm_surface_lock_front_buffer(draw_gl->gbm_surface);
+        if (!bo)
+        {
+            ERR("Failed to lock front buffer\n");
+            goto out;
+        }
+        gl_buffer = wayland_gl_drawable_track_buffer(draw_gl, bo);
+
+        if (!wayland_gl_drawable_commit(draw_gl, gl_buffer))
+            gbm_surface_release_buffer(gl_buffer->gbm_surface, gl_buffer->gbm_bo);
+
+        /* Wait until we have a free buffer for the application to render into
+         * before we continue. */
+        if (draw_gl->wayland_surface)
+        {
+            while (!gbm_surface_has_free_buffers(draw_gl->gbm_surface) &&
+                   wayland_dispatch_queue(draw_gl->wl_event_queue, -1) != -1)
+            {
+                continue;
+            }
+        }
+        else if (draw_gl->remote_surface_proxy)
+        {
+            static const DWORD wait_timeout = 100;
+            DWORD wait_start = NtGetTickCount();
+            /* If we don't get a free buffer within the specified timeout, drop
+             * one of the previous buffers to ensure we can continue and avoid
+             * potential cross-process deadlocks (e.g., the render process
+             * waiting for the window process to dispatch buffer release messages,
+             * while the window process is waiting for the render process to finish
+             * rendering). */
+            while (!gbm_surface_has_free_buffers(draw_gl->gbm_surface) &&
+                   wayland_gl_drawable_wait_remote(draw_gl, 10) != WAIT_FAILED)
+            {
+                if (get_tick_count_since(wait_start) > wait_timeout)
+                {
+                    struct wayland_gl_buffer *to_release;
+                    wl_list_for_each(to_release, &draw_gl->buffer_list, link)
+                        if (to_release != gl_buffer) break;
+                    wayland_gl_buffer_release(to_release);
+                }
+            }
+        }
+    }
+
+out:
+    wayland_gl_drawable_release(draw_gl);
+
+    return TRUE;
+}
+
+static void wayland_glDrawBuffer(GLenum mode)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    GLint draw_fbo = -1;
+
+    if (!ctx) return;
+
+    egl_funcs.gl.p_glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &draw_fbo);
+
+    TRACE("hwnd %p egl_context %p mode 0x%x draw_fbo %d\n",
+          ctx->draw_hwnd, ctx->context, mode, draw_fbo);
+
+    if (draw_fbo == 0)
+    {
+        BOOL is_draw_buffer_front = (mode == GL_FRONT || mode == GL_FRONT_LEFT);
+        /* Disable the window front buffer if we have one and it's not needed
+         * any longer.  */
+        if (ctx->is_draw_buffer_front && !is_draw_buffer_front)
+            wayland_update_front_buffer(ctx->draw_hwnd, NULL);
+        ctx->is_draw_buffer_front = is_draw_buffer_front;
+    }
+
+    p_glDrawBuffer(mode);
+}
+
+static void read_front_buffer_pixels(void *pixels_out, int width, int height)
+{
+    GLenum prev_read_buffer;
+    GLint prev_read_framebuffer;
+    GLint prev_row_length;
+    GLint prev_image_height;
+    GLint prev_skip_rows;
+    GLint prev_skip_pixels;
+    GLint prev_skip_images;
+    GLint prev_alignment;
+
+    /* Store state we might change */
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_BUFFER, (GLint*)&prev_read_buffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &prev_read_framebuffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ROW_LENGTH, &prev_row_length);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_IMAGE_HEIGHT, &prev_image_height);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_ROWS, &prev_skip_rows);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_PIXELS, &prev_skip_pixels);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_IMAGES, &prev_skip_images);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ALIGNMENT, &prev_alignment);
+
+    /* Set state we need for reading the pixels */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+    egl_funcs.gl.p_glReadBuffer(GL_FRONT);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    egl_funcs.gl.p_glReadPixels(0, 0, width, height, GL_BGRA,  GL_UNSIGNED_BYTE,
+                                pixels_out);
+
+    /* Restore prev state */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, prev_read_framebuffer);
+    egl_funcs.gl.p_glReadBuffer(prev_read_buffer);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, prev_row_length);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, prev_image_height);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, prev_skip_rows);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, prev_skip_pixels);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, prev_skip_images);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, prev_alignment);
+}
+
+static void wayland_glFinish(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFinish();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
+}
+
+static void wayland_glFlush(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFlush();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
+}
+
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static int wayland_wglGetSwapIntervalEXT(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+    int swap_interval;
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        /* This can't happen because a current WGL context is required to get
+         * here. Likely the application is buggy.
+         */
+        WARN("No GL drawable found, returning swap interval 0\n");
+        return 0;
+    }
+
+    swap_interval = gl->swap_interval;
+    wayland_gl_drawable_release(gl);
+
+    return swap_interval;
+}
+
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static BOOL wayland_wglSwapIntervalEXT(int interval)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+
+    TRACE("(%d)\n", interval);
+
+    if (interval < 0)
+    {
+        RtlSetLastWin32Error(ERROR_INVALID_DATA);
+        return FALSE;
+    }
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
+        return FALSE;
+    }
+
+    gl->swap_interval = interval;
+
+    wayland_gl_drawable_release(gl);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringARB
+ */
+static const char *wayland_wglGetExtensionsStringARB(HDC hdc)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringEXT
+ */
+static const char *wayland_wglGetExtensionsStringEXT(void)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+static void register_extension(const char *ext)
+{
+    if (wgl_extensions[0]) strcat(wgl_extensions, " ");
+    strcat(wgl_extensions, ext);
+    TRACE("%s\n", ext);
+}
+
+static BOOL has_extension(const char *list, const char *ext)
+{
+    size_t len = strlen(ext);
+    const char *cur = list;
+
+    if (!cur) return FALSE;
+
+    while ((cur = strstr(cur, ext)))
+    {
+        if ((!cur[len] || cur[len] == ' ') && (cur == list || cur[-1] == ' '))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void init_extensions(int major, int minor)
+{
+    void *ptr;
+    const char *egl_exts = p_eglQueryString(egl_display, EGL_EXTENSIONS);
+
+    register_extension("WGL_ARB_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
+
+    register_extension("WGL_EXT_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
+
+    /* In WineD3D we need the ability to set the pixel format more than once
+     * (e.g. after a device reset).  The default wglSetPixelFormat doesn't
+     * allow this, so add our own which allows it.
+     */
+    register_extension("WGL_WINE_pixel_format_passthrough");
+    egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
+
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
+
+    register_extension("WGL_ARB_create_context");
+    register_extension("WGL_ARB_create_context_profile");
+    egl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
+
+    if (has_extension(egl_exts, "EGL_KHR_create_context"))
+        has_khr_create_context = TRUE;
+
+    register_extension("WGL_EXT_swap_control");
+    egl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
+    egl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
+
+    if ((major == 1 && minor >= 5) || has_extension(egl_exts, "EGL_KHR_gl_colorspace"))
+    {
+        register_extension("WGL_EXT_framebuffer_sRGB");
+        has_gl_colorspace = TRUE;
+    }
+
+    /* load standard functions and extensions exported from the OpenGL library */
+
+#define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
+    ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+#define LOAD_FUNCPTR(func) egl_funcs.ext.p_##func = dlsym(opengl_handle, #func)
+    LOAD_FUNCPTR(glActiveShaderProgram);
+    LOAD_FUNCPTR(glActiveTexture);
+    LOAD_FUNCPTR(glAttachShader);
+    LOAD_FUNCPTR(glBeginQuery);
+    LOAD_FUNCPTR(glBeginTransformFeedback);
+    LOAD_FUNCPTR(glBindAttribLocation);
+    LOAD_FUNCPTR(glBindBuffer);
+    LOAD_FUNCPTR(glBindBufferBase);
+    LOAD_FUNCPTR(glBindBufferRange);
+    LOAD_FUNCPTR(glBindFramebuffer);
+    LOAD_FUNCPTR(glBindImageTexture);
+    LOAD_FUNCPTR(glBindProgramPipeline);
+    LOAD_FUNCPTR(glBindRenderbuffer);
+    LOAD_FUNCPTR(glBindSampler);
+    LOAD_FUNCPTR(glBindTransformFeedback);
+    LOAD_FUNCPTR(glBindVertexArray);
+    LOAD_FUNCPTR(glBindVertexBuffer);
+    LOAD_FUNCPTR(glBlendBarrierKHR);
+    LOAD_FUNCPTR(glBlendColor);
+    LOAD_FUNCPTR(glBlendEquation);
+    LOAD_FUNCPTR(glBlendEquationSeparate);
+    LOAD_FUNCPTR(glBlendFuncSeparate);
+    LOAD_FUNCPTR(glBlitFramebuffer);
+    LOAD_FUNCPTR(glBufferData);
+    LOAD_FUNCPTR(glBufferSubData);
+    LOAD_FUNCPTR(glCheckFramebufferStatus);
+    LOAD_FUNCPTR(glClearBufferfi);
+    LOAD_FUNCPTR(glClearBufferfv);
+    LOAD_FUNCPTR(glClearBufferiv);
+    LOAD_FUNCPTR(glClearBufferuiv);
+    LOAD_FUNCPTR(glClearDepthf);
+    LOAD_FUNCPTR(glClientWaitSync);
+    LOAD_FUNCPTR(glCompileShader);
+    LOAD_FUNCPTR(glCompressedTexImage2D);
+    LOAD_FUNCPTR(glCompressedTexImage3D);
+    LOAD_FUNCPTR(glCompressedTexSubImage2D);
+    LOAD_FUNCPTR(glCompressedTexSubImage3D);
+    LOAD_FUNCPTR(glCopyBufferSubData);
+    LOAD_FUNCPTR(glCopyTexSubImage3D);
+    LOAD_FUNCPTR(glCreateProgram);
+    LOAD_FUNCPTR(glCreateShader);
+    LOAD_FUNCPTR(glCreateShaderProgramv);
+    LOAD_FUNCPTR(glDeleteBuffers);
+    LOAD_FUNCPTR(glDeleteFramebuffers);
+    LOAD_FUNCPTR(glDeleteProgram);
+    LOAD_FUNCPTR(glDeleteProgramPipelines);
+    LOAD_FUNCPTR(glDeleteQueries);
+    LOAD_FUNCPTR(glDeleteRenderbuffers);
+    LOAD_FUNCPTR(glDeleteSamplers);
+    LOAD_FUNCPTR(glDeleteShader);
+    LOAD_FUNCPTR(glDeleteSync);
+    LOAD_FUNCPTR(glDeleteTransformFeedbacks);
+    LOAD_FUNCPTR(glDeleteVertexArrays);
+    LOAD_FUNCPTR(glDepthRangef);
+    LOAD_FUNCPTR(glDetachShader);
+    LOAD_FUNCPTR(glDisableVertexAttribArray);
+    LOAD_FUNCPTR(glDispatchCompute);
+    LOAD_FUNCPTR(glDispatchComputeIndirect);
+    LOAD_FUNCPTR(glDrawArraysIndirect);
+    LOAD_FUNCPTR(glDrawArraysInstanced);
+    LOAD_FUNCPTR(glDrawBuffers);
+    LOAD_FUNCPTR(glDrawElementsIndirect);
+    LOAD_FUNCPTR(glDrawElementsInstanced);
+    LOAD_FUNCPTR(glDrawRangeElements);
+    LOAD_FUNCPTR(glEnableVertexAttribArray);
+    LOAD_FUNCPTR(glEndQuery);
+    LOAD_FUNCPTR(glEndTransformFeedback);
+    LOAD_FUNCPTR(glFenceSync);
+    LOAD_FUNCPTR(glFlushMappedBufferRange);
+    LOAD_FUNCPTR(glFramebufferParameteri);
+    LOAD_FUNCPTR(glFramebufferRenderbuffer);
+    LOAD_FUNCPTR(glFramebufferTexture2D);
+    LOAD_FUNCPTR(glFramebufferTextureEXT);
+    LOAD_FUNCPTR(glFramebufferTextureLayer);
+    LOAD_FUNCPTR(glGenBuffers);
+    LOAD_FUNCPTR(glGenFramebuffers);
+    LOAD_FUNCPTR(glGenProgramPipelines);
+    LOAD_FUNCPTR(glGenQueries);
+    LOAD_FUNCPTR(glGenRenderbuffers);
+    LOAD_FUNCPTR(glGenSamplers);
+    LOAD_FUNCPTR(glGenTransformFeedbacks);
+    LOAD_FUNCPTR(glGenVertexArrays);
+    LOAD_FUNCPTR(glGenerateMipmap);
+    LOAD_FUNCPTR(glGetActiveAttrib);
+    LOAD_FUNCPTR(glGetActiveUniform);
+    LOAD_FUNCPTR(glGetActiveUniformBlockName);
+    LOAD_FUNCPTR(glGetActiveUniformBlockiv);
+    LOAD_FUNCPTR(glGetActiveUniformsiv);
+    LOAD_FUNCPTR(glGetAttachedShaders);
+    LOAD_FUNCPTR(glGetAttribLocation);
+    LOAD_FUNCPTR(glGetBooleani_v);
+    LOAD_FUNCPTR(glGetBufferParameteri64v);
+    LOAD_FUNCPTR(glGetBufferParameteriv);
+    LOAD_FUNCPTR(glGetBufferPointerv);
+    LOAD_FUNCPTR(glGetFragDataLocation);
+    LOAD_FUNCPTR(glGetFramebufferAttachmentParameteriv);
+    LOAD_FUNCPTR(glGetFramebufferParameteriv);
+    LOAD_FUNCPTR(glGetInteger64i_v);
+    LOAD_FUNCPTR(glGetInteger64v);
+    LOAD_FUNCPTR(glGetIntegeri_v);
+    LOAD_FUNCPTR(glGetInternalformativ);
+    LOAD_FUNCPTR(glGetMultisamplefv);
+    LOAD_FUNCPTR(glGetProgramBinary);
+    LOAD_FUNCPTR(glGetProgramInfoLog);
+    LOAD_FUNCPTR(glGetProgramInterfaceiv);
+    LOAD_FUNCPTR(glGetProgramPipelineInfoLog);
+    LOAD_FUNCPTR(glGetProgramPipelineiv);
+    LOAD_FUNCPTR(glGetProgramResourceIndex);
+    LOAD_FUNCPTR(glGetProgramResourceLocation);
+    LOAD_FUNCPTR(glGetProgramResourceName);
+    LOAD_FUNCPTR(glGetProgramResourceiv);
+    LOAD_FUNCPTR(glGetProgramiv);
+    LOAD_FUNCPTR(glGetQueryObjectuiv);
+    LOAD_FUNCPTR(glGetQueryiv);
+    LOAD_FUNCPTR(glGetRenderbufferParameteriv);
+    LOAD_FUNCPTR(glGetSamplerParameterfv);
+    LOAD_FUNCPTR(glGetSamplerParameteriv);
+    LOAD_FUNCPTR(glGetShaderInfoLog);
+    LOAD_FUNCPTR(glGetShaderPrecisionFormat);
+    LOAD_FUNCPTR(glGetShaderSource);
+    LOAD_FUNCPTR(glGetShaderiv);
+    LOAD_FUNCPTR(glGetStringi);
+    LOAD_FUNCPTR(glGetSynciv);
+    LOAD_FUNCPTR(glGetTexParameterIivEXT);
+    LOAD_FUNCPTR(glGetTexParameterIuivEXT);
+    LOAD_FUNCPTR(glGetTransformFeedbackVarying);
+    LOAD_FUNCPTR(glGetUniformBlockIndex);
+    LOAD_FUNCPTR(glGetUniformIndices);
+    LOAD_FUNCPTR(glGetUniformLocation);
+    LOAD_FUNCPTR(glGetUniformfv);
+    LOAD_FUNCPTR(glGetUniformiv);
+    LOAD_FUNCPTR(glGetUniformuiv);
+    LOAD_FUNCPTR(glGetVertexAttribIiv);
+    LOAD_FUNCPTR(glGetVertexAttribIuiv);
+    LOAD_FUNCPTR(glGetVertexAttribPointerv);
+    LOAD_FUNCPTR(glGetVertexAttribfv);
+    LOAD_FUNCPTR(glGetVertexAttribiv);
+    LOAD_FUNCPTR(glInvalidateFramebuffer);
+    LOAD_FUNCPTR(glInvalidateSubFramebuffer);
+    LOAD_FUNCPTR(glIsBuffer);
+    LOAD_FUNCPTR(glIsFramebuffer);
+    LOAD_FUNCPTR(glIsProgram);
+    LOAD_FUNCPTR(glIsProgramPipeline);
+    LOAD_FUNCPTR(glIsQuery);
+    LOAD_FUNCPTR(glIsRenderbuffer);
+    LOAD_FUNCPTR(glIsSampler);
+    LOAD_FUNCPTR(glIsShader);
+    LOAD_FUNCPTR(glIsSync);
+    LOAD_FUNCPTR(glIsTransformFeedback);
+    LOAD_FUNCPTR(glIsVertexArray);
+    LOAD_FUNCPTR(glLinkProgram);
+    LOAD_FUNCPTR(glMapBufferRange);
+    LOAD_FUNCPTR(glMemoryBarrier);
+    LOAD_FUNCPTR(glMemoryBarrierByRegion);
+    LOAD_FUNCPTR(glPauseTransformFeedback);
+    LOAD_FUNCPTR(glProgramBinary);
+    LOAD_FUNCPTR(glProgramParameteri);
+    LOAD_FUNCPTR(glProgramUniform1f);
+    LOAD_FUNCPTR(glProgramUniform1fv);
+    LOAD_FUNCPTR(glProgramUniform1i);
+    LOAD_FUNCPTR(glProgramUniform1iv);
+    LOAD_FUNCPTR(glProgramUniform1ui);
+    LOAD_FUNCPTR(glProgramUniform1uiv);
+    LOAD_FUNCPTR(glProgramUniform2f);
+    LOAD_FUNCPTR(glProgramUniform2fv);
+    LOAD_FUNCPTR(glProgramUniform2i);
+    LOAD_FUNCPTR(glProgramUniform2iv);
+    LOAD_FUNCPTR(glProgramUniform2ui);
+    LOAD_FUNCPTR(glProgramUniform2uiv);
+    LOAD_FUNCPTR(glProgramUniform3f);
+    LOAD_FUNCPTR(glProgramUniform3fv);
+    LOAD_FUNCPTR(glProgramUniform3i);
+    LOAD_FUNCPTR(glProgramUniform3iv);
+    LOAD_FUNCPTR(glProgramUniform3ui);
+    LOAD_FUNCPTR(glProgramUniform3uiv);
+    LOAD_FUNCPTR(glProgramUniform4f);
+    LOAD_FUNCPTR(glProgramUniform4fv);
+    LOAD_FUNCPTR(glProgramUniform4i);
+    LOAD_FUNCPTR(glProgramUniform4iv);
+    LOAD_FUNCPTR(glProgramUniform4ui);
+    LOAD_FUNCPTR(glProgramUniform4uiv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glReleaseShaderCompiler);
+    LOAD_FUNCPTR(glRenderbufferStorage);
+    LOAD_FUNCPTR(glRenderbufferStorageMultisample);
+    LOAD_FUNCPTR(glResumeTransformFeedback);
+    LOAD_FUNCPTR(glSampleCoverage);
+    LOAD_FUNCPTR(glSampleMaski);
+    LOAD_FUNCPTR(glSamplerParameterf);
+    LOAD_FUNCPTR(glSamplerParameterfv);
+    LOAD_FUNCPTR(glSamplerParameteri);
+    LOAD_FUNCPTR(glSamplerParameteriv);
+    LOAD_FUNCPTR(glShaderBinary);
+    LOAD_FUNCPTR(glShaderSource);
+    LOAD_FUNCPTR(glStencilFuncSeparate);
+    LOAD_FUNCPTR(glStencilMaskSeparate);
+    LOAD_FUNCPTR(glStencilOpSeparate);
+    LOAD_FUNCPTR(glTexBufferEXT);
+    LOAD_FUNCPTR(glTexImage3D);
+    LOAD_FUNCPTR(glTexParameterIivEXT);
+    LOAD_FUNCPTR(glTexParameterIuivEXT);
+    LOAD_FUNCPTR(glTexStorage2D);
+    LOAD_FUNCPTR(glTexStorage2DMultisample);
+    LOAD_FUNCPTR(glTexStorage3D);
+    LOAD_FUNCPTR(glTexSubImage3D);
+    LOAD_FUNCPTR(glTransformFeedbackVaryings);
+    LOAD_FUNCPTR(glUniform1f);
+    LOAD_FUNCPTR(glUniform1fv);
+    LOAD_FUNCPTR(glUniform1i);
+    LOAD_FUNCPTR(glUniform1iv);
+    LOAD_FUNCPTR(glUniform1ui);
+    LOAD_FUNCPTR(glUniform1uiv);
+    LOAD_FUNCPTR(glUniform2f);
+    LOAD_FUNCPTR(glUniform2fv);
+    LOAD_FUNCPTR(glUniform2i);
+    LOAD_FUNCPTR(glUniform2iv);
+    LOAD_FUNCPTR(glUniform2ui);
+    LOAD_FUNCPTR(glUniform2uiv);
+    LOAD_FUNCPTR(glUniform3f);
+    LOAD_FUNCPTR(glUniform3fv);
+    LOAD_FUNCPTR(glUniform3i);
+    LOAD_FUNCPTR(glUniform3iv);
+    LOAD_FUNCPTR(glUniform3ui);
+    LOAD_FUNCPTR(glUniform3uiv);
+    LOAD_FUNCPTR(glUniform4f);
+    LOAD_FUNCPTR(glUniform4fv);
+    LOAD_FUNCPTR(glUniform4i);
+    LOAD_FUNCPTR(glUniform4iv);
+    LOAD_FUNCPTR(glUniform4ui);
+    LOAD_FUNCPTR(glUniform4uiv);
+    LOAD_FUNCPTR(glUniformBlockBinding);
+    LOAD_FUNCPTR(glUniformMatrix2fv);
+    LOAD_FUNCPTR(glUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glUniformMatrix3fv);
+    LOAD_FUNCPTR(glUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glUniformMatrix4fv);
+    LOAD_FUNCPTR(glUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glUnmapBuffer);
+    LOAD_FUNCPTR(glUseProgram);
+    LOAD_FUNCPTR(glUseProgramStages);
+    LOAD_FUNCPTR(glValidateProgram);
+    LOAD_FUNCPTR(glValidateProgramPipeline);
+    LOAD_FUNCPTR(glVertexAttrib1f);
+    LOAD_FUNCPTR(glVertexAttrib1fv);
+    LOAD_FUNCPTR(glVertexAttrib2f);
+    LOAD_FUNCPTR(glVertexAttrib2fv);
+    LOAD_FUNCPTR(glVertexAttrib3f);
+    LOAD_FUNCPTR(glVertexAttrib3fv);
+    LOAD_FUNCPTR(glVertexAttrib4f);
+    LOAD_FUNCPTR(glVertexAttrib4fv);
+    LOAD_FUNCPTR(glVertexAttribBinding);
+    LOAD_FUNCPTR(glVertexAttribDivisor);
+    LOAD_FUNCPTR(glVertexAttribFormat);
+    LOAD_FUNCPTR(glVertexAttribI4i);
+    LOAD_FUNCPTR(glVertexAttribI4iv);
+    LOAD_FUNCPTR(glVertexAttribI4ui);
+    LOAD_FUNCPTR(glVertexAttribI4uiv);
+    LOAD_FUNCPTR(glVertexAttribIFormat);
+    LOAD_FUNCPTR(glVertexAttribIPointer);
+    LOAD_FUNCPTR(glVertexAttribPointer);
+    LOAD_FUNCPTR(glVertexBindingDivisor);
+    LOAD_FUNCPTR(glWaitSync);
+#undef LOAD_FUNCPTR
+
+    /* Redirect some standard OpenGL functions. */
+
+#define REDIRECT(func) \
+    do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glDrawBuffer);
+    REDIRECT(glFinish);
+    REDIRECT(glFlush);
+#undef REDIRECT
+}
+
+static BOOL init_pixel_formats(void)
+{
+    EGLint count, i, pass;
+    EGLConfig *egl_configs = NULL;
+    struct wayland_dmabuf *dmabuf = NULL;
+    dev_t render_dev;
+
+    p_eglGetConfigs(egl_display, NULL, 0, &count);
+    if (!count)
+    {
+        ERR("eglGetConfigs returned no configs.\n");
+        goto err;
+    }
+
+    if (!(egl_configs = malloc(count * sizeof(*egl_configs))) ||
+        !(pixel_formats = malloc(count * sizeof(*pixel_formats))))
+    {
+        ERR("Memory allocation failed.\n");
+        goto err;
+    }
+    p_eglGetConfigs(egl_display, egl_configs, count, &count);
+
+    if (!(render_dev = wayland_gbm_get_render_dev()))
+    {
+        ERR("Failed to get device's dev_t from GBM device.\n");
+        goto err;
+    }
+
+    dmabuf = &wayland_process_acquire()->dmabuf;
+    /* Use two passes: the first pass adds the onscreen formats to the format list,
+     * the second offscreen ones. */
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_SURFACE_TYPE, &type);
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+
+            /* Ignore formats not supported by the compositor. */
+            if (!wayland_dmabuf_is_format_supported(dmabuf, visual_id, render_dev))
+                continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_COLOR_BUFFER_TYPE, &color);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RED_SIZE, &r);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_GREEN_SIZE, &g);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_BLUE_SIZE, &b);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_DEPTH_SIZE, &d);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_STENCIL_SIZE, &s);
+
+            /* Some drivers expose 10 bit components which are not typically what
+             * applications want. */
+            if (r > 8 || g > 8 || b > 8) continue;
+
+            pixel_formats[nb_pixel_formats].config = egl_configs[i];
+            pixel_formats[nb_pixel_formats].native_visual_id = visual_id;
+            nb_pixel_formats++;
+            TRACE("%u: config %u id %u type %x visual %u native %u render %x "
+                  "colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render,
+                   color, r, g, b, d, s);
+        }
+        if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
+    }
+    wayland_process_release();
+    free(egl_configs);
+
+    return TRUE;
+
+err:
+    free(egl_configs);
+    free(pixel_formats);
+
+    return FALSE;
+}
+
+static BOOL egl_init(void)
+{
+    static int retval = -1;
+
+    if (retval != -1) return retval;
+    retval = 0;
+
+    if (!(egl_handle = dlopen(SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        ERR("failed to load %s: %s\n", SONAME_LIBEGL, dlerror());
+        return FALSE;
+    }
+
+#ifdef SONAME_LIBGL
+    if (!(opengl_handle = dlopen(SONAME_LIBGL, RTLD_NOW|RTLD_GLOBAL)))
+        WARN("failed to load %s: %s\n", SONAME_LIBGL, dlerror());
+#endif
+
+#ifdef SONAME_LIBGLESV2
+    if (!opengl_handle && (!(opengl_handle = dlopen(SONAME_LIBGLESV2, RTLD_NOW|RTLD_GLOBAL))))
+        WARN("failed to load %s: %s\n", SONAME_LIBGLESV2, dlerror());
+#endif
+
+    if (!opengl_handle)
+    {
+        ERR("failed to load GL or GLESv2 library\n");
+        return FALSE;
+    }
+
+#define LOAD_FUNCPTR(func) do { \
+        if (!(p_##func = dlsym(egl_handle, #func))) \
+        { ERR("can't find symbol %s\n", #func); return FALSE; }    \
+    } while(0)
+    LOAD_FUNCPTR(eglBindAPI);
+    LOAD_FUNCPTR(eglCreateContext);
+    LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroyContext);
+    LOAD_FUNCPTR(eglDestroySurface);
+    LOAD_FUNCPTR(eglGetConfigAttrib);
+    LOAD_FUNCPTR(eglGetConfigs);
+    LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglGetProcAddress);
+    LOAD_FUNCPTR(eglInitialize);
+    LOAD_FUNCPTR(eglMakeCurrent);
+    LOAD_FUNCPTR(eglQueryString);
+    LOAD_FUNCPTR(eglSwapBuffers);
+#undef LOAD_FUNCPTR
+
+    if (!wayland_gbm_init()) return FALSE;
+
+    egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_gbm_device);
+    if (!p_eglInitialize(egl_display, &egl_version[0], &egl_version[1]))
+        return FALSE;
+    TRACE("display %p version %u.%u\n", egl_display, egl_version[0], egl_version[1]);
+
+    if (!init_pixel_formats()) return FALSE;
+
+    init_extensions(egl_version[0], egl_version[1]);
+    retval = 1;
+    return TRUE;
+}
+
+/* generate stubs for GL functions that are not exported */
+
+#define USE_GL_FUNC(name) \
+static void glstub_##name(void) \
+{ \
+    ERR(#name " called\n"); \
+    assert(0); \
+    ExitProcess(1); \
+}
+
+ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+static struct opengl_funcs egl_funcs =
+{
+    .wgl =
+    {
+        .p_wglCopyContext = wayland_wglCopyContext,
+        .p_wglCreateContext = wayland_wglCreateContext,
+        .p_wglDeleteContext = wayland_wglDeleteContext,
+        .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
+        .p_wglGetPixelFormat = wayland_wglGetPixelFormat,
+        .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglMakeCurrent = wayland_wglMakeCurrent,
+        .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
+        .p_wglShareLists = wayland_wglShareLists,
+        .p_wglSwapBuffers = wayland_wglSwapBuffers,
+    },
+#define USE_GL_FUNC(name) (void *)glstub_##name,
+    .gl = { ALL_WGL_FUNCS }
+#undef USE_GL_FUNC
+};
+
+/**********************************************************************
+ *           WAYLAND_wine_get_wgl_driver
+ */
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
+{
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR("version mismatch, opengl32 wants %u but driver has %u\n",
+            version, WINE_WGL_DRIVER_VERSION);
+        return NULL;
+    }
+    if (!egl_init()) return NULL;
+    return &egl_funcs;
+}
+
+/***********************************************************************
+ *		wayland_update_gl_drawable_surface
+ */
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface)
+{
+    struct wayland_gl_drawable *gl;
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+
+        gl->wayland_surface = wayland_surface;
+        if (gl->wayland_surface)
+            wayland_surface_create_or_ref_glvk(gl->wayland_surface);
+
+        wayland_gl_drawable_release(gl);
+    }
+}
+
+#else /* No GL */
+
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version)
+{
+    ERR("Wine Wayland was built without OpenGL support.\n");
+    return NULL;
+}
+
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface)
+{
+}
+
+void wayland_destroy_gl_drawable(HWND hwnd)
+{
+}
+
+#endif
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
new file mode 100644
index 00000000000..e7aa2e40b3b
--- /dev/null
+++ b/dlls/winewayland.drv/options.c
@@ -0,0 +1,116 @@
+/*
+ * winewayland.drv options
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Code to read options from the registry, adapted from the X11 driver */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+
+#include <string.h>
+
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
+ *              Config options
+ */
+
+char *option_drm_device = NULL;
+enum wayland_hidpi_scaling option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+BOOL option_show_systray = TRUE;
+BOOL option_use_system_cursors = TRUE;
+
+/***********************************************************************
+ *		get_config_key
+ *
+ * Get a config key from either the app-specific or the default config
+ */
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   ULONG type, char *buffer, DWORD size)
+{
+    if (appkey && !reg_get_value_a(appkey, name, type, buffer, &size)) return 0;
+    if (defkey && !reg_get_value_a(defkey, name, type, buffer, &size)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/***********************************************************************
+ *		wayland_read_options_from_registry
+ *
+ * Read the Wayland driver options from the registry.
+ */
+void wayland_read_options_from_registry(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    char buffer[64];
+    HKEY hkey, appkey = 0;
+    DWORD process_name_len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = reg_open_hkcu_key_a("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    process_name_len = process_name ? strlen(process_name) : 0;
+    if (process_name_len > 0)
+    {
+        WCHAR appname[MAX_PATH + sizeof(waylanddriverW) / sizeof(WCHAR)];
+        DWORD reslen;
+        if (!RtlUTF8ToUnicodeN(appname, MAX_PATH * sizeof(WCHAR), &reslen,
+                               process_name, process_name_len))
+        {
+            HKEY tmpkey;
+            memcpy((char *)appname + reslen, waylanddriverW, sizeof(waylanddriverW));
+            /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+            if ((tmpkey = reg_open_hkcu_key_a("Software\\Wine\\AppDefaults")))
+            {
+                appkey = reg_open_key_w(tmpkey, appname);
+                NtClose(tmpkey);
+            }
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "DRMDevice", REG_SZ, buffer, sizeof(buffer)))
+        option_drm_device = strdup(buffer);
+
+    if (!get_config_key(hkey, appkey, "HiDPIScaling", REG_SZ, buffer, sizeof(buffer)))
+    {
+        if (!strcasecmp(buffer, "Application"))
+            option_hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+        else if (!strcasecmp(buffer, "Compositor"))
+            option_hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
+    }
+
+    if (!get_config_key(hkey, appkey, "ShowSystray", REG_SZ, buffer, sizeof(buffer)))
+        option_show_systray = IS_OPTION_TRUE(buffer[0]);
+
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
+    if (appkey) NtClose(appkey);
+    if (hkey) NtClose(hkey);
+}
diff --git a/dlls/winewayland.drv/registry.c b/dlls/winewayland.drv/registry.c
new file mode 100644
index 00000000000..ef01b23a256
--- /dev/null
+++ b/dlls/winewayland.drv/registry.c
@@ -0,0 +1,167 @@
+/*
+ * Registry helpers
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <stdio.h>
+
+/**********************************************************************
+ *          reg_open_key_a
+ *
+ *  Open a registry key with the specified ASCII name.
+ */
+HKEY reg_open_key_a(HKEY root, const char *name)
+{
+    WCHAR nameW[256];
+    if (!name || !*name) return root;
+    if (ascii_to_unicode_maybe_z(nameW, ARRAY_SIZE(nameW), name, -1) > ARRAY_SIZE(nameW))
+        return 0;
+    return reg_open_key_w(root, nameW);
+}
+
+/**********************************************************************
+ *          reg_open_key_w
+ *
+ *  Open a registry key with the specified Unicode name.
+ */
+HKEY reg_open_key_w(HKEY root, const WCHAR *nameW)
+{
+    INT name_len = nameW ? lstrlenW(nameW) * sizeof(WCHAR) : 0;
+    UNICODE_STRING name_unicode = { name_len, name_len, (WCHAR *)nameW };
+    OBJECT_ATTRIBUTES attr;
+    HANDLE ret;
+
+    if (!nameW || !*nameW) return root;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &name_unicode;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
+}
+
+/**********************************************************************
+ *          reg_open_hkcu_key_a
+ *
+ *  Open a registry key under HKCU with the specified ASCII name.
+ */
+HKEY reg_open_hkcu_key_a(const char *name)
+{
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data,
+                                    len, &len))
+        {
+            return 0;
+        }
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = snprintf(buffer, ARRAY_SIZE(buffer), "\\Registry\\User\\S-%u-%u",
+                       sid->Revision,
+                       MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                         sid->IdentifierAuthority.Value[4]),
+                                MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                         sid->IdentifierAuthority.Value[2])));
+        if (len >= ARRAY_SIZE(buffer)) return 0;
+
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+        {
+            len += snprintf(buffer + len, ARRAY_SIZE(buffer) - len, "-%u",
+                            sid->SubAuthority[i]);
+            if (len >= ARRAY_SIZE(buffer)) return 0;
+        }
+
+        hkcu = reg_open_key_a(NULL, buffer);
+    }
+
+    return reg_open_key_a(hkcu, name);
+}
+
+static DWORD reg_get_value_info(HKEY hkey, const WCHAR *nameW, ULONG type,
+                                KEY_VALUE_PARTIAL_INFORMATION *info,
+                                ULONG info_size)
+{
+    unsigned int name_size = lstrlenW(nameW) * sizeof(WCHAR);
+    UNICODE_STRING name_unicode = { name_size, name_size, (WCHAR *)nameW };
+
+    if (NtQueryValueKey(hkey, &name_unicode, KeyValuePartialInformation,
+                        info, info_size, &info_size))
+        return ERROR_FILE_NOT_FOUND;
+
+    if (info->Type != type) return ERROR_DATATYPE_MISMATCH;
+
+    return ERROR_SUCCESS;
+}
+
+/**********************************************************************
+ *          reg_get_value_a
+ *
+ *  Get the value of the specified registry key (or subkey if name is not NULL),
+ *  having the specified type. If the types do not match an error is returned.
+ *  If the stored value is REG_SZ the string is transformed into ASCII before
+ *  being returned.
+ */
+DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
+                      DWORD *buffer_len)
+{
+    WCHAR nameW[256];
+    char info_buf[2048];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)info_buf;
+    ULONG info_size = ARRAY_SIZE(info_buf);
+    DWORD err;
+
+    if (name && ascii_to_unicode_maybe_z(nameW, ARRAY_SIZE(nameW), name, -1) > ARRAY_SIZE(nameW))
+        return ERROR_INSUFFICIENT_BUFFER;
+
+    if ((err = reg_get_value_info(hkey, name ? nameW : NULL, type, info, info_size)))
+        return err;
+
+    if (type == REG_SZ)
+    {
+        size_t nchars = unicode_to_ascii_maybe_z(buffer, *buffer_len, (WCHAR *)info->Data,
+                                                 info->DataLength / sizeof(WCHAR));
+        err = *buffer_len >= nchars ? ERROR_SUCCESS : ERROR_MORE_DATA;
+        *buffer_len = nchars;
+    }
+    else
+    {
+        err = *buffer_len >= info->DataLength ? ERROR_SUCCESS : ERROR_MORE_DATA;
+        if (err == ERROR_SUCCESS) memcpy(buffer, info->Data, info->DataLength);
+        *buffer_len = info->DataLength;
+    }
+
+    return err;
+}
diff --git a/dlls/winewayland.drv/systray.c b/dlls/winewayland.drv/systray.c
new file mode 100644
index 00000000000..f72f0089fd9
--- /dev/null
+++ b/dlls/winewayland.drv/systray.c
@@ -0,0 +1,744 @@
+/*
+ * Wayland system tray management
+ *
+ * Copyright (C) 2004 Mike Hearn, for CodeWeavers
+ * Copyright (C) 2005 Robert Shearman
+ * Copyright (C) 2008 Alexandre Julliard
+ * Copyright (C) 2021 Alexandros Frantzis, for Collabora
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Adapted from winex11.drv/systray.c */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "commctrl.h"
+#include "shellapi.h"
+
+#include "waylanddrv_dll.h"
+#include "wine/list.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(systray);
+
+/* an individual systray icon */
+struct tray_icon
+{
+    struct list    entry;
+    HICON          image;    /* the image to render */
+    HWND           owner;    /* the HWND passed in to the Shell_NotifyIcon call */
+    HWND           window;   /* the adaptor window */
+    BOOL           layered;  /* whether we are using a layered window */
+    HWND           tooltip;  /* Icon tooltip */
+    UINT           state;    /* state flags */
+    UINT           id;       /* the unique id given by the app */
+    UINT           callback_message;
+    int            display;  /* display index, or -1 if hidden */
+    WCHAR          tiptext[128];    /* tooltip text */
+    WCHAR          info_text[256];  /* info balloon text */
+    WCHAR          info_title[64];  /* info balloon title */
+    UINT           info_flags;      /* flags for info balloon */
+    UINT           info_timeout;    /* timeout for info balloon */
+    HICON          info_icon;       /* info balloon icon */
+    UINT           version;         /* notify icon api version */
+};
+
+static struct list icon_list = LIST_INIT( icon_list );
+
+static const WCHAR icon_classname[] = {'_','_','w','i','n','e','w','a','y','l','a','n','d','_','t','r','a','y','_','i','c','o','n',0};
+static const WCHAR tray_classname[] = {'_','_','w','i','n','e','w','a','y','l','a','n','d','_','s','t','a','n','d','a','l','o','n','e','_','t','r','a','y',0};
+
+static BOOL show_icon( struct tray_icon *icon );
+static BOOL hide_icon( struct tray_icon *icon );
+static BOOL delete_icon( struct tray_icon *icon );
+
+#define SYSTEM_TRAY_REQUEST_DOCK  0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+
+#define MIN_DISPLAYED 8
+#define ICON_BORDER 2
+
+#define BALLOON_CREATE_TIMER 1
+#define BALLOON_SHOW_TIMER   2
+
+#define BALLOON_CREATE_TIMEOUT   2000
+#define BALLOON_SHOW_MIN_TIMEOUT 10000
+#define BALLOON_SHOW_MAX_TIMEOUT 30000
+
+static struct tray_icon *balloon_icon;
+static HWND balloon_window;
+static POINT balloon_pos;
+
+/* stand-alone tray window */
+static HWND standalone_tray;
+static int icon_cx, icon_cy;
+static unsigned int nb_displayed;
+
+/* retrieves icon record by owner window and ID */
+static struct tray_icon *get_icon(HWND owner, UINT id)
+{
+    struct tray_icon *this;
+
+    LIST_FOR_EACH_ENTRY( this, &icon_list, struct tray_icon, entry )
+        if ((this->id == id) && (this->owner == owner)) return this;
+    return NULL;
+}
+
+static void init_common_controls(void)
+{
+    static BOOL initialized = FALSE;
+
+    if (!initialized)
+    {
+        INITCOMMONCONTROLSEX init_tooltip;
+
+        init_tooltip.dwSize = sizeof(INITCOMMONCONTROLSEX);
+        init_tooltip.dwICC = ICC_TAB_CLASSES;
+
+        InitCommonControlsEx(&init_tooltip);
+        initialized = TRUE;
+    }
+}
+
+/* create tooltip window for icon */
+static void create_tooltip(struct tray_icon *icon)
+{
+    init_common_controls();
+    icon->tooltip = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                     WS_POPUP | TTS_ALWAYSTIP,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     icon->window, NULL, NULL, NULL);
+    if (icon->tooltip)
+    {
+        TTTOOLINFOW ti;
+        ZeroMemory(&ti, sizeof(ti));
+        ti.cbSize = sizeof(TTTOOLINFOW);
+        ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+        ti.hwnd = icon->window;
+        ti.uId = (UINT_PTR)icon->window;
+        ti.lpszText = icon->tiptext;
+        SendMessageW(icon->tooltip, TTM_ADDTOOLW, 0, (LPARAM)&ti);
+    }
+}
+
+void update_systray_balloon_position(void)
+{
+    RECT rect;
+    POINT pos;
+
+    if (!balloon_icon) return;
+    GetWindowRect( balloon_icon->window, &rect );
+    pos.x = (rect.left + rect.right) / 2;
+    pos.y = (rect.top + rect.bottom) / 2;
+    if (pos.x == balloon_pos.x && pos.y == balloon_pos.y) return;  /* nothing changed */
+    balloon_pos = pos;
+    SendMessageW( balloon_window, TTM_TRACKPOSITION, 0, MAKELONG( pos.x, pos.y ));
+}
+
+static void balloon_create_timer( struct tray_icon *icon )
+{
+    TTTOOLINFOW ti;
+
+    init_common_controls();
+    balloon_window = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                      WS_POPUP | TTS_ALWAYSTIP | TTS_NOPREFIX | TTS_BALLOON | TTS_CLOSE,
+                                      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+                                      icon->window, NULL, NULL, NULL);
+
+    memset( &ti, 0, sizeof(ti) );
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.uFlags = TTF_TRACK | TTF_IDISHWND;
+    ti.lpszText = icon->info_text;
+    SendMessageW( balloon_window, TTM_ADDTOOLW, 0, (LPARAM)&ti );
+    if ((icon->info_flags & NIIF_ICONMASK) == NIIF_USER)
+        SendMessageW( balloon_window, TTM_SETTITLEW, (WPARAM)icon->info_icon, (LPARAM)icon->info_title );
+    else
+        SendMessageW( balloon_window, TTM_SETTITLEW, icon->info_flags, (LPARAM)icon->info_title );
+    balloon_icon = icon;
+    balloon_pos.x = balloon_pos.y = MAXLONG;
+    update_systray_balloon_position();
+    SendMessageW( balloon_window, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti );
+    KillTimer( icon->window, BALLOON_CREATE_TIMER );
+    SetTimer( icon->window, BALLOON_SHOW_TIMER, icon->info_timeout, NULL );
+}
+
+static BOOL show_balloon( struct tray_icon *icon )
+{
+    if (standalone_tray && !option_show_systray) return FALSE;  /* no systray window */
+    if (!icon->window) return FALSE;  /* not displayed */
+    if (!icon->info_text[0]) return FALSE;  /* no balloon */
+    balloon_icon = icon;
+    SetTimer( icon->window, BALLOON_CREATE_TIMER, BALLOON_CREATE_TIMEOUT, NULL );
+    return TRUE;
+}
+
+static void hide_balloon(void)
+{
+    if (!balloon_icon) return;
+    if (balloon_window)
+    {
+        KillTimer( balloon_icon->window, BALLOON_SHOW_TIMER );
+        DestroyWindow( balloon_window );
+        balloon_window = 0;
+    }
+    else KillTimer( balloon_icon->window, BALLOON_CREATE_TIMER );
+    balloon_icon = NULL;
+}
+
+static void show_next_balloon(void)
+{
+    struct tray_icon *icon;
+
+    LIST_FOR_EACH_ENTRY( icon, &icon_list, struct tray_icon, entry )
+        if (show_balloon( icon )) break;
+}
+
+static void update_balloon( struct tray_icon *icon )
+{
+    if (balloon_icon == icon)
+    {
+        hide_balloon();
+        show_balloon( icon );
+    }
+    else if (!balloon_icon)
+    {
+        if (!show_balloon( icon )) return;
+    }
+    if (!balloon_icon) show_next_balloon();
+}
+
+static void balloon_timer(void)
+{
+    if (balloon_icon) balloon_icon->info_text[0] = 0;  /* clear text now that balloon has been shown */
+    hide_balloon();
+    show_next_balloon();
+}
+
+/* synchronize tooltip text with tooltip window */
+static void update_tooltip_text(struct tray_icon *icon)
+{
+    TTTOOLINFOW ti;
+
+    ZeroMemory(&ti, sizeof(ti));
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.lpszText = icon->tiptext;
+
+    SendMessageW(icon->tooltip, TTM_UPDATETIPTEXTW, 0, (LPARAM)&ti);
+}
+
+/* get the size of the stand-alone tray window */
+static SIZE get_window_size(void)
+{
+    SIZE size;
+    RECT rect;
+
+    rect.left = 0;
+    rect.top = 0;
+    rect.right = icon_cx * max( nb_displayed, MIN_DISPLAYED );
+    rect.bottom = icon_cy;
+    AdjustWindowRect( &rect, WS_CAPTION, FALSE );
+    size.cx = rect.right - rect.left;
+    size.cy = rect.bottom - rect.top;
+    return size;
+}
+
+/* get the position of an icon in the stand-alone tray */
+static POINT get_icon_pos( struct tray_icon *icon )
+{
+    POINT pos;
+
+    pos.x = icon_cx * icon->display;
+    pos.y = 0;
+    return pos;
+}
+
+/* window procedure for the standalone tray window */
+static LRESULT WINAPI standalone_tray_wndproc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    switch (msg)
+    {
+    case WM_MOVE:
+        update_systray_balloon_position();
+        break;
+    case WM_CLOSE:
+        ShowWindow( hwnd, SW_HIDE );
+        hide_balloon();
+        option_show_systray = FALSE;
+        return 0;
+    case WM_DESTROY:
+        standalone_tray = 0;
+        break;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+/* add an icon to the standalone tray window */
+static void add_to_standalone_tray( struct tray_icon *icon )
+{
+    SIZE size;
+    POINT pos;
+
+    if (!standalone_tray)
+    {
+        static const WCHAR winname[] = {'W','i','n','e',' ','S','y','s','t','e','m',' ','T','r','a','y',0};
+
+        size = get_window_size();
+        standalone_tray = CreateWindowExW( 0, tray_classname, winname, WS_CAPTION | WS_SYSMENU,
+                                           CW_USEDEFAULT, CW_USEDEFAULT, size.cx, size.cy, 0, 0, 0, 0 );
+        if (!standalone_tray) return;
+    }
+
+    icon->display = nb_displayed;
+    pos = get_icon_pos( icon );
+    icon->window = CreateWindowW( icon_classname, NULL, WS_CHILD | WS_VISIBLE,
+                                  pos.x, pos.y, icon_cx, icon_cy, standalone_tray, NULL, NULL, icon );
+    if (!icon->window)
+    {
+        icon->display = -1;
+        return;
+    }
+    create_tooltip( icon );
+
+    nb_displayed++;
+    size = get_window_size();
+    SetWindowPos( standalone_tray, 0, 0, 0, size.cx, size.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER );
+    if (nb_displayed == 1 && option_show_systray) ShowWindow( standalone_tray, SW_SHOWNA );
+    TRACE( "added %u now %d icons\n", icon->id, nb_displayed );
+}
+
+/* remove an icon from the stand-alone tray */
+static void remove_from_standalone_tray( struct tray_icon *icon )
+{
+    struct tray_icon *ptr;
+    POINT pos;
+
+    if (icon->display == -1) return;
+
+    LIST_FOR_EACH_ENTRY( ptr, &icon_list, struct tray_icon, entry )
+    {
+        if (ptr == icon) continue;
+        if (ptr->display < icon->display) continue;
+        ptr->display--;
+        pos = get_icon_pos( ptr );
+        SetWindowPos( ptr->window, 0, pos.x, pos.y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER );
+    }
+    icon->display = -1;
+    if (!--nb_displayed) ShowWindow( standalone_tray, SW_HIDE );
+    TRACE( "removed %u now %d icons\n", icon->id, nb_displayed );
+}
+
+static void repaint_tray_icon( struct tray_icon *icon )
+{
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
+    int width = GetSystemMetrics( SM_CXSMICON );
+    int height = GetSystemMetrics( SM_CYSMICON );
+    BITMAPINFO *info;
+    HBITMAP dib, mask;
+    HDC hdc;
+    RECT rc;
+    SIZE size;
+    POINT pos;
+    int i, x, y;
+    void *color_bits, *mask_bits;
+    DWORD *ptr;
+    BOOL has_alpha = FALSE;
+
+    GetWindowRect( icon->window, &rc );
+    size.cx = rc.right - rc.left;
+    size.cy = rc.bottom - rc.top;
+    pos.x = (size.cx - width) / 2;
+    pos.y = (size.cy - height) / 2;
+
+    info = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, FIELD_OFFSET( BITMAPINFO, bmiColors[2] ));
+    if (!info) return;
+    info->bmiHeader.biSize = sizeof(info->bmiHeader);
+    info->bmiHeader.biWidth = size.cx;
+    info->bmiHeader.biHeight = size.cy;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biCompression = BI_RGB;
+
+    hdc = CreateCompatibleDC( 0 );
+    if (!(dib = CreateDIBSection( 0, info, DIB_RGB_COLORS, &color_bits, NULL, 0 ))) goto done;
+    SelectObject( hdc, dib );
+    DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_NORMAL );
+
+    /* check if the icon was drawn with an alpha channel */
+    for (i = 0, ptr = color_bits; i < size.cx * size.cy; i++)
+        if ((has_alpha = (ptr[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (size.cx + 31) / 32 * 4;
+
+        info->bmiHeader.biBitCount = 1;
+        info->bmiColors[0].rgbRed      = 0;
+        info->bmiColors[0].rgbGreen    = 0;
+        info->bmiColors[0].rgbBlue     = 0;
+        info->bmiColors[0].rgbReserved = 0;
+        info->bmiColors[1].rgbRed      = 0xff;
+        info->bmiColors[1].rgbGreen    = 0xff;
+        info->bmiColors[1].rgbBlue     = 0xff;
+        info->bmiColors[1].rgbReserved = 0;
+
+        if (!(mask = CreateDIBSection( 0, info, DIB_RGB_COLORS, &mask_bits, NULL, 0 ))) goto done;
+        memset( mask_bits, 0xff, width_bytes * size.cy );
+        SelectObject( hdc, mask );
+        DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_MASK );
+
+        for (y = 0, ptr = color_bits; y < size.cy; y++)
+            for (x = 0; x < size.cx; x++, ptr++)
+                if (!((((BYTE *)mask_bits)[y * width_bytes + x / 8] << (x % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+
+        SelectObject( hdc, dib );
+        DeleteObject( mask );
+    }
+
+    UpdateLayeredWindow( icon->window, 0, NULL, NULL, hdc, NULL, 0, &blend, ULW_ALPHA );
+done:
+    HeapFree (GetProcessHeap(), 0, info);
+    if (hdc) DeleteDC( hdc );
+    if (dib) DeleteObject( dib );
+}
+
+static BOOL notify_owner( struct tray_icon *icon, UINT msg, LPARAM lparam )
+{
+    WPARAM wp = icon->id;
+    LPARAM lp = msg;
+
+    if (icon->version >= NOTIFYICON_VERSION_4)
+    {
+        POINT pt = { (short)LOWORD(lparam), (short)HIWORD(lparam) };
+
+        ClientToScreen( icon->window, &pt );
+        wp = MAKEWPARAM( pt.x, pt.y );
+        lp = MAKELPARAM( msg, icon->id );
+    }
+
+    TRACE( "relaying 0x%x\n", msg );
+    if (!SendNotifyMessageW( icon->owner, icon->callback_message, wp, lp ) &&
+        (GetLastError() == ERROR_INVALID_WINDOW_HANDLE))
+    {
+        WARN( "application window was destroyed, removing icon %u\n", icon->id );
+        delete_icon( icon );
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/* window procedure for the individual tray icon window */
+static LRESULT WINAPI tray_icon_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    struct tray_icon *icon = NULL;
+
+    TRACE("hwnd=%p, msg=0x%x\n", hwnd, msg);
+
+    /* set the icon data for the window from the data passed into CreateWindow */
+    if (msg == WM_NCCREATE)
+        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LPARAM)((const CREATESTRUCTW *)lparam)->lpCreateParams);
+
+    icon = (struct tray_icon *) GetWindowLongPtrW(hwnd, GWLP_USERDATA);
+
+    switch (msg)
+    {
+    case WM_SIZE:
+        if (icon->window && icon->layered) repaint_tray_icon( icon );
+        break;
+
+    case WM_PAINT:
+        if (!icon->layered)
+        {
+            PAINTSTRUCT ps;
+            RECT rc;
+            HDC hdc;
+            int cx = GetSystemMetrics( SM_CXSMICON );
+            int cy = GetSystemMetrics( SM_CYSMICON );
+
+            hdc = BeginPaint(hwnd, &ps);
+            GetClientRect(hwnd, &rc);
+            TRACE("painting rect %s\n", wine_dbgstr_rect(&rc));
+            DrawIconEx( hdc, (rc.left + rc.right - cx) / 2, (rc.top + rc.bottom - cy) / 2,
+                        icon->image, cx, cy, 0, 0, DI_DEFAULTSIZE|DI_NORMAL );
+            EndPaint(hwnd, &ps);
+            return 0;
+        }
+        break;
+
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_RBUTTONDOWN:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_LBUTTONDBLCLK:
+    case WM_RBUTTONDBLCLK:
+    case WM_MBUTTONDBLCLK:
+        notify_owner( icon, msg, lparam );
+        break;
+
+    case WM_LBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, NIN_SELECT, lparam );
+        break;
+
+    case WM_RBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, WM_CONTEXTMENU, lparam );
+        break;
+
+    case WM_WINDOWPOSCHANGED:
+        update_systray_balloon_position();
+        break;
+
+    case WM_TIMER:
+        switch (wparam)
+        {
+        case BALLOON_CREATE_TIMER:
+            balloon_create_timer( icon );
+            break;
+        case BALLOON_SHOW_TIMER:
+            balloon_timer();
+            break;
+        }
+        return 0;
+
+    case WM_CLOSE:
+        if (icon->display == -1)
+        {
+            TRACE( "icon %u no longer embedded\n", icon->id );
+            hide_icon( icon );
+            add_to_standalone_tray( icon );
+        }
+        return 0;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static BOOL init_systray(void)
+{
+    static BOOL init_done;
+    WNDCLASSEXW class;
+
+    if (init_done) return TRUE;
+
+    icon_cx = GetSystemMetrics( SM_CXSMICON ) + 2 * ICON_BORDER;
+    icon_cy = GetSystemMetrics( SM_CYSMICON ) + 2 * ICON_BORDER;
+
+    memset( &class, 0, sizeof(class) );
+    class.cbSize        = sizeof(class);
+    class.lpfnWndProc   = tray_icon_wndproc;
+    class.hIcon         = LoadIconW(0, (LPCWSTR)IDI_WINLOGO);
+    class.hCursor       = LoadCursorW( 0, (LPCWSTR)IDC_ARROW );
+    class.lpszClassName = icon_classname;
+    class.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register icon tray window class\n" );
+        return FALSE;
+    }
+
+    class.lpfnWndProc   = standalone_tray_wndproc;
+    class.hbrBackground = (HBRUSH)COLOR_WINDOW;
+    class.lpszClassName = tray_classname;
+    class.style         = CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register standalone tray window class\n" );
+        return FALSE;
+    }
+
+    init_done = TRUE;
+    return TRUE;
+}
+
+/* hide a tray icon */
+static BOOL hide_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (!icon->window) return TRUE;  /* already hidden */
+
+    DestroyWindow(icon->window);
+    DestroyWindow(icon->tooltip);
+    icon->window = 0;
+    icon->layered = FALSE;
+    icon->tooltip = 0;
+    remove_from_standalone_tray( icon );
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* make the icon visible */
+static BOOL show_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (icon->window) return TRUE;  /* already shown */
+
+    add_to_standalone_tray( icon );
+
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* Modifies an existing icon record */
+static BOOL modify_icon( struct tray_icon *icon, NOTIFYICONDATAW *nid )
+{
+    TRACE( "id=0x%x hwnd=%p flags=%x\n", nid->uID, nid->hWnd, nid->uFlags );
+
+    if (nid->uFlags & NIF_STATE)
+    {
+        icon->state = (icon->state & ~nid->dwStateMask) | (nid->dwState & nid->dwStateMask);
+    }
+
+    if (nid->uFlags & NIF_ICON)
+    {
+        if (icon->image) DestroyIcon(icon->image);
+        icon->image = CopyIcon(nid->hIcon);
+        if (icon->window)
+        {
+            if (icon->display != -1) InvalidateRect( icon->window, NULL, TRUE );
+            else if (icon->layered) repaint_tray_icon( icon );
+        }
+    }
+
+    if (nid->uFlags & NIF_MESSAGE)
+    {
+        icon->callback_message = nid->uCallbackMessage;
+    }
+    if (nid->uFlags & NIF_TIP)
+    {
+        lstrcpynW(icon->tiptext, nid->szTip, ARRAY_SIZE( icon->tiptext ));
+        if (icon->tooltip) update_tooltip_text(icon);
+    }
+    if (nid->uFlags & NIF_INFO && nid->cbSize >= NOTIFYICONDATAA_V2_SIZE)
+    {
+        lstrcpynW( icon->info_text, nid->szInfo, ARRAY_SIZE( icon->info_text ));
+        lstrcpynW( icon->info_title, nid->szInfoTitle, ARRAY_SIZE( icon->info_title ));
+        icon->info_flags = nid->dwInfoFlags;
+        icon->info_timeout = max(min(nid->u.uTimeout, BALLOON_SHOW_MAX_TIMEOUT), BALLOON_SHOW_MIN_TIMEOUT);
+        icon->info_icon = nid->hBalloonIcon;
+        update_balloon( icon );
+    }
+    if (icon->state & NIS_HIDDEN) hide_icon( icon );
+    else show_icon( icon );
+    return TRUE;
+}
+
+/* Adds a new icon record to the list */
+static BOOL add_icon(NOTIFYICONDATAW *nid)
+{
+    struct tray_icon  *icon;
+
+    TRACE("id=0x%x, hwnd=%p\n", nid->uID, nid->hWnd);
+
+    if ((icon = get_icon(nid->hWnd, nid->uID)))
+    {
+        WARN("duplicate tray icon add, buggy app?\n");
+        return FALSE;
+    }
+
+    if (!(icon = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*icon))))
+    {
+        ERR("out of memory\n");
+        return FALSE;
+    }
+
+    icon->id     = nid->uID;
+    icon->owner  = nid->hWnd;
+    icon->display = -1;
+
+    list_add_tail(&icon_list, &icon->entry);
+
+    return modify_icon( icon, nid );
+}
+
+/* delete tray icon window and icon structure */
+static BOOL delete_icon( struct tray_icon *icon )
+{
+    hide_icon( icon );
+    list_remove( &icon->entry );
+    DestroyIcon( icon->image );
+    HeapFree( GetProcessHeap(), 0, icon );
+    return TRUE;
+}
+
+/* cleanup all icons for a given window */
+static void cleanup_icons( HWND owner )
+{
+    struct tray_icon *this, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( this, next, &icon_list, struct tray_icon, entry )
+        if (this->owner == owner) delete_icon( this );
+}
+
+
+/***********************************************************************
+ *              wine_notify_icon
+ *
+ * Driver-side implementation of Shell_NotifyIcon.
+ */
+int CDECL wine_notify_icon( DWORD msg, NOTIFYICONDATAW *data )
+{
+    BOOL ret = FALSE;
+    struct tray_icon *icon;
+
+    switch (msg)
+    {
+    case NIM_ADD:
+        if (!init_systray()) return -1;  /* fall back to default handling */
+        ret = add_icon( data );
+        break;
+    case NIM_DELETE:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = delete_icon( icon );
+        break;
+    case NIM_MODIFY:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = modify_icon( icon, data );
+        break;
+    case NIM_SETVERSION:
+        if ((icon = get_icon( data->hWnd, data->uID )))
+        {
+            icon->version = data->u.uVersion;
+            ret = TRUE;
+        }
+        break;
+    case 0xdead:  /* Wine extension: owner window has died */
+        cleanup_icons( data->hWnd );
+        break;
+    default:
+        FIXME( "unhandled tray message: %u\n", msg );
+        break;
+    }
+    return ret;
+}
diff --git a/dlls/winewayland.drv/unicode.c b/dlls/winewayland.drv/unicode.c
new file mode 100644
index 00000000000..7cce78573a7
--- /dev/null
+++ b/dlls/winewayland.drv/unicode.c
@@ -0,0 +1,105 @@
+/*
+ * Wayland driver unicode helpers
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+/**********************************************************************
+ *          ascii_to_unicode_maybe_z
+ *
+ * Converts an ascii, possibly zero-terminated, string containing up to
+ * src_max_chars to a unicode string. Returns the number of characters
+ * (including any trailing zero) in the source ascii string. If the returned
+ * number of characters is greater than dst_max_chars the output will have been
+ * truncated.
+ */
+size_t ascii_to_unicode_maybe_z(WCHAR *dst, size_t dst_max_chars,
+                                const char *src, size_t src_max_chars)
+{
+    size_t src_len = 0;
+
+    while (src_max_chars--)
+    {
+        src_len++;
+        if (dst_max_chars)
+        {
+            *dst++ = *src;
+            dst_max_chars--;
+        }
+        if (!*src++) break;
+    }
+
+    return src_len;
+}
+
+/**********************************************************************
+ *          unicode_to_ascii_maybe_z
+ *
+ * Converts a unicode, possibly zero-terminated, string containing up to
+ * src_max_chars to an ascii string. Returns the number of characters
+ * (including any trailing zero) in the source unicode string. If the returned
+ * number of characters is greater than dst_max_chars the output will have been
+ * truncated.
+ */
+size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
+                                const WCHAR *src, size_t src_max_chars)
+{
+    size_t src_len = 0;
+
+    while (src_max_chars--)
+    {
+        src_len++;
+        if (dst_max_chars)
+        {
+            *dst++ = *src;
+            dst_max_chars--;
+        }
+        if (!*src++) break;
+    }
+
+    return src_len;
+}
+
+/**********************************************************************
+ *          ascii_to_unicode_z
+ *
+ * Converts an ascii, possibly zero-terminated, string containing up to
+ * src_max_chars to a zero-terminated unicode string. Returns the number of
+ * characters (including the trailing zero) written to the destination string.
+ * If there isn't enough space in the destination to hold all the characters
+ * and the trailing zero, the string is truncated enough so that a trailing
+ * zero can be placed.
+ */
+size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
+                          const char *src, size_t src_max_chars)
+{
+    size_t len;
+    if (src_max_chars == 0) return 0;
+    len = ascii_to_unicode_maybe_z(dst, dst_max_chars, src, src_max_chars);
+    if (len >= dst_max_chars) len = dst_max_chars - 1;
+    if (len > 0 && dst[len - 1] == 0) len--;
+    dst[len] = 0;
+    return len + 1;
+}
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
new file mode 100644
index 00000000000..989d8d044db
--- /dev/null
+++ b/dlls/winewayland.drv/unixlib.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_UNIXLIB_H
+#define __WINE_WAYLANDDRV_UNIXLIB_H
+
+#include "windef.h"
+#include "ntuser.h"
+#include "wine/unixlib.h"
+
+/* A pointer to memory that is guaranteed to be usable by both 32-bit and
+ * 64-bit processes. */
+typedef UINT PTR32;
+/* A handle value that is guaranteed to be usable by both 32-bit and 64-bit
+ * processes. */
+typedef UINT HANDLE32;
+
+enum waylanddrv_unix_func
+{
+    waylanddrv_unix_func_init,
+    waylanddrv_unix_func_read_events,
+    waylanddrv_unix_func_clipboard_message,
+    waylanddrv_unix_func_data_offer_accept_format,
+    waylanddrv_unix_func_data_offer_enum_formats,
+    waylanddrv_unix_func_data_offer_import_format,
+    waylanddrv_unix_func_count,
+};
+
+struct waylanddrv_unix_init_params
+{
+    BOOL option_show_systray;
+};
+
+struct waylanddrv_unix_clipboard_message_params
+{
+    HWND hwnd;
+    UINT msg;
+    WPARAM wparam;
+    LPARAM lparam;
+};
+
+struct waylanddrv_unix_data_offer_accept_format_params
+{
+    PTR32 data_offer;
+    UINT format;
+};
+
+struct waylanddrv_unix_data_offer_enum_formats_params
+{
+    PTR32 data_offer;
+    UINT *formats;
+    UINT num_formats;
+};
+
+struct waylanddrv_unix_data_offer_import_format_params
+{
+    PTR32 data_offer;
+    UINT format;
+    PTR32 data;
+    UINT size;
+};
+
+/* driver client callbacks exposed with KernelCallbackTable interface */
+enum waylanddrv_client_func
+{
+    waylanddrv_client_func_create_clipboard_window = NtUserDriverCallbackFirst,
+    waylanddrv_client_func_dnd,
+    waylanddrv_client_func_last
+};
+
+C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
+
+enum waylanddrv_client_dnd_event
+{
+    CLIENT_DND_EVENT_ENTER,
+    CLIENT_DND_EVENT_LEAVE,
+    CLIENT_DND_EVENT_MOTION,
+    CLIENT_DND_EVENT_DROP,
+};
+
+struct waylanddrv_client_dnd_params
+{
+    UINT event;
+    HANDLE32 hwnd;
+    POINT point;
+    DWORD drop_effect;
+    PTR32 data_object;
+};
+
+#endif /* __WINE_WAYLANDDRV_UNIXLIB_H */
diff --git a/dlls/winewayland.drv/version.rc b/dlls/winewayland.drv/version.rc
new file mode 100644
index 00000000000..2d99c24f99c
--- /dev/null
+++ b/dlls/winewayland.drv/version.rc
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine Wayland driver"
+#define WINE_FILENAME_STR "winewayland.drv"
+
+#include "wine/wine_common_ver.rc"
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
new file mode 100644
index 00000000000..c968842608f
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan.c
@@ -0,0 +1,1600 @@
+/* WAYLANDDRV Vulkan implementation
+ *
+ * Copyright 2017 Roderick Colenbrander
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+#include "vulkan_remote.h"
+
+#include <assert.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+#ifdef SONAME_LIBVULKAN
+
+#define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
+
+typedef struct VkWaylandSurfaceCreateInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkWaylandSurfaceCreateFlagsKHR flags;
+    struct wl_display *display;
+    struct wl_surface *surface;
+} VkWaylandSurfaceCreateInfoKHR;
+
+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
+static VkResult (*pvkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
+static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
+static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
+static void(*pvkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
+static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
+static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
+static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkEnumerateDeviceExtensionProperties)(VkPhysicalDevice, const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
+static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
+static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
+static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
+static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
+static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
+static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
+
+static void *vulkan_handle;
+
+static struct wayland_mutex wine_vk_object_mutex =
+{
+    PTHREAD_MUTEX_INITIALIZER, 0, 0, __FILE__ ": wine_vk_object_mutex"
+};
+
+static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
+static struct wl_list wine_vk_device_list = { &wine_vk_device_list, &wine_vk_device_list };
+
+static const struct vulkan_funcs vulkan_funcs;
+
+/* These instance extensions are required to support Vulkan remote. Some of them
+ * might not be supported by the device, so we must check. */
+const static char *instance_extensions_remote_vulkan[] =
+{
+    "VK_KHR_external_fence_capabilities",
+    "VK_KHR_external_memory_capabilities",
+    "VK_KHR_external_semaphore_capabilities",
+    "VK_KHR_get_physical_device_properties2",
+};
+
+/* These device extensions are required to support Vulkan remote. Some of them
+ * might not be supported by the device, so we must check. */
+const static char *device_extensions_remote_vulkan[] =
+{
+    "VK_KHR_external_fence",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory",
+    "VK_KHR_external_memory_fd",
+    "VK_KHR_external_semaphore",
+    "VK_KHR_external_semaphore_fd",
+};
+
+struct wine_vk_device
+{
+    struct wl_list link;
+    VkDevice dev;
+    VkPhysicalDevice phys_dev;
+    BOOL supports_remote_vulkan;
+};
+
+struct wine_vk_surface
+{
+    struct wl_list link;
+    HWND hwnd;
+    VkInstance instance;
+    struct wayland_surface *wayland_surface;
+    /* Used when we are rendering cross-process and we don't have the real
+     * wayland surface available. */
+    struct wl_surface *dummy_wl_surface;
+    VkSurfaceKHR native_vk_surface;
+    BOOL valid;
+};
+
+struct wine_vk_swapchain
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wine_vk_device *wine_vk_device;
+    struct wayland_surface *wayland_surface;
+    VkSwapchainKHR native_vk_swapchain;
+    VkExtent2D extent;
+    BOOL valid;
+    /* Only used for cross-process Vulkan rendering apps. */
+    struct wayland_remote_vk_swapchain *remote_vk_swapchain;
+    PFN_vkGetSemaphoreFdKHR p_vkGetSemaphoreFdKHR;
+};
+
+static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
+{
+    wayland_mutex_lock(&wine_vk_object_mutex);
+    wl_list_insert(list, link);
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+static inline void wine_vk_list_remove(struct wl_list *link)
+{
+    wayland_mutex_lock(&wine_vk_object_mutex);
+    wl_list_remove(link);
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
+{
+    wine_vk_list_remove(&wine_vk_surface->link);
+
+    if (wine_vk_surface->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_surface->wayland_surface);
+    if (wine_vk_surface->dummy_wl_surface)
+        wl_surface_destroy(wine_vk_surface->dummy_wl_surface);
+
+    free(wine_vk_surface);
+}
+
+static struct wine_vk_surface *wine_vk_surface_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *surf;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+        if (surf->native_vk_surface == handle) goto out;
+
+    surf = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return surf;
+}
+
+static BOOL wine_vk_surface_handle_is_valid(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(handle);
+    return wine_vk_surface && __atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST);
+}
+
+static BOOL wine_vk_surface_is_remote(struct wine_vk_surface *wine_vk_surface)
+{
+    return wine_vk_surface && wine_vk_surface->dummy_wl_surface;
+}
+
+static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    wine_vk_list_remove(&wine_vk_swapchain->link);
+
+    if (wine_vk_swapchain->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
+
+    if (wine_vk_swapchain->remote_vk_swapchain)
+        wayland_remote_vk_swapchain_destroy(wine_vk_swapchain->remote_vk_swapchain,
+                                            wine_vk_swapchain->wine_vk_device->dev);
+
+    free(wine_vk_swapchain);
+}
+
+static struct wine_vk_swapchain *wine_vk_swapchain_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_swapchain *swap;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+        if (swap->native_vk_swapchain == handle) goto out;
+
+    swap = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return swap;
+}
+
+static BOOL wine_vk_swapchain_is_remote(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    return wine_vk_swapchain && wine_vk_swapchain->remote_vk_swapchain;
+}
+
+static BOOL vk_extension_props_contain_all(uint32_t count_props,
+                                           VkExtensionProperties *props,
+                                           uint32_t count_required,
+                                           const char * const *required)
+{
+    BOOL supported;
+    unsigned int i, j;
+
+    for (i = 0; i < count_required; i++)
+    {
+        supported = FALSE;
+        for (j = 0; j < count_props; j++)
+        {
+            if (strcmp(props[j].extensionName, required[i]) == 0)
+            {
+                supported = TRUE;
+                break;
+            }
+        }
+        if (!supported)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL vulkan_instance_supports(size_t num_exts, const char **exts)
+{
+    VkExtensionProperties *props = NULL;
+    uint32_t count_props;
+    VkResult vk_res;
+    BOOL res = TRUE;
+
+    vk_res = pvkEnumerateInstanceExtensionProperties(NULL, &count_props, NULL);
+    if (vk_res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateInstanceExtensionProperties failed, res=%d\n", vk_res);
+        res = FALSE;
+        goto out;
+    }
+    props = calloc(count_props, sizeof(*props));
+    if (!props)
+    {
+        ERR("Failed to allocate memory\n");
+        res = FALSE;
+        goto out;
+    }
+    vk_res = pvkEnumerateInstanceExtensionProperties(NULL, &count_props, props);
+    if (vk_res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateInstanceExtensionProperties failed, res=%d\n", vk_res);
+        res = FALSE;
+        goto out;
+    }
+
+    /* These extensions are required to support the remote Vulkan, but may
+     * not be present. */
+    res = vk_extension_props_contain_all(count_props, props, num_exts, exts);
+
+out:
+    free(props);
+    return res;
+}
+
+/* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
+ * Caller is responsible for allocation and cleanup of 'dst'.
+ */
+static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
+                                                     VkInstanceCreateInfo *dst)
+{
+    BOOL supports_remote_vulkan =
+        vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                            instance_extensions_remote_vulkan);
+    unsigned int i, j;
+    uint32_t enabled_extensions_count;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pApplicationInfo = src->pApplicationInfo;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions_count = src->enabledExtensionCount;
+        if (supports_remote_vulkan)
+            enabled_extensions_count += ARRAY_SIZE(instance_extensions_remote_vulkan);
+
+        enabled_extensions = calloc(enabled_extensions_count, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            goto err;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+        {
+            /* Substitute extension with Wayland ones else copy. Long-term, when we
+             * support more extensions, we should store these in a list.
+             */
+            if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_surface"))
+                enabled_extensions[i] = "VK_KHR_wayland_surface";
+            else
+                enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+        }
+
+        if (supports_remote_vulkan)
+        {
+            /* Add the extensions required to support remote Vulkan */
+            for (j = 0; j < ARRAY_SIZE(instance_extensions_remote_vulkan); j++, i++)
+                enabled_extensions[i] = instance_extensions_remote_vulkan[j];
+        }
+
+         dst->ppEnabledExtensionNames = enabled_extensions;
+         dst->enabledExtensionCount = enabled_extensions_count;
+    }
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to convert instance create info\n");
+    free(enabled_extensions);
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
+
+#define RETURN_VK_ERROR_SURFACE_LOST_KHR { \
+    TRACE("VK_ERROR_SURFACE_LOST_KHR\n"); \
+    return VK_ERROR_SURFACE_LOST_KHR; \
+}
+
+static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
+                                         const VkAllocationCallbacks *allocator,
+                                         VkInstance *instance)
+{
+    VkInstanceCreateInfo create_info_host;
+    VkResult res;
+    TRACE("create_info %p, allocator %p, instance %p\n", create_info, allocator, instance);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Perform a second pass on converting VkInstanceCreateInfo. Winevulkan
+     * performed a first pass in which it handles everything except for WSI
+     * functionality such as VK_KHR_win32_surface. Handle this now.
+     */
+    res = wine_vk_instance_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to convert instance create info, res=%d\n", res);
+        return res;
+    }
+
+    res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
+static VkResult wine_vk_device_convert_create_info(struct wine_vk_device *wine_vk_device,
+                                                   const VkDeviceCreateInfo *src,
+                                                   VkDeviceCreateInfo *dst)
+{
+    unsigned int i, j;
+    uint32_t enabled_extensions_count;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+    dst->pEnabledFeatures = src->pEnabledFeatures;
+    dst->pQueueCreateInfos = src->pQueueCreateInfos;
+    dst->queueCreateInfoCount = src->queueCreateInfoCount;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions_count = src->enabledExtensionCount;
+        if (wine_vk_device->supports_remote_vulkan)
+            enabled_extensions_count += ARRAY_SIZE(device_extensions_remote_vulkan);
+
+        enabled_extensions = calloc(enabled_extensions_count, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            goto err;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+            enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+
+        if (wine_vk_device->supports_remote_vulkan)
+        {
+            /* Add the extensions required to support remote Vulkan */
+            for (j = 0; j < ARRAY_SIZE(device_extensions_remote_vulkan); j++, i++)
+                enabled_extensions[i] = device_extensions_remote_vulkan[j];
+        }
+
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = enabled_extensions_count;
+    }
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to convert device create info\n");
+    free(enabled_extensions);
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
+
+static struct wine_vk_device *wine_vk_device_from_handle(VkDevice handle)
+{
+    struct wine_vk_device *wine_vk_device;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(wine_vk_device, &wine_vk_device_list, link)
+        if (wine_vk_device->dev == handle) goto out;
+
+    wine_vk_device = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return wine_vk_device;
+}
+
+static void wine_vk_device_destroy(struct wine_vk_device *wine_vk_device)
+{
+    wine_vk_list_remove(&wine_vk_device->link);
+    free(wine_vk_device);
+}
+
+static VkResult wayland_vkCreateDevice(VkPhysicalDevice physical_device,
+                                       const VkDeviceCreateInfo *create_info,
+                                       const VkAllocationCallbacks *allocator,
+                                       VkDevice *device)
+{
+    VkDeviceCreateInfo create_info_host = {0};
+    VkResult res;
+    struct wine_vk_device *wine_vk_device;
+    VkExtensionProperties *props = NULL;
+    uint32_t count_props;
+
+    TRACE("%p %p %p %p\n", physical_device, create_info, allocator, device);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_device = calloc(1, sizeof(*wine_vk_device));
+    if (!wine_vk_device)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    res = pvkEnumerateDeviceExtensionProperties(physical_device, NULL, &count_props, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateDeviceExtensionProperties failed, res=%d\n", res);
+        goto err;
+    }
+    props = calloc(count_props, sizeof(*props));
+    if (!props)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+    res = pvkEnumerateDeviceExtensionProperties(physical_device, NULL, &count_props, props);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkEnumerateDeviceExtensionProperties failed, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_device->supports_remote_vulkan =
+        vk_extension_props_contain_all(count_props, props,
+                                       ARRAY_SIZE(device_extensions_remote_vulkan),
+                                       device_extensions_remote_vulkan) &&
+        vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                 instance_extensions_remote_vulkan);
+
+    free(props);
+    props = NULL;
+
+    res = wine_vk_device_convert_create_info(wine_vk_device, create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    res = pvkCreateDevice(physical_device, &create_info_host, NULL /* allocator */, device);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create VkDevice, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_device->dev = *device;
+    wine_vk_device->phys_dev = physical_device;
+
+    wl_list_init(&wine_vk_device->link);
+
+    wine_vk_list_add(&wine_vk_device_list, &wine_vk_device->link);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+
+err:
+    ERR("Failed to create VkDevice\n");
+    free(wine_vk_device);
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
+static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
+                                             const VkSwapchainCreateInfoKHR *create_info,
+                                             const VkAllocationCallbacks *allocator,
+                                             VkSwapchainKHR *swapchain)
+{
+    VkResult res;
+    struct wine_vk_device *wine_vk_device;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    VkSwapchainCreateInfoKHR info = *create_info;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Wayland can't deal with 0x0 swapchains, use the minimum 1x1. */
+    if (info.imageExtent.width == 0)
+        info.imageExtent.width = 1;
+    if (info.imageExtent.height == 0)
+        info.imageExtent.height = 1;
+
+    wine_vk_device = wine_vk_device_from_handle(device);
+    if (!wine_vk_device)
+        return VK_ERROR_DEVICE_LOST;
+
+    wine_vk_surface = wine_vk_surface_from_handle(info.surface);
+    if (!wine_vk_surface || !__atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    wine_vk_swapchain = calloc(1, sizeof(*wine_vk_swapchain));
+    if (!wine_vk_swapchain)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_swapchain->link);
+
+    res = pvkCreateSwapchainKHR(device, &info, NULL /* allocator */, swapchain);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    wine_vk_swapchain->hwnd = wine_vk_surface->hwnd;
+    if (wine_vk_surface->wayland_surface)
+    {
+        if (!wayland_surface_create_or_ref_glvk(wine_vk_surface->wayland_surface))
+        {
+            ERR("Failed to create or ref vulkan surface owned by " \
+                "wine_vk_surface=%p\n", wine_vk_surface);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
+    }
+    else
+    {
+        if (!wine_vk_device->supports_remote_vulkan)
+        {
+            ERR("Failed to create remote Vulkan swapchain, required extensions " \
+                "not supported by VkDevice %p\n", wine_vk_device->dev);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->remote_vk_swapchain =
+            wayland_remote_vk_swapchain_create(wine_vk_swapchain->hwnd,
+                                               wine_vk_surface->instance,
+                                               wine_vk_device->phys_dev,
+                                               wine_vk_device->dev,
+                                               &vulkan_funcs,
+                                               &info);
+        if (!wine_vk_swapchain->remote_vk_swapchain)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_swapchain->p_vkGetSemaphoreFdKHR =
+            pvkGetDeviceProcAddr(device, "vkGetSemaphoreFdKHR");
+        if (!wine_vk_swapchain->p_vkGetSemaphoreFdKHR)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+
+    wine_vk_swapchain->wine_vk_device = wine_vk_device;
+    wine_vk_swapchain->native_vk_swapchain = *swapchain;
+    wine_vk_swapchain->extent = info.imageExtent;
+    wine_vk_swapchain->valid = TRUE;
+
+    wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
+
+    return res;
+
+err:
+    wine_vk_swapchain_destroy(wine_vk_swapchain);
+    return res;
+}
+
+static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
+                                                const VkWin32SurfaceCreateInfoKHR *create_info,
+                                                const VkAllocationCallbacks *allocator,
+                                                VkSurfaceKHR *vk_surface)
+{
+    VkResult res;
+    VkWaylandSurfaceCreateInfoKHR create_info_host;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wayland_surface *wayland_surface;
+    BOOL ref_vk;
+
+    TRACE("%p %p %p %p\n", instance, create_info, allocator, vk_surface);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_surface = calloc(1, sizeof(*wine_vk_surface));
+    if (!wine_vk_surface)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_surface->link);
+
+    wayland_surface = wayland_surface_for_hwnd_lock(create_info->hwnd);
+    if (wayland_surface)
+    {
+        ref_vk = wayland_surface_create_or_ref_glvk(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_vk)
+        {
+            ERR("Failed to create or ref vulkan surface for hwnd=%p\n", create_info->hwnd);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wine_vk_surface->wayland_surface = wayland_surface;
+    }
+    else
+    {
+        struct wayland *wayland;
+        if (!vulkan_instance_supports(ARRAY_SIZE(instance_extensions_remote_vulkan),
+                                      instance_extensions_remote_vulkan))
+        {
+            ERR("Failed to create remote Vulkan surface, required extensions " \
+                "not supported by VkInstance %p\n", instance);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+        wayland = wayland_process_acquire();
+        wine_vk_surface->dummy_wl_surface =
+            wl_compositor_create_surface(wayland->wl_compositor);
+        wayland_process_release();
+        if (!wine_vk_surface->dummy_wl_surface)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+    }
+
+    create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
+    create_info_host.pNext = NULL;
+    create_info_host.flags = 0; /* reserved */
+    create_info_host.display = process_wl_display;
+    if (wine_vk_surface->wayland_surface)
+        create_info_host.surface = wine_vk_surface->wayland_surface->glvk->wl_surface;
+    else
+        create_info_host.surface = wine_vk_surface->dummy_wl_surface;
+
+    res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host, NULL /* allocator */, vk_surface);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create vulkan wayland surface, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_surface->hwnd = create_info->hwnd;
+    wine_vk_surface->instance = instance;
+    wine_vk_surface->native_vk_surface = *vk_surface;
+    wine_vk_surface->valid = TRUE;
+
+    wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
+
+    TRACE("Created surface=0x%s\n", wine_dbgstr_longlong(*vk_surface));
+    return VK_SUCCESS;
+
+err:
+    wine_vk_surface_destroy(wine_vk_surface);
+    return res;
+}
+
+static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
+{
+    TRACE("%p %p\n", instance, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    pvkDestroyInstance(instance, NULL /* allocator */);
+}
+
+static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
+                                        const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+
+    TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_surface)
+    {
+        pvkDestroySurfaceKHR(instance, wine_vk_surface->native_vk_surface,
+                             NULL /* allocator */);
+        wine_vk_surface_destroy(wine_vk_surface);
+    }
+}
+
+static void wayland_vkDestroySwapchainKHR(VkDevice device,
+                                          VkSwapchainKHR swapchain,
+                                          const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_swapchain)
+    {
+        pvkDestroySwapchainKHR(device, wine_vk_swapchain->native_vk_swapchain,
+                               NULL /* allocator */);
+        wine_vk_swapchain_destroy(wine_vk_swapchain);
+    }
+}
+
+static void wayland_vkDestroyDevice(VkDevice device,
+                                    const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_device *wine_vk_device = wine_vk_device_from_handle(device);
+
+    TRACE("%p %p\n", device, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_device)
+    {
+        pvkDestroyDevice(device, NULL /* allocator */);
+        wine_vk_device_destroy(wine_vk_device);
+    }
+}
+
+static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer_name,
+                                                               uint32_t *count,
+                                                               VkExtensionProperties* properties)
+{
+    unsigned int i;
+    VkResult res;
+
+    TRACE("layer_name %s, count %p, properties %p\n", debugstr_a(layer_name), count, properties);
+
+    /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
+    if (layer_name)
+    {
+        ERR("Layer enumeration not supported from ICD.\n");
+        return VK_ERROR_LAYER_NOT_PRESENT;
+    }
+
+    /* We will return the same number of instance extensions reported by the host back to
+     * winevulkan. Along the way we may replace xlib extensions with their win32 equivalents.
+     * Winevulkan will perform more detailed filtering as it knows whether it has thunks
+     * for a particular extension.
+     */
+    res = pvkEnumerateInstanceExtensionProperties(layer_name, count, properties);
+    if (!properties || res < 0)
+        return res;
+
+    for (i = 0; i < *count; i++)
+    {
+        /* For now the only wayland extension we need to fixup. Long-term we may need an array. */
+        if (!strcmp(properties[i].extensionName, "VK_KHR_wayland_surface"))
+        {
+            TRACE("Substituting VK_KHR_wayland_surface for VK_KHR_win32_surface\n");
+
+            snprintf(properties[i].extensionName, sizeof(properties[i].extensionName),
+                    VK_KHR_WIN32_SURFACE_EXTENSION_NAME);
+            properties[i].specVersion = VK_KHR_WIN32_SURFACE_SPEC_VERSION;
+        }
+    }
+
+    TRACE("Returning %u extensions.\n", *count);
+    return res;
+}
+
+static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
+                                                               VkSurfaceKHR surface,
+                                                               VkDeviceGroupPresentModeFlagsKHR *flags)
+{
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(surface), flags);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
+}
+
+static void *wayland_vkGetDeviceProcAddr(VkDevice device, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", device, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_device_proc_addr(&vulkan_funcs, name)))
+        return proc_addr;
+
+    return pvkGetDeviceProcAddr(device, name);
+}
+
+static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", instance, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_instance_proc_addr(&vulkan_funcs, instance, name)))
+        return proc_addr;
+
+    return pvkGetInstanceProcAddr(instance, name);
+}
+
+static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice phys_dev,
+                                                                VkSurfaceKHR surface,
+                                                                uint32_t *count, VkRect2D *rects)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, rects);
+
+    return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
+}
+
+/* Set the image extent in the capabilities to match what Windows expects. */
+static void set_image_extent(VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *caps)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    BOOL zero_extents = FALSE;
+
+    if (!wine_vk_surface)
+        return;
+
+    if (wine_vk_surface_is_remote(wine_vk_surface))
+    {
+        /* For cross-process surfaces, we don't have the information of
+         * drawing_allowed. So we set zero_extents to FALSE. That is safe to do
+         * because the process that will call wl_surface_commit() won't commit
+         * anything when drawing_allowed == FALSE. */
+        zero_extents = FALSE;
+    }
+    else
+    {
+        assert(wine_vk_surface->wayland_surface);
+        wayland_mutex_lock(&wine_vk_surface->wayland_surface->mutex);
+        if (!wine_vk_surface->wayland_surface->drawing_allowed)
+            zero_extents = TRUE;
+        wayland_mutex_unlock(&wine_vk_surface->wayland_surface->mutex);
+    }
+
+    if (NtUserGetWindowLongW(wine_vk_surface->hwnd, GWL_STYLE) & WS_MINIMIZE)
+        zero_extents = TRUE;
+
+    if (zero_extents)
+    {
+        caps->minImageExtent.width = 0;
+        caps->minImageExtent.height = 0;
+        caps->maxImageExtent.width = 0;
+        caps->maxImageExtent.height = 0;
+        caps->currentExtent.width = 0;
+        caps->currentExtent.height = 0;
+    }
+    else
+    {
+        RECT client;
+        NtUserGetClientRect(wine_vk_surface->hwnd, &client);
+
+        caps->minImageExtent.width = client.right;
+        caps->minImageExtent.height = client.bottom;
+        caps->maxImageExtent.width = client.right;
+        caps->maxImageExtent.height = client.bottom;
+        caps->currentExtent.width = client.right;
+        caps->currentExtent.height = client.bottom;
+    }
+
+    TRACE("vk_surface=%s hwnd=%p wayland_surface=%p dummy_wl_surface=%p extent=%dx%d\n",
+          wine_dbgstr_longlong(surface), wine_vk_surface->hwnd,
+          wine_vk_surface->wayland_surface, wine_vk_surface->dummy_wl_surface,
+          caps->currentExtent.width, caps->currentExtent.height);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice phys_dev,
+                                                                   const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                                   VkSurfaceCapabilities2KHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceCapabilities2KHR)
+    {
+        res = pvkGetPhysicalDeviceSurfaceCapabilities2KHR(phys_dev, surface_info,
+                                                          capabilities);
+        goto out;
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext || capabilities->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with "
+              "vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface_info->surface,
+                                                     &capabilities->surfaceCapabilities);
+
+out:
+    if (res == VK_SUCCESS)
+        set_image_extent(surface_info->surface, &capabilities->surfaceCapabilities);
+
+    return res;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  VkSurfaceCapabilitiesKHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
+
+    if (res == VK_SUCCESS)
+        set_image_extent(surface, capabilities);
+
+    return res;
+}
+
+static VkResult get_surface_formats2(VkPhysicalDevice phys_dev,
+                                     const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                     uint32_t *count, VkSurfaceFormat2KHR *formats)
+{
+    struct wine_vk_surface *wine_vk_surface =
+        wine_vk_surface_from_handle(surface_info->surface);
+    uint32_t count_host_formats;
+    VkSurfaceFormat2KHR *host_formats = NULL;
+    VkResult res = VK_SUCCESS;
+
+    if (!wine_vk_surface_is_remote(wine_vk_surface))
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+
+    res = pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                 &count_host_formats, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormats2KHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    host_formats = calloc(count_host_formats, sizeof(*host_formats));
+    if (!host_formats)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto out;
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                 &count_host_formats, host_formats);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormats2KHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    res = wayland_remote_vk_filter_supported_formats(count, formats,
+                                                     count_host_formats, host_formats,
+                                                     sizeof(VkSurfaceFormat2KHR),
+                                                     offsetof(VkSurfaceFormat2KHR,
+                                                              surfaceFormat));
+    if (*count == 0)
+    {
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        ERR("Failed to find formats supported by both host and remote Vulkan\n");
+    }
+
+out:
+    if (res != VK_SUCCESS && res != VK_INCOMPLETE)
+        ERR("Failed to get surface formats\n");
+    free(host_formats);
+    return res;
+}
+
+static VkResult get_surface_formats(VkPhysicalDevice phys_dev, VkSurfaceKHR surface,
+                                    uint32_t *count, VkSurfaceFormatKHR *formats)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    uint32_t count_host_formats;
+    VkSurfaceFormatKHR *host_formats = NULL;
+    VkResult res = VK_SUCCESS;
+
+    if (!wine_vk_surface_is_remote(wine_vk_surface))
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                     count, formats);
+
+    res = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                &count_host_formats, NULL);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormatsKHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    host_formats = calloc(count_host_formats, sizeof(*host_formats));
+    if (!host_formats)
+    {
+        ERR("Failed to allocate memory\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto out;
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface,
+                                                &count_host_formats, host_formats);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pvkGetPhysicalDeviceSurfaceFormatsKHR failed, res=%d\n", res);
+        goto out;
+    }
+
+    res = wayland_remote_vk_filter_supported_formats(count, formats,
+                                                     count_host_formats, host_formats,
+                                                     sizeof(VkSurfaceFormatKHR), 0);
+    if (*count == 0)
+    {
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        ERR("Failed to find formats supported by both host and remote Vulkan\n");
+    }
+
+out:
+    if (res != VK_SUCCESS && res != VK_INCOMPLETE)
+        ERR("Failed to get surface formats\n");
+    free(host_formats);
+    return res;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
+                                                              const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                              uint32_t *count,
+                                                              VkSurfaceFormat2KHR *formats)
+{
+    VkSurfaceFormatKHR *formats_host;
+    uint32_t i;
+    VkResult result;
+    TRACE("%p, %p, %p, %p\n", phys_dev, surface_info, count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
+        return get_surface_formats2(phys_dev, surface_info, count, formats);
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceFormats2KHR with "
+              "vkGetPhysicalDeviceSurfaceFormatsKHR, pNext is ignored.\n");
+    }
+
+    if (!formats)
+        return get_surface_formats(phys_dev, surface_info->surface, count, NULL);
+
+    formats_host = calloc(*count, sizeof(*formats_host));
+    if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    result = get_surface_formats(phys_dev, surface_info->surface, count, formats_host);
+    if (result == VK_SUCCESS || result == VK_INCOMPLETE)
+    {
+        for (i = 0; i < *count; i++)
+            formats[i].surfaceFormat = formats_host[i];
+    }
+
+    free(formats_host);
+    return result;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice phys_dev,
+                                                             VkSurfaceKHR surface,
+                                                             uint32_t *count,
+                                                             VkSurfaceFormatKHR *formats)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return get_surface_formats(phys_dev, surface, count, formats);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  uint32_t *count,
+                                                                  VkPresentModeKHR *modes)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, modes);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice phys_dev,
+                                                             uint32_t index,
+                                                             VkSurfaceKHR surface,
+                                                             VkBool32 *supported)
+{
+    TRACE("%p, %u, 0x%s, %p\n", phys_dev, index, wine_dbgstr_longlong(surface), supported);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
+}
+
+static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice phys_dev,
+                                                                       uint32_t index)
+{
+    TRACE("%p %u\n", phys_dev, index);
+
+    return pvkGetPhysicalDeviceWaylandPresentationSupportKHR(phys_dev, index,
+                                                             process_wl_display);
+}
+
+static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p %p\n", device, wine_dbgstr_longlong(swapchain), count, images);
+
+    if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        return wayland_remote_vk_swapchain_get_images(wine_vk_swapchain->remote_vk_swapchain,
+                                                      count, images);
+
+    return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
+}
+
+static VkResult wayland_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                              uint64_t timeout, VkSemaphore semaphore,
+                                              VkFence fence, uint32_t *image_index)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p 0x%s 0x%s 0x%s 0x%s %p\n",
+          device, wine_dbgstr_longlong(swapchain), wine_dbgstr_longlong(timeout),
+          wine_dbgstr_longlong(semaphore), wine_dbgstr_longlong(fence), image_index);
+
+    if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        return wayland_remote_vk_swapchain_acquire_next_image(wine_vk_swapchain->remote_vk_swapchain,
+                                                              wine_vk_swapchain->wine_vk_device->dev,
+                                                              timeout, semaphore, fence, image_index);
+
+    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+}
+
+static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
+{
+    uint32_t i;
+    VkResult res = VK_SUCCESS;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+        BOOL drawing_allowed;
+        RECT client;
+
+        if (!wine_vk_swapchain)
+        {
+            drawing_allowed = FALSE;
+        }
+        else
+        {
+            if (wine_vk_swapchain_is_remote(wine_vk_swapchain))
+            {
+                /* For cross-process swapchains, we don't have the information
+                 * of drawing_allowed. So we assume it is TRUE. That is safe to
+                 * do because the process that will call wl_surface_commit()
+                 * won't commit anything when drawing_allowed == FALSE. */
+                drawing_allowed = TRUE;
+            }
+            else
+            {
+                assert(wine_vk_swapchain->wayland_surface);
+                drawing_allowed = wine_vk_swapchain->wayland_surface->drawing_allowed;
+            }
+        }
+
+        TRACE("swapchain[%d] vk=0x%s wine=%p extent=%dx%d wayland_surface=%p "
+               "remote_swapchain=%p drawing_allowed=%d\n",
+               i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.width : 0,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.height : 0,
+               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
+               wine_vk_swapchain ? wine_vk_swapchain->remote_vk_swapchain : NULL,
+               drawing_allowed);
+
+        if (!wine_vk_swapchain ||
+            !__atomic_load_n(&wine_vk_swapchain->valid, __ATOMIC_SEQ_CST) ||
+            !NtUserGetClientRect(wine_vk_swapchain->hwnd, &client))
+        {
+            res = VK_ERROR_SURFACE_LOST_KHR;
+        }
+        else if (client.right != wine_vk_swapchain->extent.width ||
+                 client.bottom != wine_vk_swapchain->extent.height ||
+                 !drawing_allowed)
+        {
+            if (res == VK_SUCCESS) res = VK_ERROR_OUT_OF_DATE_KHR;
+        }
+
+        /* Since Vulkan content is presented on a Wayland subsurface, we need
+         * to ensure the parent Wayland surface is mapped for the Vulkan
+         * content to be visible. */
+        if (drawing_allowed && !wine_vk_swapchain_is_remote(wine_vk_swapchain))
+            wayland_surface_ensure_mapped(wine_vk_swapchain->wayland_surface);
+    }
+
+    /* In case of error in any swapchain, we are not going to present at all,
+     * so mark all swapchains as failures. */
+    if (res != VK_SUCCESS && present_info->pResults)
+    {
+        for (i = 0; i < present_info->swapchainCount; ++i)
+            present_info->pResults[i] = res;
+    }
+
+    return res;
+}
+
+static void lock_swapchain_wayland_surfaces(const VkPresentInfoKHR *present_info,
+                                            BOOL lock)
+{
+    uint32_t i;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+
+        if (wine_vk_swapchain && wine_vk_swapchain->wayland_surface)
+        {
+            if (lock)
+                wayland_mutex_lock(&wine_vk_swapchain->wayland_surface->mutex);
+            else
+                wayland_mutex_unlock(&wine_vk_swapchain->wayland_surface->mutex);
+        }
+    }
+}
+
+static int queue_present_wait_semaphores(struct wine_vk_swapchain *swapchain,
+                                         const VkPresentInfoKHR *present_info)
+{
+    struct pollfd pollfd;
+    int semaphore_fd = -1;
+    unsigned int i;
+    int ret;
+    VkSemaphoreGetFdInfoKHR get_fd_info = {0};
+    VkResult res;
+
+    if (present_info->waitSemaphoreCount == 0)
+        return 0;
+
+    get_fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    get_fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+
+    for (i = 0; i < present_info->waitSemaphoreCount; i++)
+    {
+        /* Current semaphore to wait for */
+        get_fd_info.semaphore = present_info->pWaitSemaphores[i];
+
+        res = swapchain->p_vkGetSemaphoreFdKHR(swapchain->wine_vk_device->dev,
+                                               &get_fd_info, &semaphore_fd);
+        if (res != VK_SUCCESS)
+        {
+            ERR("vkGetSemaphoreFdKHR failed, res=%d\n", res);
+            semaphore_fd = -1;
+            goto err;
+        }
+        if (semaphore_fd < 0)
+        {
+            ERR("Invalid semaphore fd\n");
+            goto err;
+        }
+
+        pollfd.fd = semaphore_fd;
+        pollfd.events = POLLIN;
+
+        while ((ret = poll(&pollfd, 1, -1)) == -1 && errno == EINTR)
+            continue;
+
+        if (ret < 0)
+        {
+            ERR("Poll fd failed errno=%d\n", errno);
+            goto err;
+        }
+        if (pollfd.revents & (POLLERR | POLLHUP | POLLNVAL))
+        {
+            ERR("Poll fd failed\n");
+            goto err;
+        }
+
+        close(semaphore_fd);
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to wait for semaphores before presenting queue\n");
+    if (semaphore_fd >= 0)
+        close(semaphore_fd);
+    return -1;
+}
+
+static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *present_info)
+{
+    VkResult res;
+    unsigned int i;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    int res_chain;
+    BOOL failed = FALSE;
+
+    TRACE("%p, %p\n", queue, present_info);
+
+    /* Lock the surfaces to ensure we don't present while reconfiguration is
+     * taking place, so we don't inadvertently commit an in-progress,
+     * incomplete configuration state. */
+    lock_swapchain_wayland_surfaces(present_info, TRUE);
+
+    if ((res = validate_present_info(present_info)) == VK_SUCCESS)
+    {
+        wine_vk_swapchain = wine_vk_swapchain_from_handle(present_info->pSwapchains[0]);
+        if (!wine_vk_swapchain_is_remote(wine_vk_swapchain))
+        {
+            /* We are not dealing with cross-process swapchains, so we don't
+             * have to use our remote Vulkan implementation to present */
+            res = pvkQueuePresentKHR(queue, present_info);
+        }
+        else
+        {
+            /* We are dealing with cross-process swapchains, so use our remote
+             * Vulkan implementation to present */
+            if (present_info->swapchainCount == 0 || !present_info->pSwapchains)
+            {
+                ERR("Invalid number of swapchains to present: 0\n");
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                goto out;
+            }
+            for (i = 0; i < present_info->swapchainCount; i++)
+            {
+                wine_vk_swapchain = wine_vk_swapchain_from_handle(present_info->pSwapchains[i]);
+
+                /* Before presenting the 1st swapchain, wait for the semaphores */
+                if (i == 0 && queue_present_wait_semaphores(wine_vk_swapchain, present_info) < 0)
+                {
+                    res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                    goto out;
+                }
+
+                res_chain = wayland_remote_vk_swapchain_present(wine_vk_swapchain->remote_vk_swapchain,
+                                                                present_info->pImageIndices[i]);
+                if (res_chain < 0)
+                    failed = TRUE;
+
+                if (present_info->pResults)
+                    present_info->pResults[i] = failed ? VK_ERROR_OUT_OF_HOST_MEMORY : VK_SUCCESS;
+            }
+
+            /* If presenting any of the swapchains fails, this function fails */
+            if (failed)
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
+
+out:
+    lock_swapchain_wayland_surfaces(present_info, FALSE);
+    return res;
+}
+
+/* The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
+ * native surface. */
+static VkSurfaceKHR wayland_wine_get_native_surface(VkSurfaceKHR surface)
+{
+    TRACE("0x%s\n", wine_dbgstr_longlong(surface));
+    return surface;
+}
+
+static void wine_vk_init(void)
+{
+    if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    {
+        ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+#define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkAcquireNextImageKHR);
+    LOAD_FUNCPTR(vkCreateDevice);
+    LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateSwapchainKHR);
+    LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
+    LOAD_FUNCPTR(vkDestroyDevice);
+    LOAD_FUNCPTR(vkDestroyInstance);
+    LOAD_FUNCPTR(vkDestroySurfaceKHR);
+    LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkEnumerateDeviceExtensionProperties);
+    LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
+    LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetDeviceProcAddr);
+    LOAD_FUNCPTR(vkGetInstanceProcAddr);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
+    LOAD_FUNCPTR(vkGetSwapchainImagesKHR);
+    LOAD_FUNCPTR(vkQueuePresentKHR);
+#undef LOAD_FUNCPTR
+#undef LOAD_OPTIONAL_FUNCPTR
+
+    return;
+
+fail:
+    dlclose(vulkan_handle);
+    vulkan_handle = NULL;
+}
+
+static const struct vulkan_funcs vulkan_funcs =
+{
+    .p_vkAcquireNextImageKHR = wayland_vkAcquireNextImageKHR,
+    .p_vkCreateDevice = wayland_vkCreateDevice,
+    .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
+    .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
+    .p_vkDestroyDevice = wayland_vkDestroyDevice,
+    .p_vkDestroyInstance = wayland_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
+    .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
+    .p_wine_get_native_surface = wayland_wine_get_native_surface,
+};
+
+/**********************************************************************
+ *           WAYLAND_wine_get_vulkan_driver
+ */
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+
+    if (version != WINE_VULKAN_DRIVER_VERSION)
+    {
+        ERR("version mismatch, vulkan wants %u but driver has %u\n", version, WINE_VULKAN_DRIVER_VERSION);
+        return NULL;
+    }
+
+    pthread_once(&init_once, wine_vk_init);
+    if (vulkan_handle)
+        return &vulkan_funcs;
+
+    return NULL;
+}
+
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+    struct wine_vk_swapchain *swap;
+    struct wine_vk_surface *surf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+    {
+        if (swap->hwnd == hwnd)
+            __atomic_store_n(&swap->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+    {
+        if (surf->hwnd == hwnd)
+            __atomic_store_n(&surf->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+}
+
+#else /* No vulkan */
+
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    ERR("Wine was built without Vulkan support.\n");
+    return NULL;
+}
+
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+}
+
+#endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/vulkan_remote.c b/dlls/winewayland.drv/vulkan_remote.c
new file mode 100644
index 00000000000..1d4ca73c9f6
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan_remote.c
@@ -0,0 +1,817 @@
+/* WAYLANDDRV Vulkan remote implementation
+ *
+ * Copyright 2022 Leandro Ribeiro
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+#include "vulkan_remote.h"
+
+#include <drm_fourcc.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+struct vk_funcs
+{
+    PFN_vkCreateImage p_vkCreateImage;
+    PFN_vkDestroyImage p_vkDestroyImage;
+    PFN_vkAllocateMemory p_vkAllocateMemory;
+    PFN_vkFreeMemory p_vkFreeMemory;
+    PFN_vkBindImageMemory p_vkBindImageMemory;
+    PFN_vkGetImageMemoryRequirements p_vkGetImageMemoryRequirements;
+    PFN_vkGetPhysicalDeviceMemoryProperties p_vkGetPhysicalDeviceMemoryProperties;
+    PFN_vkImportSemaphoreFdKHR p_vkImportSemaphoreFdKHR;
+    PFN_vkImportFenceFdKHR p_vkImportFenceFdKHR;
+    PFN_vkGetMemoryFdKHR p_vkGetMemoryFdKHR;
+    PFN_vkGetImageSubresourceLayout p_vkGetImageSubresourceLayout;
+};
+
+struct wayland_remote_vk_image
+{
+    VkImage native_vk_image;
+    VkDeviceMemory native_vk_image_memory;
+    VkFormat format;
+    uint32_t width, height;
+    BOOL busy;
+    struct wayland_native_buffer native_buffer;
+    HANDLE remote_buffer_released_event;
+};
+
+struct wayland_remote_vk_swapchain
+{
+    struct vk_funcs vk_funcs;
+    struct wayland_remote_surface_proxy *remote_surface_proxy;
+    uint32_t count_images;
+    struct wayland_remote_vk_image *images;
+    enum wayland_remote_buffer_commit buffer_commit;
+    HANDLE remote_throttle_event;
+};
+
+struct drm_vk_format
+{
+    VkFormat vk_format;
+    VkFormat vk_format_srgb;
+    uint32_t drm_format;
+    uint32_t drm_format_alpha;
+};
+
+/* List of Vulkan formats that we know, and the corresponding DRM formats */
+const static struct drm_vk_format format_table[] =
+{
+    {VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, DRM_FORMAT_XBGR8888, DRM_FORMAT_ABGR8888},
+    {VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_B8G8R8A8_SRGB, DRM_FORMAT_XRGB8888, DRM_FORMAT_ARGB8888},
+};
+
+/* Convert timeout in ms to the timeout format used by ntdll which is:
+ * 100ns units, negative for monotonic time. */
+static inline LARGE_INTEGER *get_nt_timeout(LARGE_INTEGER *time, int timeout_ms)
+{
+    if (timeout_ms == -1)
+        return NULL;
+
+    time->QuadPart = (ULONGLONG)timeout_ms * -10000;
+
+    return time;
+}
+
+static DWORD get_tick_count_since(DWORD start)
+{
+    DWORD now = NtGetTickCount();
+    /* Handle tick count wrap around to zero. */
+    if (now < start)
+        return 0xffffffff - start + now + 1;
+    else
+        return now - start;
+}
+
+static uint32_t vulkan_format_to_drm_format(VkFormat format, BOOL ignore_alpha)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(format_table); i++)
+    {
+        const struct drm_vk_format *dvf = &format_table[i];
+        if (dvf->vk_format == format || dvf->vk_format_srgb == format)
+            return ignore_alpha ? dvf->drm_format : dvf->drm_format_alpha;
+    }
+
+    return DRM_FORMAT_INVALID;
+}
+
+static int wayland_native_buffer_init_vk(VkInstance instance, VkPhysicalDevice physical_device,
+                                         VkDevice device, struct vk_funcs *vk_funcs,
+                                         BOOL ignore_alpha, struct wayland_remote_vk_image *image)
+{
+    struct wayland_native_buffer *buffer = &image->native_buffer;
+    VkMemoryGetFdInfoKHR memory_get_fd_info = {0};
+    VkSubresourceLayout layout;
+    VkImageSubresource image_subresource = {0};
+    VkResult res;
+
+    buffer->modifier = DRM_FORMAT_MOD_LINEAR;
+    buffer->plane_count = 1;
+
+    memory_get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+    memory_get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+    memory_get_fd_info.memory = image->native_vk_image_memory;
+
+    res = vk_funcs->p_vkGetMemoryFdKHR(device, &memory_get_fd_info, &buffer->fds[0]);
+    if (res != VK_SUCCESS)
+    {
+        buffer->fds[0] = -1;
+        ERR("pfn_vkGetMemoryFdKHR failed, res=%d\n", res);
+        goto err;
+    }
+
+    image_subresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    vk_funcs->p_vkGetImageSubresourceLayout(device, image->native_vk_image,
+                                            &image_subresource, &layout);
+    buffer->offsets[0] = layout.offset;
+    buffer->strides[0] = layout.rowPitch;
+
+    buffer->format = vulkan_format_to_drm_format(image->format, ignore_alpha);
+    if (buffer->format == DRM_FORMAT_INVALID)
+    {
+        ERR("Failed to get corresponding DRM format for Vulkan format %d\n", image->format);
+        goto err;
+    }
+    buffer->width = image->width;
+    buffer->height = image->height;
+
+    return 0;
+
+err:
+    wayland_native_buffer_deinit(buffer);
+    ERR("Failed to init wayland_native_buffer for Vulkan image\n");
+    return -1;
+}
+
+static int get_image_create_flags(VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    uint32_t flags = 0;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_PROTECTED_BIT;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR)
+        flags |= VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
+
+    return flags;
+}
+
+static VkImage create_vulkan_image(VkDevice device, struct vk_funcs *vk_funcs,
+                                   VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    VkExternalMemoryImageCreateInfo external_memory_create_info = {0};
+    VkImageCreateInfo image_create_info = {0};
+    VkResult res;
+    VkImage image;
+
+    external_memory_create_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+    external_memory_create_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+
+    image_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+    image_create_info.pNext = &external_memory_create_info;
+    image_create_info.imageType = VK_IMAGE_TYPE_2D;
+    image_create_info.format = chain_create_info->imageFormat;
+    image_create_info.extent.width = chain_create_info->imageExtent.width;
+    image_create_info.extent.height = chain_create_info->imageExtent.height;
+    image_create_info.extent.depth = 1;
+    image_create_info.arrayLayers = chain_create_info->imageArrayLayers;
+    image_create_info.sharingMode = chain_create_info->imageSharingMode;
+    image_create_info.usage = chain_create_info->imageUsage;
+    image_create_info.mipLevels = 1;
+    image_create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    image_create_info.samples = VK_SAMPLE_COUNT_1_BIT;
+    /* We'll create dma-buf buffers for these images, and so we'll need to know
+     * the layout of them on memory. When VK_EXT_image_drm_format_modifier is
+     * not supported, we can't use TILING_DRM_FORMAT_MODIFIER_EXT, so that
+     * leaves us with TILING_LINEAR or TILING_OPTIMAL available. If we choose
+     * TILING_OPTIMAL, we are not able to query the modifier chosen by the
+     * driver and the number of planes (because we don't have the extension to
+     * do so). So it'd be impossible to create dma-buf buffers. This leaves us
+     * with TILING_LINEAR, and that makes drivers decisions predictable and we
+     * can assume that they'll pick DRM_FORMAT_MOD_LINEAR and there'll be a
+     * single plane. This might fail for drivers that do not support modifiers
+     * at all, but we can't do better than that. */
+    image_create_info.tiling = VK_IMAGE_TILING_LINEAR;
+    image_create_info.flags = get_image_create_flags(chain_create_info);
+
+    res = vk_funcs->p_vkCreateImage(device, &image_create_info, NULL, &image);
+    if (res != VK_SUCCESS)
+    {
+        ERR("vkCreateImage failed, res=%d\n", res);
+        goto err;
+    }
+
+    return image;
+
+err:
+    ERR("Failed to create Vulkan image\n");
+    return VK_NULL_HANDLE;
+}
+
+static int get_memory_property_flags(VkSwapchainCreateInfoKHR *chain_create_info)
+{
+    uint32_t flags = 0;
+
+    if (chain_create_info->flags & VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR)
+        flags |= VK_MEMORY_PROPERTY_PROTECTED_BIT;
+
+    return flags;
+}
+
+static VkDeviceMemory create_vulkan_image_memory(VkInstance instance, VkPhysicalDevice physical_device,
+                                                 VkDevice device, struct vk_funcs *vk_funcs,
+                                                 VkSwapchainCreateInfoKHR *chain_create_info,
+                                                 VkImage image)
+{
+    int32_t mem_type_index = -1;
+    uint32_t flags;
+    unsigned int i;
+    VkMemoryRequirements mem_reqs;
+    VkPhysicalDeviceMemoryProperties mem_props;
+    VkExportMemoryAllocateInfo export_alloc_info = {0};
+    VkMemoryAllocateInfo alloc_info = {0};
+    VkResult res;
+    VkDeviceMemory image_mem;
+
+    export_alloc_info.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
+    export_alloc_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+
+    alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+    alloc_info.pNext = &export_alloc_info;
+
+    vk_funcs->p_vkGetImageMemoryRequirements(device, image, &mem_reqs);
+    vk_funcs->p_vkGetPhysicalDeviceMemoryProperties(physical_device, &mem_props);
+
+    flags = get_memory_property_flags(chain_create_info);
+    for (i = 0; i < mem_props.memoryTypeCount; i++)
+        if ((mem_reqs.memoryTypeBits & (1 << i)) &&
+            (mem_props.memoryTypes[i].propertyFlags & flags) == flags)
+                mem_type_index = i;
+
+    if (mem_type_index == -1)
+    {
+        ERR("Failed to find memoryTypeIndex\n");
+        goto err;
+    }
+
+    alloc_info.memoryTypeIndex = mem_type_index;
+    alloc_info.allocationSize = mem_reqs.size;
+
+    res = vk_funcs->p_vkAllocateMemory(device, &alloc_info, NULL, &image_mem);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pfn_vkAllocateMemory failed, res=%d\n", res);
+        goto err;
+    }
+
+    return image_mem;
+
+err:
+    ERR("Failed to create Vulkan image memory\n");
+    return VK_NULL_HANDLE;
+}
+
+static void wayland_remote_vk_image_deinit(VkDevice device, struct vk_funcs *vk_funcs,
+                                           struct wayland_remote_vk_image *image)
+{
+    vk_funcs->p_vkDestroyImage(device, image->native_vk_image, NULL);
+    vk_funcs->p_vkFreeMemory(device, image->native_vk_image_memory, NULL);
+
+    if (image->remote_buffer_released_event)
+        NtClose(image->remote_buffer_released_event);
+
+    wayland_native_buffer_deinit(&image->native_buffer);
+}
+
+static int wayland_remote_vk_image_init(VkInstance instance, VkPhysicalDevice physical_device,
+                                        VkDevice device, struct vk_funcs *vk_funcs,
+                                        VkSwapchainCreateInfoKHR *create_info,
+                                        struct wayland_remote_vk_image *image)
+{
+    VkResult res;
+    BOOL ignore_alpha;
+    unsigned int i;
+
+    image->native_vk_image = VK_NULL_HANDLE;
+    image->native_vk_image_memory = VK_NULL_HANDLE;
+    image->format = create_info->imageFormat;
+    image->width = create_info->imageExtent.width;
+    image->height = create_info->imageExtent.height;
+    image->busy = FALSE;
+    image->remote_buffer_released_event = 0;
+    for (i = 0; i < ARRAY_SIZE(image->native_buffer.fds); i++)
+        image->native_buffer.fds[i] = -1;
+
+    image->native_vk_image = create_vulkan_image(device, vk_funcs, create_info);
+    if (image->native_vk_image == VK_NULL_HANDLE)
+        goto err;
+
+    image->native_vk_image_memory =
+        create_vulkan_image_memory(instance, physical_device, device,
+                                   vk_funcs, create_info, image->native_vk_image);
+    if (image->native_vk_image_memory == VK_NULL_HANDLE)
+        goto err;
+
+    res = vk_funcs->p_vkBindImageMemory(device, image->native_vk_image,
+                                        image->native_vk_image_memory, 0);
+    if (res != VK_SUCCESS)
+    {
+        ERR("pfn_vkBindImageMemory failed, res=%d\n", res);
+        goto err;
+    }
+
+    ignore_alpha = create_info->compositeAlpha & VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
+    if (wayland_native_buffer_init_vk(instance, physical_device, device, vk_funcs,
+                                      ignore_alpha, image) < 0)
+        goto err;
+
+    return 0;
+
+err:
+    ERR("Failed to create remote swapchain image\n");
+    wayland_remote_vk_image_deinit(device, vk_funcs, image);
+    return -1;
+}
+
+static void wayland_remote_vk_image_release(struct wayland_remote_vk_image *image)
+{
+    if (image->remote_buffer_released_event)
+    {
+        NtClose(image->remote_buffer_released_event);
+        image->remote_buffer_released_event = 0;
+    }
+
+    image->busy = FALSE;
+}
+
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
+                                         VkDevice device)
+{
+    if (swapchain->remote_surface_proxy)
+        wayland_remote_surface_proxy_destroy(swapchain->remote_surface_proxy);
+
+    if (swapchain->images)
+    {
+        unsigned int i;
+        for (i = 0; i < swapchain->count_images; i++)
+        {
+            wayland_remote_vk_image_deinit(device, &swapchain->vk_funcs,
+                                           &swapchain->images[i]);
+        }
+        free(swapchain->images);
+    }
+
+    if (swapchain->remote_throttle_event)
+        NtClose(swapchain->remote_throttle_event);
+
+    free(swapchain);
+}
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd, VkInstance instance,
+                                                                       VkPhysicalDevice physical_device,
+                                                                       VkDevice device,
+                                                                       const struct vulkan_funcs *vulkan_funcs,
+                                                                       VkSwapchainCreateInfoKHR *create_info)
+{
+    static const uint32_t min_number_images = 4;
+    struct wayland_remote_vk_swapchain *swapchain;
+    unsigned int i;
+    int res = 0;
+
+    swapchain = calloc(1, sizeof(*swapchain));
+    if (!swapchain)
+    {
+        ERR("Failed to allocate memory\n");
+        goto err;
+    }
+
+#define LOAD_DEVICE_FUNCPTR(f) \
+    if (!(swapchain->vk_funcs.p_##f = vulkan_funcs->p_vkGetDeviceProcAddr(device, #f))) \
+        goto err
+
+#define LOAD_INSTANCE_FUNCPTR(f) \
+    if (!(swapchain->vk_funcs.p_##f = vulkan_funcs->p_vkGetInstanceProcAddr(instance, #f))) \
+        goto err
+
+    LOAD_DEVICE_FUNCPTR(vkCreateImage);
+    LOAD_DEVICE_FUNCPTR(vkDestroyImage);
+    LOAD_DEVICE_FUNCPTR(vkAllocateMemory);
+    LOAD_DEVICE_FUNCPTR(vkFreeMemory);
+    LOAD_DEVICE_FUNCPTR(vkBindImageMemory);
+    LOAD_DEVICE_FUNCPTR(vkGetImageMemoryRequirements);
+    LOAD_INSTANCE_FUNCPTR(vkGetPhysicalDeviceMemoryProperties);
+    LOAD_DEVICE_FUNCPTR(vkImportSemaphoreFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkImportFenceFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkGetMemoryFdKHR);
+    LOAD_DEVICE_FUNCPTR(vkGetImageSubresourceLayout);
+
+#undef LOAD_DEVICE_FUNCPTR
+#undef LOAD_INSTANCE_FUNCPTR
+
+    swapchain->remote_surface_proxy =
+        wayland_remote_surface_proxy_create(hwnd, WAYLAND_REMOTE_SURFACE_TYPE_GLVK);
+    if (!swapchain->remote_surface_proxy)
+    {
+        ERR("Failed to create remote surface proxy for remote swapchain\n");
+        goto err;
+    }
+
+    swapchain->count_images = max(create_info->minImageCount, min_number_images);
+    swapchain->images = calloc(swapchain->count_images, sizeof(*swapchain->images));
+    if (!swapchain->images)
+    {
+        ERR("Failed to allocate memory\n");
+        goto err;
+    }
+
+    for (i = 0; i < swapchain->count_images; i++)
+        res |= wayland_remote_vk_image_init(instance, physical_device, device,
+                                            &swapchain->vk_funcs, create_info,
+                                            &swapchain->images[i]);
+    if (res < 0)
+        goto err;
+
+    swapchain->buffer_commit =
+        (create_info->presentMode == VK_PRESENT_MODE_FIFO_KHR) ?
+            WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED :
+            WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL;
+
+    swapchain->remote_throttle_event = 0;
+
+    return swapchain;
+
+err:
+    ERR("Failed to create remote swapchain\n");
+    if (swapchain)
+        wayland_remote_vk_swapchain_destroy(swapchain, device);
+    return NULL;
+}
+
+VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    unsigned int i;
+    VkResult res = VK_SUCCESS;
+
+    if (!images)
+    {
+        *count = swapchain->count_images;
+        return VK_SUCCESS;
+    }
+
+    if (*count < swapchain->count_images)
+        res = VK_INCOMPLETE;
+
+    /* The client want us to fill images, but for some reason the size of the
+     * array is larger than the number of formats that we support. So we correct
+     * that size. */
+    if (*count > swapchain->count_images)
+        *count = swapchain->count_images;
+
+    for (i = 0; i < (*count); i++)
+        images[i] = swapchain->images[i].native_vk_image;
+
+    return res;
+}
+
+static DWORD wait_remote_release_buffer_events(struct wayland_remote_vk_swapchain *swapchain,
+                                               int timeout_ms)
+{
+    int count = 0;
+    HANDLE *handles;
+    struct wayland_remote_vk_image *image;
+    struct wayland_remote_vk_image **images;
+    unsigned int i;
+    LARGE_INTEGER timeout;
+    DWORD ret = WAIT_OBJECT_0;
+
+    handles = calloc(swapchain->count_images, sizeof(*handles));
+    images = calloc(swapchain->count_images, sizeof(*images));
+    if (!handles || !images)
+    {
+        ERR("Failed to allocate memory\n");
+        ret = WAIT_FAILED;
+        goto out;
+    }
+
+    if (!wayland_remote_surface_proxy_dispatch_events(swapchain->remote_surface_proxy))
+    {
+        ret = WAIT_FAILED;
+        goto out;
+    }
+
+    for (i = 0; i < swapchain->count_images; i++)
+    {
+        image = &swapchain->images[i];
+        if (!image->remote_buffer_released_event)
+            continue;
+        images[count] = image;
+        handles[count] = image->remote_buffer_released_event;
+        count++;
+    }
+    TRACE("count handles=%d\n", count);
+    for (i = 0; i < count; i++)
+        TRACE("handle%d=%p\n", i, handles[i]);
+
+    /* Nothing to wait for, so just return */
+    if (count == 0)
+        goto out;
+
+    ret = NtWaitForMultipleObjects(count, handles, TRUE, FALSE,
+                                   get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_FAILED)
+    {
+        ERR("Failed on NtWaitForMultipleObjects() call, ret=%d\n", ret);
+        goto out;
+    }
+    TRACE("count=%d => ret=%d\n", count, ret);
+
+    i = ret - WAIT_OBJECT_0;
+    if (i < count)
+        wayland_remote_vk_image_release(images[i]);
+
+out:
+    if (ret == WAIT_FAILED)
+        ERR("Failed to wait for remote release buffer event\n");
+    free(handles);
+    free(images);
+    return ret;
+}
+
+VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk_swapchain *swapchain,
+                                                        VkDevice device, uint64_t timeout_ns,
+                                                        VkSemaphore semaphore, VkFence fence,
+                                                        uint32_t *image_index)
+{
+    struct vk_funcs *vk_funcs = &swapchain->vk_funcs;
+    unsigned int i;
+    BOOL free_image_found = FALSE;
+    VkImportSemaphoreFdInfoKHR import_semaphore_fd_info = {0};
+    VkImportFenceFdInfoKHR import_fence_fd_info = {0};
+    VkResult res;
+    static const DWORD wait_timeout = 100;
+    DWORD wait_start = NtGetTickCount();
+
+    /* As we are not the Vulkan driver, we don't have much information about the
+     * semaphore. But the spec of VkImportSemaphoreFdInfoKHR states the
+     * following:
+     *
+     * If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT, the
+     * special value -1 for fd is treated like a valid sync file descriptor
+     * referring to an object that has already signaled. The import operation
+     * will succeed and the VkSemaphore will have a temporarily imported payload
+     * as if a valid file descriptor had been provided.
+     *
+     * This special behavior allows us to signal the semaphore by setting
+     * import_semaphore_fd_info.fd to -1. Same thing applies to VkFence, so we
+     * set import_fence_fd_info.fd to -1 */
+
+    import_semaphore_fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    import_semaphore_fd_info.fd = -1;
+    import_semaphore_fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+    import_semaphore_fd_info.semaphore = semaphore;
+    import_semaphore_fd_info.flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
+
+    import_fence_fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
+    import_fence_fd_info.fd = -1;
+    import_fence_fd_info.handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
+    import_fence_fd_info.fence = fence;
+    import_fence_fd_info.flags = VK_FENCE_IMPORT_TEMPORARY_BIT;
+
+    /* Wait until we have a free image. If we don't get a free buffer within
+     * wait_timeout, drop the first buffer to ensure we can continue and avoid
+     * potential cross-process deadlocks (e.g., the render process waiting for
+     * the window process to dispatch buffer release messages, while the window
+     * process is waiting for the render process to finish rendering). */
+    while (!free_image_found)
+    {
+        for (i = 0; i < swapchain->count_images; i++)
+            if (!swapchain->images[i].busy)
+            {
+                free_image_found = TRUE;
+                break;
+            }
+
+        if (!free_image_found)
+        {
+            /* If timeout is 0, the spec says that we should return VK_NOT_READY
+             * when no images are available. */
+            if (timeout_ns == 0)
+                return VK_NOT_READY;
+
+            if (wait_remote_release_buffer_events(swapchain, 10) == WAIT_FAILED)
+                goto err;
+
+            /* Release image so that we can continue */
+            if (get_tick_count_since(wait_start) > wait_timeout)
+            {
+                i = 0;
+                free_image_found = TRUE;
+                wayland_remote_vk_image_release(&swapchain->images[i]);
+            }
+        }
+
+        /* If applications defined a timeout, we must respect it */
+        if (!free_image_found && timeout_ns > 0 &&
+            get_tick_count_since(wait_start) > (timeout_ns / 1000000))
+            return VK_TIMEOUT;
+    }
+
+    if (semaphore != VK_NULL_HANDLE)
+    {
+        res = vk_funcs->p_vkImportSemaphoreFdKHR(device, &import_semaphore_fd_info);
+        if (res != VK_SUCCESS)
+        {
+            ERR("pfn_vkImportSemaphoreFdKHR failed, res=%d\n", res);
+            goto err;
+        }
+    }
+    if (fence != VK_NULL_HANDLE)
+    {
+        res = vk_funcs->p_vkImportFenceFdKHR(device, &import_fence_fd_info);
+        if (res != VK_SUCCESS)
+        {
+            ERR("pfn_vkImportFenceFdKHR failed, res=%d\n", res);
+            goto err;
+        }
+    }
+
+    *image_index = i;
+    swapchain->images[*image_index].busy = TRUE;
+
+    return VK_SUCCESS;
+
+err:
+    ERR("Failed to acquire image from remote Vulkan swapchain");
+    return VK_ERROR_OUT_OF_HOST_MEMORY;
+}
+
+static DWORD wayland_remote_vk_swapchain_wait_throttle(struct wayland_remote_vk_swapchain *swapchain,
+                                                       int timeout_ms)
+{
+    DWORD ret;
+    LARGE_INTEGER timeout;
+
+    TRACE("remote_throttle_event=%p timeout_ms=%d\n",
+          swapchain->remote_throttle_event, timeout_ms);
+
+    if (!wayland_remote_surface_proxy_dispatch_events(swapchain->remote_surface_proxy))
+    {
+        ERR("Failed to dispatch remote events\n");
+        return WAIT_FAILED;
+    }
+
+    ret = NtWaitForSingleObject(swapchain->remote_throttle_event, FALSE,
+                                get_nt_timeout(&timeout, timeout_ms));
+    if (ret == WAIT_OBJECT_0)
+    {
+        NtClose(swapchain->remote_throttle_event);
+        swapchain->remote_throttle_event = 0;
+    }
+
+    TRACE("=> ret=%d\n", ret);
+    return ret;
+}
+
+static void wayland_remote_vk_swapchain_throttle(struct wayland_remote_vk_swapchain *swapchain)
+{
+    static const DWORD timeout = 100;
+    DWORD start, elapsed;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    TRACE("throttle_event=%p\n", swapchain->remote_throttle_event);
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (elapsed < timeout && swapchain->remote_throttle_event &&
+           wayland_remote_vk_swapchain_wait_throttle(swapchain, 10) != WAIT_FAILED)
+    {
+        elapsed = get_tick_count_since(start);
+    }
+
+    TRACE("throttle_event=%p => elapsed=%d\n",
+          swapchain->remote_throttle_event, elapsed);
+
+    if (swapchain->remote_throttle_event)
+    {
+        NtClose(swapchain->remote_throttle_event);
+        swapchain->remote_throttle_event = 0;
+    }
+}
+
+int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
+                                        uint32_t image_index)
+{
+    struct wayland_remote_vk_image *image;
+
+    image = &swapchain->images[image_index];
+    image->busy = TRUE;
+
+    if (swapchain->remote_throttle_event)
+        wayland_remote_vk_swapchain_throttle(swapchain);
+
+    if (!wayland_remote_surface_proxy_commit(swapchain->remote_surface_proxy,
+                                             &image->native_buffer,
+                                             WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+                                             swapchain->buffer_commit,
+                                             &image->remote_buffer_released_event,
+                                             &swapchain->remote_throttle_event))
+    {
+        wayland_remote_vk_image_release(image);
+        goto err;
+    }
+
+    return 0;
+
+err:
+    ERR("Failed to present remote Vulkan swapchain\n");
+    return -1;
+}
+
+VkResult wayland_remote_vk_filter_supported_formats(uint32_t *count_filtered_formats,
+                                                    void *filtered_formats,
+                                                    uint32_t count_formats_to_filter,
+                                                    void *formats_to_filter,
+                                                    size_t format_size,
+                                                    size_t vk_surface_format_offset)
+{
+    VkFormat format;
+    VkResult res = VK_SUCCESS;
+    uint32_t count_intersect;
+    unsigned int i;
+
+    for (count_intersect = 0, i = 0; i < count_formats_to_filter; i++)
+    {
+        format = *(VkFormat *)((char *)formats_to_filter +
+                               (i * format_size) + vk_surface_format_offset);
+        if (vulkan_format_to_drm_format(format, FALSE) != DRM_FORMAT_INVALID)
+        {
+            if (filtered_formats)
+            {
+                if (count_intersect < *count_filtered_formats)
+                {
+                    /* There's room for a format on the array, so add it */
+                    memcpy((char *)filtered_formats + (count_intersect * format_size),
+                           (char *)formats_to_filter + (i * format_size),
+                           format_size);
+                }
+                else
+                {
+                    /* Array size is not enough to accommodate all the formats
+                     * we support, so we must return VK_INCOMPLETE */
+                    res = VK_INCOMPLETE;
+                    break;
+                }
+            }
+            count_intersect++;
+        }
+    }
+
+    /* We just set count_filtered_formats when the client want us to do that
+     * (i.e., filtered_formats == NULL) and when the client want us to fill
+     * filtered_formats but for some reason the size of the array is larger than
+     * the number of formats that we support. */
+    if (!filtered_formats || *count_filtered_formats > count_intersect)
+        *count_filtered_formats = count_intersect;
+
+    return res;
+}
diff --git a/dlls/winewayland.drv/vulkan_remote.h b/dlls/winewayland.drv/vulkan_remote.h
new file mode 100644
index 00000000000..5be34f4e28a
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan_remote.h
@@ -0,0 +1,57 @@
+/* WAYLANDDRV Vulkan remote implementation
+ *
+ * Copyright 2022 Leandro Ribeiro
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_VULKAN_REMOTE_H
+#define __WINE_WAYLANDDRV_VULKAN_REMOTE_H
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+
+struct wayland_remote_vk_swapchain;
+struct vulkan_funcs;
+
+struct wayland_remote_vk_swapchain *wayland_remote_vk_swapchain_create(HWND hwnd, VkInstance instance,
+                                                                       VkPhysicalDevice physical_device,
+                                                                       VkDevice device,
+                                                                       const struct vulkan_funcs *vulkan_funcs,
+                                                                       VkSwapchainCreateInfoKHR *create_info) DECLSPEC_HIDDEN;
+void wayland_remote_vk_swapchain_destroy(struct wayland_remote_vk_swapchain *swapchain,
+                                         VkDevice device) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_swapchain_get_images(struct wayland_remote_vk_swapchain *swapchain,
+                                                uint32_t *count, VkImage *images) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_swapchain_acquire_next_image(struct wayland_remote_vk_swapchain *swapchain,
+                                                        VkDevice device, uint64_t timeout_ns,
+                                                        VkSemaphore semaphore, VkFence fence,
+                                                        uint32_t *image_index) DECLSPEC_HIDDEN;
+int wayland_remote_vk_swapchain_present(struct wayland_remote_vk_swapchain *swapchain,
+                                        uint32_t image_index) DECLSPEC_HIDDEN;
+VkResult wayland_remote_vk_filter_supported_formats(uint32_t *count_filtered_formats,
+                                                    void *filtered_formats,
+                                                    uint32_t count_formats_to_filter,
+                                                    void *formats_to_filter,
+                                                    size_t format_size,
+                                                    size_t vk_surface_format_offset) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WAYLANDDRV_VULKAN_REMOTE_H */
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
new file mode 100644
index 00000000000..76e5e67f469
--- /dev/null
+++ b/dlls/winewayland.drv/wayland.c
@@ -0,0 +1,711 @@
+/*
+ * Wayland core handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct wl_display *process_wl_display = NULL;
+static struct wayland *process_wayland = NULL;
+static struct wayland_mutex process_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": process_wayland_mutex"
+};
+static struct wayland_mutex thread_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": thread_wayland_mutex"
+};
+
+static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
+
+/**********************************************************************
+ *          xdg_wm_base handling
+ */
+
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *shell, uint32_t serial)
+{
+    xdg_wm_base_pong(shell, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
+};
+
+/**********************************************************************
+ *          Seat handling
+ */
+
+static void seat_handle_capabilities(void *data, struct wl_seat *seat,
+                                     enum wl_seat_capability caps)
+{
+    struct wayland *wayland = data;
+
+    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_init(&wayland->pointer, wayland, wl_seat_get_pointer(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_deinit(&wayland->pointer);
+    }
+
+    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_init(&wayland->keyboard, wayland, wl_seat_get_keyboard(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_deinit(&wayland->keyboard);
+    }
+}
+
+static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
+{
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+    seat_handle_name,
+};
+
+/**********************************************************************
+ *          Registry handling
+ */
+
+static void registry_handle_global(void *data, struct wl_registry *registry,
+                                   uint32_t id, const char *interface,
+                                   uint32_t version)
+{
+    struct wayland *wayland = data;
+
+    TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
+
+    if (strcmp(interface, "wl_output") == 0)
+    {
+        if (!wayland_output_create(wayland, id, version))
+            ERR("Failed to create wayland_output for global id=%u\n", id);
+    }
+    else if (strcmp(interface, "zxdg_output_manager_v1") == 0)
+    {
+        struct wayland_output *output;
+
+        wayland->zxdg_output_manager_v1 =
+            wl_registry_bind(registry, id, &zxdg_output_manager_v1_interface,
+                             version < 3 ? version : 3);
+
+        /* Add zxdg_output_v1 to existing outputs. */
+        wl_list_for_each(output, &wayland->output_list, link)
+            wayland_output_use_xdg_extension(output);
+    }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
+    else if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0)
+    {
+        struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1 =
+            wl_registry_bind(registry, id, &zwp_linux_dmabuf_v1_interface,
+                             version < 4 ? version : 4);
+        wayland_dmabuf_init(&wayland->dmabuf, zwp_linux_dmabuf_v1);
+    }
+    else if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
+
+    /* The per-process wayland instance should not handle every global, as there
+     * is no point. Many globals are only needed by the per-thread instances. */
+    if (wayland_is_process(wayland)) return;
+
+    if (strcmp(interface, "wl_subcompositor") == 0)
+    {
+        wayland->wl_subcompositor =
+            wl_registry_bind(registry, id, &wl_subcompositor_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_wm_base") == 0)
+    {
+        /* Bind version 2 so that compositors (e.g., sway) can properly send tiled
+         * states, instead of falling back to (ab)using the maximized state. */
+        wayland->xdg_wm_base =
+            wl_registry_bind(registry, id, &xdg_wm_base_interface,
+                             version < 2 ? version : 2);
+        xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
+    }
+    else if (strcmp(interface, "wl_seat") == 0)
+    {
+        wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
+                                            version < 5 ? version : 5);
+        wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
+    }
+    else if (strcmp(interface, "wp_viewporter") == 0)
+    {
+        wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
+    }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        wayland->wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface,
+                             version < 3 ? version : 3);
+    }
+    else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
+    {
+        wayland->zwp_pointer_constraints_v1 =
+            wl_registry_bind(registry, id, &zwp_pointer_constraints_v1_interface, 1);
+    }
+    else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
+    {
+        wayland->zwp_relative_pointer_manager_v1 =
+            wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
+    }
+}
+
+static void registry_handle_global_remove(void *data, struct wl_registry *registry,
+                                          uint32_t id)
+{
+    struct wayland *wayland = data;
+    struct wayland_output *output, *tmp;
+
+    TRACE("id=%d\n", id);
+
+    wl_list_for_each_safe(output, tmp, &wayland->output_list, link)
+    {
+        if (output->global_id == id)
+        {
+            struct wayland_surface *surface;
+
+            TRACE("removing output->name=%s\n", output->name);
+
+            /* Remove the output from toplevels, as some compositors don't send
+             * a leave event if the output is disconnected. */
+            wl_list_for_each(surface, &wayland->toplevel_list, link)
+                wayland_surface_leave_output(surface, output);
+
+            wayland_output_destroy(output);
+            if (wayland_is_process(wayland))
+            {
+                /* Temporarily release the per-process instance lock, so that
+                 * wayland_init_display_devices can perform more fine grained
+                 * locking to avoid deadlocks. */
+                wayland_process_release();
+                wayland_init_display_devices();
+                wayland_process_acquire();
+            }
+            return;
+        }
+    }
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+
+/**********************************************************************
+ *          wayland_init
+ *
+ *  Initialise a wayland instance.
+ */
+BOOL wayland_init(struct wayland *wayland)
+{
+    struct wl_display *wl_display_wrapper;
+    int flags;
+
+    TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
+
+    wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
+
+    wayland->process_id = GetCurrentProcessId();
+    wayland->thread_id = GetCurrentThreadId();
+    wayland->wl_display = process_wl_display;
+
+    if (!wayland->wl_display)
+    {
+        ERR("Failed to connect to wayland compositor\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create event queue\n");
+        return FALSE;
+    }
+
+    if (!(wl_display_wrapper = wl_proxy_create_wrapper(wayland->wl_display)))
+    {
+        ERR("Failed to create proxy wrapper for wl_display\n");
+        return FALSE;
+    }
+    wl_proxy_set_queue((struct wl_proxy *) wl_display_wrapper, wayland->wl_event_queue);
+
+    wayland->wl_registry = wl_display_get_registry(wl_display_wrapper);
+    wl_proxy_wrapper_destroy(wl_display_wrapper);
+    if (!wayland->wl_registry)
+    {
+        ERR("Failed to get to wayland registry\n");
+        return FALSE;
+    }
+
+    wl_list_init(&wayland->output_list);
+    wl_list_init(&wayland->detached_shm_buffer_list);
+    wl_list_init(&wayland->toplevel_list);
+
+    SetRect(&wayland->cursor_clip, INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+
+    /* Populate registry */
+    wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
+
+    /* We need three roundtrips. One to get and bind globals, one to handle all
+     * initial events produced from registering the globals and one more to
+     * handle potential third-order registrations. */
+    if (wayland_is_process(wayland)) wayland_process_acquire();
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    if (wayland_is_process(wayland)) wayland_process_release();
+
+    if (wayland_is_process(wayland))
+    {
+        if (option_use_system_cursors)
+            wayland_cursor_theme_init(wayland);
+    }
+    else
+    {
+        if (wayland->wl_data_device_manager && wayland->wl_seat)
+            wayland_data_device_init(&wayland->data_device, wayland);
+
+        /* Thread wayland instances have notification pipes to inform them when
+         * there might be new events in their queues. The read part of the pipe
+         * is also used as the wine server queue fd. */
+        if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+            return FALSE;
+        /* Make just the read end non-blocking */
+        if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+            return FALSE;
+        if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+            return FALSE;
+        /* Keep a list of all thread wayland instances. */
+        wayland_mutex_lock(&thread_wayland_mutex);
+        wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+        wayland_mutex_unlock(&thread_wayland_mutex);
+    }
+
+    wayland->initialized = TRUE;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_deinit
+ *
+ *  Deinitialise a wayland instance, releasing all associated resources.
+ */
+void wayland_deinit(struct wayland *wayland)
+{
+    struct wayland_output *output, *output_tmp;
+    struct wayland_shm_buffer *shm_buffer, *shm_buffer_tmp;
+    struct wayland_surface *toplevel, *toplevel_tmp;
+
+    TRACE("%p\n", wayland);
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+    wl_list_remove(&wayland->thread_link);
+    wayland_mutex_unlock(&thread_wayland_mutex);
+
+    wl_list_for_each_safe(toplevel, toplevel_tmp, &wayland->toplevel_list, link)
+        wayland_surface_destroy(toplevel);
+
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
+    wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
+        wayland_output_destroy(output);
+
+    wl_list_for_each_safe(shm_buffer, shm_buffer_tmp,
+                          &wayland->detached_shm_buffer_list, link)
+        wayland_shm_buffer_destroy(shm_buffer);
+
+    if (wayland->pointer.wl_pointer)
+        wayland_pointer_deinit(&wayland->pointer);
+
+    if (wayland->keyboard.wl_keyboard)
+        wayland_keyboard_deinit(&wayland->keyboard);
+
+    if (wayland->data_device.wl_data_device)
+        wayland_data_device_deinit(&wayland->data_device);
+
+    if (wayland->wl_data_device_manager)
+        wl_data_device_manager_destroy(wayland->wl_data_device_manager);
+
+    if (wayland->wl_seat)
+        wl_seat_destroy(wayland->wl_seat);
+
+    if (wayland->dmabuf.zwp_linux_dmabuf_v1)
+        wayland_dmabuf_deinit(&wayland->dmabuf);
+
+    if (wayland->zwp_pointer_constraints_v1)
+        zwp_pointer_constraints_v1_destroy(wayland->zwp_pointer_constraints_v1);
+
+    if (wayland->zwp_relative_pointer_manager_v1)
+        zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
+
+    if (wayland->wp_viewporter)
+        wp_viewporter_destroy(wayland->wp_viewporter);
+
+    if (wayland->wl_shm)
+        wl_shm_destroy(wayland->wl_shm);
+
+    if (wayland->zxdg_output_manager_v1)
+        zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
+
+    if (wayland->xdg_wm_base)
+        xdg_wm_base_destroy(wayland->xdg_wm_base);
+
+    if (wayland->wl_subcompositor)
+        wl_subcompositor_destroy(wayland->wl_subcompositor);
+
+    if (wayland->wl_compositor)
+        wl_compositor_destroy(wayland->wl_compositor);
+
+    if (wayland->wl_registry)
+        wl_registry_destroy(wayland->wl_registry);
+
+    if (wayland->wl_event_queue)
+        wl_event_queue_destroy(wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    memset(wayland, 0, sizeof(*wayland));
+}
+
+/**********************************************************************
+ *          wayland_process_init
+ *
+ *  Initialise the per process wayland objects.
+ *
+ */
+BOOL wayland_process_init(void)
+{
+    process_wl_display = wl_display_connect(NULL);
+    if (!process_wl_display)
+        return FALSE;
+
+    process_wayland = calloc(1, sizeof(*process_wayland));
+    if (!process_wayland)
+        return FALSE;
+
+    return wayland_init(process_wayland);
+}
+
+/**********************************************************************
+ *          wayland_is_process
+ *
+ *  Checks whether a wayland instance is the per-process one.
+ */
+BOOL wayland_is_process(struct wayland *wayland)
+{
+    return wayland == process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_acquire
+ *
+ *  Acquires the per-process wayland instance.
+ */
+struct wayland *wayland_process_acquire(void)
+{
+    wayland_mutex_lock(&process_wayland_mutex);
+    return process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_release
+ *
+ *  Releases the per-process wayland instance.
+ */
+void wayland_process_release(void)
+{
+    wayland_mutex_unlock(&process_wayland_mutex);
+}
+
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
+
+/**********************************************************************
+ *          wayland_notify_wine_monitor_change
+ *
+ * Notify all wayland instances about a change in the state of wine monitors.
+ * The notification is synchronous, this function returns after all wayland
+ * instances have handled the event, except if it a thread is slow to process
+ * the message, and thus likely to be blocked by this synchronous operation.
+ */
+void wayland_notify_wine_monitor_change(void)
+{
+    struct wayland *w;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    /* Each thread maintains its own output information, so we need to notify
+     * all threads about the change. We can't guarantee that all threads will
+     * have windows to which we could potentially send the notification message
+     * to, so we use the internal send function to target the threads directly.
+     * We can't use PostThreadMessage since we require synchronous message
+     * handling. */
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        LRESULT res;
+        TRACE("notifying thread %04x\n", w->thread_id);
+        /* Use a timeout of 50ms to avoid blocking indefinitely if the
+         * target thread is not processing (and to avoid deadlocks). */
+        res = __wine_send_internal_message_timeout(w->process_id, w->thread_id,
+                                                   WM_WAYLAND_MONITOR_CHANGE,
+                                                   0, 0, 0, 50, NULL);
+        /* If we weren't able to synchronously send the message, post it. */
+        if (!res)
+            NtUserPostThreadMessage(w->thread_id, WM_WAYLAND_MONITOR_CHANGE, 0, 0);
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
+
+/**********************************************************************
+ *          wayland_dispatch_queue
+ *
+ * Dispatch events from the specified queue. If the queue is empty,
+ * wait for timeout_ms for events to arrive and then dispatch any events in
+ * the queue.
+ *
+ * Returns the number of events dispatched, -1 on error
+ */
+int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
+{
+    struct pollfd pfd = {0};
+    BOOL is_process_queue = queue == process_wayland->wl_event_queue;
+    int ret;
+
+    TRACE("waiting for events with timeout=%d ...\n", timeout_ms);
+
+    pfd.fd = wl_display_get_fd(process_wl_display);
+
+    if (wl_display_prepare_read_queue(process_wl_display, queue) == -1)
+    {
+        if (is_process_queue) wayland_process_acquire();
+        if ((ret = wl_display_dispatch_queue_pending(process_wl_display, queue)) == -1)
+            TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+        if (is_process_queue) wayland_process_release();
+        TRACE("... done early\n");
+        return ret;
+    }
+
+    while (TRUE)
+    {
+        ret = wl_display_flush(process_wl_display);
+
+        if (ret != -1 || errno != EAGAIN)
+            break;
+
+        pfd.events = POLLOUT;
+        while ((ret = poll(&pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+
+        if (ret == -1)
+        {
+            TRACE("... failed poll out errno=%d\n", errno);
+            wl_display_cancel_read(process_wl_display);
+            return -1;
+        }
+    }
+
+    if (ret < 0 && errno != EPIPE)
+    {
+        wl_display_cancel_read(process_wl_display);
+        return -1;
+    }
+
+    pfd.events = POLLIN;
+    while ((ret = poll(&pfd, 1, timeout_ms)) == -1 && errno == EINTR) continue;
+
+    if (ret == 0)
+    {
+        TRACE("... done => 0 events (timeout)\n");
+        wl_display_cancel_read(process_wl_display);
+        return 0;
+    }
+
+    if (ret == -1)
+    {
+        TRACE("... failed poll errno=%d\n", errno);
+        wl_display_cancel_read(process_wl_display);
+        return -1;
+    }
+
+    if (wl_display_read_events(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_read_events errno=%d\n", errno);
+        return -1;
+    }
+
+    if (is_process_queue) wayland_process_acquire();
+    ret = wl_display_dispatch_queue_pending(process_wl_display, queue);
+    if (is_process_queue) wayland_process_release();
+    if (ret == -1)
+    {
+        TRACE("... failed wl_display_dispatch_queue_pending errno=%d\n", errno);
+        return -1;
+    }
+
+    /* We may have read and queued events in queues other than the specified
+     * one, so we need to notify threads (see wayland_read_events). */
+    wayland_notify_threads();
+
+    TRACE("... done => %d events\n", ret);
+
+    return ret;
+}
+
+/**********************************************************************
+ *          wayland_read_events_and_dispatch_process
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues, dispatch any events for the per-process wayland instance,
+ * and notify threads about the possibility of new per-thread wayland instance
+ * events (without dispatching them).
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events_and_dispatch_process(void)
+{
+    return (wayland_dispatch_queue(process_wayland->wl_event_queue, -1) != -1);
+}
+
+static int wayland_dispatch_thread_pending(struct wayland *wayland)
+{
+    char buf[64];
+
+    TRACE("wayland=%p queue=%p\n", wayland, wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    /* Consume notifications */
+    while (TRUE)
+    {
+        int ret = read(wayland->event_notification_pipe[0], buf, sizeof(buf));
+        if (ret > 0) continue;
+        if (ret == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EAGAIN) break; /* no data to read */
+            ERR("failed to read from notification pipe: %s\n", strerror(errno));
+            break;
+        }
+        if (ret == 0)
+        {
+            ERR("failed to read from notification pipe: pipe is closed\n");
+            break;
+        }
+    }
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->wl_event_queue);
+}
+
+static BOOL process_wayland_events(DWORD mask)
+{
+    struct wayland *wayland = thread_wayland();
+    int dispatched;
+
+    if (!wayland)
+        return FALSE;
+
+    wayland->last_dispatch_mask = 0;
+
+    dispatched = wayland_dispatch_thread_pending(wayland);
+    if (dispatched)
+        wayland->last_dispatch_mask |= QS_SENDMESSAGE;
+
+    TRACE("dispatched=%d mask=%s%s%s%s%s%s%s\n",
+          dispatched,
+          (wayland->last_dispatch_mask & QS_KEY) ? "QS_KEY|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEMOVE) ? "QS_MOUSEMOVE|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEBUTTON) ? "QS_MOUSEBUTTON|" : "",
+          (wayland->last_dispatch_mask & QS_INPUT) ? "QS_INPUT|" : "",
+          (wayland->last_dispatch_mask & QS_PAINT) ? "QS_PAINT|" : "",
+          (wayland->last_dispatch_mask & QS_POSTMESSAGE) ? "QS_POSTMESSAGE|" : "",
+          (wayland->last_dispatch_mask & QS_SENDMESSAGE) ? "QS_SENDMESSAGE|" : "");
+
+    return wayland->last_dispatch_mask & mask;
+}
+
+/***********************************************************************
+ *           WAYLAND_MsgWaitForMultipleObjectsEx
+ */
+NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                             const LARGE_INTEGER *timeout,
+                                             DWORD mask, DWORD flags)
+{
+    NTSTATUS ret;
+
+    if (process_wayland_events(mask))
+        return count - 1;
+
+    ret = NtWaitForMultipleObjects(count, handles, !(flags & MWMO_WAITALL),
+                                   !!(flags & MWMO_ALERTABLE), timeout);
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/wayland_buffer_queue.c b/dlls/winewayland.drv/wayland_buffer_queue.c
new file mode 100644
index 00000000000..c2a424e947a
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_buffer_queue.c
@@ -0,0 +1,216 @@
+/*
+ * Wayland buffer queue
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "winuser.h"
+#include "ntgdi.h"
+
+#include <errno.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p detached=%d\n", shm_buffer, shm_buffer->detached);
+
+    if (shm_buffer->detached)
+        wayland_shm_buffer_destroy(shm_buffer);
+    else
+        shm_buffer->busy = FALSE;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+    buffer_release
+};
+
+/**********************************************************************
+ *          wayland_buffer_queue_create
+ *
+ * Creates a buffer queue containing buffers with the specified width, height
+ * and format.
+ */
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int height,
+                                                         enum wl_shm_format format)
+{
+    struct wayland_buffer_queue *queue;
+
+    queue = calloc(1, sizeof(*queue));
+    if (!queue) goto err;
+
+    queue->wayland = wayland;
+    queue->wl_event_queue = wl_display_create_queue(wayland->wl_display);
+    if (!queue->wl_event_queue) goto err;
+    queue->width = width;
+    queue->height = height;
+    queue->format = format;
+
+    wl_list_init(&queue->buffer_list);
+
+    return queue;
+
+err:
+    if (queue) wayland_buffer_queue_destroy(queue);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_destroy
+ *
+ * Destroys a buffer queue and any contained buffers.
+ */
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer, *next;
+
+    wl_list_for_each_safe(shm_buffer, next, &queue->buffer_list, link)
+    {
+        /* If the buffer is busy (committed but not yet released by the
+         * compositor), destroying it now may cause surface contents to become
+         * undefined and lead to visual artifacts. In such a case, we hand off
+         * handling of this buffer to the thread event queue and track it in
+         * the detatched_shm_buffer_list while we wait for the release event in
+         * order to destroy it (see buffer_release handler). */
+        if (shm_buffer->busy)
+        {
+            wl_list_remove(&shm_buffer->link);
+            wl_list_insert(&queue->wayland->detached_shm_buffer_list,
+                           &shm_buffer->link);
+            shm_buffer->detached = TRUE;
+            wl_proxy_set_queue((struct wl_proxy *)shm_buffer->wl_buffer,
+                                queue->wayland->wl_event_queue);
+        }
+        else
+        {
+            wayland_shm_buffer_destroy(shm_buffer);
+        }
+    }
+
+    if (queue->wl_event_queue)
+    {
+        wl_display_dispatch_queue_pending(queue->wayland->wl_display,
+                                          queue->wl_event_queue);
+        wl_event_queue_destroy(queue->wl_event_queue);
+    }
+
+    free(queue);
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_acquire_buffer
+ *
+ * Acquires a free buffer from the buffer queue. If no free buffers
+ * are available this function blocks until it can provide one.
+ *
+ * The returned buffer is marked as unavailable until committed to
+ * a surface and subsequently released by the compositor.
+ */
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    TRACE("queue=%p\n", queue);
+
+    while (TRUE)
+    {
+        int nbuffers = 0;
+
+        /* Search through our buffers to find an available one. */
+        wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        {
+            if (!shm_buffer->busy)
+            {
+                shm_buffer->busy = TRUE;
+                goto out;
+            }
+            nbuffers++;
+        }
+
+        /* Dynamically create up to 3 buffers. */
+        if (nbuffers < 3)
+        {
+            HRGN full_dmg = NtGdiCreateRectRgn(0, 0, queue->width, queue->height);
+            shm_buffer = wayland_shm_buffer_create(queue->wayland, queue->width,
+                                                   queue->height, queue->format);
+            if (shm_buffer)
+            {
+                /* Buffer events go to their own queue so that we can dispatch
+                 * them independently. */
+                wl_proxy_set_queue((struct wl_proxy *) shm_buffer->wl_buffer,
+                                   queue->wl_event_queue);
+                wl_buffer_add_listener(shm_buffer->wl_buffer, &buffer_listener,
+                                       shm_buffer);
+                wl_list_insert(&queue->buffer_list, &shm_buffer->link);
+                wayland_shm_buffer_add_damage(shm_buffer, full_dmg);
+                shm_buffer->busy = TRUE;
+            }
+            NtGdiDeleteObjectApp(full_dmg);
+            /* If we failed to allocate a new buffer, but we have at least two
+             * buffers busy, there is a good chance the compositor will
+             * eventually release one of them, so dispatch events and wait
+             * below. Otherwise, give up and return a NULL buffer. */
+            if (shm_buffer)
+            {
+                goto out;
+            }
+            else if (nbuffers < 2)
+            {
+                ERR(" => failed to acquire buffer\n");
+                return NULL;
+            }
+        }
+
+        if (wayland_dispatch_queue(queue->wl_event_queue, -1) == -1)
+            return NULL;
+    }
+
+out:
+    TRACE(" => %p %dx%d stride=%d map=[%p, %p)\n",
+          shm_buffer, shm_buffer->width, shm_buffer->height,
+          shm_buffer->stride, shm_buffer->map_data,
+          (unsigned char*)shm_buffer->map_data + shm_buffer->map_size);
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_add_damage
+ *
+ * Adds damage to all buffers in this queue.
+ */
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        wayland_shm_buffer_add_damage(shm_buffer, damage);
+}
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
new file mode 100644
index 00000000000..7b5906740a3
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -0,0 +1,721 @@
+/*
+ * Wayland cursor handling
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "waylanddrv.h"
+
+#include "ntgdi.h"
+#include "ntuser.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static struct wl_cursor_theme *cursor_theme = NULL;
+
+static HCURSOR last_cursor;
+static HCURSOR invalid_cursor;
+
+/* Mapping between Windows cursors and native Wayland cursors
+ *
+ * Note that we have multiple possible names for each Wayland cursor. This
+ * happens because the names for each cursor may vary across different themes.
+ *
+ * This table was created based on the docs below.
+ *
+ * https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursora
+ * https://bugs.kde.org/attachment.cgi?id=67313
+ */
+static const char *idc_appstarting[] = {"half-busy", "progress", "left_ptr_watch",
+                                        "00000000000000020006000e7e9ffc3f",
+                                        "08e8e1c95fe2fc01f976f1e063a24ccd",
+                                        "3ecb610c1bf2410f44200f48c40d3599",
+                                        "9116a3ea924ed2162ecab71ba103b17f"};
+static const char *idc_arrow[] = {"default", "left_ptr",
+                                  "top_left_arrow", "left-arrow"};
+static const char *idc_cross[] = {"crosshair"};
+static const char *idc_hand[] = {"pointing_hand", "pointer", "hand", "hand2"};
+static const char *idc_help[] = {"help", "question_arrow", "whats_this",
+                                 "5c6cd98b3f3ebcb1f9c7f1c204630408",
+                                 "d9ce0ab605698f320427677b458ad60b"};
+static const char *idc_ibeam[] = {"text", "ibeam", "xterm"};
+static const char *idc_icon[] = {"icon"};
+static const char *idc_no[] = {"forbidden", "not-allowed"};
+static const char *idc_pen[] = {"pencil"};
+static const char *idc_sizeall[] = {"size_all"};
+static const char *idc_sizenesw[] = {"nesw-resize", "size_bdiag",
+                                     "50585d75b494802d0151028115016902",
+                                     "fcf1c3c7cd4491d801f1e1c78f100000"};
+static const char *idc_sizens[] = {"ns-resize", "size_ver", "v_double_arrow",
+                                   "00008160000006810000408080010102"};
+static const char *idc_sizenwse[] = {"nwse-resize", "size_fdiag",
+                                     "38c5dff7c7b8962045400281044508d2",
+                                     "c7088f0f3e6c8088236ef8e1e3e70000"};
+static const char *idc_sizewe[] = {"ew-resize", "size_hor", "h_double_arrow",
+                                   "028006030e0e7ebffc7f7070c0600140"};
+static const char *idc_uparrow[] = {"up_arrow"};
+static const char *idc_wait[] = {"wait", "watch",
+                                 "0426c94ea35c87780ff01dc239897213"};
+
+static struct wl_cursor *_wl_cursor_from_wine_cursor(struct wl_cursor_theme *wl_cursor_theme,
+                                                     unsigned long int wine_cursor_enum)
+{
+    unsigned int i, count;
+    static const char **cursors;
+    struct wl_cursor *cursor;
+
+    switch(wine_cursor_enum)
+    {
+        case IDC_APPSTARTING:
+            cursors = idc_appstarting;
+            count = ARRAY_SIZE(idc_appstarting);
+            break;
+        case IDC_ARROW:
+            cursors = idc_arrow;
+            count = ARRAY_SIZE(idc_arrow);
+            break;
+        case IDC_CROSS:
+            cursors = idc_cross;
+            count = ARRAY_SIZE(idc_cross);
+            break;
+        case IDC_HAND:
+            cursors = idc_hand;
+            count = ARRAY_SIZE(idc_hand);
+            break;
+        case IDC_HELP:
+            cursors = idc_help;
+            count = ARRAY_SIZE(idc_help);
+            break;
+        case IDC_IBEAM:
+            cursors = idc_ibeam;
+            count = ARRAY_SIZE(idc_ibeam);
+            break;
+        case IDC_ICON:
+            cursors = idc_icon;
+            count = ARRAY_SIZE(idc_icon);
+            break;
+        case IDC_NO:
+            cursors = idc_no;
+            count = ARRAY_SIZE(idc_no);
+            break;
+        case IDC_PEN:
+            cursors = idc_pen;
+            count = ARRAY_SIZE(idc_pen);
+            break;
+        case IDC_SIZE:
+        case IDC_SIZEALL:
+            cursors = idc_sizeall;
+            count = ARRAY_SIZE(idc_sizeall);
+            break;
+        case IDC_SIZENESW:
+            cursors = idc_sizenesw;
+            count = ARRAY_SIZE(idc_sizenesw);
+            break;
+        case IDC_SIZENS:
+            cursors = idc_sizens;
+            count = ARRAY_SIZE(idc_sizens);
+            break;
+        case IDC_SIZENWSE:
+            cursors = idc_sizenwse;
+            count = ARRAY_SIZE(idc_sizenwse);
+            break;
+        case IDC_SIZEWE:
+            cursors = idc_sizewe;
+            count = ARRAY_SIZE(idc_sizewe);
+            break;
+        case IDC_UPARROW:
+            cursors = idc_uparrow;
+            count = ARRAY_SIZE(idc_uparrow);
+            break;
+        case IDC_WAIT:
+            cursors = idc_wait;
+            count = ARRAY_SIZE(idc_wait);
+            break;
+        default:
+            return NULL;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        cursor = wl_cursor_theme_get_cursor(wl_cursor_theme, cursors[i]);
+        if (cursor)
+            return cursor;
+    }
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           get_icon_info
+ *
+ * Local GetIconInfoExW helper implementation.
+ */
+static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
+{
+    UNICODE_STRING module, res_name;
+    ICONINFO info;
+
+    module.Buffer = ret->szModName;
+    module.MaximumLength = sizeof(ret->szModName) - sizeof(WCHAR);
+    res_name.Buffer = ret->szResName;
+    res_name.MaximumLength = sizeof(ret->szResName) - sizeof(WCHAR);
+    if (!NtUserGetIconInfo(handle, &info, &module, &res_name, NULL, 0)) return FALSE;
+    ret->fIcon = info.fIcon;
+    ret->xHotspot = info.xHotspot;
+    ret->yHotspot = info.yHotspot;
+    ret->hbmColor = info.hbmColor;
+    ret->hbmMask = info.hbmMask;
+    ret->wResID = res_name.Length ? 0 : LOWORD(res_name.Buffer);
+    ret->szModName[module.Length] = 0;
+    ret->szResName[res_name.Length] = 0;
+    return TRUE;
+}
+
+/***********************************************************************
+ *           create_mono_cursor_buffer
+ *
+ * Return a monochrome icon/cursor wl_shm_buffer
+ */
+static struct wayland_shm_buffer *create_mono_cursor_buffer(struct wayland *wayland,
+                                                            HBITMAP bmp)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    BITMAP bm;
+    char *mask = NULL;
+    unsigned int i, j, stride, mask_size, *ptr;
+
+    if (!NtGdiExtGetObjectW(bmp, sizeof(bm), &bm)) return NULL;
+    stride = ((bm.bmWidth + 15) >> 3) & ~1;
+    mask_size = stride * bm.bmHeight;
+    if (!(mask = malloc(mask_size))) return NULL;
+    if (!NtGdiGetBitmapBits(bmp, mask_size, mask)) goto done;
+
+    bm.bmHeight /= 2;
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto done;
+
+    ptr = shm_buffer->map_data;
+    for (i = 0; i < bm.bmHeight; i++)
+    {
+        for (j = 0; j < bm.bmWidth; j++, ptr++)
+        {
+            int and = ((mask[i * stride + j / 8] << (j % 8)) & 0x80);
+            int xor = ((mask[(i + bm.bmHeight) * stride + j / 8] << (j % 8)) & 0x80);
+            if (!xor && and)
+                *ptr = 0;
+            else if (xor && !and)
+                *ptr = 0xffffffff;
+            else
+                /* we can't draw "invert" pixels, so render them as black instead */
+                *ptr = 0xff000000;
+        }
+    }
+
+done:
+    free(mask);
+    return shm_buffer;
+}
+
+/***********************************************************************
+ *           get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icons and cursors.
+ */
+static struct wayland_shm_buffer *create_color_cursor_buffer(struct wayland *wayland,
+                                                             HDC hdc, HBITMAP color,
+                                                             HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        free(mask_bits);
+    }
+
+    /* Wayland requires pre-multiplied alpha values */
+    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
+    {
+        unsigned char alpha = *ptr >> 24;
+        if (alpha == 0)
+        {
+            *ptr = 0;
+        }
+        else if (alpha != 255)
+        {
+            *ptr = (alpha << 24) |
+                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
+                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
+                   (((BYTE)*ptr * alpha / 255));
+        }
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
+/***********************************************************************
+ *           get_wine_cursor_size
+ *
+ * We use the Wine cursor IDC_ARROW to compute the size that we should use in
+ * the Wayland native cursors. The bitmap usually does not have the same
+ * dimensions of the icon, as it uses a margin. So we take the IDC_ARROW and
+ * compute its height.
+ */
+static int get_wine_cursor_size(struct wayland *wayland)
+{
+    HCURSOR handle = NULL;
+    ICONINFOEXW info = { 0 };
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    unsigned int *pixels, *row, p, x, y;
+    int first_non_empty_line = -1, last_non_empty_line = -1;
+
+    handle = LoadImageW(0, (const WCHAR *)IDC_ARROW, IMAGE_CURSOR, 0, 0,
+                        LR_SHARED | LR_DEFAULTSIZE);
+    if (!handle)
+        goto out;
+
+    if (!get_icon_info(handle, &info))
+        goto out;
+
+    if (info.hbmColor)
+    {
+        HDC hdc = NtGdiCreateCompatibleDC(0);
+        shm_buffer = create_color_cursor_buffer(wayland, hdc,
+                                                info.hbmColor, info.hbmMask);
+        NtGdiDeleteObjectApp(hdc);
+    }
+    else
+    {
+        shm_buffer = create_mono_cursor_buffer(wayland, info.hbmMask);
+    }
+
+    if (!shm_buffer)
+        goto out;
+
+    pixels = (unsigned int *) shm_buffer->map_data;
+
+    /* Compute the height of the IDC_ARROW */
+    for (y = 0; y < shm_buffer->height; y++)
+    {
+        row = (unsigned int *)((unsigned char *)pixels + y * shm_buffer->stride);
+        for (x = 0; x < shm_buffer->width; x++)
+        {
+            p = row[x];
+            /* alpha 0 means fully transparent, so no content in the
+             * pixel - any other pixel we consider content */
+            if ((p & 0xff000000) == 0)
+                continue;
+            /* it's the first time that we find a content pixel, so we set
+             * the first non empty line variable accordingly */
+            if (first_non_empty_line == -1)
+                first_non_empty_line = y;
+            /* we found a content pixel in a line, so update the latest line
+             * that does have content */
+            last_non_empty_line = y;
+            /* we don't care about the other pixels of the line if we have
+             * already found a content pixel on it */
+            break;
+        }
+    }
+
+out:
+    if (handle) NtUserDestroyCursor(handle, 0);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (shm_buffer) wayland_shm_buffer_destroy(shm_buffer);
+
+    if (first_non_empty_line == -1 || last_non_empty_line == -1)
+        return -1;
+
+    return (last_non_empty_line - first_non_empty_line + 1);
+}
+
+void wayland_cursor_theme_init(struct wayland *wayland)
+{
+    char *theme;
+    int size;
+
+    if (!wayland->wl_shm)
+        return;
+
+    size = get_wine_cursor_size(wayland);
+    if (size <= 0)
+       return;
+
+    /* Some compositors set this env var, others don't. But that's fine, if we
+     * call wl_cursor_theme_load() with theme == NULL it will fallback and try
+     * to load the default system theme. */
+    theme = getenv("XCURSOR_THEME");
+
+    cursor_theme = wl_cursor_theme_load(theme, size, wayland->wl_shm);
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info = { 0 };
+    struct wayland_cursor *wayland_cursor = NULL;
+    struct wayland_shm_buffer *shm_buffer = NULL;
+
+    if (!handle) return NULL;
+
+    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto out;
+
+    if (!get_icon_info(handle, &info)) goto out;
+
+    /* First try to get the native Wayland cursor (if the config option is set
+     * and the per-process Wayland instance was able to load the theme) */
+    if (option_use_system_cursors && cursor_theme)
+    {
+        struct wl_cursor_image *wl_cursor_image;
+        struct wl_cursor *wl_cursor;
+
+        wayland_cursor->owns_wl_buffer = FALSE;
+        wl_cursor = _wl_cursor_from_wine_cursor(cursor_theme, MAKEINTRESOURCE(info.wResID));
+        if (wl_cursor && wl_cursor->image_count > 0)
+        {
+            /* TODO: add animated cursor support
+             * cursor->images[i] for i > 0 is only used by animations. */
+            wl_cursor_image = wl_cursor->images[0];
+            wayland_cursor->wl_buffer = wl_cursor_image_get_buffer(wl_cursor_image);
+            if (wayland_cursor->wl_buffer)
+            {
+                wayland_cursor->width = wl_cursor_image->width;
+                wayland_cursor->height = wl_cursor_image->height;
+
+                if (pointer->focused_surface)
+                {
+                    wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                             wl_cursor_image->hotspot_x,
+                                                             wl_cursor_image->hotspot_y,
+                                                             &wayland_cursor->hotspot_x,
+                                                             &wayland_cursor->hotspot_y);
+                }
+                else
+                {
+                    wayland_cursor->hotspot_x = wl_cursor_image->hotspot_x;
+                    wayland_cursor->hotspot_y = wl_cursor_image->hotspot_y;
+                }
+            }
+        }
+    }
+
+    /* If we couldn't get native Wayland cursor (or we didn't even try,
+     * because the config to use it was not set), we copy the Wine cursor
+     * content to a wl_buffer */
+    if (!wayland_cursor->wl_buffer)
+    {
+        wayland_cursor->owns_wl_buffer = TRUE;
+        if (info.hbmColor)
+        {
+            HDC hdc = NtGdiCreateCompatibleDC(0);
+            shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+                                                    info.hbmColor, info.hbmMask);
+            NtGdiDeleteObjectApp(hdc);
+        }
+        else
+        {
+            shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+        }
+
+        if (!shm_buffer) goto out;
+
+        wayland_cursor->width = shm_buffer->width;
+        wayland_cursor->height = shm_buffer->height;
+        wayland_cursor->wl_buffer =
+            wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+
+        /* make sure hotspot is valid */
+        if (info.xHotspot >= wayland_cursor->width ||
+            info.yHotspot >= wayland_cursor->height)
+        {
+            info.xHotspot = wayland_cursor->width / 2;
+            info.yHotspot = wayland_cursor->height / 2;
+        }
+
+        if (pointer->focused_surface)
+        {
+            wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                    info.xHotspot, info.yHotspot,
+                                                    &wayland_cursor->hotspot_x,
+                                                    &wayland_cursor->hotspot_y);
+        }
+        else
+        {
+            wayland_cursor->hotspot_x = info.xHotspot;
+            wayland_cursor->hotspot_y = info.yHotspot;
+        }
+    }
+
+out:
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (wayland_cursor && !wayland_cursor->wl_buffer)
+    {
+        wayland_cursor_destroy(wayland_cursor);
+        wayland_cursor = NULL;
+    }
+    return wayland_cursor;
+}
+
+/***********************************************************************
+ *           wayland_cursor_destroy
+ *
+ *  Destroy a Wayland cursor and its associated resources.
+ */
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
+{
+    if (!wayland_cursor)
+        return;
+
+    if (wayland_cursor->wl_buffer)
+    {
+        /* When using Wayland native cursors, we get the cursor wl_buffer from
+         * using wl_cursor_image_get_buffer(). In such case, the compositor owns
+         * the wl_buffer instead of us. So we should not destroy it. */
+        if (wayland_cursor->owns_wl_buffer)
+            wl_buffer_destroy(wayland_cursor->wl_buffer);
+    }
+
+    free(wayland_cursor);
+}
+
+/***********************************************************************
+ *           wayland_pointer_update_cursor_from_win32
+ *
+ *  Update a Wayland pointer to use the specified cursor, or NULL
+ *  to hide the cursor.
+ */
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle)
+{
+    struct wayland_cursor *wayland_cursor = pointer->cursor;
+
+    TRACE("pointer=%p pointer->hcursor=%p handle=%p\n",
+          pointer, pointer ? pointer->hcursor : 0, handle);
+
+    if (!pointer->wl_pointer)
+        return;
+
+    if (pointer->hcursor != handle)
+    {
+        wayland_cursor = wayland_cursor_from_win32(pointer, handle);
+        /* If we can't create a cursor from a valid handle, better to keep the
+         * previous cursor than make it disappear completely. */
+        if (!wayland_cursor && handle)
+            return;
+
+        if (pointer->cursor)
+            wayland_cursor_destroy(pointer->cursor);
+    }
+
+    pointer->cursor = wayland_cursor;
+    pointer->hcursor = handle;
+
+    if (!pointer->cursor)
+    {
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  NULL, 0, 0);
+            return;
+    }
+
+    wl_surface_attach(pointer->cursor_wl_surface, pointer->cursor->wl_buffer, 0, 0);
+    wl_surface_damage_buffer(pointer->cursor_wl_surface, 0, 0,
+                             wayland_cursor->width, wayland_cursor->height);
+    if (pointer->focused_surface)
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface,
+                                    wayland_surface_get_buffer_scale(pointer->focused_surface));
+    else
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface, 1);
+
+    wl_surface_commit(pointer->cursor_wl_surface);
+
+    wl_pointer_set_cursor(pointer->wl_pointer,
+                          pointer->enter_serial,
+                          pointer->cursor_wl_surface,
+                          pointer->cursor->hotspot_x,
+                          pointer->cursor->hotspot_y);
+}
+
+/***********************************************************************
+ *           wayland_init_set_cursor
+ *
+ *  Initalize internal information, so that we can track the last set
+ *  cursor properly.
+ */
+BOOL wayland_init_set_cursor(void)
+{
+    /* Allocate a handle that we are going to treat as invalid. */
+    SERVER_START_REQ(alloc_user_handle)
+    {
+        if (!wine_server_call_err(req))
+            invalid_cursor = wine_server_ptr_handle(reply->handle);
+    }
+    SERVER_END_REQ;
+
+    TRACE("invalid_cursor=%p\n", invalid_cursor);
+
+    last_cursor = invalid_cursor;
+
+    return invalid_cursor != NULL;
+}
+
+/***********************************************************************
+ *           wayland_invalidate_set_cursor
+ *
+ *  Invalidate the cursor we consider to be set, effectively forcing
+ *  the application of next SetCursor call.
+ */
+void wayland_invalidate_set_cursor(void)
+{
+    __atomic_store_n(&last_cursor, invalid_cursor, __ATOMIC_SEQ_CST);
+}
+
+static HWND wayland_get_thread_cursor_hwnd(void)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND cursor_hwnd;
+
+    if (wayland && wayland->pointer.focused_surface)
+        cursor_hwnd = wayland->pointer.focused_surface->hwnd;
+    else
+        cursor_hwnd = NULL;
+
+    return cursor_hwnd;
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursor
+ */
+void WAYLAND_SetCursor(HCURSOR hcursor)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+
+    TRACE("hcursor=%p last_cursor=%p cursor_hwnd=%p\n",
+          hcursor, last_cursor, cursor_hwnd);
+
+    if (!cursor_hwnd) return;
+
+    if (__atomic_exchange_n(&last_cursor, hcursor, __ATOMIC_SEQ_CST) != hcursor)
+    {
+        send_message(cursor_hwnd, WM_WAYLAND_SET_CURSOR, GetCurrentThreadId(),
+                     (LPARAM)hcursor);
+        /* Cursor visibility affects pointer confinement mode. */
+        send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+                     WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP, 0);
+    }
+}
+
+/***********************************************************************
+ *           WAYLAND_ClipCursor
+ */
+BOOL WAYLAND_ClipCursor(const RECT *clip)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+    WPARAM constrain;
+
+    if (!cursor_hwnd) return TRUE;
+
+    constrain = clip ? WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP :
+                       WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP;
+
+    send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE, constrain, 0);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursorPos
+ */
+BOOL WAYLAND_SetCursorPos(int x, int y)
+{
+    HWND cursor_hwnd = wayland_get_thread_cursor_hwnd();
+
+    TRACE("cursor_hwnd=%p, x=%d, y=%d\n", cursor_hwnd, x, y);
+
+    if (!cursor_hwnd) return TRUE;
+
+    send_message(cursor_hwnd, WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+                 WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS, 0);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..755e21215a4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,908 @@
+/*
+ * Wayland data device (clipboard and DnD) handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#define NONAMELESSUNION
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "objidl.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
+struct wayland_data_offer
+{
+    IDataObject data_object;
+    struct wayland *wayland;
+    struct wl_data_offer *wl_data_offer;
+    struct wl_array types;
+    uint32_t source_actions;
+    uint32_t action;
+    const char *accepted_mime_type;
+};
+
+/* Normalize the mime type by skipping inconsequential characters, such as
+ * spaces and double quotes, and converting to lower case. */
+static char *normalize_mime_type(const char *mime)
+{
+    char *new_mime;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    cur_read = mime;
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime = malloc(new_mime_len + 1);
+    if (!new_mime) return NULL;
+    cur_read = mime;
+    cur_write = new_mime;
+
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime;
+}
+
+static DWORD dnd_actions_to_drop_effect(uint32_t actions)
+{
+    DWORD drop_effect = 0;
+
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+        drop_effect |= DROPEFFECT_COPY;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+        drop_effect |= DROPEFFECT_MOVE;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+        drop_effect |= DROPEFFECT_COPY | DROPEFFECT_MOVE;
+
+    return drop_effect;
+}
+
+/**********************************************************************
+ *          wl_data_offer handling
+ */
+
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer,
+                             const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    char **p;
+
+    p = wl_array_add(&data_offer->types, sizeof *p);
+    *p = normalize_mime_type(type);
+}
+
+static void data_offer_source_actions(void *data,
+                                      struct wl_data_offer *wl_data_offer,
+                                      uint32_t source_actions)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->source_actions = source_actions;
+}
+
+static void data_offer_action(void *data, struct wl_data_offer *wl_data_offer,
+                              uint32_t dnd_action)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->action = dnd_action;
+}
+
+static const struct wl_data_offer_listener data_offer_listener = {
+    data_offer_offer,
+    data_offer_source_actions,
+    data_offer_action
+};
+
+static ULONG_PTR zero_bits(void)
+{
+#ifdef _WIN64
+    return !NtCurrentTeb()->WowTebOffset ? 0 : 0x7fffffff;
+#else
+    return 0;
+#endif
+}
+
+static void wayland_data_offer_create(struct wayland *wayland,
+                                      struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_offer *data_offer = NULL;
+    SIZE_T size = sizeof(*data_offer);
+
+    /* Ensure that the PE side can access the 'data_object' member, by
+     * allocating wayland_data_offer in Windows virtual memory. */
+    if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&data_offer,
+                                zero_bits(), &size, MEM_COMMIT, PAGE_READWRITE) ||
+        !data_offer)
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->wayland = wayland;
+    data_offer->wl_data_offer = wl_data_offer;
+    wl_array_init(&data_offer->types);
+    wl_data_offer_add_listener(data_offer->wl_data_offer,
+                               &data_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+    SIZE_T size = 0;
+
+    wl_data_offer_destroy(data_offer->wl_data_offer);
+    wl_array_for_each(p, &data_offer->types)
+        free(*p);
+    wl_array_release(&data_offer->types);
+
+    NtFreeVirtualMemory(GetCurrentProcess(), (void **)&data_offer, &size, MEM_RELEASE);
+}
+
+static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
+                                             const char *mime_type,
+                                             size_t *size_out)
+{
+    int data_pipe[2] = {-1, -1};
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    buffer = malloc(buffer_size);
+    if (buffer == NULL)
+    {
+        ERR("failed to allocate read buffer for data offer\n");
+        goto out;
+    }
+
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+        goto out;
+
+    TRACE("mime_type=%s\n", mime_type);
+
+    wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(data_offer->wayland->wl_display);
+
+    do
+    {
+        struct pollfd pfd = { .fd = data_pipe[0], .events = POLLIN };
+        int ret;
+
+        /* Wait a limited amount of time for the data to arrive, since otherwise
+         * a misbehaving data source could block us indefinitely. */
+        while ((ret = poll(&pfd, 1, 3000)) == -1 && errno == EINTR) continue;
+        if (ret <= 0 || !(pfd.revents & (POLLIN | POLLHUP)))
+        {
+            TRACE("failed polling data offer pipe ret=%d errno=%d revents=0x%x\n",
+                  ret, ret == -1 ? errno : 0, pfd.revents);
+            total = 0;
+            goto out;
+        }
+
+        nread = read(data_pipe[0], buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            ERR("failed to read data offer pipe\n");
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                unsigned char *new_buffer;
+                buffer_size += 4096;
+                new_buffer = realloc(buffer, buffer_size);
+                if (!new_buffer)
+                {
+                    ERR("failed to reallocate read buffer for data offer\n");
+                    total = 0;
+                    goto out;
+                }
+                buffer = new_buffer;
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("received %d bytes\n", total);
+
+out:
+    if (data_pipe[0] >= 0)
+        close(data_pipe[0]);
+
+    if (total == 0 && buffer != NULL)
+    {
+        free(buffer);
+        buffer = NULL;
+    }
+
+    *size_out = total;
+
+    return buffer;
+}
+
+static void *wayland_data_offer_import_format(struct wayland_data_offer *data_offer,
+                                              struct wayland_data_device_format *format,
+                                              size_t *ret_size)
+{
+    size_t data_size;
+    void *data, *ret;
+
+    data = wayland_data_offer_receive_data(data_offer, format->mime_type, &data_size);
+    if (!data)
+        return NULL;
+
+    ret = format->import(format, data, data_size, ret_size);
+
+    free(data);
+
+    return ret;
+}
+
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+}
+
+static void wayland_data_device_destroy_dnd_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->dnd_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->dnd_wl_data_offer = NULL;
+    }
+}
+
+static void data_device_data_offer(void *data,
+                                   struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_offer_create(data_device->wayland, wl_data_offer);
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    struct wayland_surface *wayland_surface;
+    POINT point;
+
+    /* Any previous dnd offer should have been freed by a drop or leave event. */
+    assert(data_device->dnd_wl_data_offer == NULL);
+
+    data_device->dnd_wl_data_offer = wl_data_offer;
+
+    if (!wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    wayland_surface = wl_surface_get_user_data(wl_surface);
+
+    if (!wayland_surface || !wayland_surface->hwnd)
+        return;
+
+    data_device->dnd_enter_serial = serial;
+    data_device->dnd_surface = wayland_surface;
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    /* Clear accepted_mime_type here. It should be eventually set by
+     * the DnD client call below. */
+    data_offer->accepted_mime_type = NULL;
+
+    params.event = CLIENT_DND_EVENT_ENTER;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) != 0)
+        return;
+
+    wl_data_offer_set_actions(wl_data_offer, data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    POINT point;
+
+    TRACE("surface=%p hwnd=%p\n",
+          data_device->dnd_surface,
+          data_device->dnd_surface ? data_device->dnd_surface->hwnd : 0);
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    params.event = CLIENT_DND_EVENT_LEAVE;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = 0;
+    params.data_object = 0;
+
+    WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params));
+
+out:
+    wayland_data_device_destroy_dnd_data_offer(data_device);
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    POINT point;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    params.event = CLIENT_DND_EVENT_MOTION;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) != 0)
+        return;
+
+    wl_data_offer_set_actions(data_device->dnd_wl_data_offer,
+                              data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(data_device->dnd_wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+    struct waylanddrv_client_dnd_params params;
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    POINT point;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    params.event = CLIENT_DND_EVENT_DROP;
+    params.hwnd = HandleToULong(data_device->dnd_surface->hwnd);
+    params.point = point;
+    params.drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    params.data_object = PtrToUint(data_offer);
+
+    if (WAYLANDDRV_CLIENT_CALL(dnd, &params, sizeof(params)) == 0)
+        wl_data_offer_finish(data_device->dnd_wl_data_offer);
+
+out:
+    wayland_data_device_destroy_dnd_data_offer(data_device);
+}
+
+static void data_device_selection(void *data,
+                                  struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_device *data_device = data;
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    TRACE("wl_data_offer=%u\n",
+          wl_data_offer ? wl_proxy_get_id((struct wl_proxy*)wl_data_offer) : 0);
+
+    /* We may get a selection event before we have had a chance to create the
+     * clipboard window after thread init (see wayland_init_thread_data), so
+     * we need to ensure we have a valid window here. */
+    wayland_data_device_ensure_clipboard_window(wayland);
+
+    /* Destroy any previous data offer. */
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+
+    /* If we didn't get an offer and we are the clipboard owner, empty the
+     * clipboard. Otherwise ignore the empty offer completely. */
+    if (!wl_data_offer)
+    {
+        if (NtUserGetClipboardOwner() == wayland->clipboard_hwnd)
+        {
+            NtUserOpenClipboard(NULL, 0);
+            NtUserEmptyClipboard();
+            NtUserCloseClipboard();
+        }
+        return;
+    }
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * from us to notify external wayland clients about a wine clipboard update.
+     * The clipboard already contains all the required data, plus we need to ignore
+     * this in order to avoid an endless notification loop. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("ignoring offer produced by winewayland\n");
+            goto ignore_selection;
+        }
+    }
+
+    if (!NtUserOpenClipboard(data_offer->wayland->clipboard_hwnd, 0))
+    {
+        WARN("failed to open clipboard for selection\n");
+        goto ignore_selection;
+    }
+
+    NtUserEmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            struct set_clipboard_params params = { .data = NULL };
+            TRACE("Avalaible clipboard format for %s => %u\n", *p, format->clipboard_format);
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+    data_device->clipboard_wl_data_offer = wl_data_offer;
+
+    return;
+
+ignore_selection:
+    wayland_data_offer_destroy(data_offer);
+}
+
+static const struct wl_data_device_listener data_device_listener = {
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection
+};
+
+/**********************************************************************
+ *          wayland_data_device_init
+ *
+ * Initializes the data_device extension in order to support clipboard
+ * operations.
+ */
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland)
+{
+    data_device->wayland = wayland;
+    data_device->wl_data_device =
+        wl_data_device_manager_get_data_device(wayland->wl_data_device_manager,
+                                               wayland->wl_seat);
+
+    wl_data_device_add_listener(data_device->wl_data_device, &data_device_listener,
+                                data_device);
+}
+
+/**********************************************************************
+ *          wayland_data_device_deinit
+ */
+void wayland_data_device_deinit(struct wayland_data_device *data_device)
+{
+    if (data_device->wl_data_device)
+        wl_data_device_destroy(data_device->wl_data_device);
+
+    memset(data_device, 0, sizeof(*data_device));
+}
+
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void wayland_data_source_export(struct wayland_data_device_format *format, int32_t fd)
+{
+    struct get_clipboard_params params = { .data_only = TRUE, .data_size = 0 };
+    static const size_t buffer_size = 1024;
+
+    if (!(params.data = malloc(buffer_size))) return;
+
+    if (!NtUserOpenClipboard(thread_wayland()->clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for export\n");
+        goto out;
+    }
+
+    params.size = buffer_size;
+    if (NtUserGetClipboardData(format->clipboard_format, &params))
+    {
+        format->export(format, fd, params.data, params.size);
+    }
+    else if (params.data_size)
+    {
+        /* If 'buffer_size' is too small, NtUserGetClipboardData writes the
+         * minimum size in 'params.data_size', so we retry with that. */
+        free(params.data);
+        params.data = malloc(params.data_size);
+        if (params.data)
+        {
+            params.size = params.data_size;
+            if (NtUserGetClipboardData(format->clipboard_format, &params))
+                format->export(format, fd, params.data, params.size);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+out:
+    free(params.data);
+}
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct wayland_data_device_format *format =
+        wayland_data_device_format_for_mime_type(mime_type);
+
+    TRACE("source=%p mime_type=%s\n", source, mime_type);
+
+    if (format) wayland_data_source_export(format, fd);
+
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    TRACE("source=%p\n", source);
+    wl_data_source_destroy(source);
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener = {
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
+/**********************************************************************
+ *          clipboard window handling
+ */
+
+static void clipboard_update(void)
+{
+    struct wayland *wayland = thread_wayland();
+    uint32_t enter_serial;
+    struct wl_data_source *source;
+    UINT clipboard_format = 0;
+
+    TRACE("WM_CLIPBOARDUPDATE wayland %p enter_serial=%d/%d\n",
+          wayland,
+          wayland ? wayland->keyboard.enter_serial : -1,
+          wayland ? wayland->pointer.enter_serial : -1);
+
+    if (!wayland)
+        return;
+
+    enter_serial = wayland->keyboard.enter_serial ? wayland->keyboard.enter_serial
+                                                  : wayland->pointer.enter_serial;
+
+    if (!enter_serial)
+        return;
+
+    if (!NtUserOpenClipboard(wayland->clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard\n");
+        return;
+    }
+
+    source = wl_data_device_manager_create_data_source(wayland->wl_data_device_manager);
+
+    while ((clipboard_format = NtUserEnumClipboardFormats(clipboard_format)))
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_clipboard_format(clipboard_format, NULL);
+        if (format)
+        {
+            TRACE("Offering source=%p mime=%s\n", source, format->mime_type);
+            wl_data_source_offer(source, format->mime_type);
+        }
+    }
+
+    /* Add a special entry so that we can detect when an offer is coming from us. */
+    wl_data_source_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
+
+    wl_data_source_add_listener(source, &data_source_listener, NULL);
+    wl_data_device_set_selection(wayland->data_device.wl_data_device, source,
+                                 enter_serial);
+
+    NtUserCloseClipboard();
+}
+
+static void clipboard_render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device;
+    struct wayland_data_offer *data_offer;
+    struct wayland_data_device_format *format;
+
+    data_device = wl_data_device_get_user_data(thread_wayland()->data_device.wl_data_device);
+    if (!data_device->clipboard_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    if (!data_offer)
+        return;
+
+    format = wayland_data_device_format_for_clipboard_format(clipboard_format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        struct set_clipboard_params params = { 0 };
+        if ((params.data = wayland_data_offer_import_format(data_offer, format, &params.size)))
+        {
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+            free(params.data);
+        }
+    }
+}
+
+static void clipboard_destroy(void)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_device *data_device =
+        wl_data_device_get_user_data(wayland->data_device.wl_data_device);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+}
+
+/**********************************************************************
+ *          waylanddrv_unix_clipboard_message
+ */
+NTSTATUS waylanddrv_unix_clipboard_message(void *arg)
+{
+    struct waylanddrv_unix_clipboard_message_params *params = arg;
+
+    switch (params->msg)
+    {
+    case WM_NCCREATE:
+        return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        TRACE("WM_CLIPBOARDUPDATE\n");
+        /* Ignore our own updates */
+        if (NtUserGetClipboardOwner() != params->hwnd) clipboard_update();
+        break;
+    case WM_RENDERFORMAT:
+        TRACE("WM_RENDERFORMAT: %ld\n", params->wparam);
+        clipboard_render_format(params->wparam);
+        break;
+    case WM_DESTROYCLIPBOARD:
+        TRACE("WM_DESTROYCLIPBOARD: clipboard_hwnd=%p\n", params->hwnd);
+        clipboard_destroy();
+        break;
+    }
+
+    return NtUserMessageCall(params->hwnd, params->msg, params->wparam,
+                             params->lparam, NULL, NtUserDefWindowProc, FALSE);
+}
+
+/**********************************************************************
+ *          wayland_data_device_ensure_clipboard_window
+ *
+ * Creates (if not already created) the window which handles clipboard
+ * messages for the specified wayland instance.
+ */
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
+{
+    if (!wayland->clipboard_hwnd)
+    {
+        wayland->clipboard_hwnd =
+            ULongToHandle(WAYLANDDRV_CLIENT_CALL(create_clipboard_window, NULL, 0));
+    }
+}
+
+NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg)
+{
+    struct waylanddrv_unix_data_offer_accept_format_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    struct wayland_data_device_format *format;
+
+    TRACE("data_offer=%p clipboard_format=%d\n", data_offer, p->format);
+
+    format = wayland_data_device_format_for_clipboard_format(p->format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        TRACE("found offer %s for clipboard format %u\n",
+              format->mime_type, format->clipboard_format);
+        data_offer->accepted_mime_type = format->mime_type;
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+NTSTATUS waylanddrv_unix_data_offer_enum_formats(void *arg)
+{
+    struct waylanddrv_unix_data_offer_enum_formats_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    char **mime;
+    UINT count = 0;
+
+    wl_array_for_each(mime, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*mime);
+        if (format)
+        {
+            if (p->formats && p->num_formats < count)
+                p->formats[count] = format->clipboard_format;
+            count++;
+        }
+    }
+
+    p->num_formats = count;
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg)
+{
+    struct waylanddrv_unix_data_offer_import_format_params *p = arg;
+    struct wayland_data_offer *data_offer = UIntToPtr(p->data_offer);
+    struct wayland_data_device_format *format;
+
+    TRACE("data_offer=%p clipboard_format=%d\n", data_offer, p->format);
+
+    format = wayland_data_device_format_for_clipboard_format(p->format,
+                                                             &data_offer->types);
+    if (format)
+    {
+        void *data, *vdata = NULL;
+        size_t size;
+        SIZE_T vsize;
+
+        if (!(data = wayland_data_offer_import_format(data_offer, format, &size)))
+            return STATUS_UNSUCCESSFUL;
+        vsize = size;
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), (void **)&vdata,
+                                    zero_bits(), &vsize, MEM_COMMIT, PAGE_READWRITE) ||
+            !vdata)
+        {
+            free(data);
+            return STATUS_UNSUCCESSFUL;
+        }
+        memcpy(vdata, data, size);
+        p->data = PtrToUint(vdata);
+        p->size = size;
+        free(data);
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
diff --git a/dlls/winewayland.drv/wayland_data_device_dll.c b/dlls/winewayland.drv/wayland_data_device_dll.c
new file mode 100644
index 00000000000..5bac8125bac
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_dll.c
@@ -0,0 +1,526 @@
+/*
+ * Wayland data device (clipboard and DnD) handling (DLL code)
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv_dll.h"
+
+#define COBJMACROS
+#include "objidl.h"
+#include "shlobj.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static IDataObjectVtbl dataOfferDataObjectVtbl;
+
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    struct waylanddrv_unix_clipboard_message_params params;
+
+    switch (msg)
+    {
+    case WM_NCCREATE:
+    case WM_CLIPBOARDUPDATE:
+    case WM_RENDERFORMAT:
+    case WM_DESTROYCLIPBOARD:
+        params.hwnd = hwnd;
+        params.msg = msg;
+        params.wparam = wp;
+        params.lparam = lp;
+        return WAYLANDDRV_UNIX_CALL(clipboard_message, &params);
+    }
+
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size)
+{
+    static const WCHAR clipboard_classname[] = {
+        '_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d',
+        '_','m','a','n','a','g','e','r',0
+    };
+    WNDCLASSW class;
+    HWND clipboard_hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW(&class) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %u\n", GetLastError());
+        return 0;
+    }
+
+    if (!(clipboard_hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                         HWND_MESSAGE, 0, 0, NULL)))
+    {
+        ERR("failed to create clipboard window err %u\n", GetLastError());
+        return 0;
+    }
+
+    if (!AddClipboardFormatListener(clipboard_hwnd))
+        ERR("failed to set clipboard listener %u\n", GetLastError());
+
+    TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
+    return HandleToUlong(clipboard_hwnd);
+}
+
+/**********************************************************************
+ *          IDropTarget discovery
+ *
+ * Based on functions in dlls/ole32/ole2.c
+ */
+
+static HANDLE get_drop_target_local_handle(HWND hwnd)
+{
+    static const WCHAR prop_marshalleddrop_target[] =
+        {'W','i','n','e','M','a','r','s','h','a','l','l','e','d',
+         'D','r','o','p','T','a','r','g','e','t',0};
+    HANDLE handle;
+    HANDLE local_handle = 0;
+
+    handle = GetPropW(hwnd, prop_marshalleddrop_target);
+    if (handle)
+    {
+        DWORD pid;
+        HANDLE process;
+
+        GetWindowThreadProcessId(hwnd, &pid);
+        process = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid);
+        if (process)
+        {
+            DuplicateHandle(process, handle, GetCurrentProcess(), &local_handle,
+                            0, FALSE, DUPLICATE_SAME_ACCESS);
+            CloseHandle(process);
+        }
+    }
+    return local_handle;
+}
+
+static HRESULT create_stream_from_map(HANDLE map, IStream **stream)
+{
+    HRESULT hr = E_OUTOFMEMORY;
+    HGLOBAL hmem;
+    void *data;
+    MEMORY_BASIC_INFORMATION info;
+
+    data = MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
+    if(!data) return hr;
+
+    VirtualQuery(data, &info, sizeof(info));
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, info.RegionSize);
+    if(hmem)
+    {
+        memcpy(GlobalLock(hmem), data, info.RegionSize);
+        GlobalUnlock(hmem);
+        hr = CreateStreamOnHGlobal(hmem, TRUE, stream);
+    }
+    UnmapViewOfFile(data);
+    return hr;
+}
+
+static IDropTarget* get_drop_target_pointer(HWND hwnd)
+{
+    IDropTarget *drop_target = NULL;
+    HANDLE map;
+    IStream *stream;
+
+    map = get_drop_target_local_handle(hwnd);
+    if(!map) return NULL;
+
+    if(SUCCEEDED(create_stream_from_map(map, &stream)))
+    {
+        CoUnmarshalInterface(stream, &IID_IDropTarget, (void**)&drop_target);
+        IStream_Release(stream);
+    }
+    CloseHandle(map);
+    return drop_target;
+}
+
+static IDropTarget *drop_target_from_window_point(HWND hwnd, POINT point)
+{
+    HWND child;
+    IDropTarget *drop_target;
+    HWND orig_hwnd = hwnd;
+    POINT orig_point = point;
+
+    /* Find the deepest child window. */
+    ScreenToClient(hwnd, &point);
+    while ((child = ChildWindowFromPointEx(hwnd, point, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE)) &&
+            child != hwnd)
+    {
+        MapWindowPoints(hwnd, child, &point, 1);
+        hwnd = child;
+    }
+
+    /* Ascend the children hierarchy until we find one that accepts drops. */
+    do
+    {
+        drop_target = get_drop_target_pointer(hwnd);
+    } while (drop_target == NULL && (hwnd = GetParent(hwnd)) != NULL);
+
+    TRACE("hwnd=%p point=(%d,%d) => dnd_hwnd=%p drop_target=%p\n",
+          orig_hwnd, orig_point.x, orig_point.y, hwnd, drop_target);
+    return drop_target;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_enter(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    IDataObject *data_object = UIntToPtr(p->data_object);
+    HRESULT hr;
+
+    /* If unixlib is 64 bits and PE is 32 bits, this will write a 32 bit
+     * pointer value to the bottom of 64 bit pointer variable, which works out
+     * fine due to little-endianness and the fact that lpVtbl has been zero
+     * initialized. */
+    data_object->lpVtbl = &dataOfferDataObjectVtbl;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragEnter(drop_target, data_object, MK_LBUTTON,
+                               *(POINTL*)&p->point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_leave(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragLeave(drop_target);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_motion(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (!drop_target)
+        return STATUS_UNSUCCESSFUL;
+
+    hr = IDropTarget_DragOver(drop_target, MK_LBUTTON, *(POINTL*)&p->point,
+                              &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return STATUS_UNSUCCESSFUL;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI waylanddrv_client_dnd_drop(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+    IDropTarget *drop_target;
+    DWORD drop_effect = p->drop_effect;
+    IDataObject *data_object = UIntToPtr(p->data_object);
+    HRESULT hr;
+
+    drop_target = drop_target_from_window_point(ULongToHandle(p->hwnd), p->point);
+    if (drop_target)
+    {
+        hr = IDropTarget_Drop(drop_target, data_object, MK_LBUTTON,
+                              *(POINTL*)&p->point, &drop_effect);
+        IDropTarget_Release(drop_target);
+        if (SUCCEEDED(hr) && drop_effect != DROPEFFECT_NONE)
+            return STATUS_SUCCESS;
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size)
+{
+    struct waylanddrv_client_dnd_params *p = params;
+
+    switch (p->event) {
+    case CLIENT_DND_EVENT_ENTER:
+        return waylanddrv_client_dnd_enter(params, size);
+    case CLIENT_DND_EVENT_LEAVE:
+        return waylanddrv_client_dnd_leave(params, size);
+    case CLIENT_DND_EVENT_MOTION:
+        return waylanddrv_client_dnd_motion(params, size);
+    case CLIENT_DND_EVENT_DROP:
+        return waylanddrv_client_dnd_drop(params, size);
+    }
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+/*********************************************************
+ * Implementation of IDataObject for wayland data offers *
+ *********************************************************/
+
+static HRESULT WINAPI dataOfferDataObject_QueryInterface(IDataObject *data_object,
+                                                         REFIID riid, void **object)
+{
+    TRACE("(%p, %s, %p)\n", data_object, debugstr_guid(riid), object);
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDataObject))
+    {
+        *object = data_object;
+        IDataObject_AddRef(data_object);
+        return S_OK;
+    }
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI dataOfferDataObject_AddRef(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when the data_offer is destroyed, so we don't care about proper
+     * reference tracking. */
+    return 2;
+}
+
+static ULONG WINAPI dataOfferDataObject_Release(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when, so we don't care about proper reference tracking. */
+    return 1;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium)
+{
+    HRESULT hr;
+    struct waylanddrv_unix_data_offer_import_format_params params;
+    void *data;
+
+    TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
+
+    hr = IDataObject_QueryGetData(data_object, format_etc);
+    if (!SUCCEEDED(hr))
+        return hr;
+
+    params.data_offer = PtrToUint(data_object);
+    params.format = format_etc->cfFormat;
+    params.data = 0;
+    params.size = 0;
+
+    if (WAYLANDDRV_UNIX_CALL(data_offer_import_format, &params) != 0 || !params.data)
+        return E_UNEXPECTED;
+
+    data = UIntToPtr(params.data);
+
+    medium->hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, params.size);
+    if (medium->hGlobal == NULL)
+        return E_OUTOFMEMORY;
+    memcpy(GlobalLock(medium->hGlobal), data, params.size);
+    GlobalUnlock(medium->hGlobal);
+
+    medium->tymed = TYMED_HGLOBAL;
+    medium->pUnkForRelease = 0;
+
+    VirtualFree(data, params.size, MEM_RELEASE);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
+                                                      FORMATETC *format_etc,
+                                                      STGMEDIUM *medium)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, medium);
+    return DATA_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
+                                                       FORMATETC *format_etc)
+{
+    struct waylanddrv_unix_data_offer_accept_format_params params;
+
+    TRACE("(%p, %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%d}\n",
+          data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
+          format_etc->cfFormat);
+
+    if (format_etc->tymed && !(format_etc->tymed & TYMED_HGLOBAL))
+    {
+        FIXME("only HGLOBAL medium types supported right now\n");
+        return DV_E_TYMED;
+    }
+
+    params.data_offer = PtrToUint(data_object);
+    params.format = format_etc->cfFormat;
+
+    if (WAYLANDDRV_UNIX_CALL(data_offer_accept_format, &params) == 0)
+        return S_OK;
+
+    TRACE("didn't find offer for clipboard format %u\n", format_etc->cfFormat);
+    return DV_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetCanonicalFormatEtc(IDataObject *data_object,
+                                                                FORMATETC *format_etc,
+                                                                FORMATETC *format_etc_out)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, format_etc_out);
+    format_etc_out->ptd = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium, BOOL release)
+{
+    FIXME("(%p, %p, %p, %s): stub\n", data_object, format_etc,
+          medium, release ? "TRUE" : "FALSE");
+    return E_NOTIMPL;
+}
+
+static BOOL formats_etc_contains_clipboard_format(FORMATETC *formats_etc,
+                                                  size_t formats_etc_count,
+                                                  UINT clipboard_format)
+{
+    size_t i;
+
+    for (i = 0; i < formats_etc_count; i++)
+        if (formats_etc[i].cfFormat == clipboard_format) return TRUE;
+
+    return FALSE;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
+                                                        DWORD direction,
+                                                        IEnumFORMATETC **enum_format_etc)
+{
+    HRESULT hr;
+    FORMATETC *formats_etc;
+    size_t formats_etc_count = 0;
+    struct waylanddrv_unix_data_offer_enum_formats_params params;
+
+    TRACE("(%p, %u, %p)\n", data_object, direction, enum_format_etc);
+
+    if (direction != DATADIR_GET)
+    {
+        FIXME("only the get direction is implemented\n");
+        return E_NOTIMPL;
+    }
+
+    params.data_offer = PtrToUint(data_object);
+    params.formats = NULL;
+    params.num_formats = 0;
+
+    WAYLANDDRV_UNIX_CALL(data_offer_enum_formats, &params);
+    params.formats = HeapAlloc(GetProcessHeap(), 0, params.num_formats * sizeof(UINT));
+    WAYLANDDRV_UNIX_CALL(data_offer_enum_formats, &params);
+    if (!params.formats)
+        return E_OUTOFMEMORY;
+
+    /* Allocate space for all offered mime types, although we may not use them all */
+    formats_etc = HeapAlloc(GetProcessHeap(), 0, params.num_formats * sizeof(FORMATETC));
+    if (!formats_etc)
+    {
+        HeapFree(GetProcessHeap(), 0, params.formats);
+        return E_OUTOFMEMORY;
+    }
+
+    for (int i = 0; i < params.num_formats; i++)
+    {
+        if (!formats_etc_contains_clipboard_format(formats_etc, formats_etc_count,
+                                                   params.formats[i]))
+        {
+            FORMATETC *current= &formats_etc[formats_etc_count];
+
+            current->cfFormat = params.formats[i];
+            current->ptd = NULL;
+            current->dwAspect = DVASPECT_CONTENT;
+            current->lindex = -1;
+            current->tymed = TYMED_HGLOBAL;
+
+            formats_etc_count += 1;
+        }
+    }
+
+    hr = SHCreateStdEnumFmtEtc(formats_etc_count, formats_etc, enum_format_etc);
+    HeapFree(GetProcessHeap(), 0, params.formats);
+    HeapFree(GetProcessHeap(), 0, formats_etc);
+
+    return hr;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
+                                                  FORMATETC *format_etc, DWORD advf,
+                                                  IAdviseSink *advise_sink,
+                                                  DWORD *connection)
+{
+    FIXME("(%p, %p, %u, %p, %p): stub\n", data_object, format_etc, advf,
+          advise_sink, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DUnadvise(IDataObject *data_object,
+                                                    DWORD connection)
+{
+    FIXME("(%p, %u): stub\n", data_object, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumDAdvise(IDataObject *data_object,
+                                                      IEnumSTATDATA **enum_advise)
+{
+    FIXME("(%p, %p): stub\n", data_object, enum_advise);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static IDataObjectVtbl dataOfferDataObjectVtbl =
+{
+    dataOfferDataObject_QueryInterface,
+    dataOfferDataObject_AddRef,
+    dataOfferDataObject_Release,
+    dataOfferDataObject_GetData,
+    dataOfferDataObject_GetDataHere,
+    dataOfferDataObject_QueryGetData,
+    dataOfferDataObject_GetCanonicalFormatEtc,
+    dataOfferDataObject_SetData,
+    dataOfferDataObject_EnumFormatEtc,
+    dataOfferDataObject_DAdvise,
+    dataOfferDataObject_DUnadvise,
+    dataOfferDataObject_EnumDAdvise
+};
diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
new file mode 100644
index 00000000000..069a4157cbe
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -0,0 +1,599 @@
+/*
+ * Wayland data device format handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "shlobj.h"
+#include "winternl.h"
+#include "winnls.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+
+    while (nwritten < count)
+    {
+        ssize_t ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR)
+        {
+            WARN("Failed to write all data, had %zu bytes, wrote %zu bytes (errno: %d)\n",
+                 count, nwritten, errno);
+            break;
+        }
+        else if (ret > 0)
+        {
+            nwritten += ret;
+        }
+    }
+}
+
+#define NLS_SECTION_CODEPAGE 11
+
+static BOOL get_cp_tableinfo(ULONG cp, CPTABLEINFO *cptable)
+{
+    USHORT *ptr;
+    SIZE_T nls_size;
+
+    if (!NtGetNlsSectionPtr(NLS_SECTION_CODEPAGE, cp, NULL, (void **)&ptr, &nls_size))
+    {
+        RtlInitCodePageTable(ptr, cptable);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void *import_text_as_unicode(struct wayland_data_device_format *format,
+                                    const void *data, size_t data_size, size_t *ret_size)
+{
+    DWORD wsize;
+    void *ret;
+
+    if (format->extra == CP_UTF8)
+    {
+        RtlUTF8ToUnicodeN(NULL, 0, &wsize, data, data_size);
+        if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+        RtlUTF8ToUnicodeN(ret, wsize, &wsize, data, data_size);
+    }
+    else
+    {
+        CPTABLEINFO cptable;
+        /* In the worst case, each byte of the input text data corresponds
+         * to a single character, which may need up to two WCHAR for UTF-16
+         * encoding. */
+        wsize = data_size * sizeof(WCHAR) * 2;
+        if (!get_cp_tableinfo(format->extra, &cptable)) return NULL;
+        if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+        RtlCustomCPToUnicodeN(&cptable, ret, wsize, &wsize, data, data_size);
+    }
+    ((WCHAR *)ret)[wsize / sizeof(WCHAR)] = 0;
+
+    if (ret_size) *ret_size = wsize + sizeof(WCHAR);
+
+    return ret;
+}
+
+static void export_text(struct wayland_data_device_format *format, int fd, void *data, size_t size)
+{
+    DWORD byte_count;
+    char *bytes;
+
+    /* Wayland apps expect strings to not be zero-terminated, so avoid
+     * zero-terminating the resulting converted string. */
+    if (((WCHAR *)data)[size / sizeof(WCHAR) - 1] == 0) size -= sizeof(WCHAR);
+
+    if (format->extra == CP_UTF8)
+    {
+        RtlUnicodeToUTF8N(NULL, 0, &byte_count, data, size);
+        if (!(bytes = malloc(byte_count))) return;
+        RtlUnicodeToUTF8N(bytes, byte_count, &byte_count, data, size);
+    }
+    else
+    {
+        CPTABLEINFO cptable;
+        if (!get_cp_tableinfo(format->extra, &cptable)) return;
+        byte_count = size / sizeof(WCHAR) * cptable.MaximumCharacterSize;
+        if (!(bytes = malloc(byte_count))) return;
+        RtlUnicodeToCustomCPN(&cptable, bytes, byte_count, &byte_count, data, size);
+    }
+
+    write_all(fd, bytes, byte_count);
+
+    free(bytes);
+}
+
+static void *import_data(struct wayland_data_device_format *format,
+                         const void *data, size_t data_size, size_t *ret_size)
+{
+    void *ret;
+
+    ret = malloc(data_size);
+    if (ret)
+    {
+        memcpy(ret, data, data_size);
+        if (ret_size) *ret_size = data_size;
+    }
+
+    return ret;
+}
+
+static void export_data(struct wayland_data_device_format *format, int fd, void *data, size_t size)
+{
+    write_all(fd, data, size);
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static char *decode_uri(const char *uri, size_t uri_length)
+{
+    char *decoded = malloc(uri_length + 1);
+    size_t uri_i = 0;
+    size_t decoded_i = 0;
+
+    if (decoded == NULL)
+        goto err;
+
+    while (uri_i < uri_length)
+    {
+        if (uri[uri_i] == '%')
+        {
+            unsigned long number;
+            char buffer[3];
+
+            if (uri_i + 1 == uri_length || uri_i + 2 == uri_length)
+                goto err;
+
+            buffer[0] = uri[uri_i + 1];
+            buffer[1] = uri[uri_i + 2];
+            buffer[2] = '\0';
+            errno = 0;
+            number = strtoul(buffer, NULL, 16);
+            if (errno != 0) goto err;
+            decoded[decoded_i] = number;
+
+            uri_i += 3;
+            decoded_i++;
+        }
+        else
+        {
+            decoded[decoded_i++] = uri[uri_i++];
+        }
+    }
+
+    decoded[decoded_i] = '\0';
+
+    return decoded;
+
+err:
+    free(decoded);
+    return NULL;
+}
+
+/* based on wine_get_dos_file_name */
+static WCHAR *get_dos_file_name(const char *path)
+{
+    ULONG len = strlen(path) + 9; /* \??\unix prefix */
+    WCHAR *ret;
+
+    if (!(ret = malloc(len * sizeof(WCHAR)))) return NULL;
+    if (wine_unix_to_nt_file_name(path, ret, &len))
+    {
+        free(ret);
+        return NULL;
+    }
+
+    if (ret[5] == ':')
+    {
+        /* get rid of the \??\ prefix */
+        memmove(ret, ret + 4, (len - 4) * sizeof(WCHAR));
+    }
+    else
+    {
+        ret[1] = '\\';
+    }
+    return ret;
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static WCHAR* decoded_uri_to_dos(const char *uri)
+{
+    WCHAR *ret = NULL;
+
+    if (strncmp(uri, "file:/", 6))
+        return NULL;
+
+    if (uri[6] == '/')
+    {
+        if (uri[7] == '/')
+        {
+            /* file:///path/to/file (nautilus, thunar) */
+            ret = get_dos_file_name(&uri[7]);
+        }
+        else if (uri[7])
+        {
+            /* file://hostname/path/to/file (X file drag spec) */
+            char hostname[256];
+            char *path = strchr(&uri[7], '/');
+            if (path)
+            {
+                *path = '\0';
+                if (strcmp(&uri[7], "localhost") == 0)
+                {
+                    *path = '/';
+                    ret = get_dos_file_name(path);
+                }
+                else if (gethostname(hostname, sizeof(hostname)) == 0)
+                {
+                    if (strcmp(hostname, &uri[7]) == 0)
+                    {
+                        *path = '/';
+                        ret = get_dos_file_name(path);
+                    }
+                }
+            }
+        }
+    }
+    else if (uri[6])
+    {
+        /* file:/path/to/file (konqueror) */
+        ret = get_dos_file_name(&uri[5]);
+    }
+
+    return ret;
+}
+
+static void *import_uri_list(struct wayland_data_device_format *format,
+                             const void *data, size_t data_size, size_t *ret_size)
+{
+    DROPFILES *drop_files = NULL;
+    size_t drop_size;
+    const char *data_end = (const char *) data + data_size;
+    const char *line_start = data;
+    const char *line_end;
+    WCHAR **path;
+    struct wl_array paths;
+    size_t total_chars = 0;
+    WCHAR *dst;
+
+    TRACE("data=%p size=%lu\n", data, (unsigned long)data_size);
+
+    wl_array_init(&paths);
+
+    while (line_start < data_end)
+    {
+        /* RFC 2483 requires CRLF for text/uri-list line termination, but
+         * some applications send LF. Accept both line terminators. */
+        line_end = strchr(line_start, '\n');
+        if (line_end == NULL)
+        {
+            WARN("URI list line doesn't end in (\\r)\\n\n");
+            break;
+        }
+
+        if (line_end > line_start && line_end[-1] == '\r') line_end--;
+
+        if (line_start[0] != '#')
+        {
+            char *decoded_uri = decode_uri(line_start, line_end - line_start);
+            TRACE("decoded_uri=%s\n", decoded_uri);
+            path = wl_array_add(&paths, sizeof *path);
+            if (!path) goto out;
+            *path = decoded_uri_to_dos(decoded_uri);
+            total_chars += lstrlenW(*path) + 1;
+            free(decoded_uri);
+        }
+
+        line_start = line_end + (*line_end == '\r' ? 2 : 1);
+    }
+
+    /* DROPFILES points to an array of consecutive null terminated WCHAR strings,
+     * followed by a final 0 WCHAR to denote the end of the array. We place that
+     * array just after the DROPFILE struct itself. */
+    drop_size = sizeof(DROPFILES) + (total_chars + 1) * sizeof(WCHAR);
+    if (!(drop_files = malloc(drop_size)))
+        goto out;
+
+    drop_files->pFiles = sizeof(*drop_files);
+    drop_files->pt.x = 0;
+    drop_files->pt.y = 0;
+    drop_files->fNC = FALSE;
+    drop_files->fWide = TRUE;
+
+    dst = (WCHAR *)(drop_files + 1);
+    wl_array_for_each(path, &paths)
+    {
+        lstrcpyW(dst, *path);
+        dst += lstrlenW(*path) + 1;
+    }
+    *dst = 0;
+
+    if (ret_size) *ret_size = drop_size;
+
+out:
+    wl_array_for_each(path, &paths)
+        free(*path);
+
+    wl_array_release(&paths);
+
+    return drop_files;
+}
+
+static CPTABLEINFO *get_ansi_cp(void)
+{
+    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
+    static CPTABLEINFO cp;
+    if (!cp.CodePage)
+    {
+        if (NtCurrentTeb()->Peb->AnsiCodePageData)
+            RtlInitCodePageTable(NtCurrentTeb()->Peb->AnsiCodePageData, &cp);
+        else
+            RtlInitCodePageTable(utf8_hdr, &cp);
+    }
+    return &cp;
+}
+
+/* Helper functions to implement export_hdrop, adapted from winex11.drv */
+
+static BOOL get_nt_pathname(const WCHAR *name, UNICODE_STRING *nt_name)
+{
+    static const WCHAR ntprefixW[] = {'\\','?','?','\\'};
+    static const WCHAR uncprefixW[] = {'U','N','C','\\'};
+    size_t len = lstrlenW(name);
+    WCHAR *ptr;
+
+    nt_name->MaximumLength = (len + 8) * sizeof(WCHAR);
+    if (!(ptr = malloc(nt_name->MaximumLength))) return FALSE;
+    nt_name->Buffer = ptr;
+
+    memcpy(ptr, ntprefixW, sizeof(ntprefixW));
+    ptr += ARRAYSIZE(ntprefixW);
+    if (name[0] == '\\' && name[1] == '\\')
+    {
+        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
+        {
+            name += 4;
+            len -= 4;
+        }
+        else
+        {
+            memcpy(ptr, uncprefixW, sizeof(uncprefixW));
+            ptr += ARRAYSIZE(uncprefixW);
+            name += 2;
+            len -= 2;
+        }
+    }
+    memcpy(ptr, name, (len + 1) * sizeof(WCHAR));
+    ptr += len;
+    nt_name->Length = (ptr - nt_name->Buffer) * sizeof(WCHAR);
+    return TRUE;
+}
+
+static char *get_unix_file_name(const WCHAR *dosW)
+{
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    ULONG size = 256;
+    char *buffer;
+
+    if (!get_nt_pathname(dosW, &nt_name)) return NULL;
+    InitializeObjectAttributes(&attr, &nt_name, 0, 0, NULL);
+    for (;;)
+    {
+        if (!(buffer = malloc(size)))
+        {
+            free(nt_name.Buffer);
+            return NULL;
+        }
+        status = wine_nt_to_unix_file_name(&attr, buffer, &size, FILE_OPEN_IF);
+        if (status != STATUS_BUFFER_TOO_SMALL) break;
+        free(buffer);
+    }
+    free(nt_name.Buffer);
+    if (status)
+    {
+        free(buffer);
+        return NULL;
+    }
+    return buffer;
+}
+
+/* Export text/uri-list to CF_HDROP, adapted from winex11.drv */
+static void export_hdrop(struct wayland_data_device_format *format, int fd,
+                         void *data, size_t size)
+{
+    char *textUriList = NULL;
+    UINT textUriListSize = 32;
+    UINT next = 0;
+    const WCHAR *ptr;
+    WCHAR *unicode_data = NULL;
+    DROPFILES *drop_files = data;
+
+    if (!drop_files->fWide)
+    {
+        char *files = (char *)data + drop_files->pFiles;
+        CPTABLEINFO *cp = get_ansi_cp();
+        DWORD len = 0;
+
+        while (files[len]) len += strlen(files + len) + 1;
+        len++;
+
+        if (!(ptr = unicode_data = malloc(len * sizeof(WCHAR)))) goto out;
+
+        if (cp->CodePage == CP_UTF8)
+            RtlUTF8ToUnicodeN(unicode_data, len * sizeof(WCHAR), &len, files, len);
+        else
+            RtlCustomCPToUnicodeN(cp, unicode_data, len * sizeof(WCHAR), &len, files, len);
+    }
+    else ptr = (const WCHAR *)((char *)data + drop_files->pFiles);
+
+    if (!(textUriList = malloc(textUriListSize))) goto out;
+
+    while (*ptr)
+    {
+        char *unixFilename = NULL;
+        UINT uriSize;
+        UINT u;
+
+        unixFilename = get_unix_file_name(ptr);
+        if (unixFilename == NULL) goto out;
+        ptr += lstrlenW(ptr) + 1;
+
+        uriSize = 8 + /* file:/// */
+                  3 * (lstrlenA(unixFilename) - 1) + /* "%xy" per char except first '/' */
+                  2; /* \r\n */
+        if ((next + uriSize) > textUriListSize)
+        {
+            UINT biggerSize = max(2 * textUriListSize, next + uriSize);
+            void *bigger = realloc(textUriList, biggerSize);
+            if (bigger)
+            {
+                textUriList = bigger;
+                textUriListSize = biggerSize;
+            }
+            else
+            {
+                free(unixFilename);
+                goto out;
+            }
+        }
+        lstrcpyA(&textUriList[next], "file:///");
+        next += 8;
+        /* URL encode everything - unnecessary, but easier/lighter than
+         * linking in shlwapi, and can't hurt */
+        for (u = 1; unixFilename[u]; u++)
+        {
+            static const char hex_table[] = "0123456789abcdef";
+            textUriList[next++] = '%';
+            textUriList[next++] = hex_table[unixFilename[u] >> 4];
+            textUriList[next++] = hex_table[unixFilename[u] & 0xf];
+        }
+        textUriList[next++] = '\r';
+        textUriList[next++] = '\n';
+        free(unixFilename);
+    }
+
+    write_all(fd, textUriList, next);
+
+out:
+    free(unicode_data);
+    free(textUriList);
+}
+
+#define CP_ASCII 20127
+
+static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+static const WCHAR pngW[] = {'P','N','G',0};
+static const WCHAR jfifW[] = {'J','F','I','F',0};
+static const WCHAR gifW[] = {'G','I','F',0};
+
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct wayland_data_device_format supported_formats[] =
+{
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
+    {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/rtf", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/richtext", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_hdrop, 0},
+    {"image/tiff", CF_TIFF, NULL, import_data, export_data, 0},
+    {"image/png", 0, pngW, import_data, export_data, 0},
+    {"image/jpeg", 0, jfifW, import_data, export_data, 0},
+    {"image/gif", 0, gifW, import_data, export_data, 0},
+    {NULL, 0, NULL, NULL, NULL, 0},
+};
+
+static ATOM register_clipboard_format(const WCHAR *name)
+{
+    ATOM atom;
+    if (NtAddAtom(name, lstrlenW(name) * sizeof(WCHAR), &atom)) return 0;
+    return atom;
+}
+
+void wayland_data_device_init_formats(void)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = register_clipboard_format(format->register_name);
+        format++;
+    }
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (!strcmp(mime, format->mime_type))
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
+
+static BOOL string_array_contains(struct wl_array *array, const char *str)
+{
+    char **p;
+
+    wl_array_for_each(p, array)
+        if (!strcmp(*p, str)) return TRUE;
+
+    return FALSE;
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                                   struct wl_array *mimes)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == clipboard_format &&
+            (!mimes || string_array_contains(mimes, format->mime_type)))
+        {
+             return format;
+        }
+        format++;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
new file mode 100644
index 00000000000..78c5185d5bf
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -0,0 +1,702 @@
+/*
+ * Wayland dmabuf buffers
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <drm_fourcc.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+enum dmabuf_dev_prio {
+    DMABUF_DEV_NODEV,
+    DMABUF_DEV_SCANOUT,
+    DMABUF_DEV_RENDER,
+    DMABUF_DEV_MAIN
+};
+
+/**********************************************************************
+ *          dmabuf private helpers
+ */
+
+static BOOL dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
+{
+    return dmabuf->version >= ZWP_LINUX_DMABUF_V1_GET_DEFAULT_FEEDBACK_SINCE_VERSION;
+}
+
+static int dmabuf_feedback_get_tranche_priority(struct wayland_dmabuf_feedback *feedback,
+                                                struct wayland_dmabuf_feedback_tranche *tranche,
+                                                dev_t render_dev)
+{
+    if (tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT)
+        return DMABUF_DEV_SCANOUT;
+    else if (tranche->device == render_dev)
+        return DMABUF_DEV_RENDER;
+    else if (tranche->device == feedback->main_device)
+        return DMABUF_DEV_MAIN;
+
+    return DMABUF_DEV_NODEV;
+}
+
+static BOOL dmabuf_format_has_modifier(struct wayland_dmabuf_format *format, uint64_t modifier)
+{
+    uint64_t *mod;
+
+    wl_array_for_each(mod, &format->modifiers)
+        if (*mod == modifier) return TRUE;
+
+    return FALSE;
+}
+
+static struct wayland_dmabuf_format *dmabuf_format_array_find_format(struct wl_array *formats,
+                                                                     uint32_t format)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+    BOOL format_found = FALSE;
+
+    wl_array_for_each(dmabuf_format, formats)
+    {
+        if (dmabuf_format->format == format)
+        {
+            format_found = TRUE;
+            break;
+        }
+    }
+
+    if (!format_found) dmabuf_format = NULL;
+
+    return dmabuf_format;
+}
+
+static struct wayland_dmabuf_format *dmabuf_feedback_get_format_from_optimal_tranche(struct wayland_dmabuf_feedback *feedback,
+                                                                                     uint32_t format,
+                                                                                     dev_t render_dev,
+                                                                                     struct wayland_dmabuf_feedback_tranche **out_tranche)
+{
+    struct wayland_dmabuf_format *dmabuf_format = NULL;
+    struct wayland_dmabuf_feedback_tranche *tranche;
+    int prio;
+
+    for (prio = DMABUF_DEV_SCANOUT; prio <= DMABUF_DEV_MAIN; prio++)
+    {
+        wl_array_for_each(tranche, &feedback->tranches)
+        {
+            if (prio == dmabuf_feedback_get_tranche_priority(feedback, tranche, render_dev) &&
+                (dmabuf_format = dmabuf_format_array_find_format(&tranche->formats, format)))
+                break;
+        }
+        if (dmabuf_format) break;
+    }
+
+    if (dmabuf_format && out_tranche) *out_tranche = tranche;
+
+    return dmabuf_format;
+}
+
+static size_t dmabuf_format_get_modifiers(struct wayland_dmabuf_format *dmabuf_format, uint64_t **modifiers)
+{
+    uint32_t num_modifiers = dmabuf_format->modifiers.size / sizeof(uint64_t);
+
+    if (num_modifiers == 1)
+    {
+        uint64_t *mod = (uint64_t *) dmabuf_format->modifiers.data;
+        if (*mod == DRM_FORMAT_MOD_INVALID) num_modifiers = 0;
+    }
+
+    if (num_modifiers > 0)
+        *modifiers = dmabuf_format->modifiers.data;
+    else
+        *modifiers = NULL;
+
+    return num_modifiers;
+}
+
+static BOOL dmabuf_format_array_add_format_modifier(struct wl_array *formats,
+                                                    uint32_t format,
+                                                    uint64_t modifier)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+    uint64_t *mod;
+
+    if ((dmabuf_format = dmabuf_format_array_find_format(formats, format)))
+    {
+        /* Avoid a possible duplicate, e.g., if compositor sends both format and
+         * modifier event with a DRM_FORMAT_MOD_INVALID. */
+        if (dmabuf_format_has_modifier(dmabuf_format, modifier))
+            goto out;
+    }
+    else
+    {
+        if (!(dmabuf_format = wl_array_add(formats, sizeof(*dmabuf_format))))
+            goto out;
+        dmabuf_format->format = format;
+        wl_array_init(&dmabuf_format->modifiers);
+    }
+
+    if (!(mod = wl_array_add(&dmabuf_format->modifiers, sizeof(uint64_t))))
+    {
+        dmabuf_format = NULL;
+        goto out;
+    }
+
+    *mod = modifier;
+
+out:
+    return dmabuf_format != NULL;
+}
+
+static void dmabuf_format_array_release(struct wl_array *formats)
+{
+    struct wayland_dmabuf_format *format;
+
+    wl_array_for_each(format, formats)
+        wl_array_release(&format->modifiers);
+
+    wl_array_release(formats);
+}
+
+static void dmabuf_feedback_tranche_init(struct wayland_dmabuf_feedback_tranche *tranche)
+{
+    memset(tranche, 0, sizeof(*tranche));
+    wl_array_init(&tranche->formats);
+}
+
+/* Moves src tranche to dst, and resets src. */
+static void dmabuf_feedback_tranche_move(struct wayland_dmabuf_feedback_tranche *dst,
+                                         struct wayland_dmabuf_feedback_tranche *src)
+{
+    memcpy(dst, src, sizeof(*dst));
+    dmabuf_feedback_tranche_init(src);
+}
+
+/**********************************************************************
+ *          zwp_linux_dmabuf_v1 handling
+ */
+
+static void dmabuf_format(void *data, struct zwp_linux_dmabuf_v1 *zwp_dmabuf, uint32_t format)
+{
+    struct wayland_dmabuf *dmabuf = data;
+
+    if (!dmabuf_format_array_add_format_modifier(&dmabuf->formats, format, DRM_FORMAT_MOD_INVALID))
+        WARN("Could not add format 0x%08x\n", format);
+}
+
+static void dmabuf_modifiers(void *data, struct zwp_linux_dmabuf_v1 *zwp_dmabuf, uint32_t format,
+                             uint32_t mod_hi, uint32_t mod_lo)
+{
+    struct wayland_dmabuf *dmabuf = data;
+    const uint64_t modifier = (uint64_t)mod_hi << 32 | mod_lo;
+
+    if (!dmabuf_format_array_add_format_modifier(&dmabuf->formats, format, modifier))
+        WARN("Could not add format/modifier 0x%08x/0x%" PRIx64 "\n", format, modifier);
+}
+
+static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
+    dmabuf_format,
+    dmabuf_modifiers
+};
+
+/**********************************************************************
+ *          default feedback handling
+ */
+
+static void dmabuf_feedback_main_device(void *data,
+                                        struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                        struct wl_array *device)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    if (device->size != sizeof(feedback->main_device))
+        return;
+
+    memcpy(&feedback->main_device, device->data, device->size);
+}
+
+static void dmabuf_feedback_format_table(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                         int32_t fd, uint32_t size)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    feedback->format_table_entries = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (feedback->format_table_entries == MAP_FAILED)
+    {
+        WARN("Failed to mmap format table entries. fd %d size %u.\n", fd, size);
+        feedback->format_table_entries = NULL;
+        close(fd);
+        return;
+    }
+
+    feedback->format_table_size = size;
+    close(fd);
+}
+
+static void dmabuf_feedback_tranche_target_device(void *data,
+                                                  struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                  struct wl_array *device)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    memcpy(&feedback->pending_tranche.device, device->data, sizeof(dev_t));
+}
+
+static void dmabuf_feedback_tranche_formats(void *data,
+                                            struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                            struct wl_array *indices)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+    struct wayland_dmabuf_feedback_format_table_entry *table_entries = feedback->format_table_entries;
+    uint16_t *index;
+
+    if (!table_entries)
+    {
+        WARN("Could not add formats/modifiers to tranche due to missing format table\n");
+        return;
+    }
+
+    wl_array_for_each(index, indices)
+    {
+        if (!dmabuf_format_array_add_format_modifier(&feedback->pending_tranche.formats,
+                                                     table_entries[*index].format,
+                                                     table_entries[*index].modifier))
+        {
+            WARN("Could not add format/modifier 0x%08x/0x%" PRIx64 "\n",
+                 table_entries[*index].format,
+                 table_entries[*index].modifier);
+        }
+    }
+}
+
+static void dmabuf_feedback_tranche_flags(void *data,
+                                          struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                          uint32_t flags)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+
+    feedback->pending_tranche.flags = flags;
+}
+
+static void dmabuf_feedback_tranche_done(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_feedback *feedback = data;
+    struct wayland_dmabuf_feedback_tranche *tranche;
+
+    if (feedback->pending_tranche.formats.size == 0 ||
+        !(tranche = wl_array_add(&feedback->tranches, sizeof(*tranche))))
+    {
+        WARN("Failed to add tranche with target device %ju\n",
+             (uintmax_t)feedback->pending_tranche.device);
+        dmabuf_format_array_release(&feedback->pending_tranche.formats);
+        dmabuf_feedback_tranche_init(&feedback->pending_tranche);
+        return;
+    }
+    dmabuf_feedback_tranche_move(tranche, &feedback->pending_tranche);
+}
+
+static void dmabuf_feedback_done(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    /* ignore event */
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener dmabuf_feedback_listener =
+{
+    .main_device = dmabuf_feedback_main_device,
+    .format_table = dmabuf_feedback_format_table,
+    .tranche_target_device = dmabuf_feedback_tranche_target_device,
+    .tranche_formats = dmabuf_feedback_tranche_formats,
+    .tranche_flags = dmabuf_feedback_tranche_flags,
+    .tranche_done = dmabuf_feedback_tranche_done,
+    .done = dmabuf_feedback_done,
+};
+
+static void dmabuf_feedback_destroy(struct wayland_dmabuf_feedback *feedback)
+{
+    struct wayland_dmabuf_feedback_tranche *tranche;
+
+    dmabuf_format_array_release(&feedback->pending_tranche.formats);
+
+    wl_array_for_each(tranche, &feedback->tranches)
+        dmabuf_format_array_release(&tranche->formats);
+    wl_array_release(&feedback->tranches);
+
+    free(feedback);
+}
+
+static struct wayland_dmabuf_feedback *dmabuf_feedback_create(void)
+{
+    struct wayland_dmabuf_feedback *feedback;
+
+    feedback = calloc(1, sizeof(*feedback));
+    if (!feedback) return NULL;
+
+    wl_array_init(&feedback->tranches);
+    dmabuf_feedback_tranche_init(&feedback->pending_tranche);
+
+    return feedback;
+}
+
+/**********************************************************************
+ *          per-surface feedback handling
+ */
+
+static void surface_dmabuf_feedback_main_device(void *data,
+                                                struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                struct wl_array *device)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_main_device(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, device);
+}
+
+static void surface_dmabuf_feedback_format_table(void *data,
+                                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                 int32_t fd, uint32_t size)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_format_table(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, fd, size);
+}
+
+static void surface_dmabuf_feedback_tranche_target_device(void *data,
+                                                          struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                          struct wl_array *device)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_tranche_target_device(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, device);
+}
+
+static void surface_dmabuf_feedback_tranche_formats(void *data,
+                                                    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                    struct wl_array *indices)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    if (!surface_feedback->pending_feedback->format_table_entries &&
+        (!(surface_feedback->pending_feedback->format_table_entries = surface_feedback->feedback->format_table_entries)))
+    {
+        WARN("Could not add formats/modifiers to tranche due to missing format table\n");
+        return;
+    }
+    dmabuf_feedback_tranche_formats(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1, indices);
+}
+
+static void surface_dmabuf_feedback_tranche_flags(void *data,
+                                                  struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                                  uint32_t flags)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    surface_feedback->pending_feedback->pending_tranche.flags = flags;
+}
+
+static void surface_dmabuf_feedback_tranche_done(void *data,
+                                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    dmabuf_feedback_tranche_done(surface_feedback->pending_feedback, zwp_linux_dmabuf_feedback_v1);
+}
+
+static void surface_dmabuf_feedback_done(void *data,
+                                         struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = data;
+
+    if (!surface_feedback->pending_feedback->format_table_entries)
+    {
+        WARN("Invalid format table: Ignoring feedback events.\n");
+        dmabuf_feedback_destroy(surface_feedback->pending_feedback);
+        goto out;
+    }
+
+    wayland_dmabuf_surface_feedback_lock(surface_feedback);
+
+    if (surface_feedback->feedback)
+        dmabuf_feedback_destroy(surface_feedback->feedback);
+
+    surface_feedback->feedback = surface_feedback->pending_feedback;
+    surface_feedback->surface_needs_update = TRUE;
+
+    wayland_dmabuf_surface_feedback_unlock(surface_feedback);
+
+out:
+    surface_feedback->pending_feedback = dmabuf_feedback_create();
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener surface_dmabuf_feedback_listener =
+{
+    .main_device = surface_dmabuf_feedback_main_device,
+    .format_table = surface_dmabuf_feedback_format_table,
+    .tranche_target_device = surface_dmabuf_feedback_tranche_target_device,
+    .tranche_formats = surface_dmabuf_feedback_tranche_formats,
+    .tranche_flags = surface_dmabuf_feedback_tranche_flags,
+    .tranche_done = surface_dmabuf_feedback_tranche_done,
+    .done = surface_dmabuf_feedback_done,
+};
+
+/***********************************************************************
+ *           wayland_dmabuf_init
+ */
+void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
+                         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1)
+{
+    dmabuf->version = wl_proxy_get_version((struct wl_proxy *)zwp_linux_dmabuf_v1);
+    dmabuf->zwp_linux_dmabuf_v1 = zwp_linux_dmabuf_v1;
+    wl_array_init(&dmabuf->formats);
+
+    /* linux-dmabuf feedback events deprecate format/modifier events from
+     * previous versions. Listen to pre-v4 events only if v4 is not supported. */
+    if (dmabuf_has_feedback_support(dmabuf))
+    {
+        if (!(dmabuf->default_feedback = dmabuf_feedback_create()))
+        {
+            WARN("Could not create default dmabuf feedback: Memory allocation failure.\n");
+            return;
+        }
+        dmabuf->zwp_linux_dmabuf_feedback_v1 =
+            zwp_linux_dmabuf_v1_get_default_feedback(dmabuf->zwp_linux_dmabuf_v1);
+        zwp_linux_dmabuf_feedback_v1_add_listener(dmabuf->zwp_linux_dmabuf_feedback_v1,
+                                                  &dmabuf_feedback_listener,
+                                                  dmabuf->default_feedback);
+    }
+    else
+        zwp_linux_dmabuf_v1_add_listener(zwp_linux_dmabuf_v1, &dmabuf_listener, dmabuf);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_deinit
+ */
+void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf)
+{
+    if (dmabuf->zwp_linux_dmabuf_feedback_v1)
+    {
+        dmabuf_feedback_destroy(dmabuf->default_feedback);
+        zwp_linux_dmabuf_feedback_v1_destroy(dmabuf->zwp_linux_dmabuf_feedback_v1);
+    }
+
+    dmabuf_format_array_release(&dmabuf->formats);
+
+    if (dmabuf->zwp_linux_dmabuf_v1)
+        zwp_linux_dmabuf_v1_destroy(dmabuf->zwp_linux_dmabuf_v1);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_feedback_get_format_info
+ */
+BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+{
+    struct wayland_dmabuf_feedback_tranche *tranche;
+    struct wayland_dmabuf_format *dmabuf_format =
+        dmabuf_feedback_get_format_from_optimal_tranche(feedback, drm_format, render_dev, &tranche);
+
+    if (!dmabuf_format) return FALSE;
+
+    format_info->scanoutable = tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT;
+    format_info->count_modifiers = dmabuf_format_get_modifiers(dmabuf_format, &format_info->modifiers);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_get_default_format_info
+ */
+BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
+                                            dev_t render_dev, struct wayland_dmabuf_format_info *format_info)
+{
+    struct wayland_dmabuf_format *dmabuf_format;
+
+    if (dmabuf_has_feedback_support(dmabuf))
+        return wayland_dmabuf_feedback_get_format_info(dmabuf->default_feedback, drm_format, render_dev, format_info);
+
+    dmabuf_format = dmabuf_format_array_find_format(&dmabuf->formats, drm_format);
+    if (!dmabuf_format) return FALSE;
+
+    format_info->scanoutable = FALSE;
+    format_info->count_modifiers = dmabuf_format_get_modifiers(dmabuf_format, &format_info->modifiers);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_has_feedback_support
+ */
+BOOL wayland_dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf)
+{
+    return dmabuf_has_feedback_support(dmabuf);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_is_format_supported
+ */
+BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev)
+{
+    if (dmabuf_has_feedback_support(dmabuf))
+        return dmabuf_feedback_get_format_from_optimal_tranche(dmabuf->default_feedback, format, render_dev, NULL) != NULL;
+
+    return dmabuf_format_array_find_format(&dmabuf->formats, format) != NULL;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_create
+ */
+struct wayland_dmabuf_surface_feedback *wayland_dmabuf_surface_feedback_create(struct wayland_dmabuf *dmabuf,
+                                                                               struct wl_surface *wl_surface)
+{
+    struct wayland_dmabuf_surface_feedback *surface_feedback = NULL;
+
+    if (!(surface_feedback = calloc(1, sizeof(*surface_feedback))) ||
+        !(surface_feedback->pending_feedback = dmabuf_feedback_create()))
+    {
+        WARN("Failed to create surface feedback: Memory allocation error.");
+        free(surface_feedback);
+        return NULL;
+    }
+
+    wayland_mutex_init(&surface_feedback->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_dmabuf_surface_feedback");
+
+    surface_feedback->zwp_linux_dmabuf_feedback_v1 =
+        zwp_linux_dmabuf_v1_get_surface_feedback(dmabuf->zwp_linux_dmabuf_v1, wl_surface);
+    zwp_linux_dmabuf_feedback_v1_add_listener(surface_feedback->zwp_linux_dmabuf_feedback_v1,
+                                              &surface_dmabuf_feedback_listener,
+                                              surface_feedback);
+
+    return surface_feedback;
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_destroy
+ */
+void wayland_dmabuf_surface_feedback_destroy(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    if (surface_feedback->feedback)
+        dmabuf_feedback_destroy(surface_feedback->feedback);
+
+    dmabuf_feedback_destroy(surface_feedback->pending_feedback);
+    zwp_linux_dmabuf_feedback_v1_destroy(surface_feedback->zwp_linux_dmabuf_feedback_v1);
+    wayland_mutex_destroy(&surface_feedback->mutex);
+    free(surface_feedback);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_lock
+ */
+void wayland_dmabuf_surface_feedback_lock(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    if (surface_feedback) wayland_mutex_lock(&surface_feedback->mutex);
+}
+
+/***********************************************************************
+ *           wayland_dmabuf_surface_feedback_unlock
+ */
+void wayland_dmabuf_surface_feedback_unlock(struct wayland_dmabuf_surface_feedback *surface_feedback)
+{
+    wayland_mutex_unlock(&surface_feedback->mutex);
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_from_native
+ *
+ * Creates a wayland dmabuf buffer from the specified native buffer.
+ */
+struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
+                                                                       struct wayland_native_buffer *native)
+{
+    struct wayland_dmabuf_buffer *dmabuf_buffer;
+    struct zwp_linux_buffer_params_v1 *params;
+    int i;
+
+    dmabuf_buffer = calloc(1, sizeof(*dmabuf_buffer));
+    if (!dmabuf_buffer)
+        goto err;
+
+    params = zwp_linux_dmabuf_v1_create_params(wayland->dmabuf.zwp_linux_dmabuf_v1);
+    for (i = 0; i < native->plane_count; i++)
+    {
+        zwp_linux_buffer_params_v1_add(params,
+                                       native->fds[i],
+                                       i,
+                                       native->offsets[i],
+                                       native->strides[i],
+                                       native->modifier >> 32,
+                                       native->modifier & 0xffffffff);
+    }
+
+    dmabuf_buffer->wl_buffer =
+        zwp_linux_buffer_params_v1_create_immed(params,
+                                                native->width,
+                                                native->height,
+                                                native->format,
+                                                0);
+
+    zwp_linux_buffer_params_v1_destroy(params);
+
+    return dmabuf_buffer;
+
+err:
+    if (dmabuf_buffer)
+        wayland_dmabuf_buffer_destroy(dmabuf_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_destroy
+ *
+ * Destroys a dmabuf buffer.
+ */
+void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer)
+{
+    TRACE("%p\n", dmabuf_buffer);
+
+    if (dmabuf_buffer->wl_buffer)
+        wl_buffer_destroy(dmabuf_buffer->wl_buffer);
+
+    free(dmabuf_buffer);
+}
+
+/**********************************************************************
+ *          wayland_dmabuf_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a dmabuf buffer and destroy the dmabuf buffer.
+ */
+struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = dmabuf_buffer->wl_buffer;
+    dmabuf_buffer->wl_buffer = NULL;
+
+    wayland_dmabuf_buffer_destroy(dmabuf_buffer);
+
+    return wl_buffer;
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
new file mode 100644
index 00000000000..0bc5de8a9b9
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -0,0 +1,1329 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013 Alexandre Julliard
+ * Copyright 2015 Josh DuBois for CodeWeavers Inc.
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include "ntuser.h"
+
+#include <linux/input.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+/* xkb_keysym_t fixed maps from wayland_keyboard_layout.h. */
+extern const WORD xkb_keysym_0xff00_to_vkey[256];
+extern const WORD xkb_keysym_0xff00_to_scan[256];
+extern const WORD xkb_keysym_xfree86_to_vkey[256];
+extern const WORD xkb_keysym_xfree86_to_scan[256];
+
+static const struct
+{
+    DWORD       vkey;
+    const char *name;
+} vkey_names[] = {
+    { VK_ADD,                   "Num +" },
+    { VK_BACK,                  "Backspace" },
+    { VK_CAPITAL,               "Caps Lock" },
+    { VK_CONTROL,               "Ctrl" },
+    { VK_DECIMAL,               "Num Del" },
+    { VK_DELETE,                "Delete" },
+    { VK_DIVIDE,                "Num /" },
+    { VK_DOWN,                  "Down" },
+    { VK_END,                   "End" },
+    { VK_ESCAPE,                "Esc" },
+    { VK_F1,                    "F1" },
+    { VK_F2,                    "F2" },
+    { VK_F3,                    "F3" },
+    { VK_F4,                    "F4" },
+    { VK_F5,                    "F5" },
+    { VK_F6,                    "F6" },
+    { VK_F7,                    "F7" },
+    { VK_F8,                    "F8" },
+    { VK_F9,                    "F9" },
+    { VK_F10,                   "F10" },
+    { VK_F11,                   "F11" },
+    { VK_F12,                   "F12" },
+    { VK_F13,                   "F13" },
+    { VK_F14,                   "F14" },
+    { VK_F15,                   "F15" },
+    { VK_F16,                   "F16" },
+    { VK_F17,                   "F17" },
+    { VK_F18,                   "F18" },
+    { VK_F19,                   "F19" },
+    { VK_F20,                   "F20" },
+    { VK_F21,                   "F21" },
+    { VK_F22,                   "F22" },
+    { VK_F23,                   "F23" },
+    { VK_F24,                   "F24" },
+    { VK_HELP,                  "Help" },
+    { VK_HOME,                  "Home" },
+    { VK_INSERT,                "Insert" },
+    { VK_LCONTROL,              "Ctrl" },
+    { VK_LEFT,                  "Left" },
+    { VK_LMENU,                 "Alt" },
+    { VK_LSHIFT,                "Shift" },
+    { VK_LWIN,                  "Win" },
+    { VK_MENU,                  "Alt" },
+    { VK_MULTIPLY,              "Num *" },
+    { VK_NEXT,                  "Page Down" },
+    { VK_NUMLOCK,               "Num Lock" },
+    { VK_NUMPAD0,               "Num 0" },
+    { VK_NUMPAD1,               "Num 1" },
+    { VK_NUMPAD2,               "Num 2" },
+    { VK_NUMPAD3,               "Num 3" },
+    { VK_NUMPAD4,               "Num 4" },
+    { VK_NUMPAD5,               "Num 5" },
+    { VK_NUMPAD6,               "Num 6" },
+    { VK_NUMPAD7,               "Num 7" },
+    { VK_NUMPAD8,               "Num 8" },
+    { VK_NUMPAD9,               "Num 9" },
+    { VK_OEM_CLEAR,             "Num Clear" },
+    { VK_OEM_NEC_EQUAL,         "Num =" },
+    { VK_PRIOR,                 "Page Up" },
+    { VK_RCONTROL,              "Right Ctrl" },
+    { VK_RETURN,                "Return" },
+    { VK_RETURN,                "Num Enter" },
+    { VK_RIGHT,                 "Right" },
+    { VK_RMENU,                 "Right Alt" },
+    { VK_RSHIFT,                "Right Shift" },
+    { VK_RWIN,                  "Right Win" },
+    { VK_SEPARATOR,             "Num ," },
+    { VK_SHIFT,                 "Shift" },
+    { VK_SPACE,                 "Space" },
+    { VK_SUBTRACT,              "Num -" },
+    { VK_TAB,                   "Tab" },
+    { VK_UP,                    "Up" },
+    { VK_VOLUME_DOWN,           "Volume Down" },
+    { VK_VOLUME_MUTE,           "Mute" },
+    { VK_VOLUME_UP,             "Volume Up" },
+    { VK_OEM_MINUS,             "-" },
+    { VK_OEM_PLUS,              "=" },
+    { VK_OEM_1,                 ";" },
+    { VK_OEM_2,                 "/" },
+    { VK_OEM_3,                 "`" },
+    { VK_OEM_4,                 "[" },
+    { VK_OEM_5,                 "\\" },
+    { VK_OEM_6,                 "]" },
+    { VK_OEM_7,                 "'" },
+    { VK_OEM_COMMA,             "," },
+    { VK_OEM_PERIOD,            "." },
+};
+
+static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
+                                      xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode) ?
+           keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
+}
+
+static xkb_keycode_t scancode_to_xkb_keycode(struct wayland_keyboard *keyboard, WORD scan)
+{
+    UINT j;
+
+    if (scan == 0) return 0;
+
+    for (j = 0; j < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode); j++)
+        if (keyboard->xkb_keycode_to_scancode[j] == scan) return j;
+
+    return 0;
+}
+
+static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                 xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey) ?
+           keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
+}
+
+static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    xkb_keycode_t i, candidate = 0;
+
+    if (vkey == 0) return 0;
+
+    switch (vkey)
+    {
+    case VK_NUMPAD0: vkey = VK_INSERT; break;
+    case VK_NUMPAD1: vkey = VK_END; break;
+    case VK_NUMPAD2: vkey = VK_DOWN; break;
+    case VK_NUMPAD3: vkey = VK_NEXT; break;
+    case VK_NUMPAD4: vkey = VK_LEFT; break;
+    case VK_NUMPAD5: vkey = VK_CLEAR; break;
+    case VK_NUMPAD6: vkey = VK_RIGHT; break;
+    case VK_NUMPAD7: vkey = VK_HOME; break;
+    case VK_NUMPAD8: vkey = VK_UP; break;
+    case VK_NUMPAD9: vkey = VK_PRIOR; break;
+    case VK_DECIMAL: vkey = VK_DELETE; break;
+
+    case VK_INSERT: case VK_END: case VK_DOWN: case VK_NEXT:
+    case VK_LEFT: case VK_RIGHT: case VK_HOME: case VK_UP:
+    case VK_PRIOR: case VK_DELETE:
+        vkey |= 0xe000;
+        break;
+    default: break;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey); i++)
+    {
+        if (keyboard->xkb_keycode_to_vkey[i] == (vkey & 0xff))
+        {
+            candidate = i;
+            if ((keyboard->xkb_keycode_to_scancode[i] & 0xff00) == (vkey & 0xff00))
+                break;
+        }
+    }
+
+    return candidate;
+}
+
+static WORD vkey_to_scancode_fixed(UINT vkey)
+{
+    int i;
+    WORD scan = 0;
+
+    if (vkey == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_vkey[i] == vkey &&
+            xkb_keysym_0xff00_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_0xff00_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_vkey[i] == vkey &&
+            xkb_keysym_xfree86_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_xfree86_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+out:
+    return scan;
+}
+
+static WORD vkey_to_scancode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WORD scan = _xkb_keycode_to_scancode(keyboard, vkey_to_xkb_keycode(keyboard, vkey));
+    if (!scan || ((scan & 0xff00) != (vkey & 0xff00))) scan = vkey_to_scancode_fixed(vkey);
+    return scan;
+}
+
+static WORD scancode_to_vkey_fixed(UINT scan)
+{
+    int i;
+
+    if (scan == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_scan[i] == scan &&
+            xkb_keysym_0xff00_to_vkey[i] != 0)
+        {
+            return xkb_keysym_0xff00_to_vkey[i];
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_scan[i] == scan &&
+            xkb_keysym_xfree86_to_vkey[i] != 0)
+        {
+            return xkb_keysym_xfree86_to_vkey[i];
+        }
+    }
+
+    return 0;
+}
+
+static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
+    if (!vkey) vkey = scancode_to_vkey_fixed(scan);
+    return vkey;
+}
+
+static const char* vkey_to_name(UINT vkey)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(vkey_names); j++)
+        if (vkey_names[j].vkey == vkey)
+            return vkey_names[j].name;
+
+    return NULL;
+}
+
+/* xkb keycodes are offset by 8 from linux input keycodes. */
+static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
+{
+    return key + 8;
+}
+
+static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
+{
+    INPUT input;
+    RAWINPUT rawinput = { 0 };
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input(hwnd, &input, &rawinput);
+}
+
+static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
+{
+    switch (xkb_keysym)
+    {
+    case XKB_KEY_dead_grave: return 0x0060;
+    case XKB_KEY_dead_acute: return 0x00B4;
+    case XKB_KEY_dead_circumflex: return 0x005E;
+    case XKB_KEY_dead_tilde: return 0x007E;
+    case XKB_KEY_dead_macron: return 0x00AF;
+    case XKB_KEY_dead_breve: return 0x02D8;
+    case XKB_KEY_dead_abovedot: return 0x02D9;
+    case XKB_KEY_dead_diaeresis: return 0x00A8;
+    case XKB_KEY_dead_abovering: return 0x02DA;
+    case XKB_KEY_dead_doubleacute: return 0x02DD;
+    case XKB_KEY_dead_caron: return 0x02C7;
+    case XKB_KEY_dead_cedilla: return 0x00B8;
+    case XKB_KEY_dead_ogonek: return 0x02DB;
+    case XKB_KEY_dead_iota: return 0x037A;
+    case XKB_KEY_dead_voiced_sound: return 0x309B;
+    case XKB_KEY_dead_semivoiced_sound: return 0x309C;
+    case XKB_KEY_dead_belowdot: return 0x002E;
+    case XKB_KEY_dead_stroke: return 0x002D;
+    case XKB_KEY_dead_abovecomma: return 0x1FBF;
+    case XKB_KEY_dead_abovereversedcomma: return 0x1FFE;
+    case XKB_KEY_dead_doublegrave: return 0x02F5;
+    case XKB_KEY_dead_belowring: return 0x02F3;
+    case XKB_KEY_dead_belowmacron: return 0x02CD;
+    case XKB_KEY_dead_belowtilde: return 0x02F7;
+    case XKB_KEY_dead_currency: return 0x00A4;
+    case XKB_KEY_dead_lowline: return 0x005F;
+    case XKB_KEY_dead_aboveverticalline: return 0x02C8;
+    case XKB_KEY_dead_belowverticalline: return 0x02CC;
+    case XKB_KEY_dead_longsolidusoverlay: return 0x002F;
+    case XKB_KEY_dead_a: return 0x0061;
+    case XKB_KEY_dead_A: return 0x0041;
+    case XKB_KEY_dead_e: return 0x0065;
+    case XKB_KEY_dead_E: return 0x0045;
+    case XKB_KEY_dead_i: return 0x0069;
+    case XKB_KEY_dead_I: return 0x0049;
+    case XKB_KEY_dead_o: return 0x006F;
+    case XKB_KEY_dead_O: return 0x004F;
+    case XKB_KEY_dead_u: return 0x0075;
+    case XKB_KEY_dead_U: return 0x0055;
+    case XKB_KEY_dead_small_schwa: return 0x0259;
+    case XKB_KEY_dead_capital_schwa: return 0x018F;
+    /* The following are non-spacing characters, couldn't find good
+     * spacing alternatives. */
+    case XKB_KEY_dead_hook: return 0x0309;
+    case XKB_KEY_dead_horn: return 0x031B;
+    case XKB_KEY_dead_belowcircumflex: return 0x032D;
+    case XKB_KEY_dead_belowbreve: return 0x032E;
+    case XKB_KEY_dead_belowdiaeresis: return 0x0324;
+    case XKB_KEY_dead_invertedbreve: return 0x0311;
+    case XKB_KEY_dead_belowcomma: return 0x0326;
+    default: return 0;
+    }
+}
+
+static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
+{
+    char utf8[64];
+    int utf8_len;
+    WCHAR wchars[8];
+    DWORD wbytes;
+
+    /* Windows doesn't emit a character for Delete. */
+    if (nsyms == 1 && syms[0] == XKB_KEY_Delete) return 0;
+
+    utf8_len = _xkb_keysyms_to_utf8(syms, nsyms, utf8, sizeof(utf8));
+
+    if (RtlUTF8ToUnicodeN(wchars, sizeof(wchars), &wbytes, utf8, utf8_len))
+        return 0;
+
+    /* TODO: normalize the keysym unicode representation. */
+
+    return wbytes >= 2 ? wchars[0] : 0;
+}
+
+static SHORT _xkb_mod_mask_to_win32(struct xkb_keymap *xkb_keymap,
+                                    xkb_mod_mask_t mod_mask)
+{
+    xkb_mod_index_t num_mods, i;
+    SHORT ret = 0;
+
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (mod_mask & (1 << i))
+        {
+            const char *mod_name = xkb_keymap_mod_get_name(xkb_keymap, i);
+
+            if (!strcmp(mod_name, XKB_MOD_NAME_SHIFT))
+                ret |= 0x0100;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_CTRL))
+                ret |= 0x0200;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_ALT))
+                ret |= 0x0400;
+        }
+    }
+
+    return ret;
+}
+
+static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
+{
+    switch (xkb_keycode - 8)
+    {
+    case KEY_KP0: case KEY_KP1: case KEY_KP2: case KEY_KP3:
+    case KEY_KP4: case KEY_KP5: case KEY_KP6: case KEY_KP7:
+    case KEY_KP8: case KEY_KP9: case KEY_KPDOT:
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
+/* Get the vkey corresponding to an xkb keycode, potentially translating it to
+ * take into account the current keyboard state. */
+static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                          xkb_keycode_t xkb_keycode)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    if (_xkb_keycode_is_keypad_num(xkb_keycode) &&
+        xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                     XKB_STATE_MODS_EFFECTIVE))
+    {
+        switch (vkey)
+        {
+        case VK_INSERT: vkey = VK_NUMPAD0; break;
+        case VK_END: vkey = VK_NUMPAD1; break;
+        case VK_DOWN: vkey = VK_NUMPAD2; break;
+        case VK_NEXT: vkey = VK_NUMPAD3; break;
+        case VK_LEFT: vkey = VK_NUMPAD4; break;
+        case VK_CLEAR: vkey = VK_NUMPAD5; break;
+        case VK_RIGHT: vkey = VK_NUMPAD6; break;
+        case VK_HOME: vkey = VK_NUMPAD7; break;
+        case VK_UP: vkey = VK_NUMPAD8; break;
+        case VK_PRIOR: vkey = VK_NUMPAD9; break;
+        case VK_DELETE: vkey = VK_DECIMAL; break;
+        default: break;
+        }
+    }
+    else if (vkey == VK_PAUSE &&
+             xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                          XKB_MOD_NAME_CTRL,
+                                          XKB_STATE_MODS_EFFECTIVE))
+    {
+        vkey = VK_CANCEL;
+    }
+
+    return vkey;
+}
+
+static UINT map_vkey_to_wchar_with_deadchar_bit(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    UINT wchar;
+    xkb_keycode_t xkb_keycode;
+    struct xkb_keymap *xkb_keymap;
+    xkb_layout_index_t layout;
+    const xkb_keysym_t *syms;
+    int nsyms;
+    int level;
+
+    if (!keyboard->xkb_state) return 0;
+
+    /* Windows seems to handle alphabetical vkeys codes specially, not taking
+     * the layout into account. */
+    if (vkey >= 'A' && vkey <= 'Z') return vkey;
+
+    layout = _xkb_state_get_active_layout(keyboard->xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("no active layout, returning wchar 0\n");
+        return 0;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(keyboard->xkb_state);
+    xkb_keycode = vkey_to_xkb_keycode(keyboard, vkey);
+
+    /* Use level 1 (i.e., numlock) for numpad keys. */
+    level = ((vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9) || vkey == VK_DECIMAL) ? 1 : 0;
+
+    nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                             layout, level, &syms);
+    if (nsyms > 0)
+    {
+        /* Set the high bit to 1 if this is dead char. */
+        if ((wchar = dead_xkb_keysym_to_wchar(syms[0])))
+            wchar |= 0x80000000;
+        else
+            wchar = _xkb_keysyms_to_wchar(syms, nsyms);
+    }
+    else
+    {
+        wchar = 0;
+    }
+
+    TRACE_(key)("vkey=0x%x xkb_keycode=%d nsyms=%d xkb_keysym[0]=0x%x => wchar=0x%x\n",
+                vkey, xkb_keycode, nsyms, nsyms ? syms[0] : 0, wchar);
+
+    return wchar;
+}
+
+static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
+                                  uint32_t state, HWND hwnd)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+    UINT scan = _xkb_keycode_to_scancode(keyboard, xkb_keycode);
+    DWORD flags;
+
+    TRACE_(key)("xkb_keycode=%u vkey=0x%x scan=0x%x state=%d hwnd=%p\n",
+                xkb_keycode, vkey, scan, state, hwnd);
+
+    if (vkey == 0) return;
+
+    flags = 0;
+    if (state == WL_KEYBOARD_KEY_STATE_RELEASED) flags |= KEYEVENTF_KEYUP;
+    if (scan & 0xff00) flags |= KEYEVENTF_EXTENDEDKEY;
+
+    send_keyboard_input(hwnd, vkey, scan & 0xff, flags);
+}
+
+static struct xkb_state *_xkb_state_new_from_wine(struct wayland_keyboard *keyboard,
+                                                  const BYTE *keystate)
+{
+    struct xkb_state *xkb_state;
+    UINT mods[] = {VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU};
+    UINT toggles[] = {VK_CAPITAL, VK_NUMLOCK, VK_SCROLL};
+    int i;
+
+    /* Create a new xkb_state using the currently active layout. */
+    xkb_state = xkb_state_new(xkb_state_get_keymap(keyboard->xkb_state));
+    if (!xkb_state) return NULL;
+    xkb_state_update_mask(xkb_state, 0, 0, 0, 0, 0,
+                          xkb_state_serialize_layout(keyboard->xkb_state,
+                                                     XKB_STATE_LAYOUT_LOCKED));
+
+    /* Update the xkb_state from the windows keyboard state by simulating
+     * keypresses. */
+    for (i = 0 ; i < ARRAY_SIZE(mods); i++)
+    {
+        if ((keystate[mods[i]] & 0x80))
+        {
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, mods[i]),
+                                 XKB_KEY_DOWN);
+        }
+    }
+
+    for (i = 0 ; i < ARRAY_SIZE(toggles); i++)
+    {
+        if ((keystate[toggles[i]] & 0x01))
+        {
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, toggles[i]),
+                                 XKB_KEY_DOWN);
+            xkb_state_update_key(xkb_state,
+                                 vkey_to_xkb_keycode(keyboard, toggles[i]),
+                                 XKB_KEY_UP);
+
+        }
+    }
+
+    return xkb_state;
+}
+
+static BOOL get_wine_async_key_state(BYTE state[256])
+{
+    BOOL ret;
+
+    SERVER_START_REQ(get_key_state)
+    {
+        req->async = 1;
+        req->key = -1;
+        wine_server_set_reply(req, state, 256);
+        ret = !wine_server_call(req);
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+static void set_wine_async_key_state(const BYTE state[256])
+{
+    SERVER_START_REQ(set_key_state)
+    {
+        req->async = 1;
+        wine_server_add_data(req, state, 256);
+        wine_server_call(req);
+    }
+    SERVER_END_REQ;
+}
+
+static void adjust_wine_lock_state(struct wayland_keyboard *keyboard,
+                                   BYTE *keystate, WORD vkey, DWORD flags)
+{
+    BYTE prev_state = keystate[vkey] & 0x01;
+    HWND hwnd = keyboard->focused_surface ? keyboard->focused_surface->hwnd : 0;
+
+    /* First try to set the lock key state by sending key events. */
+    if (hwnd)
+    {
+        WORD scan = vkey_to_scancode(keyboard, vkey);
+        send_keyboard_input(hwnd, vkey, scan, flags);
+        send_keyboard_input(hwnd, vkey, scan, flags ^ KEYEVENTF_KEYUP);
+    }
+
+    /* Keyboard hooks may have blocked processing lock keys causing our state
+     * to be different than state on the Wayland server side. Although Windows
+     * allows hooks to block changing state, we can't prevent it on Wayland
+     * server side. Having different states would cause us to try to adjust it
+     * again on the next key event. We prevent that by overriding hooks and
+     * setting key states here. */
+    if (get_wine_async_key_state(keystate) && (keystate[vkey] & 0x01) == prev_state)
+    {
+        WARN("keystate %x not changed (%#.2x), probably blocked by hooks\n",
+             vkey, keystate[vkey]);
+        keystate[vkey] ^= 0x01;
+        set_wine_async_key_state(keystate);
+    }
+}
+
+static void update_wine_lock_state(struct wayland_keyboard *keyboard)
+{
+    BYTE keystate[256];
+    BOOL capslock, numlock, scrollock;
+
+    capslock = xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_CAPS,
+                                            XKB_STATE_MODS_LOCKED);
+    numlock = xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                           XKB_STATE_MODS_LOCKED);
+    scrollock = xkb_state_led_name_is_active(keyboard->xkb_state, XKB_LED_NAME_SCROLL);
+
+    if (!get_wine_async_key_state(keystate)) return;
+
+    /* Adjust the CAPSLOCK state if it has been changed outside wine. */
+    if (!(keystate[VK_CAPITAL] & 0x01) != !capslock)
+    {
+        DWORD flags = 0;
+        if (keystate[VK_CAPITAL] & 0x80) flags ^= KEYEVENTF_KEYUP;
+        TRACE("Adjusting CapsLock state (%#.2x)\n", keystate[VK_CAPITAL]);
+        adjust_wine_lock_state(keyboard, keystate, VK_CAPITAL, flags);
+    }
+
+    /* Adjust the NUMLOCK state if it has been changed outside wine. */
+    if (!(keystate[VK_NUMLOCK] & 0x01) != !numlock)
+    {
+        DWORD flags = KEYEVENTF_EXTENDEDKEY;
+        if (keystate[VK_NUMLOCK] & 0x80) flags ^= KEYEVENTF_KEYUP;
+        TRACE("Adjusting NumLock state (%#.2x)\n", keystate[VK_NUMLOCK]);
+        adjust_wine_lock_state(keyboard, keystate, VK_NUMLOCK, flags);
+    }
+
+    /* Adjust the SCROLLLOCK state if it has been changed outside wine. */
+    if (!(keystate[VK_SCROLL] & 0x01) != !scrollock)
+    {
+        DWORD flags = 0;
+        if (keystate[VK_SCROLL] & 0x80) flags ^= KEYEVENTF_KEYUP;
+        TRACE("Adjusting ScrLock state (%#.2x)\n", keystate[VK_SCROLL]);
+        adjust_wine_lock_state(keyboard, keystate, VK_SCROLL, flags);
+    }
+}
+
+/**********************************************************************
+ *          Keyboard handling
+ */
+
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                                   uint32_t format, int fd, uint32_t size)
+{
+    struct wayland *wayland = data;
+    struct xkb_keymap *xkb_keymap = NULL;
+    struct xkb_state *xkb_state = NULL;
+    char *keymap_str;
+
+    TRACE("format=%d fd=%d size=%d\n", format, fd, size);
+
+    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 ||
+        !wayland->keyboard.xkb_context)
+        goto out;
+
+    keymap_str = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (keymap_str == MAP_FAILED)
+        goto out;
+
+    xkb_keymap = xkb_keymap_new_from_string(wayland->keyboard.xkb_context,
+                                            keymap_str,
+                                            XKB_KEYMAP_FORMAT_TEXT_V1,
+                                            0);
+    munmap(keymap_str, size);
+    if (!xkb_keymap)
+        goto out;
+
+    xkb_state = xkb_state_new(xkb_keymap);
+    xkb_keymap_unref(xkb_keymap);
+    if (!xkb_state)
+        goto out;
+
+    xkb_state_unref(wayland->keyboard.xkb_state);
+    wayland->keyboard.xkb_state = xkb_state;
+    if (wayland->keyboard.xkb_compose_state)
+        xkb_compose_state_reset(wayland->keyboard.xkb_compose_state);
+
+    wayland_keyboard_update_layout(&wayland->keyboard);
+
+out:
+    close(fd);
+}
+
+static BOOL wayland_surface_for_window_is_mapped(HWND hwnd)
+{
+    DWORD_PTR res;
+
+    if (!send_message_timeout(hwnd, WM_WAYLAND_QUERY_SURFACE_MAPPED,
+                              0, 0, SMTO_BLOCK, 50, &res))
+    {
+        return FALSE;
+    }
+
+    return res;
+}
+
+static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                                  uint32_t serial, struct wl_surface *surface,
+                                  struct wl_array *keys)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since keyboard events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        HWND foreground = NtUserGetForegroundWindow();
+        BOOL foreground_is_visible;
+        BOOL foreground_is_mapped;
+
+        if (foreground == NtUserGetDesktopWindow()) foreground = NULL;
+        if (foreground)
+        {
+            foreground_is_visible = NtUserGetWindowLongW(foreground, GWL_STYLE) & WS_VISIBLE;
+            foreground_is_mapped = wayland_surface_for_window_is_mapped(foreground);
+        }
+        else
+        {
+            foreground_is_visible = FALSE;
+            foreground_is_mapped = FALSE;
+        }
+
+        TRACE("surface=%p hwnd=%p foreground=%p visible=%d mapped=%d\n",
+              wayland_surface, wayland_surface->hwnd, foreground,
+              foreground_is_visible, foreground_is_mapped);
+
+        wayland->keyboard.focused_surface = wayland_surface;
+        wayland->keyboard.enter_serial = serial;
+
+        /* Promote the just entered window to the foreground unless we have a
+         * existing visible foreground window that is not mapped from the
+         * Wayland perspective. In that case the surface may not have had the
+         * chance to acquire the keyboard focus and if we change the foreground
+         * window now, we may cause side effects, e.g., some fullscreen games
+         * minimize if they lose focus. To avoid such side effects, err on the
+         * side of maintaining the Wine foreground state, with the expectation
+         * that the current foreground window will eventually also gain the
+         * Wayland keyboard focus. */
+        if (!foreground || !foreground_is_visible || foreground_is_mapped)
+        {
+            struct wayland_surface *toplevel = wayland_surface;
+            while (toplevel->parent) toplevel = toplevel->parent;
+
+            if (NtUserGetWindowLongW(toplevel->hwnd, GWL_STYLE) & WS_MINIMIZE)
+            {
+                /* If a minimized window is already activated from Wine's
+                 * perspective, reactivating it is a null operation, and thus
+                 * won't trigger any activation side-effects (e.g., many games
+                 * change the display mode when they are activated). In order
+                 * to get those effects properly applied, deactivate the window
+                 * now, so it can be properly reactivated after restoration. */
+                if (foreground == toplevel->hwnd)
+                    NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+                NtUserShowWindow(toplevel->hwnd, SW_RESTORE);
+                NtUserShowOwnedPopups(toplevel->hwnd, TRUE);
+            }
+
+            NtUserSetForegroundWindow(toplevel->hwnd);
+        }
+    }
+}
+
+static void CALLBACK maybe_unset_from_foreground(HWND hwnd, UINT msg,
+                                                 UINT_PTR timer_id,
+                                                 DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    TRACE("wayland=%p hwnd=%p\n", wayland, hwnd);
+
+    /* If no enter events have arrived since the previous leave event,
+     * the loss of focus was likely not transient, so drop the foreground state.
+     * We only drop the foreground state if it's ours to drop, i.e., some
+     * other window hasn't become foreground in the meantime. */
+    if (!wayland->keyboard.focused_surface && NtUserGetForegroundWindow() == hwnd)
+        NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+
+    NtUserKillTimer(hwnd, timer_id);
+}
+
+static void keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+        uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *focused_surface = wayland->keyboard.focused_surface;
+
+    if (focused_surface && focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n", focused_surface, focused_surface->hwnd);
+        NtUserKillTimer(focused_surface->hwnd, (UINT_PTR)keyboard);
+        /* This leave event may not signify a real loss of focus for the
+         * window. Such a case occurs when the focus changes from the main
+         * surface to a subsurface. Don't be too eager to lose the foreground
+         * state in such cases, as some fullscreen applications may become
+         * minimized. Instead wait a bit in case other enter events targeting a
+         * (sub)surface of the same HWND arrive soon after. */
+        NtUserSetTimer(focused_surface->hwnd,
+                       (UINT_PTR)&wayland->keyboard.focused_surface, 50,
+                       maybe_unset_from_foreground, TIMERV_DEFAULT_COALESCING);
+        wayland->keyboard.focused_surface = NULL;
+        wayland->keyboard.enter_serial = 0;
+    }
+}
+
+static void CALLBACK repeat_key(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    if (wayland->keyboard.repeat_interval_ms > 0)
+    {
+        wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.pressed_key,
+                              WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
+
+        NtUserSetTimer(hwnd, timer_id, wayland->keyboard.repeat_interval_ms,
+                       repeat_key, TIMERV_DEFAULT_COALESCING);
+    }
+}
+
+static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->keyboard.focused_surface ?
+                        wayland->keyboard.focused_surface->hwnd : 0;
+    UINT_PTR repeat_key_timer_id = (UINT_PTR)keyboard;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
+
+    wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+    wayland->last_event_type = INPUT_KEYBOARD;
+
+    wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd);
+
+    if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+    {
+        wayland->keyboard.pressed_key = key;
+        if (wayland->keyboard.repeat_interval_ms > 0)
+        {
+            NtUserSetTimer(focused_hwnd, repeat_key_timer_id, wayland->keyboard.repeat_delay_ms,
+                           repeat_key, TIMERV_DEFAULT_COALESCING);
+        }
+    }
+    else
+    {
+        wayland->keyboard.pressed_key = 0;
+        NtUserKillTimer(focused_hwnd, repeat_key_timer_id);
+    }
+}
+
+static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched, uint32_t mods_locked,
+                                      uint32_t group)
+{
+    struct wayland *wayland = data;
+    uint32_t last_group;
+
+    TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
+          mods_depressed, mods_latched, mods_locked, group);
+
+    if (!wayland->keyboard.xkb_state) return;
+
+    last_group = _xkb_state_get_active_layout(wayland->keyboard.xkb_state);
+
+    xkb_state_update_mask(wayland->keyboard.xkb_state,
+                          mods_depressed, mods_latched, mods_locked, 0, 0, group);
+
+    if (group != last_group)
+        wayland_keyboard_update_layout(&wayland->keyboard);
+
+    /* Update the wine lock key state, in case the XKB modifier state is set
+     * without previously sending the associated key events (e.g., during
+     * program startup). */
+    update_wine_lock_state(&wayland->keyboard);
+}
+
+static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
+                                        int rate, int delay)
+{
+    struct wayland *wayland = data;
+
+    TRACE("rate=%d delay=%d\n", rate, delay);
+
+    /* Handle non-negative rate values, ignore invalid (negative) values.  A
+     * rate of 0 disables repeat. Note that a requested rate value larger than
+     * 100 may not actually lead to the desired repeat rate, since we are
+     * constrained by the USER_TIMER_MINIMUM (=10ms) resolution of win32
+     * timers. */
+    if (rate > 1000)
+        wayland->keyboard.repeat_interval_ms = 1;
+    else if (rate > 0)
+        wayland->keyboard.repeat_interval_ms = 1000 / rate;
+    else if (rate == 0)
+        wayland->keyboard.repeat_interval_ms = 0;
+
+    wayland->keyboard.repeat_delay_ms = delay;
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+/***********************************************************************
+ *           wayland_keyboard_init
+ */
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard)
+{
+    struct xkb_compose_table *compose_table;
+    const char *locale;
+
+    locale = getenv("LC_ALL");
+    if (!locale || !*locale)
+        locale = getenv("LC_CTYPE");
+    if (!locale || !*locale)
+        locale = getenv("LANG");
+    if (!locale || !*locale)
+        locale = "C";
+
+    keyboard->wl_keyboard = wl_keyboard;
+    /* Some sensible default values for the repeat rate and delay. */
+    keyboard->repeat_interval_ms = 40;
+    keyboard->repeat_delay_ms = 400;
+    keyboard->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (!keyboard->xkb_context)
+    {
+        ERR("Failed to create XKB context\n");
+        return;
+    }
+    compose_table =
+        xkb_compose_table_new_from_locale(keyboard->xkb_context, locale,
+                                          XKB_COMPOSE_COMPILE_NO_FLAGS);
+    if (!compose_table)
+    {
+        ERR("Failed to create XKB compose table\n");
+        return;
+    }
+
+    keyboard->xkb_compose_state =
+        xkb_compose_state_new(compose_table, XKB_COMPOSE_STATE_NO_FLAGS);
+    xkb_compose_table_unref(compose_table);
+    if (!keyboard->xkb_compose_state)
+        ERR("Failed to create XKB compose table\n");
+
+    wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
+}
+
+/***********************************************************************
+ *           wayland_keyboard_deinit
+ */
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
+{
+    if (keyboard->wl_keyboard)
+        wl_keyboard_destroy(keyboard->wl_keyboard);
+
+    xkb_compose_state_unref(keyboard->xkb_compose_state);
+    xkb_state_unref(keyboard->xkb_state);
+    xkb_context_unref(keyboard->xkb_context);
+
+    memset(keyboard, 0, sizeof(*keyboard));
+}
+
+/***********************************************************************
+ *           WAYLAND_ToUnicodeEx
+ */
+INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                        LPWSTR buf, int nchars, UINT flags, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    char utf8[64];
+    int utf8_len = 0;
+    struct xkb_compose_state *compose_state = wayland->keyboard.xkb_compose_state;
+    enum xkb_compose_status compose_status = XKB_COMPOSE_NOTHING;
+    xkb_keycode_t xkb_keycode;
+    xkb_keysym_t xkb_keysym;
+    struct xkb_state *xkb_state;
+    INT ret;
+
+    if (!wayland->keyboard.xkb_state) return 0;
+
+    if (scan & 0x8000) return 0;  /* key up */
+
+    xkb_keycode = vkey_to_xkb_keycode(&wayland->keyboard, virt);
+    xkb_state = _xkb_state_new_from_wine(&wayland->keyboard, state);
+    if (!xkb_state) return 0;
+
+    /* Try to compose */
+    xkb_keysym = xkb_state_key_get_one_sym(xkb_state, xkb_keycode);
+    if (xkb_keysym != XKB_KEY_NoSymbol && compose_state &&
+        xkb_compose_state_feed(compose_state, xkb_keysym) == XKB_COMPOSE_FEED_ACCEPTED)
+    {
+        compose_status = xkb_compose_state_get_status(compose_state);
+    }
+
+    TRACE_(key)("vkey=0x%x scan=0x%x xkb_keycode=%d xkb_keysym=0x%x compose_status=%d\n",
+                virt, scan, xkb_keycode, xkb_keysym, compose_status);
+
+    if (compose_status == XKB_COMPOSE_NOTHING)
+    {
+        /* Windows converts some Ctrl modified key combinations to strings in a
+         * way different from Linux/xkbcommon (or doesn't convert them at all).
+         * Handle such combinations manually here. */
+        if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_CTRL,
+                                         XKB_STATE_MODS_EFFECTIVE))
+        {
+            if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_ALT,
+                                             XKB_STATE_MODS_EFFECTIVE))
+            {
+                ret = 0;
+                goto out;
+            }
+            if (((xkb_keysym >= XKB_KEY_exclam) && (xkb_keysym < XKB_KEY_at)) ||
+                (xkb_keysym == XKB_KEY_grave) || (xkb_keysym == XKB_KEY_Tab))
+            {
+                ret = 0;
+                goto out;
+            }
+            if (xkb_keysym == XKB_KEY_Return)
+            {
+                if (xkb_state_mod_name_is_active(xkb_state, XKB_MOD_NAME_SHIFT,
+                                                 XKB_STATE_MODS_EFFECTIVE))
+                {
+                    ret = 0;
+                }
+                else
+                {
+                    buf[0] = '\n';
+                    ret = 1;
+                }
+                goto out;
+            }
+            if (xkb_keysym == XKB_KEY_space)
+            {
+                buf[0] = ' ';
+                ret = 1;
+                goto out;
+            }
+        }
+
+        utf8_len = xkb_state_key_get_utf8(xkb_state, xkb_keycode, utf8, sizeof(utf8));
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSED)
+    {
+        utf8_len = xkb_compose_state_get_utf8(compose_state, utf8, sizeof(utf8));
+        TRACE_(key)("composed\n");
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSING && nchars > 0)
+    {
+        if ((buf[0] = dead_xkb_keysym_to_wchar(xkb_keysym)))
+        {
+            TRACE_(key)("returning dead char 0x%04x\n", buf[0]);
+            buf[1] = 0;
+            ret = -1;
+            goto out;
+        }
+    }
+
+    TRACE_(key)("utf8 len=%d '%s'\n", utf8_len, utf8_len ? utf8 : "");
+
+    if (RtlUTF8ToUnicodeN(buf, nchars, (DWORD *)&ret, utf8, utf8_len)) ret = 0;
+    else ret /= sizeof(WCHAR);
+
+out:
+    /* Zero terminate the returned string. */
+    if (ret >= 0 && ret < nchars) buf[ret] = 0;
+    xkb_state_unref(xkb_state);
+    return ret;
+}
+
+/***********************************************************************
+ *           GetKeyNameText
+ */
+INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+{
+    struct wayland *wayland = thread_init_wayland();
+    int scan, vkey, len;
+    const char *name;
+    char key[2];
+
+    scan = (lparam >> 16) & 0x1FF;
+    vkey = scancode_to_vkey(&wayland->keyboard, scan);
+
+    if (lparam & (1 << 25))
+    {
+        /* Caller doesn't care about distinctions between left and
+           right keys. */
+        switch (vkey)
+        {
+        case VK_LSHIFT:
+        case VK_RSHIFT:
+            vkey = VK_SHIFT; break;
+        case VK_LCONTROL:
+        case VK_RCONTROL:
+            vkey = VK_CONTROL; break;
+        case VK_LMENU:
+        case VK_RMENU:
+            vkey = VK_MENU; break;
+        }
+    }
+
+    if ((vkey >= 0x30 && vkey <= 0x39) || (vkey >= 0x41 && vkey <= 0x5a))
+    {
+        key[0] = vkey;
+        if (vkey >= 0x41)
+            key[0] += 0x20;
+        key[1] = 0;
+        name = key;
+    }
+    else
+    {
+        name = vkey_to_name(vkey);
+    }
+
+    if (!name || RtlUTF8ToUnicodeN(buffer, size, (DWORD *)&len, name, strlen(name) + 1)) len = 0;
+    else len = len / sizeof(WCHAR) - 1;
+
+    if (!len)
+    {
+        char buf[16];
+        len = snprintf(buf, sizeof(buf), "Key 0x%02x", vkey);
+        if (len > sizeof(buf)) len = sizeof(buf);
+        len = ascii_to_unicode_z(buffer, size, buf, len);
+        if (len > 0) len--;
+    }
+
+    TRACE_(key)("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
+    return len;
+}
+
+/***********************************************************************
+ *           WAYLAND_MapVirtualKeyEx
+ */
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    UINT ret = 0;
+
+    TRACE_(key)("code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl);
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+
+        if (maptype == MAPVK_VK_TO_VSC) code &= 0xff;
+        ret = vkey_to_scancode(&wayland->keyboard, code);
+        if (maptype == MAPVK_VK_TO_VSC)
+        {
+            UINT scan_prefix = (ret >> 8) & 0xff;
+            if (scan_prefix == 0xe1)
+                ret = 0;
+            else
+                ret &= 0xff;
+        }
+        break;
+    case MAPVK_VSC_TO_VK:
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey(&wayland->keyboard, code);
+        if (maptype == MAPVK_VSC_TO_VK)
+        {
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        ret = map_vkey_to_wchar_with_deadchar_bit(&wayland->keyboard, code);
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);
+    return ret;
+}
+
+/***********************************************************************
+ *           WAYLAND_VkKeyScanEx
+ */
+SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = wayland->keyboard.xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    TRACE_(key)("ch %04x hkl %p ...\n", ch, hkl);
+
+    if (!xkb_state)
+    {
+        TRACE_(key)("... no xkb state , returning -1\n");
+        return -1;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("... no active layout, returning -1\n");
+        return -1;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+
+    /* Search through all keycodes and their shift levels for one that
+     * produces a keysym that matches the requested character. */
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+
+            if (_xkb_keysyms_to_wchar(syms, nsyms) == ch)
+            {
+                UINT vkey;
+                xkb_mod_mask_t mod_mask;
+                SHORT ret;
+
+                vkey = _xkb_keycode_to_vkey(&wayland->keyboard, xkb_keycode);
+                if (vkey == 0)
+                    continue;
+
+                xkb_keymap_key_get_mods_for_level(xkb_keymap, xkb_keycode,
+                                                  layout, level, &mod_mask, 1);
+                ret = _xkb_mod_mask_to_win32(xkb_keymap, mod_mask) | vkey;
+
+                TRACE_(key)("... returning %04x\n", ret);
+                return ret;
+            }
+        }
+    }
+
+    TRACE_(key)("... matching vkey not found, returning -1\n");
+    return -1;
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
new file mode 100644
index 00000000000..6d192b23ed6
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -0,0 +1,292 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ime.h"
+#include "winuser.h"
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
+                         const xkb_keysym_t ref[MAIN_KEY_SYMBOLS_LEN])
+{
+    int score = 0, i;
+
+    for (i = 0; i < MAIN_KEY_SYMBOLS_LEN && ref[i]; i++)
+    {
+        if (ref[i] != sym[i]) return 0;
+        score++;
+    }
+
+    return score;
+}
+
+static int score_layout(int layout,
+                        const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    int score = 0;
+    int prev_key = 1000;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int key, key_score = 0;
+        const xkb_keysym_t *symbols = symbols_for_keycode[xkb_keycode];
+
+        if (*symbols == 0)
+            continue;
+
+        for (key = 0; key < MAIN_KEY_LEN; key++)
+        {
+            if (key_used[key]) continue;
+            key_score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                      (*main_key_tab[layout].symbols)[key]);
+            if (key_score)
+                break;
+        }
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols, MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' key=%d score=%d order=%d\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, key, key_score, key_score && (key > prev_key));
+        }
+
+        if (key_score)
+        {
+            /* Multiply score by 100 to allow the key order bonus to break ties,
+             * while not being a primary decision factor. */
+            score += key_score * 100;
+
+            /* xkb keycodes roughly follow a top left to bottom right direction
+             * on the keyboard as they increase, similarly to the keys in
+             * main_key_tab. Give a bonus to layouts that more closely match
+             * the expected ordering. We compare with the last key to get
+             * some reasonable (although local) measure of the order. */
+            score += (key > prev_key);
+            prev_key = key;
+            key_used[key] = 1;
+        }
+    }
+
+    return score;
+}
+
+static void _xkb_keymap_populate_symbols_for_keycode(
+    struct xkb_keymap *xkb_keymap,
+    xkb_layout_index_t layout,
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+    if (max_xkb_keycode > 255) max_xkb_keycode = 255;
+
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        if (num_levels > MAIN_KEY_SYMBOLS_LEN) num_levels = MAIN_KEY_SYMBOLS_LEN;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+            if (nsyms)
+                symbols_for_keycode[xkb_keycode][level] = syms[0];
+        }
+    }
+}
+
+static int detect_main_key_layout(struct wayland_keyboard *keyboard,
+                                  const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    int max_score = 0;
+    int max_i = 0;
+
+    for (int i = 0; i < ARRAY_SIZE(main_key_tab); i++)
+    {
+        int score = score_layout(i, symbols_for_keycode);
+        if (score > max_score)
+        {
+            max_i = i;
+            max_score = score;
+        }
+        TRACE("evaluated layout '%s' score %d\n", main_key_tab[i].name, score);
+    }
+
+    if (max_score == 0)
+    {
+        max_i = 0;
+        while (strcmp(main_key_tab[max_i].name, "us")) max_i++;
+        TRACE("failed to detect layout, falling back to layout 'us'\n");
+    }
+    else
+    {
+        TRACE("detected layout '%s' (score %d)\n", main_key_tab[max_i].name, max_score);
+    }
+
+    return max_i;
+}
+
+/* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
+ * the specified main_key layout (see wayland_keyboard_layout.h) and the
+ * xkb_keycode to xkb_keysym_t mappings which have been created from the
+ * currently active Wayland keymap. */
+static void populate_xkb_keycode_maps(struct wayland_keyboard *keyboard, int main_key_layout,
+                                      const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+    const xkb_keysym_t (*lsymbols)[MAIN_KEY_SYMBOLS_LEN] =
+        (*main_key_tab[main_key_layout].symbols);
+    const WORD *lvkey = (*main_key_tab[main_key_layout].vkey);
+    const WORD *lscan = (*main_key_tab[main_key_layout].scan);
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int max_key = -1;
+        int max_score = 0;
+        xkb_keysym_t xkb_keysym = symbols_for_keycode[xkb_keycode][0];
+        UINT vkey = 0;
+        WORD scan = 0;
+
+        if ((xkb_keysym >> 8) == 0xFF)
+        {
+            vkey = xkb_keysym_0xff00_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_0xff00_to_scan[xkb_keysym & 0xff];
+        }
+        else if ((xkb_keysym >> 8) == 0x1008FF)
+        {
+            vkey = xkb_keysym_xfree86_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_xfree86_to_scan[xkb_keysym & 0xff];
+        }
+        else if (xkb_keysym == 0x20)
+        {
+            vkey = VK_SPACE;
+            scan = 0x39;
+        }
+        else
+        {
+            int key;
+
+            for (key = 0; key < MAIN_KEY_LEN; key++)
+            {
+                int score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                          lsymbols[key]);
+                /* Consider this key if it has a better score, or the same
+                 * score as a previous match that is already in use (in order
+                 * to prefer unused keys). */
+                if (score > max_score ||
+                    (max_key >= 0 && score == max_score && key_used[max_key]))
+                {
+                    max_key = key;
+                    max_score = score;
+                }
+            }
+
+            if (max_key >= 0)
+            {
+                vkey = lvkey[max_key];
+                scan = lscan[max_key];
+                key_used[max_key] = 1;
+            }
+        }
+
+        keyboard->xkb_keycode_to_vkey[xkb_keycode] = vkey;
+        keyboard->xkb_keycode_to_scancode[xkb_keycode] = scan;
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols_for_keycode[xkb_keycode],
+                                 MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("Mapped xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' => "
+                        "vkey=0x%x scan=0x%x\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, vkey, scan);
+        }
+    }
+}
+
+/***********************************************************************
+ *           wayland_keyboard_update_layout
+ *
+ * Updates the internal weston_keyboard layout information (xkb keycode
+ * mappings etc) based on the current XKB layout.
+ */
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
+{
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = keyboard->xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+    int main_key_layout;
+
+    if (!xkb_state)
+    {
+        TRACE("no xkb state, returning\n");
+        return;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE("no active layout, returning\n");
+        return;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+
+    _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
+
+    main_key_layout = detect_main_key_layout(keyboard, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, main_key_layout, symbols_for_keycode);
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
new file mode 100644
index 00000000000..f6ee87dc040
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -0,0 +1,966 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * This header file contains the tables used by keyboard_layout.c
+ * to perform layout mapping.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kåven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+#define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+
+#define MAIN_KEY_LEN 50
+/* We currently use two symbols (levels) per key to differentiate layouts. */
+#define MAIN_KEY_SYMBOLS_LEN 2
+
+/* Windows uses PS/2 scan code set 1 for the scan codes sent to applications. */
+static const WORD main_key_scan_ps2_set1[MAIN_KEY_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x7D,
+    /* Row D: AD01-AD12 */
+    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,
+    /* Row C: AC01-AC12 */
+    0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2B,
+    /* Row B: LSGT, AB01-AB11 */
+    0x56,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x73
+};
+
+static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_jp106[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    0,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_7,VK_OEM_5,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_3,VK_OEM_4,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_PLUS,VK_OEM_1,VK_OEM_6,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_v2[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_5,'1','2','3','4','5','6','7','8','9','0',VK_OEM_PLUS,VK_OEM_4,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_3,VK_OEM_7,VK_OEM_2,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_MINUS,
+};
+
+static const WORD main_key_vkey_qwertz[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Z','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Y','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_abnt_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_8,VK_OEM_5,
+    VK_OEM_7,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_102,
+};
+
+static const WORD main_key_vkey_colemak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','F','P','G','J','L','U','Y',VK_OEM_1,VK_OEM_4,VK_OEM_6,
+    'A','R','S','T','D','H','N','E','I','O',VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','K','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_azerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_7,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_PLUS,0,
+    'A','Z','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'Q','S','D','F','G','H','J','K','L','M',VK_OEM_3,VK_OEM_5,
+    VK_OEM_102,'W','X','C','V','B','N',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_8,
+};
+
+static const WORD main_key_vkey_dvorak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_6,0,
+    VK_OEM_7,VK_OEM_COMMA,VK_OEM_PERIOD,'P','Y','F','G','C','R','L',VK_OEM_2,VK_OEM_PLUS,
+    'A','O','E','U','I','D','H','T','N','S',VK_OEM_MINUS,VK_OEM_5,
+    VK_OEM_102,VK_OEM_1,'Q','J','K','X','B','M','W','V','Z',
+};
+
+#define K(x) XKB_KEY_##x
+
+static const xkb_keysym_t main_key_symbols_be[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+   {K(twosuperior), K(threesuperior)}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {K(section), '6'}, {K(egrave), '7'}, {'!', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+   {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', '*'},
+    /* Row C: AC01-AC12 */
+   {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {K(mu), K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+   {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'=', '+'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_bds[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'(', ')'}, {'1', '!'}, {'2', '?'}, {'3', '+'}, {'4', '"'}, {'5', '%'}, {'6', '='}, {'7', ':'}, {'8', '/'}, {'9', K(endash)}, {'0', K(numerosign)}, {'-', '$'}, {'.', K(EuroSign)}, {},
+    /* Row D: AD01-AD12 */
+    {',', K(Cyrillic_yeru)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {';', K(section)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(doublelowquotemark), K(leftdoublequotemark)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_e), K(Cyrillic_E)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_che), K(Cyrillic_CHE)}, {'1', '!'}, {'2', '@'}, {'3', K(numerosign)}, {'4', '$'}, {'5', '%'}, {'6', K(EuroSign)}, {'7', K(section)}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', K(endash)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_yu), K(Cyrillic_YU)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', K(doublelowquotemark)}, {'.', K(leftdoublequotemark)}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_br_abnt2[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', '"'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_diaeresis)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_acute), K(dead_grave)}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(dead_tilde), K(dead_circumflex)}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+   {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {';', ':'}, {'/', '?'},
+};
+
+static const xkb_keysym_t main_key_symbols_by[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Byelorussian_shortu), K(Byelorussian_SHORTU)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {'\'', '\''},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ca[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'#', '|'}, {'1', '!'}, {'2', '"'}, {'3', '/'}, {'4', '$'}, {'5', '%'}, {'6', '?'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_circumflex)}, {K(dead_cedilla), K(dead_diaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_grave), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '\''}, {'.', '.'}, {K(eacute), K(Eacute)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(egrave)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(eacute)}, {K(adiaeresis), K(agrave)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(udiaeresis)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(odiaeresis)}, {K(agrave), K(adiaeresis)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz_qwerty[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_circumflex), K(degree)}, {'1', '!'}, {'2', '"'}, {'3', K(section)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(ssharp), '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'#', '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_dk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(onehalf), K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(oslash), K(Oslash)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ee[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_caron), K(dead_tilde)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {K(otilde), K(Otilde)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_es[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(masculine), K(ordfeminine)}, {'1', '!'}, {'2', '"'}, {'3', K(periodcentered)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(exclamdown), K(questiondown)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_grave), K(dead_circumflex)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ntilde), K(Ntilde)}, {K(dead_acute), K(dead_diaeresis)}, {K(ccedilla), K(Ccedilla)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fi[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(twosuperior), '~'}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {'-', '6'}, {K(egrave), '7'}, {'_', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', K(sterling)},
+    /* Row C: AC01-AC12 */
+    {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {'*', K(mu)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'!', K(section)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gb[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', K(notsign)}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '@'}, {'#', '~'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {K(Greek_finalsmallsigma), K(Greek_SIGMA)}, {K(Greek_epsilon), K(Greek_EPSILON)}, {K(Greek_rho), K(Greek_RHO)}, {K(Greek_tau), K(Greek_TAU)}, {K(Greek_upsilon), K(Greek_UPSILON)}, {K(Greek_theta), K(Greek_THETA)}, {K(Greek_iota), K(Greek_IOTA)}, {K(Greek_omicron), K(Greek_OMICRON)}, {K(Greek_pi), K(Greek_PI)}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {K(Greek_alpha), K(Greek_ALPHA)}, {K(Greek_sigma), K(Greek_SIGMA)}, {K(Greek_delta), K(Greek_DELTA)}, {K(Greek_phi), K(Greek_PHI)}, {K(Greek_gamma), K(Greek_GAMMA)}, {K(Greek_eta), K(Greek_ETA)}, {K(Greek_xi), K(Greek_XI)}, {K(Greek_kappa), K(Greek_KAPPA)}, {K(Greek_lamda), K(Greek_LAMDA)}, {K(dead_acute), K(dead_diaeresis)}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {K(Greek_zeta), K(Greek_ZETA)}, {K(Greek_chi), K(Greek_CHI)}, {K(Greek_psi), K(Greek_PSI)}, {K(Greek_omega), K(Greek_OMEGA)}, {K(Greek_beta), K(Greek_BETA)}, {K(Greek_nu), K(Greek_NU)}, {K(Greek_mu), K(Greek_MU)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hu[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'0', K(section)}, {'1', '\''}, {'2', '"'}, {'3', '+'}, {'4', '!'}, {'5', '%'}, {'6', '/'}, {'7', '='}, {'8', '('}, {'9', ')'}, {K(odiaeresis), K(Odiaeresis)}, {K(udiaeresis), K(Udiaeresis)}, {K(oacute), K(Oacute)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(odoubleacute), K(Odoubleacute)}, {K(uacute), K(Uacute)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(Eacute)}, {K(aacute), K(Aacute)}, {K(udoubleacute), K(Udoubleacute)},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(iacute), K(Iacute)}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', ')'}, {'0', '('}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'/', 'Q'}, {'\'', 'W'}, {K(hebrew_qoph), 'E'}, {K(hebrew_resh), 'R'}, {K(hebrew_aleph), 'T'}, {K(hebrew_tet), 'Y'}, {K(hebrew_waw), 'U'}, {K(hebrew_finalnun), 'I'}, {K(hebrew_finalmem), 'O'}, {K(hebrew_pe), 'P'}, {']', '}'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_shin), 'A'}, {K(hebrew_dalet), 'S'}, {K(hebrew_gimel), 'D'}, {K(hebrew_kaph), 'F'}, {K(hebrew_ayin), 'G'}, {K(hebrew_yod), 'H'}, {K(hebrew_chet), 'J'}, {K(hebrew_lamed), 'K'}, {K(hebrew_finalkaph), 'L'}, {K(hebrew_finalpe), ':'}, {',', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), 'Z'}, {K(hebrew_samech), 'X'}, {K(hebrew_bet), 'C'}, {K(hebrew_he), 'V'}, {K(hebrew_nun), 'B'}, {K(hebrew_mem), 'N'}, {K(hebrew_zade), 'M'}, {K(hebrew_taw), '>'}, {K(hebrew_finalzade), '<'}, {'.', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(hebrew_qoph), K(hebrew_qoph)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_resh), K(hebrew_resh)}, {K(hebrew_taw), K(hebrew_tet)}, {K(hebrew_ayin), K(hebrew_ayin)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_samech), K(hebrew_samech)}, {K(hebrew_pe), K(hebrew_finalpe)}, {}, {},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_shin), K(hebrew_shin)}, {K(hebrew_dalet), K(hebrew_dalet)}, {K(hebrew_pe), K(hebrew_finalpe)}, {K(hebrew_gimel), K(hebrew_gimel)}, {K(hebrew_he), K(hebrew_he)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_kaph), K(hebrew_finalkaph)}, {K(hebrew_lamed), K(hebrew_lamed)}, {}, {}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), K(hebrew_zain)}, {K(hebrew_chet), K(hebrew_chet)}, {K(hebrew_zade), K(hebrew_finalzade)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_bet), K(hebrew_bet)}, {K(hebrew_nun), K(hebrew_finalnun)}, {K(hebrew_mem), K(hebrew_finalmem)}, {}, {}, {}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_is[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_abovering), K(dead_diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(odiaeresis), K(Odiaeresis)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(eth), K(ETH)}, {'\'', '?'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(dead_acute), K(dead_acute)}, {'+', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {K(thorn), K(THORN)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_it[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(igrave), '^'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(eacute)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ograve), K(ccedilla)}, {K(agrave), K(degree)}, {K(ugrave), K(section)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_106[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '~'}, {'-', '='}, {'^', '~'}, {'\\', '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_kana86[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', K(kana_WO)}, {'-', '='}, {'^', '~'}, {K(yen), '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_mac[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {K(kana_NU)}, {K(kana_FU)}, {K(kana_A), K(kana_a)}, {K(kana_U), K(kana_u)}, {K(kana_E), K(kana_e)}, {K(kana_O), K(kana_o)}, {K(kana_YA), K(kana_ya)}, {K(kana_YU), K(kana_yu)}, {K(kana_YO), K(kana_yo)}, {K(kana_WA), K(kana_WO)}, {K(kana_HO)}, {K(kana_HE)}, {K(prolongedsound)},
+    /* Row D: AD01-AD12 */
+    {K(kana_TA)}, {K(kana_TE)}, {K(kana_I), K(kana_i)}, {K(kana_SU)}, {K(kana_KA)}, {K(kana_N)}, {K(kana_NA)}, {K(kana_NI)}, {K(kana_RA)}, {K(kana_SE)}, {K(voicedsound)}, {K(semivoicedsound), K(kana_openingbracket)},
+    /* Row C: AC01-AC12 */
+    {K(kana_CHI)}, {K(kana_TO)}, {K(kana_SHI)}, {K(kana_HA)}, {K(kana_KI)}, {K(kana_KU)}, {K(kana_MA)}, {K(kana_NO)}, {K(kana_RI)}, {K(kana_RE)}, {K(kana_KE)}, {K(kana_MU), K(kana_closingbracket)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(kana_TSU), K(kana_tsu)}, {K(kana_SA)}, {K(kana_SO)}, {K(kana_HI)}, {K(kana_KO)}, {K(kana_MI)}, {K(kana_MO)}, {K(kana_NE), K(kana_comma)}, {K(kana_RU), K(kana_fullstop)}, {K(kana_ME), K(kana_conjunctive)}, {K(kana_RO)},
+};
+
+static const xkb_keysym_t main_key_symbols_lt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {K(aogonek), K(Aogonek)}, {K(ccaron), K(Ccaron)}, {K(eogonek), K(Eogonek)}, {K(eabovedot), K(Eabovedot)}, {K(iogonek), K(Iogonek)}, {K(scaron), K(Scaron)}, {K(uogonek), K(Uogonek)}, {K(umacron), K(Umacron)}, {K(doublelowquotemark), '('}, {K(leftdoublequotemark), ')'}, {'-', '_'}, {K(zcaron), K(Zcaron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(endash), K(EuroSign)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_nl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'@', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '_'}, {'8', '('}, {'9', ')'}, {'0', '\''}, {'/', '?'}, {K(degree), K(dead_tilde)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_diaeresis), K(dead_circumflex)}, {'*', '|'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'+', K(plusminus)}, {K(dead_acute), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {']', '['}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '='}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_no[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'|', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {'\\', K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(oslash), K(Oslash)}, {K(ae), K(AE)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl_dvp[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'$', '~'}, {'&', '%'}, {'[', '7'}, {'{', '5'}, {'}', '3'}, {'(', '1'}, {'=', '9'}, {'*', '0'}, {')', '2'}, {'+', '4'}, {']', '6'}, {'!', '8'}, {'#', '`'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'@', '^'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'\'', '"'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(guillemotleft), K(guillemotright)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'+', '*'}, {K(dead_acute), K(dead_grave)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(masculine), K(ordfeminine)}, {K(dead_tilde), K(dead_circumflex)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_yu), K(Cyrillic_YU)}, {'1', '!'}, {'2', '@'}, {'3', K(Cyrillic_io)}, {'4', K(Cyrillic_IO)}, {'5', K(Cyrillic_hardsign)}, {'6', K(Cyrillic_HARDSIGN)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_e), K(Cyrillic_E)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'|', K(brokenbar)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_rs[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] = {
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_lje), K(Cyrillic_LJE)}, {K(Cyrillic_nje), K(Cyrillic_NJE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Serbian_dje), K(Serbian_DJE)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_je), K(Cyrillic_JE)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Serbian_tshe), K(Serbian_TSHE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_dzhe), K(Cyrillic_DZHE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_se[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_si[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(cedilla), K(diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_sk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(lcaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(tcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {K(adiaeresis), '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ocircumflex), '"'}, {K(section), '!'}, {K(ncaron), ')'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_th[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'_', '%'}, {K(Thai_lakkhangyao), '+'}, {'/', K(Thai_leknung)}, {'-', K(Thai_leksong)}, {K(Thai_phosamphao), K(Thai_leksam)}, {K(Thai_thothung), K(Thai_leksi)}, {K(Thai_sarau), K(Thai_sarauu)}, {K(Thai_saraue), K(Thai_baht)}, {K(Thai_khokhwai), K(Thai_lekha)}, {K(Thai_totao), K(Thai_lekhok)}, {K(Thai_chochan), K(Thai_lekchet)}, {K(Thai_khokhai), K(Thai_lekpaet)}, {K(Thai_chochang), K(Thai_lekkao)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Thai_maiyamok), K(Thai_leksun)}, {K(Thai_saraaimaimalai), '"'}, {K(Thai_saraam), K(Thai_dochada)}, {K(Thai_phophan), K(Thai_thonangmontho)}, {K(Thai_saraa), K(Thai_thothong)}, {K(Thai_maihanakat), K(Thai_nikhahit)}, {K(Thai_saraii), K(Thai_maitri)}, {K(Thai_rorua), K(Thai_nonen)}, {K(Thai_nonu), K(Thai_paiyannoi)}, {K(Thai_yoyak), K(Thai_yoying)}, {K(Thai_bobaimai), K(Thai_thothan)}, {K(Thai_loling), ','},
+    /* Row C: AC01-AC12 */
+    {K(Thai_fofan), K(Thai_ru)}, {K(Thai_hohip), K(Thai_khorakhang)}, {K(Thai_kokai), K(Thai_topatak)}, {K(Thai_dodek), K(Thai_sarao)}, {K(Thai_sarae), K(Thai_chochoe)}, {K(Thai_maitho), K(Thai_maitaikhu)}, {K(Thai_maiek), K(Thai_maichattawa)}, {K(Thai_saraaa), K(Thai_sorusi)}, {K(Thai_sosua), K(Thai_sosala)}, {K(Thai_wowaen), K(Thai_soso)}, {K(Thai_ngongu), '.'}, {K(Thai_khokhuat), K(Thai_khokhon)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Thai_phophung), '('}, {K(Thai_popla), ')'}, {K(Thai_saraae), K(Thai_choching)}, {K(Thai_oang), K(Thai_honokhuk)}, {K(Thai_sarai), K(Thai_phinthu)}, {K(Thai_sarauee), K(Thai_thanthakhat)}, {K(Thai_thothahan), '?'}, {K(Thai_moma), K(Thai_thophuthao)}, {K(Thai_saraaimaimuan), K(Thai_lochula)}, {K(Thai_fofa), K(Thai_lu)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'"', K(eacute)}, {'1', '!'}, {'2', '\''}, {'3', '^'}, {'4', '+'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'*', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {K(idotless), 'I'}, {'o', 'O'}, {'p', 'P'}, {K(gbreve), K(Gbreve)}, {K(udiaeresis), K(Udiaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(scedilla), K(Scedilla)}, {'i', K(Iabovedot)}, {',', ';'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {K(odiaeresis), K(Odiaeresis)}, {K(ccedilla), K(Ccedilla)}, {'.', ':'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr_f[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'+', '*'}, {'1', '!'}, {'2', '"'}, {'3', '^'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '='}, {'/', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'f', 'F'}, {'g', 'G'}, {K(gbreve), K(Gbreve)}, {K(idotless), 'I'}, {'o', 'O'}, {'d', 'D'}, {'r', 'R'}, {'n', 'N'}, {'h', 'H'}, {'p', 'P'}, {'q', 'Q'}, {'w', 'W'},
+    /* Row C: AC01-AC12 */
+    {'u', 'U'}, {'i', K(Iabovedot)}, {'e', 'E'}, {'a', 'A'}, {K(udiaeresis), K(Udiaeresis)}, {'t', 'T'}, {'k', 'K'}, {'m', 'M'}, {'l', 'L'}, {'y', 'Y'}, {K(scedilla), K(Scedilla)}, {'x', 'X'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'j', 'J'}, {K(odiaeresis), K(Odiaeresis)}, {'v', 'V'}, {'c', 'C'}, {K(ccedilla), K(Ccedilla)}, {'z', 'Z'}, {'s', 'S'}, {'b', 'B'}, {'.', ':'}, {',', ';'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ua[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', 0x10002bc}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Ukrainian_yi), K(Ukrainian_YI)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Ukrainian_ie), K(Ukrainian_IE)}, {K(Ukrainian_ghe_with_upturn), K(Ukrainian_GHE_WITH_UPTURN)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+
+static const xkb_keysym_t main_key_symbols_us_colemak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'f', 'F'}, {'p', 'P'}, {'g', 'G'}, {'j', 'J'}, {'l', 'L'}, {'u', 'U'}, {'y', 'Y'}, {';', ':'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'d', 'D'}, {'h', 'H'}, {'n', 'N'}, {'e', 'E'}, {'i', 'I'}, {'o', 'O'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'-', '_'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'k', 'K'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_dvorak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'[', '{'}, {']', '}'}, {},
+    /* Row D: AD01-AD12 */
+    {'\'', '"'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'=', '+'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {';', ':'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_intl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_grave), K(dead_tilde)}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_circumflex)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_acute), K(dead_diaeresis)}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+#undef K
+
+/*** The VNC keyboard layout is a special case */
+
+static const WORD main_key_scan_vnc[MAIN_KEY_LEN] =
+{
+    0x02,0x03,0x04,0x05,0x06,0x07,
+    0x08,0x09,0x0A,0x0B,0x0C,0x0D,
+    0x1A,0x1B,0x27,0x28,0x29,0x33,
+    0x34,0x35,0x2B,0x1E,0x30,0x2E,
+    0x20,0x12,0x21,0x22,0x23,0x17,
+    0x24,0x25,0x26,0x32,0x31,0x18,
+    0x19,0x10,0x13,0x1F,0x14,0x16,
+    0x2F,0x11,0x2D,0x15,0x2C,0x56
+};
+
+static const WORD main_key_vkey_vnc[MAIN_KEY_LEN] =
+{
+    '1','2','3','4','5','6',
+    '7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,
+    VK_OEM_4,VK_OEM_6,VK_OEM_1,VK_OEM_7,VK_OEM_3,VK_OEM_COMMA,
+    VK_OEM_PERIOD,VK_OEM_2,VK_OEM_5, 'A','B','C',
+    'D','E','F','G','H','I',
+    'J','K','L','M','N','O',
+    'P','Q','R','S','T','U',
+    'V','W','X','Y','Z', VK_OEM_102
+};
+
+static const xkb_keysym_t main_key_symbols_vnc[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'},
+    {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'},
+    {'[', '{'}, {']', '}'}, {';', ':'}, {'\'', '"'}, {'`', '~'}, {',', '<'},
+    {'.', '>'}, {'/', '?'}, {'\\', '|'}, {'a', 'A'}, {'b', 'B'}, {'c', 'C'},
+    {'d', 'D'}, {'e', 'E'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'i', 'I'},
+    {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {'n', 'N'}, {'o', 'O'},
+    {'p', 'P'}, {'q', 'Q'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'u', 'U'},
+    {'v', 'V'}, {'w', 'W'}, {'x', 'X'}, {'y', 'Y'}, {'z', 'Z'}
+};
+
+/*** Layout table. Add your keyboard mappings to this list */
+static struct {
+    LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
+                 in the appropriate dlls/kernel/nls/.nls file */
+    const char *name;
+    const xkb_keysym_t (*symbols)[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN];
+    const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
+    const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
+} main_key_tab[]={
+    {0x0402, "bg_bds", &main_key_symbols_bg_bds, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0402, "bg_phonetic", &main_key_symbols_bg_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz", &main_key_symbols_cz, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz_qwerty", &main_key_symbols_cz_qwerty, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0406, "dk", &main_key_symbols_dk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0407, "de", &main_key_symbols_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0408, "gr", &main_key_symbols_gr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us_colemak", &main_key_symbols_us_colemak, &main_key_scan_ps2_set1, &main_key_vkey_colemak},
+    {0x0409, "us_dvorak", &main_key_symbols_us_dvorak, &main_key_scan_ps2_set1, &main_key_vkey_dvorak},
+    {0x0409, "us_intl", &main_key_symbols_us_intl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "vnc", &main_key_symbols_vnc, &main_key_scan_vnc, &main_key_vkey_vnc},
+    {0x040a, "es", &main_key_symbols_es, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040b, "fi", &main_key_symbols_fi, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040c, "fr", &main_key_symbols_fr, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x040d, "il", &main_key_symbols_il, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040d, "il_phonetic", &main_key_symbols_il_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040e, "hu", &main_key_symbols_hu, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x040f, "is", &main_key_symbols_is, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0410, "it", &main_key_symbols_it, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_106", &main_key_symbols_jp_106, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0411, "jp_kana86", &main_key_symbols_jp_kana86, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_mac", &main_key_symbols_jp_mac, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0413, "nl", &main_key_symbols_nl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0414, "no", &main_key_symbols_no, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0415, "pl_dvp", &main_key_symbols_pl_dvp, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0416, "br_abnt2", &main_key_symbols_br_abnt2, &main_key_scan_ps2_set1, &main_key_vkey_abnt_qwerty},
+    {0x0419, "ru", &main_key_symbols_ru, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0419, "ru_phonetic", &main_key_symbols_ru_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041a, "hr", &main_key_symbols_hr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x041b, "sk", &main_key_symbols_sk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041d, "se", &main_key_symbols_se, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_v2},
+    {0x041e, "th", &main_key_symbols_th, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr_f", &main_key_symbols_tr_f, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr", &main_key_symbols_tr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0422, "ua", &main_key_symbols_ua, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0423, "by", &main_key_symbols_by, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0424, "si", &main_key_symbols_si, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0425, "ee", &main_key_symbols_ee, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0427, "lt", &main_key_symbols_lt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0807, "ch_de", &main_key_symbols_ch_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0809, "gb", &main_key_symbols_gb, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x080c, "be", &main_key_symbols_be, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x0816, "pt", &main_key_symbols_pt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c0c, "ca", &main_key_symbols_ca, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c1a, "rs", &main_key_symbols_rs, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x100c, "ch_fr", &main_key_symbols_ch_fr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+};
+
+const WORD xkb_keysym_0xff00_to_vkey[256] DECLSPEC_HIDDEN =
+{
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF00 */
+    /* special keys */
+    VK_BACK, VK_TAB, 0, VK_CLEAR, 0, VK_RETURN, 0, 0,           /* FF08 */
+    0, 0, 0, VK_PAUSE, VK_SCROLL, VK_SNAPSHOT, 0, 0,            /* FF10 */
+    0, 0, 0, VK_ESCAPE, 0, 0, 0, 0,                             /* FF18 */
+    /* Japanese special keys */
+    0, VK_KANJI, VK_NONCONVERT, VK_CONVERT,                     /* FF20 */
+    VK_DBE_ROMAN, 0, 0, VK_DBE_HIRAGANA,
+    0, 0, VK_DBE_SBCSCHAR, 0, 0, 0, 0, 0,                       /* FF28 */
+    /* Korean special keys (FF31-) */
+    VK_DBE_ALPHANUMERIC, VK_HANGUL, 0, 0, VK_HANJA, 0, 0, 0,    /* FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF38 */
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF48 */
+    /* cursor keys */
+    VK_HOME, VK_LEFT, VK_UP, VK_RIGHT,                          /* FF50 */
+    VK_DOWN, VK_PRIOR, VK_NEXT, VK_END,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF58 */
+    /* misc keys */
+    VK_SELECT, VK_SNAPSHOT, VK_EXECUTE, VK_INSERT, 0,0,0, VK_APPS, /* FF60 */
+    0, VK_CANCEL, VK_HELP, VK_CANCEL, 0, 0, 0, 0,               /* FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF70 */
+    /* keypad keys */
+    0, 0, 0, 0, 0, 0, 0, VK_NUMLOCK,                            /* FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF80 */
+    0, 0, 0, 0, 0, VK_RETURN, 0, 0,                             /* FF88 */
+    0, 0, 0, 0, 0, VK_HOME, VK_LEFT, VK_UP,                     /* FF90 */
+    VK_RIGHT, VK_DOWN, VK_PRIOR, VK_NEXT,                       /* FF98 */
+    VK_END, VK_CLEAR, VK_INSERT, VK_DELETE,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFA0 */
+    0, 0, VK_MULTIPLY, VK_ADD,                                  /* FFA8 */
+    /* Windows always generates VK_DECIMAL for Del/. on keypad while some
+     * X11 keyboard layouts generate XK_KP_Separator instead of XK_KP_Decimal
+     * in order to produce a locale dependent numeric separator.
+     */
+    VK_DECIMAL, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
+    VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3,             /* FFB0 */
+    VK_NUMPAD4, VK_NUMPAD5, VK_NUMPAD6, VK_NUMPAD7,
+    VK_NUMPAD8, VK_NUMPAD9, 0, 0, 0, VK_OEM_NEC_EQUAL,          /* FFB8 */
+    /* function keys */
+    VK_F1, VK_F2,
+    VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10,    /* FFC0 */
+    VK_F11, VK_F12, VK_F13, VK_F14, VK_F15, VK_F16, VK_F17, VK_F18, /* FFC8 */
+    VK_F19, VK_F20, VK_F21, VK_F22, VK_F23, VK_F24, 0, 0,       /* FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFD8 */
+    /* modifier keys */
+    0, VK_LSHIFT, VK_RSHIFT, VK_LCONTROL,                       /* FFE0 */
+    VK_RCONTROL, VK_CAPITAL, 0, VK_LMENU,
+    VK_RMENU, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN, 0, 0, 0,    /* FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFF0 */
+    0, 0, 0, 0, 0, 0, 0, VK_DELETE                              /* FFF8 */
+};
+
+const WORD xkb_keysym_0xff00_to_scan[256] DECLSPEC_HIDDEN =
+{
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF00 */
+    /* special keys */
+    0x0E, 0x0F, 0x00, /*?*/ 0, 0x00, 0x1C, 0x00, 0x00,           /* FF08 */
+    0x00, 0x00, 0x00, 0xE11D, 0x46, 0x54, 0x00, 0x00,            /* FF10 */
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,              /* FF18 */
+    /* Japanese special keys */
+    0x00, 0x29, 0x7B, 0x79, 0x70, 0x00, 0x00, 0x70,              /* FF20 */
+    0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF28 */
+    /* Korean special keys (FF31-) */
+    0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF30 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF38 */
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF40 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF48 */
+    /* cursor keys */
+    0xE047, 0xE04B, 0xE048, 0xE04D, 0xE050, 0xE049, 0xE051, 0xE04F, /* FF50 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF58 */
+    /* misc keys */
+    /*?*/ 0, 0xE037, /*?*/ 0, 0xE052, 0x00, 0x00, 0x00, 0xE05D,  /* FF60 */
+    /*?*/ 0, /*?*/ 0, 0x63, 0xE046, 0x00, 0x00, 0x00, 0x00,      /* FF68 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF70 */
+    /* keypad keys */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45,              /* FF78 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF80 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0xE01C, 0x00, 0x00,            /* FF88 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4B, 0x48,              /* FF90 */
+    0x4D, 0x50, 0x49, 0x51, 0x4F, 0x4C, 0x52, 0x53,              /* FF98 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFA0 */
+    0x00, 0x00, 0x37, 0x4E, 0x53, 0x4A, 0x53, 0xE035,            /* FFA8 */
+    0x52, 0x4F, 0x50, 0x51, 0x4B, 0x4C, 0x4D, 0x47,              /* FFB0 */
+    0x48, 0x49, 0x00, 0x00, 0x00, 0x00,                          /* FFB8 */
+    /* function keys */
+    0x3B, 0x3C,
+    0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44,              /* FFC0 */
+    0x57, 0x58, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,              /* FFC8 */
+    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x76, 0x00, 0x00,              /* FFD0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD8 */
+    /* modifier keys */
+    0x00, 0x2A, 0x36, 0x1D, 0xE01D, 0x3A, 0x00, 0x38,            /* FFE0 */
+    0xE038, 0x38, 0xE038, 0xE05B, 0xE05C, 0x00, 0x00, 0x00,      /* FFE8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFF0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE053             /* FFF8 */
+};
+
+const WORD xkb_keysym_xfree86_to_vkey[256] DECLSPEC_HIDDEN =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, VK_VOLUME_DOWN, VK_VOLUME_MUTE, VK_VOLUME_UP,            /* 1008FF10 */
+    VK_MEDIA_PLAY_PAUSE, VK_MEDIA_STOP,
+    VK_MEDIA_PREV_TRACK, VK_MEDIA_NEXT_TRACK,
+    0, VK_LAUNCH_MAIL, 0, VK_BROWSER_SEARCH,                    /* 1008FF18 */
+    0, 0, 0, VK_BROWSER_HOME,
+    0, 0, 0, 0, 0, 0, VK_BROWSER_BACK, VK_BROWSER_FORWARD,      /* 1008FF20 */
+    VK_BROWSER_STOP, VK_BROWSER_REFRESH, 0, 0, 0, 0, 0, VK_SLEEP, /* 1008FF28 */
+    VK_BROWSER_FAVORITES, 0, VK_LAUNCH_MEDIA_SELECT, 0,         /* 1008FF30 */
+    0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    VK_LAUNCH_APP1, VK_LAUNCH_APP2, 0, 0, 0, 0, 0, 0,           /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
+};
+
+const WORD xkb_keysym_xfree86_to_scan[256] DECLSPEC_HIDDEN =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, 0xE02E, 0xE020, 0xE030, 0xE022, 0xE024, 0xE010, 0xE019,  /* 1008FF10 */
+    0, 0xE06C, 0, 0xE065, 0, 0, 0, 0xE032,                      /* 1008FF18 */
+    0, 0, 0, 0, 0, 0, 0xE06A, 0xE069,                           /* 1008FF20 */
+    0xE068, 0xE067, 0, 0, 0, 0, 0, 0xE05F,                      /* 1008FF28 */
+    0xE066, 0, 0xE06D, 0, 0, 0, 0, 0,                           /* 1008FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    0xE06B, 0xE021, 0, 0, 0, 0, 0, 0,                           /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
+};
+
+#endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/wayland_mutex.c b/dlls/winewayland.drv/wayland_mutex.c
new file mode 100644
index 00000000000..e0f4c0e9656
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_mutex.c
@@ -0,0 +1,137 @@
+/*
+ * Wayland mutex
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <errno.h>
+#include <time.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_mutex_init
+ *
+ * Initialize a wayland_mutex.
+ */
+void wayland_mutex_init(struct wayland_mutex *wayland_mutex, int kind,
+                        const char *name)
+{
+    pthread_mutexattr_t mutexattr;
+
+    pthread_mutexattr_init(&mutexattr);
+    pthread_mutexattr_settype(&mutexattr, kind);
+    pthread_mutex_init(&wayland_mutex->mutex, &mutexattr);
+    pthread_mutexattr_destroy(&mutexattr);
+
+    wayland_mutex->owner_tid = 0;
+    wayland_mutex->lock_count = 0;
+    wayland_mutex->name = name;
+}
+
+/**********************************************************************
+ *          wayland_mutex_destroy
+ *
+ * Destroys a wayland_mutex.
+ */
+void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex)
+{
+    pthread_mutex_destroy(&wayland_mutex->mutex);
+    wayland_mutex->owner_tid = 0;
+    wayland_mutex->lock_count = 0;
+    wayland_mutex->name = NULL;
+}
+
+/**********************************************************************
+ *          wayland_mutex_lock
+ *
+ *  Lock a mutex, emitting error messages in cases of suspected deadlock.
+ *  In case of an unrecoverable error abort to ensure the program doesn't
+ *  continue with an inconsistent state.
+ */
+void wayland_mutex_lock(struct wayland_mutex *wayland_mutex)
+{
+    DWORD tid = GetCurrentThreadId();
+    struct timespec timeout;
+    int err;
+
+    clock_gettime(CLOCK_REALTIME, &timeout);
+    timeout.tv_sec += 5;
+
+    while (TRUE)
+    {
+        err = pthread_mutex_timedlock(&wayland_mutex->mutex, &timeout);
+        if (!err) break;
+
+        if (err == ETIMEDOUT)
+        {
+            ERR("mutex %p %s lock timed out in thread %04x, blocked by %04x, retrying (60 sec)\n",
+                wayland_mutex, wayland_mutex->name, tid, wayland_mutex->owner_tid);
+            clock_gettime(CLOCK_REALTIME, &timeout);
+            timeout.tv_sec += 60;
+        }
+        else
+        {
+            ERR("error locking mutex %p %s errno=%d, aborting\n",
+                wayland_mutex, wayland_mutex->name, errno);
+            abort();
+        }
+    }
+
+    wayland_mutex->owner_tid = tid;
+    wayland_mutex->lock_count++;
+}
+
+/**********************************************************************
+ *          wayland_mutex_unlock
+ *
+ *  Unlock a mutex.
+ */
+void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex)
+{
+    int err;
+
+    wayland_mutex->lock_count--;
+
+    if (wayland_mutex->lock_count == 0)
+    {
+        wayland_mutex->owner_tid = 0;
+    }
+    else if (wayland_mutex->lock_count < 0)
+    {
+        ERR("mutex %p %s lock_count is %d < 0\n",
+             wayland_mutex, wayland_mutex->name, wayland_mutex->lock_count);
+    }
+
+    if ((err = pthread_mutex_unlock(&wayland_mutex->mutex)))
+    {
+        ERR("failed to unlock mutex %p %s errno=%d\n",
+            wayland_mutex, wayland_mutex->name, err);
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
new file mode 100644
index 00000000000..34277d5f9c5
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <assert.h>
+#include <unistd.h>
+#include <xf86drm.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_native_buffer_init_shm
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format)
+{
+    int stride;
+    off_t size;
+    int fd;
+
+    assert(format == WL_SHM_FORMAT_ARGB8888 || format == WL_SHM_FORMAT_XRGB8888);
+
+    stride = width * 4;
+    size = stride * height;
+
+    fd = wayland_shmfd_create("wayland-shm", size);
+    if (fd < 0) return FALSE;
+
+    native->plane_count = 1;
+    native->fds[0] = fd;
+    native->strides[0] = stride;
+    native->offsets[0] = 0;
+    native->width = width;
+    native->height = height;
+    native->format = format;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_native_buffer_init_gbm
+ *
+ * Initializes a native buffer from a gbm_bo.
+ */
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo)
+{
+    int i;
+
+    native->plane_count = gbm_bo_get_plane_count(bo);
+    native->width = gbm_bo_get_width(bo);
+    native->height = gbm_bo_get_height(bo);
+    native->format = gbm_bo_get_format(bo);
+    native->modifier = gbm_bo_get_modifier(bo);
+    for (i = 0; i < ARRAY_SIZE(native->fds); i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        int ret;
+        union gbm_bo_handle handle;
+
+        handle = gbm_bo_get_handle_for_plane(bo, i);
+        if (handle.s32 == -1)
+        {
+            ERR("error: failed to get gbm_bo_handle\n");
+            goto err;
+        }
+
+        ret = drmPrimeHandleToFD(gbm_device_get_fd(gbm_bo_get_device(bo)),
+                                 handle.u32, 0, &native->fds[i]);
+        if (ret < 0 || native->fds[i] < 0)
+        {
+            ERR("error: failed to get dmabuf_fd\n");
+            goto err;
+        }
+        native->strides[i] = gbm_bo_get_stride_for_plane(bo, i);
+        native->offsets[i] = gbm_bo_get_offset(bo, i);
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_native_buffer_deinit
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+void wayland_native_buffer_deinit(struct wayland_native_buffer *native)
+{
+    int i;
+
+    for (i = 0; i < native->plane_count; i++)
+        if (native->fds[i] >= 0) close(native->fds[i]);
+
+    native->plane_count = 0;
+}
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
new file mode 100644
index 00000000000..ecb9c6cfa13
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -0,0 +1,682 @@
+/*
+ * Wayland output handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct default_mode { int32_t width; int32_t height; };
+static const struct default_mode default_modes[] = {
+    { 320,  200}, /* CGA 16:10 */
+    { 320,  240}, /* QVGA 4:3 */
+    { 400,  300}, /* qSVGA 4:3 */
+    { 480,  320}, /* HVGA 3:2 */
+    { 512,  384}, /* MAC 4:3 */
+    { 640,  360}, /* nHD 16:9 */
+    { 640,  400}, /* VESA-0100h 16:10 */
+    { 640,  480}, /* VGA 4:3 */
+    { 720,  480}, /* WVGA 3:2 */
+    { 720,  576}, /* PAL 5:4 */
+    { 768,  480}, /* WVGA 16:10 */
+    { 768,  576}, /* PAL* 4:3 */
+    { 800,  600}, /* SVGA 4:3 */
+    { 854,  480}, /* FWVGA 16:9 */
+    { 960,  540}, /* qHD 16:9 */
+    { 960,  640}, /* DVGA 3:2 */
+    {1024,  576}, /* WSVGA 16:9 */
+    {1024,  640}, /* WSVGA 16:10 */
+    {1024,  768}, /* XGA 4:3 */
+    {1152,  864}, /* XGA+ 4:3 */
+    {1280,  720}, /* HD 16:9 */
+    {1280,  768}, /* WXGA 5:3 */
+    {1280,  800}, /* WXGA 16:10 */
+    {1280,  960}, /* SXGA- 4:3 */
+    {1280, 1024}, /* SXGA 5:4 */
+    {1366,  768}, /* FWXGA 16:9 */
+    {1400, 1050}, /* SXGA+ 4:3 */
+    {1440,  900}, /* WSXGA 16:10 */
+    {1600,  900}, /* HD+ 16:9 */
+    {1600, 1200}, /* UXGA 4:3 */
+    {1680, 1050}, /* WSXGA+ 16:10 */
+    {1920, 1080}, /* FHD 16:9 */
+    {1920, 1200}, /* WUXGA 16:10 */
+    {2048, 1152}, /* QWXGA 16:9 */
+    {2048, 1536}, /* QXGA 4:3 */
+    {2560, 1440}, /* QHD 16:9 */
+    {2560, 1600}, /* WQXGA 16:10 */
+    {2560, 2048}, /* QSXGA 5:4 */
+    {2880, 1620}, /* 3K 16:9 */
+    {3200, 1800}, /* QHD+ 16:9 */
+    {3200, 2400}, /* QUXGA 4:3 */
+    {3840, 2160}, /* 4K 16:9 */
+    {3840, 2400}, /* WQUXGA 16:10 */
+    {5120, 2880}, /* 5K 16:9 */
+    {7680, 4320}, /* 8K 16:9 */
+};
+
+static const int32_t default_refresh = 60000;
+
+/**********************************************************************
+ *          Output handling
+ */
+
+/* Compare mode with the set of provided mode parameters and return -1 if the
+ * mode compares less than the parameters, 0 if the mode compares equal to the
+ * parameters, and 1 if the mode compares greater than the parameters.
+ *
+ * The comparison is based on comparing the width, height, bpp and refresh
+ * in that order.
+ */
+static int wayland_output_mode_cmp(struct wayland_output_mode *mode,
+                                   int32_t width, int32_t height,
+                                   int32_t refresh, int bpp)
+{
+    if (mode->width < width) return -1;
+    if (mode->width > width) return 1;
+    if (mode->height < height) return -1;
+    if (mode->height > height) return 1;
+    if (mode->bpp < bpp) return -1;
+    if (mode->bpp > bpp) return 1;
+    if (mode->refresh < refresh) return -1;
+    if (mode->refresh > refresh) return 1;
+    return 0;
+}
+
+static void wayland_output_add_mode(struct wayland_output *output,
+                                    int32_t width, int32_t height,
+                                    int32_t refresh, int bpp,
+                                    BOOL current, BOOL native)
+{
+    struct wayland_output_mode *mode;
+    struct wl_list *insert_after_link = output->mode_list.prev;
+
+    /* Update mode if it's already in list, otherwise find the insertion point
+     * to maintain the sorted order. */
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        int cmp = wayland_output_mode_cmp(mode, width, height, refresh, bpp);
+        if (cmp == 0) /* mode == new */
+        {
+            /* Upgrade modes from virtual to native, never the reverse. */
+            if (native) mode->native = TRUE;
+            if (current)
+            {
+                output->current_mode = mode;
+                output->current_wine_mode = mode;
+            }
+            return;
+        }
+        else if (cmp == 1) /* mode > new */
+        {
+            insert_after_link = mode->link.prev;
+            break;
+        }
+    }
+
+    mode = calloc(1, sizeof(*mode));
+
+    mode->width = width;
+    mode->height = height;
+    mode->refresh = refresh;
+    mode->bpp = bpp;
+    mode->native = native;
+
+    if (current)
+    {
+        output->current_mode = mode;
+        output->current_wine_mode = mode;
+    }
+
+    wl_list_insert(insert_after_link, &mode->link);
+}
+
+static void wayland_output_add_mode_all_bpp(struct wayland_output *output,
+                                            int32_t width, int32_t height,
+                                            int32_t refresh, BOOL current,
+                                            BOOL native)
+{
+    wayland_output_add_mode(output, width, height, refresh, 32, current, native);
+    wayland_output_add_mode(output, width, height, refresh, 16, FALSE, native);
+    wayland_output_add_mode(output, width, height, refresh, 8, FALSE, native);
+}
+
+static void wayland_output_add_default_modes(struct wayland_output *output)
+{
+    int i;
+    struct wayland_output_mode *mode, *tmp;
+    int32_t max_width = 0;
+    int32_t max_height = 0;
+    int32_t current_refresh =
+        output->current_mode ? output->current_mode->refresh : default_refresh;
+
+    /* Remove all existing virtual modes and get the maximum native
+     * mode size. */
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        if (!mode->native)
+        {
+            wl_list_remove(&mode->link);
+            free(mode);
+        }
+        else
+        {
+            max_width = mode->width > max_width ? mode->width : max_width;
+            max_height = mode->height > max_height ? mode->height : max_height;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(default_modes); i++)
+    {
+        int32_t width = default_modes[i].width;
+        int32_t height = default_modes[i].height;
+
+        /* Skip if this mode is larger than the largest native mode. */
+        if (width > max_width || height > max_height)
+        {
+            TRACE("Skipping mode %dx%d (max: %dx%d)\n",
+                    width, height, max_width, max_height);
+            continue;
+        }
+
+        wayland_output_add_mode_all_bpp(output, width, height, current_refresh,
+                                        FALSE, FALSE);
+    }
+}
+
+static int wayland_output_cmp_x(struct wayland_output *a, struct wayland_output *b)
+{
+    if (a->logical_x < b->logical_x) return -1;
+    if (a->logical_x > b->logical_x) return 1;
+    if (a->logical_y < b->logical_y) return -1;
+    if (a->logical_y > b->logical_y) return 1;
+    return 0;
+}
+
+static int wayland_output_cmp_y(struct wayland_output *a, struct wayland_output *b)
+{
+    if (a->logical_y < b->logical_y) return -1;
+    if (a->logical_y > b->logical_y) return 1;
+    if (a->logical_x < b->logical_x) return -1;
+    if (a->logical_x > b->logical_x) return 1;
+    return 0;
+}
+
+static struct wayland_output** wayland_output_list_sorted(struct wl_list *output_list,
+                                                          int (*cmp)(struct wayland_output *,
+                                                                     struct wayland_output *))
+{
+    int num_outputs = wl_list_length(output_list);
+    int num_sorted = 0;
+    struct wayland_output **sorted;
+    struct wayland_output *o;
+
+    sorted = malloc(sizeof(*sorted) * (num_outputs + 1));
+    if (!sorted)
+    {
+        ERR("Couldn't allocate space for sorted outputs\n");
+        return NULL;
+    }
+
+    wl_list_for_each(o, output_list, link)
+    {
+        int j = num_sorted;
+        while (j > 0 && cmp(o, sorted[j - 1]) < 0)
+        {
+            sorted[j] = sorted[j - 1];
+            j--;
+        }
+        sorted[j] = o;
+        num_sorted++;
+    }
+
+    sorted[num_outputs] = NULL;
+    return sorted;
+}
+
+static void wayland_output_list_update_physical_coords(struct wl_list *output_list)
+{
+    struct wayland_output **sorted_x, **sorted_y;
+    struct wayland_output **cur_p, **prev_p;
+    struct wayland_output *cur, *prev;
+
+    /* Set default physical coordinates. */
+    wl_list_for_each(cur, output_list, link)
+    {
+        cur->x = cur->logical_x;
+        cur->y = cur->logical_y;
+    }
+
+    /* When compositor scaling is used, we treat logical coordinates as
+     * physical. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
+    /* Sort and process the outputs from left to right. */
+    cur_p = sorted_x = wayland_output_list_sorted(output_list, wayland_output_cmp_x);
+    if (!sorted_x) return;
+
+    while ((cur = *cur_p))
+    {
+        /* Update output->x based on other outputs that are to to the left. */
+        prev_p = sorted_x;
+        while ((prev = *prev_p) != cur)
+        {
+            if (cur->logical_x == prev->logical_x + prev->logical_w &&
+                prev->current_mode)
+            {
+                int new_x = prev->x + prev->current_mode->width;
+                if (new_x > cur->x) cur->x = new_x;
+            }
+            prev_p++;
+        }
+
+        cur_p++;
+    }
+
+    free(sorted_x);
+
+    /* Now sort and process the outputs from top to bottom. */
+    cur_p = sorted_y = wayland_output_list_sorted(output_list, wayland_output_cmp_y);
+    if (!sorted_y) return;
+
+    while ((cur = *cur_p))
+    {
+        /* Update output->y based on other outputs that are above. */
+        prev_p = sorted_y;
+        while ((prev = *prev_p) != cur)
+        {
+            if (cur->logical_y == prev->logical_y + prev->logical_h &&
+                prev->current_mode)
+            {
+                int new_y = prev->y + prev->current_mode->height;
+                if (new_y > cur->y) cur->y = new_y;
+            }
+            prev_p++;
+        }
+
+        cur_p++;
+    }
+
+    free(sorted_y);
+}
+
+static void wayland_output_clear_modes(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode, *tmp;
+
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        wl_list_remove(&mode->link);
+        free(mode);
+    }
+}
+
+static void wayland_output_done(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode;
+    struct wayland_output *o;
+
+    TRACE("output->name=%s\n", output->name);
+
+    /* When compositor scaling is used, the current and only native mode
+     * corresponds to the logical width and height. */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+    {
+        int32_t current_refresh =
+            output->current_mode ? output->current_mode->refresh : default_refresh;
+        wayland_output_clear_modes(output);
+        wayland_output_add_mode_all_bpp(output, output->logical_w, output->logical_h,
+                                        current_refresh, TRUE, TRUE);
+    }
+
+    wayland_output_add_default_modes(output);
+    wayland_output_list_update_physical_coords(&output->wayland->output_list);
+
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        TRACE("mode %dx%d @ %d %s\n",
+              mode->width, mode->height, mode->refresh,
+              output->current_mode == mode ? "*" : "");
+    }
+
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (!o->current_mode) continue;
+        TRACE("output->name=%s logical=%d,%d+%dx%d physical=%d,%d+%dx%d\n",
+              o->name,
+              o->logical_x, output->logical_y, o->logical_w, o->logical_h,
+              o->x, o->y, o->current_mode->width, o->current_mode->height);
+    }
+
+    if (wayland_is_process(output->wayland))
+    {
+        /* Temporarily release the per-process instance lock, so that
+         * wayland_init_display_devices can perform more fine grained locking
+         * to avoid deadlocks. */
+        wayland_process_release();
+        wayland_init_display_devices();
+        wayland_process_acquire();
+    }
+    else
+    {
+        wayland_update_outputs_from_process(output->wayland);
+    }
+}
+
+static void output_handle_geometry(void *data, struct wl_output *wl_output,
+                                   int32_t x, int32_t y,
+                                   int32_t physical_width, int32_t physical_height,
+                                   int32_t subpixel,
+                                   const char *make, const char *model,
+                                   int32_t output_transform)
+{
+}
+
+static void output_handle_mode(void *data, struct wl_output *wl_output,
+                               uint32_t flags, int32_t width, int32_t height,
+                               int32_t refresh)
+{
+    struct wayland_output *output = data;
+
+    /* When compositor scaling is used, we don't use physical width/height
+     * for modes and the current mode will be set based on logical width
+     * and height (see wayland_output_done()). */
+    if (option_hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
+    /* Windows apps don't expect a zero refresh rate, so use a default value. */
+    if (refresh == 0) refresh = default_refresh;
+
+    wayland_output_add_mode_all_bpp(output, width, height, refresh,
+                                    (flags & WL_OUTPUT_MODE_CURRENT),
+                                    TRUE);
+}
+
+static void output_handle_done(void *data, struct wl_output *wl_output)
+{
+    struct wayland_output *output = data;
+    if (!output->zxdg_output_v1 ||
+        zxdg_output_v1_get_version(output->zxdg_output_v1) >= 3)
+    {
+        wayland_output_done(output);
+    }
+}
+
+static void output_handle_scale(void *data, struct wl_output *wl_output,
+                                int32_t scale)
+{
+    struct wayland_output *output = data;
+    TRACE("output=%p scale=%d\n", output, scale);
+    /* When compositor scaling is used, we ignore the output scale, to
+     * allow the the compositor to scale us. */
+    if (option_hidpi_scaling != WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        output->scale = scale;
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale
+};
+
+static void zxdg_output_v1_handle_logical_position(void *data,
+                                                   struct zxdg_output_v1 *zxdg_output_v1,
+                                                   int32_t x,
+                                                   int32_t y)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_x=%d logical_y=%d\n", x, y);
+    output->logical_x = x;
+    output->logical_y = y;
+}
+
+static void zxdg_output_v1_handle_logical_size(void *data,
+                                               struct zxdg_output_v1 *zxdg_output_v1,
+                                               int32_t width,
+                                               int32_t height)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_w=%d logical_h=%d\n", width, height);
+    output->logical_w = width;
+    output->logical_h = height;
+}
+
+static void zxdg_output_v1_handle_done(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1)
+{
+    if (zxdg_output_v1_get_version(zxdg_output_v1) < 3)
+    {
+        struct wayland_output *output = data;
+        wayland_output_done(output);
+    }
+}
+
+static void zxdg_output_v1_handle_name(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1,
+                                       const char *name)
+{
+    struct wayland_output *output = data;
+
+    free(output->name);
+    output->name = strdup(name);
+}
+
+static void zxdg_output_v1_handle_description(void *data,
+                                              struct zxdg_output_v1 *zxdg_output_v1,
+                                              const char *description)
+{
+}
+
+static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
+    zxdg_output_v1_handle_logical_position,
+    zxdg_output_v1_handle_logical_size,
+    zxdg_output_v1_handle_done,
+    zxdg_output_v1_handle_name,
+    zxdg_output_v1_handle_description,
+};
+
+/**********************************************************************
+ *          wayland_output_create
+ *
+ *  Creates a wayland_output and adds it to the output list.
+ */
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version)
+{
+    struct wayland_output *output = calloc(1, sizeof(*output));
+
+    if (!output)
+    {
+        ERR("Couldn't allocate space for wayland_output\n");
+        goto err;
+    }
+
+    output->wayland = wayland;
+    output->wl_output = wl_registry_bind(wayland->wl_registry, id,
+                                         &wl_output_interface,
+                                         version < 2 ? version : 2);
+    output->global_id = id;
+    wl_output_add_listener(output->wl_output, &output_listener, output);
+
+    wl_list_init(&output->mode_list);
+    wl_list_init(&output->link);
+
+    output->scale = 1;
+    output->wine_scale = 1.0;
+
+    /* Have a fallback in case xdg_output is not supported or name is not sent. */
+    output->name = malloc(20);
+    if (output->name)
+    {
+        snprintf(output->name, 20, "WaylandOutput%d",
+                 wayland->next_fallback_output_id++);
+    }
+    else
+    {
+        ERR("Couldn't allocate space for output name\n");
+        goto err;
+    }
+
+    if (wayland->zxdg_output_manager_v1)
+        wayland_output_use_xdg_extension(output);
+
+    wl_list_insert(output->wayland->output_list.prev, &output->link);
+
+    return TRUE;
+
+err:
+    if (output) wayland_output_destroy(output);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_output_destroy
+ *
+ *  Destroys a wayland_output.
+ */
+void wayland_output_destroy(struct wayland_output *output)
+{
+    wayland_output_clear_modes(output);
+    wl_list_remove(&output->link);
+    free(output->name);
+    if (output->zxdg_output_v1)
+        zxdg_output_v1_destroy(output->zxdg_output_v1);
+    wl_output_destroy(output->wl_output);
+
+    free(output);
+}
+
+/**********************************************************************
+ *          wayland_output_use_xdg_extension
+ *
+ *  Use the zxdg_output_v1 extension to get output information.
+ */
+void wayland_output_use_xdg_extension(struct wayland_output *output)
+{
+    output->zxdg_output_v1 =
+        zxdg_output_manager_v1_get_xdg_output(output->wayland->zxdg_output_manager_v1,
+                                              output->wl_output);
+    zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
+                                output);
+}
+
+/**********************************************************************
+ *          wayland_update_outputs_from_process
+ *
+ * Update the information in the outputs of this instance, using the
+ * information in the process wayland instance.
+ */
+void wayland_update_outputs_from_process(struct wayland *wayland)
+{
+    struct wayland_output *output;
+    struct wayland_output *process_output;
+    struct wayland *process_wayland = wayland_process_acquire();
+
+    TRACE("wayland=%p process_wayland=%p\n", wayland, process_wayland);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        wl_list_for_each(process_output, &process_wayland->output_list, link)
+        {
+            if (!strcmp(output->name, process_output->name))
+            {
+                lstrcpyW(output->wine_name, process_output->wine_name);
+                wayland_output_set_wine_mode(output,
+                                             process_output->current_wine_mode);
+                break;
+            }
+        }
+    }
+
+    wayland_process_release();
+}
+
+/**********************************************************************
+ *          wayland_output_get_by_wine_name
+ *
+ *  Returns the wayland_output with the specified Wine name (or NULL
+ *  if not present).
+ */
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!wcsicmp(wine_name, output->wine_name))
+            return output;
+    }
+
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_output_set_wine_mode
+ *
+ * Set the current wine mode for the specified output. Note that
+ * the provided mode struct argument is used only as a reference to get
+ * mode information from.
+ */
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  struct wayland_output_mode *ref_mode)
+{
+    struct wayland_output_mode *output_mode;
+
+    TRACE("output->name=%s %dx%d@%d %dbpp\n",
+          output->name, ref_mode->width, ref_mode->height,
+          ref_mode->refresh, ref_mode->bpp);
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (output_mode->width == ref_mode->width &&
+            output_mode->height == ref_mode->height &&
+            output_mode->bpp == ref_mode->bpp &&
+            output_mode->refresh == ref_mode->refresh)
+        {
+            output->current_wine_mode = output_mode;
+            break;
+        }
+    }
+
+    if (!output->current_wine_mode || !output->current_mode)
+    {
+        output->wine_scale = 1.0;
+    }
+    else
+    {
+        double scale_x = ((double)output->current_mode->width) /
+                         output->current_wine_mode->width;
+        double scale_y = ((double)output->current_mode->height) /
+                         output->current_wine_mode->height;
+        /* We want to keep the aspect ratio of the target mode. */
+        output->wine_scale = fmin(scale_x, scale_y);
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
new file mode 100644
index 00000000000..cd46072eec7
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -0,0 +1,352 @@
+/*
+ * Wayland input handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <linux/input.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          Pointer handling
+ */
+
+static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointer,
+                                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    int screen_x, screen_y;
+    RECT screen_rect;
+    RAWINPUT rawinput;
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_screen(wayland->pointer.focused_surface,
+                                     wl_fixed_to_double(sx),
+                                     wl_fixed_to_double(sy),
+                                     &screen_x, &screen_y);
+
+    /* Sometimes, due to rounding, we may end up with pointer coordinates
+     * slightly outside the target window, so bring them within bounds. */
+    if (NtUserGetWindowRect(focused_hwnd, &screen_rect))
+    {
+        if (screen_x >= screen_rect.right) screen_x = screen_rect.right - 1;
+        else if (screen_x < screen_rect.left) screen_x = screen_rect.left;
+        if (screen_y >= screen_rect.bottom) screen_y = screen_rect.bottom - 1;
+        else if (screen_y < screen_rect.top) screen_y = screen_rect.top;
+    }
+
+    TRACE("surface=%p hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_double(sx), wl_fixed_to_double(sy),
+          screen_x, screen_y);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = screen_x;
+    input.mi.dy          = screen_y;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, &rawinput);
+}
+
+static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
+                                  uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+
+    /* Don't handle absolute motion events if we are in relative mode. */
+    if (wayland->pointer.zwp_relative_pointer_v1)
+        return;
+
+    pointer_handle_motion_internal(data, pointer, time, sx, sy);
+}
+
+static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface,
+                                 wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+    RECT clip;
+
+    /* Since pointer events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
+        wayland->pointer.focused_surface = wayland_surface;
+        wayland->pointer.enter_serial = serial;
+        /* Invalidate the set cursor cache, so that next update is
+         * unconditionally applied. */
+        wayland_invalidate_set_cursor();
+        /* Reapply the current cursor, using NtUserSetCursor() instead of
+         * directly calling our driver function, so that the per-thread cursor
+         * visibility state (i.e., ShowCursor()), which is difficult to access
+         * otherwise, is taken into account. */
+        NtUserSetCursor(NtUserGetCursor());
+        /* Reapply the current cursor clip, so that the wayland pointer
+         * constraint is updated for the newly entered window. */
+        NtUserClipCursor(NtUserGetClipCursor(&clip) ? &clip : NULL);
+        /* Handle the enter as a motion, to account for cases where the
+         * window first appears beneath the pointer and won't get a separate
+         * motion event. */
+        pointer_handle_motion_internal(data, pointer, 0, sx, sy);
+    }
+}
+
+static void pointer_handle_leave(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+
+    if (wayland->pointer.focused_surface &&
+        wayland->pointer.focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n",
+              wayland->pointer.focused_surface,
+              wayland->pointer.focused_surface->hwnd);
+        wayland->pointer.focused_surface = NULL;
+        wayland->pointer.enter_serial = 0;
+    }
+}
+
+static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+                                  uint32_t serial, uint32_t time, uint32_t button,
+                                  uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    RAWINPUT rawinput;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("button=%#x state=%#x hwnd=%p\n", button, state, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (button)
+    {
+    case BTN_LEFT: input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN; break;
+    case BTN_RIGHT: input.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN; break;
+    case BTN_MIDDLE: input.mi.dwFlags = MOUSEEVENTF_MIDDLEDOWN; break;
+    default: break;
+    }
+
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+        input.mi.dwFlags <<= 1;
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+        wayland->last_button_serial = serial;
+    else
+        wayland->last_button_serial = 0;
+
+    __wine_send_input(focused_hwnd, &input, &rawinput);
+}
+
+static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+                                uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
+{
+}
+
+static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
+                                       uint32_t axis_source)
+{
+}
+
+static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
+                                     uint32_t time, uint32_t axis)
+{
+}
+
+static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+                                         uint32_t axis, int32_t discrete)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    RAWINPUT rawinput;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("axis=%#x discrete=%d hwnd=%p\n", axis, discrete, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+        input.mi.mouseData = -WHEEL_DELTA * discrete;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+        input.mi.mouseData = WHEEL_DELTA * discrete;
+        break;
+    default: break;
+    }
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, &rawinput);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,
+    pointer_handle_leave,
+    pointer_handle_motion,
+    pointer_handle_button,
+    pointer_handle_axis,
+    pointer_handle_frame,
+    pointer_handle_axis_source,
+    pointer_handle_axis_stop,
+    pointer_handle_axis_discrete,
+};
+
+static void relative_pointer_handle_motion(void *data,
+                                           struct zwp_relative_pointer_v1 *rpointer,
+                                           uint32_t utime_hi,
+                                           uint32_t utime_lo,
+                                           wl_fixed_t dx,
+                                           wl_fixed_t dy,
+                                           wl_fixed_t dx_unaccel,
+                                           wl_fixed_t dy_unaccel)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    int wine_dx, wine_dy;
+    INPUT input = {0};
+    RAWINPUT rawinput;
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_wine(wayland->pointer.focused_surface,
+                                   wl_fixed_to_int(dx), wl_fixed_to_int(dy),
+                                   &wine_dx, &wine_dy);
+
+    TRACE("surface=%p hwnd=%p wayland_dxdy=%d,%d wine_dxdy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_int(dx), wl_fixed_to_int(dy), wine_dx, wine_dy);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = wine_dx;
+    input.mi.dy          = wine_dy;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, &rawinput);
+}
+
+static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
+    relative_pointer_handle_motion,
+};
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer)
+{
+    wayland->pointer.wayland = wayland;
+    wayland->pointer.wl_pointer = wl_pointer;
+    wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+    wayland->pointer.cursor_wl_surface =
+        wl_compositor_create_surface(wayland->wl_compositor);
+    pointer->zwp_relative_pointer_v1 = NULL;
+}
+
+void wayland_pointer_deinit(struct wayland_pointer *pointer)
+{
+    if (pointer->zwp_relative_pointer_v1)
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+
+    if (pointer->wl_pointer)
+        wl_pointer_destroy(pointer->wl_pointer);
+
+    if (pointer->cursor_wl_surface)
+        wl_surface_destroy(pointer->cursor_wl_surface);
+
+    if (pointer->cursor)
+        wayland_cursor_destroy(pointer->cursor);
+
+    memset(pointer, 0, sizeof(*pointer));
+}
+
+/**********************************************************************
+ *          wayland_pointer_set_relative
+ *
+ * Set whether the pointer emits relative (if able) or absolute motion events.
+ * The default is to emit absolute motion events.
+ */
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative)
+{
+    if (!pointer->wayland->zwp_relative_pointer_manager_v1)
+        return;
+
+    if (!pointer->zwp_relative_pointer_v1 && relative)
+    {
+        pointer->zwp_relative_pointer_v1 =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+                pointer->wayland->zwp_relative_pointer_manager_v1,
+                pointer->wl_pointer);
+
+        zwp_relative_pointer_v1_add_listener(pointer->zwp_relative_pointer_v1,
+                                             &zwp_relative_pointer_v1_listener,
+                                             pointer->wayland);
+    }
+    else if (pointer->zwp_relative_pointer_v1 && !relative)
+    {
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+        pointer->zwp_relative_pointer_v1 = NULL;
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_remote.c b/dlls/winewayland.drv/wayland_remote.c
new file mode 100644
index 00000000000..4832e8a4c00
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_remote.c
@@ -0,0 +1,976 @@
+/*
+ * Wayland remote (cross-process) rendering
+ *
+ * Copyright (c) 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <inttypes.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+enum wayland_remote_surface_message
+{
+    WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT,
+    WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS,
+};
+
+struct wayland_remote_surface
+{
+    struct wl_list link;
+    int ref;
+    enum wayland_remote_surface_type type;
+    struct wl_event_queue *wl_event_queue;
+    struct wayland_surface *wayland_surface;
+    struct wl_list buffer_list;
+    struct wl_list throttle_list;
+};
+
+struct wayland_remote_buffer
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wl_buffer *wl_buffer;
+    HANDLE released_event;
+};
+
+struct wayland_remote_throttle
+{
+    struct wl_list link;
+    struct wl_callback *wl_callback;
+    HANDLE event;
+};
+
+struct params_type
+{
+    enum wayland_remote_surface_type type;
+};
+
+struct params_buffer
+{
+    struct params_type params_type;
+    enum wayland_remote_buffer_type buffer_type;
+    int plane_count;
+    HANDLE fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    int width, height;
+    int format;
+    uint64_t modifier;
+    HANDLE released_event;
+    HANDLE throttle_event;
+};
+
+struct wayland_remote_surface_proxy
+{
+    HWND hwnd;
+    enum wayland_remote_surface_type type;
+};
+
+static struct wayland_mutex wayland_remote_surface_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": wayland_remote_surface_mutex"
+};
+
+static struct wl_list wayland_remote_surfaces = { &wayland_remote_surfaces, &wayland_remote_surfaces };
+static struct wl_list wayland_remote_buffers = { &wayland_remote_buffers, &wayland_remote_buffers};
+
+static void wayland_remote_buffer_destroy(struct wayland_remote_buffer *remote_buffer)
+{
+    TRACE("remote_buffer=%p released_event=%p\n",
+          remote_buffer, remote_buffer->released_event);
+    if (remote_buffer->released_event)
+    {
+        wl_list_remove(&remote_buffer->link);
+        NtSetEvent(remote_buffer->released_event, NULL);
+        NtClose(remote_buffer->released_event);
+    }
+    else
+    {
+        /* Detached remote buffers are stored in the global
+         * wayland_remote_buffers list, and require locking. */
+        wayland_mutex_lock(&wayland_remote_surface_mutex);
+        wl_list_remove(&remote_buffer->link);
+        wayland_mutex_unlock(&wayland_remote_surface_mutex);
+    }
+    wl_buffer_destroy(remote_buffer->wl_buffer);
+    free(remote_buffer);
+}
+
+static void remote_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_remote_buffer *remote_buffer =
+        (struct wayland_remote_buffer *) data;
+
+    TRACE("released_event=%p\n", remote_buffer->released_event);
+    wayland_remote_buffer_destroy(remote_buffer);
+}
+
+static const struct wl_buffer_listener remote_buffer_listener = {
+    remote_buffer_release
+};
+
+static struct wayland_remote_buffer *wayland_remote_buffer_create(struct wayland_remote_surface *remote,
+                                                                  struct wl_buffer *wl_buffer,
+                                                                  HANDLE released_event)
+{
+    struct wayland_remote_buffer *remote_buffer = calloc(1, sizeof(*remote_buffer));
+    if (!remote_buffer)
+    {
+        ERR("Failed to allocate memory for remote buffer\n");
+        return NULL;
+    }
+
+    remote_buffer->hwnd = remote->wayland_surface->hwnd;
+    remote_buffer->wl_buffer = wl_buffer;
+
+    if (released_event)
+    {
+        /* Non-detached buffers are dispatched from remote surface event queue
+         * so that we can dispatch events on demand (see
+         * WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS). */
+        wl_proxy_set_queue((struct wl_proxy *) remote_buffer->wl_buffer,
+                           remote->wl_event_queue);
+        wl_list_insert(&remote->buffer_list, &remote_buffer->link);
+        remote_buffer->released_event = released_event;
+    }
+    else
+    {
+        /* Detached buffers are dispatched from the default thread queue and
+         * are stored in wayland_remote_buffers, in order to not be destroyed
+         * along with their remote surface. We don't need to explicitly lock to
+         * insert to this list at this point, since having a remote surface
+         * implies a locked wayland_remote_surface_mutex. */
+        wl_list_insert(&wayland_remote_buffers, &remote_buffer->link);
+    }
+
+    wl_buffer_add_listener(remote_buffer->wl_buffer,
+                           &remote_buffer_listener, remote_buffer);
+
+    return remote_buffer;
+}
+
+static void wayland_remote_throttle_destroy(struct wayland_remote_throttle *remote_throttle)
+{
+    wl_list_remove(&remote_throttle->link);
+
+    wl_callback_destroy(remote_throttle->wl_callback);
+
+    if (remote_throttle->event)
+    {
+        NtSetEvent(remote_throttle->event, NULL);
+        NtClose(remote_throttle->event);
+    }
+
+    free(remote_throttle);
+}
+
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_remote_throttle *remote_throttle = data;
+
+    TRACE("throttle_event=%p\n", remote_throttle->event);
+
+    wayland_remote_throttle_destroy(remote_throttle);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
+static struct wayland_remote_throttle *wayland_remote_throttle_create(struct wayland_remote_surface *remote,
+                                                                      struct wl_callback *wl_callback,
+                                                                      HANDLE throttle_event)
+{
+    struct wayland_remote_throttle *remote_throttle = calloc(1, sizeof(*remote_throttle));
+    if (!remote_throttle)
+    {
+        ERR("Failed to allocate memory for remote throttle\n");
+        return NULL;
+    }
+    remote_throttle->wl_callback = wl_callback;
+    remote_throttle->event = throttle_event;
+
+    wl_proxy_set_queue((struct wl_proxy *) remote_throttle->wl_callback,
+                        remote->wl_event_queue);
+    wl_callback_add_listener(remote_throttle->wl_callback, &throttle_listener,
+                             remote_throttle);
+    wl_list_insert(&remote->throttle_list, &remote_throttle->link);
+
+    return remote_throttle;
+}
+
+static void wayland_remote_surface_destroy(struct wayland_remote_surface *remote)
+{
+    struct wayland_remote_buffer *buffer, *buffer_tmp;
+    struct wayland_remote_throttle *throttle, *throttle_tmp;
+
+    TRACE("remote=%p\n", remote);
+
+    wl_list_remove(&remote->link);
+
+    wl_list_for_each_safe(buffer, buffer_tmp, &remote->buffer_list, link)
+        wayland_remote_buffer_destroy(buffer);
+
+    wl_list_for_each_safe(throttle, throttle_tmp, &remote->throttle_list, link)
+        wayland_remote_throttle_destroy(throttle);
+
+    if (remote->wl_event_queue) wl_event_queue_destroy(remote->wl_event_queue);
+    if (remote->wayland_surface) wayland_surface_unref_glvk(remote->wayland_surface);
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+    free(remote);
+}
+
+static struct wayland_remote_surface *wayland_remote_surface_create(struct wayland_surface *wayland_surface,
+                                                                    enum wayland_remote_surface_type type)
+{
+    struct wayland_remote_surface *remote;
+
+    remote = calloc(1, sizeof(*remote));
+    if (!remote)
+    {
+        ERR("Failed to allocate memory for remote surface hwnd=%p type=%d\n",
+            wayland_surface->hwnd, type);
+        goto err;
+    }
+
+    remote->ref = 1;
+    remote->type = type;
+    wl_list_init(&remote->buffer_list);
+    wl_list_init(&remote->throttle_list);
+
+    remote->wl_event_queue = wl_display_create_queue(wayland_surface->wayland->wl_display);
+    if (!remote->wl_event_queue)
+    {
+        ERR("Failed to create wl_event_queue for remote surface hwnd=%p type=%d\n",
+            wayland_surface->hwnd, type);
+        goto err;
+    }
+
+    switch (type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wayland_surface_ref(wayland_surface);
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        if (!wayland_surface_create_or_ref_glvk(wayland_surface))
+        {
+            ERR("Failed to create GL/VK for remote surface hwnd=%p type=%d\n",
+                wayland_surface->hwnd, type);
+            goto err;
+        }
+        break;
+    default:
+        ERR("Invalid surface type %d\n", type);
+        goto err;
+    }
+
+    remote->wayland_surface = wayland_surface;
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    wl_list_insert(&wayland_remote_surfaces, &remote->link);
+
+    return remote;
+
+err:
+    if (remote) wayland_remote_surface_destroy(remote);
+    return NULL;
+}
+
+static struct wayland_remote_surface *wayland_remote_surface_get(HWND hwnd,
+                                                                 enum wayland_remote_surface_type type)
+{
+    struct wayland_remote_surface *remote;
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    wl_list_for_each(remote, &wayland_remote_surfaces, link)
+    {
+        if (remote->wayland_surface->hwnd == hwnd && remote->type == type)
+            return remote;
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+
+    return NULL;
+}
+
+static void wayland_remote_surface_release(struct wayland_remote_surface *remote)
+{
+    if (remote) wayland_mutex_unlock(&wayland_remote_surface_mutex);
+}
+
+static void wayland_remote_surface_ref(struct wayland_remote_surface *remote)
+{
+    remote->ref++;
+}
+
+static void wayland_remote_surface_unref(struct wayland_remote_surface *remote)
+{
+    remote->ref--;
+    if (remote->ref == 0)
+        wayland_remote_surface_destroy(remote);
+    else
+        wayland_remote_surface_release(remote);
+}
+
+static BOOL wayland_remote_surface_commit(struct wayland_remote_surface *remote,
+                                          struct wayland_remote_buffer *remote_buffer,
+                                          HANDLE throttle_event)
+{
+    BOOL ret = FALSE;
+    struct wl_surface *wl_surface;
+
+    wayland_mutex_lock(&remote->wayland_surface->mutex);
+
+    TRACE("remote=%p wayland_surface=%p glvk=%p drawing_allowed=%d\n",
+          remote, remote->wayland_surface, remote->wayland_surface->glvk,
+          remote->wayland_surface->drawing_allowed);
+
+    switch (remote->type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wl_surface = remote->wayland_surface->wl_surface;
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        wl_surface = remote->wayland_surface->glvk ?
+                     remote->wayland_surface->glvk->wl_surface : NULL;
+        break;
+    default:
+        ERR("Invalid surface type %d\n", remote->type);
+        goto out;
+    }
+
+    if (remote->wayland_surface->drawing_allowed && wl_surface)
+    {
+        wayland_surface_ensure_mapped(remote->wayland_surface);
+        wl_surface_attach(wl_surface, remote_buffer->wl_buffer, 0, 0);
+        wl_surface_damage_buffer(wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (throttle_event &&
+            !wayland_remote_throttle_create(remote, wl_surface_frame(wl_surface),
+                                            throttle_event))
+        {
+            NtSetEvent(throttle_event, NULL);
+            NtClose(throttle_event);
+        }
+        wl_surface_commit(wl_surface);
+        ret = TRUE;
+    }
+
+out:
+    wayland_mutex_unlock(&remote->wayland_surface->mutex);
+
+    return ret;
+}
+
+static void *map_shm_from_handle(HANDLE params, size_t size)
+{
+    int shm_fd = -1;
+    void *data = NULL;
+
+    if (wine_server_handle_to_fd(params, FILE_READ_DATA, &shm_fd, NULL) != STATUS_SUCCESS)
+    {
+        ERR("Failed to get SHM fd from Wine handle.\n");
+        goto out;
+    }
+
+    data = mmap(NULL, size, PROT_READ, MAP_SHARED, shm_fd, 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("Failed to map SHM fd.\n");
+        data = NULL;
+    }
+
+out:
+    if (shm_fd >= 0) close(shm_fd);
+
+    return data;
+}
+
+static void wayland_remote_surface_update_wayland_surface(struct wayland_remote_surface *remote,
+                                                          struct wayland_surface *wayland_surface)
+{
+    switch (remote->type)
+    {
+    case WAYLAND_REMOTE_SURFACE_TYPE_NORMAL:
+        wayland_surface_ref(wayland_surface);
+        wayland_surface_unref(remote->wayland_surface);
+        break;
+    case WAYLAND_REMOTE_SURFACE_TYPE_GLVK:
+        if (!wayland_surface_create_or_ref_glvk(wayland_surface)) return;
+        wayland_surface_unref_glvk(remote->wayland_surface);
+        break;
+    default:
+        ERR("Invalid surface type %d\n", remote->type);
+        return;
+    }
+    remote->wayland_surface = wayland_surface;
+}
+
+static void wayland_remote_surface_handle_create(struct wayland_remote_surface *remote,
+                                                 struct wayland_surface *wayland_surface,
+                                                 struct params_type *params)
+{
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (remote)
+    {
+        wayland_remote_surface_ref(remote);
+        return;
+    }
+
+    remote = wayland_remote_surface_create(wayland_surface, params->type);
+    if (!remote)
+    {
+        ERR("Failed to create remote surface for hwnd=%p type=%d\n",
+            wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_remote_surface_release(remote);
+}
+
+static void wayland_remote_surface_handle_destroy(struct wayland_remote_surface *remote,
+                                                  struct wayland_surface *wayland_surface,
+                                                  struct params_type *params)
+{
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_remote_surface_unref(remote);
+}
+
+static BOOL _wayland_native_buffer_init_params(struct wayland_native_buffer *native,
+                                               struct params_buffer *params)
+{
+    int i;
+
+    native->plane_count = params->plane_count;
+    native->width = params->width;
+    native->height = params->height;
+    native->format = params->format;
+    native->modifier = params->modifier;
+
+    for (i = 0; i < native->plane_count; i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        NTSTATUS ret;
+
+        ret = wine_server_handle_to_fd(params->fds[i], GENERIC_READ | SYNCHRONIZE,
+                                       &native->fds[i], NULL);
+        if (ret != STATUS_SUCCESS)
+        {
+            ERR("Failed to get fd from handle ret=%#x\n", ret);
+            goto err;
+        }
+
+        native->strides[i] = params->strides[i];
+        native->offsets[i] = params->offsets[i];
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
+static void wayland_remote_surface_handle_commit(struct wayland_remote_surface *remote,
+                                                 struct wayland_surface *wayland_surface,
+                                                 struct params_buffer *params)
+{
+    struct wayland_native_buffer native;
+    struct wl_buffer *wl_buffer = NULL;
+    struct wayland_remote_buffer *remote_buffer = NULL;
+
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->params_type.type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->params_type.type);
+        goto err;
+    }
+
+    if (!_wayland_native_buffer_init_params(&native, params))
+    {
+        ERR("Failed to initialize native buffer\n");
+        goto err;
+    }
+
+    switch (params->buffer_type)
+    {
+    case WAYLAND_REMOTE_BUFFER_TYPE_SHM:
+        {
+            struct wayland_shm_buffer *shm_buffer =
+                wayland_shm_buffer_create_from_native(remote->wayland_surface->wayland,
+                                                      &native);
+            if (shm_buffer)
+                wl_buffer = wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+        }
+        break;
+    case WAYLAND_REMOTE_BUFFER_TYPE_DMABUF:
+        {
+            struct wayland_dmabuf_buffer *dmabuf_buffer =
+                wayland_dmabuf_buffer_create_from_native(remote->wayland_surface->wayland,
+                                                         &native);
+            if (dmabuf_buffer)
+                wl_buffer = wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(dmabuf_buffer);
+        }
+        break;
+    default:
+        ERR("Invalid buffer type %d\n", params->buffer_type);
+        goto err;
+    }
+
+    wayland_native_buffer_deinit(&native);
+    if (!wl_buffer)
+    {
+        ERR("Failed to create wl_buffer\n");
+        goto err;
+    }
+
+    remote_buffer = wayland_remote_buffer_create(remote, wl_buffer, params->released_event);
+
+    if (!wayland_remote_surface_commit(remote, remote_buffer, params->throttle_event))
+        goto err;
+
+    return;
+
+err:
+    if (params->released_event)
+    {
+        NtSetEvent(params->released_event, NULL);
+        NtClose(params->released_event);
+    }
+    if (params->throttle_event)
+    {
+        NtSetEvent(params->throttle_event, NULL);
+        NtClose(params->throttle_event);
+    }
+    if (remote_buffer) wayland_remote_buffer_destroy(remote_buffer);
+}
+
+static void wayland_remote_surface_handle_dispatch_events(struct wayland_remote_surface *remote,
+                                                          struct wayland_surface *wayland_surface,
+                                                          struct params_type *params)
+{
+
+    TRACE("hwnd=%p type=%d\n", wayland_surface->hwnd, params->type);
+
+    if (!remote)
+    {
+        WARN("Remote surface for hwnd=%p type=%d does not exist\n",
+             wayland_surface->hwnd, params->type);
+        return;
+    }
+
+    wayland_dispatch_queue(remote->wl_event_queue, 0);
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_handle_message
+ *
+ *  Handles a message sent to our remote surface infrastructure.
+ */
+void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
+                                           WPARAM message, LPARAM params_long)
+{
+    HANDLE params_handle = LongToHandle(params_long);
+    void *params = NULL;
+    size_t params_size;
+    struct wayland_remote_surface *remote = NULL;
+
+    TRACE("message=%ld params=%p\n", message, params_handle);
+
+    switch (message)
+    {
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE:
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY:
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS:
+        params_size = sizeof(struct params_type);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT:
+        params_size = sizeof(struct params_buffer);
+        break;
+    default:
+        goto out;
+    }
+
+    params = map_shm_from_handle(params_handle, sizeof(struct params_type));
+    if (!params) goto out;
+
+    remote = wayland_remote_surface_get(wayland_surface->hwnd,
+                                        ((struct params_type *) params)->type);
+    if (remote)
+        wayland_remote_surface_update_wayland_surface(remote, wayland_surface);
+
+    switch (message)
+    {
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE:
+        wayland_remote_surface_handle_create(remote, wayland_surface, params);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY:
+        wayland_remote_surface_handle_destroy(remote, wayland_surface, params);
+        remote = NULL;
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT:
+        wayland_remote_surface_handle_commit(remote, wayland_surface, params);
+        break;
+    case WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS:
+        wayland_remote_surface_handle_dispatch_events(remote, wayland_surface, params);
+        break;
+    }
+
+out:
+    if (remote) wayland_remote_surface_release(remote);
+    if (params) munmap(params, params_size);
+    if (params_handle) NtClose(params_handle);
+}
+
+/**********************************************************************
+ *          wayland_destroy_remote_surfaces
+ *
+ *  Destroys remote surfaces targeting a window.
+ */
+void wayland_destroy_remote_surfaces(HWND hwnd)
+{
+    struct wayland_remote_surface *remote, *tmp;
+    struct wayland_remote_buffer *remote_buf, *tmp_buf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wayland_mutex_lock(&wayland_remote_surface_mutex);
+    /* Destroy any detached remote buffers for the window. */
+    wl_list_for_each_safe(remote_buf, tmp_buf, &wayland_remote_buffers, link)
+    {
+        if (remote_buf->hwnd == hwnd)
+            wayland_remote_buffer_destroy(remote_buf);
+    }
+    /* Destroy any remote surfaces for the window. */
+    wl_list_for_each_safe(remote, tmp, &wayland_remote_surfaces, link)
+    {
+        if (remote->wayland_surface->hwnd == hwnd)
+        {
+            /* wayland_remote_surface_destroy() unlocks the surface mutex,
+             * since it assumes that that the passed remote was acquired
+             * with wayland_remote_surface_get(). Lock the mutex manually
+             * to maintain the proper lock count. */
+            wayland_mutex_lock(&wayland_remote_surface_mutex);
+            wayland_remote_surface_destroy(remote);
+        }
+    }
+    wayland_mutex_unlock(&wayland_remote_surface_mutex);
+}
+
+static HANDLE remote_handle_from_local(HANDLE local_handle, HWND remote_hwnd)
+{
+    HANDLE remote_handle = 0;
+    HANDLE remote_process = 0;
+    DWORD remote_process_id;
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(OBJECT_ATTRIBUTES) };
+    CLIENT_ID cid;
+
+    if (!NtUserGetWindowThread(remote_hwnd, &remote_process_id)) return 0;
+
+    cid.UniqueProcess = ULongToHandle(remote_process_id);
+
+    if (NtOpenProcess(&remote_process, PROCESS_DUP_HANDLE, &attr, &cid) ||
+        !remote_process)
+    {
+        ERR("Failed to open process with id %#x\n", remote_process_id);
+        return 0;
+    }
+
+    if (NtDuplicateObject(GetCurrentProcess(), local_handle, remote_process,
+                          &remote_handle, 0, 0, DUPLICATE_SAME_ACCESS))
+    {
+        ERR("Failed to duplicate handle in remote process\n");
+    }
+
+    NtClose(remote_process);
+
+    return remote_handle;
+}
+
+static HANDLE remote_handle_from_fd(int fd, HWND remote_hwnd)
+{
+    HANDLE local_fd_handle = 0;
+    HANDLE remote_fd_handle = 0;
+
+    if (wine_server_fd_to_handle(fd, GENERIC_READ | SYNCHRONIZE, 0,
+                                 &local_fd_handle) != STATUS_SUCCESS)
+    {
+        ERR("Failed to get handle from fd\n");
+        goto out;
+    }
+
+    remote_fd_handle = remote_handle_from_local(local_fd_handle, remote_hwnd);
+
+out:
+    if (local_fd_handle) NtClose(local_fd_handle);
+
+    return remote_fd_handle;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_create
+ *
+ *  Creates a proxy for rendering to a remote surface.
+ */
+struct wayland_remote_surface_proxy *wayland_remote_surface_proxy_create(HWND hwnd,
+                                                                         enum wayland_remote_surface_type type)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+    struct wayland_remote_surface_proxy *proxy;
+
+    TRACE("hwnd=%p type=%d\n", hwnd, type);
+
+    proxy = calloc(1, sizeof(*proxy));
+    if (!proxy) return NULL;
+
+    proxy->hwnd = hwnd;
+    proxy->type = type;
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-create-glvk", sizeof(*params));
+    if (params_fd < 0) goto err;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto err;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, hwnd);
+    if (!remote_params_handle) goto err;
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_CREATE,
+                      HandleToLong(remote_params_handle));
+
+    close(params_fd);
+
+    TRACE("hwnd=%p type=%d => proxy=%p\n", hwnd, type, proxy);
+
+    return proxy;
+
+err:
+    if (params_fd >= 0) close(params_fd);
+    if (proxy) free(proxy);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_destroy
+ *
+ *  Destroys a proxy to a remote surface.
+ */
+void wayland_remote_surface_proxy_destroy(struct wayland_remote_surface_proxy *proxy)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+
+    TRACE("proxy=%p hwnd=%p type=%d\n", proxy, proxy->hwnd, proxy->type);
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-destroy", sizeof(*params));
+    if (params_fd < 0) goto out;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto out;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto out;
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_DESTROY,
+                      HandleToLong(remote_params_handle));
+
+out:
+    if (params_fd >= 0) close(params_fd);
+    free(proxy);
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_commit
+ *
+ *  Commits a dmabuf to the surface targeted by the remote surface proxy.
+ *
+ *  Returns a handle to an Event that will be set when the committed buffer
+ *  can be reused.
+ */
+BOOL wayland_remote_surface_proxy_commit(struct wayland_remote_surface_proxy *proxy,
+                                         struct wayland_native_buffer *native,
+                                         enum wayland_remote_buffer_type buffer_type,
+                                         enum wayland_remote_buffer_commit commit,
+                                         HANDLE *buffer_released_event_out,
+                                         HANDLE *throttle_event_out)
+{
+    int params_fd;
+    struct params_buffer *params = MAP_FAILED;
+    HANDLE local_released_event = 0;
+    HANDLE local_throttle_event = 0;
+    HANDLE remote_params_handle;
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(attr), .Attributes = OBJ_OPENIF };
+    int i;
+
+    TRACE("proxy=%p hwnd=%p type=%d commit=%d\n",
+          proxy, proxy->hwnd, proxy->type, commit);
+
+    /* Create buffer params */
+    params_fd = wayland_shmfd_create("wayland-remote-surface-commit", sizeof(*params));
+    if (params_fd < 0) goto err;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto err;
+
+    /* Populate buffer params */
+    params->params_type.type = proxy->type;
+    params->buffer_type = buffer_type;
+    params->plane_count = native->plane_count;
+    for (i = 0; i < native->plane_count; i++)
+    {
+        params->fds[i] = remote_handle_from_fd(native->fds[i], proxy->hwnd);
+        if (!params->fds[i]) goto err;
+        params->strides[i] = native->strides[i];
+        params->offsets[i] = native->offsets[i];
+    }
+    params->width = native->width;
+    params->height = native->height;
+    params->format = native->format;
+    params->modifier = native->modifier;
+
+    if (commit != WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED)
+    {
+        if (NtCreateEvent(&local_released_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE) ||
+            !local_released_event)
+        {
+            goto err;
+        }
+        params->released_event = remote_handle_from_local(local_released_event, proxy->hwnd);
+        if (!params->released_event) goto err;
+    }
+
+    if (commit == WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED)
+    {
+        if (NtCreateEvent(&local_throttle_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE) ||
+            !local_throttle_event)
+        {
+            goto err;
+        }
+        params->throttle_event = remote_handle_from_local(local_throttle_event, proxy->hwnd);
+        if (!params->throttle_event) goto err;
+    }
+
+    /* Create remote handle for params and post message. */
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto err;
+
+    TRACE("proxy=%p hwnd=%p type=%d commit=%d => local_released=%p "
+          "remote_released=%p, local_throttle=%p remote_throttle=%p\n",
+          proxy, proxy->hwnd, proxy->type, commit, local_released_event,
+          params->released_event, local_throttle_event, params->throttle_event);
+
+    NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                      WAYLAND_REMOTE_SURFACE_MESSAGE_COMMIT,
+                      HandleToLong(remote_params_handle));
+
+    munmap(params, sizeof(*params));
+    close(params_fd);
+
+    if (buffer_released_event_out)
+        *buffer_released_event_out = local_released_event;
+    else if (local_released_event)
+        NtClose(local_released_event);
+
+    if (throttle_event_out)
+        *throttle_event_out = local_throttle_event;
+    else if (local_throttle_event)
+        NtClose(local_throttle_event);
+
+    return TRUE;
+
+err:
+    if (params != MAP_FAILED)
+    {
+        for (i = 0; i < native->plane_count; i++)
+            if (params->fds[i]) NtClose(params->fds[i]);
+        if (params->released_event) NtClose(params->released_event);
+        munmap(params, sizeof(*params));
+    }
+    if (params_fd >= 0) close(params_fd);
+    if (local_released_event) NtClose(local_released_event);
+    if (local_throttle_event) NtClose(local_throttle_event);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_remote_surface_proxy_dispatch_events
+ *
+ *  Dispatches events (e.g., buffer release events) from the remote surface.
+ */
+BOOL wayland_remote_surface_proxy_dispatch_events(struct wayland_remote_surface_proxy *proxy)
+{
+    int params_fd;
+    struct params_type *params;
+    HANDLE remote_params_handle;
+    BOOL ret = FALSE;
+
+    TRACE("proxy=%p hwnd=%p type=%d\n", proxy, proxy->hwnd, proxy->type);
+
+    params_fd = wayland_shmfd_create("wayland-remote-surface-dispatch", sizeof(*params));
+    if (params_fd < 0) goto out;
+    params = mmap(NULL, sizeof(*params), PROT_WRITE, MAP_SHARED, params_fd, 0);
+    if (params == MAP_FAILED) goto out;
+    params->type = proxy->type;
+    munmap(params, sizeof(*params));
+
+    remote_params_handle = remote_handle_from_fd(params_fd, proxy->hwnd);
+    if (!remote_params_handle) goto out;
+
+    ret = NtUserPostMessage(proxy->hwnd, WM_WAYLAND_REMOTE_SURFACE,
+                            WAYLAND_REMOTE_SURFACE_MESSAGE_DISPATCH_EVENTS,
+                            HandleToLong(remote_params_handle));
+
+out:
+    if (params_fd >= 0) close(params_fd);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
new file mode 100644
index 00000000000..ef2b65abb2d
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -0,0 +1,224 @@
+/*
+ * Wayland SHM buffers
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_shm_buffer_create_from_native
+ *
+ * Creates a wayland SHM buffer from the specified native buffer.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                 struct wayland_native_buffer *native)
+{
+    struct wayland_shm_buffer *shm_buffer;
+    struct wl_shm_pool *pool;
+    int size;
+    void *data;
+
+    shm_buffer = calloc(1, sizeof(*shm_buffer));
+    if (!shm_buffer)
+        goto err;
+
+    wl_list_init(&shm_buffer->link);
+
+    size = native->strides[0] * native->height;
+
+    TRACE("%p %dx%d format=%d size=%d\n",
+          shm_buffer, native->width, native->height, native->format, size);
+
+    if (size == 0)
+        goto err;
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, native->fds[0], 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("mmap failed: %s size=%d\n", strerror(errno), size);
+        goto err;
+    }
+
+    pool = wl_shm_create_pool(wayland->wl_shm, native->fds[0], size);
+    shm_buffer->wl_buffer = wl_shm_pool_create_buffer(pool, 0, native->width, native->height,
+                                                      native->strides[0], native->format);
+    wl_shm_pool_destroy(pool);
+
+    shm_buffer->width = native->width;
+    shm_buffer->height = native->height;
+    shm_buffer->stride = native->strides[0];
+    shm_buffer->format = native->format;
+    shm_buffer->map_data = data;
+    shm_buffer->map_size = size;
+    shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+    if (!shm_buffer->damage_region)
+    {
+        ERR("failed to create buffer damage region\n");
+        goto err;
+    }
+
+    TRACE("%p %dx%d size=%d => map=%p\n",
+          shm_buffer, native->width, native->height, size, data);
+
+    return shm_buffer;
+
+err:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_create
+ *
+ * Creates a SHM buffer with the specified width, height and format.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format)
+{
+    struct wayland_native_buffer native;
+    struct wayland_shm_buffer *shm_buffer;
+
+    if (wayland_native_buffer_init_shm(&native, width, height, format))
+    {
+        shm_buffer = wayland_shm_buffer_create_from_native(wayland, &native);
+        wayland_native_buffer_deinit(&native);
+    }
+    else
+    {
+        shm_buffer = NULL;
+    }
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_destroy
+ *
+ * Destroys a SHM buffer.
+ */
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    TRACE("%p map=%p\n", shm_buffer, shm_buffer->map_data);
+
+    wl_list_remove(&shm_buffer->link);
+
+    if (shm_buffer->wl_buffer)
+        wl_buffer_destroy(shm_buffer->wl_buffer);
+    if (shm_buffer->map_data)
+        munmap(shm_buffer->map_data, shm_buffer->map_size);
+    if (shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(shm_buffer->damage_region);
+
+    free(shm_buffer);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a SHM buffer and destroy the SHM buffer.
+ */
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = shm_buffer->wl_buffer;
+    shm_buffer->wl_buffer = NULL;
+
+    wayland_shm_buffer_destroy(shm_buffer);
+
+    return wl_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_clear_damage
+ *
+ *  Clears all damage accumulated by a SHM buffer.
+ */
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer)
+{
+    NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_add_damage
+ *
+ *  Adds damage (i.e., a region which needs update) to a SHM buffer.
+ */
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage)
+{
+    NtGdiCombineRgn(shm_buffer->damage_region, shm_buffer->damage_region, damage, RGN_OR);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_get_damage_clipped
+ *
+ * Returns the damage region data for this buffer clipped within the
+ * provided clip region (if any).
+ *
+ * The returned RGNDATA* should be freed by the caller using free().
+ */
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+    HRGN damage_region;
+
+    if (clip)
+    {
+        damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (!damage_region) goto err;
+        NtGdiCombineRgn(damage_region, shm_buffer->damage_region, clip, RGN_AND);
+    }
+    else
+    {
+        damage_region = shm_buffer->damage_region;
+    }
+
+    if (!(size = NtGdiGetRegionData(damage_region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+    if (!NtGdiGetRegionData(damage_region, size, data)) goto err;
+
+    if (damage_region != shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(damage_region);
+
+    return data;
+
+err:
+    if (damage_region && damage_region != shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(damage_region);
+    free(data);
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/wayland_shmfd.c b/dlls/winewayland.drv/wayland_shmfd.c
new file mode 100644
index 00000000000..b2e69be33e4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shmfd.c
@@ -0,0 +1,86 @@
+/*
+ * Wayland SHM fd
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+/* For memfd_create */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+
+static int fd_resize(int fd, off_t size)
+{
+    /*
+     * Filesystems that do support fallocate will return EINVAL or
+     * EOPNOTSUPP. In this case we need to fall back to ftruncate
+     */
+    errno = posix_fallocate(fd, 0, size);
+    if (errno == 0)
+        return 0;
+    else if (errno != EINVAL && errno != EOPNOTSUPP)
+        return -1;
+    if (ftruncate(fd, size) < 0)
+        return -1;
+
+    return 0;
+}
+
+/**********************************************************************
+ *          wayland_shmfd_create
+ *
+ * Creates a file descriptor representing an anonymous SHM region.
+ */
+int wayland_shmfd_create(const char *name, int size)
+{
+    int fd = memfd_create(name, MFD_CLOEXEC | MFD_ALLOW_SEALING);
+
+    if (fd >= 0)
+    {
+        /* We can add this seal before calling posix_fallocate(), as
+         * the file is currently zero-sized anyway.
+         *
+         * There is also no need to check for the return value, we
+         * couldn't do anything with it anyway.
+         */
+        fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_SEAL);
+    }
+
+    while (TRUE)
+    {
+        int ret = fd_resize(fd, size);
+        if (ret == 0) break;
+        if (ret < 0 && errno == EINTR) continue;
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
new file mode 100644
index 00000000000..a797c2203df
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -0,0 +1,1630 @@
+/*
+ * Wayland surfaces
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+#include "ntuser.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* Change to 1 to dump committed buffer contents to disk */
+#define DEBUG_DUMP_COMMIT_BUFFER 0
+
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output);
+
+static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
+                                         uint32_t serial)
+{
+    struct wayland_surface *surface = data;
+    uint32_t last_serial = surface->pending.serial;
+    BOOL last_processed = surface->pending.processed;
+
+    TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
+
+    surface->pending.serial = serial;
+    surface->pending.processed = FALSE;
+
+    /* If we have an unprocessed WM_WAYLAND_CONFIGURE message, no need to
+     * repost. Note that checking only for a valid serial is not enough to
+     * guarantee that there is a pending WM_WAYLAND_CONFIGURE message: we may
+     * have processed the message but not acked the configure request due to
+     * surface size incompatibilities (see window.c:
+     * wayland_win_data_update_wayland_surface_state()). */
+    if (last_serial && !last_processed)
+    {
+        TRACE("not reposting, last_serial=%u\n", last_serial);
+        return;
+    }
+
+    if (surface->hwnd)
+        NtUserPostMessage(surface->hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+    else
+        wayland_surface_ack_pending_configure(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ack_pending_configure
+ *
+ * Acks the pending configure event, making it current.
+ */
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
+{
+    if (!surface->xdg_surface || !surface->pending.serial)
+        return;
+
+    TRACE("Setting current serial=%u size=%dx%d flags=%#x\n",
+          surface->pending.serial, surface->pending.width,
+          surface->pending.height, surface->pending.configure_flags);
+
+    surface->current = surface->pending;
+    xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_xdg_surface_configure,
+};
+
+static void handle_xdg_toplevel_configure(void *data,
+                                          struct xdg_toplevel *xdg_toplevel,
+                                          int32_t width, int32_t height,
+                                          struct wl_array *states)
+{
+    struct wayland_surface *surface = data;
+    uint32_t *state;
+    int flags = 0;
+
+    wl_array_for_each(state, states)
+    {
+        switch(*state)
+        {
+        case XDG_TOPLEVEL_STATE_MAXIMIZED:
+            flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+            break;
+        case XDG_TOPLEVEL_STATE_ACTIVATED:
+            flags |= WAYLAND_CONFIGURE_FLAG_ACTIVATED;
+            break;
+        case XDG_TOPLEVEL_STATE_RESIZING:
+            flags |= WAYLAND_CONFIGURE_FLAG_RESIZING;
+            break;
+        case XDG_TOPLEVEL_STATE_FULLSCREEN:
+            flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+            break;
+        default:
+            break;
+        }
+    }
+
+    surface->pending.width = width;
+    surface->pending.height = height;
+    surface->pending.configure_flags = flags;
+
+    TRACE("%dx%d flags=%#x\n", width, height, flags);
+}
+
+static void handle_xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    TRACE("\n");
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    handle_xdg_toplevel_configure,
+    handle_xdg_toplevel_close,
+};
+
+/* Gets the output we consider to be the origin of this surface.
+ * If the surface can be fullscreen this is the topleft-most output that
+ * fully contains this surface, otherwise it's the topleft-most output
+ * that partially contains this surface. */
+static struct wayland_output *wayland_surface_get_origin_output(
+        struct wayland_surface *surface)
+{
+    struct wayland_output_ref *ref;
+    struct wayland_output *topleft = NULL;
+    struct wayland_output *containing = NULL;
+    RECT window_rect;
+
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+
+    wl_list_for_each(ref, &surface->output_ref_list, link)
+    {
+        if (surface->window_fullscreen)
+        {
+            RECT monitor_rect;
+            struct wayland_output_mode *mode = ref->output->current_wine_mode;
+
+            SetRect(&monitor_rect, ref->output->x, ref->output->y,
+                    ref->output->x + (mode ? mode->width : 0),
+                    ref->output->y + (mode ? mode->height : 0));
+
+            if ((!containing || ref->output->x < containing->x ||
+                 (ref->output->x == containing->x && ref->output->y < containing->y)) &&
+                contains_rect(&window_rect, &monitor_rect))
+            {
+                containing = ref->output;
+            }
+        }
+
+        if (!topleft || ref->output->x < topleft->x ||
+            (ref->output->x == topleft->x && ref->output->y < topleft->y))
+            topleft = ref->output;
+    }
+
+    return containing ? containing : topleft;
+}
+
+static void handle_wl_surface_enter(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+    struct wayland_output_ref *ref;
+    struct wayland_output *origin;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    ref = calloc(1, sizeof(*ref));
+    if (!ref) { ERR("memory allocation failed"); return; }
+    ref->output = output;
+    wl_list_insert(&surface->output_ref_list, &ref->link);
+
+    origin = wayland_surface_get_origin_output(surface);
+    wayland_surface_set_main_output(surface, origin);
+}
+
+static void handle_wl_surface_leave(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    wayland_surface_leave_output(surface, output);
+}
+
+static const struct wl_surface_listener wl_surface_listener = {
+    handle_wl_surface_enter,
+    handle_wl_surface_leave,
+};
+
+/**********************************************************************
+ *          wayland_surface_create_plain
+ *
+ * Creates a plain, role-less wayland surface.
+ */
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    surface = calloc(1, sizeof(*surface));
+    if (!surface)
+        goto err;
+
+    TRACE("surface=%p\n", surface);
+
+    wayland_mutex_init(&surface->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_surface");
+
+    surface->wayland = wayland;
+
+    surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
+    if (!surface->wl_surface)
+        goto err;
+
+    if (surface->wayland->wp_viewporter)
+    {
+        surface->wp_viewport =
+            wp_viewporter_get_viewport(surface->wayland->wp_viewporter,
+                                       surface->wl_surface);
+    }
+
+    wl_list_init(&surface->output_ref_list);
+    wl_list_init(&surface->link);
+    wl_list_init(&surface->child_list);
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, surface);
+    /* Plain surfaces are unmappable, so don't draw on them. */
+    surface->drawing_allowed = FALSE;
+
+    surface->ref = 1;
+    surface->role = WAYLAND_SURFACE_ROLE_NONE;
+
+    /* Although not technically toplevel, plain surfaces have no parent, so
+     * track them in the toplevel list. */
+    wl_list_insert(&wayland->toplevel_list, &surface->link);
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_make_toplevel
+ *
+ * Gives the toplevel role to a plain wayland surface, optionally associated
+ * with a parent surface.
+ */
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->drawing_allowed = TRUE;
+
+    surface->xdg_surface =
+        xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
+    if (!surface->xdg_surface)
+        goto err;
+    xdg_surface_add_listener(surface->xdg_surface, &xdg_surface_listener, surface);
+
+    surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
+    if (!surface->xdg_toplevel)
+        goto err;
+    xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface);
+
+    if (parent && parent->xdg_toplevel)
+        xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
+
+    if (process_name)
+        xdg_toplevel_set_app_id(surface->xdg_toplevel, process_name);
+
+    /* Plain surfaces (which are the only kind can become toplevel) are
+     * already tracked in the toplevel_list, there is no need to readd. */
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
+
+    /* Wait for the first configure event. */
+    while (!surface->current.serial)
+        wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
+    return;
+
+err:
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+    ERR("Failed to assign toplevel role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_create_subsurface
+ *
+ * Assigns the subsurface role to a plain wayland surface, with the specified
+ * parent.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->drawing_allowed = TRUE;
+
+    surface->parent = wayland_surface_ref(parent);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&surface->link);
+    wayland_mutex_lock(&parent->mutex);
+    wl_list_insert(&parent->child_list, &surface->link);
+    wayland_mutex_unlock(&parent->mutex);
+
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    surface->main_output = parent->main_output;
+    wl_surface_set_buffer_scale(surface->wl_surface,
+                                wayland_surface_get_buffer_scale(parent));
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return;
+
+err:
+    wayland_surface_unref(surface->parent);
+    surface->parent = NULL;
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_clear_role
+ *
+ * Clears the role related Wayland objects of a Wayland surface, making it a
+ * plain surface again. We can later assign the same role (but not a
+ * different one!) to the surface.
+ */
+void wayland_surface_clear_role(struct wayland_surface *surface)
+{
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    surface->drawing_allowed = FALSE;
+
+    if (surface->parent)
+    {
+        /* As a plain surface, this should now tracked in the toplevel_list. */
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+        wl_list_insert(&surface->wayland->toplevel_list, &surface->link);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+    memset(&surface->current, 0, sizeof(surface->current));
+
+    /* We need to unmap, otherwise future role assignments may fail. */
+    wayland_surface_unmap(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_position
+ *
+ * Configures the position of a wayland surface relative to its parent.
+ * This only applies to surfaces having the subsurface role.
+ *
+ * The coordinates should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int wine_x, int wine_y)
+{
+    int x, y;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d wayland=%d,%d\n",
+          surface, surface->hwnd, wine_x, wine_y, x, y);
+
+    if (surface->wl_subsurface)
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_geometry
+ *
+ * Configures the geometry of a wayland surface, i.e., the rectangle
+ * within that surface that contains the surface's visible bounds.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * Note that this doesn't configure any associated GL/VK subsurface,
+ * wayland_surface_reconfigure_glvk() needs to be called separately.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int wine_x, int wine_y,
+                                          int wine_width, int wine_height)
+{
+    int x, y, width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d+%dx%d wayland=%d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    if (surface->xdg_surface && width != 0 && height != 0)
+    {
+        enum wayland_configure_flags flags = surface->current.configure_flags;
+
+        /* Sometimes rounding errors in our coordinate space transformations
+         * can lead to invalid geometry values, so enforce acceptable geometry
+         * values to avoid causing a protocol error. */
+        if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+        {
+            width = surface->current.width;
+            height = surface->current.height;
+        }
+        else if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+        {
+            if (width > surface->current.width)
+                width = surface->current.width;
+            if (height > surface->current.height)
+                height = surface->current.height;
+        }
+
+        xdg_surface_set_window_geometry(surface->xdg_surface, x, y, width, height);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_size
+ *
+ * Configures the size of a wayland surface.
+ *
+ * The sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int wine_width, int wine_height)
+{
+    int width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%dx%d wayland=%dx%d\n",
+          surface, surface->hwnd, wine_width, wine_height, width, height);
+
+    /* Use a viewport, if supported, to handle display mode changes. */
+    if (surface->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(surface->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(surface->wp_viewport, -1, -1);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_configure_is_compatible
+ *
+ * Checks whether a wayland_surface_configure object is compatible with the
+ * the provided arguments.
+ */
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags)
+{
+    static int mask = WAYLAND_CONFIGURE_FLAG_MAXIMIZED |
+                      WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+
+    /* We require the same state. */
+    if ((flags & mask) != (conf->configure_flags & mask))
+        return FALSE;
+
+    /* The maximized state requires the configured size. During surface
+     * reconfiguration we can use surface geometry to provide smaller areas
+     * from larger sizes, so only smaller sizes are incompatible. */
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        (width < conf->width || height < conf->height))
+    {
+        return FALSE;
+    }
+
+    /* The fullscreen state requires sizes smaller or equal to the configured
+     * size. We can provide this during surface reconfiguration using surface
+     * geometry, so we are always compatible with a fullscreen state. */
+
+    return TRUE;
+}
+
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!(size = NtGdiGetRegionData(region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+
+    if (!NtGdiGetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    free(data);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_commit_buffer
+ *
+ * Commits a SHM buffer on a wayland surface. Returns whether the
+ * buffer was actually committed.
+ */
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region)
+{
+    RGNDATA *surface_damage;
+    int wayland_width, wayland_height;
+
+    /* Since multiple threads can commit a buffer to a wayland surface
+     * (e.g., child windows in different threads), we guard this function
+     * to ensure we get complete and atomic buffer commits. */
+    wayland_mutex_lock(&surface->mutex);
+
+    TRACE("surface=%p (%dx%d) flags=%#x buffer=%p (%dx%d)\n",
+          surface, surface->current.width, surface->current.height,
+          surface->current.configure_flags, shm_buffer,
+          shm_buffer->width, shm_buffer->height);
+
+    wayland_surface_coords_rounded_from_wine(surface,
+                                             shm_buffer->width, shm_buffer->height,
+                                             &wayland_width, &wayland_height);
+
+    /* Certain surface states are very strict about the dimensions of buffers
+     * they accept. To avoid wayland protocol errors, drop buffers not matching
+     * the expected dimensions of such surfaces. This typically happens
+     * transiently during resizing operations. */
+    if (!surface->drawing_allowed ||
+        !wayland_surface_configure_is_compatible(&surface->current,
+                                             wayland_width,
+                                             wayland_height,
+                                             surface->current.configure_flags))
+    {
+        wayland_mutex_unlock(&surface->mutex);
+        TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
+        shm_buffer->busy = FALSE;
+        return FALSE;
+    }
+
+    if (DEBUG_DUMP_COMMIT_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/commit-%.4d.pam", dbgid++, shm_buffer->map_data,
+                    shm_buffer->width, shm_buffer->height,
+                    shm_buffer->format == WL_SHM_FORMAT_ARGB8888,
+                    shm_buffer->damage_region, NULL);
+    }
+
+    wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
+
+    /* Add surface damage, i.e., which parts of the surface have changed since
+     * the last surface commit. Note that this is different from the buffer
+     * damage returned by wayland_shm_buffer_get_damage(). */
+    surface_damage = get_region_data(surface_damage_region);
+    if (surface_damage)
+    {
+        RECT *rgn_rect = (RECT *)surface_damage->Buffer;
+        RECT *rgn_rect_end = rgn_rect + surface_damage->rdh.nCount;
+
+        for (;rgn_rect < rgn_rect_end; rgn_rect++)
+        {
+            wl_surface_damage_buffer(surface->wl_surface,
+                                     rgn_rect->left, rgn_rect->top,
+                                     rgn_rect->right - rgn_rect->left,
+                                     rgn_rect->bottom - rgn_rect->top);
+        }
+        free(surface_damage);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = TRUE;
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_surface_destroy
+ *
+ * Destroys a wayland surface.
+ */
+void wayland_surface_destroy(struct wayland_surface *surface)
+{
+    struct wayland_pointer *pointer = &surface->wayland->pointer;
+    struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_data_device *data_device = &surface->wayland->data_device;
+    struct wayland_surface *child, *child_tmp;
+    struct wayland_output_ref *ref, *ref_tmp;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (pointer->focused_surface == surface)
+        pointer->focused_surface = NULL;
+
+    if (keyboard->focused_surface == surface)
+        keyboard->focused_surface = NULL;
+
+    if (data_device->dnd_surface == surface)
+        data_device->dnd_surface = NULL;
+
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    wayland_mutex_lock(&surface->mutex);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, link)
+    {
+        /* Since the current surface (the parent) is being destroyed,
+         * disassociate from the child to avoid the child trying to
+         * destroy the parent. */
+        child->parent = NULL;
+        wayland_surface_destroy(child);
+    }
+    wayland_mutex_unlock(&surface->mutex);
+
+    wl_list_for_each_safe(ref, ref_tmp, &surface->output_ref_list, link)
+    {
+        wl_list_remove(&ref->link);
+        free(ref);
+    }
+
+    if (surface->surface_feedback)
+        wayland_dmabuf_surface_feedback_destroy(surface->surface_feedback);
+
+    if (surface->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    if (surface->wp_viewport)
+    {
+        wp_viewport_destroy(surface->wp_viewport);
+        surface->wp_viewport = NULL;
+    }
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    if (surface->wl_surface)
+    {
+        wl_surface_destroy(surface->wl_surface);
+        surface->wl_surface = NULL;
+    }
+
+    if (surface->parent)
+    {
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+    else
+    {
+        wl_list_remove(&surface->link);
+    }
+
+    wayland_mutex_destroy(&surface->mutex);
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    free(surface);
+}
+
+static struct wayland_surface *wayland_surface_create_glvk_common(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    glvk = wayland_surface_create_plain(surface->wayland);
+    if (!glvk)
+        goto err;
+
+    glvk->parent = wayland_surface_ref(surface);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&glvk->link);
+    wayland_mutex_lock(&glvk->parent->mutex);
+    wl_list_insert(&glvk->parent->child_list, &glvk->link);
+    wayland_mutex_unlock(&glvk->parent->mutex);
+
+    glvk->wl_subsurface =
+        wl_subcompositor_get_subsurface(glvk->wayland->wl_subcompositor,
+                                        glvk->wl_surface,
+                                        surface->wl_surface);
+    if (!glvk->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(glvk->wl_subsurface);
+    /* Place the glvk subsurface just above the parent surface, so that it
+     * doesn't end up obscuring any other subsurfaces. */
+    wl_subsurface_place_above(glvk->wl_subsurface, surface->wl_surface);
+
+    glvk->hwnd = surface->hwnd;
+    glvk->main_output = surface->main_output;
+    wl_surface_set_buffer_scale(glvk->wl_surface, wayland_surface_get_buffer_scale(surface));
+    glvk->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return glvk;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return NULL;
+}
+
+static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = NULL;
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk)
+        glvk = wayland_surface_ref(surface->glvk);
+    wayland_mutex_unlock(&surface->mutex);
+    return glvk;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_glvk
+ *
+ * Creates a GL/VK subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+    RECT client_rect;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (wayland_surface_ref_glvk(surface))
+        return TRUE;
+
+    glvk = wayland_surface_create_glvk_common(surface);
+    if (!glvk)
+        goto err;
+
+    wayland_mutex_lock(&surface->mutex);
+    surface->glvk = glvk;
+    wayland_mutex_unlock(&surface->mutex);
+
+    /* Set initial position in the client area. */
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+
+    wayland_surface_reconfigure_glvk(surface,
+                                     client_rect.left, client_rect.top,
+                                     client_rect.right - client_rect.left,
+                                     client_rect.bottom - client_rect.top);
+
+    wayland_surface_reconfigure_apply(surface);
+
+    if (wayland_dmabuf_has_feedback_support(&surface->wayland->dmabuf))
+        glvk->surface_feedback = wayland_dmabuf_surface_feedback_create(&surface->wayland->dmabuf,
+                                                                        glvk->wl_surface);
+
+    return TRUE;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref_glvk
+ *
+ * Unreferences the associated GL/VK subsurface for this wayland surface.
+ */
+void wayland_surface_unref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk_to_destroy = NULL;
+    LONG ref = -12345;
+
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk && (ref = InterlockedDecrement(&surface->glvk->ref)) == 0)
+    {
+        glvk_to_destroy = surface->glvk;
+        surface->glvk = NULL;
+    }
+    TRACE("surface=%p glvk=%p ref=%d->%d\n",
+          surface, glvk_to_destroy ? glvk_to_destroy : surface->glvk, ref + 1, ref);
+    wayland_mutex_unlock(&surface->mutex);
+
+    if (glvk_to_destroy)
+        wayland_surface_destroy(glvk_to_destroy);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_glvk
+ *
+ * Configures the position and size of the GL/VK subsurface associated with
+ * a wayland surface.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      int wine_width, int wine_height)
+{
+    int x, y, width, height;
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (!glvk)
+        return;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    glvk->offset_x = wine_x;
+    glvk->offset_y = wine_y;
+
+    wl_subsurface_set_position(glvk->wl_subsurface, x, y);
+
+    /* Use a viewport, if supported, to ensure GL surfaces remain inside their
+     * parent's boundaries when resizing and also to handle display mode
+     * changes. If the size is invalid use a 1x1 destination (instead of
+     * unsetting with -1x-1) since many apps don't respect a GL/VK 0x0 size
+     * which can happen, e.g., when an app is minimized. */
+    if (glvk->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(glvk->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(glvk->wp_viewport, 1, 1);
+    }
+
+    wayland_surface_unref_glvk(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (glvk)
+    {
+        wl_surface_commit(glvk->wl_surface);
+        wayland_surface_unref_glvk(surface);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_unmap
+ *
+ * Unmaps (i.e., hides) this surface.
+ */
+void wayland_surface_unmap(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_surface_attach(surface->wl_surface, NULL, 0, 0);
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = FALSE;
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_to_screen
+ *
+ * Converts the surface-local coordinates to Windows screen coordinates.
+ */
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y)
+{
+    RECT window_rect = {0};
+    int wine_x, wine_y;
+
+    wayland_surface_coords_to_wine(surface, wayland_x, wayland_y,
+                                   &wine_x, &wine_y);
+
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+
+    /* Some wayland surfaces are offset relative to their window rect,
+     * e.g., GL subsurfaces. */
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    *screen_x = wine_x + window_rect.left;
+    *screen_y = wine_y + window_rect.top;
+
+    TRACE("hwnd=%p wayland=%.2f,%.2f rect=%s => screen=%d,%d\n",
+          surface->hwnd, wayland_x, wayland_y, wine_dbgstr_rect(&window_rect),
+          *screen_x, *screen_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_from_screen
+ *
+ * Converts the Windows screen coordinates to surface-local coordinates.
+ */
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y)
+{
+    int wine_x, wine_y;
+    RECT window_rect = {0};
+
+    /* Screen to window */
+    NtUserGetWindowRect(surface->hwnd, &window_rect);
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    wine_x = screen_x - window_rect.left;
+    wine_y = screen_y - window_rect.top;
+
+    /* Window to wayland surface */
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y,
+                                     wayland_x, wayland_y);
+
+    TRACE("hwnd=%p screen=%d,%d rect=%s => wayland=%.2f,%.2f\n",
+          surface->hwnd, screen_x, screen_y, wine_dbgstr_rect(&window_rect),
+          *wayland_x, *wayland_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates.
+ */
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y)
+{
+    struct wayland_output *output = surface->main_output;
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    if (output)
+    {
+        *wayland_x = wine_x * output->wine_scale / scale;
+        *wayland_y = wine_y * output->wine_scale / scale;
+    }
+    else
+    {
+        *wayland_x = wine_x / (double)scale;
+        *wayland_y = wine_y / (double)scale;
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wine=%d,%d => wayland=%.2f,%.2f\n",
+          surface->hwnd, output ? output->wine_scale : -1.0, wine_x, wine_y,
+          *wayland_x, *wayland_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_rounded_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates
+ * rounding to the closest integer value.
+ */
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y)
+{
+    double w_x, w_y;
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y, &w_x, &w_y);
+    *wayland_x = round(w_x);
+    *wayland_y = round(w_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_to_wine
+ *
+ * Converts the surface-local coordinates to wine windows-local coordinates.
+ */
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y)
+{
+    struct wayland_output *output = surface->main_output;
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    if (output)
+    {
+        *wine_x = round(wayland_x * scale / output->wine_scale);
+        *wine_y = round(wayland_y * scale / output->wine_scale);
+    }
+    else
+    {
+        *wine_x = round(wayland_x * scale);
+        *wine_y = round(wayland_y * scale);
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wayland=%.2f,%.2f => wine=%d,%d\n",
+          surface->hwnd, output ? output->wine_scale : -1.0,
+          wayland_x, wayland_y, *wine_x, *wine_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_find_wine_fullscreen_fit
+ *
+ * Finds the size of a fullscreen Wine window that when scaled best fits into a
+ * wayland surface with the provided size, while maintaining the aspect
+ * ratio of the current Wine display mode.
+ */
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height)
+{
+    struct wayland_output *output = surface->main_output;
+    double subarea_width, subarea_height;
+
+    TRACE("hwnd=%p wayland_width=%d wayland_height=%d\n",
+          surface->hwnd, wayland_width, wayland_height);
+
+    /* If the wine mode doesn't match the wayland mode, Find the largest subarea
+     * within wayland_width x wayland_height that has an aspect ratio equal to
+     * the wine display mode aspect ratio. */
+    if (output)
+    {
+        double aspect = ((double)wayland_width) / wayland_height;
+        double wine_aspect = ((double)output->current_wine_mode->width) /
+                             output->current_wine_mode->height;
+        if (aspect > wine_aspect)
+        {
+            subarea_width = wayland_height * wine_aspect;
+            subarea_height = wayland_height;
+        }
+        else
+        {
+            subarea_width = wayland_width;
+            subarea_height = wayland_width / wine_aspect;
+        }
+    }
+    else
+    {
+        subarea_width = wayland_width;
+        subarea_height = wayland_height;
+    }
+
+    /* Transform the calculated subarea to wine coordinates. */
+    wayland_surface_coords_to_wine(surface,
+                                   subarea_width, subarea_height,
+                                   wine_width, wine_height);
+}
+
+static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    wayland_shm_buffer_destroy(shm_buffer);
+}
+
+static const struct wl_buffer_listener dummy_buffer_listener = {
+    dummy_buffer_release
+};
+
+/**********************************************************************
+ *          wayland_surface_ensure_mapped
+ *
+ * Ensure that the wayland surface is mapped, by committing a dummy
+ * buffer if necessary.
+ *
+ * The contents of GL or Vulkan windows are rendered on subsurfaces
+ * with the parent surface used for the decorations. Such GL/VK
+ * subsurfaces may want to commit their contents before the parent
+ * surface has had a chance to commit. In such cases the GL/VK commit
+ * will not be displayed, but, more importantly, will not get a frame
+ * callback until the parent surface is also committed. Depending on
+ * the presentation mode, a second GL/VK buffer swap may indefinitely
+ * block waiting on the frame callback. By calling this function before a
+ * GL/VK buffer swap we can avoid this situation.
+ */
+void wayland_surface_ensure_mapped(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    /* If this is a subsurface, ensure its parent is also mapped. */
+    if (surface->parent)
+        wayland_surface_ensure_mapped(surface->parent);
+
+    TRACE("surface=%p hwnd=%p mapped=%d\n",
+          surface, surface->hwnd, surface->mapped);
+
+    if (!surface->mapped)
+    {
+        int width = surface->current.width;
+        int height = surface->current.height;
+        int flags = surface->current.configure_flags;
+        int wine_width, wine_height;
+        struct wayland_shm_buffer *dummy_shm_buffer;
+        HRGN damage;
+
+        /* Use a large enough width/height, so even when the target
+         * surface is scaled by the compositor, this will not end up
+         * being 0x0. */
+        if (width == 0) width = 32;
+        if (height == 0) height = 32;
+
+        if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+            !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        {
+            wayland_surface_find_wine_fullscreen_fit(surface, width, height,
+                                                     &wine_width, &wine_height);
+        }
+        else
+        {
+            wayland_surface_coords_to_wine(surface, width, height,
+                                           &wine_width, &wine_height);
+        }
+
+        dummy_shm_buffer = wayland_shm_buffer_create(surface->wayland,
+                                                     wine_width, wine_height,
+                                                     WL_SHM_FORMAT_ARGB8888);
+        wl_buffer_add_listener(dummy_shm_buffer->wl_buffer,
+                               &dummy_buffer_listener, dummy_shm_buffer);
+
+        damage = NtGdiCreateRectRgn(0, 0, wine_width, wine_height);
+        if (!wayland_surface_commit_buffer(surface, dummy_shm_buffer, damage))
+            wayland_shm_buffer_destroy(dummy_shm_buffer);
+        NtGdiDeleteObjectApp(damage);
+    }
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_ref
+ *
+ * Add a reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface)
+{
+    LONG ref = InterlockedIncrement(&surface->ref);
+    TRACE("surface=%p ref=%d->%d\n", surface, ref - 1, ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref
+ *
+ * Remove a reference to wayland_surface, potentially destroying it.
+ */
+void wayland_surface_unref(struct wayland_surface *surface)
+{
+    LONG ref = InterlockedDecrement(&surface->ref);
+
+    TRACE("surface=%p ref=%d->%d\n", surface, ref + 1, ref);
+
+    if (ref == 0)
+        wayland_surface_destroy(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_update_pointer_constraint
+ *
+ * Update the pointer constraint on the surface. Constraint mode depends
+ * on the current Windows cursor clip and cursor visibility.
+ */
+void wayland_surface_update_pointer_constraint(struct wayland_surface *surface)
+{
+    struct wayland *wayland = surface->wayland;
+    struct wayland_surface *glvk;
+    struct wl_region *region;
+    RECT vscreen_rect;
+    RECT clip_rect = wayland->cursor_clip;
+    RECT client_rect = {0};
+    RECT client_clip_rect;
+    BOOL needs_lock = FALSE;
+    BOOL needs_confine = FALSE;
+    BOOL set_cursor_pos = surface->set_cursor_pos;
+
+    /* Treat constraint updates triggered by SetCursorPos as single-shot. */
+    surface->set_cursor_pos = FALSE;
+
+    if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
+        return;
+
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+    NtUserMapWindowPoints(surface->hwnd, NULL, (POINT*)&client_rect, 2);
+
+    vscreen_rect.top = NtUserGetSystemMetrics(SM_YVIRTUALSCREEN);
+    vscreen_rect.left = NtUserGetSystemMetrics(SM_XVIRTUALSCREEN);
+    vscreen_rect.bottom = vscreen_rect.top + NtUserGetSystemMetrics(SM_CYVIRTUALSCREEN);
+    vscreen_rect.right = vscreen_rect.left + NtUserGetSystemMetrics(SM_CXVIRTUALSCREEN);
+
+    /* Get the effective clip area, if any. */
+    intersect_rect(&clip_rect, &clip_rect, &vscreen_rect);
+    intersect_rect(&client_clip_rect, &clip_rect, &client_rect);
+
+    TRACE("wayland=%p surface=%p (glvk=%p) clip_rect=%s client_clip_rect=%s "
+          "client=%s vscreen=%s hcursor=%p\n",
+          wayland, surface, surface->glvk,
+          wine_dbgstr_rect(&clip_rect), wine_dbgstr_rect(&client_clip_rect),
+          wine_dbgstr_rect(&client_rect),
+          wine_dbgstr_rect(&vscreen_rect),
+          wayland->pointer.hcursor);
+
+    /* If there is a GL/VK subsurface use that to apply the pointer constaints,
+     * since it's covering the whole client area. */
+    glvk = wayland_surface_ref_glvk(surface);
+    if (glvk)
+    {
+        if (surface->zwp_locked_pointer_v1)
+        {
+            zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+            surface->zwp_locked_pointer_v1 = NULL;
+        }
+        if (surface->zwp_confined_pointer_v1)
+        {
+            zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+            surface->zwp_confined_pointer_v1 = NULL;
+        }
+        surface = glvk;
+    }
+
+    /* Only handle confinement or locking if the cursor is actually clipped
+     * within this window, or if the clip rect is empty. */
+    if (!IsRectEmpty(&client_clip_rect) || IsRectEmpty(&clip_rect))
+    {
+        /* Having an effective clip (i.e., clip is not the whole screen) is
+         * a prerequisite for locking the pointer. If the client rect is
+         * the whole screen (i.e., application is fullscreen), we can't
+         * differentiate between an explicit fullscreen clip and no effective
+         * clip (i.e., clip is the whole screen), so also consider locking. */
+        BOOL lock_clip = !EqualRect(&clip_rect, &vscreen_rect) ||
+                         EqualRect(&client_rect, &vscreen_rect);
+        /* To consider confining the pointer we must have an effective clip,
+         * otherwise confininement makes no difference. */
+        BOOL confine_clip = !EqualRect(&clip_rect, &vscreen_rect);
+        /* We may need to unlock the cursor if it is visible or we locked
+         * because it was clipped but now the clip is gone. */
+        BOOL needs_unlock =
+            wayland->pointer.locked_reason != WAYLAND_POINTER_LOCKED_REASON_NONE &&
+            (wayland->pointer.hcursor ||
+             ((wayland->pointer.locked_reason & WAYLAND_POINTER_LOCKED_REASON_CLIP) && !lock_clip));
+
+        /* If the cursor is not visible, and we have an lock clip, lock.
+         * Otherwise if the cursor is visible check if we need to confine. */
+        if (!needs_unlock && !wayland->pointer.hcursor && (lock_clip || set_cursor_pos))
+        {
+            if (lock_clip)
+                wayland->pointer.locked_reason |= WAYLAND_POINTER_LOCKED_REASON_CLIP;
+            if (set_cursor_pos)
+                wayland->pointer.locked_reason |= WAYLAND_POINTER_LOCKED_REASON_SET_CURSOR_POS;
+            needs_lock = TRUE;
+        }
+        else if (wayland->pointer.hcursor && confine_clip)
+        {
+            needs_confine = TRUE;
+        }
+    }
+
+    if (!needs_lock) wayland->pointer.locked_reason = WAYLAND_POINTER_LOCKED_REASON_NONE;
+
+    /* Destroy unneeded interface objects. */
+    if (!needs_lock && surface->zwp_locked_pointer_v1)
+    {
+        POINT cursor_pos;
+
+        if (NtUserGetCursorPos(&cursor_pos) && PtInRect(&client_rect, cursor_pos))
+        {
+            double wayland_x, wayland_y;
+            wayland_surface_coords_from_screen(surface,
+                                               cursor_pos.x, cursor_pos.y,
+                                               &wayland_x, &wayland_y);
+
+            zwp_locked_pointer_v1_set_cursor_position_hint(
+                    surface->zwp_locked_pointer_v1,
+                    wl_fixed_from_double(wayland_x),
+                    wl_fixed_from_double(wayland_y));
+
+            wl_surface_commit(surface->wl_surface);
+        }
+
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (!needs_confine && surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    /* Set up (or update) pointer confinement or lock. */
+    if (needs_confine)
+    {
+        double top, left, bottom, right;
+
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.left,
+                                           client_clip_rect.top,
+                                           &left, &top);
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.right,
+                                           client_clip_rect.bottom,
+                                           &right, &bottom);
+
+        region = wl_compositor_create_region(wayland->wl_compositor);
+        wl_region_add(region, round(left), round(top),
+                      round(right - left), round(bottom - top));
+
+        if (!surface->zwp_confined_pointer_v1)
+        {
+            surface->zwp_confined_pointer_v1 =
+                zwp_pointer_constraints_v1_confine_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    region,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_confined_pointer_v1_set_region(surface->zwp_confined_pointer_v1,
+                                               region);
+        }
+
+        wl_region_destroy(region);
+    }
+    else if (needs_lock)
+    {
+        if (!surface->zwp_locked_pointer_v1)
+        {
+            surface->zwp_locked_pointer_v1 =
+                zwp_pointer_constraints_v1_lock_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    NULL,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_locked_pointer_v1_set_region(surface->zwp_locked_pointer_v1,
+                                             NULL);
+        }
+    }
+
+    if (wayland->pointer.focused_surface == surface)
+        wayland_pointer_set_relative(&wayland->pointer, needs_lock);
+
+    if (needs_confine || needs_lock)
+        wl_surface_commit(surface->wl_surface);
+
+    if (glvk)
+        wayland_surface_unref_glvk(glvk->parent);
+}
+
+static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
+                                                           struct wayland_output *output,
+                                                           int scale)
+{
+    struct wayland_surface *child;
+
+    surface->main_output = output;
+    wl_surface_set_buffer_scale(surface->wl_surface, scale);
+
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_list_for_each(child, &surface->child_list, link)
+        wayland_surface_tree_set_main_output_and_scale(child, output, scale);
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_main_output
+ *
+ * Sets the main output for a surface, i.e., the output whose scale will be
+ * used for surface scaling.
+ */
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->main_output != output)
+    {
+        wayland_surface_tree_set_main_output_and_scale(surface, output,
+                                                       output ? output->scale : 1);
+        if (surface->hwnd)
+            send_message(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_leave_output
+ *
+ * Removes an output from the set of outputs a surface is presented on.
+ *
+ * It is OK to call this function even if the surface is not presented
+ * on the specified output, in which case this function is a NOP.
+ */
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output)
+{
+    struct wayland_output_ref *ref, *tmp;
+
+    wl_list_for_each_safe(ref, tmp, &surface->output_ref_list, link)
+    {
+        if (ref->output == output)
+        {
+            wl_list_remove(&ref->link);
+            free(ref);
+            break;
+        }
+    }
+
+    if (surface->main_output == output)
+    {
+        struct wayland_output *origin =
+            wayland_surface_get_origin_output(surface);
+
+        wayland_surface_set_main_output(surface, origin);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_set_wine_output
+ *
+ * Sets the output which Wine considers to contain the window backed by this
+ * surface. Transiently, this may be different from the output Wayland
+ * considers to be the "main" one for this surface.
+ */
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output)
+{
+    /* Don't update non-toplevels or surfaces that already have a main output. */
+    if (!output || surface->parent || surface->main_output) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    wayland_surface_tree_set_main_output_and_scale(surface, output, output->scale);
+}
+
+/**********************************************************************
+ *          wayland_surface_get_buffer_scale
+ *
+ */
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
+{
+    /* Use the toplevel surface to get the scale */
+    struct wayland_surface *toplevel = surface;
+    int scale = 1;
+
+    while (toplevel->parent) toplevel = toplevel->parent;
+
+    if (surface->main_output) scale = surface->main_output->scale;
+
+    TRACE("hwnd=%p (toplevel=%p) => scale=%d\n", surface->hwnd, toplevel->hwnd, scale);
+    return scale;
+}
+
+/**********************************************************************
+ *          wayland_surface_set_title
+ */
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
+{
+    DWORD text_len;
+    DWORD utf8_count;
+    char *utf8 = NULL;
+
+    if (!surface->xdg_toplevel)
+        return;
+
+    TRACE("surface=%p hwnd=%p text='%s'\n",
+          surface, surface->hwnd, wine_dbgstr_w(text));
+
+    text_len = (lstrlenW(text) + 1) * sizeof(WCHAR);
+
+    if (!RtlUnicodeToUTF8N(NULL, 0, &utf8_count, text, text_len) &&
+        (utf8 = malloc(utf8_count)))
+    {
+        RtlUnicodeToUTF8N(utf8, utf8_count, &utf8_count, text, text_len);
+        xdg_toplevel_set_title(surface->xdg_toplevel, utf8);
+    }
+
+    free(utf8);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
new file mode 100644
index 00000000000..b234304b084
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -0,0 +1,879 @@
+/*
+ * Wayland driver
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_H
+#define __WINE_WAYLANDDRV_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <gbm.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <wayland-client.h>
+#include <wayland-cursor.h>
+#include <xkbcommon/xkbcommon.h>
+#include <xkbcommon/xkbcommon-compose.h>
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "pointer-constraints-unstable-v1-client-protocol.h"
+#include "relative-pointer-unstable-v1-client-protocol.h"
+#include "viewporter-client-protocol.h"
+#include "xdg-output-unstable-v1-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "ntuser.h"
+
+#include "unixlib.h"
+#include "wine/gdi_driver.h"
+
+#define WAYLANDDRV_CLIENT_CALL(func, params, size) waylanddrv_client_call(waylanddrv_client_func_ ## func, params, size)
+
+/**********************************************************************
+ *          Globals
+ */
+
+extern char *process_name DECLSPEC_HIDDEN;
+extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
+extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
+extern const struct user_driver_funcs waylanddrv_funcs DECLSPEC_HIDDEN;
+extern char *option_drm_device DECLSPEC_HIDDEN;
+extern enum wayland_hidpi_scaling option_hidpi_scaling DECLSPEC_HIDDEN;
+extern BOOL option_show_systray DECLSPEC_HIDDEN;
+extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
+
+/**********************************************************************
+  *          Internal messages and data
+  */
+
+enum wayland_window_message
+{
+    WM_WAYLAND_MONITOR_CHANGE = 0x80001000,
+    WM_WAYLAND_SET_CURSOR,
+    WM_WAYLAND_QUERY_SURFACE_MAPPED,
+    WM_WAYLAND_CONFIGURE,
+    WM_WAYLAND_STATE_UPDATE,
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+    WM_WAYLAND_WINDOW_SURFACE_FLUSH,
+    WM_WAYLAND_REMOTE_SURFACE,
+    WM_WAYLAND_POINTER_CONSTRAINT_UPDATE,
+    WM_WAYLAND_CLIPBOARD_WINDOW_CREATE,
+};
+
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+};
+
+enum wayland_configure_flags
+{
+    WAYLAND_CONFIGURE_FLAG_RESIZING   = (1 << 0),
+    WAYLAND_CONFIGURE_FLAG_ACTIVATED  = (1 << 1),
+    WAYLAND_CONFIGURE_FLAG_MAXIMIZED  = (1 << 2),
+    WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
+};
+
+enum wayland_remote_surface_type
+{
+    WAYLAND_REMOTE_SURFACE_TYPE_NORMAL,
+    WAYLAND_REMOTE_SURFACE_TYPE_GLVK,
+};
+
+enum wayland_remote_buffer_type
+{
+    WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+    WAYLAND_REMOTE_BUFFER_TYPE_DMABUF,
+};
+
+enum wayland_remote_buffer_commit
+{
+    WAYLAND_REMOTE_BUFFER_COMMIT_NORMAL,
+    WAYLAND_REMOTE_BUFFER_COMMIT_THROTTLED,
+    WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+};
+
+enum wayland_pointer_constraint
+{
+    WAYLAND_POINTER_CONSTRAINT_RETAIN_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP,
+    WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS,
+};
+
+enum wayland_pointer_locked_reason
+{
+    WAYLAND_POINTER_LOCKED_REASON_NONE = 0,
+    WAYLAND_POINTER_LOCKED_REASON_SET_CURSOR_POS = (1 << 0),
+    WAYLAND_POINTER_LOCKED_REASON_CLIP = (1 << 1),
+};
+
+enum wayland_hidpi_scaling
+{
+    WAYLAND_HIDPI_SCALING_APPLICATION,
+    WAYLAND_HIDPI_SCALING_COMPOSITOR,
+};
+
+/**********************************************************************
+ *          Definitions for wayland types
+ */
+
+struct wayland_surface;
+struct wayland_shm_buffer;
+
+struct wayland_mutex
+{
+    pthread_mutex_t mutex;
+    DWORD owner_tid;
+    int lock_count;
+    const char *name;
+};
+
+struct wayland_keyboard
+{
+    struct wl_keyboard *wl_keyboard;
+    struct wayland_surface *focused_surface;
+    int repeat_interval_ms;
+    int repeat_delay_ms;
+    uint32_t pressed_key;
+    uint32_t enter_serial;
+    struct xkb_context *xkb_context;
+    struct xkb_state *xkb_state;
+    struct xkb_compose_state *xkb_compose_state;
+    UINT xkb_keycode_to_vkey[256];
+    WORD xkb_keycode_to_scancode[256];
+};
+
+struct wayland_cursor
+{
+    BOOL owns_wl_buffer;
+    struct wl_buffer *wl_buffer;
+    int width;
+    int height;
+    int hotspot_x;
+    int hotspot_y;
+};
+
+struct wayland_pointer
+{
+    struct wayland *wayland;
+    struct wl_pointer *wl_pointer;
+    struct wayland_surface *focused_surface;
+    struct wl_surface *cursor_wl_surface;
+    uint32_t enter_serial;
+    struct wayland_cursor *cursor;
+    enum wayland_pointer_locked_reason locked_reason;
+    HCURSOR hcursor;
+    struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
+};
+
+struct wayland_dmabuf_format_info
+{
+    uint64_t *modifiers;
+    size_t count_modifiers;
+    BOOL scanoutable;
+};
+
+struct wayland_dmabuf_format
+{
+    uint32_t format;
+    struct wl_array modifiers;
+};
+
+struct wayland_dmabuf_feedback_tranche
+{
+    struct wl_array formats;
+    uint32_t flags;
+    dev_t device;
+};
+
+struct wayland_dmabuf_feedback_format_table_entry
+{
+    uint32_t format;
+    uint32_t padding; /* unused */
+    uint64_t modifier;
+};
+
+struct wayland_dmabuf_feedback
+{
+    dev_t main_device;
+    uint32_t format_table_size;
+    struct wayland_dmabuf_feedback_format_table_entry *format_table_entries;
+    struct wayland_dmabuf_feedback_tranche pending_tranche;
+    struct wl_array tranches;
+};
+
+struct wayland_dmabuf_surface_feedback
+{
+    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
+    struct wayland_dmabuf_feedback *feedback;
+    struct wayland_dmabuf_feedback *pending_feedback;
+    struct wayland_mutex mutex;
+    BOOL surface_needs_update;
+};
+
+struct wayland_dmabuf
+{
+    struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1;
+    uint32_t version;
+    struct wl_array formats;
+    struct wayland_dmabuf_feedback *default_feedback;
+    struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1;
+};
+
+struct wayland_data_device
+{
+    struct wayland *wayland;
+    struct wl_data_device *wl_data_device;
+    struct wl_data_offer *clipboard_wl_data_offer;
+    struct wl_data_offer *dnd_wl_data_offer;
+    uint32_t dnd_enter_serial;
+    struct wayland_surface *dnd_surface;
+    int dnd_x;
+    int dnd_y;
+};
+
+struct wayland_data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    const WCHAR *register_name;
+    /* In case of failure, 'ret_size' is left unchanged. */
+    void *(*import)(struct wayland_data_device_format *format,
+                    const void *data, size_t data_size, size_t *ret_size);
+    void (*export)(struct wayland_data_device_format *format, int fd,
+                   void *data, size_t size);
+    UINT_PTR extra;
+};
+
+struct wayland
+{
+    struct wl_list thread_link;
+    BOOL initialized;
+    DWORD process_id;
+    DWORD thread_id;
+    struct wl_display *wl_display;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_registry *wl_registry;
+    struct wl_compositor *wl_compositor;
+    struct wl_subcompositor *wl_subcompositor;
+    struct xdg_wm_base *xdg_wm_base;
+    struct wl_shm *wl_shm;
+    struct wl_seat *wl_seat;
+    struct wp_viewporter *wp_viewporter;
+    struct wl_data_device_manager *wl_data_device_manager;
+    struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
+    struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
+    struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
+    uint32_t next_fallback_output_id;
+    struct wl_list output_list;
+    struct wl_list detached_shm_buffer_list;
+    struct wl_list toplevel_list;
+    struct wayland_keyboard keyboard;
+    struct wayland_pointer pointer;
+    struct wayland_dmabuf dmabuf;
+    struct wayland_data_device data_device;
+    DWORD last_dispatch_mask;
+    uint32_t last_button_serial;
+    DWORD last_event_type;
+    int event_notification_pipe[2];
+    HWND clipboard_hwnd;
+    RECT cursor_clip;
+};
+
+struct wayland_output_mode
+{
+    struct wl_list link;
+    int32_t width;
+    int32_t height;
+    int32_t refresh;
+    int bpp;
+    BOOL native;
+};
+
+struct wayland_output
+{
+    struct wl_list link;
+    struct wayland *wayland;
+    struct wl_output *wl_output;
+    struct zxdg_output_v1 *zxdg_output_v1;
+    struct wl_list mode_list;
+    struct wayland_output_mode *current_mode;
+    struct wayland_output_mode *current_wine_mode;
+    int logical_x, logical_y;  /* logical position */
+    int logical_w, logical_h;  /* logical size */
+    int x, y;  /* position in native pixel coordinate space */
+    int scale; /* wayland output scale factor for hidpi */
+    /* Scale factor by which we need to multiply values in the wine coordinate
+     * space to get values in the wayland coordinate space for this output. Used
+     * when emulating a display mode change. */
+    double wine_scale;
+    char *name;
+    WCHAR wine_name[128];
+    uint32_t global_id;
+};
+
+struct wayland_surface_configure
+{
+    int width;
+    int height;
+    enum wayland_configure_flags configure_flags;
+    uint32_t serial;
+    BOOL processed;
+};
+
+struct wayland_output_ref
+{
+    struct wl_list link;
+    struct wayland_output *output;
+};
+
+struct wayland_surface
+{
+    struct wl_list link;
+    struct wayland *wayland;
+    struct wl_surface *wl_surface;
+    struct wl_subsurface *wl_subsurface;
+    struct xdg_surface *xdg_surface;
+    struct xdg_toplevel *xdg_toplevel;
+    struct wp_viewport *wp_viewport;
+    struct wayland_surface *parent;
+    struct wayland_surface *glvk;
+    struct wayland_dmabuf_surface_feedback *surface_feedback;
+    struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
+    struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
+    /* The offset of this surface relative to its owning win32 window */
+    int offset_x, offset_y;
+    HWND hwnd;
+    struct wayland_mutex mutex;
+    struct wayland_surface_configure pending;
+    struct wayland_surface_configure current;
+    BOOL mapped;
+    LONG ref;
+    enum wayland_surface_role role;
+    struct wl_list output_ref_list;
+    struct wayland_output *main_output;
+    BOOL drawing_allowed;
+    struct wl_list child_list;
+    BOOL window_fullscreen;
+    BOOL set_cursor_pos;
+};
+
+struct wayland_native_buffer
+{
+    int plane_count;
+    int fds[4];
+    uint32_t strides[4];
+    uint32_t offsets[4];
+    uint32_t width, height;
+    uint32_t format;
+    uint64_t modifier;
+};
+
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height, stride;
+    enum wl_shm_format format;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    HRGN damage_region;
+    BOOL detached;
+};
+
+struct wayland_dmabuf_buffer
+{
+   struct wl_list link;
+   struct wl_buffer *wl_buffer;
+   int width, height, stride;
+   uint32_t format;
+};
+
+struct wayland_buffer_queue
+{
+    struct wayland *wayland;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_list buffer_list;
+    int width;
+    int height;
+    enum wl_shm_format format;
+    HRGN damage_region;
+};
+
+struct wayland_remote_surface_proxy;
+
+/**********************************************************************
+ *          Wayland thread data
+ */
+
+struct wayland_thread_data
+{
+    struct wayland wayland;
+};
+
+extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
+
+static inline struct wayland_thread_data *wayland_thread_data(void)
+{
+    return (struct wayland_thread_data *)(UINT_PTR)NtUserGetThreadInfo()->driver_data;
+}
+
+static inline struct wayland *thread_init_wayland(void)
+{
+    return &wayland_init_thread_data()->wayland;
+}
+
+static inline struct wayland *thread_wayland(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+    if (!data) return NULL;
+    return &data->wayland;
+}
+
+/**********************************************************************
+ *          Wayland initialization
+ */
+
+BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
+BOOL wayland_init(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
+BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
+void wayland_process_release(void) DECLSPEC_HIDDEN;
+void wayland_init_display_devices(void) DECLSPEC_HIDDEN;
+void wayland_read_options_from_registry(void) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland mutex
+ */
+
+void wayland_mutex_init(struct wayland_mutex *wayland_mutex, int kind,
+                        const char *name) DECLSPEC_HIDDEN;
+void wayland_mutex_destroy(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+void wayland_mutex_lock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+void wayland_mutex_unlock(struct wayland_mutex *wayland_mutex) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland output
+ */
+
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version) DECLSPEC_HIDDEN;
+void wayland_output_destroy(struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_notify_wine_monitor_change(void) DECLSPEC_HIDDEN;
+void wayland_update_outputs_from_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name) DECLSPEC_HIDDEN;
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland, uint32_t id) DECLSPEC_HIDDEN;
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  struct wayland_output_mode *ref_mode) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland event dispatch
+ */
+
+int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
+BOOL wayland_read_events_and_dispatch_process(void) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland surface
+ */
+
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent) DECLSPEC_HIDDEN;
+void wayland_surface_clear_role(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags) DECLSPEC_HIDDEN;
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region) DECLSPEC_HIDDEN;
+void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int x, int y) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int x, int y, int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
+                                      int width, int height) DECLSPEC_HIDDEN;
+void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y) DECLSPEC_HIDDEN;
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y) DECLSPEC_HIDDEN;
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height) DECLSPEC_HIDDEN;
+void wayland_surface_ensure_mapped(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_update_pointer_constraint(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output) DECLSPEC_HIDDEN;
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland native buffer
+ */
+
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format) DECLSPEC_HIDDEN;
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo) DECLSPEC_HIDDEN;
+void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland SHM buffer
+ */
+
+struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                 struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage) DECLSPEC_HIDDEN;
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland dmabuf
+ */
+
+void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
+                         struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1) DECLSPEC_HIDDEN;
+void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_is_format_supported(struct wayland_dmabuf *dmabuf, uint32_t format, dev_t render_dev) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_get_default_format_info(struct wayland_dmabuf *dmabuf, uint32_t drm_format,
+                                            dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_has_feedback_support(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_feedback_get_format_info(struct wayland_dmabuf_feedback *feedback, uint32_t drm_format,
+                                             dev_t render_dev, struct wayland_dmabuf_format_info *format_info) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
+                                                                       struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
+void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_dmabuf_buffer_steal_wl_buffer_and_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_surface_feedback *wayland_dmabuf_surface_feedback_create(struct wayland_dmabuf *dmabuf,
+                                                                               struct wl_surface *wl_surface) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_destroy(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_lock(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+void wayland_dmabuf_surface_feedback_unlock(struct wayland_dmabuf_surface_feedback *surface_feedback) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland buffer queue
+ */
+
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int heigh,
+                                                         enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage) DECLSPEC_HIDDEN;
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland window surface
+ */
+
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha) DECLSPEC_HIDDEN;
+void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPEC_HIDDEN;
+BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
+                                                   struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height)) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland Keyboard
+ */
+
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland Pointer/Cursor
+ */
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
+void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative) DECLSPEC_HIDDEN;
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
+void wayland_cursor_theme_init(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle) DECLSPEC_HIDDEN;
+BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
+void wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          GBM support
+ */
+
+BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
+dev_t wayland_gbm_get_render_dev(void) DECLSPEC_HIDDEN;
+struct gbm_surface *wayland_gbm_create_surface(uint32_t drm_format, int width, int height,
+                                               size_t count_modifiers, uint64_t *modifiers,
+                                               BOOL format_is_scanoutable) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          OpenGL support
+ */
+
+void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_destroy_gl_drawable(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height)) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Vulkan support
+ */
+
+void wayland_invalidate_vulkan_objects(HWND hwnd) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_data_device_deinit(struct wayland_data_device *data_device) DECLSPEC_HIDDEN;
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland) DECLSPEC_HIDDEN;
+void wayland_data_device_init_formats(void) DECLSPEC_HIDDEN;
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime) DECLSPEC_HIDDEN;
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                                   struct wl_array *mimes) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Registry helpers
+ */
+
+HKEY reg_open_key_a(HKEY root, const char *name) DECLSPEC_HIDDEN;
+HKEY reg_open_key_w(HKEY root, const WCHAR *nameW) DECLSPEC_HIDDEN;
+HKEY reg_open_hkcu_key_a(const char *name) DECLSPEC_HIDDEN;
+DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
+                      DWORD *buffer_len) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          XKB helpers
+ */
+
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state) DECLSPEC_HIDDEN;
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Wayland remote (cross-process) rendering
+ */
+
+void wayland_remote_surface_handle_message(struct wayland_surface *wayland_surface,
+                                           WPARAM message, LPARAM params) DECLSPEC_HIDDEN;
+void wayland_destroy_remote_surfaces(HWND hwnd) DECLSPEC_HIDDEN;
+struct wayland_remote_surface_proxy *wayland_remote_surface_proxy_create(HWND hwnd,
+                                                                         enum wayland_remote_surface_type type) DECLSPEC_HIDDEN;
+void wayland_remote_surface_proxy_destroy(struct wayland_remote_surface_proxy *proxy) DECLSPEC_HIDDEN;
+BOOL wayland_remote_surface_proxy_commit(struct wayland_remote_surface_proxy *proxy,
+                                         struct wayland_native_buffer *native,
+                                         enum wayland_remote_buffer_type buffer_type,
+                                         enum wayland_remote_buffer_commit commit,
+                                         HANDLE *buffer_released_event,
+                                         HANDLE *throttle_event) DECLSPEC_HIDDEN;
+BOOL wayland_remote_surface_proxy_dispatch_events(struct wayland_remote_surface_proxy *proxy) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          Misc. helpers
+ */
+
+size_t ascii_to_unicode_maybe_z(WCHAR *dst, size_t dst_max_chars,
+                                const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+size_t unicode_to_ascii_maybe_z(char *dst, size_t dst_max_chars,
+                                const WCHAR *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
+                          const char *src, size_t src_max_chars) DECLSPEC_HIDDEN;
+int wayland_shmfd_create(const char *name, int size) DECLSPEC_HIDDEN;
+void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect) DECLSPEC_HIDDEN;
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels, int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          USER32 helpers
+ */
+
+static inline LRESULT send_message(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserSendDriverMessage, FALSE);
+}
+
+static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+                                           UINT flags, UINT timeout, PDWORD_PTR res_ptr)
+{
+    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
+    LRESULT res = NtUserMessageCall(hwnd, msg, wparam, lparam, &params,
+                                    NtUserSendMessageTimeout, FALSE);
+    if (res_ptr) *res_ptr = res;
+    return params.result;
+}
+
+static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
+{
+    dst->left = max(src1->left, src2->left);
+    dst->top = max(src1->top, src2->top);
+    dst->right = min(src1->right, src2->right);
+    dst->bottom = min(src1->bottom, src2->bottom);
+    return !IsRectEmpty(dst);
+}
+
+static inline BOOL contains_rect(RECT *outer, const RECT *inner)
+{
+    POINT tl = {inner->left, inner->top};
+    POINT br = {inner->right - 1, inner->bottom - 1};
+    return PtInRect(outer, tl) && PtInRect(outer, br);
+}
+
+static inline BOOL union_rect(RECT *dst, const RECT *src1, const RECT *src2)
+{
+    if (IsRectEmpty(src1)) *dst = *src2;
+    else if (IsRectEmpty(src2)) *dst = *src1;
+    else
+    {
+        dst->left = min(src1->left, src2->left);
+        dst->top = min(src1->top, src2->top);
+        dst->right = max(src1->right, src2->right);
+        dst->bottom = max(src1->bottom, src2->bottom);
+    }
+    return !IsRectEmpty(dst);
+}
+
+static inline HWND get_focus(void)
+{
+    GUITHREADINFO info;
+    info.cbSize = sizeof(info);
+    return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndFocus : 0;
+}
+
+/**********************************************************************
+ *          PE/unixlib support
+ */
+
+NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
+                                ULONG size) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_clipboard_message(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_accept_format(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_enum_formats(void *arg) DECLSPEC_HIDDEN;
+NTSTATUS waylanddrv_unix_data_offer_import_format(void *arg) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          USER driver functions
+ */
+
+LONG WAYLAND_ChangeDisplaySettings(LPDEVMODEW devmode, HWND hwnd, DWORD flags,
+                                   LPVOID lpvoid) DECLSPEC_HIDDEN;
+BOOL WAYLAND_ClipCursor(const RECT *clip) DECLSPEC_HIDDEN;
+BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
+BOOL WAYLAND_GetCurrentDisplaySettings(LPCWSTR name, LPDEVMODEW devmode) DECLSPEC_HIDDEN;
+INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECLSPEC_HIDDEN;
+NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                             const LARGE_INTEGER *timeout,
+                                             DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
+void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+BOOL WAYLAND_SetCursorPos(int x, int y) DECLSPEC_HIDDEN;
+void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
+INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                        LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect) DECLSPEC_HIDDEN;
+SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
+LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface) DECLSPEC_HIDDEN;
+BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                               const RECT *window_rect, const RECT *client_rect,
+                               RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
+const struct vulkan_funcs *WAYLAND_wine_get_vulkan_driver(UINT version) DECLSPEC_HIDDEN;
+struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
+
+/**********************************************************************
+ *          GDI driver functions
+ */
+
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData) DECLSPEC_HIDDEN;
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_dll.h b/dlls/winewayland.drv/waylanddrv_dll.h
new file mode 100644
index 00000000000..21a61898db3
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_dll.h
@@ -0,0 +1,37 @@
+/*
+ * Wayland driver DLL definitions
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_DLL_H
+#define __WINE_WAYLANDDRV_DLL_H
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+
+#include "unixlib.h"
+
+extern unixlib_handle_t waylanddrv_handle DECLSPEC_HIDDEN;
+#define WAYLANDDRV_UNIX_CALL(func, params) __wine_unix_call(waylanddrv_handle, waylanddrv_unix_func_ ## func, params)
+extern BOOL option_show_systray DECLSPEC_HIDDEN;
+
+NTSTATUS WINAPI waylanddrv_client_create_clipboard_window(void *arg, ULONG size);
+NTSTATUS WINAPI waylanddrv_client_dnd(void *params, ULONG size);
+
+#endif /* __WINE_WAYLANDDRV_DLL_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
new file mode 100644
index 00000000000..318c0c28c8f
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -0,0 +1,248 @@
+/*
+ * WAYLANDDRV initialization code
+ *
+ * Copyright 2020 Alexandre Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+
+char *process_name = NULL;
+
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        NtTerminateProcess(0, 1);
+    }
+
+    NtClose(handle);
+}
+
+/***********************************************************************
+ *           Initialize per thread data
+ */
+struct wayland_thread_data *wayland_init_thread_data(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data) return data;
+
+    if (!(data = calloc(1, sizeof(*data))))
+    {
+        ERR("could not create data\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    if (!wayland_init(&data->wayland))
+    {
+        ERR_(winediag)("waylanddrv: Can't open wayland display. Please ensure "
+                       "that your wayland server is running and that "
+                       "$WAYLAND_DISPLAY is set correctly.\n");
+        NtTerminateProcess(0, 1);
+    }
+
+    set_queue_fd(&data->wayland);
+    NtUserGetThreadInfo()->driver_data = (UINT_PTR)data;
+
+    /* Create the clipboard window outside of thread init. We delay window
+     * creation since the thread init function may be invoked from within the
+     * context of a user32 function which holds the internal Wine user32 lock.
+     * In such a case creating the clipboard window would cause an internal
+     * user32 lock error. */
+    NtUserPostThreadMessage(data->wayland.thread_id,
+                            WM_WAYLAND_CLIPBOARD_WINDOW_CREATE, 0, 0);
+
+    return data;
+}
+
+/***********************************************************************
+ *           ThreadDetach (WAYLAND.@)
+ */
+static void WAYLAND_ThreadDetach(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data)
+    {
+        wayland_deinit(&data->wayland);
+        free(data);
+        /* clear data in case we get re-entered from user32 before the thread is truly dead */
+        NtUserGetThreadInfo()->driver_data = 0;
+    }
+}
+
+const struct user_driver_funcs waylanddrv_funcs =
+{
+    .dc_funcs.pCreateDC = WAYLAND_CreateDC,
+    .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
+    .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.pPutImage = WAYLAND_PutImage,
+    .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
+
+    .pChangeDisplaySettings = WAYLAND_ChangeDisplaySettings,
+    .pClipCursor = WAYLAND_ClipCursor,
+    .pCreateWindow = WAYLAND_CreateWindow,
+    .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
+    .pDestroyWindow = WAYLAND_DestroyWindow,
+    .pGetCurrentDisplaySettings = WAYLAND_GetCurrentDisplaySettings,
+    .pGetKeyNameText = WAYLAND_GetKeyNameText,
+    .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
+    .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
+    .pSetCursorPos = WAYLAND_SetCursorPos,
+    .pSetCursor = WAYLAND_SetCursor,
+    .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
+    .pSetWindowRgn = WAYLAND_SetWindowRgn,
+    .pSetWindowStyle = WAYLAND_SetWindowStyle,
+    .pSetWindowText = WAYLAND_SetWindowText,
+    .pShowWindow = WAYLAND_ShowWindow,
+    .pSysCommand = WAYLAND_SysCommand,
+    .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pUpdateLayeredWindow = WAYLAND_UpdateLayeredWindow,
+    .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
+    .pThreadDetach = WAYLAND_ThreadDetach,
+    .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
+    .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanged = WAYLAND_WindowPosChanged,
+    .pWindowPosChanging = WAYLAND_WindowPosChanging,
+    .pwine_get_vulkan_driver = WAYLAND_wine_get_vulkan_driver,
+    .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
+};
+
+static const struct user_driver_funcs null_funcs = { 0 };
+
+static void wayland_init_process_name(void)
+{
+    WCHAR *p, *appname;
+    WCHAR appname_lower[MAX_PATH];
+    DWORD appname_len;
+    DWORD appnamez_size;
+    DWORD utf8_size;
+    int i;
+
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    appname_len = lstrlenW(appname);
+
+    if (appname_len == 0 || appname_len >= MAX_PATH) return;
+
+    for (i = 0; appname[i]; i++) appname_lower[i] = RtlDowncaseUnicodeChar(appname[i]);
+    appname_lower[i] = 0;
+
+    appnamez_size = (appname_len + 1) * sizeof(WCHAR);
+
+    if (!RtlUnicodeToUTF8N(NULL, 0, &utf8_size, appname_lower, appnamez_size) &&
+        (process_name = malloc(utf8_size)))
+    {
+        RtlUnicodeToUTF8N(process_name, utf8_size, &utf8_size, appname_lower, appnamez_size);
+    }
+}
+
+static NTSTATUS waylanddrv_unix_init(void *arg)
+{
+    struct waylanddrv_unix_init_params *params = arg;
+
+    /* Set the user driver functions now so that they are available during
+     * our initialization. We clear them on error. */
+    __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
+
+    wayland_init_process_name();
+
+    wayland_read_options_from_registry();
+
+    wayland_data_device_init_formats();
+
+    if (!wayland_init_set_cursor()) goto err;
+
+    if (!wayland_process_init()) goto err;
+
+    params->option_show_systray = option_show_systray;
+
+    return 0;
+
+err:
+    __wine_set_user_driver(&null_funcs, WINE_GDI_DRIVER_VERSION);
+    return STATUS_UNSUCCESSFUL;
+}
+
+static NTSTATUS waylanddrv_unix_read_events(void *arg)
+{
+    while (wayland_read_events_and_dispatch_process()) continue;
+    /* This function only returns on a fatal error, e.g., if our connection
+     * to the Wayland server is lost. */
+    return STATUS_UNSUCCESSFUL;
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    waylanddrv_unix_init,
+    waylanddrv_unix_read_events,
+    waylanddrv_unix_clipboard_message,
+    waylanddrv_unix_data_offer_accept_format,
+    waylanddrv_unix_data_offer_enum_formats,
+    waylanddrv_unix_data_offer_import_format,
+};
+
+C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
+
+/***********************************************************************
+ *           waylanddrv_client_call
+ */
+NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *params,
+                                ULONG size)
+{
+    void *ret_ptr;
+    ULONG ret_len;
+    return KeUserModeCallback(func, params, size, &ret_ptr, &ret_len);
+}
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
new file mode 100644
index 00000000000..53b2a181e26
--- /dev/null
+++ b/dlls/winewayland.drv/window.c
@@ -0,0 +1,1785 @@
+/*
+ * Window related functions
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntgdi.h"
+#include "ntuser.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+#include <limits.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* private window data */
+struct wayland_win_data
+{
+    /* hwnd that this private data belongs to */
+    HWND           hwnd;
+    /* parent hwnd for child windows */
+    HWND           parent;
+    /* effective parent hwnd (what the driver considers to
+     * be the parent for relative positioning) */
+    HWND           effective_parent;
+    /* USER window rectangle relative to parent */
+    RECT           window_rect;
+    /* client area relative to parent */
+    RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* wine window_surface backing this window */
+    struct window_surface *window_surface;
+    /* pending wine window_surface for this window */
+    struct window_surface *pending_window_surface;
+    /* whether the pending_window_surface value is valid */
+    BOOL           has_pending_window_surface;
+    /* whether this window is currently being resized */
+    BOOL           resizing;
+    /* the window_rect this window should be restored to after unmaximizing */
+    RECT           restore_rect;
+    /* whether the window is currently fullscreen */
+    BOOL           fullscreen;
+    /* whether the window is currently maximized */
+    BOOL           maximized;
+    /* whether we are currently handling a wayland configure event */
+    BOOL           handling_wayland_configure_event;
+    /* the configure flags for the configure event we are handling */
+    enum wayland_configure_flags wayland_configure_event_flags;
+    /* whether this window is visible */
+    BOOL           visible;
+    /* Save previous state to be able to decide when to recreate wayland surface */
+    HWND           old_parent;
+    RECT           old_window_rect;
+    /* whether a wayland surface update is needed */
+    BOOL           wayland_surface_needs_update;
+    /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
+    BOOL           pending_state_update_message;
+    /* The serial of the next expected WM_WAYLAND_SURFACE_OUTPUT_CHANGE message */
+    UINT           pending_surface_output_change_serial;
+};
+
+static struct wayland_mutex win_data_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": win_data_mutex"
+};
+
+static struct wayland_win_data *win_data_context[32768];
+
+static inline int context_idx(HWND hwnd)
+{
+    return LOWORD(hwnd) >> 1;
+}
+
+/***********************************************************************
+ *           wayland_win_data_destroy
+ */
+static void wayland_win_data_destroy(struct wayland_win_data *data)
+{
+    TRACE("hwnd=%p\n", data->hwnd);
+    win_data_context[context_idx(data->hwnd)] = NULL;
+
+    if (data->has_pending_window_surface && data->pending_window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->pending_window_surface, NULL);
+        window_surface_release(data->pending_window_surface);
+    }
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+        window_surface_release(data->window_surface);
+    }
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
+    free(data);
+
+    wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+static struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    if (!hwnd) return NULL;
+
+    wayland_mutex_lock(&win_data_mutex);
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data;
+    wayland_mutex_unlock(&win_data_mutex);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_release
+ *
+ * Release the data returned by wayland_win_data_get.
+ */
+static void wayland_win_data_release(struct wayland_win_data *data)
+{
+    if (data) wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_win_data_create
+ *
+ * Create a data window structure for an existing window.
+ */
+static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    HWND parent;
+
+    /* Don't create win data for desktop or HWND_MESSAGE windows. */
+    if (!(parent = NtUserGetAncestor(hwnd, GA_PARENT))) return NULL;
+    if (parent != NtUserGetDesktopWindow() && !NtUserGetAncestor(parent, GA_PARENT))
+        return NULL;
+
+    if (!(data = calloc(1, sizeof(*data))))
+        return NULL;
+
+    data->hwnd = hwnd;
+    data->wayland_surface_needs_update = TRUE;
+
+    wayland_mutex_lock(&win_data_mutex);
+    win_data_context[context_idx(hwnd)] = data;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    return data;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_lock
+ *
+ *  Gets the wayland surface for HWND while locking the private window data.
+ */
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+
+    if (data && data->wayland_surface)
+        return data->wayland_surface;
+
+    wayland_win_data_release(data);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlock
+ */
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+{
+    if (surface) wayland_mutex_unlock(&win_data_mutex);
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlocked
+ *
+ * Helper function to get the wayland_surface for a HWND without any locking.
+ * The caller should ensure that win_data_mutex has been locked before this
+ * operation, and for as long as the association between the HWND and the
+ * returned wayland_surface needs to remain valid.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_unlocked(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    assert(win_data_mutex.owner_tid == GetCurrentThreadId());
+
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data->wayland_surface;
+
+    return NULL;
+}
+
+static BOOL can_be_effective_parent(HWND hwnd, HWND parent_hwnd)
+{
+    struct wayland_surface *surface, *parent_surface;
+
+    if (parent_hwnd == 0)
+        return FALSE;
+
+    if (parent_hwnd == hwnd)
+    {
+        TRACE("hwnd=%p can't use parent=%p since it's itself\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (!(parent_surface = wayland_surface_for_hwnd_unlocked(parent_hwnd)))
+    {
+        TRACE("hwnd=%p can't use parent=%p since we are not tracking it\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (NtUserGetAncestor(hwnd, GA_PARENT) != parent_hwnd &&
+        !(NtUserGetWindowLongW(parent_hwnd, GWL_STYLE) & WS_VISIBLE))
+    {
+        TRACE("hwnd=%p (non-child) can't use parent=%p since it's not visible\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    surface = wayland_surface_for_hwnd_unlocked(hwnd);
+    parent_surface = parent_surface->parent;
+    while (parent_surface)
+    {
+        if (surface == parent_surface)
+        {
+            TRACE("hwnd=%p can't use parent=%p since hwnd is an effective ancestor\n",
+                  hwnd, parent_hwnd);
+            return FALSE;
+        }
+        parent_surface = parent_surface->parent;
+    }
+
+    return TRUE;
+}
+
+static HWND guess_popup_parent(struct wayland *wayland, HWND hwnd)
+{
+    HWND pointer_hwnd;
+    HWND cursor_hwnd;
+    HWND keyboard_hwnd;
+    HWND focus_hwnd;
+    HWND popup_hwnd;
+    POINT cursor;
+
+    pointer_hwnd = wayland->pointer.focused_surface ?
+                   wayland->pointer.focused_surface->hwnd : NULL;
+    if (pointer_hwnd)
+        pointer_hwnd = NtUserGetAncestor(pointer_hwnd, GA_ROOT);
+
+    NtUserGetCursorPos(&cursor);
+    cursor_hwnd = NtUserWindowFromPoint(cursor.x, cursor.y);
+    if (cursor_hwnd)
+        cursor_hwnd = NtUserGetAncestor(cursor_hwnd, GA_ROOT);
+
+    keyboard_hwnd = wayland->keyboard.focused_surface ?
+                    wayland->keyboard.focused_surface->hwnd : NULL;
+    if (keyboard_hwnd)
+        keyboard_hwnd = NtUserGetAncestor(keyboard_hwnd, GA_ROOT);
+
+    focus_hwnd = get_focus();
+    if (focus_hwnd)
+        focus_hwnd = NtUserGetAncestor(focus_hwnd, GA_ROOT);
+
+    TRACE("pointer_hwnd=%p cursor_hwnd=%p keyboard_hwnd=%p focus_hwnd=%p "
+          "last_event_type=%d\n",
+          pointer_hwnd, cursor_hwnd, keyboard_hwnd, focus_hwnd,
+          wayland->last_event_type);
+
+    /* If we have a recent mouse event, the popup parent is likely the window
+     * under the cursor, so prefer it. Otherwise prefer the window with
+     * the keyboard focus. */
+    if (wayland->last_event_type == INPUT_MOUSE)
+    {
+        if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+    else
+    {
+        if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+
+    TRACE("=> popup_hwnd=%p\n", popup_hwnd);
+
+    return popup_hwnd;
+}
+
+/* Whether we consider this window to be a transient popup, so we can
+ * display it as a Wayland subsurface with relative positioning. */
+static BOOL wayland_win_data_can_be_popup(struct wayland_win_data *data)
+{
+    DWORD style;
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    double monitor_width;
+    double monitor_height;
+    int window_width;
+    int window_height;
+
+    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Child windows can't be popups, unless they are children of the desktop
+     * (thus effectively top-level). */
+    if ((style & WS_CHILD) && NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT))
+    {
+        TRACE("hwnd=%p is child => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* Minimized windows can't be popups. */
+    if (style & WS_MINIMIZE)
+    {
+        TRACE("hwnd=%p is minimized => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* If the window has top bar elements, don't consider it a popup candidate. */
+    if ((style & WS_CAPTION) == WS_CAPTION ||
+        (style & (WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)))
+    {
+        TRACE("hwnd=%p style=0x%08x => FALSE\n", data->hwnd, style);
+        return FALSE;
+    }
+
+    mi.cbSize = sizeof(mi);
+    if (!(hmonitor = NtUserMonitorFromRect(&data->window_rect, MONITOR_DEFAULTTOPRIMARY)) ||
+        !NtUserGetMonitorInfo(hmonitor, &mi))
+    {
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    monitor_width = mi.rcMonitor.right - mi.rcMonitor.left;
+    monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
+    window_width = data->window_rect.right - data->window_rect.left;
+    window_height = data->window_rect.bottom - data->window_rect.top;
+
+    /* If the window has an unreasonably small size or is too large, don't consider
+     * it a popup candidate. */
+    if (window_width <= 1 || window_height <= 1 ||
+        window_width * window_height > 0.5 * monitor_width * monitor_height)
+    {
+        TRACE("hwnd=%p window=%s monitor=%s => FALSE\n",
+              data->hwnd, wine_dbgstr_rect(&data->window_rect),
+              wine_dbgstr_rect(&mi.rcMonitor));
+        return FALSE;
+    }
+
+    TRACE("hwnd=%p style=0x%08x window=%s monitor=%s => TRUE\n",
+          data->hwnd, style, wine_dbgstr_rect(&data->window_rect),
+          wine_dbgstr_rect(&mi.rcMonitor));
+
+    return TRUE;
+}
+
+static HWND wayland_win_data_get_effective_parent(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_init_wayland();
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    HWND parent_hwnd = (HWND)NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    HWND effective_parent_hwnd;
+
+    if (!can_be_effective_parent(data->hwnd, parent_hwnd))
+        parent_hwnd = 0;
+
+    /* Many applications use top level, unowned (or owned by the desktop)
+     * popup windows for menus and tooltips and depend on screen
+     * coordinates for correct positioning. Since wayland can't deal with
+     * screen coordinates, try to guess the effective parent window of such
+     * popups and manage them as wayland subsurfaces. */
+    if (!parent_hwnd && wayland_win_data_can_be_popup(data))
+        effective_parent_hwnd = guess_popup_parent(wayland, data->hwnd);
+    else
+        effective_parent_hwnd = parent_hwnd;
+
+    TRACE("hwnd=%p parent=%p effective_parent=%p\n",
+          data->hwnd, parent_hwnd, effective_parent_hwnd);
+
+    return effective_parent_hwnd;
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_update)
+        return TRUE;
+
+    /* Change of parentage (either actual or effective) requires recreating the
+     * whole win_data to ensure we have a properly owned wayland surface. We
+     * check for change of effective parent only if the window changed in any
+     * way, to avoid spuriously reassigning parent windows when new windows
+     * are created. */
+    if ((!EqualRect(&data->window_rect, &data->old_window_rect) &&
+         data->effective_parent != wayland_win_data_get_effective_parent(data)) ||
+        data->parent != data->old_parent)
+    {
+        return TRUE;
+    }
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct wayland_surface *update_surface_for_role(struct wayland_win_data *data,
+                                                       enum wayland_surface_role role,
+                                                       struct wayland *wayland,
+                                                       struct wayland_surface *parent_surface)
+{
+    struct wayland_surface *surface = data->wayland_surface;
+
+    if (!surface ||
+        (role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != role))
+    {
+        surface = wayland_surface_create_plain(wayland);
+        if (surface) wayland_mutex_lock(&surface->mutex);
+    }
+    else
+    {
+        /* Lock the wayland surface to avoid other threads interacting with it
+         * while we are updating. */
+        wayland_mutex_lock(&surface->mutex);
+        wayland_surface_clear_role(surface);
+        /* Clear the associated HWND, to allow a potential invocation of
+         * wayland_surface_make_toplevel below, to properly handle the
+         * initial configure event. */
+        surface->hwnd = 0;
+    }
+
+    if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
+        wayland_surface_make_toplevel(surface, parent_surface);
+    else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        wayland_surface_make_subsurface(surface, parent_surface);
+
+    surface->hwnd = data->hwnd;
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    return surface;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_wayland();
+    HWND effective_parent_hwnd;
+    struct wayland_surface *surface;
+    struct wayland_surface *parent_surface;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_update = FALSE;
+
+    effective_parent_hwnd = wayland_win_data_get_effective_parent(data);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+        parent_surface = wayland_surface_for_hwnd_unlocked(effective_parent_hwnd);
+
+    data->effective_parent = effective_parent_hwnd;
+
+    /* Reset window state, so that it can be properly applied again. */
+    data->maximized = FALSE;
+    data->fullscreen = FALSE;
+
+    /* Use wayland subsurfaces for children windows and toplevels that we
+     * consider to be popups and have an effective parent. Otherwise, if the
+     * window is visible make it wayland toplevel. Finally, if the window is
+     * not visible create a plain (without a role) surface to avoid polluting
+     * the compositor with empty xdg_toplevels. */
+    if (parent_surface && (data->parent || wayland_win_data_can_be_popup(data)))
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
+                                          wayland, parent_surface);
+    }
+    else if (data->visible)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_TOPLEVEL,
+                                          wayland, parent_surface);
+    }
+    else
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_NONE,
+                                          wayland, parent_surface);
+    }
+
+    if (surface && surface->xdg_toplevel)
+    {
+        WCHAR text[1024];
+        if (!NtUserInternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text)))
+            text[0] = 0;
+        wayland_surface_set_title(data->wayland_surface, text);
+    }
+
+    if (data->wayland_surface != surface)
+    {
+        if (data->wayland_surface)
+        {
+            struct wayland_surface *child;
+
+            /* Dependent Wayland surfaces require an update, so that they point
+             * to the updated surface. */
+            wayland_mutex_lock(&data->wayland_surface->mutex);
+            wl_list_for_each(child, &data->wayland_surface->child_list, link)
+            {
+                struct wayland_win_data *child_data;
+                /* Don't handle glvk subsurfaces here, they are updated specially
+                 * below. */
+                if (child != data->wayland_surface->glvk &&
+                    (child_data = wayland_win_data_get(child->hwnd)))
+                {
+                    child_data->wayland_surface_needs_update = TRUE;
+                    wayland_win_data_release(child_data);
+                }
+            }
+            wayland_mutex_unlock(&data->wayland_surface->mutex);
+
+            wayland_surface_unref(data->wayland_surface);
+        }
+
+        data->wayland_surface = surface;
+
+        wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
+        /* Force client to recreate any Vulkan objects so that we use the updated
+         * backing Wayland surface in our internal Vulkan representations. */
+        wayland_invalidate_vulkan_objects(data->hwnd);
+    }
+}
+
+static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *data)
+{
+    int wayland_width, wayland_height;
+    BOOL compat_with_current = FALSE;
+    BOOL compat_with_pending = FALSE;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    enum wayland_configure_flags conf_flags = 0;
+    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    HMONITOR hmonitor;
+    MONITORINFOEXW mi;
+    struct wayland_output *output;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        output = wayland_output_get_by_wine_name(wsurface->wayland, mi.szDevice);
+    }
+    else
+    {
+        output = NULL;
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d handling_event=%d\n",
+          data->hwnd, width, height,
+          mi.rcMonitor.right - mi.rcMonitor.left,
+          mi.rcMonitor.bottom - mi.rcMonitor.top,
+          data->maximized, data->fullscreen, data->handling_wayland_configure_event);
+
+    wayland_surface_set_wine_output(data->wayland_surface, output);
+
+    /* If we are currently handling a wayland configure event (i.e., we are
+     * being called through handle_wm_wayland_configure() -> SetWindowPos()),
+     * use the event configure flags directly. Otherwise try to infer the flags
+     * from the window style and rectangle. */
+    if (data->handling_wayland_configure_event)
+    {
+        conf_flags = data->wayland_configure_event_flags;
+    }
+    else
+    {
+        /* Set the wayland fullscreen state if the window rect covers the
+         * current monitor. Note that we set/maintain the fullscreen
+         * wayland state, even if the window style is also maximized. */
+        if (contains_rect(&data->window_rect, &mi.rcMonitor) &&
+            !(style & (WS_MINIMIZE|WS_CAPTION)))
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        }
+        if (style & WS_MAXIMIZE)
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        }
+    }
+
+    /* First do all state unsettings, before setting new state. Some wayland
+     * compositors misbehave if the order is reversed. */
+    if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
+        data->maximized = FALSE;
+    }
+
+    if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
+        data->fullscreen = FALSE;
+    }
+
+    if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
+        data->maximized = TRUE;
+    }
+
+   /* Set the fullscreen state after the maximized state on the wayland surface
+    * to ensure compositors apply the final fullscreen state properly. */
+    if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        if (!data->handling_wayland_configure_event)
+        {
+            xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
+                                        output ? output->wl_output : NULL);
+        }
+        data->fullscreen = TRUE;
+    }
+
+    if (!(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        !(style & WS_MINIMIZE))
+    {
+        data->restore_rect = data->window_rect;
+        TRACE("setting hwnd=%p restore_rect=%s\n",
+              data->hwnd, wine_dbgstr_rect(&data->restore_rect));
+    }
+
+    /* Mark in the surface whether the associated window is fullscreen. */
+    wsurface->window_fullscreen = data->fullscreen;
+
+    TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
+          data->hwnd, data->maximized, data->fullscreen);
+
+    wayland_surface_coords_rounded_from_wine(wsurface, width, height,
+                                             &wayland_width, &wayland_height);
+
+    if (wsurface->current.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->current,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_current = TRUE;
+    }
+
+    if (wsurface->pending.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->pending,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_pending = TRUE;
+    }
+
+    TRACE("current conf serial=%d size=%dx%d flags=%#x\n compat=%d\n",
+          wsurface->current.serial, wsurface->current.width,
+          wsurface->current.height, wsurface->current.configure_flags,
+          compat_with_current);
+    TRACE("pending conf serial=%d size=%dx%d flags=%#x compat=%d\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          compat_with_pending);
+
+    /* Only update the wayland surface state to match the window
+     * configuration if the surface can accept the new config, in order to
+     * avoid transient states that may cause glitches. */
+    if (!compat_with_pending && !compat_with_current)
+    {
+        TRACE("hwnd=%p window state not compatible with current or "
+              "pending wayland surface configuration\n", data->hwnd);
+        wsurface->drawing_allowed = FALSE;
+        return FALSE;
+    }
+
+    if (compat_with_pending)
+        wayland_surface_ack_pending_configure(wsurface);
+
+    return TRUE;
+}
+
+static void wayland_win_data_get_rect_in_monitor(struct wayland_win_data *data,
+                                                 enum wayland_configure_flags flags,
+                                                 RECT *rect)
+{
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    RECT *area = NULL;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+            area = &mi.rcMonitor;
+        else if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+            area = &mi.rcWork;
+    }
+
+    if (area)
+    {
+        intersect_rect(rect, area, &data->window_rect);
+        OffsetRect(rect, -data->window_rect.left, -data->window_rect.top);
+    }
+    else
+    {
+        SetRectEmpty(rect);
+    }
+}
+
+static void wayland_win_data_get_compatible_rect(struct wayland_win_data *data,
+                                                 RECT *rect)
+{
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    int wine_conf_width, wine_conf_height;
+    enum wayland_configure_flags conf_flags =
+        data->wayland_surface->current.configure_flags;
+
+    /* Get the window size corresponding to the Wayland surfaces configuration. */
+    wayland_surface_coords_to_wine(data->wayland_surface,
+                                   data->wayland_surface->current.width,
+                                   data->wayland_surface->current.height,
+                                   &wine_conf_width,
+                                   &wine_conf_height);
+
+    /* If Wayland requires a surface size smaller than what wine provides,
+     * use part of the window contents for the surface. */
+    if (((conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+         (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        (width > wine_conf_width || height > wine_conf_height))
+    {
+        wayland_win_data_get_rect_in_monitor(data, conf_flags, rect);
+        /* If the window rect in the monitor is smaller than required
+         * fall back to an appropriately sized rect at the top-left. */
+        if (rect->right - rect->left < wine_conf_width ||
+            rect->bottom - rect->top < wine_conf_height)
+        {
+            SetRect(rect, 0, 0, wine_conf_width, wine_conf_height);
+        }
+        else
+        {
+            rect->right = min(rect->right, rect->left + wine_conf_width);
+            rect->bottom = min(rect->bottom, rect->top + wine_conf_height);
+        }
+        TRACE("Window is too large for wayland state, using subarea\n");
+    }
+    else
+    {
+        SetRect(rect, 0, 0, width, height);
+    }
+}
+
+static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
+{
+    RECT screen_rect;
+    RECT parent_screen_rect;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    TRACE("hwnd=%p window=%dx%d style=0x%x\n", data->hwnd, width, height, style);
+
+    if (!(style & WS_VISIBLE))
+    {
+        wayland_surface_unmap(wsurface);
+        return;
+    }
+
+    /* Lock the wayland surface to avoid commits from other threads while we
+     * are setting up the new state. */
+    wayland_mutex_lock(&wsurface->mutex);
+
+    if (wsurface->xdg_toplevel &&
+        !wayland_win_data_update_wayland_xdg_state(data))
+    {
+        wayland_mutex_unlock(&wsurface->mutex);
+        return;
+    }
+
+    wayland_surface_reconfigure_size(wsurface, width, height);
+
+    if (wsurface->wl_subsurface)
+    {
+        /* In addition to children windows, we manage some top level, popup window
+         * with subsurfaces (see wayland_win_data_get_effective_parent), which use
+         * coordinates relative to their parent surface. */
+        if (!NtUserGetWindowRect(data->hwnd, &screen_rect))
+            SetRectEmpty(&screen_rect);
+        if (!NtUserGetWindowRect(data->effective_parent, &parent_screen_rect))
+            SetRectEmpty(&parent_screen_rect);
+
+        wayland_surface_reconfigure_position(
+            wsurface,
+            screen_rect.left - parent_screen_rect.left,
+            screen_rect.top - parent_screen_rect.top);
+    }
+    else if (wsurface->xdg_surface)
+    {
+        RECT compat;
+        wayland_win_data_get_compatible_rect(data, &compat);
+        wayland_surface_reconfigure_geometry(wsurface, compat.left, compat.top,
+                                             compat.right - compat.left,
+                                             compat.bottom - compat.top);
+    }
+
+    /* The GL/VK subsurface (if any), is positioned over the client area of the
+     * window. The position of the GL/VK subsurface is relative to the window
+     * top-left. */
+    wayland_surface_reconfigure_glvk(wsurface,
+                                     data->client_rect.left - data->window_rect.left,
+                                     data->client_rect.top - data->window_rect.top,
+                                     data->client_rect.right - data->client_rect.left,
+                                     data->client_rect.bottom - data->client_rect.top);
+
+    wayland_surface_reconfigure_apply(data->wayland_surface);
+
+    if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
+        wsurface->drawing_allowed = TRUE;
+
+    wayland_mutex_unlock(&wsurface->mutex);
+
+    wayland_surface_update_pointer_constraint(wsurface);
+}
+
+static BOOL wayland_win_data_is_fullscreen_with_overshoot(struct wayland_win_data *data)
+{
+    RECT monitor_rect;
+    struct wayland_output *output;
+
+    if (!data->fullscreen) return FALSE;
+    if (!data->wayland_surface) return FALSE;
+
+    output = data->wayland_surface->main_output;
+    if (!output || !output->current_wine_mode) return FALSE;
+
+    SetRect(&monitor_rect, output->x, output->y,
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
+
+    return data->window_rect.left < monitor_rect.left &&
+           data->window_rect.top < monitor_rect.top &&
+           data->window_rect.right >= monitor_rect.right &&
+           data->window_rect.bottom >= monitor_rect.bottom;
+}
+
+static struct wayland_win_data *update_wayland_state(struct wayland_win_data *data)
+{
+    HWND hwnd = data->hwnd;
+
+    /* Ensure we have a thread wayland instance. Perform the initialization
+     * outside the win_data lock to avoid potential deadlocks. */
+    if (!thread_wayland())
+    {
+        wayland_win_data_release(data);
+        thread_init_wayland();
+        data = wayland_win_data_get(hwnd);
+        if (!data) return NULL;
+    }
+
+    if (data->has_pending_window_surface)
+    {
+        if (data->window_surface)
+        {
+            if (data->window_surface != data->pending_window_surface)
+                wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+            window_surface_release(data->window_surface);
+        }
+        data->window_surface = data->pending_window_surface;
+        data->has_pending_window_surface = FALSE;
+        data->pending_window_surface = NULL;
+    }
+
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+
+    if (data->wayland_surface)
+        wayland_win_data_update_wayland_surface_state(data);
+
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+        if (wayland_window_surface_needs_flush(data->window_surface))
+            wayland_window_surface_flush(data->window_surface);
+    }
+
+    if (data->wayland_surface && data->wayland_surface->xdg_toplevel &&
+        data->wayland_surface->main_output)
+    {
+        struct wayland_output *output = data->wayland_surface->main_output;
+        /* We increase the serial even if we don't end up posting
+         * WM_WAYLAND_SURFACE_OUTPUT_CHANGE, to ensure all previous pending
+         * requests are invalidated. */
+        data->pending_surface_output_change_serial++;
+        /* Skip zero if we wrap around, since it has a special meaning. */
+        if (data->pending_surface_output_change_serial == 0)
+            data->pending_surface_output_change_serial++;
+
+        /* To maintain some degree of consistency between the Wayland surface and
+         * Windows window positioning, place top-level windows on the output
+         * dictated by the compositor. We position the window at the origin of that
+         * output to maximize the window area that is accessible by mouse events.
+         * We perform the move if the window:
+         * 1. is not already at origin, and
+         * 2. is not minimized
+         * 3. is not fullscreen */
+        if ((data->window_rect.left != output->x || data->window_rect.top != output->y) &&
+            !(NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_MINIMIZE) &&
+            !data->fullscreen)
+        {
+            TRACE("hwnd=%p window_rect=%s not at origin %dx%d, scheduling move\n",
+                  data->hwnd, wine_dbgstr_rect(&data->window_rect),
+                  output->x, output->y);
+            NtUserPostMessage(hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+                              data->pending_surface_output_change_serial, 0);
+        }
+    }
+
+    return data;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateWindow
+ */
+BOOL WAYLAND_CreateWindow(HWND hwnd)
+{
+    TRACE("%p\n", hwnd);
+
+    if (hwnd == NtUserGetDesktopWindow())
+    {
+        /* Initialize wayland so that the desktop process has access
+         * to all the wayland related information (e.g., displays). */
+        wayland_init_thread_data();
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLAND_DestroyWindow
+ */
+void WAYLAND_DestroyWindow(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    TRACE("%p\n", hwnd);
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_destroy_gl_drawable(hwnd);
+    wayland_invalidate_vulkan_objects(hwnd);
+    wayland_destroy_remote_surfaces(hwnd);
+    wayland_win_data_destroy(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanging
+ */
+BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                               const RECT *window_rect, const RECT *client_rect,
+                               RECT *visible_rect, struct window_surface **surface)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    BOOL exstyle = NtUserGetWindowLongW(hwnd, GWL_EXSTYLE);
+    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
+    RECT surface_rect;
+    DWORD flags;
+    COLORREF color_key;
+    BYTE alpha;
+
+    TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), style, exstyle, swp_flags, insert_after);
+
+    if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
+
+    data->old_parent = data->parent;
+    data->old_window_rect = data->window_rect;
+    data->parent = (parent == NtUserGetDesktopWindow()) ? 0 : parent;
+    data->window_rect = *window_rect;
+    data->client_rect = *client_rect;
+    data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
+
+    /* Release the dummy surface wine provides for toplevels. */
+    if (*surface) window_surface_release(*surface);
+    *surface = NULL;
+
+    /* Check if we don't want a dedicated window surface. */
+    if (data->parent || (swp_flags & SWP_HIDEWINDOW) || !data->visible) goto done;
+
+    surface_rect = *window_rect;
+    OffsetRect(&surface_rect, -surface_rect.left, -surface_rect.top);
+
+    /* Check if we can reuse our current window surface. */
+    if (data->window_surface &&
+        EqualRect(&data->window_surface->rect, &surface_rect))
+    {
+        window_surface_add_ref(data->window_surface);
+        *surface = data->window_surface;
+        TRACE("reusing surface %p\n", *surface);
+        goto done;
+    }
+
+    /* Create new window surface. */
+    color_key = alpha = flags = 0;
+    if (!(exstyle & WS_EX_LAYERED) ||
+        !NtUserGetLayeredWindowAttributes(hwnd, &color_key, &alpha, &flags))
+    {
+        flags = 0;
+    }
+    if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
+
+done:
+    wayland_win_data_release(data);
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), NtUserGetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    if (surface) window_surface_add_ref(surface);
+    if (data->has_pending_window_surface && data->pending_window_surface)
+        window_surface_release(data->pending_window_surface);
+    data->pending_window_surface = surface;
+    data->has_pending_window_surface = TRUE;
+
+    /* In some cases, notably when the app calls UpdateLayeredWindow, position
+     * and size changes may be emitted from a thread other than the window
+     * thread. Since in the current implementation updating the wayland state
+     * needs to happen in the context of the window thread to avoid racy
+     * interactions, post a message to update the state in the right thread. */
+    if (GetCurrentThreadId() == NtUserGetWindowThread(hwnd, NULL))
+    {
+        data = update_wayland_state(data);
+    }
+    else if (!data->pending_state_update_message)
+    {
+        NtUserPostMessage(hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+        data->pending_state_update_message = TRUE;
+    }
+
+    wayland_win_data_release(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_ShowWindow
+ */
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+{
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p cmd=%d\n", hwnd, cmd);
+
+    if (IsRectEmpty(rect)) return swp;
+    if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE)) return swp;
+    /* always hide icons off-screen */
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect(rect, -32000 - rect->left, -32000 - rect->top);
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+
+    if ((wsurface = wayland_surface_for_hwnd_lock(hwnd)) && wsurface->xdg_toplevel)
+        xdg_toplevel_set_minimized(wsurface->xdg_toplevel);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+
+    return swp;
+}
+
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
+/***********************************************************************
+ *           WAYLAND_SetWindowStyle
+ */
+void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
+{
+    struct wayland_win_data *data;
+    DWORD changed = style->styleNew ^ style->styleOld;
+
+    TRACE("hwnd=%p offset=%d changed=%#x\n", hwnd, offset, changed);
+
+    if (hwnd == NtUserGetDesktopWindow()) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED))
+    {
+        TRACE("hwnd=%p changed layered\n", hwnd);
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
+    }
+
+    wayland_win_data_release(data);
+}
+
+/*****************************************************************
+ *		WAYLAND_SetWindowText
+ */
+void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
+{
+    struct wayland_surface *wsurface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p text=%s\n", hwnd, wine_dbgstr_w(text));
+
+    if (wsurface && wsurface->xdg_toplevel)
+        wayland_surface_set_title(wsurface, text);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
+/***********************************************************************
+ *	     WAYLAND_SetLayeredWindowAttributes
+ */
+void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if (!(flags & LWA_COLORKEY)) key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
+        wayland_win_data_release(data);
+    }
+}
+
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect)
+{
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, info->crKey, wine_dbgstr_rect(info->prcDirty), info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = NtGdiCreateDIBSection(info->hdcDst, NULL, 0, bmi, DIB_RGB_COLORS, 0, 0, 0, &src_bits))) goto done;
+    if (!(hdc = NtGdiCreateCompatibleDC(0))) goto done;
+
+    NtGdiSelectBitmap(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        intersect_rect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        NtGdiPatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    NtGdiTransformPoints(info->hdcSrc, (POINT *)&src_rect, (POINT *)&src_rect, 2, NtGdiDPtoLP);
+
+    ret = NtGdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                          info->hdcSrc, src_rect.left, src_rect.top,
+                          src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                          (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend, 0);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        union_rect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) NtGdiDeleteObjectApp(hdc);
+    if (dib) NtGdiDeleteObjectApp(dib);
+    return ret;
+}
+
+static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
+{
+    switch (hittest) {
+    case WMSZ_LEFT:        return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
+    case WMSZ_RIGHT:       return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
+    case WMSZ_TOP:         return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
+    case WMSZ_TOPLEFT:     return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
+    case WMSZ_TOPRIGHT:    return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
+    case WMSZ_BOTTOM:      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
+    case WMSZ_BOTTOMLEFT:  return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
+    case WMSZ_BOTTOMRIGHT: return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
+    default:               return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
+    }
+}
+
+/***********************************************************************
+ *          WAYLAND_SysCommand
+ */
+LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
+{
+    LRESULT ret = -1;
+    WPARAM command = wparam & 0xfff0;
+    WPARAM hittest = wparam & 0x0f;
+    struct wayland_surface *wsurface;
+
+    TRACE("cmd=%lx hwnd=%p, %x, %lx,\n", command, hwnd, (unsigned)wparam, lparam);
+
+    if (!(wsurface = wayland_surface_for_hwnd_lock(hwnd)) || !wsurface->xdg_toplevel)
+        goto done;
+
+    if (command == SC_SIZE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_resize(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                                wsurface->wayland->last_button_serial,
+                                hittest_to_resize_edge(hittest));
+        }
+        ret = 0;
+    }
+    else if (command == SC_MOVE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_move(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                              wsurface->wayland->last_button_serial);
+        }
+        ret = 0;
+    }
+
+done:
+    wayland_surface_for_hwnd_unlock(wsurface);
+    return ret;
+}
+
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+    struct wayland_surface *surface, *tmp;
+
+    wayland_update_outputs_from_process(wayland);
+
+    /* Update the state of all surfaces tracked by the wayland thread instance,
+     * in case any surface was affected by the monitor changes (e.g., gained or
+     * lost the fullscreen state). We use the safe iteration variant since a
+     * state update may cause the surface to be recreated. */
+    wl_list_for_each_safe(surface, tmp, &wayland->toplevel_list, link)
+    {
+        struct wayland_win_data *data = wayland_win_data_get(surface->hwnd);
+        if (data)
+        {
+            update_wayland_state(data);
+            wayland_win_data_release(data);
+        }
+    }
+}
+
+static LRESULT handle_wm_wayland_configure(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+    DWORD flags;
+    int width, height, wine_width, wine_height;
+    UINT swp_flags;
+    BOOL needs_enter_size_move = FALSE;
+    BOOL needs_exit_size_move = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return 0;
+    if (!data->wayland_surface || !data->wayland_surface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface = data->wayland_surface;
+
+    TRACE("serial=%d size=%dx%d flags=%#x restore_rect=%s\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          wine_dbgstr_rect(&data->restore_rect));
+
+    if (wsurface->pending.serial == 0)
+    {
+        TRACE("pending configure event already handled, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface->pending.processed = TRUE;
+
+    data->wayland_configure_event_flags = wsurface->pending.configure_flags;
+
+    width = wsurface->pending.width;
+    height = wsurface->pending.height;
+    flags = wsurface->pending.configure_flags;
+
+    /* If we are free to set our size, first try the restore size, then
+     * the current size. */
+    if (width == 0)
+    {
+        int ignore;
+        if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE))
+            width = data->restore_rect.right - data->restore_rect.left;
+        if (width == 0)
+            width = data->window_rect.right - data->window_rect.left;
+        wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
+                                                 &width, &ignore);
+        wsurface->pending.width = width;
+    }
+    if (height == 0)
+    {
+        int ignore;
+        if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE))
+            height = data->restore_rect.bottom - data->restore_rect.top;
+        if (height == 0)
+            height = data->window_rect.bottom - data->window_rect.top;
+        wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
+                                                 &ignore, &height);
+        wsurface->pending.height = height;
+    }
+
+    if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        wayland_win_data_is_fullscreen_with_overshoot(data))
+    {
+        /* If the window is fullscreen while overshooting the monitor bounds
+         * don't try to resize it. Forcing the Wayland preferred size in such
+         * cases may trigger an endless loop of resizes while both the
+         * compositor and the app try to enforce different window sizes. */
+        wine_width = 0;
+        wine_height = 0;
+    }
+    else if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+             !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_find_wine_fullscreen_fit(wsurface, width, height,
+                                                 &wine_width, &wine_height);
+    }
+    else
+    {
+        wayland_surface_coords_to_wine(wsurface, width, height,
+                                       &wine_width, &wine_height);
+    }
+
+    TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
+          data->hwnd, width, height, wine_width, wine_height);
+
+    if ((flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && !data->resizing)
+    {
+        data->resizing = TRUE;
+        needs_enter_size_move = TRUE;
+    }
+
+    if (!(flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && data->resizing)
+    {
+        data->resizing = FALSE;
+        needs_exit_size_move = TRUE;
+    }
+
+    wayland_win_data_release(data);
+
+    if (needs_enter_size_move)
+        send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+
+    if (needs_exit_size_move)
+        send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = TRUE;
+        wayland_win_data_release(data);
+    }
+
+    if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+    {
+        NtUserSetWindowLong(hwnd, GWL_STYLE,
+                            NtUserGetWindowLongW(hwnd, GWL_STYLE) | WS_MAXIMIZE,
+                            FALSE);
+    }
+    else
+    {
+        NtUserSetWindowLong(hwnd, GWL_STYLE,
+                            NtUserGetWindowLongW(hwnd, GWL_STYLE) & ~WS_MAXIMIZE,
+                            FALSE);
+    }
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE;
+
+    if (wine_width > 0 && wine_height > 0)
+        swp_flags |= SWP_FRAMECHANGED;
+    else
+        swp_flags |= SWP_NOSIZE | SWP_NOREDRAW;
+    /* When we are maximized or fullscreen, wayland is particular about the
+     * surface size it accepts, so don't allow the app to change it. */
+    if (flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+        swp_flags |= SWP_NOSENDCHANGING;
+
+    NtUserSetWindowPos(hwnd, 0, 0, 0, wine_width, wine_height, swp_flags);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = FALSE;
+        wayland_win_data_release(data);
+    }
+
+    return 0;
+}
+
+static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    TRACE("hwnd=%p\n", hwnd);
+    NtUserKillTimer(hwnd, timer_id);
+    handle_wm_wayland_configure(hwnd);
+}
+
+static void handle_wm_wayland_surface_output_change(HWND hwnd, UINT serial)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    data = wayland_win_data_get(hwnd);
+    if (serial == 0) serial = ++data->pending_surface_output_change_serial;
+    if (serial != data->pending_surface_output_change_serial)
+    {
+        TRACE("hwnd=%p output change request has superseded serial", hwnd);
+        goto out;
+
+    }
+    if (!data || !data->wayland_surface || !data->wayland_surface->xdg_surface)
+    {
+        TRACE("hwnd=%p has no suitable wayland surface\n", hwnd);
+        goto out;
+    }
+
+    wsurface = data->wayland_surface;
+
+    if (wsurface->main_output)
+    {
+        UINT swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER |
+                         SWP_FRAMECHANGED | SWP_NOSENDCHANGING | SWP_NOSIZE;
+        int x = wsurface->main_output->x;
+        int y = wsurface->main_output->y;
+
+        TRACE("moving window to %d,%d\n", x, y);
+
+        NtUserSetWindowPos(hwnd, 0, x, y, 0, 0, swp_flags);
+    }
+
+out:
+    wayland_win_data_release(data);
+}
+
+/**********************************************************************
+ *           WAYLAND_DesktopWindowProc
+ */
+LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_DISPLAYCHANGE:
+        {
+            RECT virtual_rect = NtUserGetVirtualScreenRect();
+            NtUserSetWindowPos(hwnd, 0, virtual_rect.left, virtual_rect.top,
+                               virtual_rect.right - virtual_rect.left,
+                               virtual_rect.bottom - virtual_rect.top,
+                               SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE);
+        }
+        break;
+    }
+
+    return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserDefWindowProc, FALSE);
+}
+
+/**********************************************************************
+ *           WAYLAND_WindowMessage
+ */
+LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    TRACE("msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
+
+    switch (msg)
+    {
+    case WM_WAYLAND_MONITOR_CHANGE:
+        handle_wm_wayland_monitor_change(thread_wayland());
+        break;
+    case WM_WAYLAND_SET_CURSOR:
+        wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
+                                                 (HCURSOR)lp);
+        break;
+    case WM_WAYLAND_QUERY_SURFACE_MAPPED:
+        {
+            LRESULT res;
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            res = wayland_surface ? wayland_surface->mapped : 0;
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+            return res;
+        }
+        break;
+    case WM_WAYLAND_CONFIGURE:
+        /* While resizing, configure events can come continuously and due to the
+         * amount of other message their handling produces (e.g., paints), have
+         * the potential to keep the message loop busy for some time. This may
+         * lead Wine core to think that the app never goes idle (see
+         * win.c:flush_window_surfaces), and thus start flushing at unfortunate
+         * times (e.g., in between partial window paints), causing visual
+         * artifacts.
+         *
+         * To mitigate this we handle the configure message only if the message
+         * queue is empty, ensuring that the loop has had time to become idle.
+         * If the queue is not currently empty, we schedule a timer message,
+         * which due to having the lowest priority is guaranteed to be triggered
+         * only on otherwise empty queues.
+         */
+        if (!NtUserGetQueueStatus(QS_ALLINPUT))
+        {
+            return handle_wm_wayland_configure(hwnd);
+        }
+        else
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface && wayland_surface->xdg_toplevel)
+            {
+                NtUserSetTimer(hwnd, (UINT_PTR)wayland_surface->wl_surface, 10,
+                               post_configure, TIMERV_DEFAULT_COALESCING);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
+    case WM_WAYLAND_STATE_UPDATE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data)
+            {
+                data->pending_state_update_message = FALSE;
+                data = update_wayland_state(data);
+                wayland_win_data_release(data);
+            }
+        }
+        break;
+    case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
+        handle_wm_wayland_surface_output_change(hwnd, wp);
+        break;
+    case WM_WAYLAND_WINDOW_SURFACE_FLUSH:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data && data->window_surface)
+                wayland_window_surface_flush(data->window_surface);
+            wayland_win_data_release(data);
+        }
+        break;
+    case WM_WAYLAND_REMOTE_SURFACE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+                wayland_remote_surface_handle_message(wayland_surface, wp, lp);
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
+    case WM_WAYLAND_POINTER_CONSTRAINT_UPDATE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+            {
+                if (wp == WAYLAND_POINTER_CONSTRAINT_SYSTEM_CLIP)
+                {
+                    NtUserGetClipCursor(&wayland_surface->wayland->cursor_clip);
+                }
+                else if (wp == WAYLAND_POINTER_CONSTRAINT_UNSET_CLIP)
+                {
+                    SetRect(&wayland_surface->wayland->cursor_clip,
+                            INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+                }
+                else if (wp == WAYLAND_POINTER_CONSTRAINT_SET_CURSOR_POS)
+                {
+                    wayland_surface->set_cursor_pos = TRUE;
+                }
+                wayland_surface_update_pointer_constraint(wayland_surface);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
+    case WM_WAYLAND_CLIPBOARD_WINDOW_CREATE:
+        wayland_data_device_ensure_clipboard_window(thread_wayland());
+        break;
+    default:
+        FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *           wayland_get_client_rect_in_win_coords
+ */
+void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect)
+{
+    RECT window_rect;
+    POINT origin = {0, 0};
+
+    if (!NtUserClientToScreen(hwnd, &origin)) goto err;
+    if (!NtUserGetWindowRect(hwnd, &window_rect)) goto err;
+    if (!NtUserGetClientRect(hwnd, client_rect)) goto err;
+
+    OffsetRect(client_rect,
+               origin.x - window_rect.left,
+               origin.y - window_rect.top);
+
+    return;
+
+err:
+    ERR("Failed to get client rect for hwnd %p", hwnd);
+    SetRectEmpty(client_rect);
+}
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+
+        /* Trigger a redraw to apply any front buffer changes. */
+        NtUserPostMessage(hwnd, WM_WAYLAND_WINDOW_SURFACE_FLUSH, 0, 0);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
new file mode 100644
index 00000000000..a74a3f7151e
--- /dev/null
+++ b/dlls/winewayland.drv/window_surface.c
@@ -0,0 +1,691 @@
+/*
+ * Wayland window surface implementation
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include "ntgdi.h"
+#include "ntuser.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/* Change to 1 to dump flushed surface buffer contents to disk */
+#define DEBUG_DUMP_FLUSH_SURFACE_BUFFER 0
+
+/* Change to 1 to dump front buffer contents to disk when performing front
+ * buffer rendering. */
+#define DEBUG_DUMP_FRONT_BUFFER 0
+
+struct wayland_window_surface
+{
+    struct window_surface header;
+    HWND                  hwnd;
+    struct wayland_surface *wayland_surface; /* Not owned by us */
+    struct wayland_buffer_queue *wayland_buffer_queue;
+    RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
+    COLORREF              color_key;
+    BYTE                  alpha;
+    BOOL                  src_alpha;
+    void                 *bits;
+    struct wayland_mutex  mutex;
+    BOOL                  last_flush_failed;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
+    BITMAPINFO            info;
+};
+
+static struct wayland_window_surface *wayland_window_surface_cast(
+    struct window_surface *window_surface)
+{
+    return (struct wayland_window_surface *)window_surface;
+}
+
+static inline int get_dib_stride(int width, int bpp)
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size(const BITMAPINFO *info)
+{
+    return get_dib_stride(info->bmiHeader.biWidth, info->bmiHeader.biBitCount) *
+           abs(info->bmiHeader.biHeight);
+}
+
+static inline void reset_bounds(RECT *bounds)
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR) ||
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) NtGdiDeleteObjectApp(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue || !wws->wayland_surface) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region && NtUserGetWindowRgnEx(wws->hwnd, region, 0) == ERROR)
+        {
+            NtGdiDeleteObjectApp(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region) NtGdiCombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            NtGdiCombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = NtGdiCreateRectRgn(0, 0, 0, 0);
+            if (region) NtGdiCombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_lock
+ */
+static void wayland_window_surface_lock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    wayland_mutex_lock(&wws->mutex);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_unlock
+ */
+static void wayland_window_surface_unlock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    wayland_mutex_unlock(&wws->mutex);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bitmap_info
+ */
+static void *wayland_window_surface_get_bitmap_info(struct window_surface *window_surface,
+                                                    BITMAPINFO *info)
+{
+    struct wayland_window_surface *surface = wayland_window_surface_cast(window_surface);
+    /* We don't store any additional information at the end of our BITMAPINFO, so
+     * just copy the structure itself. */
+    memcpy(info, &surface->info, sizeof(*info));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bounds
+ */
+static RECT *wayland_window_surface_get_bounds(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return &wws->bounds;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_region
+ */
+static void wayland_window_surface_set_region(struct window_surface *window_surface,
+                                              HRGN region)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) NtGdiDeleteObjectApp(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        NtGdiCombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_flush
+ */
+void wayland_window_surface_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    struct wayland_shm_buffer *buffer;
+    RECT damage_rect;
+    BOOL needs_flush;
+    RGNDATA *buffer_damage;
+    HRGN surface_damage_region = NULL;
+    RECT *rgn_rect;
+    RECT *rgn_rect_end;
+
+    window_surface->funcs->lock(window_surface);
+
+    TRACE("hwnd=%p surface_rect=%s bounds=%s\n", wws->hwnd,
+          wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
+
+    needs_flush = intersect_rect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        RECT total_region_box;
+        surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
+                                                   damage_rect.right, damage_rect.bottom);
+        /* If the total_region is empty we are guaranteed to have empty SHM
+         * buffers. In order for this empty content to take effect, we still
+         * need to commit with non-empty damage, so don't AND with the
+         * total_region in this case, to ensure we don't end up with an empty
+         * surface_damage_region. */
+        if (wws->total_region &&
+            NtGdiGetRgnBox(wws->total_region, &total_region_box) != NULLREGION)
+        {
+            needs_flush = NtGdiCombineRgn(surface_damage_region, surface_damage_region,
+                                          wws->total_region, RGN_AND);
+        }
+    }
+
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * We also damage the whole surface if we just cleared the front buffer
+     * (i.e., front_bits == NULL and front_bits_dirty == TRUE). */
+    if (wws->front_bits || wws->front_bits_dirty)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                NtGdiSetRectRgn(surface_damage_region,
+                                wws->header.rect.left, wws->header.rect.top,
+                                wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = NtGdiCreateRectRgn(wws->header.rect.left,
+                                                           wws->header.rect.top,
+                                                           wws->header.rect.right,
+                                                           wws->header.rect.bottom);
+            }
+        }
+    }
+
+    if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
+    {
+        TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
+              wws->wayland_surface, wws->wayland_buffer_queue);
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+    wws->last_flush_failed = FALSE;
+
+    if (!needs_flush) goto done;
+
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
+          "alpha %02x src_alpha %d compression %d region %p\n",
+          wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
+          wws->bits, wws->color_key, wws->alpha, wws->src_alpha,
+          wws->info.bmiHeader.biCompression,
+          wws->total_region);
+
+    assert(wws->wayland_buffer_queue);
+
+    if (DEBUG_DUMP_FLUSH_SURFACE_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/flush-%.4d.pam", dbgid++, wws->bits,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    wws->wayland_buffer_queue->format == WL_SHM_FORMAT_ARGB8888,
+                    surface_damage_region, wws->total_region);
+    }
+
+    wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
+    buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
+    if (!buffer)
+    {
+        WARN("failed to acquire wayland buffer, returning\n");
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
+
+    /* Copy the whole front buffer to wayland SHM buffer. */
+    if (wws->front_bits)
+    {
+        int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+        int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+        int stride = width * 4;
+        unsigned char *src = wws->front_bits;
+        unsigned char *dst = buffer->map_data;
+        int src_stride = wws->info.bmiHeader.biWidth * 4;
+        int dst_stride = buffer->width * 4;
+        int i;
+
+        TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+        /* Front buffer lines are stored bottom to top, so we need to flip
+         * when copying to our buffer. */
+        for (i = 0; i < height; i++)
+        {
+            memcpy(dst + (height - i - 1) * dst_stride,
+                   src + i * src_stride,
+                   stride);
+        }
+    }
+
+    rgn_rect = (RECT *)buffer_damage->Buffer;
+    rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
+
+    /* Flush damaged buffer region from window_surface bitmap to wayland SHM buffer. */
+    for (;rgn_rect < rgn_rect_end; rgn_rect++)
+    {
+        unsigned int *src, *dst;
+        int x, y, width, height;
+        BOOL apply_surface_alpha;
+
+        TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
+
+        if (IsRectEmpty(rgn_rect))
+            continue;
+
+        src = (unsigned int *)wws->bits +
+              rgn_rect->top * wws->info.bmiHeader.biWidth +
+              rgn_rect->left;
+        dst = (unsigned int *)((unsigned char *)buffer->map_data +
+              rgn_rect->top * buffer->stride +
+              rgn_rect->left * 4);
+        width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
+        height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
+
+        /* If we have an ARGB buffer we need to explicitly apply the surface
+         * alpha to ensure the destination has sensible alpha values. The
+         * exception is when the surface uses source alpha values and the
+         * surface alpha is 255, in which case we can just copy pixel values
+         * as they are. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                              (wws->alpha != 255 || !wws->src_alpha);
+
+        /* Fast path for full width rectangles. */
+        if (width == buffer->width && !apply_surface_alpha &&
+            wws->color_key == CLR_INVALID)
+        {
+            memcpy(dst, src, height * buffer->stride);
+            continue;
+        }
+
+        for (y = 0; y < height; y++)
+        {
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else if (wws->alpha == 255 && !wws->src_alpha)
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
+            else if (!wws->src_alpha)
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((wws->alpha << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+
+            if (wws->color_key != CLR_INVALID)
+                for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
+
+            src += wws->info.bmiHeader.biWidth;
+            dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
+        }
+    }
+
+    if (!wayland_surface_commit_buffer(wws->wayland_surface, buffer,
+                                       surface_damage_region))
+    {
+        wws->last_flush_failed = TRUE;
+    }
+
+    wayland_shm_buffer_clear_damage(buffer);
+
+    free(buffer_damage);
+
+done:
+    if (!wws->last_flush_failed)
+    {
+        reset_bounds(&wws->bounds);
+        wws->front_bits_dirty = FALSE;
+    }
+    if (surface_damage_region) NtGdiDeleteObjectApp(surface_damage_region);
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_destroy
+ */
+static void wayland_window_surface_destroy(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("surface=%p\n", wws);
+
+    wayland_mutex_destroy(&wws->mutex);
+    if (wws->region) NtGdiDeleteObjectApp(wws->region);
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    if (wws->wayland_buffer_queue)
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+    free(wws->bits);
+    free(wws->front_bits);
+    free(wws);
+}
+
+static const struct window_surface_funcs wayland_window_surface_funcs =
+{
+    wayland_window_surface_lock,
+    wayland_window_surface_unlock,
+    wayland_window_surface_get_bitmap_info,
+    wayland_window_surface_get_bounds,
+    wayland_window_surface_set_region,
+    wayland_window_surface_flush,
+    wayland_window_surface_destroy
+};
+
+/***********************************************************************
+ *           wayland_window_surface_create
+ */
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
+{
+    struct wayland_window_surface *wws;
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+
+    TRACE("win %p rect %s\n", hwnd, wine_dbgstr_rect(rect));
+    wws = calloc(1, sizeof(*wws));
+    if (!wws) return NULL;
+    wws->info.bmiHeader.biSize = sizeof(wws->info.bmiHeader);
+    wws->info.bmiHeader.biClrUsed = 0;
+    wws->info.bmiHeader.biBitCount = 32;
+    wws->info.bmiHeader.biCompression = BI_RGB;
+    wws->info.bmiHeader.biWidth       = width;
+    wws->info.bmiHeader.biHeight      = -height; /* top-down */
+    wws->info.bmiHeader.biPlanes      = 1;
+    wws->info.bmiHeader.biSizeImage   = get_dib_image_size(&wws->info);
+
+    wayland_mutex_init(&wws->mutex, PTHREAD_MUTEX_RECURSIVE,
+                       __FILE__ ": wayland_window_surface");
+
+    wws->header.funcs = &wayland_window_surface_funcs;
+    wws->header.rect  = *rect;
+    wws->header.ref   = 1;
+    wws->hwnd         = hwnd;
+    wws->color_key    = color_key;
+    wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
+    reset_bounds(&wws->bounds);
+
+    if (!(wws->bits = malloc(wws->info.bmiHeader.biSizeImage)))
+        goto failed;
+
+    TRACE("created %p hwnd %p %s bits %p-%p compression %d\n", wws, hwnd, wine_dbgstr_rect(rect),
+           wws->bits, (char *)wws->bits + wws->info.bmiHeader.biSizeImage,
+           wws->info.bmiHeader.biCompression);
+
+    return &wws->header;
+
+failed:
+    wayland_window_surface_destroy(&wws->header);
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_needs_flush
+ */
+BOOL wayland_window_surface_needs_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return wws->last_flush_failed;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_wayland_surface
+ */
+void wayland_window_surface_update_wayland_surface(struct window_surface *window_surface,
+                                                   struct wayland_surface *wayland_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wayland_surface) wayland_surface_ref(wayland_surface);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    wws->wayland_surface = wayland_surface;
+
+    /* We only need a buffer queue if we have a surface to commit to. */
+    if (wws->wayland_surface && !wws->wayland_buffer_queue)
+    {
+        wws->wayland_buffer_queue =
+            wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    get_preferred_format(wws));
+    }
+    else if (!wws->wayland_surface)
+    {
+        if (wws->wayland_buffer_queue)
+        {
+            wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+            wws->wayland_buffer_queue = NULL;
+        }
+        free(wws->front_bits);
+        wws->front_bits = NULL;
+        wws->front_bits_dirty = FALSE;
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_layered
+ */
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
+        *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+
+    wws->alpha = alpha;
+    wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
+
+    if (wws->wayland_buffer_queue &&
+        wws->wayland_buffer_queue->format != get_preferred_format(wws))
+    {
+        recreate_wayland_buffer_queue(wws);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd=%p front_bits=%p read_pixels=%p size=%dx%d\n",
+          wws->hwnd, wws->front_bits, read_pixels,
+          wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        if (wws->front_bits)
+        {
+            free(wws->front_bits);
+            wws->front_bits = NULL;
+            /* When the front_bits are first invalidated, we mark them as dirty
+             * to force the next window_surface flush. */
+            wws->front_bits_dirty = TRUE;
+        }
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = malloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+    if (DEBUG_DUMP_FRONT_BUFFER && wws->front_bits)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/front-%.4d.pam", dbgid++,
+                    wws->front_bits, wws->info.bmiHeader.biWidth,
+                    abs(wws->info.bmiHeader.biHeight),
+                    FALSE, NULL, NULL);
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
new file mode 100644
index 00000000000..5f086f5c4e5
--- /dev/null
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -0,0 +1,2 @@
+# System tray
+@ cdecl wine_notify_icon(long ptr)
diff --git a/dlls/winewayland.drv/xkb_util.c b/dlls/winewayland.drv/xkb_util.c
new file mode 100644
index 00000000000..475af4b5bd6
--- /dev/null
+++ b/dlls/winewayland.drv/xkb_util.c
@@ -0,0 +1,80 @@
+/*
+ * XKB related utility functions
+ *
+ * Copyright 2021 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include <xkbcommon/xkbcommon.h>
+
+/**********************************************************************
+ *          _xkb_state_get_active_layout
+ *
+ * Gets the active layout of the xkb state.
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state)
+{
+    struct xkb_keymap *xkb_keymap = xkb_state_get_keymap(xkb_state);
+    xkb_layout_index_t num_layouts = xkb_keymap_num_layouts(xkb_keymap);
+    xkb_layout_index_t layout;
+
+    for (layout = 0; layout < num_layouts; layout++)
+    {
+        if (xkb_state_layout_index_is_active(xkb_state, layout,
+                                             XKB_STATE_LAYOUT_LOCKED))
+            return layout;
+    }
+
+    return XKB_LAYOUT_INVALID;
+}
+
+/**********************************************************************
+ *          _xkb_keysyms_to_utf8
+ *
+ * Get the null-terminated UTF-8 string representation of a sequence of
+ * keysyms. Returns the length of the UTF-8 string written, *not* including
+ * the null byte. If no bytes were produced or in case of error returns 0
+ * and produces a properly null-terminated empty string if possible.
+ */
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size)
+{
+    int i;
+    int utf8_len = 0;
+
+    if (utf8_size == 0) return 0;
+
+    for (i = 0; i < nsyms; i++)
+    {
+        int nwritten = xkb_keysym_to_utf8(syms[i], utf8 + utf8_len,
+                                          utf8_size - utf8_len);
+        if (nwritten <= 0)
+        {
+            utf8_len = 0;
+            break;
+        }
+
+        /* nwritten includes the terminating null byte */
+        utf8_len += nwritten - 1;
+    }
+
+    utf8[utf8_len] = '\0';
+
+    return utf8_len;
+}
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 101504a7887..08e57c4def0 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -683,28 +683,28 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
-    X11DRV_vkCreateInstance,
-    X11DRV_vkCreateSwapchainKHR,
-    X11DRV_vkCreateWin32SurfaceKHR,
-    X11DRV_vkDestroyInstance,
-    X11DRV_vkDestroySurfaceKHR,
-    X11DRV_vkDestroySwapchainKHR,
-    X11DRV_vkEnumerateInstanceExtensionProperties,
-    X11DRV_vkGetDeviceGroupSurfacePresentModesKHR,
-    X11DRV_vkGetDeviceProcAddr,
-    X11DRV_vkGetInstanceProcAddr,
-    X11DRV_vkGetPhysicalDevicePresentRectanglesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceFormatsKHR,
-    X11DRV_vkGetPhysicalDeviceSurfacePresentModesKHR,
-    X11DRV_vkGetPhysicalDeviceSurfaceSupportKHR,
-    X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
-    X11DRV_vkGetSwapchainImagesKHR,
-    X11DRV_vkQueuePresentKHR,
-
-    X11DRV_wine_get_native_surface,
+    .p_vkCreateInstance = X11DRV_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = X11DRV_vkCreateSwapchainKHR,
+    .p_vkCreateWin32SurfaceKHR = X11DRV_vkCreateWin32SurfaceKHR,
+    .p_vkDestroyInstance = X11DRV_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = X11DRV_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = X11DRV_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = X11DRV_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = X11DRV_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = X11DRV_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = X11DRV_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = X11DRV_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = X11DRV_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = X11DRV_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = X11DRV_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = X11DRV_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = X11DRV_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = X11DRV_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = X11DRV_vkGetSwapchainImagesKHR,
+    .p_vkQueuePresentKHR = X11DRV_vkQueuePresentKHR,
+
+    .p_wine_get_native_surface = X11DRV_wine_get_native_surface,
 };
 
 static void *X11DRV_get_vk_device_proc_addr(const char *name)
diff --git a/include/config.h.in b/include/config.h.in
index 694b11cf8c2..a36ec022477 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -53,6 +53,9 @@
 /* Define to 1 if you have the `dlinfo' function. */
 #undef HAVE_DLINFO
 
+/* Define to 1 if you have the <drm.h> header file. */
+#undef HAVE_DRM_H
+
 /* Define to 1 if you have the <EGL/egl.h> header file. */
 #undef HAVE_EGL_EGL_H
 
@@ -89,6 +92,13 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gbm.h> header file. */
+#undef HAVE_GBM_H
+
+/* Define to 1 if you have the `gbm_surface_create_with_modifiers2' function.
+   */
+#undef HAVE_GBM_SURFACE_CREATE_WITH_MODIFIERS2
+
 /* Define to 1 if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
@@ -703,6 +713,12 @@
 /* Define to 1 if you have the <valgrind/valgrind.h> header file. */
 #undef HAVE_VALGRIND_VALGRIND_H
 
+/* Define to 1 if you have the <wayland-client.h> header file. */
+#undef HAVE_WAYLAND_CLIENT_H
+
+/* Define to 1 if you have the <wayland-cursor.h> header file. */
+#undef HAVE_WAYLAND_CURSOR_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
@@ -757,6 +773,9 @@
 /* Define if you have the XKB extension */
 #undef HAVE_XKB
 
+/* Define to 1 if you have the <xkbcommon/xkbcommon.h> header file. */
+#undef HAVE_XKBCOMMON_XKBCOMMON_H
+
 /* Define if Xrender has the XRenderCreateLinearGradient function */
 #undef HAVE_XRENDERCREATELINEARGRADIENT
 
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 596d27156af..de48dfc2415 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -217,6 +217,7 @@ struct window_surface
     struct list                        entry; /* entry in global list managed by user32 */
     LONG                               ref;   /* reference count */
     RECT                               rect;  /* constant, no locking needed */
+    DWORD                              draw_start_ticks; /* start ticks of fresh draw */
     /* driver-specific fields here */
 };
 
diff --git a/include/wine/vulkan.h b/include/wine/vulkan.h
index 821c2d6a3fb..6bbe61b642d 100644
--- a/include/wine/vulkan.h
+++ b/include/wine/vulkan.h
@@ -150,10 +150,14 @@
 #define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
+#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
 #define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
+#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
 #define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
 #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
 #define VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION 2
@@ -194,6 +198,8 @@
 #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
 #define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
+#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
+#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
 #define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
 #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
 #define VK_KHR_MAINTENANCE2_SPEC_VERSION VK_KHR_MAINTENANCE_2_SPEC_VERSION
@@ -204,6 +210,8 @@
 #define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"
 #define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
 #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
+#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
+#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
 #define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
@@ -248,6 +256,8 @@
 #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
 #define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
 #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
+#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 2
+#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
 #define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
 #define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
 #define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
@@ -1830,6 +1840,7 @@ typedef enum VkExternalMemoryHandleTypeFlagBits
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
@@ -2415,6 +2426,10 @@ typedef enum VkImageAspectFlagBits
     VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
     VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
     VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
+    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
     VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
     VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
     VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
@@ -2529,6 +2544,7 @@ typedef enum VkImageTiling
 {
     VK_IMAGE_TILING_OPTIMAL = 0,
     VK_IMAGE_TILING_LINEAR = 1,
+    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
     VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
 } VkImageTiling;
 
@@ -3387,6 +3403,7 @@ typedef enum VkResult
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
     VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
     VK_ERROR_FRAGMENTATION = -1000161000,
+    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
     VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
     VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
     VK_ERROR_INVALID_SHADER_NV = -1000012000,
@@ -3799,9 +3816,14 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
     VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
     VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
+    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
+    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
+    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
     VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
     VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
+    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
+    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
@@ -3833,6 +3855,8 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
     VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
     VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
+    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
+    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
@@ -3909,6 +3933,12 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
     VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
     VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
+    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
+    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
+    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
+    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
     VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
     VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
@@ -5695,6 +5725,36 @@ typedef struct VkDrawMeshTasksIndirectCommandNV
     uint32_t firstTask;
 } VkDrawMeshTasksIndirectCommandNV;
 
+typedef struct VkDrmFormatModifierProperties2EXT
+{
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags2 drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierProperties2EXT;
+
+typedef struct VkDrmFormatModifierPropertiesEXT
+{
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
+} VkDrmFormatModifierPropertiesEXT;
+
+typedef struct VkDrmFormatModifierPropertiesList2EXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t drmFormatModifierCount;
+    VkDrmFormatModifierProperties2EXT *pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesList2EXT;
+
+typedef struct VkDrmFormatModifierPropertiesListEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t drmFormatModifierCount;
+    VkDrmFormatModifierPropertiesEXT *pDrmFormatModifierProperties;
+} VkDrmFormatModifierPropertiesListEXT;
+
 typedef struct VkEventCreateInfo
 {
     VkStructureType sType;
@@ -5805,6 +5865,14 @@ typedef struct VkFenceCreateInfo
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo;
 
+typedef struct VkFenceGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence WINE_VK_ALIGN(8) fence;
+    VkExternalFenceHandleTypeFlagBits handleType;
+} VkFenceGetFdInfoKHR;
+
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
 {
     VkStructureType sType;
@@ -5972,6 +6040,21 @@ typedef struct VkImageCreateInfo
     VkImageLayout initialLayout;
 } VkImageCreateInfo;
 
+typedef struct VkImageDrmFormatModifierListCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint32_t drmFormatModifierCount;
+    const uint64_t *pDrmFormatModifiers;
+} VkImageDrmFormatModifierListCreateInfoEXT;
+
+typedef struct VkImageDrmFormatModifierPropertiesEXT
+{
+    VkStructureType sType;
+    void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+} VkImageDrmFormatModifierPropertiesEXT;
+
 typedef struct VkImageFormatListCreateInfo
 {
     VkStructureType sType;
@@ -6119,6 +6202,24 @@ typedef struct VkImageViewUsageCreateInfo
 } VkImageViewUsageCreateInfo;
 typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;
 
+typedef struct VkImportFenceFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkFence WINE_VK_ALIGN(8) fence;
+    VkFenceImportFlags flags;
+    VkExternalFenceHandleTypeFlagBits handleType;
+    int fd;
+} VkImportFenceFdInfoKHR;
+
+typedef struct VkImportMemoryFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+} VkImportMemoryFdInfoKHR;
+
 typedef struct VkImportMemoryHostPointerInfoEXT
 {
     VkStructureType sType;
@@ -6136,6 +6237,16 @@ typedef struct VkImportMemoryWin32HandleInfoKHR
     LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR;
 
+typedef struct VkImportSemaphoreFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore WINE_VK_ALIGN(8) semaphore;
+    VkSemaphoreImportFlags flags;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+    int fd;
+} VkImportSemaphoreFdInfoKHR;
+
 typedef struct VkIndirectCommandsLayoutTokenNV
 {
     VkStructureType sType;
@@ -6259,6 +6370,21 @@ typedef struct VkMemoryDedicatedRequirements
 } VkMemoryDedicatedRequirements;
 typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;
 
+typedef struct VkMemoryFdPropertiesKHR
+{
+    VkStructureType sType;
+    void *pNext;
+    uint32_t memoryTypeBits;
+} VkMemoryFdPropertiesKHR;
+
+typedef struct VkMemoryGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkDeviceMemory WINE_VK_ALIGN(8) memory;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+} VkMemoryGetFdInfoKHR;
+
 typedef struct VkMemoryGetWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -7322,6 +7448,16 @@ typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
     VkBool32 imageCompressionControlSwapchain;
 } VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
 
+typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    VkSharingMode sharingMode;
+    uint32_t queueFamilyIndexCount;
+    const uint32_t *pQueueFamilyIndices;
+} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
+
 typedef struct VkPhysicalDeviceImageFormatInfo2
 {
     VkStructureType sType;
@@ -9594,6 +9730,14 @@ typedef struct VkSemaphoreCreateInfo
     VkSemaphoreCreateFlags flags;
 } VkSemaphoreCreateInfo;
 
+typedef struct VkSemaphoreGetFdInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkSemaphore WINE_VK_ALIGN(8) semaphore;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+} VkSemaphoreGetFdInfoKHR;
+
 typedef struct VkSemaphoreSignalInfo
 {
     VkStructureType sType;
@@ -10577,6 +10721,15 @@ typedef struct VkImageCopy2
 } VkImageCopy2;
 typedef VkImageCopy2 VkImageCopy2KHR;
 
+typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT
+{
+    VkStructureType sType;
+    const void *pNext;
+    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
+    uint32_t drmFormatModifierPlaneCount;
+    const VkSubresourceLayout *pPlaneLayouts;
+} VkImageDrmFormatModifierExplicitCreateInfoEXT;
+
 typedef struct VkImageMemoryBarrier
 {
     VkStructureType sType;
@@ -11546,9 +11699,11 @@ typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue2)(VkDevice, const VkDeviceQueueInf
 typedef VkResult (VKAPI_PTR *PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)(VkDevice, VkRenderPass, VkExtent2D *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice, const VkRenderingInfo *, VkTilePropertiesQCOM *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice, VkEvent);
+typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice, VkFence);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV *, VkMemoryRequirements2 *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice, VkImage, VkMemoryRequirements *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
@@ -11560,6 +11715,8 @@ typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout2EXT)(VkDevice, VkImage,
 typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewAddressNVX)(VkDevice, VkImageView, VkImageViewAddressPropertiesNVX *);
 typedef uint32_t (VKAPI_PTR *PFN_vkGetImageViewHandleNVX)(VkDevice, const VkImageViewHandleInfoNVX *);
 typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance, const char *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice, const VkMemoryGetFdInfoKHR *, int *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, int, VkMemoryFdPropertiesKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryHostPointerPropertiesEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice, const VkMemoryGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, VkMemoryWin32HandlePropertiesKHR *);
@@ -11626,11 +11783,14 @@ typedef VkDeviceSize (VKAPI_PTR *PFN_vkGetRayTracingShaderGroupStackSizeKHR)(VkD
 typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice, VkRenderPass, VkExtent2D *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice, VkSemaphore, uint64_t *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice, VkSemaphore, uint64_t *);
+typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice, const VkSemaphoreGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, size_t *, void *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice, const VkShaderModuleCreateInfo *, VkShaderModuleIdentifierEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleIdentifierEXT)(VkDevice, VkShaderModule, VkShaderModuleIdentifierEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
+typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR *);
+typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
 typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice, uint32_t, const VkMappedMemoryRange *);
 typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, void **);
@@ -12064,9 +12224,11 @@ void VKAPI_CALL vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQu
 VkResult VKAPI_CALL vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize);
 VkResult VKAPI_CALL vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties);
 VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event);
+VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence);
 VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
+VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties);
 void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
@@ -12078,6 +12240,8 @@ void VKAPI_CALL vkGetImageSubresourceLayout2EXT(VkDevice device, VkImage image,
 VkResult VKAPI_CALL vkGetImageViewAddressNVX(VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX *pProperties);
 uint32_t VKAPI_CALL vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo);
 PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(VkInstance instance, const char *pName);
+VkResult VKAPI_CALL vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd);
+VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties);
 VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties);
 VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties);
@@ -12144,11 +12308,14 @@ VkDeviceSize VKAPI_CALL vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device,
 void VKAPI_CALL vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
+VkResult VKAPI_CALL vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo);
 void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier);
 void VKAPI_CALL vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier);
 VkResult VKAPI_CALL vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages);
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
+VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo);
+VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo);
 VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo);
 VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges);
 VkResult VKAPI_CALL vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData);
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index f5269d554fb..99d301061aa 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,9 +21,12 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
+    VkResult (*p_vkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
+    void (*p_vkDestroyDevice)(VkDevice, const VkAllocationCallbacks *);
     void (*p_vkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
     void (*p_vkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
     void (*p_vkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
@@ -55,8 +58,12 @@ static inline void *get_vulkan_driver_device_proc_addr(
 
     name += 2;
 
+    if (!strcmp(name, "AcquireNextImageKHR"))
+        return vulkan_funcs->p_vkAcquireNextImageKHR;
     if (!strcmp(name, "CreateSwapchainKHR"))
         return vulkan_funcs->p_vkCreateSwapchainKHR;
+    if (!strcmp(name, "DestroyDevice"))
+        return vulkan_funcs->p_vkDestroyDevice;
     if (!strcmp(name, "DestroySwapchainKHR"))
         return vulkan_funcs->p_vkDestroySwapchainKHR;
     if (!strcmp(name, "GetDeviceGroupSurfacePresentModesKHR"))
@@ -85,6 +92,8 @@ static inline void *get_vulkan_driver_instance_proc_addr(
 
     if (!instance) return NULL;
 
+    if (!strcmp(name, "CreateDevice"))
+        return vulkan_funcs->p_vkCreateDevice;
     if (!strcmp(name, "CreateWin32SurfaceKHR"))
         return vulkan_funcs->p_vkCreateWin32SurfaceKHR;
     if (!strcmp(name, "DestroyInstance"))
diff --git a/include/winuser.h b/include/winuser.h
index 2f4afffb8a3..247357dcef6 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4764,6 +4764,9 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+WINUSERAPI LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                               UINT msg, WPARAM wparam, LPARAM lparam,
+                                                               UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 
 /* Uxtheme hook functions and struct */
 
diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 96673adc254..afa711a8dbf 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -40,7 +40,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(explorer);
 #define DESKTOP_CLASS_ATOM ((LPCWSTR)MAKEINTATOM(32769))
 #define DESKTOP_ALL_ACCESS 0x01ff
 
-static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',0};
+static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',',','w','a','y','l','a','n','d',0};
 
 static BOOL using_root;
 
diff --git a/tools/makedep.c b/tools/makedep.c
index ac2b7a19ff3..a4d18c8f9ff 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -160,6 +160,7 @@ static const char *icotool;
 static const char *msgfmt;
 static const char *ln_s;
 static const char *sed_cmd;
+static const char *wayland_scanner;
 /* per-architecture global variables */
 static const char *arch_dirs[MAX_ARCHS];
 static const char *arch_pe_dirs[MAX_ARCHS];
@@ -500,6 +501,15 @@ static char *replace_filename( const char *path, const char *name )
     return ret;
 }
 
+/*******************************************************************
+ *         get_filename
+ */
+static char *get_filename( const char *name )
+{
+    char *filename = strrchr( name, '/' );
+    if (!filename) return strdup( name );
+    return strdup( filename + 1 );
+}
 
 /*******************************************************************
  *         replace_substr
@@ -1448,6 +1458,9 @@ static struct file *open_include_file( const struct makefile *make, struct incl_
         if ((file = open_local_generated_file( make, pFile, ".ico", ".svg" ))) return file;
     }
 
+    /* TODO: check for corresponding wayland protocol .xml file */
+    if (strendswith( pFile->name, "-client-protocol.h" )) return NULL;
+
     /* check for extra targets */
     if (strarray_exists( &make->extra_targets, pFile->name ))
     {
@@ -1918,6 +1931,23 @@ static void add_generated_sources( struct makefile *make )
             strarray_addall_uniq( &make->extra_imports,
                                   get_expanded_file_local_var( make, obj, "IMPORTS" ));
         }
+        if (strendswith( source->name, ".xml" ))
+        {
+            char *filename = get_filename( source->name );
+            char *code_filename = replace_extension ( filename , ".xml", "-protocol.c" );
+            char *header_filename = replace_extension ( filename , ".xml", "-client-protocol.h" );
+
+            file = add_generated_source( make, code_filename, NULL, 0 );
+            file->file->flags |= FLAG_C_UNIX;
+            file->use_msvcrt = 0;
+            file = add_generated_source( make, header_filename, NULL, 0 );
+            file->file->flags |= FLAG_C_UNIX;
+            file->use_msvcrt = 0;
+
+            free( filename );
+            free( code_filename );
+            free( header_filename );
+        }
     }
     if (make->testdll)
     {
@@ -3113,6 +3143,15 @@ static void output_source_spec( struct makefile *make, struct incl_file *source,
     output( "\n" );
 }
 
+static void output_source_xml( struct makefile *make, struct incl_file *source, const char *obj )
+{
+    char *base = get_filename( obj );
+    output( "%s-protocol.c: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s private-code $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner );
+    output( "%s-client-protocol.h: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s client-header $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner);
+    free( base );
+}
 
 /*******************************************************************
  *         output_source_one_arch
@@ -3256,6 +3295,7 @@ static const struct
     { "in", output_source_in },
     { "x", output_source_x },
     { "spec", output_source_spec },
+    { "xml", output_source_xml },
     { NULL, output_source_default }
 };
 
@@ -4147,6 +4187,7 @@ static void output_silent_rules(void)
         "MSG",
         "SED",
         "TEST",
+        "WAYLAND_SCANNER",
         "WIDL",
         "WMC",
         "WRC"
@@ -4246,6 +4287,7 @@ static void load_sources( struct makefile *make )
         "IN_SRCS",
         "PO_SRCS",
         "MANPAGES",
+        "WAYLAND_PROTOCOL_SRCS",
         NULL
     };
     const char **var;
@@ -4504,6 +4546,7 @@ int main( int argc, char *argv[] )
     msgfmt             = get_expanded_make_variable( top_makefile, "MSGFMT" );
     sed_cmd            = get_expanded_make_variable( top_makefile, "SED_CMD" );
     ln_s               = get_expanded_make_variable( top_makefile, "LN_S" );
+    wayland_scanner    = get_expanded_make_variable( top_makefile, "WAYLAND_SCANNER" );
 
     if (root_src_dir && !strcmp( root_src_dir, "." )) root_src_dir = NULL;
     if (tools_dir && !strcmp( tools_dir, "." )) tools_dir = NULL;
